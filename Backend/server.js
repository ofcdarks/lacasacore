// --- IMPORTS ---
const express = require('express');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const sqlite = require('sqlite');
const sqlite3 = require('sqlite3');
const path = require('path');
const crypto = require('crypto');
const fs = require('fs'); // Importando o módulo File System
require('dotenv').config(); // Carrega as variáveis do ficheiro .env

// Usar @distube/ytdl-core diretamente do GitHub (master branch) - versão mais atualizada
const ytdl = require('@distube/ytdl-core');
console.log('[Sistema] Usando @distube/ytdl-core do GitHub (master branch) - versão mais recente');
const { YoutubeTranscript } = require('youtube-transcript');
const { fetch } = require('undici');
const { ImageFX, AspectRatio, Model, AccountError, ImageFXError } = require('./imagefx.js');
const { WhiskClient, WhiskError } = require('./whisk.js');
const ffmpeg = require('fluent-ffmpeg');
const ffmpegInstaller = require('@ffmpeg-installer/ffmpeg');
const ffprobeInstaller = require('@ffprobe-installer/ffprobe');
const { OpenAI } = require('openai');
const fse = require('fs-extra');
const axios = require('axios');
const { exec, execSync } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);
const ScriptOptimizer = require('./scriptOptimizer.js');
const AIScriptValidator = require('./aiScriptValidator.js');
const ViralFormulaReplicator = require('./viralFormulaReplicator.js');
const { GoogleGenAI } = require('@google/genai');
const formidable = require('formidable');
const Stripe = require('stripe');
const nodemailer = require('nodemailer');
const LAOZHANG_CHAT_ENDPOINT = process.env.LAOZHANG_CHAT_ENDPOINT || 'https://api.laozhang.ai/v1/chat/completions';
const puppeteer = require('puppeteer');

const PROVIDER_NAME_PATTERNS = [
    { pattern: /laozhang(\.ai)?/gi, replacement: 'provedor externo' },
    { pattern: /lao\s*zhang/gi, replacement: 'provedor externo' },
    { pattern: /voz\s*premium/gi, replacement: 'provedor externo' },
    { pattern: /voice\s*premium/gi, replacement: 'provedor externo' },
    { pattern: /genaipro/gi, replacement: 'provedor externo' }
];

const sanitizeUserFacingText = (text, fallback = 'Operação') => {
    if (!text || typeof text !== 'string') {
        return fallback;
    }
    let sanitized = text;
    for (const { pattern, replacement } of PROVIDER_NAME_PATTERNS) {
        sanitized = sanitized.replace(pattern, replacement);
    }
    sanitized = sanitized.replace(/\s{2,}/g, ' ').trim();''
    return sanitized || fallback;
};

// Configurar caminho do FFmpeg e FFprobe automaticamente
ffmpeg.setFfmpegPath(ffmpegInstaller.path);
ffmpeg.setFfprobePath(ffprobeInstaller.path);
console.log(`[Sistema] FFmpeg configurado: ${ffmpegInstaller.path}`);
console.log(`[Sistema] FFprobe configurado: ${ffprobeInstaller.path}`);

// --- CONFIGURAÇÃO ---
const app = express();
const PORT = process.env.PORT || 5001;
const JWT_SECRET = process.env.JWT_SECRET || 'seu-segredo-jwt-super-secreto-trocar-em-prod';

const ENCRYPTION_SECRET = process.env.ENCRYPTION_SECRET || 'abc123def456ghi789jkl012mno345pqr'; // 32 caracteres
const ALGORITHM = 'aes-256-cbc';

async function ensureAmbientationsTable() {
    await db.run(`CREATE TABLE IF NOT EXISTS niche_ambientations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        niche TEXT,
        theme_key TEXT,
        keywords TEXT,
        ambiente TEXT,
        elementos TEXT,
        acessorios TEXT,
        subject TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);
    await db.run(`CREATE INDEX IF NOT EXISTS idx_niche_ambientations_user ON niche_ambientations(user_id)`);
    await db.run(`CREATE INDEX IF NOT EXISTS idx_niche_ambientations_user_niche ON niche_ambientations(user_id, niche)`);
    try { await db.run('ALTER TABLE niche_ambientations ADD COLUMN acessorios TEXT'); } catch (e) {}
}

async function detectAmbientationFromTitle(userId, title, niche) {
    await ensureAmbientationsTable();
    const rows = await db.all('SELECT id, niche, theme_key, keywords, ambiente, elementos, acessorios, subject FROM niche_ambientations WHERE user_id = ? AND (niche IS NULL OR niche = ?)', [userId, niche || null]);
    if (!rows || rows.length === 0) return null;
    const lower = String(title || '').toLowerCase();
    let best = null;
    let bestScore = 0;
    for (const r of rows) {
        const kw = String(r.keywords || '').toLowerCase().split(/[,;\s]+/).filter(Boolean);
        if (kw.length === 0) continue;
        let score = 0;
        for (const k of kw) { if (k && lower.includes(k)) score++; }
        if (score > bestScore) { bestScore = score; best = r; }
    }
    return bestScore > 0 ? best : null;
}

async function saveAmbientationSnapshot(userId, niche, themeKey, title, ambienteArr, elementosArr, subject, acessorios) {
    await ensureAmbientationsTable();
    const kw = Array.from(new Set(String(title || '').toLowerCase().split(/[^a-záéíóúãõâêîôûç0-9]+/i).filter(w => w && w.length > 2))).slice(0, 10).join(',');
    try {
        await db.run(
            `INSERT INTO niche_ambientations (user_id, niche, theme_key, keywords, ambiente, elementos, acessorios, subject, updated_at)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
            [userId, niche || null, themeKey || null, kw, (ambienteArr || []).join(', '), (elementosArr || []).join(', '), acessorios || null, subject || null]
        );
    } catch (e) {
        await db.run(
            `INSERT INTO niche_ambientations (user_id, niche, theme_key, keywords, ambiente, elementos, subject, updated_at)
             VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
            [userId, niche || null, themeKey || null, kw, (ambienteArr || []).join(', '), (elementosArr || []).join(', '), subject || null]
        );
    }
}

async function seedDefaultAmbientations(userId) {
    await ensureAmbientationsTable();
    const seeds = [
        { theme_key: 'egito_antigo', keywords: 'egito,faraó,pirâmide,deserto,templo', subject: 'Egyptian pharaoh with nemes headdress and gold jewelry', acessorios: 'gold necklaces and ceremonial regalia', ambiente: 'pyramids and desert storms', elementos: 'hieroglyphs, torches, soldiers' },
        { theme_key: 'neandertais', keywords: 'neandertal,pré-história,extinção,idade da pedra', subject: 'rugged Neanderthal with thick brow ridges, deep-set eyes, and weathered skin', acessorios: 'primitive fur and animal hides, no metal or feathers', ambiente: 'icy mountains and burning forests during the Ice Age', elementos: 'tribes walking, volcanic ash, mammoth silhouettes, aurora borealis' },
        { theme_key: 'imperio_inca', keywords: 'inca,machu picchu,atahualpa,andes', subject: 'Inca leader with feathered headdress and ornate jewelry', ambiente: 'andes mountains, Inca temples, terraces', elementos: 'Machu Picchu, priests, offerings' },
        { theme_key: 'imperio_asteca', keywords: 'azteca,tenochtitlan,sacrifício,selva', subject: 'Aztec warrior with plumes and ritual paint', ambiente: 'jungle, Aztec pyramids, ritual smoke', elementos: 'temples, sculptures, sacrifices' },
        { theme_key: 'maias', keywords: 'maia,guatemala,calendário,glyphs', subject: 'Mayan king with ceremonial mask', ambiente: 'dense jungle, stone temples', elementos: 'calendars, glyphs, priests' },
        { theme_key: 'vikings', keywords: 'viking,noruega,invasão,mar', subject: 'Viking warrior with axe and thick beard', ambiente: 'stormy seas, burning ships, icy fjords', elementos: 'longships, shields, ravens' },
        { theme_key: 'grecia_antiga', keywords: 'grécia,atenas,olimpio,filósofo', subject: 'Greek general or philosopher', ambiente: 'doric temples, thundered hills', elementos: 'statues, palaces, columns' },
        { theme_key: 'roma_antiga', keywords: 'romanos,império,coliseu,roma', subject: 'Roman centurion', ambiente: 'Colosseum ruins, banners', elementos: 'gladius, shields, aqueducts' },
        { theme_key: 'medieval_cem_anos', keywords: 'medieval,cavaleiros,batalha,castelo', subject: 'Medieval knight', ambiente: 'burning castles, armored riders', elementos: 'lances, flags, catapults' },
        { theme_key: 'guerra_civil_americana', keywords: 'civil americana,gettysburg,union,confederado', subject: 'Civil War soldier', ambiente: 'battlefields, smoke and powder', elementos: 'flags, cannons, horses' },
        { theme_key: 'ww2', keywords: 'wwii,segunda guerra,d-day,nações', subject: 'WWII realistic soldier', ambiente: 'ruined city, tanks, rubble', elementos: 'planes, smoke, squads' },
        { theme_key: 'imperio_persa', keywords: 'persa,ciro,aquemênida,deserto', subject: 'Persian king with royal jewels', ambiente: 'deserts, luxurious palaces', elementos: 'arches, cavalry, banners' },
        { theme_key: 'china_imperial', keywords: 'china,dinastia,muralha,imperador', subject: 'Chinese emperor', ambiente: 'great wall, temples, mist', elementos: 'dragons, warriors, pagodas' },
        { theme_key: 'japao_samurai', keywords: 'samurai,bushido,edo,katana', subject: 'Samurai in armor', ambiente: 'mountains, sakura, mist', elementos: 'katanas, buddhist temples' },
        { theme_key: 'mesopotamia', keywords: 'mesopotâmia,babilônia,sumério,zigurates', subject: 'Sumerian/Babylonian king', ambiente: 'ziggurats, deserts, smoke', elementos: 'cuneiform tablets, deities' },
        { theme_key: 'nativos_america_norte', keywords: 'nativo,índios,tribo,tótens', subject: 'Native American chief', ambiente: 'forests, mountains, camps', elementos: 'totems, arrows, paintings' },
        { theme_key: 'descobrimento_conquista', keywords: 'descobrimento,columbus,navegador,astrolábio', subject: 'European navigator', ambiente: 'ships, storm, tropical coasts', elementos: 'maps, astrolabe' },
        { theme_key: 'revolucao_industrial', keywords: 'industrial,vapor,fábricas,engrenagens', subject: 'Worker/engineer', ambiente: 'factories, black smoke, machinery', elementos: 'gears, boilers' },
        { theme_key: 'renascimento_italiano', keywords: 'renascimento,florença,artista,filósofo', subject: 'Renaissance artist or philosopher', ambiente: 'Italian squares, artworks', elementos: 'paintings, statues' },
        { theme_key: 'antiguidade_classica_oriental', keywords: 'orientais,confucionismo,templos,desertos', subject: 'Eastern warrior or philosopher', ambiente: 'temples, deserts, sacred mountains', elementos: 'ancient swords, scrolls' },
    ];
    for (const s of seeds) {
        try {
            await db.run(
                `INSERT INTO niche_ambientations (user_id, niche, theme_key, keywords, ambiente, elementos, acessorios, subject, updated_at)
                 VALUES (?, NULL, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
                [userId, s.theme_key, s.keywords, s.ambiente, s.elementos, s.acessorios || null, s.subject]
            );
        } catch {
            await db.run(
                `INSERT INTO niche_ambientations (user_id, niche, theme_key, keywords, ambiente, elementos, subject, updated_at)
                 VALUES (?, NULL, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
                [userId, s.theme_key, s.keywords, s.ambiente, s.elementos, s.subject]
            );
        }
    }
}

// --- GLOBALS ---
let db;

// SSE clients para progresso em tempo real
const sseClients = new Map();

// Diretório temporário para arquivos de áudio
const TEMP_DIR = path.join(__dirname, 'temp_audio');
if (!fs.existsSync(TEMP_DIR)) {
    fs.mkdirSync(TEMP_DIR, { recursive: true });
}

// --- MIDDLEWARES ---
app.use(cors({
  origin: '*', // Allow any origin
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'], // Explicitly allow methods
  allowedHeaders: ['Content-Type', 'Authorization'] // Explicitly allow headers
}));
app.use(express.json({ limit: '50mb' }));

// Middleware de log para requisições (depois do express.json para ter acesso ao body)
app.use((req, res, next) => {
    if (req.path.includes('/forgot-password') || req.path.includes('/auth')) {
        console.log(`[HTTP] ${req.method} ${req.path} - ${new Date().toISOString()}`);
        if (req.body && Object.keys(req.body).length > 0) {
            const bodyCopy = { ...req.body };
            // Ocultar senhas nos logs
            if (bodyCopy.password) bodyCopy.password = '***';
            console.log(`[HTTP] Body recebido:`, bodyCopy);
        }
    }
    next();
});

// Aumentar timeout para requisições longas (transcrição pode demorar)
app.use((req, res, next) => {
    // Timeout de 15 minutos para requisições de transcrição
    if (req.path.includes('/transcript')) {
        req.setTimeout(15 * 60 * 1000); // 15 minutos
        res.setTimeout(15 * 60 * 1000);
    }
    next();
}); // Aumentar limite para suportar URLs de imagens grandes
app.use(express.urlencoded({ limit: '50mb', extended: true }));

// Desabilitar cache para arquivos HTML durante desenvolvimento
app.use(express.static(__dirname, {
    setHeaders: (res, path) => {
        if (path.endsWith('.html')) {
            res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, private');
            res.setHeader('Pragma', 'no-cache');
            res.setHeader('Expires', '0');
        }
    }
}));

// Middleware para garantir que todas as respostas sejam JSON válido
app.use((req, res, next) => {
    // Interceptar res.json para garantir formato válido
    const originalJson = res.json;
    res.json = function(data) {
        // Garantir que sempre retorna JSON válido
        if (typeof data === 'string') {
            try {
                data = JSON.parse(data);
            } catch {
                data = { msg: data };
            }
        }
        res.setHeader('Content-Type', 'application/json');
        return originalJson.call(this, data);
    };
    next();
});

// Middleware de tratamento de erros para garantir que sempre retorne JSON
app.use((err, req, res, next) => {
    console.error('Erro no middleware:', err);
    if (!res.headersSent) {
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});

// Rota para redirecionar o acesso direto ao arquivo de autenticação
app.get('/la-casa-dark-core-auth.html', (req, res) => {
    res.redirect('/');
});

// Rota principal para servir a página de autenticação
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'la-casa-dark-core-auth.html'));
});

// Páginas legais (domínio principal)
app.get('/politica-de-privacidade', (req, res) => {
    res.sendFile(path.join(__dirname, 'privacy.html'));
});

app.get('/termos-de-uso', (req, res) => {
    res.sendFile(path.join(__dirname, 'terms.html'));
});

// Rota para service worker (deve ser servido com tipo MIME correto)
app.get('/sw.js', (req, res) => {
    res.setHeader('Content-Type', 'application/javascript');
    res.sendFile(path.join(__dirname, 'sw.js'));
});

// Rota para manifest.json
app.get('/manifest.json', (req, res) => {
    res.setHeader('Content-Type', 'application/manifest+json');
    res.sendFile(path.join(__dirname, 'manifest.json'));
});


// --- FUNÇÕES AUXILIARES DE ENCRIPTAÇÃO ---
function encrypt(text) {
    if (!ENCRYPTION_SECRET || ENCRYPTION_SECRET.length !== 32) {
        console.error("ENCRYPTION_SECRET inválida. Deve ter 32 caracteres.");
        throw new Error("Configuração de encriptação inválida.");
    }
    const iv = crypto.randomBytes(16); // Gera um novo IV para cada encriptação
    const cipher = crypto.createCipheriv(ALGORITHM, Buffer.from(ENCRYPTION_SECRET), iv);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return `${iv.toString('hex')}:${encrypted}`;
}

function decrypt(hash) {
    if (!ENCRYPTION_SECRET || ENCRYPTION_SECRET.length !== 32) {
        console.error("ENCRYPTION_SECRET inválida. Deve ter 32 caracteres.");
        throw new Error("Configuração de encriptação inválida.");
    }
    if (!hash || typeof hash !== 'string') {
        console.error("Hash inválido para descriptografia");
        return null;
    }
    try {
        // Verificar se é formato antigo (sem IV) ou novo (com IV:encrypted)
        const parts = hash.split(':');
        
        // Se não tem ':', pode ser formato antigo - tentar descriptografar diretamente
        if (parts.length === 1) {
            console.warn("Formato antigo de hash detectado, tentando descriptografar sem IV...");
            // Para formato antigo, usar um IV fixo (não seguro, mas compatível)
            const fixedIV = Buffer.alloc(16, 0); // IV zero para compatibilidade
            try {
                const encryptedBuffer = Buffer.from(hash, 'hex');
                const decipher = crypto.createDecipheriv(ALGORITHM, Buffer.from(ENCRYPTION_SECRET), fixedIV);
                let decrypted = decipher.update(encryptedBuffer, null, 'utf8');
                decrypted += decipher.final('utf8');
                return decrypted;
            } catch (oldErr) {
                console.error("Falha ao descriptografar formato antigo:", oldErr.message);
                return null;
            }
        }
        
        // Formato novo: IV:encrypted
        if (parts.length < 2) {
            console.error("Formato de hash inválido (deve conter IV:encrypted)");
            return null;
        }
        const ivHex = parts.shift();
        if (!ivHex || ivHex.length !== 32) { // IV deve ter 16 bytes = 32 caracteres hex
            console.error("IV inválido no hash:", ivHex);
            return null;
        }
        const decipher_iv = Buffer.from(ivHex, 'hex');
        const encryptedText = parts.join(':');
        if (!encryptedText) {
            console.error("Texto criptografado vazio");
            return null;
        }
        const encryptedBuffer = Buffer.from(encryptedText, 'hex');
        const decipher = crypto.createDecipheriv(ALGORITHM, Buffer.from(ENCRYPTION_SECRET), decipher_iv);
        let decrypted = decipher.update(encryptedBuffer, null, 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    } catch (err) {
        console.error("Falha ao desencriptar:", err.message);
        return null;
    }
}

// Função auxiliar para descriptografar token com tratamento de erro melhorado
function decryptToken(encryptedToken, context = '') {
    if (!encryptedToken) {
        console.warn(`[${context}] Token não fornecido`);
        return null;
    }
    const decrypted = decrypt(encryptedToken);
    if (!decrypted) {
        console.error(`[${context}] Falha ao descriptografar token`);
    }
    return decrypted;
}


// --- FUNÇÕES AUXILIARES DE MINERAÇÃO (YOUTUBE API V3) ---
async function callYouTubeDataAPI(videoId, apiKey) {
    if (!apiKey || !apiKey.trim()) {
        throw new Error('Chave de API do YouTube não fornecida.');
    }
    
    // Limpar a chave de espaços e caracteres inválidos
    apiKey = apiKey.trim();
    
    const url = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoId}&key=${apiKey}`;
    try {
        const response = await fetch(url);
        const data = await response.json();
        
        if (!response.ok) {
            // Verificar erros específicos da API do YouTube
            if (data.error) {
                const errorMessage = data.error.message || '';
                const errorReason = data.error.errors?.[0]?.reason || '';
                
                console.log('[YouTube API] Erro recebido:', {
                    status: response.status,
                    errorMessage: errorMessage,
                    errorReason: errorReason,
                    fullError: JSON.stringify(data.error, null, 2)
                });
                
                // Erro de API key inválida
                if (errorMessage.includes('API key not valid') || 
                    errorMessage.includes('invalid API key') ||
                    errorMessage.includes('badRequest') ||
                    errorReason === 'keyInvalid' ||
                    errorReason === 'badRequest') {
                    throw new Error('A chave de API do YouTube está inválida. Configure uma chave válida nas Configurações.');
                }
                
                // Erro de API key não fornecida
                if (errorMessage.includes('API key not found') || 
                    errorReason === 'keyNotFound') {
                    throw new Error('Chave de API do YouTube não configurada. Configure uma chave nas Configurações.');
                }
                
                // Erro de quota excedida
                if (errorMessage.includes('quota') || errorReason === 'quotaExceeded') {
                    throw new Error('Cota da API do YouTube excedida. Tente novamente mais tarde.');
                }
                
                // Outros erros
                throw new Error(errorMessage || 'Erro ao buscar dados do YouTube.');
            }
            
            throw new Error('Erro desconhecido ao buscar dados do YouTube.');
        }
        
        if (!data.items || data.items.length === 0) {
            throw new Error('Vídeo não encontrado. Verifique se a URL está correta.');
        }
        
        const item = data.items[0];
        const snippet = item.snippet;
        const stats = item.statistics;

        return {
            title: snippet.title,
            description: snippet.description || '',
            thumbnailUrl: snippet.thumbnails.maxres?.url || snippet.thumbnails.high?.url || snippet.thumbnails.default?.url,
            views: stats.viewCount || 0,
            likes: stats.likeCount || 0,
            comments: stats.commentCount || 0,
            days: Math.round((new Date() - new Date(snippet.publishedAt)) / (1000 * 60 * 60 * 24))
        };
    } catch (err) {
        console.error("Erro ao chamar YouTube Data API v3:", err);
        // Se o erro já tem uma mensagem amigável, manter
        if (err.message && (
            err.message.includes('chave de API') || 
            err.message.includes('API key') ||
            err.message.includes('Cota') ||
            err.message.includes('não encontrado')
        )) {
            throw err;
        }
        // Caso contrário, lançar erro genérico
        throw new Error(`Falha ao buscar dados do YouTube: ${err.message}`);
    }
}

async function getChannelVideosWithDetails(channelId, apiKey, order = 'date', maxResults = 5) {
    try {
        // Etapa 1: Buscar IDs dos vídeos
        const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=id&channelId=${channelId}&order=${order}&maxResults=${maxResults}&type=video&key=${apiKey}`;
        const searchResponse = await fetch(searchUrl);
        
        if (!searchResponse.ok) {
            const errorText = await searchResponse.text();
            console.error('[getChannelVideosWithDetails] Erro na busca de vídeos:', searchResponse.status, errorText.substring(0, 200));
            // Tentar parsear como JSON, se falhar retornar array vazio
            try {
                const errorData = JSON.parse(errorText);
                throw new Error(errorData.error?.message || `Erro ao buscar vídeos: ${searchResponse.status}`);
            } catch {
                throw new Error(`Erro ao buscar vídeos do canal: ${searchResponse.status}`);
            }
        }
        
        const searchData = await searchResponse.json();
        if (!searchData.items || !Array.isArray(searchData.items)) {
            console.warn('[getChannelVideosWithDetails] Nenhum vídeo encontrado ou resposta inválida');
            return [];
        }
        
        const videoIds = searchData.items.map(item => item.id?.videoId).filter(id => id).join(',');
        if (!videoIds) {
            console.warn('[getChannelVideosWithDetails] Nenhum ID de vídeo válido encontrado');
            return [];
        }

        // Etapa 2: Buscar detalhes e estatísticas de todos os vídeos de uma vez
        const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoIds}&key=${apiKey}`;
        const detailsResponse = await fetch(detailsUrl);
        
        if (!detailsResponse.ok) {
            const errorText = await detailsResponse.text();
            console.error('[getChannelVideosWithDetails] Erro ao buscar detalhes:', detailsResponse.status, errorText.substring(0, 200));
            // Tentar parsear como JSON, se falhar retornar array vazio
            try {
                const errorData = JSON.parse(errorText);
                throw new Error(errorData.error?.message || `Erro ao buscar detalhes: ${detailsResponse.status}`);
            } catch {
                throw new Error(`Erro ao buscar detalhes dos vídeos: ${detailsResponse.status}`);
            }
        }
        
        const detailsData = await detailsResponse.json();
        if (!detailsData.items || !Array.isArray(detailsData.items)) {
            console.warn('[getChannelVideosWithDetails] Nenhum detalhe de vídeo encontrado');
            return [];
        }

        // Etapa 3: Mapear e formatar os dados (com receita e RPM estimados)
        return detailsData.items.map(item => {
            const uploadDate = new Date(item.snippet.publishedAt);
            const daysPosted = Math.round((new Date() - uploadDate) / (1000 * 60 * 60 * 24));
            const views = parseInt(item.statistics.viewCount || 0);
            // Calcular receita e RPM (usar padrão, pode ser melhorado buscando nicho do canal)
            const rpm = getRPMByNiche(null);
            const estimatedRevenueUSD = (views / 1000) * rpm.usd;
            const estimatedRevenueBRL = (views / 1000) * rpm.brl;
            
            return {
                videoId: item.id,
                title: item.snippet.title,
                thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default?.url || '',
                publishedAt: item.snippet.publishedAt,
                views: views,
                likes: parseInt(item.statistics.likeCount || 0),
                comments: parseInt(item.statistics.commentCount || 0),
                days: daysPosted,
                estimatedRevenueUSD: estimatedRevenueUSD,
                estimatedRevenueBRL: estimatedRevenueBRL,
                rpmUSD: rpm.usd,
                rpmBRL: rpm.brl
            };
        });
    } catch (err) {
        console.error('[getChannelVideosWithDetails] Erro geral:', err.message);
        // Sempre retornar array vazio em caso de erro, não lançar exceção
        return [];
    }
}

// --- Helper para buscar imagem como Base64 ---
async function fetchImageAsBase64(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Falha ao baixar imagem: ${response.statusText}`);
        const buffer = await response.arrayBuffer();
        const base64 = Buffer.from(buffer).toString('base64');
        const mimeType = response.headers.get('content-type') || 'image/jpeg';
        return { base64, mimeType };
    } catch (err) {
        console.error(`Erro ao converter imagem para base64: ${err.message}`);
        throw err;
    }
}

// --- Helper para corrigir JSON com quebras de linha não escapadas ---
function fixJsonWithUnescapedNewlines(jsonString) {
    let result = '';
    let inString = false;
    let escapeNext = false;
    
    for (let i = 0; i < jsonString.length; i++) {
        const char = jsonString[i];
        const nextChar = jsonString[i + 1];
        
        if (escapeNext) {
            result += char;
            escapeNext = false;
            continue;
        }
        
        if (char === '\\') {
            result += char;
            escapeNext = true;
            continue;
        }
        
        if (char === '"') {
            inString = !inString;
            result += char;
            continue;
        }
        
        if (inString && (char === '\n' || char === '\r')) {
            // Substituir quebras de linha dentro de strings por \n escapado
            if (char === '\r' && nextChar === '\n') {
                result += '\\n';
                i++; // Pular o \n também
            } else {
                result += '\\n';
            }
            continue;
        }
        
        result += char;
    }
    
    return result;
}

// --- Função auxiliar para extrair JSON completo contando chaves ---
function extractCompleteJson(text, startPattern = /\{/) {
    const startMatch = text.match(startPattern);
    if (!startMatch) return null;
    
    const startIndex = startMatch.index;
    let braceCount = 0;
    let inString = false;
    let escapeNext = false;
    
    for (let i = startIndex; i < text.length; i++) {
        const char = text[i];
        
        if (escapeNext) {
            escapeNext = false;
            continue;
        }
        
        if (char === '\\') {
            escapeNext = true;
            continue;
        }
        
        if (char === '"') {
            inString = !inString;
            continue;
        }
        
        if (!inString) {
            if (char === '{') {
                braceCount++;
            } else if (char === '}') {
                braceCount--;
                if (braceCount === 0) {
                    return text.substring(startIndex, i + 1);
                }
            }
        }
    }
    
    return null;
}

// --- Helper para analisar resposta JSON da IA ---
function parseAIResponse(responseText, serviceName) {
    const rawText = (typeof responseText === 'string')
        ? responseText
        : (responseText === null || responseText === undefined ? '' : String(responseText));
    try {
        // Limpar o texto removendo possíveis markdown code blocks
        let cleanedText = rawText.trim();
        
        // Remover markdown code blocks se existirem
        cleanedText = cleanedText.replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/\s*```$/i, '');

        const sanitizeJsonString = (jsonString) => {
            if (!jsonString) return jsonString;
            let s = jsonString.trim();
            // Remover BOM e caracteres invisíveis comuns
            s = s.replace(/^\uFEFF/, '');
            // Remover trailing commas antes de } ou ]
            s = s.replace(/,\s*([}\]])/g, '$1');
            // Normalizar quebras de linha dentro de strings (já existe helper)
            s = fixJsonWithUnescapedNewlines(s);
            return s;
        };

        const tryParse = (candidate) => {
            if (!candidate) return null;
            const s = sanitizeJsonString(candidate);
            return JSON.parse(s);
        };
        
        // 1) Tentar extrair JSON completo contando chaves (mais robusto que regex guloso)
        const extractedObject = extractCompleteJson(cleanedText, /\{/);
        if (extractedObject) {
            try { return tryParse(extractedObject); } catch (_) {}
        }

        // 2) Tentar extrair array completo
        const extractCompleteArray = (text) => {
            const startIdx = text.indexOf('[');
            if (startIdx < 0) return null;
            let depth = 0;
            let inString = false;
            let escapeNext = false;
            for (let i = startIdx; i < text.length; i++) {
                const ch = text[i];
                if (escapeNext) { escapeNext = false; continue; }
                if (ch === '\\') { escapeNext = true; continue; }
                if (ch === '"') { inString = !inString; continue; }
                if (!inString) {
                    if (ch === '[') depth++;
                    else if (ch === ']') {
                        depth--;
                        if (depth === 0) return text.substring(startIdx, i + 1);
                    }
                }
            }
            return null;
        };

        const extractedArray = extractCompleteArray(cleanedText);
        if (extractedArray) {
            try { return tryParse(extractedArray); } catch (_) {}
        }

        // 3) Tentar parsear a string inteira (por último)
        try {
            return tryParse(cleanedText);
        } catch (_) {}
        
        throw new Error('JSON não encontrado ou inválido após sanitização.');
    } catch (e) {
        console.error(`[Análise-${serviceName}] Falha ao parsear JSON da IA:`, e);
        console.error(`[Análise-${serviceName}] Texto recebido (primeiros 2000 caracteres):`, rawText.substring(0, 2000));
        
        // Tentar uma última abordagem: usar regex para extrair campos específicos
        try {
            // Regex mais robusta que lida com quebras de linha dentro de strings
            const nicheMatch = rawText.match(/"niche"\s*:\s*"((?:[^"\\]|\\.)*)"/);
            const subnicheMatch = rawText.match(/"subniche"\s*:\s*"((?:[^"\\]|\\.)*)"/);
            // Usar [\s\S] em vez de . com flag s para compatibilidade
            const motivoMatch = rawText.match(/"motivoSucesso"\s*:\s*"((?:[^"\\]|\\.|[\s\S])*?)"/);
            const formulaMatch = rawText.match(/"formulaTitulo"\s*:\s*"((?:[^"\\]|\\.|[\s\S])*?)"/);
            
            if (nicheMatch && motivoMatch) {
                console.warn(`[Análise-${serviceName}] Usando fallback de parsing regex devido a JSON malformado`);
                
                // Extrair títulos sugeridos usando regex (mais robusta)
                const titulosMatches = [...rawText.matchAll(/"titulo"\s*:\s*"((?:[^"\\]|\\.)*)"/g)];
                const titulos = titulosMatches.map(m => m[1]).filter(t => t.length > 0);
                
                // Limpar quebras de linha dos valores extraídos
                const cleanValue = (val) => val.replace(/\r?\n/g, ' ').trim();
                
                return {
                    niche: cleanValue(nicheMatch[1]),
                    subniche: subnicheMatch ? cleanValue(subnicheMatch[1]) : 'N/A',
                    analiseOriginal: {
                        motivoSucesso: cleanValue(motivoMatch[1]),
                        formulaTitulo: formulaMatch ? cleanValue(formulaMatch[1]) : 'N/A'
                    },
                    titulosSugeridos: titulos.map((titulo, index) => ({
                        titulo: cleanValue(titulo),
                        pontuacao: 8,
                        explicacao: `Título gerado pela IA (parsing fallback)`
                    }))
                };
            }
        } catch (fallbackError) {
            console.error(`[Análise-${serviceName}] Fallback também falhou:`, fallbackError);
        }
        
        throw new Error(`A IA (${serviceName}) retornou um formato JSON inválido.`);
    }
}

// --- Helper específico para Análise de Títulos ---
// Aceita JSON (formato antigo) OU lista numerada (1..5) conforme "PROMPT UNIVERSAL — CLONAGEM DE TÍTULOS VIRAIS".
function parseNumberedTitles(responseText, expectedCount = 5) {
    let cleaned = String(responseText || '')
        .trim()
        .replace(/^```[a-z]*\s*/i, '')
        .replace(/\s*```$/i, '')
        .trim();
    
    // Remover texto introdutório comum antes da lista numerada
    cleaned = cleaned.replace(/^(?:aqui estão?|segue|seguem|títulos?|lista|resultado).*?(?=\n\s*\d)/is, '');
    cleaned = cleaned.replace(/^.*?(?=\n?\s*1[\.\)\:\-])/is, (match) => {
        // Só remove se não tiver muitas linhas (evita remover títulos)
        return match.split('\n').length <= 2 ? '' : match;
    });
    cleaned = cleaned.trim();

    const titles = [];
    const seen = new Set();

    const pushTitle = (t) => {
        let rawText = String(t || '').trim().replace(/^["']|["']$/g, '').trim();
        if (!rawText) return;
        
        // Extrair título e fórmula se presente (formato: "TÍTULO | FÓRMULA: descrição")
        let title = rawText;
        let formula = null;
        
        const formulaMatch = rawText.match(/^(.+?)\s*\|\s*F[ÓO]RMULA\s*:\s*(.+)$/i);
        if (formulaMatch) {
            title = formulaMatch[1].trim();
            formula = formulaMatch[2].trim();
        }
        
        const key = title.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        titles.push({ title, formula });
    };

    // Normalizar alguns formatos comuns (ex: 1️⃣, travessões)
    const normalized = cleaned
        .replace(/1️⃣/g, '1.')
        .replace(/2️⃣/g, '2.')
        .replace(/3️⃣/g, '3.')
        .replace(/4️⃣/g, '4.')
        .replace(/5️⃣/g, '5.')
        .replace(/6️⃣/g, '6.')
        .replace(/7️⃣/g, '7.')
        .replace(/8️⃣/g, '8.')
        .replace(/9️⃣/g, '9.')
        .replace(/10️⃣/g, '10.')
        .replace(/[“”]/g, '"')
        .replace(/[‘’]/g, "'");

    // 0) Se vier como JSON array, aceitar (["t1","t2",...] ou [{title:"...", formula:"..."}])
    try {
        const maybeJson = JSON.parse(normalized);
        if (Array.isArray(maybeJson)) {
            maybeJson.forEach(item => {
                if (typeof item === 'string') {
                    pushTitle(item);
                } else if (typeof item === 'object' && item !== null) {
                    // Array de objetos: [{id: 1, title: "...", formula: "..."}]
                    const titleText = item.title || item.titulo || item.text;
                    const formulaText = item.formula || item.fórmula;
                    if (titleText) {
                        const fullText = formulaText ? `${titleText} | FÓRMULA: ${formulaText}` : titleText;
                        pushTitle(fullText);
                    }
                }
            });
            if (titles.length >= expectedCount) return titles.slice(0, expectedCount);
        }
    } catch {}

    // Preferência: linhas numeradas
    const lines = normalized.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    for (const line of lines) {
        const m = line.match(/^(\d{1,2})\s*[\)\.\:\-\–\—\]\>]\s*(.+)$/);
        if (m && m[2]) pushTitle(m[2]);
    }

    // Fallback: bullets
    if (titles.length === 0) {
        for (const line of lines) {
            const m = line.match(/^(?:[-•*])\s*(.+)$/);
            if (m && m[1]) pushTitle(m[1]);
        }
    }

    // Fallback 2: se veio em uma linha com separadores comuns
    if (titles.length < expectedCount) {
        const chunks = normalized
            .split(/\r?\n|(?:\s*\|\s*)|(?:\s*;\s*)|(?:\s*\/\s*)/g)
            .map(s => s.trim())
            .filter(Boolean);

        // não duplicar trabalho: evitar incluir linhas que já eram só contexto
        if (chunks.length >= expectedCount) {
            for (const c of chunks) {
                // se estiver numerado, remove o prefixo
                const m = c.match(/^(\d{1,2})\s*[\)\.\:\-\–\—\]\>]\s*(.+)$/);
                pushTitle(m && m[2] ? m[2] : c);
                if (titles.length >= expectedCount) break;
            }
        }
    }

    // Fallback 3: vários títulos na mesma linha com numeração interna (1... 2... 3...)
    if (titles.length < expectedCount) {
        const pattern = /(\d{1,2})\s*[\)\.\:\-\–\—]\s*([\s\S]*?)(?=(\d{1,2})\s*[\)\.\:\-\–\—]|$)/g;
        const matches = [...normalized.matchAll(pattern)];
        if (matches.length > 0) {
            for (const m of matches) {
                pushTitle(m[2]);
                if (titles.length >= expectedCount) break;
            }
        }
    }

    // Último fallback: pegar as primeiras linhas não vazias
    if (titles.length === 0) {
        for (const line of lines) pushTitle(line);
    }

    if (titles.length < expectedCount) {
        console.warn(`[PARSE] parseNumberedTitles: esperado ${expectedCount}, extraído ${titles.length}`);
        if (titles.length > 0) {
            console.warn(`[PARSE] Títulos extraídos:`, titles.map(t => `"${t.title}"`).join(', '));
        }
        return null;
    }
    return titles.slice(0, expectedCount);
}

function parseTitleAnalysisResponse(responseText, serviceName, expectedCount = 5) {
    const raw = (typeof responseText === 'string')
        ? responseText
        : (responseText === null || responseText === undefined ? '' : String(responseText));
    const trimmed = raw.trim();

    // PRIORIDADE 1: Se parece JSON (começa com [ ou {), tentar parsear JSON primeiro
    const looksLikeJson = trimmed.startsWith('[') || trimmed.startsWith('{');
    
    if (looksLikeJson) {
        try {
            const parsed = parseAIResponse(raw, serviceName);
            // 1.a) Formato antigo completo
            if (parsed && Array.isArray(parsed.titulosSugeridos) && parsed.titulosSugeridos.length > 0) {
                return parsed;
            }
            // 1.b) JSON array simples: ["t1","t2"...] ou [{id:1, title:"..."}]
            if (Array.isArray(parsed)) {
                // Verificar se são strings ou objetos
                const hasObjects = parsed.some(x => typeof x === 'object' && x !== null);
                if (hasObjects) {
                    // Array de objetos: [{id: 1, title: "...", formula: "..."}]
                    const titlesData = parsed
                        .map(item => {
                            if (typeof item === 'object' && item !== null) {
                                const titulo = item.title || item.titulo || item.text;
                                const formula = item.formula || item.fórmula;
                                if (titulo) return { titulo, formula };
                            }
                            return null;
                        })
                        .filter(Boolean)
                        .slice(0, expectedCount);
                    
                    if (titlesData.length >= expectedCount) {
            return {
                niche: null,
                subniche: null,
                analiseOriginal: { motivoSucesso: 'N/A', formulaTitulo: 'N/A' },
                            titulosSugeridos: titlesData.map(({ titulo, formula }) => ({ 
                                titulo, 
                    pontuacao: 9, 
                    explicacao: '', 
                                formula: formula || null 
                }))
            };
        }
                } else {
                    // Array de strings simples
            const titles = parsed.filter(x => typeof x === 'string').slice(0, expectedCount);
            if (titles.length >= expectedCount) {
                return {
                    niche: null,
                    subniche: null,
                    analiseOriginal: { motivoSucesso: 'N/A', formulaTitulo: 'N/A' },
                    titulosSugeridos: titles.map(titulo => ({ titulo, pontuacao: 9, explicacao: '' }))
                };
                    }
            }
        }
        // 1.c) JSON com array em outros campos comuns
        const altArr = parsed && (
            (Array.isArray(parsed.titles) ? parsed.titles : null) ||
            (Array.isArray(parsed.titulos) ? parsed.titulos : null) ||
            (Array.isArray(parsed.result) ? parsed.result : null)
        );
        if (altArr) {
            const titles = altArr.filter(x => typeof x === 'string').slice(0, expectedCount);
            if (titles.length >= expectedCount) {
                return {
                    niche: null,
                    subniche: null,
                    analiseOriginal: { motivoSucesso: 'N/A', formulaTitulo: 'N/A' },
                    titulosSugeridos: titles.map(titulo => ({ titulo, pontuacao: 9, explicacao: '' }))
                };
            }
        }
    } catch (e) {
            // Se JSON falhar, tentar lista numerada abaixo
            console.warn(`[PARSE] Tentativa de JSON falhou, tentando lista numerada:`, e.message);
        }
    }

    // PRIORIDADE 2: Se parece lista numerada, tentar parsear como lista
    if (/^(?:\s*(?:\d{1,2}|[1-9]️⃣|10️⃣)\s*[\)\.\:\-\–\—])/.test(trimmed)) {
        const titles = parseNumberedTitles(trimmed, expectedCount);
        if (titles) {
            return {
                niche: null,
                subniche: null,
                analiseOriginal: { motivoSucesso: 'N/A', formulaTitulo: 'N/A' },
                titulosSugeridos: titles.map(item => ({ 
                    titulo: item.title, 
                    pontuacao: 9, 
                    explicacao: '', 
                    formula: item.formula 
                }))
            };
        }
    }

    // 3) Tentar lista numerada como último recurso
    const titles = parseNumberedTitles(raw, expectedCount);
    if (titles) {
        return {
            niche: null,
            subniche: null,
            analiseOriginal: {
                motivoSucesso: 'N/A',
                formulaTitulo: 'N/A'
            },
            titulosSugeridos: titles.map(item => ({
                titulo: item.title,
                pontuacao: 9,
                explicacao: '',
                formula: item.formula
            }))
        };
    }

    // Debug: log da resposta bruta quando falhar
    console.error(`[PARSE ERROR] IA: ${serviceName}, Resposta recebida (primeiros 500 chars):`);
    console.error(raw.substring(0, 500));
    throw new Error(`A IA (${serviceName}) retornou um formato inválido para títulos. Esperado: JSON ou lista numerada com ${expectedCount} títulos.`);
}

// --- Score 2: Impacto Visual (0–10) ---
// Não avalia verdade histórica. Avalia força competitiva no feed: CAIXA ALTA, loop mental, contraste, clareza em 3s, thumb-friendly.
function computeImpactVisualScore(titleText) {
    const text = String(titleText || '').trim();
    if (!text) return 0;

    const upperMatches = text.match(/[A-ZÁÉÍÓÚÃÕÂÊÎÔÛÇ]{3,}(?:\s+[A-ZÁÉÍÓÚÃÕÂÊÎÔÛÇ]{3,})*/g) || [];
    const uniqueUpper = Array.from(new Set(upperMatches.map(s => s.trim()))).filter(Boolean);

    const letters = (text.match(/[A-Za-zÁÉÍÓÚÃÕÂÊÎÔÛÇáéíóúãõâêîôûç]/g) || []).length;
    const upperLetters = (text.match(/[A-ZÁÉÍÓÚÃÕÂÊÎÔÛÇ]/g) || []).length;
    const isMostlyAllCaps = letters > 0 && (upperLetters / letters) > 0.85;

    // 1) CAIXA ALTA (0–3)
    let scoreCaps = 0;
    if (uniqueUpper.length === 0) {
        scoreCaps = 0;
    } else if (isMostlyAllCaps) {
        // poluição visual: tudo em caps
        scoreCaps = 0;
    } else if (uniqueUpper.length === 1) {
        scoreCaps = 1;
    } else if (uniqueUpper.length === 2) {
        scoreCaps = 2;
    } else {
        scoreCaps = 3;
    }

    // 2) Loop mental (0–2)
    // Mais alinhado ao critério: palavras de "lacuna" contam forte mesmo sem interrogação.
    const strongLoop = /(N[ÃA]O\s+DEVERIA|NUNCA\s+DEVERIA|NINGU[ÉE]M\s+EXPLICA|N[ÃA]O\s+CONSEGUE\s+EXPLICAR|DETALHE\s+(IGNORADO|OCULTO)|COMO\s+FOI\s+POSS[ÍI]VEL|O\s+SEGREDO|MIST[ÉE]RIO|VERDADE\s+(OCULTA|SOBRE)|NINGU[ÉE]M\s+(CONTA|TE\s+CONTA))/i.test(text);
    const softLoop = /(\?|COMO|POR\s+QUE|O\s+QUE|QUASE\s+NINGU[ÉE]M|NINGU[ÉE]M|SEGREDO|DETALHE|REVELA|IMPOSS[ÍI]VEL|NUNCA)/i.test(text);
    const scoreLoop = strongLoop ? 2 : (softLoop ? 1 : 0);

    // 3) Contraste / tensão visual (0–2)
    const hasArrow = /→|->/i.test(text);
    const hasContrastWord = /\b(MAS|POR[ÉE]M|S[ÓO]\s+QUE|MESMO\s+ASSIM|AINDA\s+ASSIM|APESAR|CONTRA)\b/i.test(text);
    const hasTwoClauses = /[.!?].+/.test(text) || hasArrow || /:\s*\S+/.test(text);
    const hasTensionEnv = /\b(HOSTIL|PIOR\s+LUGAR|P[ÂA]NTANO|LAGO|DEBAIXO\s+D['’]?[ÁA]GUA|PROIBIDO|MORTAL)\b/i.test(text);
    let scoreContrast = 0;
    if (hasArrow) scoreContrast = 2;
    else if (hasContrastWord && hasTwoClauses) scoreContrast = 2;
    else if (hasTwoClauses || hasContrastWord || hasTensionEnv) scoreContrast = 1;

    // 4) Clareza em até 3s (0–2)
    const words = text.split(/\s+/).filter(Boolean);
    let scoreClarity = 0;
    // Um pouco mais permissivo (Claude/Gemini tendem a ser levemente mais longos)
    if (words.length <= 14) scoreClarity = 2;
    else if (words.length <= 18) scoreClarity = 1;
    else scoreClarity = 0;
    // Penalizar excesso de complexidade: muitas vírgulas/termos técnicos longos
    const commas = (text.match(/,/g) || []).length;
    if (commas >= 3 && scoreClarity > 0) scoreClarity -= 1;

    // 5) Compatibilidade com thumb (0–1)
    // Thumb-friendly quando há 1+ termo em caps e a leitura não é longa demais
    const scoreThumb = (scoreCaps > 0 && words.length <= 18) ? 1 : 0;

    const total = scoreCaps + scoreLoop + scoreContrast + scoreClarity + scoreThumb;
    return Math.max(0, Math.min(10, Math.round(total)));
}

function enforceImpactGate(titles, { minImpact = 7, expectedCount = 5 } = {}) {
    const normalized = Array.isArray(titles) ? titles : [];
    const withScore = normalized.map(t => ({
        ...t,
        impact_score: typeof t.impact_score === 'number' ? t.impact_score : computeImpactVisualScore(t.titulo)
    }));
    const passing = withScore
        .filter(t => Number(t.impact_score || 0) >= minImpact)
        .sort((a, b) => Number(b.impact_score || 0) - Number(a.impact_score || 0));
    return { passing: passing.slice(0, expectedCount), withScore };
}

function buildTitleRefinePrompt({
    originalTitle,
    translatedTitle,
    performanceContext,
    descriptionStart,
    transcriptStart,
    languageInstruction,
    titlesRequired = 5,
    minImpact = 7,
    avoidTitles = [],
    attemptLevel = 1
}) {
    const avoidBlock = avoidTitles && avoidTitles.length
        ? `\nTÍTULOS JÁ ACEITOS (NÃO REPETIR IDEIA/NEM FRASE):\n${avoidTitles.map(t => `- ${t}`).join('\n')}\n`
        : '';
    const level = Number(attemptLevel || 1);
    const attemptBlock = () => {
        if (level <= 1) return '';
        if (level === 2) {
            return `\nAUTO-FALLBACK (2ª tentativa — relaxar 1 regra)\n- CAIXA ALTA pode ser apenas 1 palavra (a mais forte)\n- Contraste pode ser sutil (não precisa ser extremo)\n`;
        }
        return `\nAUTO-FALLBACK (3ª tentativa — generalizar cenário)\n- Se houver risco factual, GENERALIZE cenário/povo/local (ex: “uma CIVILIZAÇÃO ANTIGA”, “uma cidade improvável”, “um AMBIENTE HOSTIL”)\n`;
    };
    return `PROMPT FINAL — GERAÇÃO DE TÍTULOS VIRAIS (≥ ${minImpact} COM AUTO-FALLBACK)

Você receberá o título de um vídeo que JÁ VIRALIZOU, comprovadamente com alto CTR e retenção.

OBJETIVO CENTRAL (REGRA ABSOLUTA)

Gerar ${titlesRequired} títulos ALTAMENTE COMPETITIVOS, focados em:
- CTR alto
- Retenção inicial
- Impacto visual no feed

👉 Somente títulos com IMPACTO VISUAL ESTIMADO ≥ ${minImpact}/10 podem ser entregues ao frontend.

PRINCÍPIO-CHAVE

O título original já venceu o algoritmo.
Sua função é clonar a fórmula psicológica vencedora, intensificando impacto,
variando o cenário, sem quebrar fidelidade temática.

⚠️ REGRA FUNDAMENTAL (NÃO NEGOCIÁVEL)

Todos os títulos gerados DEVEM:

✓ Replicar a FÓRMULA PSICOLÓGICA do título original viralizado
  (estrutura, gancho, curiosidade, promessa, tensão, contraste)

✓ Manter o mesmo TIPO DE PROMESSA e NÍVEL DE CURIOSIDADE

✓ MAS aplicar essa fórmula em um CONTEXTO DIFERENTE, alterando explicitamente:
  • LOCAL (onde acontece)
  • POVO / ATOR COLETIVO (quem fez)
  • CIVILIZAÇÃO / SISTEMA (em que mundo isso existe)

❌ É PROIBIDO reutilizar o mesmo contexto do título original.
❌ Se detectar repetição de mundo narrativo, você DEVE reescrever antes de entregar.

Modelo mental correto:
"Inspirado no que viralizou, não preso ao mesmo contexto."
Mesma FÓRMULA → Mundo diferente.

Execute silenciosamente.

REGRAS OBRIGATÓRIAS DE IMPACTO

Cada título precisa conter:

1️⃣ GATILHOS EM CAIXA ALTA (OBRIGATÓRIO)

Use 1 a 3 termos em CAIXA ALTA

Priorize gatilhos fortes:

IMPOSSÍVEL
NUNCA
SEGREDO
NINGUÉM
VERDADE
GENIALIDADE
OBRA IMPOSSÍVEL
NÃO DEVERIA EXISTIR

Sem CAIXA ALTA estratégica → impacto insuficiente.

2️⃣ LOOP MENTAL INCOMPLETO

O título não pode explicar tudo.
Deve criar expectativa clara de revelação após o clique.

Exemplos válidos:

“NUNCA DEVERIA TER FUNCIONADO”
“NINGUÉM EXPLICA ISSO”
“O DETALHE IGNORADO”

3️⃣ CONTRASTE OU TENSÃO

Cada título deve conter ao menos um contraste:

ambiente hostil × sucesso
impossível × realizado
esquecido × grandioso
antigo × avançado

4️⃣ VARIAÇÃO OBRIGATÓRIA DE CENÁRIO

Entre os ${titlesRequired} títulos:

NO MÍNIMO 3 DEVEM trocar explicitamente:

local
povo / civilização
cenário ambiental ou contextual

Se houver risco factual, GENERALIZE:

“uma CIVILIZAÇÃO ANTIGA”
“uma CIDADE ESQUECIDA”
“um AMBIENTE HOSTIL”

5️⃣ LEITURA EM ATÉ 3 SEGUNDOS

Frases curtas
Estrutura simples
Impacto imediato

6️⃣ VARIAÇÃO CONTEXTUAL UNIVERSAL (OBRIGATÓRIA)

Entre os ${titlesRequired} títulos gerados, você DEVE variar explicitamente os ELEMENTOS CONTEXTUAIS,
independentemente do nicho.

Distribua os títulos para que cada um enfatize um eixo diferente:

1. Um título com foco no ATOR (quem fez / quem viveu)
2. Um título com foco no AMBIENTE ou CONTEXTO (onde / em que situação)
3. Um título com foco no DESAFIO ou LIMITAÇÃO (o que tornava difícil)
4. Um título com foco na SOLUÇÃO ou AÇÃO (o que foi feito)
5. Um título com foco no RESULTADO ou IMPACTO (o que mudou)

Não reutilize o mesmo elemento contextual como foco principal em mais de um título.
Se houver risco de imprecisão, generalize (ex: "alguém", "um grupo", "uma situação extrema").

Execute silenciosamente.

7️⃣ VARIAÇÃO DE ATOR (OBRIGATÓRIA)

Entre os ${titlesRequired} títulos gerados, você DEVE variar explicitamente o ATOR principal.
O ATOR é quem executa a ação central do título.

Cada título deve usar um ATOR DIFERENTE, escolhendo entre:

- um povo
- uma civilização
- um grupo
- uma sociedade
- uma organização
- um ator genérico (ex: "um povo esquecido", "uma civilização perdida", "um grupo improvável")

É PROIBIDO que mais de dois títulos usem o mesmo ATOR implícito ou explícito.
Se detectar repetição do mesmo ATOR (mesmo que sem nome), você DEVE reescrever antes de entregar.

Se houver risco factual, use ATOR genérico, mas DIFERENTE do anterior.

Execute silenciosamente.

8️⃣ EQUILÍBRIO CONCRETO vs GENÉRICO (OBRIGATÓRIO)

Ao variar LOCAL, POVO e CIVILIZAÇÃO entre os ${titlesRequired} títulos:

✓ Pelo menos 2 títulos devem usar referências CONCRETAS (nomes reais, povos específicos, locais identificáveis)
✓ Pelo menos 2 títulos devem usar referências GENÉRICAS ("um povo", "uma ordem", "uma sociedade", "uma civilização")
✓ Nenhum título pode ser totalmente vago em TODOS os elementos

Se um título estiver excessivamente genérico (todos os elementos vagos), você DEVE reescrevê-lo
para torná-lo mais tangível, sem perder impacto.

Execute silenciosamente.

AUTO-REFINO OBRIGATÓRIO (CRÍTICO)

Antes de entregar os títulos:

Avalie mentalmente o IMPACTO VISUAL (0–10) de cada título

Se algum título ficar < ${minImpact}, você DEVE:

reescrevê-lo imediatamente
reforçar CAIXA ALTA, contraste ou loop mental

Repita esse processo internamente até que:

todos os ${titlesRequired} títulos estejam com impacto ≥ ${minImpact}

⚠️ Nunca entregue títulos < ${minImpact}.
    ⚠️ Não explique o processo. Apenas entregue o resultado final.
${attemptBlock()}

IDIOMA
- Todos os títulos devem estar ${languageInstruction}.

CONTEXTO DO VÍDEO (para fidelidade — não copie texto literalmente)
${performanceContext ? performanceContext : ''}
- Título original (idioma original): "${originalTitle}"
- Título traduzido (PT-BR): "${translatedTitle || originalTitle}"
- Descrição (início): ${descriptionStart || 'N/A'}...
- Transcrição (início): ${transcriptStart || 'N/A'}...
${avoidBlock}
FORMATO DE SAÍDA (OBRIGATÓRIO)

Retorne EXATAMENTE ${titlesRequired} títulos, numerados de 1 a ${titlesRequired}.

Cada linha deve seguir este formato:
NÚMERO. TÍTULO | FÓRMULA: [descrição breve da estrutura usada]

A FÓRMULA deve identificar:
- Qual ATOR foi usado (ex: "povo esquecido", "civilização antiga", "grupo improvável")
- Qual EIXO CONTEXTUAL foi enfatizado (ATOR/AMBIENTE/DESAFIO/SOLUÇÃO/IMPACTO)
- Qual GATILHO PSICOLÓGICO dominante (MISTÉRIO/CONTRASTE/IMPOSSÍVEL/SEGREDO/REVELAÇÃO)

Exemplo de formato válido:
1. A GENIALIDADE que criou uma CIDADE no NADA | FÓRMULA: Civilização antiga + DESAFIO + Contraste impossível
2. O SEGREDO por trás de uma OBRA PROIBIDA | FÓRMULA: Grupo desconhecido + SOLUÇÃO + Mistério oculto

Sem explicações adicionais.
Sem emojis.
Formato de lista numerada (não JSON).`;
}

function deriveNicheAndSubnicheFromContext({ originalTitle, translatedTitle, descriptionStart, transcriptStart }) {
    const hay = `${originalTitle || ''}\n${translatedTitle || ''}\n${descriptionStart || ''}\n${transcriptStart || ''}`.toLowerCase();
    
    // História e Civilizações
    if (/(hist[oó]ria|civiliza|imp[eé]rio|antigo|antiga|aztec|astec|tenocht|maia|inca|roma|egito|eg[ipí]cio|templo|pir[âa]mide|conquista|descobr|explora)/i.test(hay)) {
        return { niche: 'História', subniche: 'Civilizações Antigas' };
    }
    
    // Finanças e Investimentos
    if (/(finan|dinheiro|invest|renda|bitcoin|cripto|a[cç][aã]o|bolsa|neg[óo]cio|empreend)/i.test(hay)) {
        return { niche: 'Finanças', subniche: 'Investimentos' };
    }
    
    // Saúde e Bem-estar
    if (/(sa[uú]de|fitness|treino|dieta|emagrec|ansiedade|depress|m[uú]sculo|nutri[cç])/i.test(hay)) {
        return { niche: 'Saúde', subniche: 'Bem-estar' };
    }
    
    // Engenharia e Construção
    if (/(engenharia|constru|obra|arquitetura|edif[ií]cio|estrutura|projeto|engenh)/i.test(hay)) {
        return { niche: 'Educação', subniche: 'Engenharia' };
    }
    
    // Mistérios e Enigmas
    if (/(mist[eé]rio|enigma|inexplicável|segredo|oculto|conspira|paranormal)/i.test(hay)) {
        return { niche: 'Entretenimento', subniche: 'Mistérios' };
    }
    
    // Ciência e Tecnologia
    if (/(ci[eê]ncia|tecnologia|inven[cç]|descoberta|pesquisa|cientista|inova)/i.test(hay)) {
        return { niche: 'Educação', subniche: 'Ciência' };
    }
    
    // Fallback: Entretenimento Geral
    return { niche: 'Entretenimento', subniche: 'Geral' };
}

function deriveTitleAnalysis({ originalTitle, translatedTitle, views, days }) {
    const t = String(translatedTitle || originalTitle || '').trim();
    const lower = t.toLowerCase();
    const isList = /\b(\d+)\b/.test(lower) || /(pilares|raz[õo]es|fundamentos|segredos|passos)/i.test(lower);
    const hasHow = /(como|how)/i.test(lower);
    const hasWhy = /(por que|porque|why)/i.test(lower);
    const hasBigWord = /(genial|imposs[ií]vel|segredo|mist[eé]rio|verdade|ningu[eé]m|nunca)/i.test(lower);
    const vpd = days ? Math.round((views || 0) / Math.max(days, 1)) : null;

    const motivoSucesso = [
        vpd ? `Ganhou tração por consistência de interesse (≈${vpd.toLocaleString()} views/dia).` : 'Ganhou tração por consistência de interesse.',
        isList ? 'Promessa clara de estrutura (lista) ajuda clique e retenção.' : 'Promessa clara do tema ajuda clique.',
        hasHow || hasWhy ? 'Ângulo de curiosidade (“como/por que”) aumenta expectativa inicial.' : (hasBigWord ? 'Palavra de impacto aumenta o stop-scroll.' : 'Tema forte sustenta o clique.')
    ].join(' ');

    const formulaTitulo = [
        isList ? 'Estrutura de lista + promessa de clareza' : 'Promessa central + benefício',
        hasHow ? '+ gancho “COMO FOI POSSÍVEL”' : '',
        hasWhy ? '+ gancho “POR QUE”' : '',
        '+ 1–3 termos em CAIXA ALTA (gatilho principal)',
        '+ loop mental (o detalhe/segredo/verdade) sem inventar fatos',
        '+ contraste leve (antes vs depois / hostil vs feito) quando aplicável'
    ].filter(Boolean).join(' ');

    return { motivoSucesso, formulaTitulo };
}

async function generatePassingTitlesWithRefine({
    apiFunc,
    apiKey,
    model,
    serviceName,
    basePromptBuilder,
    buildArgs,
    titlesRequired = 5,
    minImpact = 7,
    maxRefines = 3
}) {
    let accepted = [];
    for (let attempt = 0; attempt <= maxRefines; attempt++) {
        const prompt = basePromptBuilder({
            ...buildArgs,
            titlesRequired,
            minImpact,
            avoidTitles: accepted.map(t => t.titulo),
            attemptLevel: Math.min(3, attempt + 1) // 1ª, 2ª, 3ª (fallback)
        });
        const resp = await apiFunc(prompt, apiKey, model);
        const text = typeof resp === 'string' ? resp : (resp?.titles || '');
        const parsed = parseTitleAnalysisResponse(text, serviceName, titlesRequired);
        const merged = [...accepted, ...parsed.titulosSugeridos];
        accepted = enforceImpactGate(merged, { minImpact, expectedCount: titlesRequired }).passing;
        if (accepted.length >= titlesRequired) break;
    }
    return accepted;
}


// --- FUNÇÕES AUXILIARES DE API (O DISTRIBUIDOR) ---

async function callGeminiAPI(prompt, apiKey, model, imageUrl = null, additionalImages = []) {
    if (!apiKey) throw new Error("Chave de API do Utilizador (Gemini) não configurada.");
    
    const modelName = model; // Usar o nome do modelo diretamente do frontend

    const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
    
    const parts = [];
    
    // Adicionar imagem principal se fornecida
    if (imageUrl) {
        const { base64, mimeType } = await fetchImageAsBase64(imageUrl);
        parts.push({
            inlineData: {
                mimeType: mimeType,
                data: base64
            }
        });
    }
    
    // Adicionar imagens adicionais (thumbnails de referência)
    if (Array.isArray(additionalImages) && additionalImages.length > 0) {
        for (const img of additionalImages) {
            let base64, mimeType;
            if (typeof img === 'string') {
                // Se for base64 string direto
                if (img.startsWith('data:image/')) {
                    const imgParts = img.split(',');
                    base64 = imgParts[1];
                    // Extrair mimeType completo
                    const mimeMatch = imgParts[0].match(/data:image\/([^;]+)/);
                    if (mimeMatch && mimeMatch[1]) {
                        const mimePart = mimeMatch[1].toLowerCase();
                        // Normalizar para os tipos aceitos
                        if (mimePart === 'jpeg' || mimePart === 'jpg') {
                            mimeType = 'image/jpeg';
                        } else if (mimePart === 'png') {
                            mimeType = 'image/png';
                        } else if (mimePart === 'gif') {
                            mimeType = 'image/gif';
                        } else if (mimePart === 'webp') {
                            mimeType = 'image/webp';
                        } else {
                            mimeType = 'image/jpeg';
                        }
                    } else {
                        mimeType = 'image/jpeg';
                    }
                } else {
                    // Assumir que é base64 puro
                    base64 = img;
                    mimeType = 'image/jpeg';
                }
            } else if (img.base64) {
                base64 = img.base64.startsWith('data:image/') ? img.base64.split(',')[1] : img.base64;
                // Normalizar mimeType se fornecido
                if (img.mimeType) {
                    const mimeLower = img.mimeType.toLowerCase();
                    if (mimeLower === 'jpeg' || mimeLower === 'jpg' || mimeLower === 'image/jpeg') {
                        mimeType = 'image/jpeg';
                    } else if (mimeLower === 'png' || mimeLower === 'image/png') {
                        mimeType = 'image/png';
                    } else if (mimeLower === 'gif' || mimeLower === 'image/gif') {
                        mimeType = 'image/gif';
                    } else if (mimeLower === 'webp' || mimeLower === 'image/webp') {
                        mimeType = 'image/webp';
                    } else {
                        mimeType = 'image/jpeg';
                    }
                } else {
                    mimeType = 'image/jpeg';
                }
            }
            
            if (base64 && mimeType) {
                parts.push({
                    inlineData: {
                        mimeType: mimeType,
                        data: base64
                    }
                });
            }
        }
    }
    
    // Sempre adicionar o texto por último
    parts.push({ text: prompt });

    // Detectar tipo de resposta esperada
    const isScriptRequest = typeof prompt === 'string' && (
        prompt.includes('RESPOSTA FINAL - CRÍTICO') ||
        prompt.includes('roteiro em TEXTO SIMPLES') ||
        prompt.includes('NÃO use JSON') ||
        prompt.includes('Escreva APENAS o texto') ||
        prompt.includes('SEM JSON')
    );
    
    const isTitleListRequest = typeof prompt === 'string' && (
        prompt.includes('PROMPT FINAL — GERAÇÃO DE TÍTULOS VIRAIS') ||
        prompt.includes('Formato de lista numerada (não JSON)')
    );

    const generationConfig = {
            temperature: 0.7, 
            topK: 1, 
            topP: 1, 
            maxOutputTokens: 32000  // Aumentar para permitir gerar muitas cenas (31 cenas x ~1000 chars = ~31000 tokens)
    };
    
    // CRÍTICO: Só adicionar responseMimeType JSON se NÃO for pedido de roteiro OU lista de títulos
    // Para lista de títulos, deixar o Gemini retornar texto livre (lista numerada)
    if (!isScriptRequest && !isTitleListRequest) {
        generationConfig.responseMimeType = "application/json";
    }

    const payload = {
        contents: [{ parts: parts }],
        generationConfig: generationConfig,
    };

    // Retry logic com backoff exponencial para erro 429 (Resource exhausted)
    const maxRetries = 3;
    const baseDelay = 2000; // 2 segundos base
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
            const response = await fetch(GEMINI_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();

            if (!response.ok) {
                console.error('[La Casa Dark Core] Erro da API:', result);
                
                // Tratar erro de autenticação
                if (response.status === 400 && result.error?.message.includes('API key not valid')) {
                    throw new Error(`A sua Chave de API do Gemini é inválida.`);
                }
                
                // Tratar erro 429 (Resource exhausted) com retry
                if (response.status === 429 || (result.error?.message && result.error.message.includes('Resource exhausted'))) {
                    if (attempt < maxRetries) {
                        const delay = baseDelay * Math.pow(2, attempt); // Backoff exponencial: 2s, 4s, 8s
                        console.warn(`[La Casa Dark Core] Limite de requisições atingido (429). Tentativa ${attempt + 1}/${maxRetries + 1}. Aguardando ${delay}ms antes de tentar novamente...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue; // Tentar novamente
                    } else {
                        // Todas as tentativas falharam
                        throw new Error(`Limite de requisições atingido para a API Gemini. Aguarde alguns minutos ou use outro modelo de IA (Claude ou OpenAI). Detalhes: ${result.error?.message || response.statusText}`);
                    }
                }
                
                // Outros erros não relacionados a rate limit
                throw new Error(`Erro da API Gemini: ${result.error?.message || response.statusText}`);
            }
            
            // Sucesso - processar resposta
            if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0].text) {
                const content = result.candidates[0].content.parts[0].text;
                
                // Se for pedido de roteiro, retornar texto direto
                if (isScriptRequest) {
                    console.log('[La Casa Dark Core] Retornando texto puro de script');
                    return content; // Retorna string diretamente
                } else {
                    // Para JSON ou lista numerada, retornar conteúdo para parsing posterior
                    // O parseTitleAnalysisResponse vai detectar automaticamente o formato
                    return { titles: content, model: model };
                }
            } else {
                console.error('[La Casa Dark Core] Resposta inesperada da API:', result);
                throw new Error('A resposta da IA foi bloqueada ou retornou vazia.');
            }
        } catch (error) {
            // Se for erro de rate limit e ainda temos tentativas, continuar o loop
            if (error.message.includes('Resource exhausted') || error.message.includes('Limite de requisições')) {
                if (attempt < maxRetries) {
                    const delay = baseDelay * Math.pow(2, attempt);
                    console.warn(`[La Casa Dark Core] Erro detectado. Tentativa ${attempt + 1}/${maxRetries + 1}. Aguardando ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    continue;
                }
            }
            
            // Se não for erro de rate limit ou se esgotaram as tentativas, lançar erro
            console.error('[La Casa Dark Core] Falha ao chamar a API:', error);
            throw error;
        }
    }
}
async function callOpenAIAPI(prompt, apiKey, model, imageUrl = null, additionalImages = []) {
    if (!apiKey) throw new Error("Chave de API do Utilizador (OpenAI) não configurada.");
    
    const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
    
    const modelName = model; // Usar o nome do modelo diretamente do frontend

    const content = [];
    
    // Adicionar imagem principal se fornecida
    if (imageUrl) {
        content.push({
            type: "image_url",
            image_url: { "url": imageUrl, "detail": "high" }
        });
    }
    
    // Adicionar imagens adicionais (thumbnails de referência)
    if (Array.isArray(additionalImages) && additionalImages.length > 0) {
        for (const img of additionalImages) {
            let imgUrl;
            if (typeof img === 'string') {
                // Se for base64 string, usar diretamente
                imgUrl = img.startsWith('data:image/') ? img : `data:image/jpeg;base64,${img}`;
            } else if (img.base64) {
                imgUrl = img.base64.startsWith('data:image/') ? img.base64 : `data:image/jpeg;base64,${img.base64}`;
            }
            
            if (imgUrl) {
                content.push({
                    type: "image_url",
                    image_url: { "url": imgUrl, "detail": "high" }
                });
            }
        }
    }
    
    // Sempre adicionar o texto por último
    content.push({ type: "text", text: prompt });

    // Detectar tipo de resposta esperada
    const isScriptRequest = typeof prompt === 'string' && (
        prompt.includes('RESPOSTA FINAL - CRÍTICO') ||
        prompt.includes('roteiro em TEXTO SIMPLES') ||
        prompt.includes('NÃO use JSON') ||
        prompt.includes('Escreva APENAS o texto') ||
        prompt.includes('SEM JSON')
    );
    
    const isTitleListRequest = typeof prompt === 'string' && (
        prompt.includes('PROMPT FINAL — GERAÇÃO DE TÍTULOS VIRAIS') ||
        prompt.includes('Formato de lista numerada (não JSON)')
    );

    // Determinar max_tokens baseado no modelo
    // GPT-4o suporta no máximo 16384 tokens de completion
    // Outros modelos podem ter limites diferentes
    let maxTokens = 16384; // Padrão seguro para GPT-4o
    if (modelName && typeof modelName === 'string') {
        const modelLower = modelName.toLowerCase();
        if (modelLower.includes('gpt-4o')) {
            maxTokens = 16384; // Limite do GPT-4o
        } else if (modelLower.includes('gpt-4-turbo') || modelLower.includes('gpt-4-1106')) {
            maxTokens = 4096; // Limite de modelos GPT-4 Turbo mais antigos
        } else if (modelLower.includes('gpt-3.5')) {
            maxTokens = 4096; // Limite do GPT-3.5
        } else {
            // Para outros modelos, usar 16384 como padrão seguro
            maxTokens = 16384;
        }
    }

    const payload = {
        model: modelName,
        messages: [
            { 
                role: "system", 
                content: isScriptRequest 
                    ? "You are a professional scriptwriter. Respond ONLY with the script text in plain text format. Do NOT use JSON, objects, or special formatting. Write natural, flowing text."
                    : isTitleListRequest
                        ? "You are a viral YouTube title expert. Respond ONLY with a numbered list of titles following the exact format specified in the prompt. Do NOT use JSON, just a numbered list."
                    : "You are a helpful assistant designed to output JSON."
            },
            { role: "user", content: content }
        ],
        temperature: 0.7,
        max_tokens: maxTokens,
    };
    
    // CRÍTICO: Só adicionar response_format JSON se NÃO for pedido de roteiro OU lista de títulos
    if (!isScriptRequest && !isTitleListRequest) {
        payload.response_format = { type: "json_object" };
    }

    try {
        const response = await fetch(OPENAI_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify(payload)
        });
        const result = await response.json();

        if (!response.ok) {
            console.error('[La Casa Dark Core] Erro da API:', result);
            if (result.error?.code === 'invalid_api_key') {
                 throw new Error(`A sua Chave de API do OpenAI é inválida.`);
            }
            throw new Error(`Erro da API OpenAI: ${result.error?.message || response.statusText}`);
        }
        if (result.choices && result.choices[0].message && result.choices[0].message.content) {
            const content = result.choices[0].message.content;
            
            // Se for pedido de roteiro, retornar texto direto sem envolver em "titles"
            if (isScriptRequest) {
                console.log('[La Casa Dark Core] Retornando texto puro de script');
                return content; // Retorna string diretamente
            } else {
                // Para JSON, manter comportamento antigo
                return { titles: content, model: model };
            }
        } else {
            throw new Error('A resposta da IA (OpenAI) retornou vazia.');
        }
    } catch (error) {
        console.error('[La Casa Dark Core] Falha ao chamar a API:', error);
        throw error;
    }
}

async function callClaudeAPI(prompt, apiKey, model, imageUrl = null, customTimeout = null, additionalImages = []) {
    if (!apiKey) throw new Error("Chave de API do Utilizador (Claude) não configurada.");
    
    const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';
    
    // Mapeamento de nomes amigáveis para nomes corretos da API da Anthropic
    // MODELOS VÁLIDOS CONFIRMADOS (Novembro 2025 - Anthropic API):
    // - claude-3-7-sonnet-20250219 (Sonnet mais recente)
    // - claude-sonnet-4-20250514 (Sonnet 4)
    // - claude-opus-4-20250514 (Opus 4)
    const modelAliases = {
        'claude-3-5-sonnet-20241022': 'claude-3-7-sonnet-20250219',
        'claude-3-5-sonnet-20240620': 'claude-3-7-sonnet-20250219',
        'claude-3-5-sonnet-latest': 'claude-3-7-sonnet-20250219',
        'claude-3-sonnet-20240229': 'claude-3-7-sonnet-20250219',
        'claude-3.5-sonnet-20241022': 'claude-3-7-sonnet-20250219',
        'claude-3.5-sonnet-20240620': 'claude-3-7-sonnet-20250219',
        'claude-3-haiku-20240307': 'claude-3-7-sonnet-20250219',
        'claude-3.5-haiku-20241022': 'claude-3-7-sonnet-20250219',
        'claude-3-5-haiku-20241022': 'claude-3-7-sonnet-20250219',
        'claude-3-5-haiku-latest': 'claude-3-7-sonnet-20250219',
        'claude-3-opus-20240229': 'claude-opus-4-20250514'
    };
    
    const supportedModels = new Set([
        'claude-3-7-sonnet-20250219',  // Modelo mais recente
        'claude-sonnet-4-20250514',    // Sonnet 4
        'claude-opus-4-20250514'       // Opus 4
    ]);
    
    let modelName = modelAliases[model] || model;
    
    if (!supportedModels.has(modelName)) {
        if (model && model.toLowerCase().includes('opus')) {
            modelName = 'claude-opus-4-20250514';
        } else if (model && (model.toLowerCase().includes('sonnet') || model.toLowerCase().includes('4'))) {
            modelName = 'claude-sonnet-4-20250514';
        } else {
            modelName = 'claude-3-7-sonnet-20250219';
        }
        console.warn(`[Claude API] Modelo ${model} não reconhecido. Usando ${modelName} como padrão.`);
    }
    
    const validModels = ['claude-3-7-sonnet-20250219', 'claude-sonnet-4-20250514', 'claude-opus-4-20250514'];
    
    console.log(`[Claude API] Modelo original: ${model}, Modelo mapeado: ${modelName}`);

    const content = [];
    
    // Adicionar imagem principal se fornecida
    if (imageUrl) {
        const { base64, mimeType } = await fetchImageAsBase64(imageUrl);
        content.push({
            type: "image",
            source: {
                type: "base64",
                media_type: mimeType,
                data: base64
            }
        });
    }
    
    // Adicionar imagens adicionais (thumbnails de referência)
    if (Array.isArray(additionalImages) && additionalImages.length > 0) {
        for (const img of additionalImages) {
            let base64, mimeType;
            if (typeof img === 'string') {
                // Se for base64 string direto
                if (img.startsWith('data:image/')) {
                    const parts = img.split(',');
                    base64 = parts[1];
                    // Extrair mimeType completo (data:image/jpeg ou data:image/png, etc)
                    const mimeMatch = parts[0].match(/data:image\/([^;]+)/);
                    if (mimeMatch && mimeMatch[1]) {
                        const mimePart = mimeMatch[1].toLowerCase();
                        // Normalizar para os tipos aceitos pelo Claude API
                        if (mimePart === 'jpeg' || mimePart === 'jpg') {
                            mimeType = 'image/jpeg';
                        } else if (mimePart === 'png') {
                            mimeType = 'image/png';
                        } else if (mimePart === 'gif') {
                            mimeType = 'image/gif';
                        } else if (mimePart === 'webp') {
                            mimeType = 'image/webp';
                        } else {
                            // Default para jpeg se não reconhecer
                            mimeType = 'image/jpeg';
                        }
                    } else {
                        mimeType = 'image/jpeg';
                    }
                } else {
                    // Assumir que é base64 puro
                    base64 = img;
                    mimeType = 'image/jpeg';
                }
            } else if (img.base64) {
                base64 = img.base64.startsWith('data:image/') ? img.base64.split(',')[1] : img.base64;
                // Normalizar mimeType se fornecido
                if (img.mimeType) {
                    const mimeLower = img.mimeType.toLowerCase();
                    if (mimeLower === 'jpeg' || mimeLower === 'jpg' || mimeLower === 'image/jpeg') {
                        mimeType = 'image/jpeg';
                    } else if (mimeLower === 'png' || mimeLower === 'image/png') {
                        mimeType = 'image/png';
                    } else if (mimeLower === 'gif' || mimeLower === 'image/gif') {
                        mimeType = 'image/gif';
                    } else if (mimeLower === 'webp' || mimeLower === 'image/webp') {
                        mimeType = 'image/webp';
                    } else {
                        mimeType = 'image/jpeg';
                    }
                } else {
                    mimeType = 'image/jpeg';
                }
            }
            
            if (base64 && mimeType) {
                content.push({
                    type: "image",
                    source: {
                        type: "base64",
                        media_type: mimeType,
                        data: base64
                    }
                });
            }
        }
    }
    
    // Sempre adicionar o texto por último
    content.push({ type: "text", text: prompt });

    // Detectar tipo de resposta esperada
    const isScriptRequest = typeof prompt === 'string' && (
        prompt.includes('RESPOSTA FINAL - CRÍTICO') ||
        prompt.includes('roteiro em TEXTO SIMPLES') ||
        prompt.includes('NÃO use JSON')
    );
    
    const isTitleListRequest = typeof prompt === 'string' && (
        prompt.includes('PROMPT FINAL — GERAÇÃO DE TÍTULOS VIRAIS') ||
        prompt.includes('Formato de lista numerada (não JSON)')
    );

    const payload = {
        model: modelName,
        system: isScriptRequest 
            ? "Você é um roteirista profissional. Responda APENAS com o texto do roteiro, sem usar JSON, objetos ou formatações especiais. Escreva texto corrido e natural."
            : isTitleListRequest
                ? "Você é um especialista em títulos virais para YouTube. Responda APENAS com a lista numerada de títulos solicitada, seguindo exatamente o formato especificado no prompt. Não use JSON, apenas lista numerada."
            : "Responda APENAS com o objeto JSON solicitado, começando com { e terminando com }.",
        messages: [{ role: "user", content: content }],
        temperature: 0.7,
        max_tokens: 32000,  // Aumentar para permitir gerar muitas cenas (31 cenas x ~1000 chars = ~31000 tokens)
    };

    try {
        // Timeout de 120 segundos para evitar travamentos
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 120000);

        const response = await fetch(CLAUDE_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify(payload),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        const result = await response.json();
        
        // Log para debug (só primeiros 500 caracteres)
        if (isScriptRequest && result.content) {
            console.log('[Claude API] Resposta para roteiro (preview):', JSON.stringify(result).substring(0, 500));
        }

        if (!response.ok) {
            console.error('Erro da API Claude:', result);
            console.error(`[Claude API] Modelo tentado: ${modelName} (original: ${model})`);
            if (result.error?.type === 'authentication_error') {
                 throw new Error(`A sua Chave de API do Claude é inválvida.`);
            }
            // Mensagem de erro mais detalhada
            const errorMsg = result.error?.message || response.statusText;
            if (errorMsg.includes('model') || errorMsg.includes('invalid') || errorMsg.includes('not found') || errorMsg.includes('does not exist')) {
                // Tentar fallback automático com os modelos válidos mais recentes
    const validModels = ['claude-3-7-sonnet-20250219', 'claude-sonnet-4-20250514', 'claude-opus-4-20250514'];
                
                // Tentar outros modelos válidos se o atual falhou
                for (const altModel of validModels) {
                    if (altModel === modelName) continue; // Pular o modelo que já falhou
                    
                    try {
                        console.log(`[Claude API] Tentando modelo alternativo: ${altModel}`);
                        const fallbackPayload = { ...payload, model: altModel };
                        const fallbackResponse = await fetch(CLAUDE_API_URL, {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json',
                                'x-api-key': apiKey,
                                'anthropic-version': '2023-06-01'
                            },
                            body: JSON.stringify(fallbackPayload)
                        });
                        const fallbackResult = await fallbackResponse.json();
                        
                        if (fallbackResponse.ok && fallbackResult.content && fallbackResult.content[0] && fallbackResult.content[0].text) {
                            console.log(`[Claude API] Sucesso com modelo alternativo: ${altModel}`);
                            return { titles: fallbackResult.content[0].text, model: model };
                        }
                    } catch (fallbackErr) {
                        console.warn(`[Claude API] Fallback ${altModel} falhou:`, fallbackErr.message);
                        continue;
                    }
                }
                
                // Se todos os modelos válidos falharem, mostrar erro
                throw new Error(`Modelo Claude inválido ou não disponível: ${modelName}. Use um destes modelos válidos: ${validModels.join(', ')}. Erro da API: ${errorMsg}`);
            }
            throw new Error(`Erro da API Claude: ${errorMsg}`);
        }
        if (result.content && result.content[0] && result.content[0].text) {
            return { titles: result.content[0].text, model: model };
        } else {
            throw new Error('A resposta da IA (Claude) retornou vazia.');
        }
    } catch (error) {
        // Tratamento específico para timeout
        if (error.name === 'AbortError') {
            const timeoutSeconds = (customTimeout || 120000) / 1000;
            console.error(`[Claude API] ⏰ Timeout após ${timeoutSeconds} segundos`);
            throw new Error(`A API do Claude demorou muito para responder (timeout após ${timeoutSeconds}s). Tente novamente com um roteiro mais curto ou use outro modelo.`);
        }
        console.error('Falha ao chamar a API do Claude:', error);
        throw error;
    }
}

// Função para remover repetições de frases/parágrafos
function removeRepetitions(text) {
    if (!text) return text;
    
    const sentences = text.split(/[.!?]\s+/);
    const uniqueSentences = [];
    const seenSentences = new Set();
    
    for (const sentence of sentences) {
        const normalized = sentence.trim().toLowerCase().replace(/\s+/g, ' ');
        if (normalized.length > 20 && !seenSentences.has(normalized)) {
            uniqueSentences.push(sentence.trim());
            seenSentences.add(normalized);
        } else if (normalized.length <= 20) {
            uniqueSentences.push(sentence.trim());
        }
    }
    
    return uniqueSentences.join('. ') + '.';
}

/**
 * Remove marcações de roteiro (música, visual, narrador, etc.) deixando apenas texto para voice over
 * @param {string} script - Texto do roteiro com marcações
 * @returns {string} - Roteiro limpo apenas com texto para narração
 */
function cleanScriptForVoiceOver(script) {
    if (!script || typeof script !== 'string') return script;
    
    let cleaned = script;
    
    // Remover marcações de PARTE X com intervalos de tempo (mais agressivo)
    cleaned = cleaned.replace(/PARTE\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gi, ''); // Remove linha inteira com "PARTE 1 0:00 - 3:00"
    cleaned = cleaned.replace(/Parte\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gi, ''); // Remove linha inteira com "Parte 1 0:00 - 3:00"
    cleaned = cleaned.replace(/PARTE\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}/gi, ''); // Remove "PARTE 1 0:00 - 3:00" (sem quebra de linha)
    cleaned = cleaned.replace(/Parte\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}/gi, ''); // Remove "Parte 1 0:00 - 3:00" (sem quebra de linha)
    cleaned = cleaned.replace(/PARTE\s+\d+.*?(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})/gi, ''); // Remove "PARTE 1 0:00 - 3:00" (qualquer variação)
    cleaned = cleaned.replace(/Parte\s+\d+.*?(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})/gi, ''); // Remove "Parte 1 0:00 - 3:00" (qualquer variação)
    cleaned = cleaned.replace(/^\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gmi, ''); // Remove linha que começa com "0:00 - 3:00"
    cleaned = cleaned.replace(/^\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}\s*/gmi, ''); // Remove "0:00 - 3:00" no início da linha (sem quebra)
    cleaned = cleaned.replace(/PARTE\s+\d+\s*$/gmi, ''); // Remove "PARTE 1" sozinho no final da linha
    cleaned = cleaned.replace(/Parte\s+\d+\s*$/gmi, ''); // Remove "Parte 1" sozinho no final da linha
    
    // Remover marcações de música e sons entre parênteses
    cleaned = cleaned.replace(/\([^)]*[Mm]úsica[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([^)]*[Ss]om[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([^)]*[Aa]udio[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([^)]*[Tt]ela[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([^)]*[Cc]âmera[^)]*\)/gi, '');
    
    // Remover marcações de visual entre parênteses
    cleaned = cleaned.replace(/\([Vv]isual[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Vv]isualização[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Ii]magem[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Aa]nimação[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Cc]ena[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Mm]apa[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Rr]eencenação[^)]*\)/gi, '');
    
    // Remover marcações genéricas entre parênteses que começam com maiúscula (geralmente são direções)
    cleaned = cleaned.replace(/\([A-Z][^)]*\)/g, '');
    
    // Remover prefixos de narrador/personagem
    cleaned = cleaned.replace(/^NARRADOR:\s*/gmi, '');
    cleaned = cleaned.replace(/^NARRATOR:\s*/gmi, '');
    cleaned = cleaned.replace(/^VOZ:\s*/gmi, '');
    cleaned = cleaned.replace(/^VOICE:\s*/gmi, '');
    cleaned = cleaned.replace(/^[A-ZÁÉÍÓÚÀÈÌÒÙÂÊÎÔÛÃÕÇ]+:\s*/gm, ''); // Remove qualquer palavra em maiúsculas seguida de dois pontos no início da linha
    
    // Remover linhas que são apenas direções ou marcações
    cleaned = cleaned.split('\n')
        .map(line => {
            const trimmed = line.trim();
            // Remover linhas que são apenas parênteses vazios ou com conteúdo de direção
            if (trimmed.match(/^\([^)]*\)\s*$/)) return '';
            // Remover linhas muito curtas que são provavelmente marcações
            if (trimmed.length < 3 && trimmed.match(/^[A-Z\s]+$/)) return '';
            return line;
        })
        .filter(line => line.trim().length > 0)
        .join('\n');
    
    // Limpar múltiplas quebras de linha
    cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
    
    // Limpar espaços extras
    cleaned = cleaned.replace(/[ \t]+/g, ' ');
    cleaned = cleaned.replace(/\s+\n/g, '\n');
    cleaned = cleaned.replace(/\n\s+/g, '\n');
    
    // Remover espaços no início e fim
    cleaned = cleaned.trim();
    
    return cleaned;
}

function extractTextFromAIResponse(response) {
    if (response === null || response === undefined) {
        console.warn('[extractTextFromAIResponse] Response is null or undefined');
        return '';
    }
    
    // Se for string, retornar diretamente
    if (typeof response === 'string') {
        return response;
    }
    
    // Se for array, processar recursivamente
    if (Array.isArray(response)) {
        return response
            .map(item => extractTextFromAIResponse(item))
            .filter(Boolean)
            .join('\n');
    }
    
    // Se for objeto, tentar extrair de várias formas
    if (typeof response === 'object') {
        // PRIORIDADE 1: Claude retorna content como array de objetos com text
        if (response.content && Array.isArray(response.content)) {
            const extracted = response.content
                .map(item => {
                    if (typeof item === 'string') return item;
                    if (typeof item.text === 'string') return item.text;
                    if (typeof item.content === 'string') return item.content;
                    return '';
                })
                .filter(Boolean)
                .join('\n');
            
            if (extracted.trim().length > 0) {
                console.log('[extractTextFromAIResponse] ✅ Extracted from content array (Claude format)');
                return extracted;
            }
        }
        
        // PRIORIDADE 2: Campos específicos de roteiro (evitar "titles")
        const scriptFields = [
            'script',      // Roteiros
            'roteiro',     // Roteiro em PT
            'text',        // Campo genérico de texto
            'output_text', // Saída de texto
            'message',     // Mensagem
            'response',    // Resposta genérica
            'result'       // Resultado
        ];
        
        for (const field of scriptFields) {
            if (typeof response[field] === 'string' && response[field].trim().length > 0) {
                console.log(`[extractTextFromAIResponse] ✅ Extracted from field: ${field}`);
                return response[field];
            }
        }
        
        // PRIORIDADE 3: Campo "content" como string (Gemini)
        if (typeof response.content === 'string' && response.content.trim().length > 0) {
            console.log('[extractTextFromAIResponse] ✅ Extracted from content string');
            return response.content;
        }
        
        // ÚLTIMO RECURSO: "titles" (só se nada mais funcionar e tiver conteúdo real)
        if (typeof response.titles === 'string') {
            const trimmedTitles = response.titles.trim();
            // Verificar se tem conteúdo real (não apenas espaços/tabs/newlines)
            const hasRealContent = trimmedTitles.length > 50 && /[a-zA-Z0-9]{10,}/.test(trimmedTitles);
            if (hasRealContent) {
                console.warn('[extractTextFromAIResponse] ⚠️ Using "titles" field as fallback - this might be wrong for scripts!');
                return trimmedTitles;
            } else if (trimmedTitles.length > 0) {
                console.error(`[extractTextFromAIResponse] ❌ "titles" field has only whitespace (${trimmedTitles.length} chars): "${trimmedTitles.substring(0, 100)}"`);
            }
        }
        
        // Log completo do objeto para debug
        console.error('[extractTextFromAIResponse] ❌ Não encontrou texto em nenhum campo conhecido!');
        console.error('[extractTextFromAIResponse] Campos disponíveis:', Object.keys(response));
        console.error('[extractTextFromAIResponse] Objeto completo (primeiros 500 chars):', JSON.stringify(response).substring(0, 500));
        
        // Tentar JSON.stringify como último recurso (provavelmente vai falhar)
        try {
            const stringified = JSON.stringify(response);
            console.warn('[extractTextFromAIResponse] ⚠️ Had to stringify entire object:', stringified.substring(0, 200) + '...');
            return stringified;
        } catch {
            console.error('[extractTextFromAIResponse] ❌ Failed to stringify object');
            return String(response);
        }
    }
    
    console.warn('[extractTextFromAIResponse] ⚠️ Falling back to String conversion');
    return String(response);
}

function parseScenePromptsResponse(response) {
    let rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);

    if (!rawResponse || rawResponse.length === 0) {
        throw new Error('A resposta da IA veio vazia.');
    }

    console.log('[Scene Prompts Parser] Pré-processando resposta...');
    rawResponse = rawResponse
        .replace(/^```json\s*/i, '')
        .replace(/^```\s*/i, '')
        .replace(/\s*```\s*$/i, '')
        .trim();

    const sanitizeSceneArray = (scenes) => {
        if (!Array.isArray(scenes)) return [];
        return scenes
            .filter(scene => scene && (scene.prompt_text || scene.prompt || scene.text))
            .map((scene, index) => ({
                scene_number: scene.scene_number || scene.number || index + 1,
                scene_description: scene.scene_description || scene.description || `Cena ${scene.scene_number || scene.number || index + 1}`,
                prompt_text: scene.prompt_text || scene.prompt || scene.text || ''
            }));
    };

    const tryParseJson = (text) => {
        try {
            return JSON.parse(text);
        } catch {
            return null;
        }
    };

    let parsed = tryParseJson(rawResponse);
    if (parsed && parsed.scenes) {
        const scenes = sanitizeSceneArray(parsed.scenes);
        if (scenes.length > 0) return scenes;
    } else if (parsed && Array.isArray(parsed)) {
        const scenes = sanitizeSceneArray(parsed);
        if (scenes.length > 0) return scenes;
    }

    const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
        const cleaned = jsonMatch[0]
            .replace(/```json\s*/gi, '')
            .replace(/```\s*/g, '')
            .replace(/^[^{]*/, '')
            .replace(/[^}]*$/, '');

        parsed = tryParseJson(cleaned);
        if (parsed && parsed.scenes) {
            const scenes = sanitizeSceneArray(parsed.scenes);
            if (scenes.length > 0) return scenes;
        }
    }

    const scenesArrayMatch = rawResponse.match(/"scenes"\s*:\s*\[([\s\S]*?)\]/);
    if (scenesArrayMatch) {
        let scenesArrayStr = scenesArrayMatch[1];
        if (!scenesArrayStr.trim().endsWith('}')) {
            const sceneObjects = scenesArrayStr.match(/\{[^{}]*\}/g);
            if (sceneObjects && sceneObjects.length > 0) {
                scenesArrayStr = sceneObjects.join(',\n');
            }
        }

        const fallbackJson = tryParseJson(`{"scenes":[${scenesArrayStr}]}`);
        if (fallbackJson && fallbackJson.scenes) {
            const scenes = sanitizeSceneArray(fallbackJson.scenes);
            if (scenes.length > 0) return scenes;
        }
    }

    const scenePattern = /\{\s*"scene_number"\s*:\s*(\d+)[\s\S]*?"scene_description"\s*:\s*"([^"]*)"[\s\S]*?"prompt_text"\s*:\s*"([^"]*)"[\s\S]*?\}/g;
    const regexScenes = [];
    let match;
    while ((match = scenePattern.exec(rawResponse)) !== null) {
        regexScenes.push({
            scene_number: parseInt(match[1]),
            scene_description: match[2],
            prompt_text: match[3]
        });
    }
    if (regexScenes.length > 0) {
        console.log(`[Scene Prompts Parser] ✅ Extraídas ${regexScenes.length} cenas via regex padrão!`);
        return regexScenes;
    }

    const simpleScenePattern = /\{\s*"scene_number"\s*:\s*\d+[\s\S]*?\}/g;
    const simpleMatches = rawResponse.match(simpleScenePattern);
    if (simpleMatches && simpleMatches.length > 0) {
        const parsedScenes = [];
        simpleMatches.forEach((sceneStr, index) => {
            const sceneObject = tryParseJson(sceneStr);
            if (sceneObject && (sceneObject.prompt_text || sceneObject.prompt || sceneObject.text)) {
                parsedScenes.push({
                    scene_number: sceneObject.scene_number || sceneObject.number || index + 1,
                    scene_description: sceneObject.scene_description || sceneObject.description || `Cena ${sceneObject.scene_number || sceneObject.number || index + 1}`,
                    prompt_text: sceneObject.prompt_text || sceneObject.prompt || sceneObject.text || ''
                });
            }
        });
        if (parsedScenes.length > 0) {
            console.log(`[Scene Prompts Parser] ✅ Extraídas ${parsedScenes.length} cenas via fallback simples!`);
            return parsedScenes;
        }
    }

    throw new Error(`Não foi possível interpretar a resposta da IA como JSON válido. Conteúdo analisado (primeiros 500 chars): ${rawResponse.substring(0, 500)}`);
}

function buildScenePromptText({
    script,
    targetScenes,
    minScenes,
    maxScenes,
    wordCount,
    styleInstruction = '',
    imageModelInstruction = '',
    charactersInstruction = '',
    startSceneNumber = 1,
    isContinuation = false,
    previousScenes = []
}) {
    const previousSummary = previousScenes && previousScenes.length > 0
        ? `CENAS JÁ GERADAS (não repita):\n${previousScenes.slice(-5).map(scene => `- Cena ${scene.scene_number}: ${scene.scene_description}`).join('\n')}\n\n`
        : '';

    const continuationInstruction = isContinuation
        ? `Você já gerou ${startSceneNumber - 1} cenas. Continue a numeração a partir da cena ${startSceneNumber} e gere EXATAMENTE ${targetScenes} novas cenas sem repetir ou alterar as anteriores.\n`
        : `Divida o roteiro em aproximadamente ${targetScenes} cenas (entre ${minScenes} e ${maxScenes} cenas, se necessário).\n`;

    return `Você é um especialista em criação de prompts para geração de imagens usando IA.

${previousSummary}${continuationInstruction}
REGRAS IMPORTANTES:
1. Cada prompt deve ter entre 600-1200 caracteres.
2. Cada prompt deve ser em INGLÊS e otimizado para geração de imagens.
3. Seja específico e detalhado: descreva composição, iluminação, cores, atmosfera, personagens, cenário.
4. Use termos técnicos de fotografia/cinematografia quando apropriado.${styleInstruction}${imageModelInstruction}${charactersInstruction ? `\n${charactersInstruction}` : ''}
5. Os prompts devem ser fotorealísticos e cinematográficos, a menos que especificado outro estilo.
6. Se já existem cenas anteriores, continue a história sem repetir.

ROTEIRO:
"""
${script}
"""

FORMATO DE RESPOSTA (JSON):
{
  "scenes": [
    {
      "scene_number": ${startSceneNumber},
      "scene_description": "Breve descrição da cena em português",
      "prompt_text": "Prompt detalhado em inglês para geração de imagem"
    },
    ...
  ]
}

IMPORTANTE:
- Retorne APENAS o JSON, sem texto adicional.
- Gere EXATAMENTE ${targetScenes} novas cenas começando em ${startSceneNumber}.
- Continue a história exatamente do ponto onde parou, sem reiniciar a narrativa.
- Não repita cenas anteriores.`;
}

async function generateScenesWithRetries({
    apiFunc,
    apiKey,
    model,
    script,
    styleInstruction,
    imageModelInstruction,
    charactersInstruction,
    estimatedScenes,
    minScenes,
    maxScenes,
    wordCount,
    serviceLabel = 'AI',
    maxAttempts = 4
}) {
    let allScenes = [];
    let attempt = 0;
    let startSceneNumber = 1;
    let remainingScenes = estimatedScenes;

    while (remainingScenes > 0 && attempt < maxAttempts) {
        const targetScenes = remainingScenes;
        const prompt = buildScenePromptText({
            script,
            targetScenes,
            minScenes: Math.max(1, Math.min(minScenes, targetScenes)),
            maxScenes: Math.max(targetScenes, Math.min(maxScenes, targetScenes + 2)),
            wordCount,
            styleInstruction,
            imageModelInstruction,
            charactersInstruction,
            startSceneNumber,
            isContinuation: attempt > 0,
            previousScenes: allScenes
        });

        console.log(`[Scene Prompts][${serviceLabel}] Tentativa ${attempt + 1}: solicitando ${targetScenes} cenas (iniciando na cena ${startSceneNumber})`);

        const response = await apiFunc(prompt, apiKey, model);
        const parsedScenes = parseScenePromptsResponse(response);

        if (!parsedScenes || parsedScenes.length === 0) {
            console.warn(`[Scene Prompts][${serviceLabel}] Nenhuma cena retornada nesta tentativa.`);
            attempt++;
            continue;
        }

        const normalizedScenes = parsedScenes
            .map((scene, idx) => {
                const promptText = scene.prompt_text || scene.prompt || scene.text || '';
                if (!promptText.trim()) return null;
                return {
                    scene_number: startSceneNumber + idx,
                    scene_description: scene.scene_description || scene.description || `Cena ${startSceneNumber + idx}`,
                    prompt_text: promptText
                };
            })
            .filter(Boolean);

        if (normalizedScenes.length === 0) {
            console.warn(`[Scene Prompts][${serviceLabel}] As cenas retornadas estavam vazias.`);
            attempt++;
            continue;
        }

        allScenes = allScenes.concat(normalizedScenes);
        if (allScenes.length > estimatedScenes) {
            allScenes = allScenes.slice(0, estimatedScenes);
        }

        remainingScenes = estimatedScenes - allScenes.length;
        startSceneNumber = allScenes.length + 1;
        attempt++;
    }

    return allScenes;
}

function parseJSONFromString(text) {
    if (!text) return null;
    let cleaned = text.trim();
    cleaned = cleaned.replace(/^```json/i, '').replace(/^```/, '').replace(/```$/g, '').trim();
    
    try {
        return JSON.parse(cleaned);
    } catch (err) {
        const match = cleaned.match(/\{[\s\S]*\}/);
        if (match) {
            try {
                return JSON.parse(match[0]);
            } catch (innerErr) {
                return null;
            }
        }
        return null;
    }
}

/**
 * Chama a API do provedor externo
 */
async function callLaozhangAPI(prompt, apiKey, model = null, imageUrl = null, userId = null, operationType = 'api_call', details = null) {
    if (!apiKey) throw new Error("Chave de API do provedor externo não configurada.");
    
    // Endpoint oficial documentado (compatível com OpenAI)
    const possibleEndpoints = [LAOZHANG_CHAT_ENDPOINT];
    
    // Detectar se é pedido de roteiro (texto puro) ou JSON
    const isScriptRequest = typeof prompt === 'string' && (
        prompt.includes('RESPOSTA FINAL - CRÍTICO') ||
        prompt.includes('roteiro em TEXTO SIMPLES') ||
        prompt.includes('NÃO use JSON')
    );
    
    // Calcular tokens aproximados (input + output estimado)
    const promptTokens = Math.ceil((typeof prompt === 'string' ? prompt.length : JSON.stringify(prompt).length) / 4);
    // Para roteiros longos, estimar mais tokens de saída baseado no número de partes
    let estimatedOutputTokens = 2000; // Estimativa conservadora padrão
    if (isScriptRequest) {
        if (prompt.includes('partes')) {
            const partsMatch = prompt.match(/dividido em.*?(\d+).*?partes/i) || prompt.match(/EXATAMENTE (\d+) PARTES/i);
            const numParts = partsMatch ? parseInt(partsMatch[1]) : 1;
            // Estimativa: ~450 palavras por parte × 1.3 tokens por palavra × número de partes
            estimatedOutputTokens = Math.min(12000, Math.ceil(450 * 1.3 * numParts)); // Máximo 12000 tokens
            console.log(`[API] Estimativa de tokens de saída para ${numParts} partes: ${estimatedOutputTokens}`);
        } else if (operationType && operationType.includes('viral_agent')) {
            // Para agentes virais, estimar tokens baseado no max_tokens (geralmente 8192)
            // Usar 80% do max_tokens como estimativa conservadora
            estimatedOutputTokens = 6554; // ~80% de 8192
            console.log(`[API] Estimativa de tokens para agente viral: ${estimatedOutputTokens}`);
        }
    }
    const totalTokens = promptTokens + estimatedOutputTokens;
    
    // Debitar créditos ANTES da chamada se userId fornecido
    // IMPORTANTE: Esta função só deve ser chamada quando realmente deve usar créditos
    // A verificação de preferência já foi feita em getPreferredAIProvider
    let creditDebitResult = null;
    if (userId) {
        try {
            // Verificar novamente se realmente deve usar créditos (double-check)
            const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
            if (!creditsCheck.shouldUse) {
                console.warn('[callLaozhangAPI] ⚠️ Esta função foi chamada mas usuário não deve usar créditos. Verifique a lógica em getPreferredAIProvider.');
                throw new Error('Usuário não deve usar créditos. Use API própria.');
            }
            
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (laozhangProviderId) {
                creditDebitResult = await checkAndDebitCredits(
                    userId,
                    laozhangProviderId,
                    totalTokens,
                    operationType,
                    details || JSON.stringify({ model: modelToUse || model || 'gpt-4o', service: 'laozhang' })
                );
                console.log(`[API] 💰 Créditos debitados: ${creditDebitResult.creditsUsed.toFixed(4)}, Novo saldo: ${creditDebitResult.newBalance.toFixed(4)}`);
            }
        } catch (creditError) {
            console.error('[API] ❌ Erro ao debitar créditos:', creditError.message);
            // Se não tiver créditos suficientes, lançar erro
            if (creditError.message.includes('Créditos insuficientes')) {
                throw creditError;
            }
            // Se for outro erro, continuar mas logar
        }
    }
    
    // Se modelo não fornecido, usar 'gpt-4o' apenas como último recurso
    // Mas preferir extrair do details se disponível
    let modelToUse = model;
    if (!modelToUse && details) {
        try {
            const detailsObj = typeof details === 'string' ? JSON.parse(details) : details;
            modelToUse = detailsObj?.model || detailsObj?.selectedModel;
        } catch (e) {
            // Ignorar erro de parsing
        }
    }
    // Último fallback: usar 'gpt-4o' apenas se realmente não houver modelo
    modelToUse = modelToUse || 'gpt-4o';
    
    // Log do modelo que será usado na API
    console.log(`[callLaozhangAPI] 🎯 Enviando requisição para API com modelo: "${modelToUse}"`);
    
    const payload = {
        model: modelToUse,
        messages: [
            {
                role: 'system',
                content: isScriptRequest 
                    ? "Você é um roteirista profissional. Responda APENAS com o texto do roteiro, sem usar JSON, objetos ou formatações especiais. Escreva texto corrido e natural."
                    : "Responda APENAS com o objeto JSON solicitado, começando com { e terminando com }."
            },
            {
                role: 'user',
                content: prompt
            }
        ],
        temperature: 0.7,
        max_tokens: isScriptRequest ? 16384 : 16384  // Usar 16384 tokens (limite seguro da API Laozhang)
    };
    
    // Tentar diferentes endpoints até encontrar um que funcione
    let lastError = null;
    for (const endpoint of possibleEndpoints) {
        try {
            console.log(`[API] Tentando endpoint: ${endpoint}`);
            const controller = new AbortController();
            // Timeout dinâmico baseado no tipo de requisição: roteiros longos precisam de mais tempo
            // Para roteiros: 10 minutos base + 1 minuto por parte (mínimo 5 minutos, máximo 20 minutos)
            const isLongScript = isScriptRequest && prompt.includes('partes');
            // Aumentar timeout padrão para 5 minutos (300000ms) para dar mais tempo à API
            let timeoutDuration = 300000; // 5 minutos padrão (aumentado de 3 minutos)
            
            // Detectar se é requisição de scene prompts ou outras operações que podem demorar
            const isScenePrompts = operationType && operationType.includes('scene-prompts');
            const isViralAgent = operationType && operationType.includes('viral_agent');
            
            if (isLongScript) {
                // Tentar extrair número de partes do prompt
                const partsMatch = prompt.match(/dividido em.*?(\d+).*?partes/i) || prompt.match(/EXATAMENTE (\d+) PARTES/i);
                const numParts = partsMatch ? parseInt(partsMatch[1]) : 1;
                timeoutDuration = Math.min(1200000, Math.max(300000, 600000 + (numParts * 60000))); // 5-20 minutos
                console.log(`[API] Timeout ajustado para ${timeoutDuration / 1000 / 60} minutos (${numParts} partes)`);
            } else if (isScenePrompts || isViralAgent || isScriptRequest) {
                // Para scene prompts, tentar extrair número de cenas do metadata (details)
                let timeoutForScenes = 480000; // 8 minutos padrão
                const operationMetadata = details; // Usar details como operationMetadata
                if (isScenePrompts && operationMetadata) {
                    try {
                        const metadata = typeof operationMetadata === 'string' ? JSON.parse(operationMetadata) : operationMetadata;
                        if (metadata.estimatedScenes || metadata.timeout) {
                            // Se o metadata já tem timeout calculado, usar ele
                            timeoutForScenes = metadata.timeout || timeoutForScenes;
                            // Ou calcular baseado no número de cenas
                            if (metadata.estimatedScenes && !metadata.timeout) {
                                const baseTimeout = 300000; // 5 minutos
                                const timeoutPerScene = 2000; // 2 segundos por cena
                                const baseScenes = 20;
                                const calculatedTimeout = baseTimeout + (Math.max(0, metadata.estimatedScenes - baseScenes) * timeoutPerScene);
                                timeoutForScenes = Math.min(1200000, Math.max(300000, calculatedTimeout));
                            }
                            console.log(`[API] Timeout calculado dinamicamente: ${timeoutForScenes/1000}s para ${metadata.estimatedScenes || 'N/A'} cenas`);
                        }
                    } catch (e) {
                        console.warn(`[API] Erro ao parsear metadata: ${e.message}`);
                        // Se não conseguir parsear, usar padrão
                    }
                }
                timeoutDuration = timeoutForScenes;
                console.log(`[API] Timeout ajustado para ${timeoutDuration / 1000 / 60} minutos (${isScenePrompts ? 'scene prompts' : isViralAgent ? 'agente viral' : 'roteiro'})`);
            }
            const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);
            
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'Accept': 'application/json'
                },
                body: JSON.stringify(payload),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                const errorText = await response.text().catch(() => response.statusText);
                console.warn(`[API] Endpoint ${endpoint} retornou erro ${response.status}:`, errorText.substring(0, 500));
                
                // Tentar parsear o erro JSON para mais detalhes
                let errorDetails = errorText;
                try {
                    const errorJson = JSON.parse(errorText);
                    if (errorJson.error) {
                        errorDetails = JSON.stringify(errorJson.error);
                        console.error(`[API] Detalhes do erro:`, errorJson.error);
                    }
                } catch (e) {
                    // Não é JSON, usar texto direto
                }
                
                lastError = new Error(`Erro ${response.status}: ${errorDetails.substring(0, 200)}`);
                continue; // Tentar próximo endpoint
            }
            
            const result = await response.json();
            console.log(`[API] ✅ Sucesso com endpoint: ${endpoint}`);
            console.log('[API] Estrutura da resposta:', JSON.stringify(result).substring(0, 300));
            
            // Se tiver informações de uso de tokens na resposta, ajustar créditos
            if (userId && creditDebitResult && result.usage) {
                const actualTokens = (result.usage.prompt_tokens || promptTokens) + (result.usage.completion_tokens || estimatedOutputTokens);
                const actualCredits = (actualTokens / 1000) * (creditDebitResult.creditsUsed / (totalTokens / 1000));
                const difference = actualCredits - creditDebitResult.creditsUsed;
                
                if (Math.abs(difference) > 0.01) { // Ajustar apenas se diferença > 0.01 créditos
                    try {
                        const laozhangProviderId = await getLaozhangApiProviderId();
                        if (laozhangProviderId) {
                            // Ajustar saldo do usuário
                            await db.run(`
                                UPDATE user_credits 
                                SET balance = balance + ?, updated_at = CURRENT_TIMESTAMP 
                                WHERE user_id = ?
                            `, [creditDebitResult.creditsUsed - actualCredits, userId]);
                            
                            // Atualizar registro de uso
                            await db.run(`
                                UPDATE credit_usage 
                                SET credits_used = ?, units_consumed = ?
                                WHERE id = (SELECT id FROM credit_usage WHERE user_id = ? AND api_provider_id = ? ORDER BY id DESC LIMIT 1)
                            `, [actualCredits, actualTokens, userId, laozhangProviderId]);
                            
                            console.log(`[API] 💰 Créditos ajustados: ${difference > 0 ? '+' : ''}${difference.toFixed(4)}`);
                        }
                    } catch (adjustError) {
                        console.error('[API] ⚠️ Erro ao ajustar créditos:', adjustError.message);
                    }
                }
            }
            
            if (result.choices && result.choices[0] && result.choices[0].message) {
                const content = result.choices[0].message.content;
                
                console.log('[API] Resposta recebida (primeiros 200 chars):', content.substring(0, 200));
                
                if (isScriptRequest) {
                    console.log('[API] Retornando texto puro de script');
                    return content; // Retorna string diretamente
                } else {
                    // Para requisições JSON, retornar o conteúdo diretamente
                    return content;
                }
            } else if (result.content) {
                // Algumas APIs retornam content diretamente
                const content = typeof result.content === 'string' ? result.content : JSON.stringify(result.content);
                console.log('[API] Resposta recebida (formato alternativo)');
                return content;
            } else {
                console.warn(`[API] Estrutura de resposta inesperada em ${endpoint}:`, JSON.stringify(result).substring(0, 500));
                lastError = new Error('Estrutura de resposta inesperada');
                continue; // Tentar próximo endpoint
            }
        } catch (error) {
            // Se a chamada falhou e já debitamos créditos, reembolsar
            if (userId && creditDebitResult) {
                try {
                    await refundCredits(userId, creditDebitResult.creditsUsed, 'Erro ao processar solicitação');
                    console.log(`[API] 💰 Créditos reembolsados: ${creditDebitResult.creditsUsed.toFixed(4)}`);
                } catch (refundError) {
                    console.error('[API] ⚠️ Erro ao reembolsar créditos:', refundError.message);
                }
            }
            
            // Tratar erros de abort (timeout)
            if (error.name === 'AbortError') {
                console.error(`[API] ⏱️ Timeout após ${timeoutDuration / 1000 / 60} minutos ao tentar endpoint ${endpoint}`);
                lastError = new Error(`Timeout: A requisição demorou mais de ${timeoutDuration / 1000 / 60} minutos. Tente novamente ou use uma requisição menor.`);
                // Se não for o último endpoint, tentar próximo
                if (endpoint !== possibleEndpoints[possibleEndpoints.length - 1]) {
                    console.warn(`[API] Tentando próximo endpoint...`);
                    continue;
                }
                break; // Se for o último endpoint, sair do loop
            }
            
            // Tratar outros erros
            console.warn(`[API] Erro ao tentar endpoint ${endpoint}:`, error.message);
            lastError = error;
            // Se não for o último endpoint, tentar próximo
            if (endpoint !== possibleEndpoints[possibleEndpoints.length - 1]) {
                continue; // Tentar próximo endpoint
            }
        }
    }
    
    // Se chegou aqui, nenhum endpoint funcionou
    console.error('[API] ❌ Todos os endpoints falharam');
    throw lastError || new Error('Falha ao chamar a API: nenhum endpoint funcionou');
}

async function getPreferredAIProvider(userId, preferenceOrder = ['claude', 'openai', 'gemini']) {
    const defaultModels = {
        claude: 'claude-3-7-sonnet-20250219',  // Claude 3.7 Sonnet (Fev/2025)
        openai: 'gpt-4o',                       // GPT-4o (2025)
        gemini: 'gemini-2.5-pro',               // Gemini 2.5 Pro (2025)
        laozhang: 'gpt-4o'                      // Laozhang.ai (usa GPT-4o como padrão)
    };

    // PRIMEIRO: Verificar se laozhang.ai está configurada como padrão no admin
    try {
        const laozhangDefaultSetting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
        console.log('[AI Provider] Verificando configuração padrão:', laozhangDefaultSetting);
        
        let laozhangUseAsDefault = false;
        if (laozhangDefaultSetting) {
            try {
                const parsedValue = JSON.parse(laozhangDefaultSetting.value);
                laozhangUseAsDefault = parsedValue === true || parsedValue === 'true' || parsedValue === 1;
            } catch (e) {
                // Se não for JSON, verificar como string
                laozhangUseAsDefault = laozhangDefaultSetting.value === 'true' || laozhangDefaultSetting.value === '1';
            }
        }
        
        console.log('[AI Provider] laozhangUseAsDefault:', laozhangUseAsDefault);
        
        if (laozhangUseAsDefault) {
            const laozhangKey = await getLaozhangApiKey();
            console.log('[AI Provider] Chave de API encontrada:', laozhangKey ? 'Sim' : 'Não');
            if (laozhangKey) {
                console.log('[AI Provider] ✅ Usando API configurada como padrão (configuração do admin)');
                return {
                    service: 'laozhang',
                    apiKey: laozhangKey,
                    model: defaultModels.laozhang
                };
            } else {
                console.warn('[AI Provider] ⚠️ API configurada como padrão mas chave não encontrada');
            }
        } else {
            console.log('[AI Provider] Laozhang.ai não está configurada como padrão');
        }
    } catch (err) {
        console.error('[AI Provider] ❌ Erro ao verificar configuração padrão Laozhang.ai:', err.message);
    }

    // SEGUNDO: Verificar se deve usar créditos (laozhang.ai)
    // REGRA: Usa créditos SOMENTE se usuário marcou preferência OU não tem plano que permite API própria OU não tem API própria configurada
    // REGRA CRÍTICA: Se preferência NÃO está marcada E usuário tem plano que permite E tem API própria → usar API própria SEM verificar créditos
    try {
        // Primeiro, verificar a preferência do usuário
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
        const hasPreference = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // Se a preferência NÃO está marcada, verificar se pode usar API própria diretamente
        if (!hasPreference) {
            // Verificar se usuário tem plano que permite usar API própria
            let hasPlanPermission = false;
            try {
                const userData = await db.get('SELECT plan, subscription_plan, isAdmin FROM users WHERE id = ?', [userId]);
                if (userData) {
                    // Admin sempre tem permissão
                    if (userData.isAdmin === 1 || userData.isAdmin === true || String(userData.isAdmin) === '1') {
                        hasPlanPermission = true;
                    } else {
                        const planName = userData.subscription_plan || userData.plan || 'plan-free';
                        const permission = await db.get(
                            'SELECT is_allowed FROM plan_permissions WHERE plan_name = ? AND feature_name = ?',
                            [planName, 'api_propria']
                        );
                        hasPlanPermission = permission && permission.is_allowed === 1;
                    }
                }
            } catch (err) {
                console.warn('[AI Provider] Erro ao verificar permissão do plano:', err.message);
            }
            
            // Se tem plano que permite, verificar se tem API própria configurada
            if (hasPlanPermission) {
                for (const service of preferenceOrder) {
                    try {
                        const keyData = await db.get(
                            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                            [userId, service]
                        );
                        if (keyData && keyData.api_key) {
                            const decryptedKey = decrypt(keyData.api_key);
                            if (decryptedKey && decryptedKey.trim().length > 0) {
                                console.log(`[AI Provider] ✅ Usando API própria (preferência não marcada, tem plano e API configurada)`);
                                return {
                                    service,
                                    apiKey: decryptedKey,
                                    model: defaultModels[service] || 'gemini-2.0-flash'
                                };
                            }
                        }
                    } catch (err) {
                        console.warn(`[AI Provider] Erro ao buscar chave ${service}:`, err.message);
                    }
                }
            }
        }
        
        // Se chegou aqui, verificar se deve usar créditos (preferência marcada OU não tem plano OU não tem API)
        const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
        
        if (creditsCheck.shouldUse) {
            // Se deve usar créditos, usar laozhang.ai
            const laozhangKey = await getLaozhangApiKey();
            if (laozhangKey) {
                console.log(`[AI Provider] ✅ Usando Laozhang.ai (${creditsCheck.reason})`);
                return {
                    service: 'laozhang',
                    apiKey: laozhangKey,
                    model: defaultModels.laozhang
                };
            } else {
                console.warn('[AI Provider] ⚠️ Laozhang.ai não configurada, tentando usar APIs próprias do usuário');
            }
        } else {
            console.log(`[AI Provider] ✅ Usando API própria (${creditsCheck.reason})`);
        }
    } catch (err) {
        console.warn('[AI Provider] Erro ao verificar uso de créditos:', err.message);
    }

    // TERCEIRO: Se não usar laozhang.ai, usar APIs próprias do usuário
    for (const service of preferenceOrder) {
        try {
            const keyData = await db.get(
                'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                [userId, service]
            );
            if (keyData) {
                const decryptedKey = decrypt(keyData.api_key);
                if (decryptedKey) {
                    return {
                        service,
                        apiKey: decryptedKey,
                        model: defaultModels[service] || 'gemini-2.0-flash'
                    };
                }
            }
        } catch (err) {
            console.warn(`[AI Provider] Erro ao buscar chave ${service}:`, err.message);
        }
    }
    return null;
}

async function analyzeTranscriptForVirality({ userId, transcript, videoTitle, niche, subniche }) {
    const provider = await getPreferredAIProvider(userId, ['claude', 'openai', 'gemini']);
    if (!provider) {
        throw new Error('Configure uma chave do Claude, OpenAI ou Gemini para gerar a análise do roteiro.');
    }

    const sanitizedTranscript = transcript.trim();
    const truncatedTranscript = sanitizedTranscript.length > 20000
        ? `${sanitizedTranscript.substring(0, 20000)}\n[... conteúdo truncado para análise ...]`
        : sanitizedTranscript;

    const analysisPrompt = `
Você é um ESPECIALISTA EM CRIAÇÃO DE CONTEÚDO VIRAL para YouTube, com expertise em análise profunda de roteiros que alcançaram milhões de visualizações. Sua missão é DISSECAR este roteiro viral e criar uma FÓRMULA COMPLETA que permita gerar roteiros AINDA MAIS VIRAIS que o original, com ALTO PODER DE RETENÇÃO e VIRALIZAÇÃO.

OBJETIVO: Entregar uma fórmula viral detalhada que permita ao agente de roteiro criar conteúdos 10/10, superando o original em:
- Retenção de audiência (watch time)
- Taxa de engajamento (likes, comentários, compartilhamentos)
- Potencial de viralização
- Conexão emocional com o público
- Elementos de suspense e curiosidade

Retorne APENAS um JSON válido no formato:
{
  "resumo": "Síntese detalhada em 3-4 frases explicando a essência viral do roteiro",
  "motivosVirais": [
    "Motivo 1 com explicação detalhada",
    "Motivo 2 com explicação detalhada",
    "..."
  ],
  "gatilhosEmocionais": [
    {
      "gatilho": "Nome do gatilho emocional",
      "intensidade": "alta/média/baixa",
      "momentoAplicado": "Em qual parte do roteiro aparece",
      "comoIntensificar": "Como tornar ainda mais impactante"
    }
  ],
  "estruturaNarrativa": [
    {
      "etapa": "Nome da etapa",
      "descricao": "Descrição detalhada do que acontece",
      "tempoAproximado": "0:00-0:45",
      "elementosVirais": ["elemento 1", "elemento 2"],
      "pontoRetencao": "O que mantém o espectador assistindo nesta parte",
      "melhoriasSugeridas": "Como melhorar esta etapa para aumentar retenção"
    }
  ],
  "formulaChecklist": [
    {
      "item": "Elemento específico da fórmula viral",
      "status": "aplicado" ou "melhorar",
      "porqueFunciona": "Explicação científica/psicológica detalhada de POR QUE funciona",
      "comoAplicarNoMeuConteudo": "Diretriz prática e específica para replicar",
      "upgradeSugerido": "Ajuste específico para ficar 10/10 e SUPERAR o original",
      "exemploConcreto": "Exemplo prático de como aplicar"
    }
  ],
  "elementosRetencao": [
    {
      "elemento": "Nome do elemento de retenção",
      "comoFunciona": "Explicação detalhada",
      "momentoIdeal": "Quando aplicar no roteiro",
      "intensificacao": "Como intensificar para aumentar watch time"
    }
  ],
  "tecnicasViralizacao": [
    {
      "tecnica": "Nome da técnica",
      "descricao": "Como funciona",
      "aplicacao": "Como aplicar no roteiro",
      "potencialViral": "Por que tem potencial de viralizar"
    }
  ],
  "pontosClimaticos": [
    {
      "momento": "Descrição do momento climático",
      "tempoAproximado": "Quando acontece",
      "impactoEmocional": "Qual emoção desperta",
      "comoAmplificar": "Como tornar ainda mais impactante"
    }
  ],
  "diferencialProposto": "Diferencial específico e acionável para deixar o roteiro AINDA MELHOR que o original, com foco em retenção e viralização",
  "formulaViralCompleta": {
    "introducao": {
      "elementos": ["elemento 1", "elemento 2"],
      "tempoIdeal": "0:00-0:XX",
      "objetivo": "O que deve alcançar",
      "formula": "Fórmula específica para criar introdução virais"
    },
    "desenvolvimento": {
      "ritmo": "Ritmo ideal (lento/médio/rápido)",
      "elementos": ["elemento 1", "elemento 2"],
      "tecnicas": ["técnica 1", "técnica 2"],
      "formula": "Fórmula específica para manter engajamento"
    },
    "climax": {
      "elementos": ["elemento 1", "elemento 2"],
      "intensidade": "Nível de intensidade necessário",
      "formula": "Fórmula específica para criar clímax virais"
    },
    "fechamento": {
      "elementos": ["elemento 1", "elemento 2"],
      "cta": "Como fazer CTA eficaz",
      "formula": "Fórmula específica para fechamento que gera compartilhamentos"
    }
  },
  "sugestoesAplicacao": [
    "Ação específica 1 com detalhes",
    "Ação específica 2 com detalhes",
    "..."
  ],
  "roteiro10por10": {
    "caracteristicas": ["característica 1", "característica 2"],
    "diferenciais": ["diferencial 1", "diferencial 2"],
    "formula": "Fórmula completa para criar roteiros 10/10",
    "checklist": ["item 1", "item 2", "item 3"]
  },
  "alertas": [
    "Possíveis riscos ou pontos de atenção específicos",
    "..."
  ]
}

REGRAS CRÍTICAS:
- Idioma: português do Brasil.
- Seja EXTREMAMENTE DETALHADO e ESPECÍFICO em todas as respostas.
- Não copie trechos do roteiro; ANALISE e EXTRAIA os princípios virais.
- Foque em ENTREGAR uma fórmula que permita CRIAR roteiros SUPERIORES ao original.
- Cada elemento deve ter explicação do POR QUÊ funciona (base científica/psicológica quando possível).
- Forneça EXEMPLOS CONCRETOS e ACIONÁVEIS.
- A fórmula deve ser clara o suficiente para um agente de IA replicar e melhorar.
- Priorize elementos que aumentem RETENÇÃO (watch time) e VIRALIZAÇÃO (compartilhamentos).

CONTEXTO DO VÍDEO:
- Título: ${videoTitle || 'N/A'}
- Nicho: ${niche || 'N/A'}
- Subnicho: ${subniche || 'N/A'}

ROTEIRO COMPLETO PARA ANÁLISE:
"""${truncatedTranscript}"""

ANALISE ESTE ROTEIRO E ENTREGUE UMA FÓRMULA VIRAL COMPLETA QUE PERMITA CRIAR ROTEIROS 10/10, COM ALTO PODER DE RETENÇÃO E VIRALIZAÇÃO, SUPERANDO O ORIGINAL.`;

    let aiResponse;
        if (provider.service === 'laozhang') {
            aiResponse = await callLaozhangAPI(
                analysisPrompt, 
                provider.apiKey, 
                provider.model, 
                null, 
                userId, 
                'api_call', 
                JSON.stringify({ endpoint: '/api/scripts/generate', model: provider.model })
            );
        // callLaozhangAPI retorna string diretamente
        const responseText = typeof aiResponse === 'string' ? aiResponse : JSON.stringify(aiResponse);
        const parsed = parseJSONFromString(responseText);
        if (!parsed) {
            throw new Error('A IA retornou um formato inválido na análise do roteiro.');
        }
        return { analysis: parsed, provider: provider.service };
    } else if (provider.service === 'claude') {
        aiResponse = await callClaudeAPI(analysisPrompt, provider.apiKey, provider.model);
    } else if (provider.service === 'openai') {
        aiResponse = await callOpenAIAPI(analysisPrompt, provider.apiKey, provider.model);
    } else {
        aiResponse = await callGeminiAPI(analysisPrompt, provider.apiKey, provider.model);
    }

    const parsed = parseJSONFromString(extractTextFromAIResponse(aiResponse));
    if (!parsed) {
        throw new Error('A IA retornou um formato inválido na análise do roteiro.');
    }

    return { analysis: parsed, provider: provider.service };
}

/**
 * Função para gerar agente automático após análise da transcrição
 * Usa os prompts específicos fornecidos pelo usuário
 */
async function generateAgentFromTranscript({ userId, transcript, videoTitle, niche, subniche, analysis }) {
    const provider = await getPreferredAIProvider(userId, ['claude', 'openai', 'gemini']);
    if (!provider) {
        throw new Error('Configure uma chave do Claude, OpenAI ou Gemini para gerar o agente.');
    }

    const sanitizedTranscript = transcript.trim();
    const truncatedTranscript = sanitizedTranscript.length > 50000
        ? `${sanitizedTranscript.substring(0, 50000)}\n[... conteúdo truncado ...]`
        : sanitizedTranscript;

    // Construir o prompt completo com os 4 passos
    const agentPrompt = `
PASSO 1 - CRIAR ROTEIRO BASE:
Preciso que você me ajude a criar um agente de criação de roteiros em forma de documento no nicho de ${niche || 'N/A'} subnichado em ${subniche || 'N/A'}. 

Vou te mandar uma transcrição de um roteiro e quero que o agente crie roteiros com a mesma estrutura da TRANSCRIÇÃO. O agente deve criar os roteiros com parágrafos longos, cheios, sem quebras de linha excessivas e deve evitar termos técnicos como "capitulo x" ou "parte tal" deve seguir apenas com o conteúdo para facilitar que eu copie o roteiro para um documento. O agente deve produzir roteiros com em média 30 mil caracteres em ptbr. Preciso que o texto seja feito em um bloco único, sem separação por subtítulos ou tópicos e que não possua palavras destacadas em negrito ou algo do tipo. Esse texto vai ser narrado por uma IA, por isso peço que retire todos os travessões ou hifens em palavras ou frases, para que não ocorra nenhum tipo de bug na hora que a IA for narrar esse texto. Corte a introdução da resposta do prompt e vá direto ao texto traduzido. Mantenha a essência de um roteiro feito para youtube, como CTA de like e inscrição no canal.

PASSO 2 - INTRODUÇÃO:
Crie uma introdução breve e impactante para o vídeo com o título "${videoTitle || 'N/A'}" como referência no agente. A introdução deve ser envolvente, criar conexão com o público, gerar identificação imediata, tocar diretamente na dor que o espectador sente e apresentar a promessa de uma solução real e acessível. Use linguagem emocional, simples e direta, como se estivesse falando com alguém que sofre com esse problema há muito tempo. Utilize riqueza de detalhes e storytelling para o público se identificar.

PASSO 3 - CTA DE INSCRIÇÃO:
Crie um CTA de inscrição envolvente e humanizado para um canal desse nicho e subnicho específico voltado ao público que sofre com essa dor específica. O CTA deve incentivar a inscrição de forma acolhedora, sem pressão, destacando os benefícios de acompanhar o canal. Use linguagem simples, direta e emocional. O tom deve transmitir cuidado, confiança e autoridade.

PASSO 4 - CTA DE COMENTÁRIO:
Crie um CTA envolvente, localizado por volta de 1/3 do vídeo, que provoque o espectador a comentar. O trecho deve usar uma pergunta direta, gerar identificação com a dor ou dificuldade da audiência, e ativar emocionalmente a pessoa — como se ela estivesse sendo ouvida pela primeira vez. O texto deve induzir o comentário com uma frase pronta para copiar e colar, e fazer o espectador sentir que sua participação ajuda outras pessoas. Use um tom empático, acolhedor e de conversa íntima, como se estivesse falando com um amigo que sofre em silêncio.

CONTEXTO:
- Título do vídeo: ${videoTitle || 'N/A'}
- Nicho: ${niche || 'N/A'}
- Subnicho: ${subniche || 'N/A'}
- Análise da fórmula viral: ${JSON.stringify(analysis, null, 2)}

TRANSCRIÇÃO DE REFERÊNCIA:
"""${truncatedTranscript}"""

INSTRUÇÕES PARA O AGENTE:
Com base na transcrição acima e na análise da fórmula viral, crie um agente que:
1. Gere roteiros seguindo a mesma estrutura e estilo da transcrição
2. Use a introdução, CTA de inscrição e CTA de comentário criados acima
3. Mantenha o tom, estilo narrativo e elementos virais identificados na análise
4. Produza roteiros completos de aproximadamente 30.000 caracteres
5. Formate o texto como um bloco único, sem quebras excessivas ou formatação especial
6. Remova todos os travessões e hifens que possam causar problemas na narração por IA

Retorne APENAS um JSON válido no formato:
{
  "agentName": "Nome do agente baseado no nicho/subnicho",
  "agentDescription": "Descrição do agente",
  "agentInstructions": "Instruções completas para o agente seguir ao criar roteiros",
  "introduction": "Introdução criada no PASSO 2",
  "subscriptionCTA": "CTA de inscrição criado no PASSO 3",
  "commentCTA": "CTA de comentário criado no PASSO 4",
  "exampleScript": "Exemplo de roteiro completo seguindo a estrutura da transcrição (aprox. 2000 caracteres como exemplo)"
}`;

    let aiResponse;
    if (provider.service === 'laozhang') {
        aiResponse = await callLaozhangAPI(
            agentPrompt, 
            provider.apiKey, 
            provider.model, 
            null, 
            userId, 
            'api_call', 
            JSON.stringify({ endpoint: '/api/scripts/generate', model: provider.model })
        );
        const responseText = typeof aiResponse === 'string' ? aiResponse : JSON.stringify(aiResponse);
        const parsed = parseJSONFromString(responseText);
        if (!parsed) {
            throw new Error('A IA retornou um formato inválido na geração do agente.');
        }
        return { agent: parsed, provider: provider.service };
    } else if (provider.service === 'claude') {
        aiResponse = await callClaudeAPI(agentPrompt, provider.apiKey, provider.model);
    } else if (provider.service === 'openai') {
        aiResponse = await callOpenAIAPI(agentPrompt, provider.apiKey, provider.model);
    } else {
        aiResponse = await callGeminiAPI(agentPrompt, provider.apiKey, provider.model);
    }

    const parsed = parseJSONFromString(extractTextFromAIResponse(aiResponse));
    if (!parsed) {
        throw new Error('A IA retornou um formato inválido na geração do agente.');
    }

    return { agent: parsed, provider: provider.service };
}


// --- FUNÇÕES AUXILIARES DE VALIDAÇÃO DE CHAVE ---

async function validateGeminiKey(apiKey) {
    try {
        // Validação de formato básica
        if (!apiKey || typeof apiKey !== 'string' || apiKey.trim().length < 20) {
            return { success: false, error: 'Chave de API inválida: formato incorreto ou muito curta.' };
        }

        // Tentar primeiro com API do Gemini (generativelanguage.googleapis.com)
        // Para chaves de API do Gemini diretas
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // Timeout de 10 segundos
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${encodeURIComponent(apiKey)}`, {
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (response.status === 200) {
                const data = await response.json();
                if (data.models && data.models.length > 0) {
                    return { success: true, type: 'gemini-api', message: 'Chave de API do Gemini válida e funcional.' };
                }
            }
            const error = await response.json().catch(() => ({}));
            // Se der erro específico sobre API keys não suportadas, tentar Vertex AI
            if (error.error?.message && error.error.message.includes('API keys are not supported')) {
                console.log('[Validação Gemini] Chave é do Google Cloud (Vertex AI), não API key direta');
                // Continuar para validar como Google Cloud
            } else {
                return { success: false, error: error.error?.message || 'Chave inválida ou sem modelos acessíveis.' };
            }
        } catch (geminiErr) {
            if (geminiErr.name === 'AbortError') {
                return { success: false, error: 'Timeout: A validação demorou muito. Verifique sua conexão.' };
            }
            console.log('[Validação Gemini] Erro ao validar como API direta, tentando Google Cloud...', geminiErr.message);
        }
        
        // Tentar validar como chave do Google Cloud
        // Chaves do Google Cloud podem ser usadas para:
        // 1. Google Cloud Text-to-Speech (já implementado)
        // 2. Outros serviços do Google Cloud
        // Nota: Vertex AI geralmente requer OAuth2, mas a chave pode ser válida para outros serviços
        try {
            // Validar usando Google Cloud Text-to-Speech API (que já estamos usando)
            // Se a chave funcionar para TTS, ela é válida para serviços do Google Cloud
            const ttsController = new AbortController();
            const ttsTimeoutId = setTimeout(() => ttsController.abort(), 10000);
            const ttsResponse = await fetch(`https://texttospeech.googleapis.com/v1/voices?key=${encodeURIComponent(apiKey)}&languageCode=pt-BR`, {
                signal: ttsController.signal
            });
            clearTimeout(ttsTimeoutId);
            
            if (ttsResponse.status === 200) {
                const ttsData = await ttsResponse.json();
                if (ttsData.voices && ttsData.voices.length > 0) {
                    return { 
                        success: true, 
                        type: 'google-cloud', 
                        message: 'Chave do Google Cloud válida. Pode ser usada para Text-to-Speech e outros serviços do Google Cloud.'
                    };
                }
            } else if (ttsResponse.status === 401 || ttsResponse.status === 403) {
                const ttsError = await ttsResponse.json().catch(() => ({}));
                // Se a mensagem menciona que a API não está habilitada, a chave é válida mas precisa habilitar a API
                if (ttsError.error?.message && ttsError.error.message.includes('API has not been used')) {
                    return { 
                        success: true, 
                        type: 'google-cloud', 
                        message: 'Chave do Google Cloud válida. Habilite a API Text-to-Speech no Google Cloud Console para usar TTS.',
                        warning: 'A API Text-to-Speech precisa ser habilitada no Google Cloud Console.'
                    };
                }
                return { success: false, error: ttsError.error?.message || 'Chave inválida ou sem permissão para Text-to-Speech.' };
            } else {
                const ttsError = await ttsResponse.json().catch(() => ({}));
                return { success: false, error: ttsError.error?.message || 'Erro ao validar chave do Google Cloud.' };
            }
        } catch (cloudErr) {
            // Se ambos falharem, mas a chave parece ser do Google Cloud (baseado no erro original)
            // Retornar como válida mas com aviso
            console.log('[Validação Gemini] Erro ao validar Google Cloud:', cloudErr.message);
            return { 
                success: true, 
                type: 'google-cloud', 
                message: 'Chave do Google Cloud detectada. Pode ser usada para serviços do Google Cloud.',
                warning: 'Validação completa não foi possível. Certifique-se de que as APIs necessárias estão habilitadas no Google Cloud Console.'
            };
        }
    } catch (err) {
        return { success: false, error: err.message };
    }
}

async function validateOpenAIKey(apiKey) {
    try {
        // Validação de formato básica - OpenAI keys geralmente começam com sk-
        if (!apiKey || typeof apiKey !== 'string' || apiKey.trim().length < 20) {
            return { success: false, error: 'Chave de API inválida: formato incorreto ou muito curta.' };
        }
        
        if (!apiKey.trim().startsWith('sk-')) {
            return { success: false, error: 'Formato inválido: chaves OpenAI devem começar com "sk-".' };
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // Timeout de 10 segundos
        const response = await fetch('https://api.openai.com/v1/models', {
            headers: { 'Authorization': `Bearer ${apiKey}` },
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        
        if (response.status === 200) {
            const data = await response.json();
            if (data.data && Array.isArray(data.data) && data.data.length > 0) {
                return { success: true, message: 'Chave OpenAI válida e funcional.' };
            }
            return { success: true, message: 'Chave OpenAI válida.' };
        }
        
        const error = await response.json().catch(() => ({}));
        if (response.status === 401 || response.status === 403) {
            return { success: false, error: error.error?.message || 'Chave inválida ou sem permissão.' };
        }
        return { success: false, error: error.error?.message || `Erro na validação (status ${response.status})` };
    } catch (err) {
        if (err.name === 'AbortError') {
            return { success: false, error: 'Timeout: A validação demorou muito. Verifique sua conexão.' };
        }
        return { success: false, error: err.message || 'Erro ao conectar com a API OpenAI.' };
    }
}

async function validateClaudeKey(apiKey) {
    try {
        // Validação de formato básica - Claude keys geralmente começam com sk-ant-
        if (!apiKey || typeof apiKey !== 'string' || apiKey.trim().length < 20) {
            return { success: false, error: 'Chave de API inválida: formato incorreto ou muito curta.' };
        }
        
        if (!apiKey.trim().startsWith('sk-ant-')) {
            return { success: false, error: 'Formato inválido: chaves Claude devem começar com "sk-ant-".' };
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // Timeout de 10 segundos
        const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: { 
                'x-api-key': apiKey, 
                'anthropic-version': '2023-06-01',
                'content-type': 'application/json'
            },
            body: JSON.stringify({
                model: "claude-3-5-haiku-20241022", // Usar um modelo válido mais recente para validação
                max_tokens: 10,
                messages: [{ role: "user", content: "Test" }]
            }),
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        
        const data = await response.json();

        if (response.status === 200) {
            return { success: true, message: 'Chave Claude válida e funcional.' };
        } 
        else if (response.status === 401 || response.status === 403) {
            return { success: false, error: data.error?.message || data.error?.type || 'Chave inválida ou sem permissão.' };
        } 
        else if (response.status === 400 && data.error?.type === 'invalid_request_error') {
            // Claude pode retornar 400 para 'invalid_request_error' mesmo com chave válida se o prompt for muito curto,
            // mas a chave em si é válida. Consideramos sucesso para validação da chave.
            return { success: true, message: 'Chave Claude válida.' }; 
        }
        else {
            return { success: false, error: data.error?.message || data.error?.type || `Erro na validação (status ${response.status})` };
        }
    } catch (err) {
        if (err.name === 'AbortError') {
            return { success: false, error: 'Timeout: A validação demorou muito. Verifique sua conexão.' };
        }
        return { success: false, error: err.message || 'Erro ao conectar com a API Claude.' };
    }
}

async function validateYouTubeKey(apiKey) {
    try {
        // Validação de formato básica - YouTube API keys geralmente começam com AIza
        if (!apiKey || typeof apiKey !== 'string' || apiKey.trim().length < 20) {
            return { success: false, error: 'Chave de API inválida: formato incorreto ou muito curta.' };
        }
        
        if (!apiKey.trim().startsWith('AIza')) {
            return { success: false, error: 'Formato inválido: chaves YouTube Data API devem começar com "AIza".' };
        }

        // Testar a chave fazendo uma requisição simples de busca
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // Timeout de 10 segundos
        const response = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=1&q=test&type=video&key=${encodeURIComponent(apiKey)}`, {
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        
        if (response.status === 200) {
            const data = await response.json();
            if (data.items || data.pageInfo) {
                return { success: true, message: 'Chave YouTube Data API válida e funcional.' };
            }
            return { success: true, message: 'Chave YouTube Data API válida.' };
        }
        
        // Verificar erros específicos
        const data = await response.json();
        
        if (response.status === 400 && data.error?.errors?.[0]?.reason === 'keyInvalid') {
            return { success: false, error: 'Chave de API inválida ou malformada.' };
        }
        
        if (response.status === 403) {
            const reason = data.error?.errors?.[0]?.reason;
            if (reason === 'quotaExceeded') {
                // Se a cota foi excedida, a chave é válida mas sem créditos
                return { success: true, message: 'Chave válida, mas cota excedida.', warning: 'A cota diária da API foi excedida.' };
            } else if (reason === 'accessNotConfigured') {
                return { success: false, error: 'YouTube Data API v3 não está habilitada no Google Cloud Console.' };
            } else if (reason === 'forbidden') {
                return { success: false, error: 'Chave sem permissão para acessar a API YouTube.' };
            }
        }
        
        return { success: false, error: data.error?.message || data.error?.errors?.[0]?.message || 'Chave inválida ou com problemas de acesso.' };
    } catch (err) {
        if (err.name === 'AbortError') {
            return { success: false, error: 'Timeout: A validação demorou muito. Verifique sua conexão.' };
        }
        return { success: false, error: err.message || 'Erro ao conectar com a API YouTube.' };
    }
}


// --- MIDDLEWARE DE AUTENTICAÇÃO ---
const authenticateToken = (req, res, next) => {
    // Verificar se o banco de dados está inicializado
    if (!db) {
        return res.status(503).json({ msg: 'Servidor ainda não está pronto. Aguarde alguns instantes e tente novamente.' });
    }
    
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token == null) {
        return res.status(401).json({ msg: 'Token não fornecido.' });
    }

    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).json({ msg: 'Token inválido ou expirado.' });
        }
        req.user = user;
        next();
    });
};

const isAdmin = (req, res, next) => {
    if (!req.user || !req.user.isAdmin) {
        return res.status(403).json({ msg: 'Acesso negado. Requer privilégios de administrador.' });
    }
    next();
};

// ================================================
// SISTEMA DE CRÉDITOS - FUNÇÕES PRINCIPAIS
// ================================================

/**
 * Obtém a API padrão do admin (para uso com créditos)
 */
const getDefaultAdminApi = async () => {
    try {
        // Buscar API padrão ativa
        let api = await db.get(`
            SELECT * FROM api_providers 
            WHERE is_active = 1 AND is_default = 1
            LIMIT 1
        `);
        
        if (api) {
            return api;
        }
        
        // Se não tem padrão, buscar primeira API ativa
        api = await db.get(`
            SELECT * FROM api_providers 
            WHERE is_active = 1
            ORDER BY id ASC
            LIMIT 1
        `);
        
        return api || null;
    } catch (error) {
        console.error('❌ Erro ao buscar API padrão do admin:', error);
        return null;
    }
};

// Função para buscar chave de voz configurada no admin
const getAdminVoiceApiKey = async () => {
    try {
        const setting = await db.get(`
            SELECT value FROM app_settings 
            WHERE key = 'voice_api_key'
        `);
        
        if (setting && setting.value) {
            let apiKey = setting.value;
            
            // Tentar parsear como JSON (caso tenha sido salvo como JSON)
            try {
                const parsed = JSON.parse(setting.value);
                // Se o resultado do parse for uma string, usar ela
                if (typeof parsed === 'string') {
                    apiKey = parsed;
                }
            } catch (parseError) {
                // Se não for JSON, usar diretamente (já é string)
                apiKey = setting.value;
            }
            
            // Remover aspas extras se houver (caso tenha sido salvo como JSON string)
            if (apiKey.startsWith('"') && apiKey.endsWith('"')) {
                apiKey = apiKey.slice(1, -1);
            }
            
            // Validar se não está vazia
            if (apiKey && apiKey.trim().length > 0) {
                console.log('[getAdminVoiceApiKey] ✅ Chave encontrada (tamanho:', apiKey.length, 'caracteres)');
                return apiKey.trim();
            } else {
                console.log('[getAdminVoiceApiKey] ⚠️ Chave encontrada mas está vazia');
                return null;
            }
        }
        
        console.log('[getAdminVoiceApiKey] ❌ Nenhuma chave de voz encontrada no admin');
        return null;
    } catch (error) {
        console.error('Erro ao buscar chave de voz do admin:', error);
        return null;
    }
};

const normalizeAppSettingKey = (value) => {
    if (value === null || value === undefined) return null;
    let key = String(value);
    if (key.startsWith('"') && key.endsWith('"')) {
        key = key.slice(1, -1);
    }
    key = key.trim();
    return key.length >= 10 ? key : null;
};

const getAdminOpenAiVoiceApiKey = async () => {
    try {
        const setting = await db.get("SELECT value FROM app_settings WHERE key = 'openai_voice_api_key'");
        if (setting && setting.value) {
            let apiKey = setting.value;
            try {
                const parsed = JSON.parse(setting.value);
                if (typeof parsed === 'string') apiKey = parsed;
            } catch {
                apiKey = setting.value;
            }
            apiKey = normalizeAppSettingKey(apiKey);
            if (apiKey) {
                console.log('[getAdminOpenAiVoiceApiKey] ✅ Chave encontrada no admin');
                return apiKey;
            }
        }
        return null;
    } catch (error) {
        console.error('[getAdminOpenAiVoiceApiKey] ❌ Erro ao buscar chave OpenAI:', error);
        return null;
    }
};

const getAdminVideoApiKey = async () => {
    try {
        const setting = await db.get("SELECT value FROM app_settings WHERE key = 'video_api_key'");
        if (setting && setting.value) {
            let apiKey = setting.value;
            try {
                const parsed = JSON.parse(setting.value);
                if (typeof parsed === 'string') apiKey = parsed;
            } catch {
                apiKey = setting.value;
            }
            apiKey = normalizeAppSettingKey(apiKey);
            if (apiKey) {
                console.log('[getAdminVideoApiKey] ✅ Chave de vídeo encontrada no admin');
                return apiKey;
            }
        }
        return null;
    } catch (error) {
        console.error('[getAdminVideoApiKey] ❌ Erro ao buscar chave de vídeo:', error);
        return null;
    }
};

const cacheVideoOperationMetadata = async (operationId, userId, meta = {}) => {
    try {
        await db.run(`
            INSERT OR REPLACE INTO video_operations_cache (
                operation_id,
                user_id,
                api_key_source,
                user_key_id,
                admin_api_id,
                use_laozhang
            ) VALUES (?, ?, ?, ?, ?, ?)
        `, [
            operationId,
            userId,
            meta.apiKeySource || 'unknown',
            meta.userKeyId || null,
            meta.adminApiId || null,
            meta.useLaozhang ? 1 : 0
        ]);
        console.log('[VideoCache] Operação registrada:', operationId, meta.apiKeySource);
    } catch (error) {
        console.error('[VideoCache] Erro ao salvar operação:', error.message);
    }
};

const removeVideoOperationCache = async (operationId) => {
    try {
        await db.run('DELETE FROM video_operations_cache WHERE operation_id = ?', [operationId]);
    } catch (error) {
        console.error('[VideoCache] Erro ao remover operação:', error.message);
    }
};

const resolveCachedVideoApiKey = async (cacheRow) => {
    try {
        switch (cacheRow.api_key_source) {
            case 'panel_video':
                return await getAdminVideoApiKey();
            case 'user_gemini':
                if (!cacheRow.user_key_id) return null;
                const userKey = await db.get('SELECT api_key FROM user_api_keys WHERE id = ?', [cacheRow.user_key_id]);
                if (!userKey || !userKey.api_key) return null;
                if (userKey.api_key.includes(':')) {
                    try {
                        return decrypt(userKey.api_key);
                    } catch (err) {
                        console.warn('[VideoCache] Erro ao descriptografar chave do usuário:', err.message);
                        return userKey.api_key;
                    }
                }
                return userKey.api_key;
            case 'admin_provider':
                if (!cacheRow.admin_api_id) return null;
                const adminProvider = await db.get('SELECT * FROM api_providers WHERE id = ?', [cacheRow.admin_api_id]);
                if (!adminProvider || !adminProvider.api_key) return null;
                if (adminProvider.api_key.includes(':')) {
                    try {
                        return decrypt(adminProvider.api_key);
                    } catch (err) {
                        console.warn('[VideoCache] Erro ao descriptografar chave do admin provider:', err.message);
                        return adminProvider.api_key;
                    }
                }
                return adminProvider.api_key;
            case 'laozhang':
                return await getLaozhangApiKey();
            default:
                return null;
        }
    } catch (error) {
        console.error('[VideoCache] Erro ao resolver chave para operação:', cacheRow.operation_id, error.message);
        return null;
    }
};

const rehydratePendingVideoOperations = async () => {
    try {
        const pending = await db.all('SELECT * FROM video_operations_cache');
        if (!pending || pending.length === 0) {
            console.log('[VideoCache] Nenhuma operação pendente para reidratar.');
            return;
        }
        
        console.log(`[VideoCache] Reidratando ${pending.length} operação(ões) de vídeo pendentes...`);
        for (const row of pending) {
            const apiKey = await resolveCachedVideoApiKey(row);
            if (!apiKey) {
                console.warn('[VideoCache] Não foi possível recuperar chave para operação:', row.operation_id);
                continue;
            }
            
            const operationData = {
                userId: row.user_id,
                operation: { name: row.operation_id },
                status: 'processing',
                useAdminApi: row.api_key_source === 'admin_provider',
                adminApi: null,
                useLaozhang: row.use_laozhang === 1
            };
            
            if (row.admin_api_id) {
                operationData.adminApi = await db.get('SELECT * FROM api_providers WHERE id = ?', [row.admin_api_id]);
            }
            
            videoOperations.set(row.operation_id, operationData);
            pollVideoOperation(row.operation_id, apiKey);
        }
    } catch (error) {
        console.error('[VideoCache] Erro ao reidratar operações pendentes:', error.message);
    }
};

/**
 * Obtém a chave da API Laozhang.ai das configurações da aplicação
 */
const getLaozhangApiKey = async () => {
    try {
        const setting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_api_key'");
        if (setting && setting.value) {
            try {
                const parsed = JSON.parse(setting.value);
                // Se for objeto, extrair api_key se existir, senão retornar o objeto
                if (typeof parsed === 'object' && parsed !== null) {
                    if (parsed.api_key) {
                        return parsed.api_key;
                    } else if (parsed.key) {
                        return parsed.key;
                    } else {
                        // Se for objeto sem api_key, tentar converter para string
                        return JSON.stringify(parsed);
                    }
                }
                return parsed;
            } catch (e) {
                // Se não for JSON, retornar como string
                const value = String(setting.value).trim();
                if (value && value.length > 10) {
                    return value;
                }
                return null;
            }
        }
        return null;
    } catch (error) {
        console.error('❌ Erro ao buscar chave Laozhang.ai:', error);
        return null;
    }
};

/**
 * Obtém o ID do provider Laozhang.ai da tabela api_providers
 */
const getLaozhangApiProviderId = async () => {
    try {
        const provider = await db.get("SELECT id FROM api_providers WHERE provider = 'laozhang' AND is_active = 1 LIMIT 1");
        if (provider) {
            return provider.id;
        }
        // Se não existir, criar um provider padrão para Laozhang
        const result = await db.run(`
            INSERT INTO api_providers (
                name, provider, model, api_key, unit_type, unit_size,
                real_cost_per_unit, credits_per_unit, markup, is_premium,
                is_active, is_default
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
            'Laozhang.ai', 'laozhang', 'gpt-4o', '', 'tokens', 1000,
            0.0, 1.0, 1.0, 0, 1, 0
        ]);
        return result.lastID;
    } catch (error) {
        console.error('❌ Erro ao buscar/criar provider Laozhang.ai:', error);
        return null;
    }
};

/**
 * Determina se deve usar créditos (laozhang.ai) ou API própria
 * REGRA: Usa créditos se:
 * 1. Usuário marcou preferência para usar créditos, OU
 * 2. Usuário NÃO tem plano que permite API própria, OU
 * 3. Usuário tem plano que permite mas NÃO tem API própria configurada
 * 
 * REGRA CRÍTICA: Se preferência NÃO estiver marcada E usuário tem plano que permite API própria E tem API própria configurada → usar API própria
 * 
 * @param {number} userId - ID do usuário
 * @param {string[]} services - Lista de serviços para verificar (ex: ['claude', 'openai', 'gemini'])
 * @returns {Promise<{shouldUse: boolean, reason: string, hasOwnApi: boolean, hasPreference: boolean, hasPlanPermission: boolean}>}
 */
async function shouldUseCredits(userId, services = ['claude', 'openai', 'gemini']) {
    try {
        // Verificar preferência do usuário PRIMEIRO
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
        const hasPreference = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // REGRA CRÍTICA: Se preferência NÃO está marcada, verificar se pode usar API própria
        // Se pode usar API própria, NÃO deve usar créditos (não precisa nem verificar saldo)
        if (!hasPreference) {
            // Verificar se usuário tem plano que permite usar API própria
            let hasPlanPermission = false;
            try {
                const userData = await db.get('SELECT plan, subscription_plan, isAdmin FROM users WHERE id = ?', [userId]);
                if (userData) {
                    // Admin sempre tem permissão
                    if (userData.isAdmin === 1 || userData.isAdmin === true || String(userData.isAdmin) === '1') {
                        hasPlanPermission = true;
                    } else {
                        const planName = userData.subscription_plan || userData.plan || 'plan-free';
                        const permission = await db.get(
                            'SELECT is_allowed FROM plan_permissions WHERE plan_name = ? AND feature_name = ?',
                            [planName, 'api_propria']
                        );
                        hasPlanPermission = permission && permission.is_allowed === 1;
                    }
                }
            } catch (err) {
                console.warn('[shouldUseCredits] Erro ao verificar permissão do plano:', err.message);
            }
            
            // Se tem plano que permite, verificar se tem API própria configurada
            if (hasPlanPermission) {
                let hasOwnApi = false;
                for (const service of services) {
                    try {
                        const keyData = await db.get(
                            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                            [userId, service]
                        );
                        if (keyData && keyData.api_key) {
                            const decryptedKey = decrypt(keyData.api_key);
                            if (decryptedKey && decryptedKey.trim().length > 0) {
                                hasOwnApi = true;
                                break;
                            }
                        }
                    } catch (err) {
                        // Ignorar erros individuais
                    }
                }
                
                // Se tem plano E tem API própria → NÃO usar créditos (retornar imediatamente)
                if (hasOwnApi) {
                    console.log(`[shouldUseCredits] userId: ${userId}, shouldUse: false, reason: Preferência não marcada, tem plano e API própria - NÃO usar créditos`);
                    return {
                        shouldUse: false,
                        reason: 'Preferência não marcada, usuário tem plano que permite API própria e tem API própria configurada',
                        hasOwnApi: true,
                        hasPreference: false,
                        hasPlanPermission: true
                    };
                }
            }
        }
        
        // Se preferência estiver marcada, SEMPRE usar créditos
        if (hasPreference) {
            console.log(`[shouldUseCredits] userId: ${userId}, shouldUse: true, reason: Preferência do usuário marcada para usar créditos`);
            return {
                shouldUse: true,
                reason: 'Preferência do usuário marcada para usar créditos',
                hasOwnApi: false,
                hasPreference: true,
                hasPlanPermission: false
            };
        }
        
        // Se chegou aqui, não tem preferência marcada mas também não tem plano/permissão ou não tem API própria
        // Verificar se usuário tem plano que permite usar API própria
        let hasPlanPermission = false;
        try {
            const userData = await db.get('SELECT plan, subscription_plan, isAdmin FROM users WHERE id = ?', [userId]);
            if (userData) {
                // Admin sempre tem permissão
                if (userData.isAdmin === 1 || userData.isAdmin === true || String(userData.isAdmin) === '1') {
                    hasPlanPermission = true;
                } else {
                    const planName = userData.subscription_plan || userData.plan || 'plan-free';
                    const permission = await db.get(
                        'SELECT is_allowed FROM plan_permissions WHERE plan_name = ? AND feature_name = ?',
                        [planName, 'api_propria']
                    );
                    hasPlanPermission = permission && permission.is_allowed === 1;
                }
            }
        } catch (err) {
            console.warn('[shouldUseCredits] Erro ao verificar permissão do plano:', err.message);
        }
        
        // Se não tem plano que permite API própria, usar créditos
        if (!hasPlanPermission) {
            console.log(`[shouldUseCredits] userId: ${userId}, shouldUse: true, reason: Usuário não tem plano que permite usar API própria`);
            return {
                shouldUse: true,
                reason: 'Usuário não tem plano que permite usar API própria',
                hasOwnApi: false,
                hasPreference: false,
                hasPlanPermission: false
            };
        }
        
        // Se tem plano mas não tem API própria configurada, usar créditos
        console.log(`[shouldUseCredits] userId: ${userId}, shouldUse: true, reason: Usuário tem plano mas não tem API própria configurada`);
        return {
            shouldUse: true,
            reason: 'Usuário tem plano que permite API própria mas não tem API própria configurada',
            hasOwnApi: false,
            hasPreference: false,
            hasPlanPermission: true
        };
    } catch (error) {
        console.error('[shouldUseCredits] Erro:', error);
        // Em caso de erro, por padrão usar créditos (mais seguro)
        return {
            shouldUse: true,
            reason: 'Erro ao verificar configurações, usando créditos por padrão',
            hasOwnApi: false,
            hasPreference: false,
            hasPlanPermission: false
        };
    }
}

/**
 * Verifica e debita créditos do usuário
 */
const checkAndDebitCredits = async (userId, apiProviderId, unitsConsumed, operationType = 'api_call', details = null) => {
    try {
        // Obter informações da API
        const apiProvider = await db.get(`
            SELECT credits_per_unit, unit_type, unit_size, name 
            FROM api_providers 
            WHERE id = ? AND is_active = 1
        `, [apiProviderId]);

        if (!apiProvider) {
            throw new Error('API provider não encontrada ou inativa');
        }

        // Aplicar multiplicador TTS se for operação de TTS
        let creditsPerUnit = apiProvider.credits_per_unit;
        if (operationType && (operationType.includes('tts') || operationType.includes('TTS') || operationType === 'api_tts_generation' || operationType === 'api_tts_preview')) {
            const ttsMultiplierSetting = await db.get("SELECT value FROM app_settings WHERE key = 'tts_credits_multiplier'");
            const ttsMultiplier = ttsMultiplierSetting ? parseFloat(ttsMultiplierSetting.value) : 1.0;
            
            if (ttsMultiplier > 0 && ttsMultiplier !== 1.0) {
                creditsPerUnit = apiProvider.credits_per_unit * ttsMultiplier;
                console.log(`🔊 [TTS] Aplicando multiplicador de ${ttsMultiplier}x ao custo de créditos para TTS. Custo base: ${apiProvider.credits_per_unit}, Custo final: ${creditsPerUnit.toFixed(4)}`);
            }
        }

        // Calcular créditos necessários
        const creditsNeeded = (unitsConsumed / apiProvider.unit_size) * creditsPerUnit;

        // Verificar saldo
        let userCredits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [userId]);
        
        if (!userCredits) {
            // Criar registro se não existir
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [userId]);
            userCredits = { balance: 0 };
        }

        if (userCredits.balance < creditsNeeded) {
            throw new Error(`Créditos insuficientes. Necessário: ${creditsNeeded.toFixed(2)}, Disponível: ${userCredits.balance.toFixed(2)}`);
        }

        // Debitar créditos
        const newBalance = userCredits.balance - creditsNeeded;
        await db.run(`
            UPDATE user_credits 
            SET balance = ?, updated_at = CURRENT_TIMESTAMP 
            WHERE user_id = ?
        `, [newBalance, userId]);

        // Registrar uso
        await db.run(`
            INSERT INTO credit_usage (
                user_id, api_provider_id, credits_used, 
                units_consumed, operation_type, details
            ) VALUES (?, ?, ?, ?, ?, ?)
        `, [userId, apiProviderId, creditsNeeded, unitsConsumed, operationType, details || JSON.stringify({ model: operationType })]);
        
        // Mapear operationType e endpoints para nomes amigáveis de ferramentas
        // IMPORTANTE: NUNCA incluir nome do fornecedor de API (Laozhang.ai, etc)
        const toolNames = {
            // ===== GERADOR DE ROTEIRO =====
            'api_script_agents_generate': 'Gerador de Roteiro',
            '/api/generate': 'Gerador de Roteiro',
            '/api/scripts': 'Gerador de Roteiro',
            '/api/scripts/generate': 'Gerador de Roteiro',
            '/api/script-agents/:agentId/generate': 'Gerador de Roteiro',
            '/api/script-agents/:agentId/generate/laozhang': 'Gerador de Roteiro',
            'viral_agent_chat': 'Agente Viral',
            'viral_agent': 'Agente Viral',
            
            // ===== GERADOR DE VÍDEO =====
            'api_video_generation': 'Gerador de Vídeo',
            
            // ===== GERAÇÃO DE VOZ (TTS) =====
            'api_tts_generation': 'Geração de Voz',
            'api_tts_preview': 'Preview de Voz',
            
            // ===== GERAÇÃO DE IMAGEM =====
            'api_image_generation': 'Geração de Imagem',
            
            // ===== GERADOR DE THUMBNAIL =====
            'api_analyze_thumbnail': 'Gerador de Thumbnail',
            '/api/analyze/thumbnail': 'Gerador de Thumbnail',
            '/api/analyze/thumbnail/laozhang': 'Gerador de Thumbnail',
            
            // ===== GERADOR DE CENAS =====
            '/api/generate/scene-prompts': 'Gerador de Cenas',
            '/api/generate/scene-prompts/laozhang': 'Gerador de Cenas',
            
            // ===== ANÁLISE DE TÍTULOS =====
            '/api/analyze/titles': 'Análise de Títulos',
            '/api/analyze/titles/laozhang': 'Análise de Títulos',
            
            // ===== DETECÇÃO DE PERSONAGENS =====
            'api_detect_characters': 'Detecção de Personagens',
            '/api/detect/characters': 'Detecção de Personagens',
            '/api/detect/characters/laozhang': 'Detecção de Personagens',
            
            // ===== BUSCA DE SUBNICHO =====
            'api_niche_find_subniche': 'Busca de Subnicho',
            '/api/niche/find-subniche': 'Busca de Subnicho',
            '/api/niche/find-subniche/laozhang': 'Busca de Subnicho',
            
            // ===== ANÁLISE DE COMPETIDOR =====
            'api_niche_analyze_competitor': 'Análise de Competidor',
            '/api/niche/analyze-competitor': 'Análise de Competidor',
            '/api/niche/analyze-competitor/laozhang': 'Análise de Competidor',
            
            // ===== CRIAÇÃO DE AGENTE =====
            '/api/script-agents/create': 'Criação de Agente',
            '/api/script-agents/create/laozhang': 'Criação de Agente',
            
            // ===== REESCREVER PROMPT =====
            'api_rewrite_prompt': 'Reescrever Prompt',
            '/api/rewrite/blocked-prompt': 'Reescrever Prompt',
            '/api/rewrite/blocked-prompt/laozhang': 'Reescrever Prompt',
            
            // ===== ANÁLISE DE TRANSCRIÇÃO =====
            'api_transcript_analyze': 'Análise de Transcrição',
            '/api/video/transcript/analyze': 'Análise de Transcrição',
            '/api/video/transcript/analyze/laozhang': 'Análise de Transcrição',
            
            // ===== GERADOR DE METADADOS YOUTUBE =====
            '/api/youtube/generate-metadata': 'Gerador de Metadados YouTube',
            
            // ===== GENÉRICOS (fallback) =====
            'api_generation': 'Geração de Conteúdo',
            'api_call': 'Ferramenta'
        };
        
        const detailsObj = typeof details === 'string' ? JSON.parse(details) : (details || {});
        
        // Determinar nome da ferramenta - tentar múltiplas fontes
        let toolName = toolNames[operationType];
        
        // Se não encontrou pelo operationType, tentar pelo endpoint nos details
        if (!toolName && detailsObj?.endpoint) {
            // Tentar match parcial do endpoint
            for (const [key, value] of Object.entries(toolNames)) {
                if (detailsObj.endpoint.includes(key) || key.includes(detailsObj.endpoint)) {
                    toolName = value;
                    break;
                }
            }
        }
        
        // Se ainda não encontrou, tentar inferir pelo operationType ou endpoint
        if (!toolName) {
            const searchKey = operationType || detailsObj?.endpoint || '';
            
            // Buscar por palavras-chave no operationType ou endpoint
            if (searchKey.includes('script') || searchKey.includes('roteiro') || searchKey.includes('agent')) {
                toolName = 'Gerador de Roteiro';
            } else if (searchKey.includes('video') || searchKey.includes('vídeo')) {
                toolName = 'Gerador de Vídeo';
            } else if (searchKey.includes('tts') || searchKey.includes('voz') || searchKey.includes('voice')) {
                toolName = 'Geração de Voz';
            } else if (searchKey.includes('image') || searchKey.includes('imagem')) {
                toolName = 'Geração de Imagem';
            } else if (searchKey.includes('thumbnail') || searchKey.includes('thumb')) {
                toolName = 'Gerador de Thumbnail';
            } else if (searchKey.includes('scene') || searchKey.includes('cena')) {
                toolName = 'Gerador de Cenas';
            } else if (searchKey.includes('title') || searchKey.includes('título')) {
                toolName = 'Análise de Títulos';
            } else if (searchKey.includes('character') || searchKey.includes('personagem')) {
                toolName = 'Detecção de Personagens';
            } else if (searchKey.includes('subniche') || searchKey.includes('sub-nicho')) {
                toolName = 'Busca de Subnicho';
            } else if (searchKey.includes('competitor') || searchKey.includes('competidor')) {
                toolName = 'Análise de Competidor';
            } else if (searchKey.includes('transcript') || searchKey.includes('transcrição')) {
                toolName = 'Análise de Transcrição';
            } else if (searchKey.includes('rewrite') || searchKey.includes('reescrever')) {
                toolName = 'Reescrever Prompt';
            } else {
                // Último fallback: usar o operationType formatado (sem "api_" ou "laozhang")
                toolName = (operationType || 'Ferramenta')
                    .replace(/^api_/, '')
                    .replace(/laozhang/gi, '')
                    .replace(/_/g, ' ')
                    .replace(/\s+/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase())
                    .trim() || 'Ferramenta';
            }
        }
        
        // Extrair modelo dos details - verificar múltiplas fontes
        let modelName = detailsObj?.model || detailsObj?.selectedModel || null;
        
        // Se não encontrou nos details, tentar extrair do operationType ou endpoint
        if (!modelName && detailsObj?.endpoint) {
            // Alguns endpoints podem ter o modelo no nome
            const endpointModelMatch = detailsObj.endpoint.match(/(gpt-4o|claude-3-7-sonnet|gemini-2\.5-pro)/i);
            if (endpointModelMatch) {
                modelName = endpointModelMatch[1];
            }
        }
        
        // Formatar nome do modelo para exibição amigável
        // IMPORTANTE: Remover qualquer referência a fornecedores de API
        if (modelName) {
            // Remover referências a fornecedores de API ANTES de formatar
            modelName = modelName
                .replace(/genaipro/gi, 'Voz Premium')
                .replace(/laozhang/gi, 'Provedor Externo')
                .replace(/openai/gi, '')
                .replace(/claude/gi, '')
                .replace(/gemini/gi, '')
                .replace(/anthropic/gi, '')
                .replace(/google/gi, '')
                .trim();
            // Vídeo - Veo
            // Veo models - verificar modelos landscape primeiro
            if (modelName.includes('veo-3.1-landscape-fast-fl') || modelName === 'veo-3.1-landscape-fast-fl') {
                modelName = 'Veo 3.1 Landscape Fast';
            } else if (modelName.includes('veo-3.1-landscape-fast') || modelName === 'veo-3.1-landscape-fast') {
                modelName = 'Veo 3.1 Landscape Fast';
            } else if (modelName.includes('veo-3.1-landscape-fl') || modelName === 'veo-3.1-landscape-fl') {
                modelName = 'Veo 3.1 Landscape';
            } else if (modelName.includes('veo-3.1-landscape') || modelName === 'veo-3.1-landscape') {
                modelName = 'Veo 3.1 Landscape';
            } else if (modelName.includes('veo-3.1-fast-fl') || modelName === 'veo-3.1-fast-fl') {
                modelName = 'Veo 3.1 Fast';
            } else if (modelName.includes('veo-3.1-fast') || modelName === 'veo-3.1-fast-generate-preview' || modelName === 'veo-3.1-fast') {
                modelName = 'Veo 3.1 Fast';
            } else if (modelName.includes('veo-3.1-fl') || modelName === 'veo-3.1-fl') {
                modelName = 'Veo 3.1';
            } else if (modelName.includes('veo-3.1-generate') || modelName === 'veo-3.1-generate-preview' || modelName === 'veo-3.1') {
                modelName = 'Veo 3.1';
            } else if (modelName.includes('veo-3.1')) {
                modelName = 'Veo 3.1';
            } else if (modelName.includes('veo')) {
                modelName = modelName.replace('veo-', 'Veo ').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            // Claude
            else if (modelName.includes('claude-3-7-sonnet') || modelName === 'claude-3-7-sonnet-20250219') {
                modelName = 'Claude 3.7 Sonnet';
            } else if (modelName.includes('claude-3-5')) {
                modelName = 'Claude 3.5';
            } else if (modelName.includes('claude')) {
                modelName = modelName.replace('claude-', 'Claude ').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            // GPT
            else if (modelName === 'gpt-4o' || modelName.includes('gpt-4o')) {
                modelName = 'GPT-4o';
            } else if (modelName.includes('gpt-4')) {
                modelName = 'GPT-4';
            } else if (modelName.includes('gpt')) {
                modelName = modelName.replace('gpt-', 'GPT-').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            // Gemini
            else if (modelName.includes('gemini-2.5-pro') || modelName === 'gemini-2.5-pro') {
                modelName = 'Gemini 2.5 Pro';
            } else if (modelName.includes('gemini-2.0')) {
                modelName = 'Gemini 2.0';
            } else if (modelName.includes('gemini')) {
                modelName = modelName.replace('gemini-', 'Gemini ').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            // Outros - limpar formato técnico
            else {
                // Remover sufixos de data e versão
                modelName = modelName
                    .replace(/-\d{8}$/, '') // Remove datas como -20250219
                    .replace(/-\d{4}$/, '') // Remove anos como -2025
                    .replace(/-preview$/, '')
                    .replace(/-generate$/, '')
                    .replace(/-latest$/, '')
                    .replace(/-exp$/, '')
                    .replace(/-experimental$/, '')
                    .replace(/-default$/, '') // Remover "-default"
                    .replace(/voz-premium/gi, 'Voz Premium') // Formatar nome genérico
                    .replace(/-/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
            }
            
            // Limpeza final: garantir que não há referências a fornecedores
            modelName = modelName
                .replace(/genaipro/gi, 'Voz Premium')
                .replace(/laozhang/gi, 'Provedor Externo')
                .replace(/openai/gi, '')
                .replace(/anthropic/gi, '')
                .replace(/google/gi, '')
                .replace(/\s+/g, ' ')
                .trim();
        }
        
        // Criar descrição apenas com nome da ferramenta e modelo (sem fornecedor de API)
        let description = toolName;
        if (modelName) {
            description += ` - ${modelName}`;
        }
        
        // Limpeza final: garantir que não há referências a fornecedores na descrição
        description = description
            .replace(/genaipro/gi, 'Voz Premium')
            .replace(/laozhang/gi, 'Provedor Externo')
            .replace(/laozhang\.ai/gi, 'Provedor Externo')
            .replace(/openai/gi, '')
            .replace(/anthropic/gi, '')
            .replace(/google/gi, '')
            .replace(/\s+/g, ' ')
            .trim();
        
        // Se a descrição ficou vazia ou só com espaços, usar apenas o nome da ferramenta
        if (!description || description.trim() === '' || description.trim() === '-') {
            description = toolName || 'Ferramenta';
        }
        
        // Registrar transação para histórico do usuário
        const sanitizedDescription = sanitizeUserFacingText(description, toolName || 'Operação');
        await db.run(`
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description, admin_id)
            VALUES (?, ?, 'debit', ?, NULL)
        `, [userId, -creditsNeeded, sanitizedDescription]);

        return {
            success: true,
            creditsUsed: creditsNeeded,
            newBalance: newBalance
        };
    } catch (error) {
        console.error('❌ Erro ao verificar/debitar créditos:', error);
        throw error;
    }
};

/**
 * Reembolsa créditos ao usuário em caso de erro
 */
const refundCredits = async (userId, creditsAmount, reason = 'Erro na operação') => {
    try {
        if (!creditsAmount || creditsAmount <= 0) {
            return { success: false, message: 'Valor inválido' };
        }

        let userCredits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [userId]);
        
        if (!userCredits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [userId]);
            userCredits = { balance: 0 };
        }

        const newBalance = userCredits.balance + creditsAmount;
        await db.run(`
            UPDATE user_credits 
            SET balance = ?, updated_at = CURRENT_TIMESTAMP 
            WHERE user_id = ?
        `, [newBalance, userId]);

        // Registrar transação de reembolso
        const sanitizedReason = sanitizeUserFacingText(reason || 'Créditos reembolsados', 'Créditos reembolsados');
        await db.run(`
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description)
            VALUES (?, ?, 'refund', ?)
        `, [userId, creditsAmount, sanitizedReason]);

        return {
            success: true,
            creditsRefunded: creditsAmount,
            newBalance: newBalance
        };
    } catch (error) {
        console.error('❌ Erro ao reembolsar créditos:', error);
        throw error;
    }
};

// ================================================
// SISTEMA DE TTS (TEXT-TO-SPEECH) - FUNÇÕES
// ================================================

// Armazenamento de jobs TTS em memória
const ttsJobs = {};

// Limpar jobs antigos (mais de 1 hora)
setInterval(() => {
    const oneHourAgo = Date.now() - 3600000;
    for (const [jobId, job] of Object.entries(ttsJobs)) {
        if (job.createdAt && new Date(job.createdAt).getTime() < oneHourAgo) {
            delete ttsJobs[jobId];
        }
    }
}, 600000); // A cada 10 minutos

// Diretório temporário para áudio
const TEMP_AUDIO_DIR = path.join(__dirname, 'temp_audio');
if (!fs.existsSync(TEMP_AUDIO_DIR)) {
    fs.mkdirSync(TEMP_AUDIO_DIR, { recursive: true });
}

// Modelos TTS válidos
const VALID_TTS_MODELS = [
    'gemini-2.5-pro-preview-tts',
    'gemini-2.5-flash-preview-tts',
    'tts-1',
    'tts-1-hd',
    'voz-premium', // Nome genérico para Voz Premium (não expor fornecedor)
    'genaipro-default' // Mantido para compatibilidade, mas será substituído por 'voz-premium'
];
const DEFAULT_TTS_MODEL = 'gemini-2.5-pro-preview-tts';
const FALLBACK_TTS_VOICE = 'zephyr';
const DEFAULT_TTS_SAMPLE_TEXT = 'LaCasa Dark A ferramenta de elite para canais dark.';

const validateTtsModel = (model) => {
    if (!model || !VALID_TTS_MODELS.includes(model)) {
        // Se for genaipro-default, converter para voz-premium
        if (model && (model.includes('genaipro') || model === 'genaipro-default')) {
            return 'voz-premium';
        }
        return DEFAULT_TTS_MODEL;
    }
    // Se for genaipro-default, converter para voz-premium
    if (model === 'genaipro-default') {
        return 'voz-premium';
    }
    return model;
};

// Função auxiliar para dividir texto tipo CapCut (máx 500 chars por bloco, respeitando frases)
function splitLikeCapcut(text, maxLen = 500) {
    const sentences = text.split(/(?<=[.!?])\s+/);
    const blocks = [];
    let current = "";

    for (const sentence of sentences) {
        if (sentence.length > maxLen) {
            // Se uma frase sozinha ultrapassa o limite, divide por palavras
            const words = sentence.split(" ");
            let tempCurrent = "";
            for (const word of words) {
                if ((tempCurrent + " " + word).trim().length <= maxLen) {
                    tempCurrent += " " + word;
                } else {
                    if (tempCurrent.trim().length > 0) {
                        blocks.push(tempCurrent.trim());
                    }
                    tempCurrent = word;
                }
            }
            if (tempCurrent.trim().length > 0) {
                current = tempCurrent.trim();
            }
        } else {
            if ((current + " " + sentence).trim().length <= maxLen) {
                current += " " + sentence;
            } else {
                if (current.trim().length > 0) {
                    blocks.push(current.trim());
                }
                current = sentence;
            }
        }
    }
    if (current.trim().length > 0) {
        blocks.push(current.trim());
    }
    return blocks;
}

// Função completa de divisão de texto do DARKSCRIPT (com prioridades de quebra)
function splitTextIntoChunks(text, charLimit) {
    const chunks = [];
    let remainingText = text.trim();

    while (remainingText.length > 0) {
        if (remainingText.length <= charLimit) {
            chunks.push(remainingText);
            break;
        }

        // Tenta usar 95% do limite para deixar margem e evitar cortes no meio de palavras
        const safeLimit = Math.floor(charLimit * 0.95);
        let chunk = remainingText.substring(0, safeLimit);
        let lastSentenceEnd = -1;
        let bestBreakPoint = -1;

        // PRIORIDADE 1: Procura por finais de parágrafo (quebra de linha dupla)
        const doubleLineBreak = chunk.lastIndexOf('\n\n');
        if (doubleLineBreak > charLimit * 0.7) { // Se está nos últimos 30% do chunk
            bestBreakPoint = doubleLineBreak + 2;
        }

        // PRIORIDADE 2: Procura por finais de frase (ponto, exclamação, interrogação seguidos de espaço)
        if (bestBreakPoint === -1) {
            const sentenceEnders = ['.', '!', '?'];
            for (const ender of sentenceEnders) {
                // Procura pelo padrão: "encerrador + espaço" ou "encerrador + quebra de linha"
                const pattern1 = `${ender} `;
                const pattern2 = `${ender}\n`;
                const index1 = chunk.lastIndexOf(pattern1);
                const index2 = chunk.lastIndexOf(pattern2);
                const index = Math.max(index1, index2);
                
                if (index > lastSentenceEnd && index > charLimit * 0.7) {
                    lastSentenceEnd = index + (index === index1 ? pattern1.length : pattern2.length);
                    bestBreakPoint = lastSentenceEnd;
                }
            }
        }

        // PRIORIDADE 3: Procura por vírgulas ou ponto-e-vírgula (em posições adequadas)
        if (bestBreakPoint === -1) {
            const commaBreak = chunk.lastIndexOf(', ');
            const semicolonBreak = chunk.lastIndexOf('; ');
            const breakPoint = Math.max(commaBreak, semicolonBreak);
            
            if (breakPoint > charLimit * 0.8) { // Se está nos últimos 20% do chunk
                bestBreakPoint = breakPoint + 2;
            }
        }

        // PRIORIDADE 4: Se não encontrou ponto de quebra natural, quebra na última palavra
        if (bestBreakPoint === -1) {
            const lastSpace = chunk.lastIndexOf(' ');
            if (lastSpace !== -1 && lastSpace > charLimit * 0.5) {
                bestBreakPoint = lastSpace + 1;
            } else {
                // Último recurso: quebra no limite exato (pode cortar palavra, mas é raro)
                bestBreakPoint = safeLimit;
            }
        }

        // Se encontrou um ponto de quebra adequado, usa ele
        if (bestBreakPoint > 0 && bestBreakPoint <= safeLimit) {
            chunk = remainingText.substring(0, bestBreakPoint).trim();
        } else {
            // Fallback: usa o chunk até o limite seguro
            chunk = chunk.trim();
        }
        
        chunks.push(chunk);
        remainingText = remainingText.substring(chunk.length).trim();
    }

    return chunks.filter(Boolean); // Remove chunks vazios
}

// Função para gerar áudio usando OpenAI TTS
const generateOpenAiTtsAudio = async ({ apiKey, textInput, voiceName }) => {
    const MAX_RETRIES = 3;
    const RETRY_DELAY = 3000;
    
    const validOpenAiVoices = ['alloy', 'echo', 'fable', 'onyx', 'nova', 'shimmer'];
    
    // Mapeamento de vozes Gemini para OpenAI
    const voiceMapping = {
        'Zephyr': 'nova',
        'Puck': 'shimmer',
        'Charon': 'onyx',
        'Kore': 'nova',
        'Fenrir': 'echo',
        'Leda': 'alloy',
        'Orus': 'onyx',
        'Aoede': 'shimmer',
        'Callirrhoe': 'alloy',
        'Autonoe': 'nova',
        'Enceladus': 'shimmer',
        'Iapetus': 'echo',
        'Umbriel': 'alloy',
        'Algieba': 'onyx',
        'Despina': 'nova',
        'Erinome': 'shimmer',
        'Algenib': 'onyx',
        'Rasalgethi': 'echo',
        'Laomedeia': 'shimmer',
        'Achernar': 'nova',
        'Alnilam': 'onyx',
        'Schedar': 'echo',
        'Gacrux': 'onyx',
        'Pulcherrima': 'nova',
        'Achird': 'alloy',
        'Zubenelgenubi': 'alloy',
        'Vindemiatrix': 'shimmer',
        'Sadachbia': 'shimmer',
        'Sadaltager': 'onyx',
        'Sulafat': 'nova'
    };
    
    let openAiVoice = voiceMapping[voiceName] || 'alloy';
    if (validOpenAiVoices.includes(voiceName?.toLowerCase())) {
        openAiVoice = voiceName.toLowerCase();
    }
    
    const cleanText = textInput.trim().replace(/[\x00-\x1F\x7F]/g, '');
    if (cleanText.length === 0) {
        throw new Error('Texto de entrada está vazio após limpeza');
    }
    
    if (cleanText.length > 4096) {
        throw new Error(`Texto muito longo (${cleanText.length} chars). Limite da API OpenAI é 4096 caracteres.`);
    }
    
    const responseFormat = 'mp3';
    
    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
        try {
            const response = await axios.post(
                'https://api.openai.com/v1/audio/speech',
                {
                    model: 'tts-1-hd',
                    input: cleanText,
                    voice: openAiVoice,
                    response_format: responseFormat,
                    speed: 1.0
                },
                {
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    responseType: 'arraybuffer',
                    timeout: 300000
                }
            );
            
            if (!response.data || response.data.length === 0) {
                throw new Error('A API retornou uma resposta vazia');
            }
            
            const audioBuffer = Buffer.from(response.data);
            const audioBase64 = audioBuffer.toString('base64');
            
            return {
                audioBase64: audioBase64,
                usage: null,
                format: 'mp3'
            };
        } catch (error) {
            if (attempt < MAX_RETRIES - 1) {
                const delay = RETRY_DELAY * (attempt + 1);
                await new Promise(resolve => setTimeout(resolve, delay));
            } else {
                throw error;
            }
        }
    }
};

// Função para gerar áudio usando Voz Premium API (GenAIPro)
// Sistema assíncrono: cria task e consulta status
// Documentação: https://genaipro.vn/docs-api
const generateVoicePremiumTtsAudio = async ({ apiKey, textInput, voiceName }) => {
    const MAX_WAIT_TIME = 300000; // 5 minutos máximo (algumas tasks podem demorar)
    const POLL_INTERVAL = 1500; // Verificar a cada 1.5 segundos (mais rápido para preview)
    
    // API Voz Premium (GenAIPro) conforme documentação
    // Base URL: https://genaipro.vn/api/v1
    const API_BASE = 'https://genaipro.vn/api/v1';
    
    const cleanText = textInput.trim();
    if (cleanText.length === 0) {
        throw new Error('Texto de entrada está vazio');
    }
    
    // Validar voice_id - se não foi fornecido, usar um padrão
    if (!voiceName || voiceName.trim() === '' || voiceName === 'default') {
        console.warn('[La Casa Dark Core] Voice ID não fornecido ou inválido, tentando buscar vozes disponíveis...');
        // Tentar buscar uma voz padrão
        try {
            const voicesResponse = await axios.get(`${API_BASE}/max/voices`, {
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                params: {
                    page: 1,
                    page_size: 1,
                    language: 'Portuguese'
                },
                timeout: 10000
            });
            
            if (voicesResponse?.data?.voice_list && voicesResponse.data.voice_list.length > 0) {
                voiceName = voicesResponse.data.voice_list[0].voice_id;
                console.log(`[La Casa Dark Core] Usando voz padrão: ${voiceName}`);
            } else {
                throw new Error('Nenhuma voz disponível encontrada');
            }
        } catch (voiceError) {
            console.error('[La Casa Dark Core] Erro ao buscar voz padrão:', voiceError.message);
            throw new Error('Voice ID é obrigatório. Configure uma voz premium no painel.');
        }
    }
    
    try {
        // Detectar tipo de voz: Labs (alfanumérica) ou Max (numérica)
        const isLabsVoice = voiceName && !/^\d+$/.test(voiceName);
        const voiceType = isLabsVoice ? 'Labs' : 'Max';
        
        console.log(`[La Casa Dark Core] Criando task TTS com voz: ${voiceName} (tipo: ${voiceType})`);
        console.log(`[La Casa Dark Core] Texto (primeiros 100 chars): ${cleanText.substring(0, 100)}...`);
        
        let taskResponse;
        let audioResult = null;
        
        // Headers de autenticação conforme documentação GenAIPro
        const authHeaders = {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
        };
        
        // =========================================================
        // Se for voz LABS, usar endpoint Labs PRIMEIRO
        // =========================================================
        if (isLabsVoice) {
            console.log('[La Casa Dark Core] Voz Labs detectada, tentando POST /labs/task...');
            try {
                console.log(`[La Casa Dark Core] Tamanho do texto para Labs: ${cleanText.length} caracteres`);
                
                // Verificar se o texto não está muito grande (algumas APIs têm limite)
                if (cleanText.length > 5000) {
                    console.warn(`[La Casa Dark Core] ⚠️ Texto muito grande (${cleanText.length} chars). A API Labs pode ter limites.`);
                }
                
                const labsTaskResponse = await axios.post(
                    `${API_BASE}/labs/task`,
                    {
                        input: cleanText,  // Labs usa "input" não "text"
                        voice_id: voiceName,
                        model_id: 'eleven_multilingual_v2',
                        speed: 1.0  // Speed deve estar entre 0.7 e 1.2 (conforme API)
                    },
                    {
                        headers: authHeaders,
                        timeout: 60000, // Aumentar timeout para 60s para textos maiores
                        validateStatus: (status) => true
                    }
                );
                
                console.log('[La Casa Dark Core] Resposta /labs/task status:', labsTaskResponse.status);
                console.log('[La Casa Dark Core] Resposta /labs/task data:', JSON.stringify(labsTaskResponse.data).substring(0, 500));
                
                // Verificar se está em manutenção
                if (labsTaskResponse.status === 503) {
                    const responseText = typeof labsTaskResponse.data === 'string' ? labsTaskResponse.data : '';
                    if (responseText.includes('Maintenance') || responseText.includes('Bảo Trì') || responseText.includes('<!DOCTYPE')) {
                        console.log('[La Casa Dark Core] ⚠️ API Labs está em manutenção');
                        throw new Error('O serviço de voz está temporariamente em manutenção. Por favor, tente novamente em alguns minutos.');
                    }
                }
                
                // Tratar erros HTTP antes de processar resposta
                if (labsTaskResponse.status === 400) {
                    const errorData = labsTaskResponse.data;
                    const errorMsg = errorData?.error || errorData?.message || errorData?.detail || 'Parâmetros inválidos';
                    console.error('[La Casa Dark Core] ❌ Labs retornou 400 (Bad Request):', errorMsg);
                    console.error('[La Casa Dark Core] ❌ Dados completos do erro:', JSON.stringify(errorData));
                    throw new Error(`Erro ao gerar áudio: ${errorMsg}. Verifique se a voz e os parâmetros estão corretos.`);
                }
                
                if (labsTaskResponse.status === 401 || labsTaskResponse.status === 403) {
                    const errorData = labsTaskResponse.data;
                    const errorMsg = errorData?.error || errorData?.message || 'Não autorizado';
                    console.error('[La Casa Dark Core] ❌ Labs retornou erro de autenticação:', errorMsg);
                    throw new Error(`Erro de autenticação: ${errorMsg}. Verifique sua chave de API.`);
                }
                
                if (labsTaskResponse.status >= 500 && labsTaskResponse.status !== 503) {
                    const errorData = labsTaskResponse.data;
                    const errorMsg = errorData?.error || errorData?.message || 'Erro interno do servidor';
                    console.error('[La Casa Dark Core] ❌ Labs retornou erro do servidor:', errorMsg);
                    throw new Error(`Erro no servidor da API: ${errorMsg}. Tente novamente em alguns instantes.`);
                }
                
                if (labsTaskResponse.status === 200 || labsTaskResponse.status === 201) {
                    const data = labsTaskResponse.data;
                    
                    console.log('[La Casa Dark Core] Resposta Labs completa:', JSON.stringify(data).substring(0, 500));
                    
                    // Verificar se já tem resultado direto (múltiplos formatos possíveis)
                    const audioUrl = data.result || data.audio_url || data.url || data.output_url || data.file_url;
                    const status = (data.status || '').toLowerCase();
                    const successStatuses = ['completed', 'done', 'success', 'finished'];
                    
                    if (audioUrl) {
                        console.log('[La Casa Dark Core] ✅ Task Labs já tem áudio disponível:', audioUrl);
                        
                        // Se for URL relativa, adicionar base URL
                        let fullAudioUrl = audioUrl;
                        if (audioUrl.startsWith('/')) {
                            fullAudioUrl = `https://genaipro.vn${audioUrl}`;
                        } else if (!audioUrl.startsWith('http')) {
                            fullAudioUrl = `${API_BASE.replace('/api/v1', '')}${audioUrl}`;
                        }
                        
                        const audioDownload = await axios.get(fullAudioUrl, {
                            responseType: 'arraybuffer',
                            timeout: 60000
                        });
                        return {
                            audioBase64: Buffer.from(audioDownload.data).toString('base64'),
                            usage: null,
                            format: 'mp3'
                        };
                    }
                    
                    // Se retornou task_id, fazer polling
                    if (data.task_id || data.id) {
                        const taskId = data.task_id || data.id;
                        console.log('[La Casa Dark Core] Labs Task criada:', taskId, '- Aguardando...');
                        
                        // Verificação imediata após criar a task (algumas APIs retornam resultado síncrono)
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Aguardar 1s antes do primeiro poll
                        
                        const startTime = Date.now();
                        let pollCount = 0;
                        let lastStatus = null;
                        let statusChangeCount = 0;
                        let consecutiveProcessingCount = 0; // Contador de polls consecutivos em "processing"
                        
                        while (Date.now() - startTime < MAX_WAIT_TIME) {
                            pollCount++;
                            const elapsed = Math.floor((Date.now() - startTime) / 1000);
                            
                            // Log apenas a cada 5 polls para não poluir muito
                            if (pollCount % 5 === 1 || elapsed > 30) {
                                console.log(`[La Casa Dark Core] Polling Labs #${pollCount} (${elapsed}s decorridos)...`);
                            }
                            
                            try {
                                const statusResponse = await axios.get(
                                    `${API_BASE}/labs/task/${taskId}`,
                                    { headers: authHeaders, timeout: 8000 } // Timeout reduzido para 8s
                                );
                                
                                if (statusResponse.data) {
                                    const taskData = statusResponse.data;
                                    const status = (taskData.status || taskData.state || '').toLowerCase();
                                    
                                    // Verificar se há erro mesmo quando status é processing
                                    if (taskData.error && typeof taskData.error === 'string' && taskData.error.length > 0) {
                                        console.error('[La Casa Dark Core] ❌ Erro na task Labs:', taskData.error);
                                        throw new Error(taskData.error);
                                    }
                                    
                                    // PRIORIDADE 1: Verificar se tem resultado disponível (mesmo que status ainda seja processing)
                                    // Algumas APIs retornam o resultado antes de mudar o status para "completed"
                                    // Verificar múltiplos campos possíveis onde o resultado pode estar
                                    const audioUrl = taskData.result || taskData.audio_url || taskData.url || taskData.output_url || taskData.file_url;
                                    
                                    if (audioUrl && typeof audioUrl === 'string' && audioUrl.length > 0) {
                                        console.log('[La Casa Dark Core] ✅ Resultado encontrado! Baixando áudio (status:', status, ', URL:', audioUrl.substring(0, 100), ')');
                                        
                                        let fullAudioUrl = audioUrl.trim();
                                        if (!fullAudioUrl.startsWith('http')) {
                                            fullAudioUrl = `https://${fullAudioUrl}`;
                                        }
                                        
                                        try {
                                            const audioDownload = await axios.get(fullAudioUrl, {
                                                responseType: 'arraybuffer',
                                                timeout: 60000,
                                                validateStatus: (status) => status === 200
                                            });
                                            
                                            console.log('[La Casa Dark Core] ✅ Áudio baixado com sucesso (tamanho:', audioDownload.data.length, 'bytes)');
                                            
                                            return {
                                                audioBase64: Buffer.from(audioDownload.data).toString('base64'),
                                                usage: null,
                                                format: 'mp3'
                                            };
                                        } catch (downloadError) {
                                            // Se falhar o download, continuar polling
                                            console.log('[La Casa Dark Core] ⏳ URL ainda não acessível (erro:', downloadError.message, '), continuando polling...');
                                        }
                                    } else if (pollCount % 20 === 0) {
                                        // A cada 20 polls, logar estrutura completa para debug
                                        console.log('[La Casa Dark Core] 🔍 Estrutura completa da resposta:', JSON.stringify(taskData).substring(0, 800));
                                    }
                                    
                                    // Detectar se status mudou
                                    if (lastStatus !== status) {
                                        lastStatus = status;
                                        statusChangeCount++;
                                        consecutiveProcessingCount = 0; // Reset contador
                                        console.log(`[La Casa Dark Core] Status mudou para: "${status}" (mudança #${statusChangeCount})`);
                                    } else if (status === 'processing') {
                                        consecutiveProcessingCount++;
                                    }
                                    
                                    // Log detalhado apenas quando necessário
                                    const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                                    if (pollCount % 10 === 0 || elapsedSeconds > 30) {
                                        // Log completo da resposta para debug
                                        console.log(`[La Casa Dark Core] Labs Task ${taskId}:`, {
                                            status: status,
                                            hasResult: !!taskData.result,
                                            resultPreview: taskData.result ? taskData.result.substring(0, 100) : 'não disponível',
                                            elapsed: `${elapsedSeconds}s`,
                                            polls: pollCount,
                                            fullResponse: JSON.stringify(taskData).substring(0, 500)
                                        });
                                    }
                                    
                                    // Conforme documentação: quando status é "completed", o campo "result" contém a URL
                                    if (status === 'completed') {
                                        // Se chegou aqui e não tem result, aguardar mais um pouco
                                        if (!audioUrl) {
                                            console.log('[La Casa Dark Core] ⏳ Status completed mas sem result ainda, aguardando...');
                                            await new Promise(resolve => setTimeout(resolve, 2000)); // Aguardar 2s e verificar novamente
                                            continue;
                                        }
                                    } else if (status === 'failed' || status === 'error' || status === 'failure') {
                                        const errorMsg = taskData.error || taskData.message || 'Task Labs falhou';
                                        console.error('[La Casa Dark Core] ❌ Task Labs falhou:', errorMsg);
                                        throw new Error(errorMsg);
                                    } else if (status === 'processing' || status === 'pending' || status === 'queued') {
                                        // Ainda processando, continuar aguardando
                                    } else {
                                        // Status desconhecido
                                        console.log(`[La Casa Dark Core] ⚠️ Status desconhecido: "${status}", continuando polling...`);
                                    }
                                }
                            } catch (pollError) {
                                // Se for erro de rede/timeout, continuar tentando
                                if (pollError.code === 'ECONNABORTED' || pollError.code === 'ETIMEDOUT') {
                                    console.log('[La Casa Dark Core] Timeout no polling, continuando...');
                                } else if (pollError.message && !pollError.message.includes('Task Labs falhou')) {
                                    console.log('[La Casa Dark Core] Erro no polling Labs:', pollError.message);
                                } else {
                                    // Se for erro de task falhada, propagar
                                    throw pollError;
                                }
                            }
                            
                            // Aguardar antes do próximo poll (intervalo dinâmico)
                            // Se está em processing há muito tempo, aumentar intervalo para não sobrecarregar
                            const waitTime = consecutiveProcessingCount > 10 ? POLL_INTERVAL * 2 : POLL_INTERVAL;
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                        }
                        
                        // Timeout - task não completou no tempo esperado
                        const totalSeconds = Math.floor((Date.now() - startTime) / 1000);
                        console.error(`[La Casa Dark Core] ❌ Timeout após ${totalSeconds}s (${pollCount} tentativas). Task pode ainda estar processando.`);
                        throw new Error(`A geração de áudio está demorando mais que o esperado (${totalSeconds}s). A task pode ainda estar processando. Tente novamente em alguns instantes.`);
                    }
                }
            } catch (labsError) {
                console.log('[La Casa Dark Core] Erro Labs:', labsError.message);
                throw labsError;
            }
        }
        
        // =========================================================
        // MÉTODO MAX: POST /max/tasks (para vozes Max/numéricas)
        // =========================================================
        console.log('[La Casa Dark Core] Tentando POST /max/tasks...');
        console.log(`[La Casa Dark Core] Tamanho do texto: ${cleanText.length} caracteres`);
        
        // Verificar se o texto não está muito grande (algumas APIs têm limite)
        if (cleanText.length > 5000) {
            console.warn(`[La Casa Dark Core] ⚠️ Texto muito grande (${cleanText.length} chars). A API pode ter limites.`);
        }
        
        try {
            const maxTaskResponse = await axios.post(
                `${API_BASE}/max/tasks`,
                {
                    text: cleanText,
                    voice_id: voiceName,
                    model_id: 'speech-2.5-hd-preview',
                    speed: 1.0,
                    pitch: 0,
                    volume: 1.0,
                    language: 'Auto'
                },
                {
                    headers: authHeaders,
                    timeout: 60000, // Aumentar timeout para 60s para textos maiores
                    validateStatus: (status) => true // Aceitar qualquer status para tratar manualmente
                }
            );
            
            // Verificar se está em manutenção (503)
            if (maxTaskResponse.status === 503) {
                const responseText = typeof maxTaskResponse.data === 'string' ? maxTaskResponse.data : '';
                if (responseText.includes('Maintenance') || responseText.includes('Bảo Trì')) {
                    console.log('[La Casa Dark Core] ⚠️ API Max está em manutenção');
                    throw new Error('O serviço de Voz Premium está temporariamente em manutenção. Por favor, tente novamente em alguns minutos.');
                }
            }
            
            console.log('[La Casa Dark Core] Resposta /max/tasks status:', maxTaskResponse.status);
            console.log('[La Casa Dark Core] Resposta /max/tasks data:', JSON.stringify(maxTaskResponse.data).substring(0, 500));
            
            // Tratar erros HTTP antes de processar resposta
            if (maxTaskResponse.status === 400) {
                const errorData = maxTaskResponse.data;
                const errorMsg = errorData?.error || errorData?.message || errorData?.detail || 'Parâmetros inválidos';
                console.error('[La Casa Dark Core] ❌ Erro 400 (Bad Request):', errorMsg);
                throw new Error(`Erro ao gerar áudio: ${errorMsg}. Verifique se a voz e os parâmetros estão corretos.`);
            }
            
            if (maxTaskResponse.status === 401 || maxTaskResponse.status === 403) {
                const errorData = maxTaskResponse.data;
                const errorMsg = errorData?.error || errorData?.message || 'Não autorizado';
                console.error('[La Casa Dark Core] ❌ Erro de autenticação:', errorMsg);
                throw new Error(`Erro de autenticação: ${errorMsg}. Verifique sua chave de API.`);
            }
            
            if (maxTaskResponse.status >= 500 && maxTaskResponse.status !== 503) {
                const errorData = maxTaskResponse.data;
                const errorMsg = errorData?.error || errorData?.message || 'Erro interno do servidor';
                console.error('[La Casa Dark Core] ❌ Erro do servidor:', errorMsg);
                throw new Error(`Erro no servidor da API: ${errorMsg}. Tente novamente em alguns instantes.`);
            }
            
            if (maxTaskResponse.status === 200 || maxTaskResponse.status === 201) {
                const data = maxTaskResponse.data;
                
                // Se já tem resultado direto
                if (data.result && data.status === 'completed') {
                    console.log('[La Casa Dark Core] ✅ Task já completa, baixando áudio...');
                    const audioDownload = await axios.get(data.result, {
                        responseType: 'arraybuffer',
                        timeout: 60000
                    });
                    return {
                        audioBase64: Buffer.from(audioDownload.data).toString('base64'),
                        usage: null,
                        format: 'mp3'
                    };
                }
                
                // Se retornou task_id, fazer polling
                if (data.id) {
                    const taskId = data.id;
                    console.log('[La Casa Dark Core] Task criada:', taskId, '- Aguardando processamento...');
                    
                    const startTime = Date.now();
                    while (Date.now() - startTime < MAX_WAIT_TIME) {
                        await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));
                        
                        try {
                            const statusResponse = await axios.get(
                                `${API_BASE}/max/tasks/${taskId}`,
                                { headers: authHeaders, timeout: 10000 }
                            );
                            
                            if (statusResponse.data) {
                                const taskData = statusResponse.data;
                                const status = taskData.status;
                                const percentage = taskData.process_percentage || 0;
                                
                                console.log(`[La Casa Dark Core] Task ${taskId}: ${status} (${percentage}%)`);
                                
                                if (status === 'completed') {
                                    if (taskData.result) {
                                        console.log('[La Casa Dark Core] ✅ Áudio pronto:', taskData.result);
                                        const audioDownload = await axios.get(taskData.result, {
                                            responseType: 'arraybuffer',
                                            timeout: 60000
                                        });
                                        return {
                                            audioBase64: Buffer.from(audioDownload.data).toString('base64'),
                                            usage: null,
                                            format: 'mp3'
                                        };
                                    }
                                } else if (status === 'failed' || status === 'error') {
                                    throw new Error(taskData.error || 'Task falhou');
                                }
                                // processing, pending - continuar polling
                            }
                        } catch (pollError) {
                            console.log('[La Casa Dark Core] Erro no polling:', pollError.message);
                        }
                    }
                    throw new Error('Timeout aguardando conclusão da task');
                }
            }
        } catch (maxTaskError) {
            console.log('[La Casa Dark Core] Erro /max/tasks:', maxTaskError.message);
            
            // Se for erro de manutenção, propagar diretamente
            if (maxTaskError.message && maxTaskError.message.includes('manutenção')) {
                throw maxTaskError;
            }
            
            if (maxTaskError.response) {
                console.log('[La Casa Dark Core] Status:', maxTaskError.response.status);
                console.log('[La Casa Dark Core] Data:', JSON.stringify(maxTaskError.response.data).substring(0, 300));
            }
        }
        
        // Se chegou aqui (vozes Max que falharam), nenhum método funcionou
        console.error('[La Casa Dark Core] Nenhum método de TTS funcionou');
        throw new Error('O serviço de Voz Premium está temporariamente indisponível. Por favor, tente novamente em alguns minutos ou selecione uma voz online.');
        
    } catch (error) {
        console.error('[La Casa Dark Core] Erro ao gerar TTS:', error.message);
        
        // Não verificar mais status 503 aqui, deixar a mensagem de erro original passar
        if (error.response) {
            console.error('[La Casa Dark Core] Status:', error.response.status);
            console.error('[La Casa Dark Core] Data:', JSON.stringify(error.response.data).substring(0, 500));
        }
        
        // Se o erro já tem uma mensagem amigável do catch anterior, manter
        if (error.message && !error.message.includes('AxiosError')) {
            throw error;
        }
        
        // Erro genérico
        throw new Error('Erro ao gerar áudio com Voz Premium. Verifique sua chave de API e tente novamente.');
    }
};

const generateLaozhangTtsAudio = async ({ apiKey, textInput, voiceName = 'alloy', speed = 1.0, model = 'tts-1' }) => {
    const cleanText = textInput.trim();
    if (!cleanText) {
        throw new Error('Texto de entrada vazio para geração de voz.');
    }

    const payload = {
        model: model,
        voice: voiceName || 'alloy',
        input: cleanText,
        speed: Math.min(Math.max(speed || 1.0, 0.25), 4.0)
    };

    try {
        console.log(`[DarkVoz TTS] Gerando áudio com voz "${voiceName}" (speed ${payload.speed})`);
        const response = await axios.post(
            'https://api.laozhang.ai/v1/audio/speech',
            payload,
            {
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'Accept': 'audio/mpeg'
                },
                responseType: 'arraybuffer',
                timeout: 120000
            }
        );

        if (!response || !response.data) {
            throw new Error('Resposta vazia da API do provedor de voz ao gerar áudio.');
        }

        const audioBuffer = Buffer.from(response.data);
        console.log(`[DarkVoz TTS] Áudio gerado (${audioBuffer.length} bytes)`);
        return {
            audioBase64: audioBuffer.toString('base64'),
            mimeType: 'audio/mp3'
        };
    } catch (error) {
        console.error('[DarkVoz TTS] Erro ao gerar áudio:', error.message);
        console.error('[DarkVoz TTS] Voz usada:', voiceName);
        if (error.response) {
            console.error('[DarkVoz TTS] Status:', error.response.status);
            const errorData = typeof error.response.data === 'string' ? error.response.data : JSON.stringify(error.response.data);
            console.error('[DarkVoz TTS] Data:', errorData.substring(0, 500));
            
            if (error.response.status === 401) {
                throw new Error('Chave do DarkVoz inválida ou expirada. Atualize a chave no painel admin.');
            }
            if (error.response.status === 403) {
                throw new Error('Acesso negado pela API do DarkVoz. Verifique se a chave possui permissões para TTS.');
            }
            if (error.response.status === 400) {
                // Erro 400 geralmente indica voz inválida ou parâmetros incorretos
                const errorMsg = errorData.toLowerCase();
                if (errorMsg.includes('voice') || errorMsg.includes('voz')) {
                    throw new Error(`Voz "${voiceName}" não está disponível ou é inválida. Verifique se a voz existe no DarkVoz e tente outra voz.`);
                }
                throw new Error(`Erro na requisição: ${errorData.substring(0, 200)}`);
            }
            if (error.response.status === 503) {
                throw new Error('O DarkVoz está temporariamente indisponível. Tente novamente em alguns minutos.');
            }
        }
        if (error.code === 'ECONNABORTED') {
            throw new Error('Timeout ao conectar com a API do DarkVoz. Tente novamente em instantes.');
        }
        throw new Error(error.message || 'Erro ao gerar áudio com o DarkVoz.');
    }
};

// Função principal para gerar TTS
const generateTtsAudio = async ({ apiKey, model, textInput, speakerVoiceMap, provider = 'gemini', speed = 1.0 }, retryCount = 0) => {
    // Se o provedor for OpenAI, usa a função específica
    if (provider === 'openai') {
        const voiceName = Array.from(speakerVoiceMap.values())[0] || 'alloy';
        return await generateOpenAiTtsAudio({ apiKey, textInput, voiceName });
    }
    
    // Se o provedor for Voz Premium (GenAIPro)
    if (provider === 'voice_premium' || provider === 'genaipro') {
        const voiceName = Array.from(speakerVoiceMap.values())[0] || 'default';
        return await generateVoicePremiumTtsAudio({ apiKey, textInput, voiceName });
    }
    
    // Gemini TTS - usar API oficial do Google Gemini
    if (provider === 'gemini') {
        return await generateGeminiTtsAudio({ apiKey, textInput });
    }

    if (provider === 'laozhang') {
        const voiceName = Array.from(speakerVoiceMap.values())[0] || 'alloy';
        return await generateLaozhangTtsAudio({ apiKey, textInput, voiceName, speed, model });
    }
    
    throw new Error(`Provedor TTS "${provider}" não suportado. Use OpenAI, Voz Premium, Gemini ou DarkVoz.`);
};

// Função para gerar TTS usando a API oficial do Google Cloud Text-to-Speech
// Nota: O Google Gemini não tem TTS nativo, então usamos o Google Cloud Text-to-Speech API
// que pode usar a mesma chave de API do Google Cloud
const generateGeminiTtsAudio = async ({ apiKey, textInput }) => {
    const cleanText = textInput.trim();
    if (cleanText.length === 0) {
        throw new Error('Texto de entrada está vazia');
    }
    
    try {
        console.log('[La Casa Dark Core TTS] Gerando áudio usando Text-to-Speech');
        
        // Usar Google Cloud Text-to-Speech API
        // Endpoint: https://texttospeech.googleapis.com/v1/text:synthesize
        // A chave do Google Cloud pode ser usada diretamente aqui
        const response = await axios.post(
            `https://texttospeech.googleapis.com/v1/text:synthesize?key=${encodeURIComponent(apiKey)}`,
            {
                input: {
                    text: cleanText
                },
                voice: {
                    languageCode: 'pt-BR',
                    name: 'pt-BR-Neural2-C', // Voz neural em português brasileiro
                    ssmlGender: 'FEMALE' // NEUTRAL não é suportado, usar FEMALE ou MALE
                },
                audioConfig: {
                    audioEncoding: 'MP3',
                    speakingRate: 1.0,
                    pitch: 0.0,
                    volumeGainDb: 0.0
                }
            },
            {
                headers: {
                    'Content-Type': 'application/json'
                },
                timeout: 60000
            }
        );
        
        if (response.data && response.data.audioContent) {
            // O audioContent já vem em base64
            const audioBase64 = response.data.audioContent;
            
            console.log('[La Casa Dark Core TTS] Áudio gerado com sucesso');
            return {
                audioBase64: audioBase64,
                mimeType: 'audio/mp3'
            };
        } else {
            throw new Error('Resposta da API não contém áudio');
        }
    } catch (error) {
        console.error('[La Casa Dark Core TTS] Erro ao gerar áudio:', error.message);
        
        if (error.response) {
            const status = error.response.status;
            const errorData = error.response.data;
            
            console.error('[La Casa Dark Core TTS] Status:', status);
            console.error('[La Casa Dark Core TTS] Error Data:', JSON.stringify(errorData).substring(0, 500));
            
            if (status === 401 || status === 403) {
                throw new Error('Chave de API do Google inválida ou expirada. Verifique suas configurações. A chave precisa ter a API Text-to-Speech habilitada.');
            }
            
            if (status === 429) {
                throw new Error('Limite de requisições excedido. Aguarde alguns instantes e tente novamente.');
            }
            
            let errorMessage = 'Erro ao gerar áudio com Google Cloud Text-to-Speech';
            if (typeof errorData === 'object' && errorData.error) {
                errorMessage = errorData.error.message || errorData.error || errorMessage;
            } else if (typeof errorData === 'string') {
                errorMessage = errorData;
            }
            
            throw new Error(errorMessage);
        }
        
        if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {
            throw new Error('Timeout ao conectar com a API do Google. Tente novamente.');
        }
        
        throw error;
    }
};

// --- INICIALIZAÇÃO DO BANCO DE DADOS ---
(async () => {
    try {
        // Define o caminho do banco de dados, usando a variável de ambiente ou um padrão.
        const dbPath = process.env.DB_PATH || path.join(__dirname, 'data', 'lacasacorebd.db');
        
        // Garante que o diretório do banco de dados exista
        const dbDir = path.dirname(dbPath);
        if (!fs.existsSync(dbDir)) {
            fs.mkdirSync(dbDir, { recursive: true });
        }

        // Configurar SQLite para melhor performance
        db = await sqlite.open({
            filename: dbPath, // Usa o caminho definido
            driver: sqlite3.Database
        });

        // Otimizações de performance do SQLite
        await db.exec('PRAGMA journal_mode = WAL;'); // Write-Ahead Logging para melhor performance
        await db.exec('PRAGMA synchronous = NORMAL;'); // Balance entre segurança e performance
        await db.exec('PRAGMA cache_size = -64000;'); // 64MB de cache
        await db.exec('PRAGMA foreign_keys = ON;'); // Garantir integridade referencial
        await db.exec('PRAGMA temp_store = MEMORY;'); // Usar memória para temporários

        console.log(`✅ Conectado ao banco de dados em: ${dbPath}`);

        // --- CRIAÇÃO DAS TABELAS ---

        await db.exec(`
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                email TEXT NOT NULL UNIQUE,
                whatsapp TEXT,
                password_hash TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                isAdmin BOOLEAN NOT NULL DEFAULT 0,
                isBlocked BOOLEAN NOT NULL DEFAULT 0,
                isApproved BOOLEAN NOT NULL DEFAULT 0,
                last_login_at DATETIME,
                plan TEXT DEFAULT 'plan-free',
                subscription_plan TEXT DEFAULT 'plan-free'
            );
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS password_reset_tokens (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                token TEXT NOT NULL UNIQUE,
                expires_at DATETIME NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                used BOOLEAN NOT NULL DEFAULT 0,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            );
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS analysis_folders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS monitored_channels (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                channel_name TEXT NOT NULL,
                channel_url TEXT NOT NULL,
                last_checked DATETIME,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                UNIQUE(user_id, channel_url)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS analyzed_videos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                folder_id INTEGER,
                
                youtube_video_id TEXT NOT NULL,
                video_url TEXT,
                original_title TEXT,
                translated_title TEXT,
                original_views INTEGER,
                original_comments INTEGER,
                original_days INTEGER,
                original_thumbnail_url TEXT,
                
                detected_niche TEXT,
                detected_subniche TEXT,
                
                analysis_data_json TEXT, -- JSON com a 'analiseOriginal'
                
                analyzed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                FOREIGN KEY (folder_id) REFERENCES analysis_folders (id) ON DELETE SET NULL
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS generated_titles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                video_analysis_id INTEGER NOT NULL,
                title_text TEXT NOT NULL,
                model_used TEXT,
                pontuacao INTEGER DEFAULT 0,
                impact_score INTEGER DEFAULT NULL,
                explicacao TEXT,
                formula TEXT DEFAULT NULL,
                is_checked BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (video_analysis_id) REFERENCES analyzed_videos (id) ON DELETE CASCADE
            );
        `);

        // Migração: adicionar impact_score se não existir (SCORE 2 - Impacto Visual)
        try {
            const tableInfo = await db.all("PRAGMA table_info(generated_titles)");
            const existingColumns = tableInfo.map(col => col.name);
            if (!existingColumns.includes('impact_score')) {
                await db.run('ALTER TABLE generated_titles ADD COLUMN impact_score INTEGER DEFAULT NULL');
                console.log('[MIGRATION] Adicionado campo impact_score em generated_titles');
            }
            if (!existingColumns.includes('formula')) {
                await db.run('ALTER TABLE generated_titles ADD COLUMN formula TEXT DEFAULT NULL');
                console.log('[MIGRATION] Adicionado campo formula em generated_titles');
            }
        } catch (migrationErr) {
            console.warn('[MIGRATION] Falha ao migrar generated_titles:', migrationErr.message);
        }
        
        // Tabelas para análise de canais virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS channel_viral_analysis (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                channel_id TEXT NOT NULL,
                channel_name TEXT NOT NULL,
                channel_url TEXT NOT NULL,
                channel_handle TEXT,
                subscriber_count INTEGER,
                total_videos INTEGER,
                total_views INTEGER,
                channel_age_days INTEGER,
                channel_age_years REAL,
                avg_rpm_usd REAL,
                avg_rpm_brl REAL,
                niche TEXT,
                folder_id INTEGER,
                analysis_data_json TEXT,
                viral_insights_json TEXT,
                new_channel_insights_json TEXT,
                analyzed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                FOREIGN KEY (folder_id) REFERENCES analysis_folders (id) ON DELETE SET NULL,
                UNIQUE(user_id, channel_id)
            );
        `);
        
        // Migração: Adicionar campos novos se não existirem
        try {
            const tableInfo = await db.all("PRAGMA table_info(channel_viral_analysis)");
            const existingColumns = tableInfo.map(col => col.name);
            
            if (!existingColumns.includes('channel_age_days')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN channel_age_days INTEGER');
                console.log('[MIGRATION] Adicionado campo channel_age_days');
            }
            if (!existingColumns.includes('channel_age_years')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN channel_age_years REAL');
                console.log('[MIGRATION] Adicionado campo channel_age_years');
            }
            if (!existingColumns.includes('avg_rpm_usd')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN avg_rpm_usd REAL');
                console.log('[MIGRATION] Adicionado campo avg_rpm_usd');
            }
            if (!existingColumns.includes('avg_rpm_brl')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN avg_rpm_brl REAL');
                console.log('[MIGRATION] Adicionado campo avg_rpm_brl');
            }
            if (!existingColumns.includes('niche')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN niche TEXT');
                console.log('[MIGRATION] Adicionado campo niche');
            }
            if (!existingColumns.includes('folder_id')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN folder_id INTEGER');
                console.log('[MIGRATION] Adicionado campo folder_id');
            }
            if (!existingColumns.includes('new_channel_insights_json')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN new_channel_insights_json TEXT');
                console.log('[MIGRATION] Adicionado campo new_channel_insights_json');
            }
            if (!existingColumns.includes('subniche')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN subniche TEXT');
                console.log('[MIGRATION] Adicionado campo subniche');
            }
            if (!existingColumns.includes('total_revenue_usd')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN total_revenue_usd REAL');
                console.log('[MIGRATION] Adicionado campo total_revenue_usd');
            }
            if (!existingColumns.includes('total_revenue_brl')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN total_revenue_brl REAL');
                console.log('[MIGRATION] Adicionado campo total_revenue_brl');
            }
        } catch (migrationErr) {
            console.error('[MIGRATION] Erro ao adicionar campos:', migrationErr);
            // Não bloquear se a migração falhar, os campos podem já existir
        }

        await db.exec(`
            CREATE TABLE IF NOT EXISTS channel_viral_videos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                analysis_id INTEGER NOT NULL,
                video_id TEXT NOT NULL,
                video_url TEXT NOT NULL,
                title TEXT NOT NULL,
                description TEXT,
                thumbnail_url TEXT,
                view_count INTEGER,
                like_count INTEGER,
                comment_count INTEGER,
                published_at DATETIME,
                duration TEXT,
                tags_json TEXT,
                category_id INTEGER,
                viral_score REAL,
                analysis_notes TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (analysis_id) REFERENCES channel_viral_analysis (id) ON DELETE CASCADE,
                UNIQUE(analysis_id, video_id)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS channel_viral_comments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                video_id INTEGER NOT NULL,
                comment_id TEXT NOT NULL,
                author_name TEXT,
                author_channel_id TEXT,
                text TEXT NOT NULL,
                like_count INTEGER DEFAULT 0,
                published_at DATETIME,
                sentiment TEXT,
                keywords_json TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (video_id) REFERENCES channel_viral_videos (id) ON DELETE CASCADE,
                UNIQUE(video_id, comment_id)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS channel_viral_insights (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                analysis_id INTEGER NOT NULL,
                insight_type TEXT NOT NULL,
                insight_title TEXT NOT NULL,
                insight_content TEXT NOT NULL,
                supporting_data_json TEXT,
                priority INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (analysis_id) REFERENCES channel_viral_analysis (id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS generated_thumbnails (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                video_analysis_id INTEGER NOT NULL,
                base_title TEXT, 
                description TEXT,
                hook_phrases_json TEXT,
                generated_image_base64 TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (video_analysis_id) REFERENCES analyzed_videos (id) ON DELETE CASCADE
            );
            
            CREATE TABLE IF NOT EXISTS thumbnail_references (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                thumbnail_base64 TEXT NOT NULL,
                folder_id INTEGER,
                channel_name TEXT,
                niche TEXT,
                subniche TEXT,
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                FOREIGN KEY (folder_id) REFERENCES analysis_folders (id) ON DELETE SET NULL
            );
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS thumbnail_style_prompts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                niche TEXT,
                subniche TEXT,
                folder_id INTEGER,
                standard_prompt TEXT NOT NULL,
                analyzed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                FOREIGN KEY (folder_id) REFERENCES analysis_folders (id) ON DELETE SET NULL
            );
            
            -- Criar índice para melhorar performance nas buscas
            CREATE INDEX IF NOT EXISTS idx_thumbnail_style_prompts_user_niche ON thumbnail_style_prompts(user_id, niche, subniche, folder_id);
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS generated_videos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                operation_id TEXT UNIQUE NOT NULL,
                video_uri TEXT NOT NULL,
                prompt TEXT,
                model TEXT,
                aspect_ratio TEXT,
                resolution TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            );
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_api_keys (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                service_name TEXT NOT NULL, 
                api_key TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                UNIQUE(user_id, service_name)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS pinned_videos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                monitored_channel_id INTEGER NOT NULL,
                youtube_video_id TEXT NOT NULL,
                title TEXT,
                thumbnail_url TEXT,
                pinned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                FOREIGN KEY (monitored_channel_id) REFERENCES monitored_channels (id) ON DELETE CASCADE,
                UNIQUE(user_id, monitored_channel_id, youtube_video_id)
            );
        `);

        // --- CORREÇÃO DO BANCO DE DADOS (MINI-MIGRAÇÃO) ---
        const usersInfo = await db.all("PRAGMA table_info(users)");
        if (!usersInfo.some(c => c.name === 'isApproved')) {
            console.log('MIGRATION: Adding column "isApproved" to "users"...');
            await db.exec('ALTER TABLE users ADD COLUMN isApproved BOOLEAN NOT NULL DEFAULT 0');
        }
        if (!usersInfo.some(c => c.name === 'last_login_at')) {
            console.log('MIGRATION: Adding column "last_login_at" to "users"...');
            await db.exec('ALTER TABLE users ADD COLUMN last_login_at DATETIME');
        }
        if (!usersInfo.some(c => c.name === 'plan')) {
            console.log('MIGRATION: Adding column "plan" to "users"...');
            await db.exec('ALTER TABLE users ADD COLUMN plan TEXT DEFAULT "plan-free"');
        }
        if (!usersInfo.some(c => c.name === 'subscription_plan')) {
            console.log('MIGRATION: Adding column "subscription_plan" to "users"...');
            await db.exec('ALTER TABLE users ADD COLUMN subscription_plan TEXT DEFAULT "plan-free"');
        }

        const analyzedVideosInfo = await db.all("PRAGMA table_info(analyzed_videos)");
        const analyzedVideosColumns = {
            video_url: 'TEXT',
            folder_id: 'INTEGER REFERENCES analysis_folders(id) ON DELETE SET NULL',
            translated_title: 'TEXT',
            original_views: 'INTEGER',
            original_comments: 'INTEGER',
            original_days: 'INTEGER',
            original_thumbnail_url: 'TEXT',
            analysis_data_json: 'TEXT'
        };
        for (const [col, type] of Object.entries(analyzedVideosColumns)) {
            if (!analyzedVideosInfo.some(c => c.name === col)) {
                console.log(`MIGRATION: Adding column "${col}" to "analyzed_videos"...`);
                await db.exec(`ALTER TABLE analyzed_videos ADD COLUMN ${col} ${type}`);
            }
        }

        const generatedTitlesInfo = await db.all("PRAGMA table_info(generated_titles)");
        const generatedTitlesColumns = {
            pontuacao: 'INTEGER DEFAULT 0',
            explicacao: 'TEXT',
            is_checked: 'BOOLEAN DEFAULT 0'
        };
        for (const [col, type] of Object.entries(generatedTitlesColumns)) {
            if (!generatedTitlesInfo.some(c => c.name === col)) {
                console.log(`MIGRATION: Adding column "${col}" to "generated_titles"...`);
                await db.exec(`ALTER TABLE generated_titles ADD COLUMN ${col} ${type}`);
            }
        }
        
        // Criar tabela de limites customizados de armazenamento
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_storage_limits (
                user_id INTEGER PRIMARY KEY,
                custom_limit INTEGER NOT NULL,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            )
        `);
        
        // Criar tabela para rastrear armazenamento por usuário
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_storage (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                file_path TEXT NOT NULL,
                file_size INTEGER NOT NULL,
                file_type TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            )
        `);
        
        // Criar índice para melhor performance
        await db.exec(`
            CREATE INDEX IF NOT EXISTS idx_user_storage_user_id ON user_storage(user_id)
        `);
        
        // Migração: adicionar coluna updated_at se não existir
        try {
            const userStorageInfo = await db.all("PRAGMA table_info(user_storage)");
            if (!userStorageInfo.some(c => c.name === 'updated_at')) {
                console.log('MIGRATION: Adicionando coluna "updated_at" à tabela "user_storage"...');
                await db.exec('ALTER TABLE user_storage ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP');
            }
        } catch (err) {
            // Ignorar se já existe
            if (!/duplicate column name/i.test(err.message)) {
                console.error('[MIGRATION] Erro ao adicionar coluna updated_at:', err);
            }
        }
        
        // Migração: adicionar colunas para 3 prompts no thumbnail_style_prompts
        try {
            const thumbnailStylePromptsInfo = await db.all("PRAGMA table_info(thumbnail_style_prompts)");
            const thumbnailStylePromptsColumns = {
                prompt_1: 'TEXT',
                prompt_2: 'TEXT',
                prompt_3: 'TEXT',
                prompt_selected: 'INTEGER DEFAULT 1'
            };
            for (const [col, type] of Object.entries(thumbnailStylePromptsColumns)) {
                if (!thumbnailStylePromptsInfo.some(c => c.name === col)) {
                    console.log(`MIGRATION: Adicionando coluna "${col}" à tabela "thumbnail_style_prompts"...`);
                    await db.exec(`ALTER TABLE thumbnail_style_prompts ADD COLUMN ${col} ${type}`);
                }
            }
            // Migrar dados existentes: se standard_prompt existe mas prompt_1 não, copiar
            const hasPrompt1 = thumbnailStylePromptsInfo.some(c => c.name === 'prompt_1');
            const hasStandardPrompt = thumbnailStylePromptsInfo.some(c => c.name === 'standard_prompt');
            if (!hasPrompt1 && hasStandardPrompt) {
                console.log('MIGRATION: Migrando dados de standard_prompt para prompt_1...');
                await db.exec(`UPDATE thumbnail_style_prompts SET prompt_1 = standard_prompt, prompt_selected = 1 WHERE prompt_1 IS NULL`);
            }
        } catch (err) {
            if (!/duplicate column name/i.test(err.message)) {
                console.error('[MIGRATION] Erro ao adicionar colunas de prompts:', err);
            }
        }
        
        // Criar tabela de créditos por plano
        await db.exec(`
            CREATE TABLE IF NOT EXISTS plan_credits (
                plan_name TEXT PRIMARY KEY,
                monthly_credits INTEGER NOT NULL DEFAULT 0,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Inicializar créditos padrão dos planos
        const defaultPlanCredits = {
            'plan-free': 100,
            'plan-start': 1000,
            'plan-turbo': 2500,
            'plan-master': 5000,
            'plan-start-annual': 1000, // Mensal (12.000/12)
            'plan-turbo-annual': 2500, // Mensal (30.000/12)
            'plan-master-annual': 5000 // Mensal (60.000/12)
        };
        
        for (const [plan, credits] of Object.entries(defaultPlanCredits)) {
            await db.run(`
                INSERT OR IGNORE INTO plan_credits (plan_name, monthly_credits)
                VALUES (?, ?)
            `, [plan, credits]);
        }
        
        // Criar tabela de renovação de créditos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS credit_renewals (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                plan_name TEXT NOT NULL,
                credits_added INTEGER NOT NULL,
                renewal_date DATETIME NOT NULL,
                next_renewal_date DATETIME,
                is_annual BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            )
        `);
        
        // Criar tabela de permissões de planos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS plan_permissions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                plan_name TEXT NOT NULL,
                feature_name TEXT NOT NULL,
                is_allowed BOOLEAN DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(plan_name, feature_name)
            )
        `);
        
        // Criar tabela de notificações
        await db.exec(`
            CREATE TABLE IF NOT EXISTS notifications (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                title TEXT NOT NULL,
                message TEXT NOT NULL,
                type TEXT DEFAULT 'info',
                is_read BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            )
        `);
        
        // Criar tabela de usuários fictícios
        await db.exec(`
            CREATE TABLE IF NOT EXISTS fake_users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                email TEXT NOT NULL,
                type TEXT DEFAULT 'purchase',
                plan_name TEXT DEFAULT NULL,
                is_active BOOLEAN DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Migração: adicionar coluna plan_name se não existir
        try {
            const fakeUsersInfo = await db.all("PRAGMA table_info(fake_users)");
            if (!fakeUsersInfo.some(c => c.name === 'plan_name')) {
                console.log('MIGRATION: Adding column "plan_name" to "fake_users"...');
                await db.exec('ALTER TABLE fake_users ADD COLUMN plan_name TEXT DEFAULT NULL');
            }
        } catch (err) {
            // Ignorar se já existe
        }
        
        // Criar tabela de configurações de notificações
        await db.exec(`
            CREATE TABLE IF NOT EXISTS notification_config (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Criar tabela de loops ativos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS active_loops (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                loop_type TEXT NOT NULL UNIQUE,
                is_active BOOLEAN DEFAULT 0,
                interval_seconds INTEGER DEFAULT 5,
                started_at DATETIME,
                stopped_at DATETIME,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Inicializar permissões padrão
        const defaultFeatures = [
            'video_analyzer',
            'niche_explorer',
            'script_generator',
            'voice_generator',
            'image_generator',
            'video_generator',
            'youtube_integration',
            'api_propria',
            'batch_images',
            'analytics',
            'viral_library'
        ];
        
        const defaultPermissions = {
            'plan-free': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': false,
                'image_generator': false,
                'video_generator': false,
                'youtube_integration': false,
                'api_propria': false,
                'batch_images': false,
                'analytics': true,
                'viral_library': true
            },
            'plan-start': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': false,
                'api_propria': false,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-turbo': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': false,
                'api_propria': false,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-master': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': true,
                'api_propria': true,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-start-annual': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': true,
                'api_propria': true,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-turbo-annual': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': true,
                'api_propria': true,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-master-annual': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': true,
                'api_propria': true,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            }
        };
        
        for (const [plan, features] of Object.entries(defaultPermissions)) {
            for (const [feature, allowed] of Object.entries(features)) {
                await db.run(`
                    INSERT OR IGNORE INTO plan_permissions (plan_name, feature_name, is_allowed)
                    VALUES (?, ?, ?)
                `, [plan, feature, allowed ? 1 : 0]);
            }
        }
        // Migração: Corrigir constraint UNIQUE em monitored_channels (permitir múltiplos canais por usuário)
        try {
            const monitoredChannelsInfo = await db.all("PRAGMA table_info(monitored_channels)");
            const tableExists = monitoredChannelsInfo.length > 0;
            
            if (tableExists) {
                // Verificar schema atual da tabela
                const tableSchema = await db.get("SELECT sql FROM sqlite_master WHERE type='table' AND name='monitored_channels'");
                const schemaSql = (tableSchema?.sql || '').toUpperCase();
                
                console.log('[MIGRATION] Schema atual de monitored_channels:', schemaSql.substring(0, 200));
                
                // Se a constraint UNIQUE está apenas em channel_url (sem user_id), precisamos recriar
                if (schemaSql.includes('CHANNEL_URL') && schemaSql.includes('UNIQUE') && !schemaSql.includes('UNIQUE(USER_ID, CHANNEL_URL)')) {
                    console.log('[MIGRATION] Detectada constraint UNIQUE incorreta. Recriando tabela com UNIQUE(user_id, channel_url)...');
                    try {
                        // Criar nova tabela com constraint correta
                        await db.exec(`CREATE TABLE monitored_channels_new (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            user_id INTEGER NOT NULL,
                            channel_name TEXT NOT NULL,
                            channel_url TEXT NOT NULL,
                            last_checked DATETIME,
                            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                            FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                            UNIQUE(user_id, channel_url)
                        )`);
                        
                        // Copiar dados existentes (ignorar duplicatas se houver)
                        try {
                            await db.exec(`INSERT INTO monitored_channels_new (id, user_id, channel_name, channel_url, last_checked, created_at) 
                                         SELECT id, user_id, channel_name, channel_url, last_checked, created_at 
                                         FROM monitored_channels`);
                            console.log('[MIGRATION] Dados copiados com sucesso.');
                        } catch (copyErr) {
                            console.warn('[MIGRATION] Alguns dados podem ter duplicatas, tentando inserir apenas únicos...', copyErr.message);
                            // Tentar inserir apenas registros únicos
                            const existingChannels = await db.all('SELECT DISTINCT user_id, channel_url, MIN(id) as id, channel_name, last_checked, created_at FROM monitored_channels GROUP BY user_id, channel_url');
                            for (const channel of existingChannels) {
                                try {
                                    await db.run('INSERT INTO monitored_channels_new (id, user_id, channel_name, channel_url, last_checked, created_at) VALUES (?, ?, ?, ?, ?, ?)',
                                        [channel.id, channel.user_id, channel.channel_name, channel.channel_url, channel.last_checked, channel.created_at]);
                                } catch (insErr) {
                                    console.warn(`[MIGRATION] Erro ao inserir canal ${channel.id}:`, insErr.message);
                                }
                            }
                        }
                        
                        // Dropar tabela antiga
                        await db.exec('DROP TABLE monitored_channels');
                        
                        // Renomear nova tabela
                        await db.exec('ALTER TABLE monitored_channels_new RENAME TO monitored_channels');
                        
                        console.log('[MIGRATION] ✅ Tabela monitored_channels recriada com sucesso com constraint UNIQUE(user_id, channel_url).');
                    } catch (recreateErr) {
                        console.error('[MIGRATION] ❌ Erro ao recriar tabela monitored_channels:', recreateErr.message);
                        // Tentar criar índice único como fallback
                        try {
                            await db.exec('CREATE UNIQUE INDEX IF NOT EXISTS idx_monitored_channels_user_url ON monitored_channels(user_id, channel_url)');
                            console.log('[MIGRATION] ✅ Índice único criado como fallback.');
                        } catch (idxErr) {
                            console.warn('[MIGRATION] ⚠️ Não foi possível criar índice único:', idxErr.message);
                        }
                    }
                } else {
                    // Garantir que o índice único correto existe
                    try {
                        await db.exec('CREATE UNIQUE INDEX IF NOT EXISTS idx_monitored_channels_user_url ON monitored_channels(user_id, channel_url)');
                        console.log('[MIGRATION] ✅ Índice único verificado/criado.');
                    } catch (idxErr) {
                        // Índice já existe ou há outro problema, continuar
                        console.log('[MIGRATION] ℹ️ Índice único já existe ou constraint já está correta.');
                    }
                }
            }
        } catch (migErr) {
            console.error('[MIGRATION] ❌ Erro na migração de monitored_channels:', migErr.message);
        }

        const pinnedVideosInfo = await db.all("PRAGMA table_info(pinned_videos)");
        if (!pinnedVideosInfo.some(c => c.name === 'monitored_channel_id')) {
            console.log('MIGRATION: Adding column "monitored_channel_id" to "pinned_videos"...');
            // This is a simplified migration. In a real app, you'd handle existing data.
            await db.exec('DROP TABLE IF EXISTS pinned_videos');
            await db.exec(`
                CREATE TABLE pinned_videos (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    monitored_channel_id INTEGER NOT NULL,
                    youtube_video_id TEXT NOT NULL,
                    title TEXT,
                    thumbnail_url TEXT,
                    pinned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    FOREIGN KEY (monitored_channel_id) REFERENCES monitored_channels (id) ON DELETE CASCADE,
                    UNIQUE(user_id, monitored_channel_id, youtube_video_id)
                );
            `);
        }

        // --- CRIAÇÃO DAS NOVAS TABELAS PARA ANALYTICS, BIBLIOTECA E INTEGRAÇÃO ---
        
        // Sistema de Analytics e Tracking
        await db.exec(`
            CREATE TABLE IF NOT EXISTS video_tracking (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                analysis_id INTEGER,
                youtube_video_id TEXT,
                title_used TEXT,
                thumbnail_used TEXT,
                predicted_ctr REAL,
                predicted_views INTEGER,
                actual_views INTEGER DEFAULT 0,
                actual_ctr REAL DEFAULT 0,
                actual_likes INTEGER DEFAULT 0,
                actual_comments INTEGER DEFAULT 0,
                revenue_estimate REAL DEFAULT 0,
                published_at DATETIME,
                tracked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (analysis_id) REFERENCES analyzed_videos(id) ON DELETE SET NULL
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS analytics_snapshots (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                video_tracking_id INTEGER,
                views INTEGER,
                likes INTEGER,
                comments INTEGER,
                ctr REAL,
                snapshot_date DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (video_tracking_id) REFERENCES video_tracking(id) ON DELETE CASCADE
            );
        `);

        // Biblioteca de Títulos Virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_titles_library (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                title TEXT NOT NULL,
                niche TEXT,
                subniche TEXT,
                original_views INTEGER,
                original_ctr REAL,
                formula_type TEXT,
                keywords TEXT,
                viral_score INTEGER,
                is_favorite INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS title_templates (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                template_name TEXT NOT NULL,
                template_pattern TEXT NOT NULL,
                niche TEXT,
                subniche TEXT,
                usage_count INTEGER DEFAULT 0,
                success_rate REAL DEFAULT 0,
                is_public INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Biblioteca de Thumbnails Virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_thumbnails_library (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                thumbnail_url TEXT,
                thumbnail_description TEXT,
                niche TEXT,
                subniche TEXT,
                original_views INTEGER,
                original_ctr REAL,
                style TEXT,
                elements TEXT,
                viral_score INTEGER,
                is_favorite INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS thumbnail_templates (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                template_name TEXT NOT NULL,
                template_description TEXT NOT NULL,
                niche TEXT,
                subniche TEXT,
                style TEXT,
                usage_count INTEGER DEFAULT 0,
                success_rate REAL DEFAULT 0,
                is_public INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Integração YouTube API
        await db.exec(`
            CREATE TABLE IF NOT EXISTS youtube_integrations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                channel_id TEXT,
                channel_name TEXT,
                language TEXT,
                country TEXT,
                access_token TEXT,
                refresh_token TEXT,
                token_expires_at DATETIME,
                is_active INTEGER DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
            
            -- Criar índice para melhor performance (sem UNIQUE para permitir múltiplos canais)
            CREATE INDEX IF NOT EXISTS idx_youtube_integrations_user_channel 
            ON youtube_integrations(user_id, channel_id);
        `);

        // Sistema de Créditos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS api_providers (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                provider TEXT NOT NULL,
                model TEXT NOT NULL,
                api_key TEXT NOT NULL,
                unit_type TEXT NOT NULL DEFAULT 'tokens',
                unit_size INTEGER NOT NULL DEFAULT 1000,
                real_cost_per_unit REAL NOT NULL DEFAULT 0.0,
                credits_per_unit REAL NOT NULL DEFAULT 1.0,
                markup REAL NOT NULL DEFAULT 1.0,
                is_premium INTEGER NOT NULL DEFAULT 0,
                is_active INTEGER NOT NULL DEFAULT 1,
                is_default INTEGER NOT NULL DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_credits (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL UNIQUE,
                balance REAL NOT NULL DEFAULT 0.0,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS credit_transactions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                amount REAL NOT NULL,
                transaction_type TEXT NOT NULL,
                description TEXT,
                admin_id INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (admin_id) REFERENCES users(id)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS credit_usage (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                api_provider_id INTEGER NOT NULL,
                credits_used REAL NOT NULL,
                units_consumed REAL NOT NULL,
                operation_type TEXT NOT NULL,
                details TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (api_provider_id) REFERENCES api_providers(id)
            );
        `);

        // Tabela de configurações da aplicação
        await db.exec(`
            CREATE TABLE IF NOT EXISTS app_settings (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        `);

        // Tabela de preferências do usuário
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_preferences (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL UNIQUE,
                use_credits_instead_of_own_api INTEGER NOT NULL DEFAULT 0,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Inicializar configurações padrão
        try {
            const initialBonus = await db.get("SELECT value FROM app_settings WHERE key = 'initial_bonus_credits'");
            if (!initialBonus) {
                await db.run("INSERT INTO app_settings (key, value) VALUES ('initial_bonus_credits', '0')");
            }
            
            const ttsMultiplier = await db.get("SELECT value FROM app_settings WHERE key = 'tts_credits_multiplier'");
            if (!ttsMultiplier) {
                await db.run("INSERT INTO app_settings (key, value) VALUES ('tts_credits_multiplier', '1.0')");
            }
            
            const laozhangUseAsDefault = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
            if (!laozhangUseAsDefault) {
                await db.run("INSERT INTO app_settings (key, value) VALUES ('laozhang_use_as_default', 'false')");
            }
        } catch (e) {
            console.log('Configurações já inicializadas ou erro:', e);
        }

        // Criar índices para melhor performance
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_user_credits_user_id ON user_credits(user_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_id ON credit_transactions(user_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_user_preferences_user_id ON user_preferences(user_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_transactions_created_at ON credit_transactions(created_at);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_usage_user_id ON credit_usage(user_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_usage_api_provider_id ON credit_usage(api_provider_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_usage_created_at ON credit_usage(created_at);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_api_providers_is_active ON api_providers(is_active);`);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS scheduled_posts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                youtube_integration_id INTEGER,
                video_file_path TEXT,
                title TEXT NOT NULL,
                description TEXT,
                tags TEXT,
                thumbnail_url TEXT,
                scheduled_time DATETIME NOT NULL,
                status TEXT DEFAULT 'pending',
                published_video_id TEXT,
                error_message TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (youtube_integration_id) REFERENCES youtube_integrations(id) ON DELETE CASCADE
            );
        `);

        // === PARTE 2: TABELAS PARA MONITORAMENTO AUTOMÁTICO ===
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_alerts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                competitor_channel_id TEXT,
                competitor_channel_name TEXT,
                video_id TEXT NOT NULL,
                video_title TEXT,
                video_url TEXT,
                views INTEGER,
                views_per_day REAL,
                detected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                notified INTEGER DEFAULT 0,
                notified_at DATETIME,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS trend_analysis (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                niche TEXT,
                subniche TEXT,
                video_id TEXT NOT NULL,
                video_title TEXT,
                video_url TEXT,
                channel_id TEXT,
                channel_name TEXT,
                views INTEGER,
                views_per_day REAL,
                detected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                analyzed INTEGER DEFAULT 0,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS competitor_monitoring (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                competitor_channel_id TEXT NOT NULL,
                competitor_channel_name TEXT,
                niche TEXT,
                subniche TEXT,
                auto_analyze INTEGER DEFAULT 1,
                last_checked DATETIME,
                check_frequency TEXT DEFAULT 'daily',
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                UNIQUE(user_id, competitor_channel_id)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS ai_suggestions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                suggestion_type TEXT NOT NULL,
                title TEXT,
                description TEXT,
                niche TEXT,
                subniche TEXT,
                reason TEXT,
                priority INTEGER DEFAULT 5,
                viewed INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Tabela para agentes de roteiro
        await db.exec(`
            CREATE TABLE IF NOT EXISTS script_agents (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                agent_name TEXT NOT NULL,
                niche TEXT,
                subniche TEXT,
                source_video_id TEXT,
                source_video_url TEXT,
                source_video_title TEXT,
                full_transcript TEXT,
                agent_prompt TEXT,
                agent_instructions TEXT,
                viral_formula_json TEXT,
                usage_count INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Garantir que a coluna viral_formula_json exista (migração suave)
        try {
            await db.run(`ALTER TABLE script_agents ADD COLUMN viral_formula_json TEXT`);
            console.log('[DB] Coluna viral_formula_json adicionada à tabela script_agents.');
        } catch (columnErr) {
            if (!/duplicate column name/i.test(columnErr.message)) {
                throw columnErr;
            }
        }

        // Tabela para roteiros gerados
        await db.exec(`
            CREATE TABLE IF NOT EXISTS generated_scripts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                script_agent_id INTEGER,
                title TEXT NOT NULL,
                script_content TEXT NOT NULL,
                model_used TEXT,
                niche TEXT,
                subniche TEXT,
                optimization_score REAL,
                optimization_report TEXT,
                retention_score REAL,
                authenticity_score REAL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (script_agent_id) REFERENCES script_agents(id) ON DELETE SET NULL
            );
        `);

        // Tabela para Agentes Virais (seguindo modelo Claude AI)
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_agents (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                description TEXT,
                memory TEXT,
                instructions TEXT,
                model TEXT DEFAULT 'gpt-4o',
                is_favorite BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        // Adicionar coluna model se não existir (migração)
        try {
            await db.run(`ALTER TABLE viral_agents ADD COLUMN model TEXT DEFAULT 'gpt-4o'`);
            console.log('[DB] Coluna model adicionada à tabela viral_agents.');
        } catch (columnErr) {
            if (!/duplicate column name/i.test(columnErr.message)) {
                throw columnErr;
            }
        }

        // Tabela para arquivos dos agentes virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_agent_files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                agent_id INTEGER NOT NULL,
                file_name TEXT NOT NULL,
                file_content TEXT,
                file_type TEXT,
                file_size INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (agent_id) REFERENCES viral_agents(id) ON DELETE CASCADE
            );
        `);

        // Tabela para conversas com agentes virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_agent_conversations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                agent_id INTEGER NOT NULL,
                user_id INTEGER NOT NULL,
                title TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (agent_id) REFERENCES viral_agents(id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Tabela para mensagens das conversas
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_agent_messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                conversation_id INTEGER NOT NULL,
                role TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (conversation_id) REFERENCES viral_agent_conversations(id) ON DELETE CASCADE
            );
        `);

        // Tabela para histórico de prompts de cena
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS video_operations_cache (
                operation_id TEXT PRIMARY KEY,
                user_id INTEGER NOT NULL,
                api_key_source TEXT NOT NULL,
                user_key_id INTEGER,
                admin_api_id INTEGER,
                use_laozhang INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        console.log('✅ Novas tabelas criadas: Analytics, Biblioteca, Integração YouTube, Agentes de Roteiro e Histórico de Prompts de Cena');
        
        // === MIGRAÇÃO: Remover constraint UNIQUE de youtube_integrations (permitir múltiplos canais) ===
        try {
            const tableInfo = await db.all("PRAGMA table_info(youtube_integrations)");
            const indexes = await db.all("PRAGMA index_list(youtube_integrations)");
            
            // Verificar se existe constraint UNIQUE (através de índices únicos)
            const uniqueIndexes = indexes.filter(idx => idx.unique === 1);
            if (uniqueIndexes.length > 0) {
                console.log('MIGRATION: Removendo constraint UNIQUE de youtube_integrations para permitir múltiplos canais...');
                
                // Recriar tabela sem UNIQUE
                await db.exec(`
                    CREATE TABLE IF NOT EXISTS youtube_integrations_new (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        channel_id TEXT,
                        channel_name TEXT,
                        access_token TEXT,
                        refresh_token TEXT,
                        token_expires_at DATETIME,
                        is_active INTEGER DEFAULT 1,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                    );
                `);
                
                await db.exec(`INSERT INTO youtube_integrations_new SELECT * FROM youtube_integrations;`);
                await db.exec(`DROP TABLE youtube_integrations;`);
                await db.exec(`ALTER TABLE youtube_integrations_new RENAME TO youtube_integrations;`);
                
                // Criar índice não-único para performance
                await db.exec(`
                    CREATE INDEX IF NOT EXISTS idx_youtube_integrations_user_channel 
                    ON youtube_integrations(user_id, channel_id);
                `);
                
                console.log('✅ Migração concluída: múltiplos canais agora são permitidos');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migração de youtube_integrations:', migrationErr.message);
        }

        // === MIGRAÇÃO: Adicionar campos niche e subniche em youtube_integrations ===
        try {
            const youtubeIntegrationsInfo = await db.all("PRAGMA table_info(youtube_integrations)");
            const hasNiche = youtubeIntegrationsInfo.some(c => c.name === 'niche');
            const hasSubniche = youtubeIntegrationsInfo.some(c => c.name === 'subniche');
            const hasLanguage = youtubeIntegrationsInfo.some(c => c.name === 'language');
            const hasCountry = youtubeIntegrationsInfo.some(c => c.name === 'country');
            
            if (!hasNiche) {
                console.log('MIGRATION: Adicionando coluna "niche" em youtube_integrations...');
                await db.exec(`ALTER TABLE youtube_integrations ADD COLUMN niche TEXT`);
            }
            if (!hasSubniche) {
                console.log('MIGRATION: Adicionando coluna "subniche" em youtube_integrations...');
                await db.exec(`ALTER TABLE youtube_integrations ADD COLUMN subniche TEXT`);
            }
            if (!hasLanguage) {
                console.log('MIGRATION: Adicionando coluna "language" em youtube_integrations...');
                await db.exec(`ALTER TABLE youtube_integrations ADD COLUMN language TEXT`);
            }
            if (!hasCountry) {
                console.log('MIGRATION: Adicionando coluna "country" em youtube_integrations...');
                await db.exec(`ALTER TABLE youtube_integrations ADD COLUMN country TEXT`);
            }
            if (!hasNiche || !hasSubniche || !hasLanguage || !hasCountry) {
                console.log('✅ Migração concluída: campos niche/subniche/language/country adicionados em youtube_integrations');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migração de youtube_integrations (niche/subniche):', migrationErr.message);
        }
        
        // === MIGRAÇÃO: Adicionar colunas de otimização em generated_scripts ===
        try {
            const scriptsInfo = await db.all("PRAGMA table_info(generated_scripts)");
            const hasOptimizationScore = scriptsInfo.some(c => c.name === 'optimization_score');
            const hasOptimizationReport = scriptsInfo.some(c => c.name === 'optimization_report');
            const hasRetentionScore = scriptsInfo.some(c => c.name === 'retention_score');
            const hasAuthenticityScore = scriptsInfo.some(c => c.name === 'authenticity_score');
            
            if (!hasOptimizationScore) {
                console.log('MIGRATION: Adicionando coluna "optimization_score" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN optimization_score REAL`);
            }
            if (!hasOptimizationReport) {
                console.log('MIGRATION: Adicionando coluna "optimization_report" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN optimization_report TEXT`);
            }
            if (!hasRetentionScore) {
                console.log('MIGRATION: Adicionando coluna "retention_score" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN retention_score REAL`);
            }
            if (!hasAuthenticityScore) {
                console.log('MIGRATION: Adicionando coluna "authenticity_score" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN authenticity_score REAL`);
            }
            if (!hasOptimizationScore || !hasOptimizationReport || !hasRetentionScore || !hasAuthenticityScore) {
                console.log('✅ Migração concluída: campos de otimização adicionados em generated_scripts');
            }
            
            // Verificar e adicionar colunas duration_minutes e language se não existirem
            const hasDurationMinutes = scriptsInfo.some(col => col.name === 'duration_minutes');
            const hasLanguage = scriptsInfo.some(col => col.name === 'language');
            
            if (!hasDurationMinutes) {
                console.log('MIGRATION: Adicionando coluna "duration_minutes" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN duration_minutes INTEGER`);
            }
            if (!hasLanguage) {
                console.log('MIGRATION: Adicionando coluna "language" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN language TEXT`);
            }
            if (!hasDurationMinutes || !hasLanguage) {
                console.log('✅ Migração concluída: campos duration_minutes e language adicionados em generated_scripts');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migração de generated_scripts (optimization):', migrationErr.message);
        }
        
        // === MIGRAÇÃO: Corrigir tabela viral_thumbnails_library ===
        try {
            const thumbnailsInfo = await db.all("PRAGMA table_info(viral_thumbnails_library)");
            const thumbnailUrlColumn = thumbnailsInfo.find(c => c.name === 'thumbnail_url');
            if (thumbnailUrlColumn && thumbnailUrlColumn.notnull === 1) {
                console.log('MIGRATION: Corrigindo constraint NOT NULL em viral_thumbnails_library.thumbnail_url...');
                // SQLite não suporta ALTER TABLE para remover NOT NULL diretamente
                // Vamos recriar a tabela sem o NOT NULL
                await db.exec(`
                    CREATE TABLE IF NOT EXISTS viral_thumbnails_library_new (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER,
                        thumbnail_url TEXT,
                        thumbnail_description TEXT,
                        niche TEXT,
                        subniche TEXT,
                        original_views INTEGER,
                        original_ctr REAL,
                        style TEXT,
                        elements TEXT,
                        viral_score INTEGER,
                        is_favorite INTEGER DEFAULT 0,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                    );
                `);
                await db.exec(`INSERT INTO viral_thumbnails_library_new SELECT * FROM viral_thumbnails_library;`);
                await db.exec(`DROP TABLE viral_thumbnails_library;`);
                await db.exec(`ALTER TABLE viral_thumbnails_library_new RENAME TO viral_thumbnails_library;`);
                console.log('✅ Migração concluída: thumbnail_url agora é opcional');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migração de viral_thumbnails_library:', migrationErr.message);
        }

        // === TABELA DE CANAIS DO USUÁRIO ===
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_channels (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                channel_name TEXT NOT NULL,
                channel_url TEXT,
                channel_id TEXT,
                niche TEXT,
                language TEXT DEFAULT 'pt-BR',
                country TEXT DEFAULT 'BR',
                is_active INTEGER DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                UNIQUE(user_id, channel_name)
            );
        `);

        // Adicionar coluna channel_id na tabela video_tracking se não existir
        try {
            const trackingInfo = await db.all("PRAGMA table_info(video_tracking)");
            if (!trackingInfo.some(c => c.name === 'channel_id')) {
                console.log('MIGRATION: Adicionando coluna channel_id em video_tracking...');
                await db.exec('ALTER TABLE video_tracking ADD COLUMN channel_id INTEGER REFERENCES user_channels(id) ON DELETE SET NULL');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migração de video_tracking:', migrationErr.message);
        }
        // Adicionar coluna full_transcript na tabela analyzed_videos se não existir
        try {
            const analyzedVideosInfo = await db.all("PRAGMA table_info(analyzed_videos)");
            if (!analyzedVideosInfo.some(c => c.name === 'full_transcript')) {
                console.log('MIGRATION: Adicionando coluna full_transcript em analyzed_videos...');
                await db.exec('ALTER TABLE analyzed_videos ADD COLUMN full_transcript TEXT');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migração de analyzed_videos (full_transcript):', migrationErr.message);
        }
        
        console.log('Tabelas e colunas sincronizadas.');

        // --- CRIAÇÃO DO ADMIN ---
        const adminEmail = 'rudysilvaads@gmail.com';
        const adminPassword = '253031';
        
        const adminExists = await db.get('SELECT * FROM users WHERE email = ?', [adminEmail]);
        
        if (!adminExists) {
            console.log('Criando utilizador administrador...');
            const salt = await bcrypt.genSalt(10);
            const admin_pass_hash = await bcrypt.hash(adminPassword, salt);
            
            await db.run(
                'INSERT INTO users (name, email, whatsapp, password_hash, isAdmin, isApproved) VALUES (?, ?, ?, ?, ?, ?)',
                ['Admin Core', adminEmail, '(00) 00000-0000', admin_pass_hash, 1, 1]
            );
            console.log('Utilizador administrador criado com sucesso!');
        } else {
            await db.run('UPDATE users SET isAdmin = 1, isBlocked = 0, isApproved = 1 WHERE email = ?', [adminEmail]);
            console.log('Utilizador administrador já existe. Status verificado.');
        }

        console.log('✅ Banco de dados inicializado com sucesso!');
        
        // Sinalizar que o banco está pronto ANTES de operações pesadas
        global.dbReady = true;
        
        // Executar rehydrate em background (não bloqueia o servidor)
        rehydratePendingVideoOperations().catch(err => {
            console.error('[VideoCache] Erro ao reidratar operações (não crítico):', err.message);
        });
        
    } catch (err) {
        console.error('❌ Erro ao conectar ou inicializar o banco de dados:', err);
        global.dbReady = false;
    }
})();


// --- ROTAS DE API ---
// ================================================
// ROTAS DE NOTIFICAÇÕES
// ================================================

// GET /api/notifications/pending - Obter notificações pendentes do usuário
app.get('/api/notifications/pending', authenticateToken, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS notifications (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    title TEXT NOT NULL,
                    message TEXT NOT NULL,
                    type TEXT DEFAULT 'info',
                    is_read BOOLEAN DEFAULT 0,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const notifications = await db.all(
            'SELECT * FROM notifications WHERE (user_id IS NULL OR user_id = ?) AND is_read = 0 ORDER BY created_at DESC LIMIT 10',
            [req.user.id]
        );
        res.json(notifications);
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao buscar notificações:', error);
        res.status(500).json({ message: 'Erro ao buscar notificações: ' + error.message });
    }
});

// POST /api/notifications/:id/read - Marcar notificação como lida
app.post('/api/notifications/:id/read', authenticateToken, async (req, res) => {
    try {
        await db.run('UPDATE notifications SET is_read = 1 WHERE id = ?', [req.params.id]);
        res.json({ success: true });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao marcar notificação como lida:', error);
        res.status(500).json({ message: 'Erro ao marcar notificação como lida' });
    }
});

// POST /api/admin/notifications/create - Criar notificação (admin)
app.post('/api/admin/notifications/create', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { title, message, type = 'info', user_id = null } = req.body;
        
        if (!title || !message) {
            return res.status(400).json({ message: 'Título e mensagem são obrigatórios' });
        }
        
        await db.run(
            'INSERT INTO notifications (user_id, title, message, type) VALUES (?, ?, ?, ?)',
            [user_id, title, message, type]
        );
        
        res.json({ success: true, message: 'Notificação criada com sucesso' });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao criar notificação:', error);
        res.status(500).json({ message: 'Erro ao criar notificação' });
    }
});

// GET /api/admin/notifications/config - Obter configurações de notificações
app.get('/api/admin/notifications/config', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS notification_config (
                    key TEXT PRIMARY KEY,
                    value TEXT NOT NULL,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const configs = await db.all('SELECT * FROM notification_config');
        const config = {};
        configs.forEach(c => {
            config[c.key] = c.value;
        });
        
        // Valores padrão
        res.json({
            purchase_enabled: config.purchase_enabled === 'true',
            purchase_interval: parseInt(config.purchase_interval) || 5,
            purchase_message: config.purchase_message || '🎉 {name} acabou de comprar o plano {plan}!',
            user_enabled: config.user_enabled === 'true',
            user_interval: parseInt(config.user_interval) || 5,
            user_message: config.user_message || '👋 {name} acabou de se cadastrar na plataforma!'
        });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao buscar configurações:', error);
        res.status(500).json({ message: 'Erro ao buscar configurações: ' + error.message });
    }
});

// POST /api/admin/notifications/config - Salvar configurações de notificações
app.post('/api/admin/notifications/config', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS notification_config (
                    key TEXT PRIMARY KEY,
                    value TEXT NOT NULL,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const { purchase_enabled, purchase_interval, purchase_message, user_enabled, user_interval, user_message } = req.body;
        
        const configs = [
            { key: 'purchase_enabled', value: String(purchase_enabled || false) },
            { key: 'purchase_interval', value: String(purchase_interval || 5) },
            { key: 'purchase_message', value: purchase_message || '🎉 {name} acabou de comprar o plano {plan}!' },
            { key: 'user_enabled', value: String(user_enabled || false) },
            { key: 'user_interval', value: String(user_interval || 5) },
            { key: 'user_message', value: user_message || '👋 {name} acabou de se cadastrar na plataforma!' }
        ];
        
        for (const config of configs) {
            await db.run(
                'INSERT OR REPLACE INTO notification_config (key, value, updated_at) VALUES (?, ?, CURRENT_TIMESTAMP)',
                [config.key, config.value]
            );
        }
        
        res.json({ success: true, message: 'Configurações salvas com sucesso' });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao salvar configurações:', error);
        res.status(500).json({ message: 'Erro ao salvar configurações: ' + error.message });
    }
});

// GET /api/admin/notifications/fake-users - Listar usuários fictícios
app.get('/api/admin/notifications/fake-users', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS fake_users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    email TEXT NOT NULL,
                    type TEXT DEFAULT 'purchase',
                    is_active BOOLEAN DEFAULT 1,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const users = await db.all('SELECT * FROM fake_users ORDER BY created_at DESC');
        res.json(users);
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao listar usuários fictícios:', error);
        res.status(500).json({ message: 'Erro ao listar usuários fictícios: ' + error.message });
    }
});

// POST /api/admin/notifications/fake-users - Criar usuário fictício
app.post('/api/admin/notifications/fake-users', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS fake_users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    email TEXT NOT NULL,
                    type TEXT DEFAULT 'purchase',
                    plan_name TEXT DEFAULT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const { name, email, type = 'purchase', plan_name = null, bulk = false } = req.body;
        
        if (bulk && Array.isArray(req.body.users)) {
            // Criar múltiplos usuários
            const results = [];
            for (const user of req.body.users) {
                try {
                    const result = await db.run(
                        'INSERT INTO fake_users (name, email, type, plan_name) VALUES (?, ?, ?, ?)',
                        [user.name, user.email, user.type, user.plan_name || null]
                    );
                    results.push({ id: result.lastID, email: user.email });
                } catch (err) {
                    console.error(`[NOTIFICATIONS] Erro ao criar usuário ${user.email}:`, err);
                }
            }
            res.json({ success: true, created: results.length, message: `${results.length} usuários fictícios criados com sucesso` });
        } else {
            if (!name || !email) {
                return res.status(400).json({ message: 'Nome e email são obrigatórios' });
            }
            
            const result = await db.run(
                'INSERT INTO fake_users (name, email, type, plan_name) VALUES (?, ?, ?, ?)',
                [name, email, type, plan_name]
            );
            
            res.json({ success: true, id: result.lastID, message: 'Usuário fictício criado com sucesso' });
        }
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao criar usuário fictício:', error);
        res.status(500).json({ message: 'Erro ao criar usuário fictício: ' + error.message });
    }
});

// DELETE /api/admin/notifications/fake-users/:id - Deletar usuário fictício
app.delete('/api/admin/notifications/fake-users/:id', authenticateToken, isAdmin, async (req, res) => {
    try {
        await db.run('DELETE FROM fake_users WHERE id = ?', [req.params.id]);
        res.json({ success: true, message: 'Usuário fictício deletado com sucesso' });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao deletar usuário fictício:', error);
        res.status(500).json({ message: 'Erro ao deletar usuário fictício' });
    }
});

// POST /api/admin/notifications/loop/start - Iniciar loop de notificações
app.post('/api/admin/notifications/loop/start', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { loop_type, interval_seconds } = req.body;
        
        if (!loop_type || (loop_type !== 'purchase' && loop_type !== 'user')) {
            return res.status(400).json({ message: 'Tipo de loop inválido. Use "purchase" ou "user"' });
        }
        
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS active_loops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    loop_type TEXT NOT NULL UNIQUE,
                    is_active BOOLEAN DEFAULT 0,
                    interval_seconds INTEGER DEFAULT 5,
                    started_at DATETIME,
                    stopped_at DATETIME,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        await db.run(
            'INSERT OR REPLACE INTO active_loops (loop_type, is_active, interval_seconds, started_at, updated_at) VALUES (?, 1, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)',
            [loop_type, interval_seconds || 5]
        );
        
        console.log(`[NOTIFICATIONS] Loop ${loop_type} iniciado e salvo no banco de dados`);
        res.json({ success: true, message: `Loop ${loop_type} iniciado com sucesso` });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao iniciar loop:', error);
        res.status(500).json({ message: 'Erro ao iniciar loop: ' + error.message });
    }
});

// POST /api/admin/notifications/loop/stop - Parar loop de notificações
app.post('/api/admin/notifications/loop/stop', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { loop_type } = req.body;
        
        if (!loop_type || (loop_type !== 'purchase' && loop_type !== 'user')) {
            return res.status(400).json({ message: 'Tipo de loop inválido. Use "purchase" ou "user"' });
        }
        
        await db.run(
            'UPDATE active_loops SET is_active = 0, stopped_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP WHERE loop_type = ?',
            [loop_type]
        );
        
        // Parar o loop imediatamente
        if (notificationLoops[loop_type]) {
            clearInterval(notificationLoops[loop_type]);
            notificationLoops[loop_type] = null;
        }
        
        console.log(`[NOTIFICATIONS] Loop ${loop_type} parado e salvo no banco de dados`);
        res.json({ success: true, message: `Loop ${loop_type} parado com sucesso` });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao parar loop:', error);
        res.status(500).json({ message: 'Erro ao parar loop: ' + error.message });
    }
});

// GET /api/admin/notifications/loop/status - Verificar status dos loops
app.get('/api/admin/notifications/loop/status', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS active_loops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    loop_type TEXT NOT NULL UNIQUE,
                    is_active BOOLEAN DEFAULT 0,
                    interval_seconds INTEGER DEFAULT 5,
                    started_at DATETIME,
                    stopped_at DATETIME,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const loops = await db.all('SELECT * FROM active_loops');
        const status = {
            purchase: { is_active: false, interval_seconds: 5 },
            user: { is_active: false, interval_seconds: 5 }
        };
        
        loops.forEach(loop => {
            if (loop.loop_type === 'purchase' || loop.loop_type === 'user') {
                status[loop.loop_type] = {
                    is_active: loop.is_active === 1,
                    interval_seconds: loop.interval_seconds,
                    started_at: loop.started_at,
                    stopped_at: loop.stopped_at
                };
            }
        });
        
        res.json(status);
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao verificar status dos loops:', error);
        res.status(500).json({ message: 'Erro ao verificar status dos loops: ' + error.message });
    }
});

// ================================================
// SISTEMA DE PERMISSÕES DE PLANOS
// ================================================

// Middleware para verificar permissão de funcionalidade
function checkPlanPermission(featureName) {
    return async (req, res, next) => {
        try {
            const userId = req.user.id;
            
            // Admin sempre tem acesso
            const user = await db.get('SELECT isAdmin FROM users WHERE id = ?', [userId]);
            if (user && (user.isAdmin === 1 || user.isAdmin === true || String(user.isAdmin) === '1')) {
                return next();
            }
            
            // Obter plano do usuário
            const userData = await db.get('SELECT plan, subscription_plan FROM users WHERE id = ?', [userId]);
            if (!userData) {
                return res.status(403).json({ message: 'Usuário não encontrado' });
            }
            
            const planName = userData.subscription_plan || userData.plan || 'plan-free';
            
            // Verificar permissão
            const permission = await db.get(
                'SELECT is_allowed FROM plan_permissions WHERE plan_name = ? AND feature_name = ?',
                [planName, featureName]
            );
            
            if (!permission || permission.is_allowed === 0) {
                return res.status(403).json({ 
                    message: `Esta funcionalidade não está disponível no seu plano atual.`,
                    feature: featureName,
                    plan: planName
                });
            }
            
            next();
        } catch (error) {
            console.error('[PERMISSIONS] Erro ao verificar permissão:', error);
            res.status(500).json({ message: 'Erro ao verificar permissão' });
        }
    };
}

// GET /api/admin/plan-permissions - Listar todas as permissões
app.get('/api/admin/plan-permissions', authenticateToken, isAdmin, async (req, res) => {
    try {
        const permissions = await db.all(`
            SELECT pp.*, pc.monthly_credits
            FROM plan_permissions pp
            LEFT JOIN plan_credits pc ON pp.plan_name = pc.plan_name
            ORDER BY pp.plan_name, pp.feature_name
        `);
        
        // Organizar por plano
        const organized = {};
        permissions.forEach(p => {
            if (!organized[p.plan_name]) {
                organized[p.plan_name] = {
                    plan_name: p.plan_name,
                    monthly_credits: p.monthly_credits || 0,
                    features: {}
                };
            }
            organized[p.plan_name].features[p.feature_name] = p.is_allowed === 1;
        });
        
        res.json(organized);
    } catch (error) {
        console.error('[PERMISSIONS] Erro ao listar permissões:', error);
        res.status(500).json({ message: 'Erro ao listar permissões' });
    }
});

// PUT /api/admin/plan-permissions/:planName/:featureName - Atualizar permissão
app.put('/api/admin/plan-permissions/:planName/:featureName', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { planName, featureName } = req.params;
        const { is_allowed } = req.body;
        
        await db.run(`
            INSERT OR REPLACE INTO plan_permissions (plan_name, feature_name, is_allowed, updated_at)
            VALUES (?, ?, ?, CURRENT_TIMESTAMP)
        `, [planName, featureName, is_allowed ? 1 : 0]);
        
        res.json({ success: true, message: 'Permissão atualizada com sucesso' });
    } catch (error) {
        console.error('[PERMISSIONS] Erro ao atualizar permissão:', error);
        res.status(500).json({ message: 'Erro ao atualizar permissão' });
    }
});

// PUT /api/admin/plan-credits/:planName - Atualizar créditos do plano
app.put('/api/admin/plan-credits/:planName', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { planName } = req.params;
        const { monthly_credits } = req.body;
        
        if (!monthly_credits || monthly_credits < 0) {
            return res.status(400).json({ message: 'Créditos mensais inválidos' });
        }
        
        await db.run(`
            INSERT OR REPLACE INTO plan_credits (plan_name, monthly_credits, updated_at)
            VALUES (?, ?, CURRENT_TIMESTAMP)
        `, [planName, monthly_credits]);
        
        res.json({ success: true, message: 'Créditos do plano atualizados com sucesso' });
    } catch (error) {
        console.error('[PLAN CREDITS] Erro ao atualizar créditos:', error);
        res.status(500).json({ message: 'Erro ao atualizar créditos' });
    }
});

// GET /api/user/permissions - Obter permissões do usuário atual
app.get('/api/user/permissions', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        
        // Admin sempre tem todas as permissões
        const user = await db.get('SELECT isAdmin FROM users WHERE id = ?', [userId]);
        if (user && (user.isAdmin === 1 || user.isAdmin === true || String(user.isAdmin) === '1')) {
            const allFeatures = ['video_analyzer', 'niche_explorer', 'script_generator', 'voice_generator', 
                               'image_generator', 'video_generator', 'youtube_integration', 'api_propria', 
                               'batch_images', 'analytics', 'viral_library'];
            const permissions = {};
            allFeatures.forEach(f => permissions[f] = true);
            return res.json({ permissions, plan: 'admin' });
        }
        
        // Obter plano do usuário
        const userData = await db.get('SELECT plan, subscription_plan FROM users WHERE id = ?', [userId]);
        const planName = userData?.subscription_plan || userData?.plan || 'plan-free';
        
        // Obter permissões
        const perms = await db.all(
            'SELECT feature_name, is_allowed FROM plan_permissions WHERE plan_name = ?',
            [planName]
        );
        
        const permissions = {};
        perms.forEach(p => {
            permissions[p.feature_name] = p.is_allowed === 1;
        });
        
        res.json({ permissions, plan: planName });
    } catch (error) {
        console.error('[PERMISSIONS] Erro ao obter permissões:', error);
        res.status(500).json({ message: 'Erro ao obter permissões' });
    }
});

// NOTA: Todas as rotas devem ser definidas ANTES do app.listen() para funcionarem corretamente

// === ROTAS DE AUTENTICAÇÃO ===

app.post('/api/auth/register', async (req, res) => {
    const { name, email, whatsapp, password } = req.body;

    if (!name || !email || !password) {
        return res.status(400).json({ msg: 'Por favor, preencha todos os campos obrigatórios.' });
    }

    try {
        const userExists = await db.get('SELECT * FROM users WHERE email = ?', [email]);
        if (userExists) {
            return res.status(400).json({ msg: 'Este e-mail já está registado.' });
        }

        const salt = await bcrypt.genSalt(10);
        const password_hash = await bcrypt.hash(password, salt);

        const result = await db.run(
            'INSERT INTO users (name, email, whatsapp, password_hash) VALUES (?, ?, ?, ?)',
            [name, email, whatsapp, password_hash]
        );
        
        const userId = result.lastID;
        
        // Inicializar saldo de créditos para novo usuário com bônus inicial
        try {
            const bonusSetting = await db.get("SELECT value FROM app_settings WHERE key = 'initial_bonus_credits'");
            const bonusAmount = bonusSetting ? parseFloat(bonusSetting.value) : 0;

            if (bonusAmount > 0) {
                await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, ?)', [userId, bonusAmount]);
                await db.run(
                    'INSERT INTO credit_transactions (user_id, amount, transaction_type, description, admin_id) VALUES (?, ?, ?, ?, NULL)',
                    [userId, bonusAmount, 'credit', 'Bônus de boas-vindas']
                );
                console.log(`✅ Créditos bônus iniciais (${bonusAmount}) adicionados para novo usuário ${email}`);
            } else {
                await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [userId]);
            }
        } catch (creditError) {
            console.error('⚠️ Erro ao inicializar créditos para novo usuário:', creditError);
        }

        // Enviar email de boas-vindas
        try {
            // Priorizar variável de ambiente, depois header, depois req.get('host')
            const baseUrl = process.env.BASE_URL || process.env.APP_URL || process.env.PUBLIC_URL;
            let loginUrl;
            
            if (baseUrl) {
                loginUrl = `${baseUrl.replace(/\/$/, '')}/la-casa-dark-core-auth.html`;
            } else {
                const protocol = req.protocol || (req.get('x-forwarded-proto') || 'http');
                const host = req.get('x-forwarded-host') || req.get('host') || 'localhost:5001';
                loginUrl = `${protocol}://${host}/la-casa-dark-core-auth.html`;
            }
            
            await sendTemplateEmail('register', email, {
                nome: name,
                email: email,
                creditos_iniciais: bonusAmount || 0,
                link_acesso: loginUrl
            });
        } catch (emailError) {
            console.error('[EMAIL] Erro ao enviar email de boas-vindas:', emailError.message);
            // Não falhar o registro se o email falhar
        }

        res.status(201).json({ msg: 'Utilizador registado com sucesso! A aguardar aprovação.', userId: userId });

    } catch (err) {
        console.error('Erro no registo:', err);
        res.status(500).json({ msg: 'Erro no servidor ao tentar registar.' });
    }
});

app.post('/api/auth/login', async (req, res) => {
    // Verificar se o banco de dados está inicializado
    if (!db) {
        return res.status(503).json({ msg: 'Servidor ainda não está pronto. Aguarde alguns instantes e tente novamente.' });
    }

    const { email, password } = req.body;

    if (!email || !password) {
        return res.status(400).json({ msg: 'Por favor, forneça e-mail e senha.' });
    }

    try {
        const user = await db.get('SELECT * FROM users WHERE email = ?', [email]);
        if (!user) {
            return res.status(400).json({ msg: 'Credenciais inválidas.' });
        }

        if (user.isBlocked) {
            return res.status(403).json({ msg: 'Esta conta está bloqueada. Entre em contacto com o suporte.' });
        }

        if (!user.isApproved && !user.isAdmin) {
            return res.status(403).json({ msg: 'A sua conta está pendente de aprovação.' });
        }

        const isMatch = await bcrypt.compare(password, user.password_hash);
        if (!isMatch) {
            return res.status(400).json({ msg: 'Credenciais inválidas.' });
        }

        await db.run('UPDATE users SET last_login_at = CURRENT_TIMESTAMP WHERE id = ?', [user.id]);

        const token = jwt.sign(
            { id: user.id, email: user.email, isAdmin: user.isAdmin },
            JWT_SECRET,
            { expiresIn: '8h' }
        );

        res.json({
            msg: 'Login feito com sucesso!',
            token,
            isAdmin: user.isAdmin
        });

    } catch (err) {
        console.error('Erro no login:', err);
        res.status(500).json({ msg: 'Erro no servidor durante o login.' });
    }
});

app.get('/api/auth/me', authenticateToken, async (req, res) => {
    try {
        const user = await db.get('SELECT id, name, email, whatsapp, isAdmin, isBlocked, plan, subscription_plan FROM users WHERE id = ?', [req.user.id]);
        
        if (!user) {
            return res.status(404).json({ msg: 'Utilizador não encontrado.' });
        }
        
        if (user.isBlocked) {
             return res.status(403).json({ msg: 'A sua conta foi bloqueada.' });
        }
        
        res.json(user);

    } catch (err) {
        console.error('Erro ao buscar dados do utilizador (/me):', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Rota para solicitar reset de senha
app.post('/api/auth/forgot-password', async (req, res) => {
    console.log('[AUTH] ========== SOLICITAÇÃO DE RESET DE SENHA ==========');
    console.log('[AUTH] Recebida requisição POST /api/auth/forgot-password');
    console.log('[AUTH] Body recebido:', JSON.stringify(req.body));
    
    const { email } = req.body;

    if (!email) {
        console.log('[AUTH] ❌ Email não fornecido');
        return res.status(400).json({ msg: 'Por favor, forneça um email.' });
    }

    console.log(`[AUTH] 📧 Processando reset de senha para: ${email}`);

    try {
        // Verificar se o usuário existe
        console.log('[AUTH] 🔍 Buscando usuário no banco de dados...');
        const user = await db.get('SELECT id, name, email FROM users WHERE email = ?', [email]);
        
        // Sempre retornar sucesso (por segurança, não revelar se o email existe ou não)
        const successMessage = 'Se este email estiver cadastrado, um link de reset será enviado!';
        
        if (user) {
            console.log(`[AUTH] ✅ Usuário encontrado: ${user.name} (ID: ${user.id})`);
            
            // Gerar token de reset (válido por 1 hora)
            console.log('[AUTH] 🔑 Gerando token de reset...');
            const resetToken = jwt.sign(
                { userId: user.id, type: 'password_reset' },
                JWT_SECRET,
                { expiresIn: '1h' }
            );
            console.log('[AUTH] ✅ Token gerado com sucesso');
            
            // Salvar token no banco de dados
            console.log('[AUTH] 💾 Salvando token no banco de dados...');
            await db.run(
                'INSERT OR REPLACE INTO password_reset_tokens (user_id, token, expires_at) VALUES (?, ?, datetime("now", "+1 hour"))',
                [user.id, resetToken]
            );
            console.log('[AUTH] ✅ Token salvo no banco de dados');
            
            // Construir URL de reset
            // Priorizar variável de ambiente, depois header X-Forwarded-Host, depois req.get('host')
            const baseUrl = process.env.BASE_URL || process.env.APP_URL || process.env.PUBLIC_URL;
            let resetUrl;
            
            if (baseUrl) {
                // Usar URL base configurada
                resetUrl = `${baseUrl.replace(/\/$/, '')}/la-casa-dark-core-auth.html?reset_token=${resetToken}`;
                console.log(`[AUTH] 🔗 Usando URL base configurada: ${baseUrl}`);
            } else {
                // Tentar detectar automaticamente
                const protocol = req.protocol || (req.get('x-forwarded-proto') || 'http');
                let host = req.get('x-forwarded-host') || req.get('host');
                
                // Se não tiver host, tentar usar o hostname da requisição
                if (!host) {
                    host = req.hostname || 'localhost:5001';
                    // Adicionar porta se não estiver no hostname
                    if (!host.includes(':') && req.socket && req.socket.localPort) {
                        host = `${host}:${req.socket.localPort}`;
                    } else if (!host.includes(':')) {
                        host = `${host}:5001`;
                    }
                }
                
                resetUrl = `${protocol}://${host}/la-casa-dark-core-auth.html?reset_token=${resetToken}`;
            }
            
            console.log(`[AUTH] 🔗 URL de reset gerada: ${resetUrl}`);
            console.log(`[AUTH] 📍 Servidor rodando na porta: ${PORT}`);
            console.log(`[AUTH] 🌐 Host detectado: ${req.get('host') || 'N/A'}`);
            console.log(`[AUTH] 🔒 Protocolo: ${req.protocol || 'http'}`);
            
            // Enviar email de reset
            console.log('[AUTH] 📨 Tentando enviar email de reset...');
            try {
                const emailResult = await sendTemplateEmail('password_reset', user.email, {
                    nome: user.name,
                    email: user.email,
                    senha_provisoria: null, // Não usamos senha provisória aqui
                    link_acesso: resetUrl
                });
                
                if (emailResult.success) {
                    console.log(`[AUTH] ✅ Email de reset de senha enviado com sucesso para: ${user.email}`);
                    console.log(`[AUTH] 📧 Message ID: ${emailResult.messageId || 'N/A'}`);
                    if (emailResult.accepted && emailResult.accepted.length > 0) {
                        console.log(`[AUTH] ✅ Email aceito para entrega: ${emailResult.accepted.join(', ')}`);
                    }
                    if (emailResult.rejected && emailResult.rejected.length > 0) {
                        console.error(`[AUTH] ❌ Email rejeitado: ${emailResult.rejected.join(', ')}`);
                    }
                    console.log(`[AUTH] 💡 Dica: Verifique a pasta de SPAM/Lixo Eletrônico se o email não chegar em alguns minutos.`);
                } else {
                    console.error(`[AUTH] ⚠️ Falha ao enviar email: ${emailResult.message || emailResult.error}`);
                }
            } catch (emailError) {
                console.error('[AUTH] ❌ Erro ao enviar email de reset:', emailError.message);
                console.error('[AUTH] Stack trace:', emailError.stack);
                // Continuar mesmo se o email falhar
            }
        } else {
            console.log(`[AUTH] ⚠️ Usuário não encontrado para o email: ${email}`);
            console.log('[AUTH] ℹ️ Retornando mensagem genérica por segurança');
        }
        
        // Sempre retornar a mesma mensagem (por segurança)
        console.log('[AUTH] ✅ Retornando resposta de sucesso');
        console.log('[AUTH] ============================================');
        res.json({ msg: successMessage });
        
    } catch (err) {
        console.error('[AUTH] ❌ Erro ao processar solicitação de reset de senha:', err);
        console.error('[AUTH] Stack trace:', err.stack);
        // Retornar sucesso mesmo em caso de erro (por segurança)
        res.json({ msg: 'Se este email estiver cadastrado, um link de reset será enviado!' });
    }
});

// ================================================
// ROTAS DO SISTEMA DE CRÉDITOS
// ================================================

// Função auxiliar para obter limite de armazenamento baseado no plano
async function getStorageLimit(planName, isAdmin = false, userId = null) {
    // Verificar se há limite customizado para o usuário
    if (userId) {
        try {
            const customLimit = await db.get('SELECT custom_limit FROM user_storage_limits WHERE user_id = ?', [userId]);
            if (customLimit) {
                return customLimit.custom_limit;
            }
        } catch (err) {
            // Tabela pode não existir ainda, continuar com limite padrão
        }
    }
    
    // Admin tem 100 GB de armazenamento e acesso ilimitado
    if (isAdmin) {
        return 100 * 1024 * 1024 * 1024; // 100 GB
    }
    
    const storageLimits = {
        'plan-free': 10 * 1024 * 1024, // 10 MB
        'plan-start': 150 * 1024 * 1024, // 150 MB
        'plan-turbo': 250 * 1024 * 1024, // 250 MB
        'plan-master': 500 * 1024 * 1024, // 500 MB
        'plan-start-annual': 1024 * 1024 * 1024, // 1 GB
        'plan-turbo-annual': 1024 * 1024 * 1024, // 1 GB
        'plan-master-annual': 1024 * 1024 * 1024 // 1 GB
    };
    return storageLimits[planName] || storageLimits['plan-free'];
}

// Função auxiliar para verificar se o usuário pode usar mais armazenamento
// Retorna true se pode usar, false se excedeu o limite
async function checkStorageLimit(userId, additionalSize = 0, isAdmin = false) {
    // Admin sempre tem acesso ilimitado
    if (isAdmin) {
        return true;
    }
    
    try {
        const storageUsed = await calculateUserStorage(userId);
        // Obter plano do usuário
        let userPlan = 'plan-free';
        try {
            const user = await db.get('SELECT plan, subscription_plan FROM users WHERE id = ?', [userId]);
            if (user) {
                userPlan = user.subscription_plan || user.plan || 'plan-free';
            }
        } catch (err) {
            // Usar padrão
        }
        
        const storageLimit = await getStorageLimit(userPlan, isAdmin, userId);
        return (storageUsed + additionalSize) <= storageLimit;
    } catch (error) {
        console.error('[STORAGE] Erro ao verificar limite de armazenamento:', error);
        return false; // Em caso de erro, bloquear por segurança
    }
}

// Função auxiliar para calcular tamanho de string/texto em bytes
function calculateTextSize(text) {
    if (!text) return 0;
    return Buffer.byteLength(String(text), 'utf8');
}

// Função para calcular e atualizar armazenamento usado por dados nas tabelas
async function calculateAndUpdateDatabaseStorage(userId) {
    try {
        let totalSize = 0;
        
        // 1. PASTAS E HISTÓRICOS
        // analysis_folders (apenas name, não tem description)
        try {
            const folders = await db.all('SELECT name FROM analysis_folders WHERE user_id = ?', [userId]);
            for (const folder of folders) {
                totalSize += calculateTextSize(folder.name);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de analysis_folders:', err.message);
        }
        
        // generated_scripts (roteiros)
        try {
            const scripts = await db.all(
                'SELECT title, script_content, optimization_report FROM generated_scripts WHERE user_id = ?', 
                [userId]
            );
            for (const script of scripts) {
                totalSize += calculateTextSize(script.title);
                totalSize += calculateTextSize(script.script_content);
                totalSize += calculateTextSize(script.optimization_report);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de generated_scripts:', err.message);
        }
        
        // analyzed_videos (usar colunas corretas: original_title, translated_title, analysis_data_json)
        try {
            const videos = await db.all(
                'SELECT original_title, translated_title, analysis_data_json FROM analyzed_videos WHERE user_id = ?', 
                [userId]
            );
            for (const video of videos) {
                totalSize += calculateTextSize(video.original_title);
                totalSize += calculateTextSize(video.translated_title);
                totalSize += calculateTextSize(video.analysis_data_json);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de analyzed_videos:', err.message);
        }
        
        // 2. CANAIS MONITORADOS
        // monitored_channels
        try {
            const channels = await db.all(
                'SELECT channel_name, channel_url FROM monitored_channels WHERE user_id = ?', 
                [userId]
            );
            for (const channel of channels) {
                totalSize += calculateTextSize(channel.channel_name);
                totalSize += calculateTextSize(channel.channel_url);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de monitored_channels:', err.message);
        }
        
        // youtube_integrations
        try {
            const integrations = await db.all(
                'SELECT channel_id, channel_name, access_token, refresh_token FROM youtube_integrations WHERE user_id = ?', 
                [userId]
            );
            for (const integration of integrations) {
                totalSize += calculateTextSize(integration.channel_id);
                totalSize += calculateTextSize(integration.channel_name);
                totalSize += calculateTextSize(integration.access_token);
                totalSize += calculateTextSize(integration.refresh_token);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de youtube_integrations:', err.message);
        }
        
        // pinned_videos
        try {
            const pinnedVideos = await db.all(
                'SELECT youtube_video_id, title FROM pinned_videos WHERE user_id = ?', 
                [userId]
            );
            for (const pinned of pinnedVideos) {
                totalSize += calculateTextSize(pinned.youtube_video_id);
                totalSize += calculateTextSize(pinned.title || '');
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de pinned_videos:', err.message);
        }
        
        // 3. BIBLIOTECA DE TÍTULOS E THUMBNAILS
        // generated_titles (através de analyzed_videos)
        try {
            const titles = await db.all(`
                SELECT gt.title_text, gt.explicacao 
                FROM generated_titles gt
                INNER JOIN analyzed_videos av ON gt.video_analysis_id = av.id
                WHERE av.user_id = ?
            `, [userId]);
            for (const title of titles) {
                totalSize += calculateTextSize(title.title_text);
                totalSize += calculateTextSize(title.explicacao);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de generated_titles:', err.message);
        }
        
        // generated_thumbnails (imagens em base64 - muito pesado)
        try {
            const thumbnails = await db.all(`
                SELECT gt.base_title, gt.description, gt.hook_phrases_json, gt.generated_image_base64
                FROM generated_thumbnails gt
                INNER JOIN analyzed_videos av ON gt.video_analysis_id = av.id
                WHERE av.user_id = ?
            `, [userId]);
            for (const thumb of thumbnails) {
                totalSize += calculateTextSize(thumb.base_title);
                totalSize += calculateTextSize(thumb.description);
                totalSize += calculateTextSize(thumb.hook_phrases_json);
                // Base64 de imagem é muito pesado
                totalSize += calculateTextSize(thumb.generated_image_base64);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de generated_thumbnails:', err.message);
        }
        
        // viral_thumbnails_library
        try {
            const viralThumbnails = await db.all(
                'SELECT thumbnail_url, thumbnail_description, niche, subniche, style, elements FROM viral_thumbnails_library WHERE user_id = ?', 
                [userId]
            );
            for (const thumb of viralThumbnails) {
                totalSize += calculateTextSize(thumb.thumbnail_url);
                totalSize += calculateTextSize(thumb.thumbnail_description);
                totalSize += calculateTextSize(thumb.niche);
                totalSize += calculateTextSize(thumb.subniche);
                totalSize += calculateTextSize(thumb.style);
                totalSize += calculateTextSize(thumb.elements);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de viral_thumbnails_library:', err.message);
        }
        
        // 4. AGENTES VIRAIS
        // viral_agents
        try {
            const viralAgents = await db.all(
                'SELECT name, description, memory, instructions FROM viral_agents WHERE user_id = ?', 
                [userId]
            );
            for (const agent of viralAgents) {
                totalSize += calculateTextSize(agent.name);
                totalSize += calculateTextSize(agent.description);
                totalSize += calculateTextSize(agent.memory);
                totalSize += calculateTextSize(agent.instructions);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de viral_agents:', err.message);
        }
        
        // viral_agent_files
        try {
            const agentFiles = await db.all(`
                SELECT vaf.file_name, vaf.file_content, vaf.file_type, vaf.file_size
                FROM viral_agent_files vaf
                INNER JOIN viral_agents va ON vaf.agent_id = va.id
                WHERE va.user_id = ?
            `, [userId]);
            for (const file of agentFiles) {
                totalSize += calculateTextSize(file.file_name);
                totalSize += calculateTextSize(file.file_content);
                totalSize += calculateTextSize(file.file_type);
                // Se file_size estiver disponível, usar ele (mais preciso)
                if (file.file_size) {
                    totalSize += file.file_size;
                }
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de viral_agent_files:', err.message);
        }
        
        // viral_agent_messages
        try {
            const agentMessages = await db.all(`
                SELECT vam.content
                FROM viral_agent_messages vam
                INNER JOIN viral_agent_conversations vac ON vam.conversation_id = vac.id
                WHERE vac.user_id = ?
            `, [userId]);
            for (const msg of agentMessages) {
                totalSize += calculateTextSize(msg.content);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de viral_agent_messages:', err.message);
        }
        
        // script_agents
        try {
            const scriptAgents = await db.all(
                'SELECT name, description, system_prompt, niche, subniche FROM script_agents WHERE user_id = ?', 
                [userId]
            );
            for (const agent of scriptAgents) {
                totalSize += calculateTextSize(agent.name);
                totalSize += calculateTextSize(agent.description);
                totalSize += calculateTextSize(agent.system_prompt);
                totalSize += calculateTextSize(agent.niche);
                totalSize += calculateTextSize(agent.subniche);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de script_agents:', err.message);
        }
        
        // 5. PROMPTS E IMAGENS
        // scene_prompts_history
        try {
            const scenePrompts = await db.all(
                'SELECT title, script, scenes_json FROM scene_prompts_history WHERE user_id = ?', 
                [userId]
            );
            for (const prompt of scenePrompts) {
                totalSize += calculateTextSize(prompt.title);
                totalSize += calculateTextSize(prompt.script);
                totalSize += calculateTextSize(prompt.scenes_json);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de scene_prompts_history:', err.message);
        }
        
        // Registrar o total calculado na tabela user_storage com um identificador único
        const storageKey = `database_data_${userId}`;
        const existing = await db.get(
            'SELECT id FROM user_storage WHERE user_id = ? AND file_path = ?',
            [userId, storageKey]
        );
        
        if (existing) {
            // Atualizar
            try {
                await db.run(
                    'UPDATE user_storage SET file_size = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
                    [totalSize, existing.id]
                );
            } catch (err) {
                // Se a coluna updated_at não existir, atualizar sem ela
                if (err.message && err.message.includes('updated_at')) {
                    await db.run(
                        'UPDATE user_storage SET file_size = ? WHERE id = ?',
                        [totalSize, existing.id]
                    );
                } else {
                    throw err;
                }
            }
        } else {
            // Inserir
            await db.run(
                'INSERT INTO user_storage (user_id, file_path, file_size, file_type) VALUES (?, ?, ?, ?)',
                [userId, storageKey, totalSize, 'database']
            );
        }
        
        console.log(`[STORAGE] Armazenamento de dados do banco calculado para usuário ${userId}: ${(totalSize / (1024 * 1024)).toFixed(2)} MB`);
        
        return totalSize;
    } catch (error) {
        console.error('[STORAGE] Erro ao calcular armazenamento do banco de dados:', error);
        return 0;
    }
}

// Função para recalcular armazenamento de forma assíncrona (não bloqueia)
function recalculateStorageAsync(userId) {
    // Executar de forma assíncrona sem bloquear
    setImmediate(async () => {
        try {
            await calculateAndUpdateDatabaseStorage(userId);
        } catch (error) {
            console.error(`[STORAGE] Erro ao recalcular armazenamento assíncrono para usuário ${userId}:`, error);
        }
    });
}

// Função auxiliar para calcular armazenamento usado pelo usuário
// Calcula baseado na tabela user_storage (arquivos + dados do banco)
async function calculateUserStorage(userId, forceRecalculate = false) {
    try {
        // Se forçar recálculo ou se não houver registro de dados do banco, recalcular
        const storageKey = `database_data_${userId}`;
        let existing = null;
        try {
            existing = await db.get(
                'SELECT id, updated_at FROM user_storage WHERE user_id = ? AND file_path = ?',
                [userId, storageKey]
            );
        } catch (err) {
            // Se a coluna updated_at não existir, buscar apenas id
            if (err.message && err.message.includes('updated_at')) {
                existing = await db.get(
                    'SELECT id FROM user_storage WHERE user_id = ? AND file_path = ?',
                    [userId, storageKey]
                );
            } else {
                throw err;
            }
        }
        
        // Recalcular se forçado ou se não existir registro ou se o registro for muito antigo (> 1 hora)
        const shouldRecalculate = forceRecalculate || !existing || 
            (existing && existing.updated_at && (Date.now() - new Date(existing.updated_at).getTime() > 3600000));
        
        if (shouldRecalculate) {
            await calculateAndUpdateDatabaseStorage(userId);
        }
        
        // Depois, somar tudo da tabela user_storage
        const result = await db.get(
            'SELECT COALESCE(SUM(file_size), 0) as total_size FROM user_storage WHERE user_id = ?', 
            [userId]
        );
        
        const totalSize = result?.total_size || 0;
        
        console.log(`[STORAGE] Armazenamento total calculado para usuário ${userId}: ${(totalSize / (1024 * 1024)).toFixed(2)} MB`);
        
        return totalSize;
    } catch (error) {
        console.error('[STORAGE] Erro ao calcular armazenamento:', error);
        return 0;
    }
}

// Função auxiliar para registrar um arquivo no armazenamento do usuário
async function registerUserStorage(userId, filePath, fileSize, fileType = null) {
    try {
        // Normalizar o caminho do arquivo (relativo ao diretório do servidor)
        const path = require('path');
        const normalizedPath = path.isAbsolute(filePath) 
            ? path.relative(__dirname, filePath) 
            : filePath;
        
        // Verificar se o arquivo já está registrado
        const existing = await db.get(
            'SELECT id FROM user_storage WHERE user_id = ? AND file_path = ?',
            [userId, normalizedPath]
        );
        
        if (existing) {
            // Atualizar tamanho se mudou
            try {
                await db.run(
                    'UPDATE user_storage SET file_size = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
                    [fileSize, existing.id]
                );
            } catch (err) {
                // Se a coluna updated_at não existir, atualizar sem ela
                if (err.message && err.message.includes('updated_at')) {
                    await db.run(
                        'UPDATE user_storage SET file_size = ? WHERE id = ?',
                        [fileSize, existing.id]
                    );
                } else {
                    throw err;
                }
            }
        } else {
            // Registrar novo arquivo
            await db.run(
                'INSERT INTO user_storage (user_id, file_path, file_size, file_type) VALUES (?, ?, ?, ?)',
                [userId, normalizedPath, fileSize, fileType]
            );
        }
        
        console.log(`[STORAGE] Arquivo registrado para usuário ${userId}: ${normalizedPath} (${(fileSize / 1024 / 1024).toFixed(2)} MB)`);
    } catch (error) {
        console.error('[STORAGE] Erro ao registrar armazenamento:', error);
    }
}

// Função auxiliar para remover registro de arquivo do armazenamento
async function unregisterUserStorage(userId, filePath) {
    try {
        const path = require('path');
        const normalizedPath = path.isAbsolute(filePath) 
            ? path.relative(__dirname, filePath) 
            : filePath;
        
        await db.run(
            'DELETE FROM user_storage WHERE user_id = ? AND file_path = ?',
            [userId, normalizedPath]
        );
        
        console.log(`[STORAGE] Arquivo removido do registro para usuário ${userId}: ${normalizedPath}`);
    } catch (error) {
        console.error('[STORAGE] Erro ao remover registro de armazenamento:', error);
    }
}

// GET /api/credits/balance - Usuário consulta seu próprio saldo
app.get('/api/credits/balance', authenticateToken, async (req, res) => {
    try {
        console.log('[CRÉDITOS API] Consultando saldo para usuário:', req.user.id);
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [req.user.id]);
        if (!credits) {
            console.log('[CRÉDITOS API] Criando registro de créditos para usuário:', req.user.id);
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [req.user.id]);
            credits = { balance: 0 };
        }
        
        // Obter plano do usuário e verificar se é admin
        let userPlan = 'plan-free'; // Padrão
        let isAdmin = false;
        
        // Primeiro verificar se req.user já tem isAdmin (do token)
        if (req.user && req.user.isAdmin !== undefined) {
            isAdmin = req.user.isAdmin === 1 || req.user.isAdmin === true || req.user.isAdmin === '1';
        }
        
        try {
            // Buscar dados completos do usuário incluindo plano
            const user = await db.get('SELECT id, isAdmin, email, plan, subscription_plan FROM users WHERE id = ?', [req.user.id]);
            if (user) {
                // Obter plano do usuário
                userPlan = user.subscription_plan || user.plan || 'plan-free';
                
                // Verificação robusta de isAdmin (SQLite retorna como INTEGER)
                const adminValue = user.isAdmin;
                // Verificar todas as possibilidades
                isAdmin = adminValue === 1 || 
                         adminValue === true || 
                         adminValue === '1' || 
                         String(adminValue) === '1' ||
                         Number(adminValue) === 1;
                
                console.log('[CRÉDITOS API] Usuário:', user.email, 'ID:', user.id);
                console.log('[CRÉDITOS API] isAdmin valor bruto:', adminValue, 'tipo:', typeof adminValue);
                console.log('[CRÉDITOS API] isAdmin resultado:', isAdmin);
                console.log('[CRÉDITOS API] userPlan:', userPlan);
            } else {
                console.log('[CRÉDITOS API] Usuário não encontrado no banco de dados para ID:', req.user.id);
            }
        } catch (err) {
            console.error('[CRÉDITOS API] Erro ao buscar usuário:', err);
        }
        
        console.log('[CRÉDITOS API] Verificação final - isAdmin:', isAdmin, 'userPlan:', userPlan);
        
        // Calcular armazenamento
        const storageUsed = await calculateUserStorage(req.user.id);
        const storageLimit = await getStorageLimit(userPlan, isAdmin, req.user.id);
        
        console.log('[CRÉDITOS API] Saldo encontrado:', credits.balance);
        console.log('[CRÉDITOS API] Armazenamento - Usado:', (storageUsed / (1024*1024)).toFixed(2), 'MB, Limite:', (storageLimit / (1024*1024*1024)).toFixed(2), 'GB, isAdmin:', isAdmin);
        res.json({ 
            balance: credits.balance,
            storageUsed: storageUsed,
            storageLimit: storageLimit,
            plan: userPlan,
            isAdmin: isAdmin // Incluir isAdmin na resposta para debug
        });
    } catch (error) {
        console.error('[CRÉDITOS API] Erro ao consultar saldo:', error);
        res.status(500).json({ message: 'Erro ao consultar saldo' });
    }
});

// GET /api/user/credits - Alias para /api/credits/balance (compatibilidade)
app.get('/api/user/credits', authenticateToken, async (req, res) => {
    try {
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [req.user.id]);
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [req.user.id]);
            credits = { balance: 0 };
        }
        
        // Obter plano e armazenamento
        let userPlan = 'plan-free';
        let isAdmin = false;
        
        // Primeiro verificar se req.user já tem isAdmin (do token)
        if (req.user && req.user.isAdmin !== undefined) {
            isAdmin = req.user.isAdmin === 1 || req.user.isAdmin === true || req.user.isAdmin === '1';
        }
        
        try {
            // Buscar dados completos do usuário incluindo plano
            const user = await db.get('SELECT id, isAdmin, email, plan, subscription_plan FROM users WHERE id = ?', [req.user.id]);
            if (user) {
                // Obter plano do usuário
                userPlan = user.subscription_plan || user.plan || 'plan-free';
                
                // Verificação robusta de isAdmin (SQLite retorna como INTEGER)
                const adminValue = user.isAdmin;
                isAdmin = adminValue === 1 || 
                         adminValue === true || 
                         adminValue === '1' || 
                         String(adminValue) === '1' ||
                         Number(adminValue) === 1;
            }
        } catch (err) {
            console.error('[CRÉDITOS API] Erro ao buscar usuário:', err);
        }
        
        const storageUsed = await calculateUserStorage(req.user.id);
        const storageLimit = await getStorageLimit(userPlan, isAdmin, req.user.id);
        
        res.json({ 
            balance: credits.balance,
            storageUsed: storageUsed,
            storageLimit: storageLimit,
            plan: userPlan,
            isAdmin: isAdmin
        });
    } catch (error) {
        console.error('Erro ao consultar saldo:', error);
        res.status(500).json({ message: 'Erro ao consultar saldo' });
    }
});

// GET /api/user/preferences - Buscar preferências do usuário
app.get('/api/user/preferences', authenticateToken, async (req, res) => {
    try {
        let preferences = await db.get('SELECT * FROM user_preferences WHERE user_id = ?', [req.user.id]);
        if (!preferences) {
            // Criar preferências padrão
            await db.run('INSERT INTO user_preferences (user_id, use_credits_instead_of_own_api) VALUES (?, 0)', [req.user.id]);
            preferences = { use_credits_instead_of_own_api: 0 };
        }
        res.json({ 
            use_credits_instead_of_own_api: preferences.use_credits_instead_of_own_api === 1 
        });
    } catch (error) {
        console.error('Erro ao buscar preferências:', error);
        res.status(500).json({ message: 'Erro ao buscar preferências' });
    }
});

// POST /api/user/preferences - Salvar preferências do usuário
app.post('/api/user/preferences', authenticateToken, async (req, res) => {
    try {
        const { use_credits_instead_of_own_api } = req.body;
        
        // Verificar se já existe
        const existing = await db.get('SELECT id FROM user_preferences WHERE user_id = ?', [req.user.id]);
        
        if (existing) {
            await db.run(
                'UPDATE user_preferences SET use_credits_instead_of_own_api = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?',
                [use_credits_instead_of_own_api ? 1 : 0, req.user.id]
            );
        } else {
            await db.run(
                'INSERT INTO user_preferences (user_id, use_credits_instead_of_own_api) VALUES (?, ?)',
                [req.user.id, use_credits_instead_of_own_api ? 1 : 0]
            );
        }
        
        res.json({ 
            message: 'Preferências salvas com sucesso',
            use_credits_instead_of_own_api: use_credits_instead_of_own_api 
        });
    } catch (error) {
        console.error('Erro ao salvar preferências:', error);
        res.status(500).json({ message: 'Erro ao salvar preferências' });
    }
});

// POST /api/storage/recalculate - Forçar recálculo do armazenamento
app.post('/api/storage/recalculate', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        
        // Forçar recálculo completo
        await calculateUserStorage(userId, true);
        
        // Obter o resultado atualizado
        const result = await db.get(
            'SELECT COALESCE(SUM(file_size), 0) as total_size FROM user_storage WHERE user_id = ?', 
            [userId]
        );
        
        const totalSize = result?.total_size || 0;
        
        res.json({ 
            success: true, 
            message: 'Armazenamento recalculado com sucesso',
            storageUsed: totalSize,
            storageUsedMB: (totalSize / (1024 * 1024)).toFixed(2)
        });
    } catch (error) {
        console.error('[STORAGE] Erro ao recalcular armazenamento:', error);
        res.status(500).json({ message: 'Erro ao recalcular armazenamento', error: error.message });
    }
});

// GET /api/credits/transactions - Usuário consulta suas transações com detalhes
app.get('/api/credits/transactions', authenticateToken, async (req, res) => {
    try {
        // Buscar transações com JOIN para obter detalhes de uso
        const transactions = await db.all(`
            SELECT 
                ct.id,
                ct.amount,
                ct.transaction_type,
                ct.description,
                ct.created_at,
                cu.operation_type,
                cu.details,
                cu.units_consumed,
                ap.name as api_name,
                ap.provider as api_provider,
                ap.model as api_model
            FROM credit_transactions ct
            LEFT JOIN credit_usage cu ON ct.user_id = cu.user_id 
                AND ABS(ct.amount) = cu.credits_used 
                AND DATE(ct.created_at) = DATE(cu.created_at)
                AND ct.transaction_type = 'debit'
            LEFT JOIN api_providers ap ON cu.api_provider_id = ap.id
            WHERE ct.user_id = ?
            ORDER BY ct.created_at DESC
            LIMIT 100
        `, [req.user.id]);
        
        // Processar transações para adicionar informações detalhadas
        const processedTransactions = transactions.map(t => {
            let details = null;
            let operationInfo = null;
            
            if (t.details) {
                try {
                    details = typeof t.details === 'string' ? JSON.parse(t.details) : t.details;
                } catch (e) {
                    details = { raw: t.details };
                }
            }
            
            // Montar informação detalhada sobre a operação
            if (t.operation_type) {
                const operationTypes = {
                    // Roteiros
                    'api_script_agents_generate': 'Gerador de Roteiro',
                    '/api/generate': 'Gerador de Roteiro',
                    '/api/scripts': 'Gerador de Roteiro',
                    '/api/scripts/generate': 'Gerador de Roteiro',
                    '/api/script-agents/:agentId/generate': 'Gerador de Roteiro',
                    '/api/script-agents/:agentId/generate/laozhang': 'Gerador de Roteiro',
                    // Vídeos
                    'api_video_generation': 'Gerador de Vídeo',
                    // Voz
                    'api_tts_generation': 'Geração de Voz',
                    'api_tts_preview': 'Preview de Voz',
                    // Imagens
                    'api_image_generation': 'Geração de Imagem',
                    // Thumbnails
                    'api_analyze_thumbnail': 'Gerador de Thumbnail',
                    '/api/analyze/thumbnail': 'Gerador de Thumbnail',
                    '/api/analyze/thumbnail/laozhang': 'Gerador de Thumbnail',
                    // Cenas
                    '/api/generate/scene-prompts': 'Gerador de Cenas',
                    '/api/generate/scene-prompts/laozhang': 'Gerador de Cenas',
                    // Análise de Títulos
                    '/api/analyze/titles': 'Análise de Títulos',
                    '/api/analyze/titles/laozhang': 'Análise de Títulos',
                    // Detecção de Personagens
                    'api_detect_characters': 'Detecção de Personagens',
                    '/api/detect/characters': 'Detecção de Personagens',
                    '/api/detect/characters/laozhang': 'Detecção de Personagens',
                    // Busca de Subnicho
                    'api_niche_find_subniche': 'Busca de Subnicho',
                    '/api/niche/find-subniche': 'Busca de Subnicho',
                    '/api/niche/find-subniche/laozhang': 'Busca de Subnicho',
                    // Análise de Competidor
                    'api_niche_analyze_competitor': 'Análise de Competidor',
                    '/api/niche/analyze-competitor': 'Análise de Competidor',
                    '/api/niche/analyze-competitor/laozhang': 'Análise de Competidor',
                    // Criação de Agente
                    '/api/script-agents/create': 'Criação de Agente',
                    '/api/script-agents/create/laozhang': 'Criação de Agente',
                    // Reescrever Prompt
                    'api_rewrite_prompt': 'Reescrever Prompt',
                    '/api/rewrite/blocked-prompt': 'Reescrever Prompt',
                    '/api/rewrite/blocked-prompt/laozhang': 'Reescrever Prompt',
                    // Análise de Transcrição
                    'api_transcript_analyze': 'Análise de Transcrição',
                    '/api/video/transcript/analyze': 'Análise de Transcrição',
                    '/api/video/transcript/analyze/laozhang': 'Análise de Transcrição',
                    // Genéricos
                    'api_generation': 'Geração de Conteúdo',
                    'api_call': 'Ferramenta'
                };
                
                // Tentar extrair nome da ferramenta da descrição se ela contiver "Ferramenta - Laozhang.ai"
                let toolName = operationTypes[t.operation_type];
                
                // Se não encontrou pelo operationType, tentar pelo endpoint nos details
                if (!toolName && details?.endpoint) {
                    for (const [key, value] of Object.entries(operationTypes)) {
                        if (details.endpoint.includes(key) || key.includes(details.endpoint)) {
                            toolName = value;
                            break;
                        }
                    }
                }
                
                // Se ainda não encontrou, usar fallback
                if (!toolName) {
                    toolName = operationTypes[t.operation_type] || t.operation_type;
                }
                
                // Priorizar modelo dos details (modelo real usado), depois api_model (modelo do provider), depois descrição
                let modelName = details?.model || t.api_model || 'N/A';
                
                // Se a descrição contém "Ferramenta - Laozhang.ai", tentar extrair informações
                if ((!modelName || modelName === 'N/A') && t.description && t.description.includes('Ferramenta - Laozhang.ai')) {
                    // Tentar extrair o modelo da descrição
                    const modelMatch = t.description.match(/\(([^)]+)\)/);
                    if (modelMatch && modelMatch[1]) {
                        modelName = modelMatch[1];
                    }
                }
                
                // Se ainda não tem modelo, tentar extrair da descrição atual
                if ((!modelName || modelName === 'N/A') && t.description && t.description.includes(' - ')) {
                    const parts = t.description.split(' - ');
                    if (parts.length > 1) {
                        const possibleModel = parts[parts.length - 1];
                        // Verificar se parece um modelo (não é apenas o nome da ferramenta)
                        if (possibleModel && !possibleModel.includes('Gerador') && !possibleModel.includes('Ferramenta')) {
                            modelName = possibleModel;
                        }
                    }
                }
                
                // Formatar modelo se necessário
                if (modelName && modelName !== 'N/A') {
                    if (modelName.includes('claude-3-7-sonnet') || modelName === 'claude-3-7-sonnet-20250219') {
                        modelName = 'Claude 3.7 Sonnet';
                    } else if (modelName.includes('gemini-2.5-pro') || modelName === 'gemini-2.5-pro') {
                        modelName = 'Gemini 2.5 Pro';
                    } else if (modelName === 'gpt-4o' || modelName.includes('gpt-4o')) {
                        modelName = 'GPT-4o';
                    } else if (modelName.includes('veo-3.1-landscape-fast-fl') || modelName === 'veo-3.1-landscape-fast-fl') {
                        modelName = 'Veo 3.1 Landscape Fast';
                    } else if (modelName.includes('veo-3.1-landscape-fast') || modelName === 'veo-3.1-landscape-fast') {
                        modelName = 'Veo 3.1 Landscape Fast';
                    } else if (modelName.includes('veo-3.1-landscape-fl') || modelName === 'veo-3.1-landscape-fl') {
                        modelName = 'Veo 3.1 Landscape';
                    } else if (modelName.includes('veo-3.1-landscape') || modelName === 'veo-3.1-landscape') {
                        modelName = 'Veo 3.1 Landscape';
                    } else if (modelName.includes('veo-3.1-fast-fl') || modelName === 'veo-3.1-fast-fl') {
                        modelName = 'Veo 3.1 Fast';
                    } else if (modelName.includes('veo-3.1-fast') || modelName === 'veo-3.1-fast-generate-preview' || modelName === 'veo-3.1-fast') {
                        modelName = 'Veo 3.1 Fast';
                    } else if (modelName.includes('veo-3.1-fl') || modelName === 'veo-3.1-fl') {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('veo-3.1-generate') || modelName === 'veo-3.1-generate-preview' || modelName === 'veo-3.1') {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('veo-3.1')) {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('voz-premium') || modelName.includes('genaipro')) {
                        modelName = 'Voz Premium';
                    }
                    
                    // Limpeza final: remover qualquer referência a fornecedores
                    modelName = modelName
                        .replace(/genaipro/gi, 'Voz Premium')
                        .replace(/laozhang/gi, 'Provedor Externo')
                        .replace(/laozhang\.ai/gi, 'Provedor Externo')
                        .replace(/openai/gi, '')
                        .replace(/anthropic/gi, '')
                        .replace(/google/gi, '')
                        .replace(/\s+/g, ' ')
                        .trim();
                }
                
                operationInfo = {
                    type: t.operation_type,
                    typeName: toolName,
                    model: modelName !== 'N/A' ? modelName : null,
                    units: t.units_consumed || null,
                    endpoint: details?.endpoint || null,
                    details: details
                };
            }
            
            // Se a descrição contém "Ferramenta - Laozhang.ai", substituir pela descrição correta baseada no operationInfo
            let finalDescription = t.description;
            if (finalDescription && finalDescription.includes('Ferramenta - Laozhang.ai')) {
                if (operationInfo && operationInfo.typeName) {
                    finalDescription = operationInfo.typeName;
                    if (operationInfo.model) {
                        finalDescription += ` - ${operationInfo.model}`;
                    }
                }
            }
            
            // Limpeza final da descrição: remover referências a fornecedores
            finalDescription = finalDescription
                .replace(/genaipro/gi, 'Voz Premium')
                .replace(/laozhang/gi, 'Provedor Externo')
                .replace(/laozhang\.ai/gi, 'Provedor Externo')
                .replace(/openai/gi, '')
                .replace(/anthropic/gi, '')
                .replace(/google/gi, '')
                .replace(/\s+/g, ' ')
                .trim();
            
            finalDescription = sanitizeUserFacingText(
                finalDescription || (operationInfo?.typeName || 'Operação'),
                operationInfo?.typeName || 'Operação'
            );
            
            return {
                id: t.id,
                amount: t.amount,
                transaction_type: t.transaction_type,
                description: finalDescription,
                created_at: t.created_at,
                operation: operationInfo,
                isCredit: t.transaction_type === 'credit'
            };
        });
        
        res.json({ data: processedTransactions });
    } catch (error) {
        console.error('Erro ao listar transações:', error);
        res.status(500).json({ message: 'Erro ao listar transações' });
    }
});

// === ROTAS ADMINISTRATIVAS DE CRÉDITOS ===

// GET /api/admin/credits/balance/:userId - Consulta saldo de um usuário específico
app.get('/api/admin/credits/balance/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId);
        if (!userId) {
            return res.status(400).json({ message: 'ID do usuário inválido' });
        }
        
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [userId]);
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [userId]);
            credits = { balance: 0 };
        }
        res.json({ balance: credits.balance });
    } catch (error) {
        console.error('Erro ao consultar saldo:', error);
        res.status(500).json({ message: 'Erro ao consultar saldo' });
    }
});

// POST /api/admin/credits/add - Adiciona créditos a um usuário
app.post('/api/admin/credits/add', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { user_id, amount, description } = req.body;
        if (!user_id || !amount || amount <= 0) {
            return res.status(400).json({ message: 'user_id e amount são obrigatórios e amount deve ser positivo' });
        }
        
        const user = await db.get('SELECT id FROM users WHERE id = ?', [user_id]);
        if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });
        
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [user_id]);
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [user_id]);
            credits = { balance: 0 };
        }
        
        const newBalance = credits.balance + parseFloat(amount);
        await db.run('UPDATE user_credits SET balance = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?', [newBalance, user_id]);
        await db.run(`
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description, admin_id)
            VALUES (?, ?, 'credit', ?, ?)
        `, [user_id, amount, description || 'Créditos adicionados pelo administrador', req.user.id]);
        
        res.json({ message: 'Créditos adicionados com sucesso', new_balance: newBalance });
    } catch (error) {
        console.error('Erro ao adicionar créditos:', error);
        res.status(500).json({ message: 'Erro ao adicionar créditos' });
    }
});

// ================================================
// ROTAS DE ADMINISTRAÇÃO - ARMAZENAMENTO
// ================================================

// GET /api/admin/storage/stats - Obter estatísticas de armazenamento do servidor
app.get('/api/admin/storage/stats', authenticateToken, isAdmin, async (req, res) => {
    try {
        const fs = require('fs');
        const path = require('path');
        const os = require('os');
        const { execSync } = require('child_process');
        
        // Calcular espaço total do disco (não RAM)
        let totalSpace = 0;
        try {
            // Tentar usar comando do sistema para obter espaço em disco
            if (process.platform === 'win32') {
                // Windows: usar wmic
                const output = execSync('wmic logicaldisk get size,freespace,caption', { encoding: 'utf-8' });
                const lines = output.split('\n').filter(line => line.trim() && !line.includes('Caption'));
                let total = 0;
                for (const line of lines) {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        const size = parseInt(parts[parts.length - 1]);
                        if (!isNaN(size)) {
                            total += size;
                        }
                    }
                }
                totalSpace = total;
            } else {
                // Linux/Unix: usar df
                const output = execSync('df -B1 /', { encoding: 'utf-8' });
                const lines = output.split('\n');
                if (lines.length > 1) {
                    const parts = lines[1].trim().split(/\s+/);
                    if (parts.length >= 2) {
                        totalSpace = parseInt(parts[1]); // Tamanho total em bytes
                    }
                }
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao obter espaço em disco, usando fallback:', err.message);
            // Fallback: tentar usar fs.statfs se disponível (Node.js 18+)
            try {
                const stats = fs.statfsSync ? fs.statfsSync('/') : null;
                if (stats && stats.blocks && stats.bsize) {
                    totalSpace = stats.blocks * stats.bsize;
                } else {
                    // Último fallback: usar espaço do diretório atual
                    const stats = fs.statSync(__dirname);
                    // Não temos como saber o tamanho total, então vamos usar um valor padrão ou calcular do diretório
                    totalSpace = 200 * 1024 * 1024 * 1024; // 200 GB como padrão se não conseguir detectar
                }
            } catch (fallbackErr) {
                console.warn('[STORAGE] Fallback também falhou, usando valor padrão');
                totalSpace = 200 * 1024 * 1024 * 1024; // 200 GB como padrão
            }
        }
        
        // Buscar todos os usuários
        const users = await db.all('SELECT id, email, name, isAdmin FROM users');
        
        // Calcular espaço usado por usuário (usando a tabela user_storage)
        const usersStorage = [];
        let totalUsersStorage = 0;
        
        for (const user of users) {
            const userStorage = await calculateUserStorage(user.id);
            totalUsersStorage += userStorage;
            
            // Obter limite do usuário
            let userPlan = 'plan-free';
            let isUserAdmin = false;
            try {
                const userData = await db.get('SELECT plan, subscription_plan, isAdmin FROM users WHERE id = ?', [user.id]);
                if (userData) {
                    userPlan = userData.subscription_plan || userData.plan || 'plan-free';
                    isUserAdmin = userData.isAdmin === 1 || userData.isAdmin === true || String(userData.isAdmin) === '1';
                }
            } catch (err) {
                // Ignorar
            }
            
            const storageLimit = await getStorageLimit(userPlan, isUserAdmin, user.id);
            
            usersStorage.push({
                userId: user.id,
                email: user.email,
                name: user.name,
                isAdmin: isUserAdmin,
                plan: userPlan,
                storageUsed: userStorage,
                storageLimit: storageLimit,
                percentage: storageLimit > 0 ? (userStorage / storageLimit * 100) : 0
            });
        }
        
        // Calcular espaço usado em temp_audio (arquivos não associados a usuários)
        const tempAudioDir = path.join(__dirname, 'temp_audio');
        let tempAudioSize = 0;
        if (fs.existsSync(tempAudioDir)) {
            const files = fs.readdirSync(tempAudioDir);
            for (const file of files) {
                try {
                    const filePath = path.join(tempAudioDir, file);
                    const stats = fs.statSync(filePath);
                    if (stats.isFile()) {
                        tempAudioSize += stats.size;
                    }
                } catch (err) {
                    // Ignorar erros
                }
            }
        }
        
        res.json({
            serverTotalSpace: totalSpace,
            tempAudioSize: tempAudioSize,
            totalUsersStorage: totalUsersStorage,
            users: usersStorage,
            totalUsers: usersStorage.length
        });
    } catch (error) {
        console.error('[ADMIN STORAGE] Erro ao obter estatísticas:', error);
        res.status(500).json({ message: 'Erro ao obter estatísticas de armazenamento' });
    }
});

// POST /api/admin/storage/sync - Sincronizar armazenamento de todos os usuários
app.post('/api/admin/storage/sync', authenticateToken, isAdmin, async (req, res) => {
    try {
        const fs = require('fs');
        const path = require('path');
        
        console.log('[STORAGE SYNC] Iniciando sincronização de armazenamento...');
        
        // Buscar todos os usuários
        const users = await db.all('SELECT id FROM users');
        let syncedCount = 0;
        let totalFiles = 0;
        
        for (const user of users) {
            const userId = user.id;
            
            // Verificar arquivos em temp_audio que pertencem a este usuário
            const tempAudioDir = path.join(__dirname, 'temp_audio');
            if (fs.existsSync(tempAudioDir)) {
                const files = fs.readdirSync(tempAudioDir);
                const userIdStr = String(userId);
                
                for (const file of files) {
                    // Verificar se o arquivo pertence a este usuário
                    if (file.includes(userIdStr) || file.startsWith(`${userIdStr}_`) || file.includes(`_${userIdStr}_`)) {
                        const filePath = path.join(tempAudioDir, file);
                        try {
                            const stats = fs.statSync(filePath);
                            if (stats.isFile()) {
                                const relativePath = path.relative(__dirname, filePath);
                                await registerUserStorage(userId, relativePath, stats.size, 'audio');
                                totalFiles++;
                            }
                        } catch (err) {
                            console.error(`[STORAGE SYNC] Erro ao processar arquivo ${file}:`, err);
                        }
                    }
                }
            }
            
            syncedCount++;
        }
        
        console.log(`[STORAGE SYNC] Sincronização concluída: ${syncedCount} usuários, ${totalFiles} arquivos registrados`);
        
        res.json({ 
            message: 'Sincronização concluída com sucesso',
            usersSynced: syncedCount,
            filesRegistered: totalFiles
        });
    } catch (error) {
        console.error('[STORAGE SYNC] Erro ao sincronizar armazenamento:', error);
        res.status(500).json({ message: 'Erro ao sincronizar armazenamento', error: error.message });
    }
});

// PUT /api/admin/storage/reset/:userId - Zerar armazenamento de um usuário
app.put('/api/admin/storage/reset/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId);
        const fs = require('fs');
        const path = require('path');
        
        // Deletar registros de armazenamento do usuário
        try {
            await db.run('DELETE FROM user_storage WHERE user_id = ?', [userId]);
            console.log(`[STORAGE] Registros de armazenamento deletados para usuário ${userId}`);
        } catch (err) {
            console.error('[STORAGE] Erro ao deletar registros de armazenamento:', err);
        }
        
        // Deletar arquivos em temp_audio do usuário (arquivos que contêm o userId ou são do usuário)
        const tempAudioDir = path.join(__dirname, 'temp_audio');
        let deletedFiles = 0;
        let freedSpace = 0;
        
        if (fs.existsSync(tempAudioDir)) {
            const files = fs.readdirSync(tempAudioDir);
            for (const file of files) {
                try {
                    // Verificar se o arquivo pertence ao usuário (pode conter userId no nome ou timestamp)
                    // Por segurança, vamos listar todos e verificar propriedades
                    const filePath = path.join(tempAudioDir, file);
                    const stats = fs.statSync(filePath);
                    
                    // Deletar arquivo (por enquanto deletamos todos os arquivos temporários)
                    // Em produção, você pode querer associar arquivos a usuários em uma tabela
                    fs.unlinkSync(filePath);
                    deletedFiles++;
                    freedSpace += stats.size;
                } catch (err) {
                    console.error(`[ADMIN STORAGE] Erro ao deletar arquivo ${file}:`, err);
                }
            }
        }
        
        // Deletar arquivos associados ao usuário em user_files (se a tabela existir)
        try {
            const userFiles = await db.all('SELECT file_path FROM user_files WHERE user_id = ?', [userId]);
            for (const file of userFiles) {
                try {
                    if (file.file_path) {
                        const filePath = path.join(__dirname, file.file_path);
                        if (fs.existsSync(filePath)) {
                            const stats = fs.statSync(filePath);
                            fs.unlinkSync(filePath);
                            freedSpace += stats.size;
                        }
                    }
                } catch (err) {
                    // Ignorar erros
                }
            }
            await db.run('DELETE FROM user_files WHERE user_id = ?', [userId]);
        } catch (err) {
            // Tabela pode não existir, ignorar
        }
        
        res.json({
            success: true,
            message: `Armazenamento zerado para o usuário ${userId}`,
            deletedFiles: deletedFiles,
            freedSpace: freedSpace
        });
    } catch (error) {
        console.error('[ADMIN STORAGE] Erro ao zerar armazenamento:', error);
        res.status(500).json({ message: 'Erro ao zerar armazenamento' });
    }
});

// PUT /api/admin/storage/limit/:userId - Alterar limite de armazenamento de um usuário
app.put('/api/admin/storage/limit/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId);
        const { storageLimit } = req.body;
        
        if (!storageLimit || storageLimit < 0) {
            return res.status(400).json({ message: 'Limite de armazenamento inválido' });
        }
        
        // Converter para bytes se necessário
        let limitInBytes = storageLimit;
        if (typeof storageLimit === 'string') {
            // Se vier como "100GB", "500MB", etc
            const match = storageLimit.match(/^(\d+(?:\.\d+)?)\s*(GB|MB|KB|B)$/i);
            if (match) {
                const value = parseFloat(match[1]);
                const unit = match[2].toUpperCase();
                if (unit === 'GB') limitInBytes = value * 1024 * 1024 * 1024;
                else if (unit === 'MB') limitInBytes = value * 1024 * 1024;
                else if (unit === 'KB') limitInBytes = value * 1024;
                else limitInBytes = value;
            } else {
                limitInBytes = parseInt(storageLimit);
            }
        }
        
        // Criar ou atualizar limite customizado na tabela user_storage_limits (se não existir, criar)
        try {
            await db.run(`
                CREATE TABLE IF NOT EXISTS user_storage_limits (
                    user_id INTEGER PRIMARY KEY,
                    custom_limit INTEGER NOT NULL,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                )
            `);
            
            await db.run(`
                INSERT OR REPLACE INTO user_storage_limits (user_id, custom_limit, updated_at)
                VALUES (?, ?, CURRENT_TIMESTAMP)
            `, [userId, limitInBytes]);
        } catch (err) {
            console.error('[ADMIN STORAGE] Erro ao salvar limite customizado:', err);
            return res.status(500).json({ message: 'Erro ao salvar limite de armazenamento' });
        }
        
        res.json({
            success: true,
            message: `Limite de armazenamento atualizado para ${(limitInBytes / (1024 * 1024 * 1024)).toFixed(2)} GB`,
            storageLimit: limitInBytes
        });
    } catch (error) {
        console.error('[ADMIN STORAGE] Erro ao alterar limite:', error);
        res.status(500).json({ message: 'Erro ao alterar limite de armazenamento' });
    }
});

// GET /api/admin/storage/limit/:userId - Obter limite customizado de um usuário
app.get('/api/admin/storage/limit/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId);
        
        try {
            const customLimit = await db.get('SELECT custom_limit FROM user_storage_limits WHERE user_id = ?', [userId]);
            if (customLimit) {
                return res.json({ hasCustomLimit: true, storageLimit: customLimit.custom_limit });
            }
        } catch (err) {
            // Tabela pode não existir ainda
        }
        
        res.json({ hasCustomLimit: false });
    } catch (error) {
        console.error('[ADMIN STORAGE] Erro ao obter limite:', error);
        res.status(500).json({ message: 'Erro ao obter limite de armazenamento' });
    }
});

// PUT /api/admin/credits/reset - Zerar créditos de um usuário
app.put('/api/admin/credits/reset', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { user_id } = req.body;
        if (!user_id) {
            return res.status(400).json({ message: 'user_id é obrigatório' });
        }
        
        const user = await db.get('SELECT id, email FROM users WHERE id = ?', [user_id]);
        if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });
        
        // Obter saldo atual antes de zerar
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [user_id]);
        const oldBalance = credits ? credits.balance : 0;
        
        // Zerar saldo
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [user_id]);
        } else {
            await db.run('UPDATE user_credits SET balance = 0, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?', [user_id]);
        }
        
        // Registrar transação
        if (oldBalance > 0) {
            await db.run(`
                INSERT INTO credit_transactions (user_id, amount, transaction_type, description, admin_id)
                VALUES (?, ?, 'debit', ?, ?)
            `, [user_id, -oldBalance, `Créditos zerados pelo administrador (saldo anterior: ${oldBalance.toFixed(2)})`, req.user.id]);
        }
        
        res.json({ message: 'Créditos zerados com sucesso', old_balance: oldBalance, new_balance: 0 });
    } catch (error) {
        console.error('Erro ao zerar créditos:', error);
        res.status(500).json({ message: 'Erro ao zerar créditos' });
    }
});

// ================================================
// ROTAS ADMINISTRATIVAS DE APIs
// ================================================

// GET /api/admin/api-providers - Listar todas as APIs
app.get('/api/admin/api-providers', authenticateToken, isAdmin, async (req, res) => {
    try {
        const apis = await db.all('SELECT * FROM api_providers ORDER BY created_at DESC');
        // Descriptografar chaves de API para exibição (apenas para admin)
        const apisWithDecryptedKeys = apis.map(api => {
            if (api.api_key) {
                try {
                    const decrypted = decrypt(api.api_key);
                    if (decrypted) {
                        return { ...api, api_key: decrypted };
                    }
                } catch (err) {
                    // Se falhar ao descriptografar, pode não estar criptografada
                    return api;
                }
            }
            return api;
        });
        res.json(apisWithDecryptedKeys);
    } catch (error) {
        console.error('Erro ao listar APIs:', error);
        res.status(500).json({ message: 'Erro ao listar APIs' });
    }
});

// POST /api/admin/api-providers - Criar nova API
app.post('/api/admin/api-providers', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { name, provider, model, api_key, unit_type, unit_size, real_cost_per_unit, credits_per_unit, markup, is_premium, is_active, is_default } = req.body;
        
        if (!name || !provider || !model || !api_key) {
            return res.status(400).json({ message: 'Nome, provedor, modelo e chave de API são obrigatórios' });
        }
        
        // Se marcar como padrão, desmarcar outras
        if (is_default) {
            await db.run('UPDATE api_providers SET is_default = 0');
        }
        
        const result = await db.run(`
            INSERT INTO api_providers (
                name, provider, model, api_key, unit_type, unit_size,
                real_cost_per_unit, credits_per_unit, markup, is_premium,
                is_active, is_default
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
            name, provider, model, api_key, unit_type || 'tokens', unit_size || 1000,
            real_cost_per_unit || 0.0, credits_per_unit || 1.0, markup || 1.0,
            is_premium || 0, is_active !== undefined ? is_active : 1, is_default || 0
        ]);
        
        res.json({ message: 'API criada com sucesso', id: result.lastID });
    } catch (error) {
        console.error('Erro ao criar API:', error);
        res.status(500).json({ message: 'Erro ao criar API' });
    }
});

// PUT /api/admin/api-providers/:id - Editar API
app.put('/api/admin/api-providers/:id', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { id } = req.params;
        const { name, provider, model, api_key, unit_type, unit_size, real_cost_per_unit, credits_per_unit, markup, is_premium, is_active, is_default } = req.body;
        
        // Se marcar como padrão, desmarcar outras
        if (is_default) {
            await db.run('UPDATE api_providers SET is_default = 0 WHERE id != ?', [id]);
        }
        
        await db.run(`
            UPDATE api_providers SET
                name = ?, provider = ?, model = ?, api_key = ?,
                unit_type = ?, unit_size = ?, real_cost_per_unit = ?,
                credits_per_unit = ?, markup = ?, is_premium = ?,
                is_active = ?, is_default = ?, updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        `, [
            name, provider, model, api_key, unit_type, unit_size,
            real_cost_per_unit, credits_per_unit, markup, is_premium,
            is_active, is_default, id
        ]);
        
        res.json({ message: 'API atualizada com sucesso' });
    } catch (error) {
        console.error('Erro ao atualizar API:', error);
        res.status(500).json({ message: 'Erro ao atualizar API' });
    }
});

// DELETE /api/admin/api-providers/:id - Deletar API
app.delete('/api/admin/api-providers/:id', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { id } = req.params;
        await db.run('DELETE FROM api_providers WHERE id = ?', [id]);
        res.json({ message: 'API excluída com sucesso' });
    } catch (error) {
        console.error('Erro ao excluir API:', error);
        res.status(500).json({ message: 'Erro ao excluir API' });
    }
});

// GET /api/admin/credits/statistics - Estatísticas de créditos (completo)
app.get('/api/admin/credits/statistics', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { startDate, endDate, userId, tool } = req.query;
        
        let dateFilter = '';
        let params = [];
        
        if (startDate && endDate) {
            dateFilter = 'AND DATE(cu.created_at) BETWEEN DATE(?) AND DATE(?)';
            params.push(startDate, endDate);
        } else if (startDate) {
            dateFilter = 'AND DATE(cu.created_at) >= DATE(?)';
            params.push(startDate);
        } else if (endDate) {
            dateFilter = 'AND DATE(cu.created_at) <= DATE(?)';
            params.push(endDate);
        } else {
            // Padrão: últimos 30 dias
            dateFilter = 'AND DATE(cu.created_at) >= DATE("now", "-30 days")';
        }
        
        if (userId) {
            dateFilter += ' AND cu.user_id = ?';
            params.push(userId);
        }
        
        // Estatísticas gerais
        const totalStats = await db.get(`
            SELECT 
                COUNT(*) as total_operations,
                SUM(cu.credits_used) as total_credits,
                AVG(cu.credits_used) as avg_credits_per_operation,
                MIN(cu.credits_used) as min_credits,
                MAX(cu.credits_used) as max_credits,
                COUNT(DISTINCT cu.user_id) as unique_users,
                COUNT(DISTINCT DATE(cu.created_at)) as days_with_usage
            FROM credit_usage cu
            WHERE 1=1 ${dateFilter}
        `, params);
        
        // Estatísticas por dia
        const dailyStats = await db.all(`
            SELECT 
                DATE(cu.created_at) as date,
                COUNT(*) as operations,
                SUM(cu.credits_used) as total_credits,
                COUNT(DISTINCT cu.user_id) as unique_users
            FROM credit_usage cu
            WHERE 1=1 ${dateFilter}
            GROUP BY DATE(cu.created_at)
            ORDER BY date DESC
            LIMIT 90
        `, params);
        
        // Estatísticas por ferramenta
        let toolFilter = '';
        let toolParams = [...params];
        if (tool) {
            toolFilter = 'AND ct.description = ?';
            toolParams.push(tool);
        }
        
        let ctDateFilter = '';
        if (startDate && endDate) {
            ctDateFilter = 'AND DATE(ct.created_at) BETWEEN DATE(?) AND DATE(?)';
        } else if (startDate) {
            ctDateFilter = 'AND DATE(ct.created_at) >= DATE(?)';
        } else if (endDate) {
            ctDateFilter = 'AND DATE(ct.created_at) <= DATE(?)';
        } else {
            ctDateFilter = 'AND DATE(ct.created_at) >= DATE("now", "-30 days")';
        }
        
        const toolStats = await db.all(`
            SELECT 
                ct.description as tool_name,
                COUNT(*) as operations,
                SUM(ABS(ct.amount)) as total_credits,
                AVG(ABS(ct.amount)) as avg_credits,
                COUNT(DISTINCT ct.user_id) as unique_users
            FROM credit_transactions ct
            WHERE ct.transaction_type = 'debit' ${ctDateFilter} ${toolFilter}
            GROUP BY ct.description
            ORDER BY total_credits DESC
        `, toolParams);
        
        // Estatísticas por usuário (top 20)
        const userStats = await db.all(`
            SELECT 
                u.id,
                u.email,
                u.whatsapp,
                COUNT(cu.id) as operations,
                SUM(cu.credits_used) as total_credits,
                AVG(cu.credits_used) as avg_credits
            FROM credit_usage cu
            JOIN users u ON cu.user_id = u.id
            WHERE 1=1 ${dateFilter}
            GROUP BY u.id, u.email, u.whatsapp
            ORDER BY total_credits DESC
            LIMIT 20
        `, params);
        
        // Estatísticas por API Provider
        const apiStats = await db.all(`
            SELECT 
                ap.id,
                ap.name,
                ap.provider,
                ap.model,
                COUNT(cu.id) as operations,
                SUM(cu.credits_used) as total_credits,
                SUM(cu.units_consumed) as total_units
            FROM credit_usage cu
            JOIN api_providers ap ON cu.api_provider_id = ap.id
            WHERE 1=1 ${dateFilter}
            GROUP BY ap.id, ap.name, ap.provider, ap.model
            ORDER BY total_credits DESC
        `, params);
        
        // Total distribuído (créditos adicionados)
        const totalDistributed = await db.get(`
            SELECT SUM(amount) as total FROM credit_transactions WHERE transaction_type = 'credit'
        `);
        
        // Usuários com créditos
        const usersWithCredits = await db.get(`
            SELECT COUNT(*) as count FROM user_credits WHERE balance > 0
        `);
        
        res.json({
            summary: totalStats,
            daily: dailyStats,
            byTool: toolStats,
            byUser: userStats,
            byApi: apiStats,
            totalDistributed: totalDistributed?.total || 0,
            usersWithCredits: usersWithCredits?.count || 0,
            creditsUsed30Days: totalStats?.total_credits || 0
        });
    } catch (error) {
        console.error('Erro ao buscar estatísticas de créditos:', error);
        res.status(500).json({ message: 'Erro ao buscar estatísticas', details: error.message });
    }
});

// GET /api/admin/credits/export - Exportar dados de créditos (CSV)
app.get('/api/admin/credits/export', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { startDate, endDate, format = 'csv' } = req.query;
        
        let dateFilter = '';
        let params = [];
        
        if (startDate && endDate) {
            dateFilter = 'WHERE DATE(cu.created_at) BETWEEN DATE(?) AND DATE(?)';
            params.push(startDate, endDate);
        } else if (startDate) {
            dateFilter = 'WHERE DATE(cu.created_at) >= DATE(?)';
            params.push(startDate);
        } else if (endDate) {
            dateFilter = 'WHERE DATE(cu.created_at) <= DATE(?)';
            params.push(endDate);
        }
        
        const data = await db.all(`
            SELECT 
                cu.created_at as data,
                u.email,
                u.whatsapp,
                ap.name as api_name,
                ap.provider,
                ap.model,
                cu.operation_type as tipo_operacao,
                cu.credits_used as creditos_usados,
                cu.units_consumed as unidades_consumidas
            FROM credit_usage cu
            JOIN users u ON cu.user_id = u.id
            JOIN api_providers ap ON cu.api_provider_id = ap.id
            ${dateFilter}
            ORDER BY cu.created_at DESC
        `, params);
        
        if (format === 'json') {
            res.json({ data });
        } else {
            // CSV
            const headers = ['Data', 'Email', 'WhatsApp', 'API', 'Provider', 'Modelo', 'Tipo Operação', 'Créditos Usados', 'Unidades Consumidas'];
            const csvRows = [
                headers.join(','),
                ...data.map(row => [
                    row.data || '',
                    `"${(row.email || '').replace(/"/g, '""')}"`,
                    `"${(row.whatsapp || '').replace(/"/g, '""')}"`,
                    `"${(row.api_name || '').replace(/"/g, '""')}"`,
                    `"${(row.provider || '').replace(/"/g, '""')}"`,
                    `"${(row.model || '').replace(/"/g, '""')}"`,
                    `"${(row.tipo_operacao || '').replace(/"/g, '""')}"`,
                    row.creditos_usados || 0,
                    row.unidades_consumidas || 0
                ].join(','))
            ];
            
            res.setHeader('Content-Type', 'text/csv; charset=utf-8');
            res.setHeader('Content-Disposition', `attachment; filename="creditos_${Date.now()}.csv"`);
            res.send('\ufeff' + csvRows.join('\n')); // BOM para Excel
        }
    } catch (error) {
        console.error('Erro ao exportar créditos:', error);
        res.status(500).json({ message: 'Erro ao exportar créditos' });
    }
});

// GET /api/admin/credits/transactions/:userId - Histórico de transações de um usuário com detalhes
app.get('/api/admin/credits/transactions/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { userId } = req.params;
        
        // Buscar transações com JOIN para obter detalhes de uso
        const transactions = await db.all(`
            SELECT 
                ct.id,
                ct.amount,
                ct.transaction_type,
                ct.description,
                ct.created_at,
                cu.operation_type,
                cu.details,
                cu.units_consumed,
                ap.name as api_name,
                ap.provider as api_provider,
                ap.model as api_model
            FROM credit_transactions ct
            LEFT JOIN credit_usage cu ON ct.user_id = cu.user_id 
                AND ABS(ct.amount) = cu.credits_used 
                AND DATE(ct.created_at) = DATE(cu.created_at)
                AND ct.transaction_type = 'debit'
            LEFT JOIN api_providers ap ON cu.api_provider_id = ap.id
            WHERE ct.user_id = ?
            ORDER BY ct.created_at DESC
            LIMIT 100
        `, [userId]);
        
        // Processar transações para adicionar informações detalhadas
        const processedTransactions = transactions.map(t => {
            let details = null;
            let operationInfo = null;
            
            if (t.details) {
                try {
                    details = typeof t.details === 'string' ? JSON.parse(t.details) : t.details;
                } catch (e) {
                    details = { raw: t.details };
                }
            }
            
            // Montar informação detalhada sobre a operação
            if (t.operation_type) {
                const operationTypes = {
                    // Roteiros
                    'api_script_agents_generate': 'Gerador de Roteiro',
                    '/api/generate': 'Gerador de Roteiro',
                    '/api/scripts': 'Gerador de Roteiro',
                    '/api/scripts/generate': 'Gerador de Roteiro',
                    '/api/script-agents/:agentId/generate': 'Gerador de Roteiro',
                    '/api/script-agents/:agentId/generate/laozhang': 'Gerador de Roteiro',
                    // Vídeos
                    'api_video_generation': 'Gerador de Vídeo',
                    // Voz
                    'api_tts_generation': 'Geração de Voz',
                    'api_tts_preview': 'Preview de Voz',
                    // Imagens
                    'api_image_generation': 'Geração de Imagem',
                    // Thumbnails
                    'api_analyze_thumbnail': 'Gerador de Thumbnail',
                    '/api/analyze/thumbnail': 'Gerador de Thumbnail',
                    '/api/analyze/thumbnail/laozhang': 'Gerador de Thumbnail',
                    // Cenas
                    '/api/generate/scene-prompts': 'Gerador de Cenas',
                    '/api/generate/scene-prompts/laozhang': 'Gerador de Cenas',
                    // Análise de Títulos
                    '/api/analyze/titles': 'Análise de Títulos',
                    '/api/analyze/titles/laozhang': 'Análise de Títulos',
                    // Detecção de Personagens
                    'api_detect_characters': 'Detecção de Personagens',
                    '/api/detect/characters': 'Detecção de Personagens',
                    '/api/detect/characters/laozhang': 'Detecção de Personagens',
                    // Busca de Subnicho
                    'api_niche_find_subniche': 'Busca de Subnicho',
                    '/api/niche/find-subniche': 'Busca de Subnicho',
                    '/api/niche/find-subniche/laozhang': 'Busca de Subnicho',
                    // Análise de Competidor
                    'api_niche_analyze_competitor': 'Análise de Competidor',
                    '/api/niche/analyze-competitor': 'Análise de Competidor',
                    '/api/niche/analyze-competitor/laozhang': 'Análise de Competidor',
                    // Criação de Agente
                    '/api/script-agents/create': 'Criação de Agente',
                    '/api/script-agents/create/laozhang': 'Criação de Agente',
                    // Reescrever Prompt
                    'api_rewrite_prompt': 'Reescrever Prompt',
                    '/api/rewrite/blocked-prompt': 'Reescrever Prompt',
                    '/api/rewrite/blocked-prompt/laozhang': 'Reescrever Prompt',
                    // Análise de Transcrição
                    'api_transcript_analyze': 'Análise de Transcrição',
                    '/api/video/transcript/analyze': 'Análise de Transcrição',
                    '/api/video/transcript/analyze/laozhang': 'Análise de Transcrição',
                    // Genéricos
                    'api_generation': 'Geração de Conteúdo',
                    'api_call': 'Ferramenta'
                };
                
                // Tentar extrair nome da ferramenta da descrição se ela contiver "Ferramenta - Laozhang.ai"
                let toolName = operationTypes[t.operation_type];
                
                // Se não encontrou pelo operationType, tentar pelo endpoint nos details
                if (!toolName && details?.endpoint) {
                    for (const [key, value] of Object.entries(operationTypes)) {
                        if (details.endpoint.includes(key) || key.includes(details.endpoint)) {
                            toolName = value;
                            break;
                        }
                    }
                }
                
                // Se ainda não encontrou, usar fallback
                if (!toolName) {
                    toolName = operationTypes[t.operation_type] || t.operation_type;
                }
                
                // Priorizar modelo dos details (modelo real usado), depois api_model (modelo do provider), depois descrição
                let modelName = details?.model || t.api_model || 'N/A';
                
                // Se a descrição contém "Ferramenta - Laozhang.ai", tentar extrair informações
                if ((!modelName || modelName === 'N/A') && t.description && t.description.includes('Ferramenta - Laozhang.ai')) {
                    // Tentar extrair o modelo da descrição
                    const modelMatch = t.description.match(/\(([^)]+)\)/);
                    if (modelMatch && modelMatch[1]) {
                        modelName = modelMatch[1];
                    }
                }
                
                // Se ainda não tem modelo, tentar extrair da descrição atual
                if ((!modelName || modelName === 'N/A') && t.description && t.description.includes(' - ')) {
                    const parts = t.description.split(' - ');
                    if (parts.length > 1) {
                        const possibleModel = parts[parts.length - 1];
                        // Verificar se parece um modelo (não é apenas o nome da ferramenta)
                        if (possibleModel && !possibleModel.includes('Gerador') && !possibleModel.includes('Ferramenta')) {
                            modelName = possibleModel;
                        }
                    }
                }
                
                // Formatar modelo se necessário
                if (modelName && modelName !== 'N/A') {
                    if (modelName.includes('claude-3-7-sonnet') || modelName === 'claude-3-7-sonnet-20250219') {
                        modelName = 'Claude 3.7 Sonnet';
                    } else if (modelName.includes('gemini-2.5-pro') || modelName === 'gemini-2.5-pro') {
                        modelName = 'Gemini 2.5 Pro';
                    } else if (modelName === 'gpt-4o' || modelName.includes('gpt-4o')) {
                        modelName = 'GPT-4o';
                    } else if (modelName.includes('veo-3.1-landscape-fast-fl') || modelName === 'veo-3.1-landscape-fast-fl') {
                        modelName = 'Veo 3.1 Landscape Fast';
                    } else if (modelName.includes('veo-3.1-landscape-fast') || modelName === 'veo-3.1-landscape-fast') {
                        modelName = 'Veo 3.1 Landscape Fast';
                    } else if (modelName.includes('veo-3.1-landscape-fl') || modelName === 'veo-3.1-landscape-fl') {
                        modelName = 'Veo 3.1 Landscape';
                    } else if (modelName.includes('veo-3.1-landscape') || modelName === 'veo-3.1-landscape') {
                        modelName = 'Veo 3.1 Landscape';
                    } else if (modelName.includes('veo-3.1-fast-fl') || modelName === 'veo-3.1-fast-fl') {
                        modelName = 'Veo 3.1 Fast';
                    } else if (modelName.includes('veo-3.1-fast') || modelName === 'veo-3.1-fast-generate-preview' || modelName === 'veo-3.1-fast') {
                        modelName = 'Veo 3.1 Fast';
                    } else if (modelName.includes('veo-3.1-fl') || modelName === 'veo-3.1-fl') {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('veo-3.1-generate') || modelName === 'veo-3.1-generate-preview' || modelName === 'veo-3.1') {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('veo-3.1')) {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('voz-premium') || modelName.includes('genaipro')) {
                        modelName = 'Voz Premium';
                    }
                    
                    // Limpeza final: remover qualquer referência a fornecedores
                    modelName = modelName
                        .replace(/genaipro/gi, 'Voz Premium')
                        .replace(/laozhang/gi, 'Provedor Externo')
                        .replace(/laozhang\.ai/gi, 'Provedor Externo')
                        .replace(/openai/gi, '')
                        .replace(/anthropic/gi, '')
                        .replace(/google/gi, '')
                        .replace(/\s+/g, ' ')
                        .trim();
                }
                
                operationInfo = {
                    type: t.operation_type,
                    typeName: toolName,
                    model: modelName !== 'N/A' ? modelName : null,
                    units: t.units_consumed || null,
                    endpoint: details?.endpoint || null,
                    details: details
                };
            }
            
            // Se a descrição contém "Ferramenta - Laozhang.ai", substituir pela descrição correta baseada no operationInfo
            let finalDescription = t.description;
            if (finalDescription && finalDescription.includes('Ferramenta - Laozhang.ai')) {
                if (operationInfo && operationInfo.typeName) {
                    finalDescription = operationInfo.typeName;
                    if (operationInfo.model) {
                        finalDescription += ` - ${operationInfo.model}`;
                    }
                }
            }
            
            // Limpeza final da descrição: remover referências a fornecedores
            finalDescription = finalDescription
                .replace(/genaipro/gi, 'Voz Premium')
                .replace(/laozhang/gi, 'Provedor Externo')
                .replace(/laozhang\.ai/gi, 'Provedor Externo')
                .replace(/openai/gi, '')
                .replace(/anthropic/gi, '')
                .replace(/google/gi, '')
                .replace(/\s+/g, ' ')
                .trim();
            
            return {
                id: t.id,
                amount: t.amount,
                transaction_type: t.transaction_type,
                description: finalDescription,
                created_at: t.created_at,
                operation: operationInfo,
                isCredit: t.transaction_type === 'credit'
            };
        });
        
        res.json({ data: processedTransactions });
    } catch (error) {
        console.error('Erro ao buscar transações:', error);
        res.status(500).json({ message: 'Erro ao buscar transações' });
    }
});

// DELETE /api/admin/credits/transactions/:userId/clear - Zerar histórico de transações de um usuário
app.delete('/api/admin/credits/transactions/:userId/clear', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { userId } = req.params;
        const userIdInt = parseInt(userId);
        
        if (!userIdInt || isNaN(userIdInt)) {
            return res.status(400).json({ message: 'ID do usuário inválido' });
        }
        
        // Verificar se o usuário existe
        const user = await db.get('SELECT id, email FROM users WHERE id = ?', [userIdInt]);
        if (!user) {
            return res.status(404).json({ message: 'Usuário não encontrado' });
        }
        
        // Deletar todas as transações do usuário
        const deleteResult = await db.run(
            'DELETE FROM credit_transactions WHERE user_id = ?',
            [userIdInt]
        );
        
        // Deletar também os registros de uso de créditos relacionados
        await db.run(
            'DELETE FROM credit_usage WHERE user_id = ?',
            [userIdInt]
        );
        
        console.log(`[Admin] Histórico de transações zerado para usuário ${userIdInt} (${user.email}) por admin ${req.user.id}`);
        
        res.json({ 
            success: true, 
            message: 'Histórico de transações zerado com sucesso',
            deletedTransactions: deleteResult.changes || 0
        });
    } catch (error) {
        console.error('Erro ao zerar histórico de transações:', error);
        res.status(500).json({ message: 'Erro ao zerar histórico de transações' });
    }
});

// GET /api/admin/credits/users-with-balance - Lista usuários com saldo (com paginação e busca)
app.get('/api/admin/credits/users-with-balance', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { min_balance = 0, limit = 100, offset = 0, search = '' } = req.query;
        
        // Construir cláusula WHERE com busca opcional
        let whereClause = 'WHERE COALESCE(uc.balance, 0) >= ?';
        let queryParams = [parseFloat(min_balance)];
        
        if (search && search.trim()) {
            const searchTerm = `%${search.trim()}%`;
            whereClause += ` AND (
                LOWER(u.email) LIKE LOWER(?) 
                OR LOWER(COALESCE(u.whatsapp, '')) LIKE LOWER(?)
                OR LOWER(COALESCE(u.name, '')) LIKE LOWER(?)
            )`;
            queryParams.push(searchTerm, searchTerm, searchTerm);
        }
        
        const users = await db.all(`
            SELECT 
                u.id,
                u.email,
                u.whatsapp,
                u.name,
                COALESCE(uc.balance, 0) as balance,
                uc.updated_at as last_updated
            FROM users u
            LEFT JOIN user_credits uc ON u.id = uc.user_id
            ${whereClause}
            ORDER BY uc.balance DESC, u.email ASC
            LIMIT ? OFFSET ?
        `, [...queryParams, parseInt(limit), parseInt(offset)]);
        
        // Query para total com mesma busca
        let totalWhereClause = 'WHERE COALESCE(uc.balance, 0) >= ?';
        let totalParams = [parseFloat(min_balance)];
        if (search && search.trim()) {
            const searchTerm = `%${search.trim()}%`;
            totalWhereClause += ` AND (
                LOWER(u.email) LIKE LOWER(?) 
                OR LOWER(COALESCE(u.whatsapp, '')) LIKE LOWER(?)
                OR LOWER(COALESCE(u.name, '')) LIKE LOWER(?)
            )`;
            totalParams.push(searchTerm, searchTerm, searchTerm);
        }
        
        const total = await db.get(`
            SELECT COUNT(*) as count
            FROM users u
            LEFT JOIN user_credits uc ON u.id = uc.user_id
            ${totalWhereClause}
        `, totalParams);
        
        res.json({ 
            users: users.map(u => ({
                id: u.id,
                email: u.email,
                whatsapp: u.whatsapp || null,
                name: u.name || null,
                balance: parseFloat(u.balance || 0),
                last_updated: u.last_updated
            })),
            total: total.count,
            limit: parseInt(limit),
            offset: parseInt(offset)
        });
    } catch (error) {
        console.error('Erro ao buscar usuários com créditos:', error);
        res.status(500).json({ message: 'Erro ao buscar usuários' });
    }
});

// POST /api/admin/credits/balance - Consulta saldo por email, WhatsApp ou nome
app.post('/api/admin/credits/balance', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { identifier } = req.body;
        if (!identifier) return res.status(400).json({ message: 'Identificador é obrigatório' });
        
        // Buscar por email, whatsapp ou nome (busca parcial, case-insensitive)
        const searchTerm = `%${identifier}%`;
        const user = await db.get(`
            SELECT id, email, whatsapp, name 
            FROM users 
            WHERE LOWER(email) LIKE LOWER(?) 
               OR LOWER(COALESCE(whatsapp, '')) LIKE LOWER(?)
               OR LOWER(COALESCE(name, '')) LIKE LOWER(?)
            LIMIT 1
        `, [searchTerm, searchTerm, searchTerm]);
        
        if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });
        
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [user.id]);
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [user.id]);
            credits = { balance: 0 };
        }
        
        res.json({ user: { id: user.id, email: user.email, whatsapp: user.whatsapp, name: user.name }, balance: credits.balance });
    } catch (error) {
        console.error('Erro ao consultar saldo:', error);
        res.status(500).json({ message: 'Erro ao consultar saldo' });
    }
});

// GET /api/app-settings/laozhang-status - Verificar se laozhang.ai está ativa (público para usuários autenticados)
app.get('/api/app-settings/laozhang-status', authenticateToken, async (req, res) => {
    try {
        const laozhangDefaultSetting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
        let laozhangUseAsDefault = false;
        if (laozhangDefaultSetting) {
            try {
                const parsedValue = JSON.parse(laozhangDefaultSetting.value);
                laozhangUseAsDefault = parsedValue === true || parsedValue === 'true' || parsedValue === 1;
            } catch (e) {
                laozhangUseAsDefault = laozhangDefaultSetting.value === 'true' || laozhangDefaultSetting.value === '1';
            }
        }
        res.json({ laozhang_use_as_default: laozhangUseAsDefault });
    } catch (err) {
        console.error("Erro ao verificar status laozhang.ai:", err.message);
        res.json({ laozhang_use_as_default: false });
    }
});

// GET /api/admin/app-settings - Buscar configurações da aplicação
app.get('/api/admin/app-settings', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings");
        const settings = rows.reduce((acc, row) => {
            try {
                acc[row.key] = JSON.parse(row.value);
            } catch (e) {
                acc[row.key] = row.value; // fallback for non-json values
            }
            return acc;
        }, {});
        
        // Garantir que initial_bonus_credits existe (padrão: 0)
        if (settings.initial_bonus_credits === undefined) {
            settings.initial_bonus_credits = 0;
        }
        
        // Garantir que tts_credits_multiplier existe (padrão: 1.0)
        if (settings.tts_credits_multiplier === undefined) {
            settings.tts_credits_multiplier = 1.0;
        }
        
        // Garantir que laozhang_use_as_default existe (padrão: false)
        if (settings.laozhang_use_as_default === undefined) {
            settings.laozhang_use_as_default = false;
        }
        
        res.json(settings);
    } catch (err) {
        console.error("Erro ao buscar app settings:", err.message);
        res.status(500).json({ message: "Erro ao buscar configurações." });
    }
});

// POST /api/admin/app-settings - Salvar configurações da aplicação
app.post('/api/admin/app-settings', authenticateToken, isAdmin, async (req, res) => {
    const { settings } = req.body;
    try {
        for (const [key, value] of Object.entries(settings)) {
            // Para voice_api_key, salvar como string simples (não JSON)
            if (key === 'voice_api_key' && typeof value === 'string') {
                await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [key, value]);
            } else {
                await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [key, JSON.stringify(value)]);
            }
        }
        res.json({ message: 'Configurações da aplicação salvas.' });
    } catch (err) {
        console.error("Erro ao salvar app settings:", err.message);
        res.status(500).json({ message: "Erro ao salvar configurações." });
    }
});

// GET /api/admin/whatsapp-config - Obter configurações do WhatsApp
app.get('/api/admin/whatsapp-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key IN ('whatsapp_token', 'whatsapp_number_id')");
        const config = {};
        rows.forEach(row => {
            try {
                config[row.key] = JSON.parse(row.value);
            } catch (e) {
                config[row.key] = row.value;
            }
        });
        res.json(config);
    } catch (err) {
        console.error("Erro ao buscar configurações do WhatsApp:", err.message);
        res.status(500).json({ message: "Erro ao buscar configurações do WhatsApp." });
    }
});

// POST /api/admin/whatsapp-config - Salvar configurações do WhatsApp
app.post('/api/admin/whatsapp-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { token, number_id } = req.body;
        
        if (token !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['whatsapp_token', JSON.stringify(token)]);
        }
        
        if (number_id !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['whatsapp_number_id', JSON.stringify(number_id)]);
        }
        
        res.json({ message: 'Configurações do WhatsApp salvas com sucesso.' });
    } catch (err) {
        console.error("Erro ao salvar configurações do WhatsApp:", err.message);
        res.status(500).json({ message: "Erro ao salvar configurações do WhatsApp." });
    }
});

// GET /api/admin/email-templates - Obter templates de email
app.get('/api/admin/email-templates', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key LIKE 'email_template_%'");
        const templates = {};
        rows.forEach(row => {
            try {
                const templateType = row.key.replace('email_template_', '').replace('_subject', '').replace('_body', '');
                if (!templates[templateType]) templates[templateType] = {};
                if (row.key.includes('_subject')) {
                    templates[templateType].subject = JSON.parse(row.value);
                } else if (row.key.includes('_body')) {
                    templates[templateType].body = JSON.parse(row.value);
                }
            } catch (e) {
                // Ignorar erros de parse
            }
        });
        res.json(templates);
    } catch (err) {
        console.error("Erro ao buscar templates de email:", err.message);
        res.status(500).json({ message: "Erro ao buscar templates de email." });
    }
});

// POST /api/admin/email-templates - Salvar template de email
app.post('/api/admin/email-templates', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { template_type, subject, body } = req.body;
        
        if (!template_type || !subject || !body) {
            return res.status(400).json({ message: 'template_type, subject e body são obrigatórios' });
        }
        
        await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [`email_template_${template_type}_subject`, JSON.stringify(subject)]);
        await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [`email_template_${template_type}_body`, JSON.stringify(body)]);
        
        res.json({ message: 'Template de email salvo com sucesso.' });
    } catch (err) {
        console.error("Erro ao salvar template de email:", err.message);
        res.status(500).json({ message: "Erro ao salvar template de email." });
    }
});

// POST /api/admin/email-templates/test - Testar envio de template de email
app.post('/api/admin/email-templates/test', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { template_type, test_email } = req.body;
        
        if (!template_type) {
            return res.status(400).json({ message: "Tipo de template é obrigatório." });
        }
        
        if (!test_email) {
            return res.status(400).json({ message: "Email de teste é obrigatório." });
        }
        
        // Validar formato de email
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(test_email)) {
            return res.status(400).json({ message: "Email inválido." });
        }
        
        // Variáveis de exemplo para cada tipo de template
        const exampleVariables = {
            register: {
                nome: 'João Silva',
                email: test_email,
                creditos_iniciais: '100',
                link_acesso: 'https://lacasadarkcore.com/login'
            },
            cancel: {
                nome: 'João Silva',
                email: test_email,
                plano: 'MASTER PRO Mensal',
                data_cancelamento: new Date().toLocaleDateString('pt-BR'),
                data_fim_acesso: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR')
            },
            payment: {
                nome: 'João Silva',
                email: test_email,
                plano: 'MASTER PRO Mensal',
                valor: 'R$ 297,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR')
            },
            package: {
                nome: 'João Silva',
                email: test_email,
                pacote: 'Pacote Premium',
                creditos: '500',
                valor: 'R$ 99,90',
                data_compra: new Date().toLocaleDateString('pt-BR'),
                saldo_atual: '600'
            },
            password_reset: {
                nome: 'João Silva',
                email: test_email,
                senha_provisoria: 'TempPass123!',
                link_acesso: 'https://lacasadarkcore.com/login'
            },
            'subscription_plan-start': {
                nome: 'João Silva',
                email: test_email,
                plano: 'START CREATOR Mensal',
                valor: 'R$ 79,90',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '100'
            },
            'subscription_plan-turbo': {
                nome: 'João Silva',
                email: test_email,
                plano: 'TURBO MAKER Mensal',
                valor: 'R$ 197,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '500'
            },
            'subscription_plan-master': {
                nome: 'João Silva',
                email: test_email,
                plano: 'MASTER PRO Mensal',
                valor: 'R$ 297,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '1000'
            },
            'subscription_plan-start-annual': {
                nome: 'João Silva',
                email: test_email,
                plano: 'START CREATOR Anual',
                valor: 'R$ 799,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '1200'
            },
            'subscription_plan-turbo-annual': {
                nome: 'João Silva',
                email: test_email,
                plano: 'TURBO MAKER Anual',
                valor: 'R$ 1.970,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '6000'
            },
            'subscription_plan-master-annual': {
                nome: 'João Silva',
                email: test_email,
                plano: 'MASTER PRO Anual',
                valor: 'R$ 2.970,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '12000'
            }
        };
        
        const variables = exampleVariables[template_type] || {
            nome: 'João Silva',
            email: test_email
        };
        
        console.log(`[EMAIL TEST] Enviando email de teste para template: ${template_type}`);
        console.log(`[EMAIL TEST] Email de destino: ${test_email}`);
        
        const result = await sendTemplateEmail(template_type, test_email, variables);
        
        if (result.success) {
            res.status(200).json({ 
                message: `Email de teste enviado com sucesso para ${test_email}`,
                messageId: result.messageId,
                accepted: result.accepted
            });
        } else {
            res.status(500).json({ 
                message: `Erro ao enviar email de teste: ${result.error || result.message}`,
                error: result.error
            });
        }
    } catch (err) {
        console.error("[EMAIL TEST] Erro ao testar template de email:", err.message);
        res.status(500).json({ message: "Erro ao testar template de email.", error: err.message });
    }
});

// GET /api/admin/smtp-config - Obter configurações SMTP
app.get('/api/admin/smtp-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key LIKE 'smtp_%'");
        const config = {};
        rows.forEach(row => {
                const key = row.key.replace('smtp_', '');
            // Valores já são strings simples, não precisam de JSON.parse
            let value = row.value;
            
            // Remover aspas duplas se existirem (corrigir dados antigos salvos incorretamente)
            if (typeof value === 'string') {
                value = value.replace(/^["']|["']$/g, '').trim();
            }
            
            // Se for senha, descriptografar
            if (key === 'password') {
                try {
                    // Verificar se está no formato criptografado (IV:encrypted)
                    if (value && value.includes(':') && !value.startsWith('"')) {
                        value = decrypt(value);
                        if (!value) {
                            // Se decrypt retornar null, usar o valor original (senha antiga não criptografada)
                            value = row.value.replace(/^["']|["']$/g, '').trim();
                        }
                    }
                    // Se não tiver ':', é senha antiga não criptografada, manter como está
            } catch (e) {
                    // Se falhar ao descriptografar, usar o valor original (senha antiga não criptografada)
                    console.warn('[SMTP Config] Senha não está criptografada ou erro ao descriptografar, usando valor original');
                    value = row.value.replace(/^["']|["']$/g, '').trim();
                }
            }
            
            // Converter secure para boolean
            if (key === 'secure') {
                value = value === 'true' || value === true;
            }
            
            // Converter port para número
            if (key === 'port') {
                value = parseInt(value) || 587;
            }
            
            config[key] = value;
        });
        console.log('[SMTP Config] Configurações carregadas:', Object.keys(config));
        res.json(config);
    } catch (err) {
        console.error("[SMTP Config] Erro ao buscar configurações SMTP:", err.message);
        res.status(500).json({ message: "Erro ao buscar configurações SMTP: " + err.message });
    }
});

// POST /api/admin/smtp-config - Salvar configurações SMTP
app.post('/api/admin/smtp-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { host, port, email, password, secure } = req.body;
        
        console.log('[SMTP Config] Salvando configurações:', { host, port, email, hasPassword: !!password, secure });
        
        // Remover aspas duplas dos valores antes de salvar
        const cleanHost = host ? String(host).replace(/^["']|["']$/g, '').trim() : null;
        const cleanEmail = email ? String(email).replace(/^["']|["']$/g, '').trim() : null;
        
        if (cleanHost && cleanHost !== '') {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_host', cleanHost]);
            console.log('[SMTP Config] Host salvo:', cleanHost);
        }
        if (port !== undefined && port !== null) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_port', String(port)]);
            console.log('[SMTP Config] Porta salva:', port);
        }
        if (cleanEmail && cleanEmail !== '') {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_email', cleanEmail]);
            console.log('[SMTP Config] Email salvo:', cleanEmail);
        }
        if (password !== undefined && password !== null && password !== '') {
            // Criptografar a senha antes de salvar
            const encryptedPassword = encrypt(password);
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_password', encryptedPassword]);
            console.log('[SMTP Config] Senha salva (criptografada)');
        }
        if (secure !== undefined && secure !== null) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_secure', String(secure)]);
            console.log('[SMTP Config] Secure salvo:', secure);
        }
        
        res.json({ message: 'Configurações SMTP salvas com sucesso.' });
    } catch (err) {
        console.error("[SMTP Config] Erro ao salvar configurações SMTP:", err.message);
        res.status(500).json({ message: "Erro ao salvar configurações SMTP: " + err.message });
    }
});

// POST /api/admin/smtp-config/test - Testar configuração SMTP enviando email de teste
app.post('/api/admin/smtp-config/test', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { testEmail } = req.body;
        
        if (!testEmail) {
            return res.status(400).json({ message: 'Email de teste não fornecido.' });
        }

        console.log('[SMTP Test] Iniciando teste de configuração SMTP...');
        console.log('[SMTP Test] Email de destino:', testEmail);

        // Obter configuração SMTP atual
        const smtpConfig = await getSMTPConfig();
        
        if (!smtpConfig || !smtpConfig.host || !smtpConfig.email || !smtpConfig.password) {
            return res.status(400).json({ 
                message: 'Configuração SMTP incompleta. Configure o servidor, email e senha antes de testar.' 
            });
        }

        // Limpar host e email de possíveis aspas (corrigir dados antigos)
        const cleanHost = smtpConfig.host ? String(smtpConfig.host).replace(/^["']|["']$/g, '').trim() : null;
        const cleanEmail = smtpConfig.email ? String(smtpConfig.email).replace(/^["']|["']$/g, '').trim() : null;
        
        console.log('[SMTP Test] Configuração SMTP encontrada:', {
            host: cleanHost,
            port: smtpConfig.port,
            email: cleanEmail,
            hasPassword: !!smtpConfig.password,
            secure: smtpConfig.secure
        });
        
        if (!cleanHost) {
            return res.status(400).json({ 
                message: 'Host SMTP inválido. Verifique as configurações.' 
            });
        }

        // Criar transporter com valores limpos
        const transporter = nodemailer.createTransport({
            host: cleanHost,
            port: parseInt(smtpConfig.port) || 587,
            secure: smtpConfig.secure === true || smtpConfig.secure === 'true',
            // Aceitar certificados autoassinados (comum em servidores SMTP privados)
            tls: {
                rejectUnauthorized: false,
                ciphers: 'SSLv3'
            },
            auth: {
                user: cleanEmail,
                pass: smtpConfig.password
            },
            // Timeout aumentado para conexões mais lentas
            connectionTimeout: 10000,
            greetingTimeout: 10000,
            socketTimeout: 10000
        });

        console.log('[SMTP Test] Verificando conexão SMTP...');
        
        // Verificar conexão
        await transporter.verify();
        console.log('[SMTP Test] ✅ Conexão SMTP verificada com sucesso');

        // Enviar email de teste
        const testSubject = 'Teste de Configuração SMTP - La Casa Dark Core';
        const testBody = `
            <html>
                <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
                    <div style="max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f9f9f9; border-radius: 8px;">
                        <h2 style="color: #f59e0b;">✅ Teste de Configuração SMTP</h2>
                        <p>Este é um email de teste para validar as configurações SMTP do La Casa Dark Core.</p>
                        <p><strong>Se você recebeu este email, significa que suas configurações SMTP estão funcionando corretamente!</strong></p>
                        <hr style="border: none; border-top: 1px solid #ddd; margin: 20px 0;">
                        <p style="color: #666; font-size: 12px;">
                            <strong>Detalhes da configuração:</strong><br>
                            Servidor: ${cleanHost}<br>
                            Porta: ${smtpConfig.port}<br>
                            Email de envio: ${cleanEmail}<br>
                            TLS/SSL: ${smtpConfig.secure ? 'Sim' : 'Não'}<br>
                            Data/Hora: ${new Date().toLocaleString('pt-BR')}
                        </p>
                    </div>
                </body>
            </html>
        `;

        console.log('[SMTP Test] Enviando email de teste...');
        
        const mailOptions = {
            from: `"La Casa Dark Core" <${cleanEmail}>`,
            to: testEmail,
            subject: testSubject,
            html: testBody,
            text: 'Este é um email de teste para validar as configurações SMTP do La Casa Dark Core. Se você recebeu este email, significa que suas configurações SMTP estão funcionando corretamente!'
        };

        const info = await transporter.sendMail(mailOptions);
        
        console.log('[SMTP Test] ✅ Email de teste enviado com sucesso!');
        console.log('[SMTP Test] Message ID:', info.messageId);

        res.json({ 
            message: `Email de teste enviado com sucesso para ${testEmail}! Verifique sua caixa de entrada.`,
            messageId: info.messageId
        });

    } catch (err) {
        console.error('[SMTP Test] ❌ Erro ao testar configuração SMTP:', err.message);
        console.error('[SMTP Test] Stack trace:', err.stack);
        
        let errorMessage = 'Erro ao enviar email de teste.';
        
        if (err.code === 'EAUTH') {
            errorMessage = 'Erro de autenticação. Verifique o email e senha do SMTP.';
        } else if (err.code === 'ECONNECTION' || err.code === 'ETIMEDOUT' || err.message.includes('Connection closed')) {
            errorMessage = 'Erro de conexão. Verifique o servidor SMTP, porta e se o TLS/SSL está configurado corretamente. Alguns servidores requerem STARTTLS na porta 587.';
        } else if (err.code === 'EENVELOPE') {
            errorMessage = 'Erro no endereço de email. Verifique o email de destino.';
        } else if (err.message.includes('self-signed certificate') || err.message.includes('certificate')) {
            errorMessage = 'Erro de certificado SSL. O servidor SMTP está usando um certificado autoassinado. Tente desmarcar "Usar TLS/SSL" ou verifique as configurações do servidor.';
        } else if (err.message) {
            errorMessage = `Erro: ${err.message}`;
        }
        
        res.status(500).json({ message: errorMessage });
    }
});

// ============================================
// SISTEMA DE ENVIO DE EMAILS
// ============================================

// Função para obter configuração SMTP
async function getSMTPConfig() {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key LIKE 'smtp_%'");
        const config = {};
        rows.forEach(row => {
                const key = row.key.replace('smtp_', '');
            let value = row.value;
            
            // Se for senha, descriptografar
            if (key === 'password') {
                try {
                    // Verificar se está no formato criptografado (IV:encrypted)
                    if (value && value.includes(':')) {
                        value = decrypt(value);
                        if (!value) {
                            // Se decrypt retornar null, usar o valor original (senha antiga não criptografada)
                            value = row.value;
                        }
                    }
                    // Se não tiver ':', é senha antiga não criptografada, manter como está
            } catch (e) {
                    // Se falhar ao descriptografar, usar o valor original (senha antiga não criptografada)
                    console.warn('[EMAIL] Senha SMTP não está criptografada ou erro ao descriptografar, usando valor original');
                    value = row.value;
            }
            }
            
            // Converter secure para boolean
            if (key === 'secure') {
                value = value === 'true' || value === true;
            }
            
            // Converter port para número
            if (key === 'port') {
                value = parseInt(value) || 587;
            }
            
            config[key] = value;
        });
        return config;
    } catch (error) {
        console.error('[EMAIL] Erro ao buscar configuração SMTP:', error.message);
        return null;
    }
}

// Função para criar transporter do nodemailer
async function createEmailTransporter() {
    const smtpConfig = await getSMTPConfig();
    
    if (!smtpConfig || !smtpConfig.host || !smtpConfig.email || !smtpConfig.password) {
        console.warn('[EMAIL] SMTP não configurado. Emails não serão enviados.');
        return null;
    }
    
    try {
        // Limpar host e email de possíveis aspas
        const cleanHost = smtpConfig.host ? String(smtpConfig.host).replace(/^["']|["']$/g, '').trim() : null;
        const cleanEmail = smtpConfig.email ? String(smtpConfig.email).replace(/^["']|["']$/g, '').trim() : null;
        
        const transporter = nodemailer.createTransport({
            host: cleanHost,
            port: parseInt(smtpConfig.port) || 587,
            secure: smtpConfig.secure === true || smtpConfig.secure === 'true',
            // Aceitar certificados autoassinados (comum em servidores SMTP privados)
            tls: {
                rejectUnauthorized: false,
                ciphers: 'SSLv3'
            },
            auth: {
                user: cleanEmail,
                pass: smtpConfig.password
            },
            // Timeout aumentado para conexões mais lentas
            connectionTimeout: 10000,
            greetingTimeout: 10000,
            socketTimeout: 10000
        });
        
        // Verificar conexão
        await transporter.verify();
        console.log('[EMAIL] SMTP configurado e verificado com sucesso');
        return transporter;
    } catch (error) {
        console.error('[EMAIL] Erro ao criar transporter:', error.message);
        return null;
    }
}

// Templates padrão para fallback
const defaultEmailTemplates = {
    password_reset: {
        subject: 'Reset de Senha - La Casa Dark Core',
        body: `
            <html>
                <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
                    <div style="background-color: #f9f9f9; border-radius: 8px; padding: 30px; border: 1px solid #ddd;">
                        <h2 style="color: #f59e0b; margin-top: 0;">🔐 Reset de Senha</h2>
                        <p>Olá <strong>{{nome}}</strong>,</p>
                        <p>Você solicitou a redefinição de senha para sua conta no La Casa Dark Core.</p>
                        <p>Clique no link abaixo para redefinir sua senha:</p>
                        <div style="text-align: center; margin: 30px 0;">
                            <a href="{{link_acesso}}" style="background-color: #f59e0b; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;">Redefinir Senha</a>
                        </div>
                        <p style="color: #666; font-size: 12px;">Ou copie e cole este link no seu navegador:</p>
                        <p style="color: #666; font-size: 12px; word-break: break-all;">{{link_acesso}}</p>
                        <p style="color: #999; font-size: 11px; margin-top: 30px; border-top: 1px solid #ddd; padding-top: 20px;">
                            Este link expira em 1 hora. Se você não solicitou esta redefinição, ignore este email.
                        </p>
                        <p style="color: #999; font-size: 11px;">
                            Equipe La Casa Dark Core
                        </p>
                    </div>
                </body>
            </html>
        `
    },
    register: {
        subject: 'Bem-vindo à La Casa Dark Core!',
        body: `
            <html>
                <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
                    <p>Olá {{nome}},</p>
                    <p>Bem-vindo à La Casa Dark Core! Sua conta foi criada com sucesso.</p>
                    <p>Créditos iniciais: {{creditos_iniciais}}</p>
                    <p><a href="{{link_acesso}}">Acessar minha conta</a></p>
                </body>
            </html>
        `
    }
};

// Função para obter template de email
async function getEmailTemplate(templateType) {
    try {
        const subjectRow = await db.get("SELECT value FROM app_settings WHERE key = ?", [`email_template_${templateType}_subject`]);
        const bodyRow = await db.get("SELECT value FROM app_settings WHERE key = ?", [`email_template_${templateType}_body`]);
        
        // Se não encontrar no banco, usar template padrão
        if (!subjectRow || !bodyRow) {
            if (defaultEmailTemplates[templateType]) {
                console.log(`[EMAIL] Usando template padrão para ${templateType}`);
                return defaultEmailTemplates[templateType];
            }
            return null;
        }
        
        let subject, body;
        try {
            subject = JSON.parse(subjectRow.value);
            body = JSON.parse(bodyRow.value);
        } catch {
            subject = subjectRow.value;
            body = bodyRow.value;
        }
        
        return { subject, body };
    } catch (error) {
        console.error(`[EMAIL] Erro ao buscar template ${templateType}:`, error.message);
        // Tentar usar template padrão em caso de erro
        if (defaultEmailTemplates[templateType]) {
            console.log(`[EMAIL] Usando template padrão para ${templateType} devido a erro`);
            return defaultEmailTemplates[templateType];
        }
        return null;
    }
}

// Função para substituir variáveis no template
function replaceTemplateVariables(template, variables) {
    if (!template) return '';
    
    let result = template;
    for (const [key, value] of Object.entries(variables)) {
        const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        result = result.replace(regex, value || '');
    }
    return result;
}

// Função para enviar email
async function sendEmail(to, subject, htmlBody, textBody = null) {
    try {
        const transporter = await createEmailTransporter();
        if (!transporter) {
            console.warn('[EMAIL] Transporter não disponível, email não enviado');
            return { success: false, message: 'SMTP não configurado' };
        }
        
        const smtpConfig = await getSMTPConfig();
        // Limpar email de possíveis aspas
        const fromEmail = smtpConfig && smtpConfig.email ? String(smtpConfig.email).replace(/^["']|["']$/g, '').trim() : 'noreply@lacasadarkcore.com';
        
        const mailOptions = {
            from: `"La Casa Dark Core" <${fromEmail}>`,
            to: to,
            subject: subject,
            html: htmlBody,
            text: textBody || htmlBody.replace(/<[^>]*>/g, ''), // Remover HTML se não houver texto
            // Adicionar headers para melhorar a entrega
            headers: {
                'X-Priority': '1',
                'X-MSMail-Priority': 'High',
                'Importance': 'high',
                'List-Unsubscribe': `<mailto:${fromEmail}?subject=unsubscribe>`,
                'X-Mailer': 'La Casa Dark Core'
            },
            // Adicionar informações de reply-to
            replyTo: fromEmail
        };
        
        console.log(`[EMAIL] Enviando email para: ${to}`);
        console.log(`[EMAIL] De: ${mailOptions.from}`);
        console.log(`[EMAIL] Assunto: ${mailOptions.subject}`);
        
        const info = await transporter.sendMail(mailOptions);
        
        console.log(`[EMAIL] ✅ Email aceito pelo servidor SMTP`);
        console.log(`[EMAIL] Message ID: ${info.messageId}`);
        console.log(`[EMAIL] Response: ${info.response || 'N/A'}`);
        console.log(`[EMAIL] Envelope:`, JSON.stringify(info.envelope || {}));
        
        // Verificar se o servidor SMTP realmente aceitou o email
        if (info.accepted && info.accepted.length > 0) {
            console.log(`[EMAIL] ✅ Email aceito para entrega: ${info.accepted.join(', ')}`);
        }
        if (info.rejected && info.rejected.length > 0) {
            console.error(`[EMAIL] ❌ Email rejeitado: ${info.rejected.join(', ')}`);
        }
        if (info.pending && info.pending.length > 0) {
            console.warn(`[EMAIL] ⚠️ Email pendente: ${info.pending.join(', ')}`);
        }
        
        return { success: true, messageId: info.messageId, response: info.response, accepted: info.accepted, rejected: info.rejected };
    } catch (error) {
        console.error('[EMAIL] ❌ Erro ao enviar email:', error.message);
        console.error('[EMAIL] Stack trace:', error.stack);
        if (error.response) {
            console.error('[EMAIL] Response do servidor:', error.response);
        }
        return { success: false, error: error.message };
    }
}

// Função para enviar email usando template
async function sendTemplateEmail(templateType, to, variables = {}) {
    try {
        const template = await getEmailTemplate(templateType);
        if (!template) {
            console.warn(`[EMAIL] Template ${templateType} não encontrado`);
            return { success: false, message: 'Template não encontrado' };
        }
        
        const subject = replaceTemplateVariables(template.subject, variables);
        const body = replaceTemplateVariables(template.body, variables);
        
        console.log(`[EMAIL] Preparando email ${templateType} para: ${to}`);
        console.log(`[EMAIL] Assunto: ${subject.substring(0, 50)}...`);
        
        const result = await sendEmail(to, subject, body);
        
        // Log adicional sobre o resultado
        if (result.success) {
            console.log(`[EMAIL] ✅ Email ${templateType} processado com sucesso`);
            if (result.accepted && result.accepted.length > 0) {
                console.log(`[EMAIL] 📬 Destinatários aceitos: ${result.accepted.join(', ')}`);
            }
            if (result.rejected && result.rejected.length > 0) {
                console.error(`[EMAIL] ❌ Destinatários rejeitados: ${result.rejected.join(', ')}`);
            }
        } else {
            console.error(`[EMAIL] ❌ Falha ao enviar email ${templateType}: ${result.error || result.message}`);
        }
        
        return result;
    } catch (error) {
        console.error(`[EMAIL] Erro ao enviar email com template ${templateType}:`, error.message);
        console.error(`[EMAIL] Stack trace:`, error.stack);
        return { success: false, error: error.message };
    }
}

// GET /api/admin/pixel-config - Obter configurações de Pixel/Ads
app.get('/api/admin/pixel-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key IN ('facebook_pixel_id', 'google_ads_id')");
        const config = {};
        rows.forEach(row => {
            try {
                config[row.key] = JSON.parse(row.value);
            } catch (e) {
                config[row.key] = row.value;
            }
        });
        res.json(config);
    } catch (err) {
        console.error("Erro ao buscar configurações de Pixel:", err.message);
        res.status(500).json({ message: "Erro ao buscar configurações de Pixel." });
    }
});

// POST /api/admin/pixel-config - Salvar configurações de Pixel/Ads
app.post('/api/admin/pixel-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { facebook_pixel_id, google_ads_id } = req.body;
        
        if (facebook_pixel_id !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['facebook_pixel_id', JSON.stringify(facebook_pixel_id)]);
        }
        
        if (google_ads_id !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['google_ads_id', JSON.stringify(google_ads_id)]);
        }
        
        res.json({ message: 'Configurações de Pixel salvas com sucesso.' });
    } catch (err) {
        console.error("Erro ao salvar configurações de Pixel:", err.message);
        res.status(500).json({ message: "Erro ao salvar configurações de Pixel." });
    }
});

// GET /api/admin/stripe-config - Obter configurações do Stripe
app.get('/api/admin/stripe-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key LIKE 'stripe_%'");
        const config = {};
        rows.forEach(row => {
            try {
                config[row.key.replace('stripe_', '')] = JSON.parse(row.value);
            } catch (e) {
                config[row.key.replace('stripe_', '')] = row.value;
            }
        });
        
        // Retornar em formato mais amigável
        res.json({
            publishable_key: config.publishable_key || null,
            secret_key: config.secret_key || null,
            webhook_secret: config.webhook_secret || null,
            plans: {
                'plan-free': config['plan-free'] || null,
                'plan-start': config['plan-start'] || null,
                'plan-turbo': config['plan-turbo'] || null,
                'plan-master': config['plan-master'] || null,
                'plan-start-annual': config['plan-start-annual'] || null,
                'plan-turbo-annual': config['plan-turbo-annual'] || null,
                'plan-master-annual': config['plan-master-annual'] || null,
                'package-1000': config['package-1000'] || null,
                'package-2500': config['package-2500'] || null,
                'package-5000': config['package-5000'] || null,
                'package-10000': config['package-10000'] || null,
                'package-20000': config['package-20000'] || null
            }
        });
    } catch (err) {
        console.error("Erro ao buscar configurações do Stripe:", err.message);
        res.status(500).json({ message: "Erro ao buscar configurações do Stripe." });
    }
});

// GET /api/admin/subscriptions - Obter dados de assinaturas
app.get('/api/admin/subscriptions', authenticateToken, isAdmin, async (req, res) => {
    try {
        const period = parseInt(req.query.period) || 30;
        const status = req.query.status || 'all';
        
        // Calcular datas
        const endDate = new Date();
        const startDate = new Date();
        if (period !== 0) {
            startDate.setDate(startDate.getDate() - period);
        } else {
            startDate.setFullYear(2000); // Para "all"
        }
        
        // Por enquanto, vamos criar uma estrutura de dados mockada
        // Quando você integrar com Stripe, substitua por dados reais
        const subscriptions = [];
        
        // Buscar assinaturas do banco (assumindo que você tem uma tabela de assinaturas)
        // Por enquanto, vamos retornar dados de exemplo
        const kpis = {
            mrr: 0,
            arr: 0,
            active_subscribers: 0,
            churn_rate: 0,
            mrr_change: 0,
            arr_change: 0,
            active_subscribers_change: 0,
            churn_rate_change: 0,
            new_subscribers: 0,
            cancellations: 0,
            ltv: 0,
            avg_duration: 0,
            // Novos campos
            total_revenue: 0,
            monthly_revenue: 0,
            total_subscriptions: 0,
            conversion_rate: 0,
            monthly_new: 0,
            monthly_canceled: 0,
            monthly_growth: 0,
            revenue_30d: 0,
            revenue_90d: 0,
            revenue_year: 0,
            avg_ticket: 0,
            total_canceled: 0,
            retention_rate: 0
        };
        
        const charts = {
            mrr: { labels: [], data: [] },
            subscribers: { labels: [], data: [] },
            plans_distribution: { labels: [], data: [] },
            churn: { labels: [], data: [] }
        };
        
        const insights = [
            {
                type: 'info',
                icon: 'info',
                title: 'Sistema de Assinaturas',
                message: 'Configure o Stripe e comece a receber assinaturas para ver dados reais aqui.'
            }
        ];
        
        // Tentar buscar dados reais se existir tabela de assinaturas
        try {
            // Verificar se existe tabela de assinaturas
            const tableExists = await db.get(`
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='subscriptions'
            `);
            
            if (tableExists) {
                // Verificar quais colunas existem na tabela
                const tableInfo = await db.all(`PRAGMA table_info(subscriptions)`);
                const columns = tableInfo.map(col => col.name);
                
                // Construir query dinamicamente baseado nas colunas disponíveis
                const hasMonthlyAmount = columns.includes('monthly_amount');
                const hasTotalPaid = columns.includes('total_paid');
                const hasDurationDays = columns.includes('duration_days');
                const hasPlanName = columns.includes('plan_name');
                const hasNextBilling = columns.includes('next_billing_date');
                const hasUpdatedAt = columns.includes('updated_at');
                const hasCanceledAt = columns.includes('canceled_at');
                
                // Buscar assinaturas
                let query = `
                    SELECT s.*, u.email as user_email, u.name as user_name
                    FROM subscriptions s
                    LEFT JOIN users u ON s.user_id = u.id
                    WHERE s.created_at >= ? AND s.created_at <= ?
                `;
                const params = [startDate.toISOString(), endDate.toISOString()];
                
                if (status !== 'all') {
                    query += ' AND s.status = ?';
                    params.push(status);
                }
                
                query += ' ORDER BY s.created_at DESC';
                
                const subs = await db.all(query, params);
                
                // Calcular KPIs
                let totalMRR = 0;
                let activeCount = 0;
                let newCount = 0;
                let cancelCount = 0;
                let totalPaid = 0;
                let totalDuration = 0;
                
                const planDistribution = {};
                
                subs.forEach(sub => {
                    if (sub.status === 'active') {
                        if (hasMonthlyAmount) {
                            totalMRR += parseFloat(sub.monthly_amount || 0);
                        }
                        activeCount++;
                    }
                    if (sub.status === 'canceled') {
                        cancelCount++;
                    }
                    if (new Date(sub.created_at) >= startDate) {
                        newCount++;
                    }
                    if (hasTotalPaid) {
                        totalPaid += parseFloat(sub.total_paid || 0);
                    }
                    if (hasDurationDays) {
                        totalDuration += parseInt(sub.duration_days || 0);
                    }
                    
                    const planName = (hasPlanName && sub.plan_name) ? sub.plan_name : 'Desconhecido';
                    planDistribution[planName] = (planDistribution[planName] || 0) + 1;
                });
                
                kpis.mrr = totalMRR;
                kpis.arr = totalMRR * 12;
                kpis.active_subscribers = activeCount;
                kpis.new_subscribers = newCount;
                kpis.cancellations = cancelCount;
                kpis.ltv = activeCount > 0 ? totalPaid / activeCount : 0;
                kpis.avg_duration = subs.length > 0 ? totalDuration / subs.length : 0;
                
                // Calcular receitas
                kpis.total_revenue = totalPaid;
                kpis.monthly_revenue = totalMRR;
                
                // Calcular receitas por período
                const now = new Date();
                const date30d = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                const date90d = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                const yearStart = new Date(now.getFullYear(), 0, 1);
                
                if (hasTotalPaid) {
                    const revenue30dQuery = `SELECT SUM(total_paid) as revenue FROM subscriptions WHERE created_at >= ?`;
                    const revenue30dResult = await db.get(revenue30dQuery, [date30d.toISOString()]);
                    kpis.revenue_30d = parseFloat(revenue30dResult?.revenue || 0);
                    
                    const revenue90dQuery = `SELECT SUM(total_paid) as revenue FROM subscriptions WHERE created_at >= ?`;
                    const revenue90dResult = await db.get(revenue90dQuery, [date90d.toISOString()]);
                    kpis.revenue_90d = parseFloat(revenue90dResult?.revenue || 0);
                    
                    const revenueYearQuery = `SELECT SUM(total_paid) as revenue FROM subscriptions WHERE created_at >= ?`;
                    const revenueYearResult = await db.get(revenueYearQuery, [yearStart.toISOString()]);
                    kpis.revenue_year = parseFloat(revenueYearResult?.revenue || 0);
                }
                
                // Calcular métricas mensais
                const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
                const monthlyNewQuery = `SELECT COUNT(*) as count FROM subscriptions WHERE created_at >= ?`;
                const monthlyNewResult = await db.get(monthlyNewQuery, [monthStart.toISOString()]);
                kpis.monthly_new = parseInt(monthlyNewResult?.count || 0);
                
                const monthlyCanceledQuery = `SELECT COUNT(*) as count FROM subscriptions WHERE status = 'canceled' AND updated_at >= ?`;
                const monthlyCanceledResult = await db.get(monthlyCanceledQuery, [monthStart.toISOString()]);
                kpis.monthly_canceled = parseInt(monthlyCanceledResult?.count || 0);
                
                // Calcular crescimento mensal
                const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
                const lastMonthNewQuery = `SELECT COUNT(*) as count FROM subscriptions WHERE created_at >= ? AND created_at <= ?`;
                const lastMonthNewResult = await db.get(lastMonthNewQuery, [lastMonthStart.toISOString(), lastMonthEnd.toISOString()]);
                const lastMonthNew = parseInt(lastMonthNewResult?.count || 0);
                kpis.monthly_growth = lastMonthNew > 0 ? ((kpis.monthly_new - lastMonthNew) / lastMonthNew) * 100 : 0;
                
                // Total de assinaturas
                const totalSubsQuery = `SELECT COUNT(*) as count FROM subscriptions`;
                const totalSubsResult = await db.get(totalSubsQuery);
                kpis.total_subscriptions = parseInt(totalSubsResult?.count || 0);
                
                // Total canceladas
                const totalCanceledQuery = `SELECT COUNT(*) as count FROM subscriptions WHERE status = 'canceled'`;
                const totalCanceledResult = await db.get(totalCanceledQuery);
                kpis.total_canceled = parseInt(totalCanceledResult?.count || 0);
                
                // Taxa de retenção
                const totalActive = kpis.active_subscribers;
                kpis.retention_rate = kpis.total_subscriptions > 0 ? (totalActive / kpis.total_subscriptions) * 100 : 0;
                
                // Ticket médio
                kpis.avg_ticket = subs.length > 0 ? totalPaid / subs.length : 0;
                
                // Taxa de conversão (assumindo que você tem dados de visitantes/usuários)
                // Por enquanto, vamos calcular baseado em novos assinantes vs total de usuários
                const totalUsersQuery = `SELECT COUNT(*) as count FROM users`;
                const totalUsersResult = await db.get(totalUsersQuery);
                const totalUsers = parseInt(totalUsersResult?.count || 1);
                kpis.conversion_rate = totalUsers > 0 ? (kpis.total_subscriptions / totalUsers) * 100 : 0;
                
                // Calcular churn rate (últimos 30 dias)
                if (hasUpdatedAt) {
                    const churnStartDate = new Date();
                    churnStartDate.setDate(churnStartDate.getDate() - 30);
                    const churnQuery = `
                        SELECT COUNT(*) as canceled_count
                        FROM subscriptions
                        WHERE status = 'canceled' AND updated_at >= ?
                    `;
                    const churnResult = await db.get(churnQuery, [churnStartDate.toISOString()]);
                    const canceledCount = churnResult?.canceled_count || 0;
                    const totalActive30DaysAgo = activeCount + canceledCount;
                    kpis.churn_rate = totalActive30DaysAgo > 0 ? (canceledCount / totalActive30DaysAgo) * 100 : 0;
                }
                
                // Preparar dados para gráficos (apenas se tiver colunas necessárias)
                if (hasMonthlyAmount) {
                    // MRR ao longo do tempo (últimos 12 meses)
                    for (let i = 11; i >= 0; i--) {
                        const date = new Date();
                        date.setMonth(date.getMonth() - i);
                        const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
                        const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                        
                        let mrrQuery = `
                            SELECT SUM(monthly_amount) as mrr
                            FROM subscriptions
                            WHERE status = 'active' AND created_at <= ?
                        `;
                        if (hasCanceledAt) {
                            mrrQuery += ' AND (status != \'canceled\' OR canceled_at > ?)';
                            const mrrResult = await db.get(mrrQuery, [monthEnd.toISOString(), monthEnd.toISOString()]);
                            charts.mrr.labels.push(monthStart.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                            charts.mrr.data.push(parseFloat(mrrResult?.mrr || 0));
                        } else {
                            const mrrResult = await db.get(mrrQuery, [monthEnd.toISOString()]);
                            charts.mrr.labels.push(monthStart.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                            charts.mrr.data.push(parseFloat(mrrResult?.mrr || 0));
                        }
                    }
                }
                
                // Assinantes ao longo do tempo
                for (let i = 11; i >= 0; i--) {
                    const date = new Date();
                    date.setMonth(date.getMonth() - i);
                    const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                    
                    let subsQuery = `
                        SELECT COUNT(*) as count
                        FROM subscriptions
                        WHERE status = 'active' AND created_at <= ?
                    `;
                    if (hasCanceledAt) {
                        subsQuery += ' AND (status != \'canceled\' OR canceled_at > ?)';
                        const subsResult = await db.get(subsQuery, [monthEnd.toISOString(), monthEnd.toISOString()]);
                        charts.subscribers.labels.push(date.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                        charts.subscribers.data.push(parseInt(subsResult?.count || 0));
                    } else {
                        const subsResult = await db.get(subsQuery, [monthEnd.toISOString()]);
                        charts.subscribers.labels.push(date.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                        charts.subscribers.data.push(parseInt(subsResult?.count || 0));
                    }
                }
                
                // Distribuição por plano
                charts.plans_distribution.labels = Object.keys(planDistribution);
                charts.plans_distribution.data = Object.values(planDistribution);
                
                // Churn mensal
                if (hasUpdatedAt) {
                    for (let i = 11; i >= 0; i--) {
                        const date = new Date();
                        date.setMonth(date.getMonth() - i);
                        const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
                        const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                        
                        const churnQuery = `
                            SELECT 
                                COUNT(CASE WHEN status = 'canceled' AND updated_at >= ? AND updated_at <= ? THEN 1 END) as canceled,
                                COUNT(CASE WHEN status = 'active' AND created_at <= ? THEN 1 END) as active
                            FROM subscriptions
                            WHERE created_at <= ?
                        `;
                        const churnResult = await db.get(churnQuery, [
                            monthStart.toISOString(), 
                            monthEnd.toISOString(),
                            monthEnd.toISOString(),
                            monthEnd.toISOString()
                        ]);
                        const canceled = churnResult?.canceled || 0;
                        const active = churnResult?.active || 1;
                        const churnRate = (canceled / active) * 100;
                        
                        charts.churn.labels.push(date.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                        charts.churn.data.push(churnRate);
                    }
                }
                
                // Preparar lista de assinaturas
                subscriptions.push(...subs.map(sub => ({
                    user_email: sub.user_email || 'N/A',
                    plan_name: (hasPlanName && sub.plan_name) ? sub.plan_name : 'N/A',
                    status: sub.status || 'unknown',
                    monthly_amount: hasMonthlyAmount ? parseFloat(sub.monthly_amount || 0) : 0,
                    start_date: sub.created_at,
                    next_billing_date: (hasNextBilling && sub.next_billing_date) ? sub.next_billing_date : null,
                    duration_days: hasDurationDays ? parseInt(sub.duration_days || 0) : 0,
                    total_paid: hasTotalPaid ? parseFloat(sub.total_paid || 0) : 0
                })));
                
                // Gerar insights
                insights.length = 0; // Limpar insights padrão
                
                if (kpis.mrr > 0) {
                    insights.push({
                        type: 'positive',
                        icon: 'trending-up',
                        title: 'MRR Crescente',
                        message: `Seu MRR atual é de ${kpis.mrr.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}. Continue focado em crescimento!`
                    });
                }
                
                if (kpis.churn_rate > 5) {
                    insights.push({
                        type: 'warning',
                        icon: 'alert-triangle',
                        title: 'Churn Rate Alto',
                        message: `Seu churn rate está em ${kpis.churn_rate.toFixed(2)}%. Considere melhorar a retenção de clientes.`
                    });
                }
                
                if (kpis.new_subscribers > 0) {
                    insights.push({
                        type: 'positive',
                        icon: 'user-plus',
                        title: 'Novos Assinantes',
                        message: `${kpis.new_subscribers} novos assinantes no período selecionado.`
                    });
                }
            }
        } catch (err) {
            console.log('Tabela de assinaturas não encontrada ou erro ao buscar:', err.message);
        }
        
        res.json({
            kpis,
            charts,
            subscriptions,
            insights
        });
    } catch (err) {
        console.error('Erro ao buscar assinaturas:', err);
        res.status(500).json({ message: 'Erro ao buscar dados de assinaturas' });
    }
});

// GET /api/admin/subscriptions/report/revenue - Relatório de receitas
app.get('/api/admin/subscriptions/report/revenue', authenticateToken, isAdmin, async (req, res) => {
    try {
        const tableExists = await db.get(`
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='subscriptions'
        `);
        
        if (!tableExists) {
            return res.status(404).json({ message: 'Tabela de assinaturas não encontrada' });
        }
        
        const tableInfo = await db.all(`PRAGMA table_info(subscriptions)`);
        const columns = tableInfo.map(col => col.name);
        const hasTotalPaid = columns.includes('total_paid');
        const hasMonthlyAmount = columns.includes('monthly_amount');
        
        const now = new Date();
        const date30d = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const date90d = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
        const yearStart = new Date(now.getFullYear(), 0, 1);
        
        let csv = 'Métrica,Valor\n';
        const totalRevenue = hasTotalPaid ? (await db.get('SELECT SUM(total_paid) as total FROM subscriptions')).total || 0 : 0;
        const revenue30d = hasTotalPaid ? (await db.get('SELECT SUM(total_paid) as total FROM subscriptions WHERE created_at >= ?', [date30d.toISOString()])).total || 0 : 0;
        const revenue90d = hasTotalPaid ? (await db.get('SELECT SUM(total_paid) as total FROM subscriptions WHERE created_at >= ?', [date90d.toISOString()])).total || 0 : 0;
        const revenueYear = hasTotalPaid ? (await db.get('SELECT SUM(total_paid) as total FROM subscriptions WHERE created_at >= ?', [yearStart.toISOString()])).total || 0 : 0;
        const mrr = hasMonthlyAmount ? (await db.get('SELECT SUM(monthly_amount) as mrr FROM subscriptions WHERE status = ?', ['active'])).mrr || 0 : 0;
        const arr = mrr * 12;
        
        csv += `Receita Total,${totalRevenue}\n`;
        csv += `Receita Últimos 30 Dias,${revenue30d}\n`;
        csv += `Receita Últimos 90 Dias,${revenue90d}\n`;
        csv += `Receita do Ano,${revenueYear}\n`;
        csv += `MRR,${mrr}\n`;
        csv += `ARR,${arr}\n`;
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=relatorio_receitas_${Date.now()}.csv`);
        res.send(csv);
    } catch (err) {
        console.error('Erro ao exportar relatório de receitas:', err);
        res.status(500).json({ message: 'Erro ao exportar relatório' });
    }
});

// GET /api/admin/subscriptions/report/subscriptions - Relatório de assinaturas
app.get('/api/admin/subscriptions/report/subscriptions', authenticateToken, isAdmin, async (req, res) => {
    try {
        const tableExists = await db.get(`
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='subscriptions'
        `);
        
        if (!tableExists) {
            return res.status(404).json({ message: 'Tabela de assinaturas não encontrada' });
        }
        
        const totalSubs = await db.get('SELECT COUNT(*) as count FROM subscriptions');
        const activeSubs = await db.get('SELECT COUNT(*) as count FROM subscriptions WHERE status = ?', ['active']);
        const canceledSubs = await db.get('SELECT COUNT(*) as count FROM subscriptions WHERE status = ?', ['canceled']);
        
        const now = new Date();
        const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
        const monthlyNew = await db.get('SELECT COUNT(*) as count FROM subscriptions WHERE created_at >= ?', [monthStart.toISOString()]);
        const monthlyCanceled = await db.get('SELECT COUNT(*) as count FROM subscriptions WHERE status = ? AND updated_at >= ?', ['canceled', monthStart.toISOString()]);
        
        let csv = 'Métrica,Valor\n';
        csv += `Total de Assinaturas,${totalSubs?.count || 0}\n`;
        csv += `Assinaturas Ativas,${activeSubs?.count || 0}\n`;
        csv += `Assinaturas Canceladas,${canceledSubs?.count || 0}\n`;
        csv += `Novos Este Mês,${monthlyNew?.count || 0}\n`;
        csv += `Cancelados Este Mês,${monthlyCanceled?.count || 0}\n`;
        const retentionRate = totalSubs?.count > 0 ? ((activeSubs?.count || 0) / totalSubs.count * 100).toFixed(2) : 0;
        csv += `Taxa de Retenção,${retentionRate}%\n`;
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=relatorio_assinaturas_${Date.now()}.csv`);
        res.send(csv);
    } catch (err) {
        console.error('Erro ao exportar relatório de assinaturas:', err);
        res.status(500).json({ message: 'Erro ao exportar relatório' });
    }
});

// GET /api/admin/subscriptions/export - Exportar assinaturas
app.get('/api/admin/subscriptions/export', authenticateToken, isAdmin, async (req, res) => {
    try {
        const period = parseInt(req.query.period) || 30;
        const status = req.query.status || 'all';
        
        const endDate = new Date();
        const startDate = new Date();
        if (period !== 0) {
            startDate.setDate(startDate.getDate() - period);
        }
        
        let query = `
            SELECT s.*, u.email as user_email, u.name as user_name
            FROM subscriptions s
            LEFT JOIN users u ON s.user_id = u.id
            WHERE s.created_at >= ? AND s.created_at <= ?
        `;
        const params = [startDate.toISOString(), endDate.toISOString()];
        
        if (status !== 'all') {
            query += ' AND s.status = ?';
            params.push(status);
        }
        
        query += ' ORDER BY s.created_at DESC';
        
        const subscriptions = await db.all(query, params);
        
        // Gerar CSV
        const csvHeader = 'Email,Plano,Status,Valor Mensal,Início,Próxima Cobrança,Duração (dias),Total Pago\n';
        const csvRows = subscriptions.map(sub => {
            return [
                sub.user_email || '',
                sub.plan_name || '',
                sub.status || '',
                parseFloat(sub.monthly_amount || 0).toFixed(2),
                sub.created_at || '',
                sub.next_billing_date || '',
                sub.duration_days || 0,
                parseFloat(sub.total_paid || 0).toFixed(2)
            ].join(',');
        }).join('\n');
        
        const csv = csvHeader + csvRows;
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=assinaturas_${Date.now()}.csv`);
        res.send(csv);
    } catch (err) {
        console.error('Erro ao exportar assinaturas:', err);
        res.status(500).json({ message: 'Erro ao exportar assinaturas' });
    }
});

// POST /api/admin/stripe-config - Salvar configurações do Stripe
app.post('/api/admin/stripe-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { publishable_key, secret_key, webhook_secret, plans } = req.body;
        
        if (publishable_key !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['stripe_publishable_key', JSON.stringify(publishable_key)]);
        }
        
        if (secret_key !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['stripe_secret_key', JSON.stringify(secret_key)]);
        }
        
        if (webhook_secret !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['stripe_webhook_secret', JSON.stringify(webhook_secret)]);
        }
        
        if (plans && typeof plans === 'object') {
            for (const [planKey, planValue] of Object.entries(plans)) {
                if (planValue !== undefined && planValue !== null && planValue !== '') {
                    await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [`stripe_${planKey}`, JSON.stringify(planValue)]);
                }
            }
        }
        
        res.json({ message: 'Configurações do Stripe salvas com sucesso.' });
    } catch (err) {
        console.error("Erro ao salvar configurações do Stripe:", err.message);
        res.status(500).json({ message: "Erro ao salvar configurações do Stripe." });
    }
});

// Função auxiliar para obter instância do Stripe
async function getStripeInstance() {
    try {
        const secretKeyRow = await db.get("SELECT value FROM app_settings WHERE key = 'stripe_secret_key'");
        if (!secretKeyRow || !secretKeyRow.value) {
            throw new Error('Chave secreta do Stripe não configurada');
        }
        const secretKey = JSON.parse(secretKeyRow.value);
        if (!secretKey || secretKey.trim() === '') {
            throw new Error('Chave secreta do Stripe inválida');
        }
        return new Stripe(secretKey);
    } catch (error) {
        console.error('[STRIPE] Erro ao criar instância:', error.message);
        throw error;
    }
}

// GET /api/stripe/plans - Obter IDs dos planos do Stripe
app.get('/api/stripe/plans', authenticateToken, async (req, res) => {
    try {
        const planKeys = [
            'plan-free',
            'plan-start',
            'plan-turbo',
            'plan-master',
            'plan-start-annual',
            'plan-turbo-annual',
            'plan-master-annual',
            'package-1000',
            'package-2500',
            'package-5000',
            'package-10000',
            'package-20000'
        ];
        
        const plans = {};
        for (const key of planKeys) {
            const row = await db.get("SELECT value FROM app_settings WHERE key = ?", [`stripe_${key}`]);
            if (row && row.value) {
                try {
                    plans[key] = JSON.parse(row.value);
                } catch {
                    plans[key] = row.value;
                }
            }
        }
        
        res.json({ success: true, plans });
    } catch (error) {
        console.error('[STRIPE] Erro ao buscar planos:', error.message);
        res.status(500).json({ success: false, message: 'Erro ao buscar planos do Stripe' });
    }
});

// POST /api/stripe/create-checkout - Criar sessão de checkout
app.post('/api/stripe/create-checkout', authenticateToken, async (req, res) => {
    try {
        const { planKey, planType } = req.body; // planType: 'subscription' ou 'one-time'
        
        if (!planKey) {
            return res.status(400).json({ success: false, message: 'ID do plano é obrigatório' });
        }
        
        // Buscar o Price ID do Stripe
        const row = await db.get("SELECT value FROM app_settings WHERE key = ?", [`stripe_${planKey}`]);
        if (!row || !row.value) {
            return res.status(404).json({ success: false, message: 'Plano não encontrado ou não configurado no Stripe' });
        }
        
        let priceId;
        try {
            priceId = JSON.parse(row.value);
        } catch {
            priceId = row.value;
        }
        
        if (!priceId || priceId.trim() === '') {
            return res.status(404).json({ success: false, message: 'Price ID do Stripe não configurado para este plano' });
        }
        
        // Validar se é um Price ID válido (deve começar com 'price_')
        if (!priceId.startsWith('price_')) {
            return res.status(400).json({ 
                success: false, 
                message: `ID inválido para o plano ${planKey}. Você configurou "${priceId}", mas precisa usar um Price ID (que começa com "price_"). Product IDs (que começam com "prod_") não funcionam.`,
                error: 'Invalid Price ID format',
                hint: 'No Stripe, você precisa usar o Price ID (price_...), não o Product ID (prod_...). Acesse o produto no Stripe e copie o Price ID correto.'
            });
        }
        
        // Obter dados do usuário
        const userId = req.user.id;
        const userData = await db.get("SELECT email FROM users WHERE id = ?", [userId]);
        if (!userData) {
            return res.status(404).json({ success: false, message: 'Usuário não encontrado' });
        }
        
        // Mapear planKey para nome do plano (ANTES de criar URLs)
        const planNames = {
            'plan-free': 'FREE',
            'plan-start': 'START CREATOR',
            'plan-turbo': 'TURBO MAKER',
            'plan-master': 'MASTER PRO',
            'plan-start-annual': 'START CREATOR Anual',
            'plan-turbo-annual': 'TURBO MAKER Anual',
            'plan-master-annual': 'MASTER PRO Anual',
            'package-1000': 'Pacote 1.000 Créditos',
            'package-2500': 'Pacote 2.500 Créditos',
            'package-5000': 'Pacote 5.000 Créditos',
            'package-10000': 'Pacote 10.000 Créditos',
            'package-20000': 'Pacote 20.000 Créditos'
        };
        
        const planName = planNames[planKey] || planKey;
        
        // Obter instância do Stripe
        let stripe;
        try {
            stripe = await getStripeInstance();
        } catch (error) {
            console.error('[STRIPE] Erro ao obter instância do Stripe:', error.message);
            return res.status(500).json({ 
                success: false, 
                message: 'Stripe não está configurado. Configure as chaves do Stripe no painel administrativo.',
                error: error.message
            });
        }
        
        // Configurar URLs de sucesso e cancelamento
        const protocol = req.protocol;
        const host = req.get('host');
        // URL de sucesso vai para página de agradecimento com informações do plano
        const successUrl = `${protocol}://${host}/thank-you.html?session_id={CHECKOUT_SESSION_ID}&planKey=${encodeURIComponent(planKey)}&planName=${encodeURIComponent(planName)}&success=true`;
        const cancelUrl = `${protocol}://${host}/plans.html?canceled=true`;
        
        console.log(`[STRIPE] Criando checkout para plano: ${planKey}, tipo: ${planType || 'subscription'}, priceId: ${priceId}`);
        
        // Criar sessão de checkout
        const sessionParams = {
            payment_method_types: ['card'],
            customer_email: userData.email,
            metadata: {
                userId: userId.toString(),
                planKey: planKey,
                planType: planType || 'subscription'
            },
            success_url: successUrl,
            cancel_url: cancelUrl
        };
        
        // Se for assinatura recorrente
        if (planType === 'subscription' || !planType) {
            sessionParams.mode = 'subscription';
            sessionParams.line_items = [{
                price: priceId,
                quantity: 1
            }];
        } else {
            // Se for pagamento único (pacotes avulsos)
            sessionParams.mode = 'payment';
            sessionParams.line_items = [{
                price: priceId,
                quantity: 1
            }];
        }
        
        let session;
        try {
            session = await stripe.checkout.sessions.create(sessionParams);
            console.log(`[STRIPE] Sessão criada com sucesso: ${session.id}`);
        } catch (stripeError) {
            console.error('[STRIPE] Erro ao criar sessão no Stripe:', stripeError.message);
            console.error('[STRIPE] Detalhes do erro:', stripeError);
            return res.status(500).json({ 
                success: false, 
                message: `Erro ao criar sessão no Stripe: ${stripeError.message}`,
                error: stripeError.message,
                details: stripeError.type || 'unknown'
            });
        }
        
        res.json({ 
            success: true, 
            sessionId: session.id,
            url: session.url
        });
    } catch (error) {
        console.error('[STRIPE] Erro geral ao criar checkout:', error.message);
        console.error('[STRIPE] Stack trace:', error.stack);
        res.status(500).json({ 
            success: false, 
            message: 'Erro ao criar sessão de checkout',
            error: error.message
        });
    }
});

// POST /api/stripe/webhook - Webhook do Stripe (não requer autenticação)
app.post('/api/stripe/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
    const sig = req.headers['stripe-signature'];
    
    try {
        // Obter webhook secret
        const webhookSecretRow = await db.get("SELECT value FROM app_settings WHERE key = 'stripe_webhook_secret'");
        if (!webhookSecretRow || !webhookSecretRow.value) {
            console.error('[STRIPE WEBHOOK] Webhook secret não configurado');
            return res.status(400).send('Webhook secret não configurado');
        }
        
        let webhookSecret;
        try {
            webhookSecret = JSON.parse(webhookSecretRow.value);
        } catch {
            webhookSecret = webhookSecretRow.value;
        }
        
        // Obter instância do Stripe
        const stripe = await getStripeInstance();
        
        // Verificar assinatura do webhook
        const event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
        
        // Processar eventos
        if (event.type === 'checkout.session.completed') {
            const session = event.data.object;
            const userId = session.metadata?.userId;
            const planKey = session.metadata?.planKey;
            
            if (userId && planKey) {
                // Obter dados do usuário
                const userData = await db.get("SELECT name, email, credits FROM users WHERE id = ?", [userId]);
                if (!userData) {
                    console.error(`[STRIPE WEBHOOK] Usuário ${userId} não encontrado`);
                    return res.json({ received: true });
                }
                
                // Mapear planKey para nome do plano no sistema
                const planMapping = {
                    'plan-free': 'plan-free',
                    'plan-start': 'plan-start',
                    'plan-turbo': 'plan-turbo',
                    'plan-master': 'plan-master',
                    'plan-start-annual': 'plan-start-annual',
                    'plan-turbo-annual': 'plan-turbo-annual',
                    'plan-master-annual': 'plan-master-annual',
                    'package-1000': 'plan-start', // Pacotes podem adicionar créditos
                    'package-2500': 'plan-turbo',
                    'package-5000': 'plan-master',
                    'package-10000': 'plan-master',
                    'package-20000': 'plan-master'
                };
                
                const systemPlan = planMapping[planKey] || planKey;
                
                // Nomes dos planos para email
                const planNames = {
                    'plan-start': 'START CREATOR',
                    'plan-turbo': 'TURBO MAKER',
                    'plan-master': 'MASTER PRO',
                    'plan-start-annual': 'START CREATOR Anual',
                    'plan-turbo-annual': 'TURBO MAKER Anual',
                    'plan-master-annual': 'MASTER PRO Anual',
                    'package-1000': 'Pacote 1.000 Créditos',
                    'package-2500': 'Pacote 2.500 Créditos',
                    'package-5000': 'Pacote 5.000 Créditos',
                    'package-10000': 'Pacote 10.000 Créditos',
                    'package-20000': 'Pacote 20.000 Créditos'
                };
                
                const planName = planNames[planKey] || planKey;
                const amount = session.amount_total ? (session.amount_total / 100).toFixed(2) : '0.00';
                const currency = session.currency?.toUpperCase() || 'BRL';
                const paymentDate = new Date().toLocaleDateString('pt-BR');
                
                // Atualizar plano do usuário
                if (session.mode === 'subscription') {
                    // Assinatura recorrente
                    await db.run(
                        "UPDATE users SET subscription_plan = ?, plan = ? WHERE id = ?",
                        [systemPlan, systemPlan, userId]
                    );
                    
                    // Recarregar créditos baseado no plano
                    const planCreditsRow = await db.get(
                        "SELECT monthly_credits FROM plan_credits WHERE plan_name = ?",
                        [systemPlan]
                    );
                    
                    if (planCreditsRow) {
                        await db.run(
                            "UPDATE users SET credits = ? WHERE id = ?",
                            [planCreditsRow.monthly_credits, userId]
                        );
                    }
                    
                    // Calcular próxima cobrança (30 dias para mensal, 365 para anual)
                    const nextBillingDate = new Date();
                    if (planKey.includes('annual')) {
                        nextBillingDate.setFullYear(nextBillingDate.getFullYear() + 1);
                    } else {
                        nextBillingDate.setMonth(nextBillingDate.getMonth() + 1);
                    }
                    const nextBilling = nextBillingDate.toLocaleDateString('pt-BR');
                    
                    // Enviar email de assinatura (usar template específico do plano ou genérico)
                    try {
                        const templateType = `subscription_${planKey}`;
                        const template = await getEmailTemplate(templateType);
                        
                        if (template) {
                            // Template específico do plano existe
                            await sendTemplateEmail(templateType, userData.email, {
                                nome: userData.name,
                                email: userData.email,
                                plano: planName,
                                valor: `R$ ${amount}`,
                                data_pagamento: paymentDate,
                                proxima_cobranca: nextBilling,
                                creditos: planCreditsRow?.monthly_credits || 0
                            });
                        } else {
                            // Usar template genérico de pagamento
                            await sendTemplateEmail('payment', userData.email, {
                                nome: userData.name,
                                email: userData.email,
                                plano: planName,
                                valor: `R$ ${amount}`,
                                data_pagamento: paymentDate,
                                proxima_cobranca: nextBilling
                            });
                        }
                    } catch (emailError) {
                        console.error('[EMAIL] Erro ao enviar email de assinatura:', emailError.message);
                    }
                } else {
                    // Pagamento único - adicionar créditos
                    const creditAmounts = {
                        'package-1000': 1000,
                        'package-2500': 2500,
                        'package-5000': 5000,
                        'package-10000': 10000,
                        'package-20000': 20000
                    };
                    
                    const creditsToAdd = creditAmounts[planKey] || 0;
                    if (creditsToAdd > 0) {
                        await db.run(
                            "UPDATE users SET credits = credits + ? WHERE id = ?",
                            [creditsToAdd, userId]
                        );
                        
                        // Obter saldo atualizado
                        const updatedUser = await db.get("SELECT credits FROM users WHERE id = ?", [userId]);
                        
                        // Enviar email de pacote comprado
                        try {
                            await sendTemplateEmail('package', userData.email, {
                                nome: userData.name,
                                email: userData.email,
                                pacote: planName,
                                creditos: creditsToAdd,
                                valor: `R$ ${amount}`,
                                data_compra: paymentDate,
                                saldo_atual: updatedUser?.credits || 0
                            });
                        } catch (emailError) {
                            console.error('[EMAIL] Erro ao enviar email de pacote:', emailError.message);
                        }
                    }
                }
                
                console.log(`[STRIPE WEBHOOK] Usuário ${userId} atualizado para plano ${systemPlan}`);
            }
        } else if (event.type === 'customer.subscription.deleted') {
            // Assinatura cancelada
            const subscription = event.data.object;
            const customerId = subscription.customer;
            
            // Buscar usuário pelo customer_id ou metadata
            try {
                // Tentar encontrar usuário pela subscription
                const userData = await db.get(
                    "SELECT id, name, email, subscription_plan FROM users WHERE id IN (SELECT user_id FROM subscriptions WHERE stripe_subscription_id = ?)",
                    [subscription.id]
                );
                
                if (userData) {
                    // Enviar email de cancelamento
                    const cancelDate = new Date().toLocaleDateString('pt-BR');
                    const endDate = new Date();
                    endDate.setMonth(endDate.getMonth() + 1); // Acesso até fim do período pago
                    const endAccessDate = endDate.toLocaleDateString('pt-BR');
                    
                    const planNames = {
                        'plan-start': 'START CREATOR',
                        'plan-turbo': 'TURBO MAKER',
                        'plan-master': 'MASTER PRO',
                        'plan-start-annual': 'START CREATOR Anual',
                        'plan-turbo-annual': 'TURBO MAKER Anual',
                        'plan-master-annual': 'MASTER PRO Anual'
                    };
                    
                    const planName = planNames[userData.subscription_plan] || userData.subscription_plan;
                    
                    await sendTemplateEmail('cancel', userData.email, {
                        nome: userData.name,
                        email: userData.email,
                        plano: planName,
                        data_cancelamento: cancelDate,
                        data_fim_acesso: endAccessDate
                    });
                }
            } catch (emailError) {
                console.error('[EMAIL] Erro ao enviar email de cancelamento:', emailError.message);
            }
            
            console.log(`[STRIPE WEBHOOK] Assinatura ${subscription.id} cancelada`);
        }
        
        res.json({ received: true });
    } catch (err) {
        console.error('[STRIPE WEBHOOK] Erro:', err.message);
        res.status(400).send(`Webhook Error: ${err.message}`);
    }
});

// POST /api/admin/voice-api-key/validate - Validar chave de voz do admin
app.post('/api/admin/voice-api-key/validate', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API é obrigatória' });
        }
        
        // Primeiro, tentar validar como chave do Google Cloud Text-to-Speech (que é o que vamos usar)
        try {
            const ttsResponse = await fetch(`https://texttospeech.googleapis.com/v1/voices?key=${encodeURIComponent(api_key)}&languageCode=pt-BR`);
            
            if (ttsResponse.status === 200) {
                const ttsData = await ttsResponse.json();
                if (ttsData.voices && ttsData.voices.length > 0) {
                    return res.json({ 
                        success: true, 
                        message: 'Chave do Google Cloud válida! Pode ser usada para Text-to-Speech.',
                        type: 'google-cloud',
                        details: `Encontradas ${ttsData.voices.length} vozes disponíveis para português brasileiro.`
                    });
                }
            } else if (ttsResponse.status === 401 || ttsResponse.status === 403) {
                const ttsError = await ttsResponse.json().catch(() => ({}));
                // Se a mensagem menciona que a API não está habilitada, a chave é válida mas precisa habilitar a API
                if (ttsError.error?.message && ttsError.error.message.includes('API has not been used')) {
                    return res.json({ 
                        success: true, 
                        message: 'Chave do Google Cloud válida. Habilite a API Text-to-Speech no Google Cloud Console.',
                        type: 'google-cloud',
                        warning: 'A API Text-to-Speech precisa ser habilitada no Google Cloud Console para usar TTS.'
                    });
                }
                return res.status(400).json({ 
                    success: false, 
                    message: ttsError.error?.message || 'Chave inválida ou sem permissão para Text-to-Speech.',
                    error: ttsError.error?.message
                });
            } else {
                const ttsError = await ttsResponse.json().catch(() => ({}));
                // Se der erro sobre API keys não suportadas, é chave do Google Cloud (não Gemini direto)
                if (ttsError.error?.message && ttsError.error.message.includes('API keys are not supported')) {
                    return res.json({ 
                        success: true, 
                        message: 'Chave do Google Cloud detectada. Esta chave funciona para Text-to-Speech e outros serviços do Google Cloud.',
                        type: 'google-cloud',
                        warning: 'Esta chave não funciona diretamente com a API do Gemini, mas funciona perfeitamente para Text-to-Speech (TTS).'
                    });
                }
                return res.status(400).json({ 
                    success: false, 
                    message: ttsError.error?.message || 'Erro ao validar chave do Google Cloud.',
                    error: ttsError.error?.message
                });
            }
        } catch (ttsErr) {
            console.log('[Validação] Erro ao validar via TTS, tentando validação Gemini...', ttsErr.message);
        }
        
        // Fallback: tentar validação Gemini (para chaves diretas do Gemini)
        const validationResult = await validateGeminiKey(api_key);
        
        if (validationResult.success) {
            res.json({ 
                success: true, 
                message: validationResult.message || 'Chave válida!',
                type: validationResult.type || 'gemini-api',
                warning: validationResult.warning || null
            });
        } else {
            // Se falhou, mas a mensagem indica que é chave do Google Cloud, considerar válida
            if (validationResult.error && validationResult.error.includes('API keys are not supported')) {
                return res.json({ 
                    success: true, 
                    message: 'Chave do Google Cloud detectada. Esta chave funciona para Text-to-Speech.',
                    type: 'google-cloud',
                    warning: 'Esta chave não funciona diretamente com a API do Gemini, mas funciona perfeitamente para Text-to-Speech (TTS).'
                });
            }
            
            res.status(400).json({ 
                success: false, 
                message: validationResult.error || 'Chave inválida',
                error: validationResult.error
            });
        }
    } catch (error) {
        console.error('Erro ao validar chave de voz:', error);
        res.status(500).json({ success: false, message: 'Erro ao validar chave', details: error.message });
    }
});

// POST /api/admin/openai-voice/validate - Validar chave de voz OpenAI
app.post('/api/admin/openai-voice/validate', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API é obrigatória' });
        }
        
        const validationResult = await validateOpenAIKey(api_key);
        if (validationResult.success) {
            return res.json({
                success: true,
                message: 'Chave OpenAI válida!',
                type: 'openai'
            });
        }
        
        return res.status(400).json({
            success: false,
            message: validationResult.error || 'Chave inválida',
            error: validationResult.error
        });
    } catch (error) {
        console.error('Erro ao validar chave OpenAI:', error);
        res.status(500).json({ success: false, message: 'Erro ao validar chave OpenAI', details: error.message });
    }
});

// POST /api/admin/video-api/validate - Validar chave de vídeo (Gemini/Veo)
app.post('/api/admin/video-api/validate', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API é obrigatória' });
        }
        
        const validationResult = await validateGeminiKey(api_key);
        if (validationResult.success) {
            return res.json({
                success: true,
                message: validationResult.message || 'Chave Gemini válida!',
                type: validationResult.type || 'gemini'
            });
        }
        
        return res.status(400).json({
            success: false,
            message: validationResult.error || 'Chave inválida',
            error: validationResult.error
        });
    } catch (error) {
        console.error('Erro ao validar chave de vídeo:', error);
        res.status(500).json({ success: false, message: 'Erro ao validar chave de vídeo', details: error.message });
    }
});

// POST /api/admin/voice-premium/check-balance - Verificar saldo da API Voz Premium
app.post('/api/admin/voice-premium/check-balance', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ message: 'Chave de API é obrigatória' });
        }
        
        // Verificar saldo na API GenAIPro conforme documentação oficial
        // Base URL: https://genaipro.vn/api/v1
        // Endpoint: GET /me - retorna informações do usuário incluindo balance
        try {
            const response = await axios.get('https://genaipro.vn/api/v1/me', {
                headers: {
                    'Authorization': `Bearer ${api_key}`,
                    'Content-Type': 'application/json'
                },
                timeout: 15000
            });
            
            if (response && response.data) {
                console.log('[La Casa Dark Core] Resposta do endpoint /me:', JSON.stringify(response.data).substring(0, 300));
                
                // Conforme documentação: { "balance": 1000, ... }
                const balance = response.data.balance;
                
                if (balance !== null && balance !== undefined) {
                    console.log(`[La Casa Dark Core] Saldo encontrado: ${balance}`);
                    res.json({ 
                        success: true, 
                        balance: parseFloat(balance),
                        message: 'Saldo verificado com sucesso'
                    });
                    return;
                }
            }
            
            // Se não encontrou balance, retornar sucesso mas sem saldo
            res.json({ 
                success: true, 
                balance: null,
                message: 'Chave válida, mas saldo não disponível na resposta'
            });
            
        } catch (apiError) {
            console.error('[La Casa Dark Core] Erro ao verificar saldo:', apiError.message);
            if (apiError.response) {
                console.error('[La Casa Dark Core] Status:', apiError.response.status);
                console.error('[La Casa Dark Core] Data:', apiError.response.data);
                
                // Se for erro 401, a chave é inválida
                if (apiError.response.status === 401) {
                    return res.status(401).json({ 
                        success: false,
                        message: 'Chave de API inválida ou expirada',
                        balance: null
                    });
                }
            }
            
            // Outros erros - retornar erro
            res.status(500).json({ 
                success: false,
                message: `Erro ao verificar saldo: ${apiError.message}`,
                balance: null
            });
        }
    } catch (error) {
        console.error('Erro ao verificar saldo:', error);
        res.status(500).json({ 
            success: false,
            message: 'Erro ao verificar saldo', 
            details: error.message,
            balance: null
        });
    }
});

// POST /api/admin/voice-premium/save - Salvar chave da API Voz Premium
app.post('/api/admin/voice-premium/save', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key, name = 'Voz Premium' } = req.body;
        if (!api_key) {
            return res.status(400).json({ message: 'Chave de API é obrigatória' });
        }
        
        // Verificar se já existe uma API Voz Premium
        let existingApi = await db.get(`
            SELECT * FROM api_providers 
            WHERE provider = 'genaipro' OR provider = 'voice_premium'
            LIMIT 1
        `);
        
        if (existingApi) {
            // Atualizar existente
            await db.run(`
                UPDATE api_providers SET
                    api_key = ?,
                    name = ?,
                    is_active = 1,
                    is_default = 1,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            `, [api_key, name, existingApi.id]);
            
            // Desmarcar outras como padrão
            await db.run('UPDATE api_providers SET is_default = 0 WHERE id != ?', [existingApi.id]);
            
            res.json({ message: 'Chave de API Voz Premium atualizada com sucesso', id: existingApi.id });
        } else {
            // Criar nova
            const result = await db.run(`
                INSERT INTO api_providers (
                    name, provider, model, api_key, unit_type, unit_size,
                    real_cost_per_unit, credits_per_unit, markup, is_premium,
                    is_active, is_default
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                name, 'genaipro', 'voice-premium-default', api_key, 'tokens', 1000,
                0.0, 1.0, 1.0, 1, 1, 1
            ]);
            
            // Desmarcar outras como padrão
            await db.run('UPDATE api_providers SET is_default = 0 WHERE id != ?', [result.lastID]);
            
            res.json({ message: 'Chave de API Voz Premium salva com sucesso', id: result.lastID });
        }
    } catch (error) {
        console.error('Erro ao salvar chave:', error);
        res.status(500).json({ message: 'Erro ao salvar chave', details: error.message });
    }
});

// POST /api/admin/laozhang/verify - Verificar chave da API Laozhang.ai
app.post('/api/admin/laozhang/verify', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API é obrigatória' });
        }
        
        // Verificar chave fazendo uma requisição simples para a API da laozhang.ai
        // Tentamos alguns endpoints comuns para verificar a chave
        const endpointsToTry = [
            'https://api.laozhang.ai/v1/status',
            'https://api.laozhang.ai/api/status',
            'https://api.laozhang.ai/status',
            'https://api.laozhang.ai/'
        ];
        
        let lastError = null;
        
        for (const endpoint of endpointsToTry) {
            try {
                const response = await axios.get(endpoint, {
                    headers: {
                        'Authorization': `Bearer ${api_key}`,
                        'Content-Type': 'application/json'
                    },
                    timeout: 5000,
                    validateStatus: (status) => status < 500 // Não lançar erro para 4xx
                });
                
                // Se a resposta for bem-sucedida (status 200-299), a chave é válida
                if (response.status >= 200 && response.status < 300) {
                    res.json({ 
                        success: true, 
                        message: 'Chave de API válida'
                    });
                    return;
                }
                
                // Se for erro 401/403, a chave é inválida
                if (response.status === 401 || response.status === 403) {
                    res.json({ 
                        success: false, 
                        message: 'Chave de API inválida ou expirada'
                    });
                    return;
                }
                
            } catch (apiError) {
                console.error(`[La Casa Dark Core] Erro ao verificar endpoint ${endpoint}:`, apiError.message);
                lastError = apiError;
                
                // Se for erro 401/403, a chave é inválida
                if (apiError.response && (apiError.response.status === 401 || apiError.response.status === 403)) {
                    res.json({ 
                        success: false, 
                        message: 'Chave de API inválida ou expirada'
                    });
                    return;
                }
                
                // Continuar tentando outros endpoints
                continue;
            }
        }
        
        // Se chegou aqui, nenhum endpoint funcionou, mas não foi erro de autenticação
        // Vamos considerar a chave como válida (pode ser que a API não tenha endpoint de verificação)
        // O importante é que não foi rejeitada por autenticação
        res.json({ 
            success: true, 
            message: 'Chave de API aceita (não foi possível verificar endpoint, mas não há erro de autenticação)'
        });
    } catch (error) {
        console.error('Erro ao verificar chave Laozhang.ai:', error);
        res.status(500).json({ 
            success: false,
            message: 'Erro ao verificar chave', 
            details: error.message
        });
    }
});

// POST /api/admin/downsub/verify - Verificar chave da API DownSub
app.post('/api/admin/downsub/verify', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API é obrigatória' });
        }
        
        try {
            // Verificar chave fazendo uma requisição para o endpoint de status
            const response = await axios.get('https://api.downsub.com/status', {
                headers: {
                    'Authorization': `Bearer ${api_key}`,
                    'Content-Type': 'application/json'
                },
                timeout: 10000,
                validateStatus: (status) => status < 500 // Não lançar erro para 4xx
            });
            
            if (response.status === 200 && response.data && response.data.status === 'success') {
                res.json({ 
                    success: true, 
                    message: 'Chave de API válida',
                    credits: response.data.data || {}
                });
                return;
            }
            
            // Se for erro 401/403, a chave é inválida
            if (response.status === 401 || response.status === 403) {
                res.json({ 
                    success: false, 
                    message: 'Chave de API inválida ou expirada'
                });
                return;
            }
            
            // Outros erros
            res.json({ 
                success: false, 
                message: 'Erro ao verificar chave: ' + (response.data?.message || 'Erro desconhecido')
            });
        } catch (apiErr) {
            if (apiErr.response) {
                if (apiErr.response.status === 401 || apiErr.response.status === 403) {
                    res.json({ 
                        success: false, 
                        message: 'Chave de API inválida ou expirada'
                    });
                } else {
                    res.json({ 
                        success: false, 
                        message: 'Erro ao verificar chave: ' + (apiErr.response.data?.message || 'Erro desconhecido')
                    });
                }
            } else {
                throw apiErr;
            }
        }
    } catch (error) {
        console.error('[Admin] Erro ao verificar chave DownSub:', error);
        res.status(500).json({ 
            success: false,
            message: 'Erro ao verificar chave', 
            details: error.message
        });
    }
});

// POST /api/admin/downsub/save - Salvar chave da API DownSub
app.post('/api/admin/downsub/save', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ message: 'Chave de API é obrigatória' });
        }
        
        // Verificar se já existe uma API DownSub
        let existingApi = await db.get(`
            SELECT * FROM api_providers 
            WHERE provider = 'downsub'
            LIMIT 1
        `);
        
        if (existingApi) {
            // Atualizar existente
            await db.run(`
                UPDATE api_providers SET
                    api_key = ?,
                    name = 'DownSub API',
                    is_active = 1,
                    is_default = 1,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            `, [encrypt(api_key), existingApi.id]);
            
            res.json({ message: 'Chave de API DownSub atualizada com sucesso', id: existingApi.id });
        } else {
            // Criar nova
            const result = await db.run(`
                INSERT INTO api_providers (
                    name, provider, model, api_key, unit_type, unit_size,
                    real_cost_per_unit, credits_per_unit, markup, is_premium,
                    is_active, is_default
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                'DownSub API', 'downsub', 'downsub-default', encrypt(api_key), 'calls', 1,
                0.0, 1.0, 1.0, 0, 1, 1
            ]);
            
            res.json({ message: 'Chave de API DownSub salva com sucesso', id: result.lastID });
        }
    } catch (error) {
        console.error('Erro ao salvar chave DownSub:', error);
        res.status(500).json({ message: 'Erro ao salvar chave', details: error.message });
    }
});

// Função para obter transcrição usando API DownSub
async function getTranscriptFromDownSub(videoUrl, apiKey) {
    try {
        console.log('[DownSub] Tentando obter transcrição para:', videoUrl);
        
        const response = await axios.post('https://api.downsub.com/download', 
            { url: videoUrl },
            {
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                timeout: 60000 // 60 segundos
            }
        );
        
        if (response.data && response.data.status === 'success' && response.data.data) {
            const data = response.data.data;
            
            // Verificar se há legendas disponíveis
            if (data.subtitles && Array.isArray(data.subtitles) && data.subtitles.length > 0) {
                // Tentar obter legenda em português primeiro, depois inglês, depois a primeira disponível
                let selectedSubtitle = null;
                
                // Procurar português
                selectedSubtitle = data.subtitles.find(s => 
                    s.language && (s.language.toLowerCase().includes('portuguese') || 
                                   s.language.toLowerCase().includes('português') ||
                                   s.language.toLowerCase().includes('pt'))
                );
                
                // Se não encontrar português, procurar inglês
                if (!selectedSubtitle) {
                    selectedSubtitle = data.subtitles.find(s => 
                        s.language && (s.language.toLowerCase().includes('english') || 
                                       s.language.toLowerCase().includes('en'))
                    );
                }
                
                // Se não encontrar, usar a primeira disponível
                if (!selectedSubtitle) {
                    selectedSubtitle = data.subtitles[0];
                }
                
                // Tentar obter o formato TXT primeiro, depois SRT
                let transcriptUrl = null;
                if (selectedSubtitle.formats && Array.isArray(selectedSubtitle.formats)) {
                    const txtFormat = selectedSubtitle.formats.find(f => f.format === 'txt');
                    const srtFormat = selectedSubtitle.formats.find(f => f.format === 'srt');
                    
                    transcriptUrl = txtFormat ? txtFormat.url : (srtFormat ? srtFormat.url : null);
                }
                
                if (transcriptUrl) {
                    console.log('[DownSub] Baixando transcrição de:', transcriptUrl);
                    const transcriptResponse = await axios.get(transcriptUrl, {
                        timeout: 30000,
                        responseType: 'text'
                    });
                    
                    if (transcriptResponse.data) {
                        // Limpar o texto (remover timestamps se for SRT, etc)
                        let transcript = transcriptResponse.data;
                        
                        // Se for formato SRT, remover timestamps
                        if (transcript.includes('-->')) {
                            transcript = transcript
                                .replace(/\d+\n/g, '') // Remove números de sequência
                                .replace(/\d{2}:\d{2}:\d{2},\d{3} --> \d{2}:\d{2}:\d{2},\d{3}\n/g, '') // Remove timestamps
                                .replace(/\n{3,}/g, '\n\n') // Remove múltiplas linhas vazias
                                .trim();
                        }
                        
                        console.log('[DownSub] ✓ Transcrição obtida com sucesso!');
                        return transcript;
                    }
                }
            }
            
            throw new Error('Nenhuma legenda disponível para este vídeo');
        } else {
            throw new Error('Resposta inválida da API DownSub');
        }
    } catch (error) {
        if (error.response) {
            if (error.response.status === 401 || error.response.status === 403) {
                throw new Error('Chave de API DownSub inválida ou expirada');
            } else if (error.response.status === 403) {
                throw new Error('Limite de créditos da API DownSub excedido');
            } else if (error.response.status === 404) {
                throw new Error('Vídeo não encontrado ou sem legendas disponíveis');
            } else {
                throw new Error(`Erro da API DownSub: ${error.response.status} - ${error.response.data?.message || 'Erro desconhecido'}`);
            }
        } else if (error.request) {
            throw new Error('Erro de conexão com a API DownSub');
        } else {
            throw error;
        }
    }
}

// ================================================
// ROTAS DO SISTEMA DE TTS (TEXT-TO-SPEECH)
// ================================================

// GET /api/tts/voices - Lista vozes disponíveis (Voz Premium)
app.get('/api/tts/voices', authenticateToken, async (req, res) => {
    try {
        const { provider = 'laozhang' } = req.query;
        
        console.log(`[TTS Voices] Requisição recebida - Provider: "${provider}"`);
        
        // Se provider for voice_premium ou genaipro, SEMPRE buscar vozes premium
        if (provider === 'voice_premium' || provider === 'genaipro') {
            console.log('[TTS Voices] Buscando vozes premium...');
            // Buscar API key do Voz Premium do usuário ou admin
            const userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'genaipro']);
            
            let apiKey = null;
            if (userApiKey) {
                // Descriptografar a chave
                apiKey = decrypt(userApiKey.api_key);
                if (!apiKey) {
                    console.error('[La Casa Dark Core] Erro ao descriptografar chave do usuário');
                }
            }
            
            // Se não tem chave do usuário ou falhou ao descriptografar, tentar usar API do admin
            if (!apiKey) {
                // Buscar especificamente a API Voz Premium do admin (não a API padrão genérica)
                const adminVoicePremiumApi = await db.get(`
                    SELECT * FROM api_providers 
                    WHERE (provider = 'genaipro' OR provider = 'voice_premium')
                    AND is_active = 1
                    LIMIT 1
                `);
                
                console.log('[La Casa Dark Core] Buscando API Voz Premium do admin:', adminVoicePremiumApi ? 'Encontrada' : 'Não encontrada');
                
                if (adminVoicePremiumApi && adminVoicePremiumApi.api_key) {
                    // Tentar descriptografar a chave do admin
                    // Se a chave contém ':' provavelmente está criptografada
                    if (adminVoicePremiumApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminVoicePremiumApi.api_key);
                        } catch (decryptError) {
                            console.warn('[La Casa Dark Core] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                            // Se falhar, tentar usar diretamente (pode não estar criptografada)
                            apiKey = adminVoicePremiumApi.api_key;
                        }
                    } else {
                        // Chave não parece estar criptografada, usar diretamente
                        apiKey = adminVoicePremiumApi.api_key;
                    }
                    console.log('[La Casa Dark Core] Usando API Voz Premium do admin');
                }
            }
            
            if (!apiKey) {
                console.error('[La Casa Dark Core] Nenhuma chave de API Voz Premium encontrada (nem do usuário nem do admin)');
                return res.status(400).json({ message: 'Chave de API Voz Premium não configurada. Configure no painel admin ou nas suas configurações.' });
            }
            
            console.log('[La Casa Dark Core] Buscando vozes com chave de API disponível');
            
            // Buscar vozes de AMBOS os endpoints (Max e Labs) e indicar status
            // Base URL: https://genaipro.vn/api/v1
            try {
                let allVoices = [];
                let maxStatus = 'online'; // Status do serviço Max
                let labsStatus = 'online'; // Status do serviço Labs
                
                // ============================================
                // BUSCAR VOZES LABS (ElevenLabs) - Geralmente mais estáveis
                // ============================================
                console.log('[La Casa Dark Core] Buscando vozes Labs...');
                
                // Primeiro, verificar se o serviço de TTS Labs está disponível
                try {
                    console.log('[La Casa Dark Core] Verificando status do serviço Labs TTS...');
                    const labsTtsCheck = await axios.post('https://genaipro.vn/api/v1/labs/task', 
                        { input: 'test', voice_id: 'test' },
                        {
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            timeout: 10000,
                            validateStatus: (status) => true
                        }
                    );
                    
                    // Se retornar 503 ou HTML de manutenção, marcar como em manutenção
                    if (labsTtsCheck.status === 503) {
                        labsStatus = 'maintenance';
                        console.log('[La Casa Dark Core] ⚠️ Serviço Labs TTS em manutenção (503)');
                    } else if (typeof labsTtsCheck.data === 'string' && 
                              (labsTtsCheck.data.includes('Maintenance') || labsTtsCheck.data.includes('Bảo Trì') || labsTtsCheck.data.includes('<!DOCTYPE'))) {
                        labsStatus = 'maintenance';
                        console.log('[La Casa Dark Core] ⚠️ Serviço Labs TTS em manutenção (HTML)');
                    } else {
                        console.log('[La Casa Dark Core] ✅ Serviço Labs TTS disponível (status:', labsTtsCheck.status, ')');
                    }
                } catch (labsCheckError) {
                    console.log('[La Casa Dark Core] Erro ao verificar status Labs:', labsCheckError.message);
                }
                
                try {
                    // Buscar TODAS as vozes Labs (sem filtro de idioma restritivo)
                    const labsResponse = await axios.get('https://genaipro.vn/api/v1/labs/voices', {
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        params: {
                            page: 1,
                            page_size: 100
                            // Removido filtro de idioma para buscar todas as vozes
                        },
                        timeout: 15000,
                        validateStatus: (status) => true
                    });
                    
                    console.log('[La Casa Dark Core] Labs voices response status:', labsResponse.status);
                    if (labsResponse.data) {
                        console.log('[La Casa Dark Core] Labs voices data keys:', Object.keys(labsResponse.data));
                    }
                    
                    // Verificar se está em manutenção
                    if (labsResponse.status === 503) {
                        const responseText = typeof labsResponse.data === 'string' ? labsResponse.data : '';
                        if (responseText.includes('Maintenance') || responseText.includes('Bảo Trì')) {
                            labsStatus = 'maintenance';
                            console.log('[La Casa Dark Core] ⚠️ Serviço Labs em manutenção');
                        }
                    } else if (labsResponse.status === 200 && labsResponse.data) {
                        console.log('[La Casa Dark Core] Labs data sample:', JSON.stringify(labsResponse.data).substring(0, 500));
                        
                        // Tentar diferentes formatos de resposta
                        let voiceList = [];
                        if (labsResponse.data.voices) {
                            voiceList = labsResponse.data.voices;
                            console.log('[La Casa Dark Core] Labs usando campo "voices"');
                        } else if (labsResponse.data.voice_list) {
                            voiceList = labsResponse.data.voice_list;
                            console.log('[La Casa Dark Core] Labs usando campo "voice_list"');
                        } else if (labsResponse.data.data) {
                            voiceList = labsResponse.data.data;
                            console.log('[La Casa Dark Core] Labs usando campo "data"');
                        } else if (Array.isArray(labsResponse.data)) {
                            voiceList = labsResponse.data;
                            console.log('[La Casa Dark Core] Labs resposta é array direto');
                        }
                        
                        if (Array.isArray(voiceList) && voiceList.length > 0) {
                            console.log(`[La Casa Dark Core] Labs: ${voiceList.length} vozes encontradas`);
                            
                            const labsVoices = voiceList.map(voice => {
                                let friendlyName = voice.name || 'Voz Labs';
                                
                                if (voice.labels) {
                                    const gender = voice.labels.gender || '';
                                    const description = voice.labels.description || '';
                                    
                                    if (gender) {
                                        const genderPt = gender === 'male' ? 'Masculina' : gender === 'female' ? 'Feminina' : '';
                                        if (genderPt) {
                                            friendlyName = `Voz ${genderPt}`;
                                            if (description) {
                                                friendlyName += ` - ${description}`;
                                            }
                                        }
                                    }
                                }
                                
                                return {
                                    id: voice.voice_id || voice.id || voice.name,
                                    name: voice.voice_id || voice.id || voice.name,
                                    label: `✅ ${friendlyName}`, // Indicar que está online
                                    language: voice.labels?.accent || 'pt-BR',
                                    gender: voice.labels?.gender || null,
                                    description: voice.labels?.description || null,
                                    category: voice.category,
                                    original_name: voice.name,
                                    api_type: 'labs',
                                    status: 'online'
                                };
                            });
                            
                            allVoices.push(...labsVoices);
                        }
                    }
                } catch (labsError) {
                    console.log('[La Casa Dark Core] Erro ao buscar vozes Labs:', labsError.message);
                    labsStatus = 'error';
                }
                
                // ============================================
                // BUSCAR VOZES MAX - Melhor para português
                // ============================================
                console.log('[La Casa Dark Core] Buscando vozes Max...');
                
                // Primeiro, verificar se o serviço de TTS Max está disponível
                try {
                    console.log('[La Casa Dark Core] Verificando status do serviço Max TTS...');
                    const maxTtsCheck = await axios.post('https://genaipro.vn/api/v1/max/tasks', 
                        { text: 'test', voice_id: 'test' },
                        {
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            timeout: 10000,
                            validateStatus: (status) => true
                        }
                    );
                    
                    // Se retornar 503 ou HTML de manutenção, marcar como em manutenção
                    if (maxTtsCheck.status === 503) {
                        maxStatus = 'maintenance';
                        console.log('[La Casa Dark Core] ⚠️ Serviço Max TTS em manutenção (503)');
                    } else if (typeof maxTtsCheck.data === 'string' && 
                              (maxTtsCheck.data.includes('Maintenance') || maxTtsCheck.data.includes('Bảo Trì') || maxTtsCheck.data.includes('<!DOCTYPE'))) {
                        maxStatus = 'maintenance';
                        console.log('[La Casa Dark Core] ⚠️ Serviço Max TTS em manutenção (HTML)');
                    } else {
                        console.log('[La Casa Dark Core] ✅ Serviço Max TTS disponível');
                    }
                } catch (maxCheckError) {
                    console.log('[La Casa Dark Core] Erro ao verificar status Max:', maxCheckError.message);
                }
                
                try {
                    const maxResponse = await axios.get('https://genaipro.vn/api/v1/max/voices', {
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        params: {
                            page: 1,
                            page_size: 100,
                            language: 'Portuguese'
                        },
                        timeout: 15000,
                        validateStatus: (status) => true
                    });
                    
                    // Verificar se está em manutenção
                    if (maxResponse.status === 503) {
                        const responseText = typeof maxResponse.data === 'string' ? maxResponse.data : '';
                        if (responseText.includes('Maintenance') || responseText.includes('Bảo Trì')) {
                            maxStatus = 'maintenance';
                            console.log('[La Casa Dark Core] ⚠️ Serviço Max em manutenção');
                        }
                    } else if (maxResponse.status === 200 && maxResponse.data) {
                        const voiceList = maxResponse.data.voice_list || maxResponse.data.voices || maxResponse.data.data || [];
                        
                        if (Array.isArray(voiceList) && voiceList.length > 0) {
                            console.log(`[La Casa Dark Core] Max: ${voiceList.length} vozes encontradas`);
                            
                            const maxVoices = voiceList.map(voice => {
                                let friendlyName = voice.voice_name || voice.name || 'Voz Max';
                                
                                const tagList = voice.tag_list || voice.tags || [];
                                const gender = tagList.find(tag => tag === 'Male' || tag === 'Female') || '';
                                const age = tagList.find(tag => ['Youth', 'Young Adult', 'Adult', 'Middle Aged', 'Senior'].includes(tag)) || '';
                                
                                if (gender && age) {
                                    const genderPt = gender === 'Male' ? 'Masculina' : 'Feminina';
                                    const agePt = age === 'Youth' ? 'Jovem' : 
                                                 age === 'Young Adult' ? 'Jovem Adulta' :
                                                 age === 'Adult' ? 'Adulto' :
                                                 age === 'Middle Aged' ? 'Meia Idade' : 'Sênior';
                                    friendlyName = `Voz ${genderPt} ${agePt}`;
                                } else if (gender) {
                                    const genderPt = gender === 'Male' ? 'Masculina' : 'Feminina';
                                    friendlyName = `Voz ${genderPt}`;
                                }
                                
                                // Indicador de status no label
                                const statusIndicator = maxStatus === 'maintenance' ? '🔧 ' : '✅ ';
                                const statusSuffix = maxStatus === 'maintenance' ? ' (Manutenção)' : '';
                                
                                return {
                                    id: voice.voice_id || voice.id || voice.voice_name || voice.name,
                                    name: voice.voice_id || voice.id || voice.voice_name || voice.name,
                                    label: `${statusIndicator}${friendlyName}${statusSuffix}`,
                                    language: 'Portuguese',
                                    gender: gender || null,
                                    description: voice.description || null,
                                    tags: tagList,
                                    original_name: voice.voice_name || voice.name,
                                    api_type: 'max',
                                    status: maxStatus
                                };
                            });
                            
                            allVoices.push(...maxVoices);
                        }
                    }
                } catch (maxError) {
                    console.log('[La Casa Dark Core] Erro ao buscar vozes Max:', maxError.message);
                    maxStatus = 'error';
                }
                
                // Ordenar vozes: online primeiro, depois manutenção
                allVoices.sort((a, b) => {
                    if (a.status === 'online' && b.status !== 'online') return -1;
                    if (a.status !== 'online' && b.status === 'online') return 1;
                    return 0;
                });
                
                if (allVoices.length > 0) {
                    const onlineCount = allVoices.filter(v => v.status === 'online').length;
                    const maintenanceCount = allVoices.filter(v => v.status === 'maintenance').length;
                    
                    console.log(`[La Casa Dark Core] ✅ Total: ${allVoices.length} vozes (${onlineCount} online, ${maintenanceCount} em manutenção)`);
                    
                    return res.json({ 
                        data: allVoices,
                        provider: 'voice_premium',
                        message: `${allVoices.length} vozes disponíveis (${onlineCount} online${maintenanceCount > 0 ? `, ${maintenanceCount} em manutenção` : ''})`,
                        status: {
                            labs: labsStatus,
                            max: maxStatus
                        }
                    });
                } else {
                    console.warn('[La Casa Dark Core] ⚠️ Nenhuma voz encontrada');
                    return res.status(404).json({ 
                        message: 'Nenhuma voz encontrada. Verifique se sua chave de API tem acesso às vozes premium.',
                        data: [],
                        status: {
                            labs: labsStatus,
                            max: maxStatus
                        }
                    });
                }
            } catch (apiError) {
                console.error('[La Casa Dark Core] Erro ao buscar vozes:', apiError.message);
                if (apiError.response) {
                    console.error('[La Casa Dark Core] Status:', apiError.response.status);
                    console.error('[La Casa Dark Core] Data:', JSON.stringify(apiError.response.data).substring(0, 500));
                    
                    if (apiError.response.status === 401 || apiError.response.status === 403) {
                        return res.status(401).json({ 
                            message: 'Chave de API inválida ou expirada. Verifique suas configurações.',
                            data: []
                        });
                    }
                }
                return res.status(500).json({ 
                    message: `Erro ao buscar vozes: ${apiError.message}`,
                    data: []
                });
            }
        }
        
        // Verificar preferência do usuário
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // Se provider for laozhang ou se useCredits estiver marcado, retornar vozes DarkVoz
        if (provider === 'laozhang' || useCredits) {
            console.log('[TTS Voices] Retornando vozes DarkVoz');
            
            // Verificar se tem chave de API configurada
            const laozhangKey = await getLaozhangApiKey();
            if (!laozhangKey) {
                return res.status(400).json({ 
                    message: 'Chave de API DarkVoz não configurada. Configure no painel admin.' 
                });
            }
            
            // Retornar todas as vozes disponíveis do DarkVoz
            const laozhangVoices = [
                {
                    id: 'alloy',
                    name: 'alloy',
                    voice_id: 'alloy',
                    label: 'Alloy - Neutra, clara e natural',
                    description: 'Voz neutra, clara e natural',
                    gender: 'neutral',
                    language: 'pt-BR'
                },
                {
                    id: 'echo',
                    name: 'echo',
                    voice_id: 'echo',
                    label: 'Echo - Masculina, firme e forte',
                    description: 'Voz masculina, firme e forte',
                    gender: 'male',
                    language: 'pt-BR'
                },
                {
                    id: 'fable',
                    name: 'fable',
                    voice_id: 'fable',
                    label: 'Fable - Sotaque britânico, elegante',
                    description: 'Voz com sotaque britânico, elegante',
                    gender: 'neutral',
                    language: 'en-GB'
                },
                {
                    id: 'onyx',
                    name: 'onyx',
                    voice_id: 'onyx',
                    label: 'Onyx - Masculina profunda, notícias/transmissão',
                    description: 'Voz masculina profunda, ideal para notícias e transmissão',
                    gender: 'male',
                    language: 'pt-BR'
                },
                {
                    id: 'nova',
                    name: 'nova',
                    voice_id: 'nova',
                    label: 'Nova - Feminina, calorosa e amigável',
                    description: 'Voz feminina, calorosa e amigável',
                    gender: 'female',
                    language: 'pt-BR'
                },
                {
                    id: 'shimmer',
                    name: 'shimmer',
                    voice_id: 'shimmer',
                    label: 'Shimmer - Feminina suave, narração',
                    description: 'Voz feminina suave, ideal para narração',
                    gender: 'female',
                    language: 'pt-BR'
                }
            ];
            
            return res.status(200).json({ 
                data: laozhangVoices,
                provider: 'darkvoz',
                message: `${laozhangVoices.length} vozes disponíveis`
            });
        }
        
        // Chave configurada no painel admin (sempre priorizar se existir)
        const adminVoiceApiKey = await getAdminVoiceApiKey();
        if (provider === 'gemini' && adminVoiceApiKey && adminVoiceApiKey.trim().length >= 10) {
            apiKey = adminVoiceApiKey.trim();
            console.log('[TTS Generate] ✅ Usando chave de voz configurada no painel admin (Google Cloud/Gemini)');
        }
        
        if (provider === 'gemini') {
            // Vozes Gemini (hardcoded conforme voices.js)
            const geminiVoices = [
                { name: "Zephyr", label: "Brisa - Voz Brilhante", lang: "pt-BR" },
                { name: "Puck", label: "Vibe - Voz Animada", lang: "pt-BR" },
                { name: "Charon", label: "Dorio - Voz Informativa", lang: "pt-BR" },
                { name: "Kore", label: "Livia - Voz Firme", lang: "pt-BR" },
                { name: "Fenrir", label: "Rafael - Voz Excitada", lang: "pt-BR" },
                { name: "Leda", label: "Clara - Voz Juvenil", lang: "pt-BR" },
                { name: "Orus", label: "Icaro - Voz Firme", lang: "pt-BR" },
                { name: "Aoede", label: "Marina - Voz Arejada", lang: "pt-BR" },
                { name: "Callirrhoe", label: "Nina - Voz Descontraida", lang: "pt-BR" },
                { name: "Autonoe", label: "Bia - Voz Brilhante", lang: "pt-BR" },
                { name: "Enceladus", label: "Dandara - Voz Sussurrada", lang: "pt-BR" },
                { name: "Iapetus", label: "Vitor - Voz Clara", lang: "pt-BR" },
                { name: "Umbriel", label: "Otavio - Voz Descontraida", lang: "pt-BR" },
                { name: "Algieba", label: "Joao - Voz Suave", lang: "pt-BR" },
                { name: "Despina", label: "Luna - Voz Suave", lang: "pt-BR" },
                { name: "Erinome", label: "Paula - Voz Clara", lang: "pt-BR" },
                { name: "Algenib", label: "Gustavo - Voz Grave", lang: "pt-BR" },
                { name: "Rasalgethi", label: "Henrique - Voz Informativa", lang: "pt-BR" },
                { name: "Laomedeia", label: "Taina - Voz Animada", lang: "pt-BR" },
                { name: "Achernar", label: "Noa - Voz Suave", lang: "pt-BR" },
                { name: "Alnilam", label: "Edu - Voz Firme", lang: "pt-BR" },
                { name: "Schedar", label: "Rafa - Voz Constante", lang: "pt-BR" },
                { name: "Gacrux", label: "Sergio - Voz Madura", lang: "pt-BR" },
                { name: "Pulcherrima", label: "Helena - Voz Projetada", lang: "pt-BR" },
                { name: "Achird", label: "Mia - Voz Amigavel", lang: "pt-BR" },
                { name: "Zubenelgenubi", label: "Teo - Voz Casual", lang: "pt-BR" },
                { name: "Vindemiatrix", label: "Erica - Voz Gentil", lang: "pt-BR" },
                { name: "Sadachbia", label: "Duda - Voz Vivaz", lang: "pt-BR" },
                { name: "Sadaltager", label: "Marcelo - Voz Conhecedora", lang: "pt-BR" },
                { name: "Sulafat", label: "Isis - Voz Acolhedora", lang: "pt-BR" }
            ];
            res.json({ data: geminiVoices });
        } else if (provider === 'laozhang') {
            const laozhangVoices = [
                { name: 'alloy', label: 'Alloy - Neutro e claro', lang: 'pt-BR' },
                { name: 'echo', label: 'Echo - Masculino forte', lang: 'pt-BR' },
                { name: 'fable', label: 'Fable - Inglês elegante', lang: 'en-US' },
                { name: 'onyx', label: 'Onyx - Grave jornalístico', lang: 'pt-BR' },
                { name: 'nova', label: 'Nova - Feminino acolhedor', lang: 'pt-BR' },
                { name: 'shimmer', label: 'Shimmer - Feminino suave', lang: 'pt-BR' }
            ];
            res.json({ data: laozhangVoices });
        } else {
            res.json({ data: [] });
        }
    } catch (error) {
        console.error('Erro ao listar vozes:', error);
        res.status(500).json({ message: 'Erro ao listar vozes' });
    }
});

// POST /api/tts/preview - Gera preview de voz
app.post('/api/tts/preview', authenticateToken, async (req, res) => {
    const { voice, model, provider = 'laozhang' } = req.body || {};
    const previewVoice = typeof voice === 'string' && voice.trim() ? voice.trim() : FALLBACK_TTS_VOICE;
    const previewText = DEFAULT_TTS_SAMPLE_TEXT; // Remover prefixo "Narrador:"
    const validatedModel = validateTtsModel(model);
    
    // Declarar actualProvider fora do try para estar disponível no catch
    let actualProvider = provider;

    try {
        // Verificar se tem API própria ou usar API do admin (com créditos)
        let apiKey = null;
        let useAdminApi = false;
        let adminApi = null;
        
        // Verificar preferência do usuário
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // IMPORTANTE: Se o provider é voice_premium/genaipro, SEMPRE usar a API GenAIPro, não laozhang
        // A lógica useCredits só se aplica a outros providers
        
        // Se useCredits estiver marcado E o provider NÃO é voice_premium, usar laozhang.ai
        if (useCredits && provider !== 'voice_premium' && provider !== 'genaipro') {
            console.log(`[TTS Preview] useCredits marcado (provider: ${provider}), usando DarkVoz`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Chave do DarkVoz não configurada. Configure no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            actualProvider = 'laozhang';
            console.log('[TTS Preview] ✅ Usando API DarkVoz (useCredits marcado)');
        } else if (provider === 'laozhang') {
            console.log(`[TTS Preview] Provider: laozhang, Voice: ${previewVoice}`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Configure a chave do DarkVoz no painel admin para usar este provedor.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            actualProvider = 'laozhang';
            console.log('[TTS Preview] ✅ Usando API DarkVoz (Laozhang.ai) do painel admin');
        } else if (provider === 'gemini') {
            // Chave configurada no painel admin (sempre priorizar se existir)
            const adminVoiceApiKey = await getAdminVoiceApiKey();
            if (adminVoiceApiKey && adminVoiceApiKey.trim().length >= 10) {
                apiKey = adminVoiceApiKey.trim();
                console.log('[TTS Preview] ✅ Usando chave de voz configurada no painel admin (Google Cloud/Gemini)');
            }
            console.log(`[TTS Preview] Provider: gemini, Voice: ${previewVoice}`);
            
            // PRIORIDADE 2: Se não houver chave do admin, buscar API do Gemini do usuário
            if (!apiKey && !useCredits) {
                let userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'gemini']);
                console.log('[TTS Preview] DEBUG - Gemini API do usuário encontrada:', !!userApiKey);
                
                if (userApiKey && userApiKey.api_key) {
                    // Descriptografar a chave do Gemini
                    if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(userApiKey.api_key);
                            console.log('[TTS Preview] Chave Gemini descriptografada (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                        } catch (decryptError) {
                            console.warn('[TTS Preview] Erro ao descriptografar chave Gemini, tentando usar diretamente:', decryptError.message);
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        apiKey = userApiKey.api_key;
                        console.log('[TTS Preview] Chave Gemini usada diretamente (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                    }
                    
                    // Validar se a chave não está vazia
                    if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                        console.warn('[TTS Preview] ⚠️ Chave Gemini está vazia, tentando API do admin');
                        apiKey = null;
                    } else {
                        console.log('[TTS Preview] ✅ Usando API Gemini do usuário');
                    }
                }
            }
            
            // Se não conseguiu usar API própria, tentar admin como fallback
            if (!apiKey) {
                console.log('[TTS Preview] Tentando usar API do admin como fallback para Gemini...');
                adminApi = await getDefaultAdminApi();
                console.log('[TTS Preview] Admin API encontrada:', adminApi ? `${adminApi.provider} - ${adminApi.name}` : 'Nenhuma');
                if (adminApi && adminApi.provider === 'gemini' && adminApi.api_key) {
                    // Descriptografar se necessário
                    if (adminApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminApi.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Preview] Erro ao descriptografar chave Gemini do admin, tentando usar diretamente:', decryptError.message);
                            apiKey = adminApi.api_key;
                        }
                    } else {
                        apiKey = adminApi.api_key;
                    }
                    
                    if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                        console.error('[TTS Preview] ❌ Chave Gemini do admin está vazia');
                        apiKey = null;
                    } else {
                        useAdminApi = true;
                        console.log('[TTS Preview] ✅ Usando API Gemini do admin com créditos');
                    }
                } else {
                    console.warn('[TTS Preview] ⚠️ Admin API não encontrada ou não é Gemini');
                }
                
                if (!apiKey) {
                    console.error('[TTS Preview] ❌ Nenhuma API Gemini disponível');
                    return res.status(400).json({ message: 'Configure uma chave de voz (Google Cloud/Gemini) no painel admin ou use créditos.' });
                }
            }
        } else if (provider === 'voice_premium' || provider === 'genaipro') {
            console.log(`[TTS Preview] Provider: ${provider}, Voice: ${previewVoice}`);
            
            // Buscar API do usuário - tentar tanto 'genaipro' quanto 'voice_premium'
            let userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'genaipro']);
            if (!userApiKey || !userApiKey.api_key) {
                // Tentar buscar como 'voice_premium' se não encontrou como 'genaipro'
                userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'voice_premium']);
                if (userApiKey) {
                    console.log('[TTS Preview] API encontrada como voice_premium');
                }
            } else {
                console.log('[TTS Preview] API encontrada como genaipro');
            }
            
            console.log('[TTS Preview] DEBUG - userApiKey encontrada:', !!userApiKey);
            console.log('[TTS Preview] DEBUG - userApiKey.api_key existe:', !!(userApiKey && userApiKey.api_key));
            if (userApiKey && userApiKey.api_key) {
                console.log('[TTS Preview] DEBUG - userApiKey.api_key tamanho:', userApiKey.api_key.length);
                console.log('[TTS Preview] DEBUG - userApiKey.api_key preview:', userApiKey.api_key.substring(0, 20) + '...');
            }
            
            if (useCredits) {
                // Usuário prefere usar créditos - buscar especificamente a API Voz Premium do admin
                // NÃO usar getDefaultAdminApi() pois pode retornar outra API
                adminApi = await db.get(`
                    SELECT * FROM api_providers 
                    WHERE (provider = 'genaipro' OR provider = 'voice_premium')
                    AND is_active = 1
                    LIMIT 1
                `);
                console.log('[TTS Preview] Buscando API Voz Premium do admin:', adminApi ? 'Encontrada' : 'Não encontrada');
                
                if (adminApi && adminApi.api_key) {
                    // Tentar descriptografar a chave do admin
                    if (adminApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminApi.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Preview] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                            apiKey = adminApi.api_key;
                        }
                    } else {
                        apiKey = adminApi.api_key;
                    }
                    useAdminApi = true;
                    actualProvider = 'voice_premium'; // Garantir que o provider seja correto
                    console.log('[TTS Preview] ✅ Usando API Voz Premium do admin');
                } else {
                    // Fallback: usar API própria se disponível
                    if (userApiKey && userApiKey.api_key) {
                        console.log('[TTS Preview] Fallback: tentando usar API própria do usuário...');
                        // Descriptografar a chave do usuário
                        if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                            try {
                                apiKey = decrypt(userApiKey.api_key);
                                console.log('[TTS Preview] Chave descriptografada (tamanho:', apiKey ? apiKey.length : 0, ')');
                            } catch (decryptError) {
                                console.warn('[TTS Preview] Erro ao descriptografar chave do usuário, tentando usar diretamente:', decryptError.message);
                                apiKey = userApiKey.api_key;
                            }
                        } else {
                            apiKey = userApiKey.api_key;
                            console.log('[TTS Preview] Chave usada diretamente (não criptografada, tamanho:', apiKey ? apiKey.length : 0, ')');
                        }
                        
                        // Validar se a chave não está vazia
                        if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                            console.error('[TTS Preview] Chave do usuário está vazia ou muito curta após descriptografar');
                            return res.status(400).json({ message: 'A chave da API Voz Premium configurada está vazia ou inválida. Verifique suas configurações.' });
                        }
                        
                        actualProvider = 'voice_premium'; // Garantir provider correto
                        console.log('[TTS Preview] ✅ Fallback: usando API própria (admin API não disponível)');
                    } else {
                        console.error('[TTS Preview] ❌ API própria não encontrada e admin API Voz Premium não disponível');
                        return res.status(400).json({ message: 'Configure uma chave da API Voz Premium no painel admin ou nas suas configurações.' });
                    }
                }
            } else {
                // Usuário prefere usar API própria quando disponível
                console.log('[TTS Preview] Verificando API própria do usuário (preferência: não usar créditos)');
                console.log('[TTS Preview] - userApiKey encontrada:', !!userApiKey);
                console.log('[TTS Preview] - userApiKey.api_key existe:', !!(userApiKey && userApiKey.api_key));
                
                if (userApiKey && userApiKey.api_key) {
                    // Descriptografar a chave do usuário
                    if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(userApiKey.api_key);
                            console.log('[TTS Preview] Chave descriptografada com sucesso (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                        } catch (decryptError) {
                            console.warn('[TTS Preview] Erro ao descriptografar chave do usuário, tentando usar diretamente:', decryptError.message);
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        apiKey = userApiKey.api_key;
                        console.log('[TTS Preview] Chave usada diretamente (não criptografada, tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                    }
                    
                    // Validar se a chave não está vazia após descriptografar
                    if (!apiKey || apiKey.trim() === '') {
                        console.warn('[TTS Preview] ⚠️ Chave do usuário está vazia após descriptografar, tentando API do admin');
                        apiKey = null; // Resetar para tentar admin
                    } else {
                        console.log('[TTS Preview] ✅ API key do usuário encontrada e válida (tamanho:', apiKey.length, 'caracteres)');
                    }
                } else {
                    console.log('[TTS Preview] ⚠️ API própria do usuário não encontrada ou vazia');
                }
                
                // Se não conseguiu usar API própria, tentar admin como fallback
                if (!apiKey) {
                    console.log('[TTS Preview] Tentando usar API Voz Premium do admin como fallback...');
                    // Buscar especificamente a API Voz Premium do admin
                    adminApi = await db.get(`
                        SELECT * FROM api_providers 
                        WHERE (provider = 'genaipro' OR provider = 'voice_premium')
                        AND is_active = 1
                        LIMIT 1
                    `);
                    console.log('[TTS Preview] Admin API Voz Premium encontrada:', adminApi ? 'Sim' : 'Não');
                    
                    if (adminApi && adminApi.api_key) {
                        // Tentar descriptografar a chave do admin
                        if (adminApi.api_key.includes(':')) {
                            try {
                                apiKey = decrypt(adminApi.api_key);
                                console.log('[TTS Preview] Chave do admin descriptografada (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                            } catch (decryptError) {
                                console.warn('[TTS Preview] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                                apiKey = adminApi.api_key;
                            }
                        } else {
                            apiKey = adminApi.api_key;
                            console.log('[TTS Preview] Chave do admin usada diretamente (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                        }
                        
                        // Validar se a chave não está vazia
                        if (!apiKey || apiKey.trim() === '') {
                            console.error('[TTS Preview] ❌ Chave do admin está vazia após descriptografar');
                            apiKey = null;
                        } else {
                            useAdminApi = true;
                            actualProvider = 'voice_premium'; // Garantir provider correto
                            console.log('[TTS Preview] ✅ Usando API Voz Premium do admin (fallback)');
                        }
                    } else {
                        console.warn('[TTS Preview] ⚠️ Admin API Voz Premium não encontrada');
                    }
                    
                    if (!apiKey) {
                        console.error('[TTS Preview] ❌ Nenhuma API Voz Premium disponível');
                        return res.status(400).json({ message: 'Configure uma chave da API Voz Premium no painel admin ou nas suas configurações.' });
                    }
                } else {
                    actualProvider = 'voice_premium'; // Garantir provider correto quando usando API do usuário
                }
            }
        } else if (provider === 'openai') {
            // Verificar preferência do usuário
            const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
            const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
            
            const userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'openai']);
            const adminOpenAiKey = await getAdminOpenAiVoiceApiKey();
            
            if (adminOpenAiKey) {
                apiKey = adminOpenAiKey;
                console.log('[TTS Preview] ✅ Usando chave de voz OpenAI do painel admin');
            }
            
            if (!apiKey && useCredits) {
                // Usuário prefere usar créditos mesmo tendo API própria
                adminApi = await getDefaultAdminApi();
                if (adminApi && adminApi.provider === 'openai') {
                    apiKey = adminApi.api_key;
                    useAdminApi = true;
                } else {
                    // Fallback: usar API própria se disponível
                    if (userApiKey) {
                        apiKey = userApiKey.api_key;
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API OpenAI ou use créditos.' });
                    }
                }
            }
        } else if (provider === 'laozhang') {
            console.log(`[TTS Preview] Provider: laozhang, Voice: ${previewVoice}`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Configure a chave do provedor externo no painel admin para usar este provedor.' });
            }
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (!laozhangProviderId) {
                return res.status(400).json({ message: 'Provedor externo não está ativo no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            adminApi = { id: laozhangProviderId, provider: 'laozhang' };
            actualProvider = 'laozhang';
        }
        
        // Validação final: verificar se apiKey não está vazia e tem formato válido
        if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
            console.error('[TTS Preview] ❌ API Key está vazia, inválida ou muito curta após todo o processamento');
            console.error('[TTS Preview] - Provider:', provider);
            console.error('[TTS Preview] - User ID:', req.user.id);
            const userPrefsDebug = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
            console.error('[TTS Preview] - useCredits:', userPrefsDebug ? (userPrefsDebug.use_credits_instead_of_own_api === 1) : 'N/A');
            console.error('[TTS Preview] - apiKey length:', apiKey ? apiKey.length : 0);
            console.error('[TTS Preview] - apiKey preview:', apiKey ? apiKey.substring(0, 10) + '...' : 'null');
            
            // Verificar se há API do admin disponível como última tentativa
            if (provider === 'voice_premium' || provider === 'genaipro' || provider === 'gemini') {
                const lastChanceAdminApi = await getDefaultAdminApi();
                // Para Gemini, buscar API do Gemini; para outros, buscar genaipro/voice_premium
                if (provider === 'gemini') {
                    if (lastChanceAdminApi && lastChanceAdminApi.provider === 'gemini' && lastChanceAdminApi.api_key) {
                        console.log('[TTS Preview] 🆘 Última tentativa: usando API Gemini do admin');
                        try {
                            if (lastChanceAdminApi.api_key.includes(':')) {
                                apiKey = decrypt(lastChanceAdminApi.api_key);
                            } else {
                                apiKey = lastChanceAdminApi.api_key;
                            }
                            if (apiKey && apiKey.trim() !== '' && apiKey.trim().length >= 10) {
                                useAdminApi = true;
                                console.log('[TTS Preview] ✅ API Gemini do admin funcionou como última tentativa');
                            } else {
                                apiKey = null;
                            }
                        } catch (err) {
                            console.error('[TTS Preview] Erro na última tentativa com admin Gemini API:', err.message);
                            apiKey = null;
                        }
                    }
                } else if (lastChanceAdminApi && (lastChanceAdminApi.provider === 'genaipro' || lastChanceAdminApi.provider === 'voice_premium') && lastChanceAdminApi.api_key) {
                    console.log('[TTS Preview] 🆘 Última tentativa: usando API do admin');
                    try {
                        if (lastChanceAdminApi.api_key.includes(':')) {
                            apiKey = decrypt(lastChanceAdminApi.api_key);
                        } else {
                            apiKey = lastChanceAdminApi.api_key;
                        }
                        if (apiKey && apiKey.trim() !== '' && apiKey.trim().length >= 10) {
                            useAdminApi = true;
                            console.log('[TTS Preview] ✅ API do admin funcionou como última tentativa');
                        } else {
                            apiKey = null;
                        }
                    } catch (err) {
                        console.error('[TTS Preview] Erro na última tentativa com admin API:', err.message);
                        apiKey = null;
                    }
                }
            }
            
            if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                return res.status(400).json({ 
                    message: 'Nenhuma API configurada ou a chave está vazia/inválida. Verifique suas configurações de API. Se sua chave foi marcada como inválida na validação, corrija-a ou use créditos.' 
                });
            }
        }
        
        console.log('[TTS Preview] ✅ API Key validada com sucesso (tamanho:', apiKey.length, 'caracteres, usando admin:', useAdminApi, ')');

        const speakerVoiceMap = new Map([['Narrador', previewVoice]]);
        console.log(`[TTS Preview] Gerando áudio com provider: ${provider}, voice: ${previewVoice}, text length: ${previewText.length}`);
        
        // Garantir que o provider seja correto para a função generateTtsAudio
        // Se for Gemini, usar genaipro mas com a API do Gemini
        actualProvider = provider;
        if (provider === 'voice_premium' || provider === 'genaipro') {
            actualProvider = 'genaipro';
        } else if (provider === 'gemini') {
            // Gemini TTS: usar 'gemini' para usar a API oficial do Google Gemini
            actualProvider = 'gemini';
            console.log('[TTS Preview] Usando Gemini TTS oficial com API do Google Gemini');
        }
        
        // Obter velocidade do body se for DarkVoz
        const speed = provider === 'laozhang' ? (parseFloat(req.body.speed) || 1.0) : 1.0;
        
        const { audioBase64 } = await generateTtsAudio({
            apiKey: apiKey,
            model: validatedModel,
            textInput: previewText,
            speakerVoiceMap: speakerVoiceMap,
            provider: actualProvider,
            speed: speed
        });
        
        console.log('[TTS Preview] Áudio gerado com sucesso');
        
        // Se usou API do admin, debitar créditos
        if (useAdminApi && adminApi) {
            try {
                // Estimar tokens (aproximadamente 1 token por caractere para TTS)
                const estimatedTokens = Math.ceil(previewText.length / 4);
                
                const creditResult = await checkAndDebitCredits(
                    req.user.id,
                    adminApi.id,
                    estimatedTokens,
                    'api_tts_preview',
                    JSON.stringify({ model: validatedModel, provider: provider, endpoint: '/api/tts/preview' })
                );
                
                console.log(`💳 [CRÉDITOS] ${creditResult.creditsUsed.toFixed(2)} créditos debitados. Saldo restante: ${creditResult.newBalance.toFixed(2)}`);
            } catch (creditError) {
                console.error('❌ [CRÉDITOS] Erro ao debitar créditos:', creditError);
            }
        }

        res.json({
            message: 'Prévia gerada.',
            audio: {
                mimeType: 'audio/mpeg',
                base64: audioBase64,
            }
        });
    } catch (err) {
        console.error('Erro ao gerar prévia de voz:', err);
        if (err.response) {
            console.error('Status:', err.response.status);
            console.error('Data:', err.response.data);
        }
        
        // Mensagem de erro mais amigável
        let errorMessage = err.message || 'Erro desconhecido ao gerar prévia de voz';
        const status = err.response?.status;
        const responseData = err.response?.data;
        
        // Usar actualProvider se disponível, senão usar provider do body
        const currentProvider = (typeof actualProvider !== 'undefined' ? actualProvider : provider) || 'unknown';
        const isVoicePremiumProvider = currentProvider === 'genaipro' || currentProvider === 'voice_premium';
        const isGeminiProvider = currentProvider === 'gemini';
        const isLaozhangProvider = currentProvider === 'laozhang';
        
        const responseString = typeof responseData === 'string' ? responseData : '';
        const maintenanceHints = ['manutenção', 'Đang Bảo Trì', 'maintenance'];
        const messageIndicatesMaintenance = maintenanceHints.some(hint => (err.message || '').toLowerCase().includes(hint) || responseString.toLowerCase().includes(hint));
        
        if (isVoicePremiumProvider && status === 503 && messageIndicatesMaintenance) {
            errorMessage = 'A API Voz Premium informou que está em manutenção. Por favor, tente novamente em alguns minutos.';
        } else if (messageIndicatesMaintenance) {
            errorMessage = err.message;
        } else if (isGeminiProvider && status === 401) {
            errorMessage = 'Chave do Google Cloud (Gemini) inválida ou expirada. Verifique a chave salva no painel admin.';
        } else if (isGeminiProvider && status === 403) {
            errorMessage = 'Acesso negado pela API do Google Cloud. Verifique se a chave tem permissão para usar o Text-to-Speech.';
        } else if (isLaozhangProvider && (status === 401 || status === 403)) {
            errorMessage = 'Chave do DarkVoz inválida ou sem permissão para TTS. Atualize a chave no painel admin.';
        } else if (isLaozhangProvider && status === 429) {
            errorMessage = 'Limite de requisições atingido no DarkVoz. Aguarde alguns instantes e tente novamente.';
        } else if (isLaozhangProvider && status === 503) {
            errorMessage = 'O DarkVoz está temporariamente indisponível. Tente novamente em alguns minutos.';
        } else if (!isGeminiProvider && !isLaozhangProvider && status === 401) {
            errorMessage = 'Chave de API inválida ou expirada. Verifique suas configurações no painel admin.';
        } else if (!isGeminiProvider && !isLaozhangProvider && status === 403) {
            errorMessage = 'Acesso negado. Verifique se sua chave de API tem permissões para gerar áudio.';
        } else if (err.message && err.message.toLowerCase().includes('timeout')) {
            errorMessage = 'Timeout ao conectar com a API. Tente novamente.';
        }
        
        res.status(err.response?.status || 500).json({ 
            message: errorMessage,
            details: err.response?.data?.message || err.message
        });
    }
});

// POST /api/tts/generate-from-script - Gera áudio completo a partir de roteiro
app.post('/api/tts/generate-from-script', authenticateToken, async (req, res) => {
    const { ttsModel, script, voice, styleInstructions, provider = 'laozhang', speed = 1.0 } = req.body;

    // Validar parâmetros obrigatórios
    if (!script || !voice) {
        return res.status(400).json({ message: 'Roteiro e voz são obrigatórios.' });
    }
    
    // Se não tiver modelo, usar padrão baseado no provider
    let finalTtsModel = ttsModel;
    if (!finalTtsModel || !finalTtsModel.trim()) {
        if (provider === 'laozhang') {
            finalTtsModel = 'tts-1'; // Modelo padrão para laozhang
        } else if (provider === 'openai') {
            finalTtsModel = 'tts-1-hd';
        } else if (provider === 'gemini') {
            finalTtsModel = 'gemini-2.5-pro-preview-tts';
        } else {
            finalTtsModel = 'voz-premium'; // Nome genérico, não expor fornecedor
        }
    }
    
    // Validar modelo
    finalTtsModel = validateTtsModel(finalTtsModel);

    try {
        // Verificar API e créditos
        let apiKey = null;
        let useAdminApi = false;
        let adminApi = null;
        
        // Verificar preferência do usuário
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // Se useCredits estiver marcado, usar laozhang.ai
        if (useCredits) {
            console.log(`[TTS Generate] useCredits marcado, usando laozhang.ai`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Chave da laozhang.ai não configurada. Configure no painel admin.' });
            }
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (!laozhangProviderId) {
                return res.status(400).json({ message: 'Provider laozhang.ai não está ativo no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            adminApi = { id: laozhangProviderId, provider: 'laozhang' };
            // Forçar provider para laozhang
            actualProvider = 'laozhang';
            console.log('[TTS Generate] ✅ Usando API laozhang.ai (useCredits marcado)');
        } else if (provider === 'laozhang') {
            console.log(`[TTS Generate] Provider: laozhang, Voice: ${voice}`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Configure a chave do DarkVoz no painel admin para usar este provedor.' });
            }
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (!laozhangProviderId) {
                return res.status(400).json({ message: 'Provider DarkVoz não está ativo no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            adminApi = { id: laozhangProviderId, provider: 'laozhang' };
            console.log('[TTS Generate] ✅ Usando API DarkVoz (Laozhang.ai) do painel admin');
        } else if (provider === 'gemini') {
            console.log(`[TTS Generate] Provider: gemini, Voice: ${voice}`);
            
            // PRIORIDADE 2: Se não houver chave do admin, buscar API do Gemini do usuário
            if (!apiKey && !useCredits) {
                let userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'gemini']);
                console.log('[TTS Generate] DEBUG - Gemini API do usuário encontrada:', !!userApiKey);
                
                if (userApiKey && userApiKey.api_key) {
                    // Descriptografar a chave do Gemini
                    if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(userApiKey.api_key);
                            console.log('[TTS Generate] Chave Gemini descriptografada (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                        } catch (decryptError) {
                            console.warn('[TTS Generate] Erro ao descriptografar chave Gemini, tentando usar diretamente:', decryptError.message);
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        apiKey = userApiKey.api_key;
                        console.log('[TTS Generate] Chave Gemini usada diretamente (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                    }
                    
                    // Validar se a chave não está vazia
                    if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                        console.warn('[TTS Generate] ⚠️ Chave Gemini está vazia, tentando API do admin');
                        apiKey = null;
                    } else {
                        console.log('[TTS Generate] ✅ Usando API Gemini do usuário');
                    }
                }
            }
            
            // Se não conseguiu usar API própria, tentar admin como fallback
            if (!apiKey) {
                console.log('[TTS Generate] Tentando usar API do admin como fallback para Gemini...');
                adminApi = await getDefaultAdminApi();
                console.log('[TTS Generate] Admin API encontrada:', adminApi ? `${adminApi.provider} - ${adminApi.name}` : 'Nenhuma');
                if (adminApi && adminApi.provider === 'gemini' && adminApi.api_key) {
                    // Descriptografar se necessário
                    if (adminApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminApi.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Generate] Erro ao descriptografar chave Gemini do admin, tentando usar diretamente:', decryptError.message);
                            apiKey = adminApi.api_key;
                        }
                    } else {
                        apiKey = adminApi.api_key;
                    }
                    useAdminApi = true;
                } else {
                    return res.status(400).json({ message: 'Nenhuma API configurada ou a chave está vazia/inválida. Verifique suas configurações de API. Se sua chave foi marcada como inválida na validação, corrija-a ou use créditos.' });
                }
            }
        } else if (provider === 'voice_premium' || provider === 'genaipro') {
            
            const userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'genaipro']);
            
            if (useCredits) {
                // Usuário prefere usar créditos mesmo tendo API própria
                adminApi = await getDefaultAdminApi();
                if (adminApi && (adminApi.provider === 'genaipro' || adminApi.provider === 'voice_premium')) {
                    // Tentar descriptografar a chave do admin
                    if (adminApi.api_key && adminApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminApi.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Generate] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                            apiKey = adminApi.api_key;
                        }
                    } else {
                        apiKey = adminApi.api_key;
                    }
                    useAdminApi = true;
                } else {
                    // Fallback: usar API própria se disponível
                    if (userApiKey) {
                        // Descriptografar a chave do usuário
                        if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                            try {
                                apiKey = decrypt(userApiKey.api_key);
                            } catch (decryptError) {
                                console.warn('[TTS Generate] Erro ao descriptografar chave do usuário, tentando usar diretamente:', decryptError.message);
                                apiKey = userApiKey.api_key;
                            }
                        } else {
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API Voz Premium ou use créditos.' });
                    }
                }
            } else {
                // Usuário prefere usar API própria quando disponível
                if (userApiKey) {
                    // Descriptografar a chave do usuário
                    if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(userApiKey.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Generate] Erro ao descriptografar chave do usuário, tentando usar diretamente:', decryptError.message);
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        apiKey = userApiKey.api_key;
                    }
                } else {
                    adminApi = await getDefaultAdminApi();
                    if (adminApi && (adminApi.provider === 'genaipro' || adminApi.provider === 'voice_premium')) {
                        // Tentar descriptografar a chave do admin
                        if (adminApi.api_key && adminApi.api_key.includes(':')) {
                            try {
                                apiKey = decrypt(adminApi.api_key);
                            } catch (decryptError) {
                                console.warn('[TTS Generate] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                                apiKey = adminApi.api_key;
                            }
                        } else {
                            apiKey = adminApi.api_key;
                        }
                        useAdminApi = true;
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API Voz Premium ou use créditos.' });
                    }
                }
            }
        } else if (provider === 'openai') {
            // Verificar preferência do usuário
            const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
            const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
            
            const userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'openai']);
            const adminOpenAiKey = await getAdminOpenAiVoiceApiKey();
            
            if (adminOpenAiKey) {
                apiKey = adminOpenAiKey;
                console.log('[TTS Generate] ✅ Usando chave de voz OpenAI do painel admin');
            }
            
            if (!apiKey && useCredits) {
                // Usuário prefere usar créditos mesmo tendo API própria
                adminApi = await getDefaultAdminApi();
                if (adminApi && adminApi.provider === 'openai') {
                    apiKey = adminApi.api_key;
                    useAdminApi = true;
                } else {
                    // Fallback: usar API própria se disponível
                    if (userApiKey) {
                        apiKey = userApiKey.api_key;
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API OpenAI ou use créditos.' });
                    }
                }
            } else if (!apiKey) {
                // Usuário prefere usar API própria quando disponível
                if (userApiKey) {
                    apiKey = userApiKey.api_key;
                } else {
                    adminApi = await getDefaultAdminApi();
                    if (adminApi && adminApi.provider === 'openai') {
                        apiKey = adminApi.api_key;
                        useAdminApi = true;
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API OpenAI ou use créditos.' });
                    }
                }
            }
        } else if (provider === 'laozhang') {
            console.log(`[TTS Generate] Provider: laozhang, Voice: ${voice}`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Configure a chave do DarkVoz no painel admin para usar este provedor.' });
            }
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (!laozhangProviderId) {
                return res.status(400).json({ message: 'Provider DarkVoz não está ativo no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            adminApi = { id: laozhangProviderId, provider: 'laozhang' };
            console.log('[TTS Generate] ✅ Usando API DarkVoz (Laozhang.ai) do painel admin');
        }
        
        if (!apiKey) {
            return res.status(400).json({ message: 'Nenhuma API configurada.' });
        }

        // Se usar API do admin, verificar créditos antes
        if (useAdminApi && adminApi) {
            // Estimar tokens necessários
            const estimatedTokens = Math.ceil(script.length / 4);
            
            try {
                const creditCheck = await checkAndDebitCredits(
                    req.user.id,
                    adminApi.id,
                    estimatedTokens,
                    'api_tts_generation',
                    JSON.stringify({ model: finalTtsModel, provider: provider, endpoint: '/api/tts/generate-from-script' })
                );
                
                console.log(`💳 [CRÉDITOS] Pré-débito: ${creditCheck.creditsUsed.toFixed(2)} créditos. Saldo restante: ${creditCheck.newBalance.toFixed(2)}`);
            } catch (creditError) {
                if (creditError.message.includes('Créditos insuficientes')) {
                    return res.status(402).json({ 
                        error: creditError.message,
                        code: 'INSUFFICIENT_CREDITS'
                    });
                }
                throw creditError;
            }
        }

        const jobId = `tts-script-${Date.now()}-${crypto.randomBytes(4).toString('hex')}`;
        const jobData = {
            apiKey,
            ttsModel: finalTtsModel,
            script,
            voice,
            styleInstructions,
            provider: provider,
            speed: parseFloat(speed) || 1.0,
            useAdminApi: useAdminApi,
            adminApi: adminApi,
            userId: req.user.id
        };

        ttsJobs[jobId] = {
            id: jobId,
            status: 'queued',
            progress: 0,
            total: 1,
            message: 'Na fila para processamento...',
            downloadUrl: null,
            createdAt: new Date(),
        };

        // Processar job em background (implementação simplificada)
        processScriptTtsJob(jobId, jobData);

        res.status(202).json({ jobId });

    } catch (error) {
        console.error("Erro ao iniciar trabalho de TTS a partir de roteiro:", error);
        res.status(500).json({ message: `Não foi possível iniciar a geração de áudio: ${error.message}` });
    }
});

// GET /api/tts/status/:jobId - Consulta status do job TTS
app.get('/api/tts/status/:jobId', authenticateToken, (req, res) => {
    const { jobId } = req.params;
    const job = ttsJobs[jobId];

    if (!job) {
        return res.status(404).json({ message: 'Job não encontrado.' });
    }

    res.json({
        status: job.status,
        progress: job.progress,
        total: job.total,
        message: job.message,
        downloadUrl: job.downloadUrl,
        partDownloads: job.partDownloads || []
    });
});

// Função para processar job TTS em background (versão completa do DARKSCRIPT)
async function processScriptTtsJob(jobId, jobData) {
    const job = ttsJobs[jobId];
    
    // Garante que o job existe e reinicializa os valores
    if (!job) {
        console.error(`Job ${jobId} não encontrado`);
        return;
    }
    
    // Reinicializa o progresso para garantir que comece do zero
    job.status = 'processing';
    job.progress = 0;
    job.total = 0;
    job.message = 'Dividindo o roteiro...';
    const tempFilePaths = [];

    try {
        // Define o modelo e limite baseado no provedor
        // SEMPRE usar 4000 caracteres por parte conforme DARKSCRIPT
        let validatedTtsModel;
        let charLimit = 4000; // SEMPRE 4000 caracteres por parte
        let minDelayBetweenRequests;
        
        if (jobData.provider === 'openai') {
            // OpenAI TTS: limite REAL é 4096 caracteres por requisição, mas vamos usar 4000 para padronizar
            validatedTtsModel = 'tts-1-hd';
            minDelayBetweenRequests = 500; // 0.5s (OpenAI é rápido)
            console.log(`📢 Usando OpenAI TTS para gerar áudio (4000 chars por parte)`);
        } else if (jobData.provider === 'genaipro' || jobData.provider === 'voice_premium') {
            validatedTtsModel = 'voz-premium'; // Nome genérico, não expor fornecedor
            minDelayBetweenRequests = 2000; // 2s entre requisições
            console.log(`📢 Usando Voz Premium para gerar áudio (4000 chars por parte)`);
        } else if (jobData.provider === 'laozhang') {
            // Usar modelo do jobData se fornecido, senão usar padrão
            validatedTtsModel = jobData.ttsModel || 'tts-1';
            minDelayBetweenRequests = 1500;
            console.log(`📢 Usando DarkVoz TTS para gerar áudio (4000 chars por parte, modelo: ${validatedTtsModel}, velocidade: ${jobData.speed || 1.0}x)`);
        } else {
            // Gemini TTS: aceita textos MUITO longos, mas vamos usar 4000 para padronizar
            validatedTtsModel = 'gemini-2.5-flash-preview-tts';
            minDelayBetweenRequests = 2000; // 2s entre requisições
            console.log(`📢 Usando Gemini TTS para gerar áudio (4000 chars por parte)`);
        }
        
        // Log para monitorar processamento de áudios longos
        const estimatedMinutes = Math.ceil((jobData.script.length / charLimit) * 0.5); // ~0.5 min por chunk
        if (estimatedMinutes > 30) {
            console.log(`Processando áudio longo estimado em ~${estimatedMinutes} minutos (${jobData.script.length} caracteres)`);
        }

        // Usando a função splitTextIntoChunks com 4000 caracteres
        const chunks = splitTextIntoChunks(jobData.script, charLimit);

        if (!chunks || chunks.length === 0) {
            throw new Error("Não foi possível dividir o roteiro em partes.");
        }
        
        // Validação prévia: verifica se há chunks antes de processar
        console.log(`📊 Roteiro dividido em ${chunks.length} parte(s) de até ${charLimit} caracteres cada.`);
        console.log(`   Total de caracteres: ${jobData.script.length.toLocaleString('pt-BR')}`);
        console.log(`   Estimativa de tempo: ~${Math.ceil(chunks.length * minDelayBetweenRequests / 1000 / 60)} minutos`);

        // Atualiza o job com o total de chunks ANTES de começar o processamento
        job.total = chunks.length;
        job.progress = 0;
        job.message = `📋 Roteiro dividido em ${chunks.length} partes. Preparando geração...`;
        
        // Verificar FFmpeg ANTES de começar (para mostrar status correto)
        let ffmpegAvailable = false;
        try {
            await new Promise((resolve, reject) => {
                ffmpeg().version((err) => {
                    if (err) reject(err);
                    else resolve();
                });
            });
            ffmpegAvailable = true;
        } catch (e) {
            ffmpegAvailable = false;
        }
        
        if (ffmpegAvailable) {
            job.message = `✅ FFmpeg detectado. Gerando ${chunks.length} partes de áudio...`;
        } else {
            job.message = `⚠️ FFmpeg não encontrado. Usando método alternativo para ${chunks.length} partes...`;
        }
        
        const audioExt = 'mp3'; // Sempre usar MP3
        const validTempFiles = [];
        
        // Processar cada chunk
        for (let i = 0; i < chunks.length; i++) {
            job.progress = i;
            job.message = `🎙️ Gerando parte ${i + 1}/${chunks.length}...`;
            
            try {
                const speakerVoiceMap = new Map([['Narrador', jobData.voice]]);
                
                // Garantir que o provider seja correto para a função generateTtsAudio
                // Se for voice_premium ou genaipro, converter para genaipro
                let actualProvider = jobData.provider;
                if (actualProvider === 'voice_premium' || actualProvider === 'genaipro') {
                    actualProvider = 'genaipro';
                } else if (actualProvider === 'gemini') {
                    // Gemini TTS: usar 'gemini' para usar a API oficial do Google Gemini
                    actualProvider = 'gemini';
                }
                
                const result = await generateTtsAudio({
                    apiKey: jobData.apiKey,
                    model: validatedTtsModel,
                    textInput: chunks[i],
                    speakerVoiceMap: speakerVoiceMap,
                    provider: actualProvider,
                    speed: jobData.speed || 1.0
                });
                
                // Salvar arquivo temporário
                const tempPath = path.join(TEMP_AUDIO_DIR, `${jobId}_part_${i}.${audioExt}`);
                const audioBuffer = Buffer.from(result.audioBase64, 'base64');
                await fs.promises.writeFile(tempPath, audioBuffer);
                validTempFiles.push(tempPath);
                tempFilePaths.push(tempPath);
                
                // Registrar arquivo no banco de dados para controle de armazenamento
                if (jobData.userId) {
                    await registerUserStorage(jobData.userId, tempPath, audioBuffer.length, 'audio');
                }
                
                console.log(`✅ Parte ${i + 1}/${chunks.length} gerada: ${audioBuffer.length} bytes`);
                
                // Delay entre partes
                if (i < chunks.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, minDelayBetweenRequests));
                }
            } catch (chunkError) {
                console.error(`❌ Erro ao gerar parte ${i + 1}/${chunks.length}:`, chunkError);
                console.error(`❌ Detalhes do erro:`, {
                    message: chunkError.message,
                    stack: chunkError.stack,
                    response: chunkError.response ? {
                        status: chunkError.response.status,
                        data: chunkError.response.data
                    } : null,
                    provider: actualProvider || jobData.provider,
                    voice: jobData.voice,
                    chunkLength: chunks[i].length,
                    chunkPreview: chunks[i].substring(0, 100)
                });
                
                // Se for erro crítico (não de rede), parar o processamento
                const isCriticalError = chunkError.message && (
                    chunkError.message.includes('manutenção') ||
                    chunkError.message.includes('API Key') ||
                    chunkError.message.includes('inválida') ||
                    chunkError.message.includes('indisponível') ||
                    chunkError.message.includes('não está disponível') ||
                    chunkError.message.includes('não existe') ||
                    chunkError.message.includes('voz') && chunkError.message.includes('inválida') ||
                    (chunkError.response && chunkError.response.status === 400) // Erro 400 geralmente indica parâmetros inválidos
                );
                
                if (isCriticalError) {
                    // Se for primeira parte e erro crítico, parar imediatamente
                    if (i === 0) {
                        throw chunkError; // Parar processamento se for erro crítico na primeira parte
                    }
                    // Se for erro crítico em partes subsequentes, também parar para evitar desperdício
                    throw chunkError;
                }
                // Continuar com outras partes mesmo se uma falhar (apenas para erros não críticos como timeout de rede)
            }
        }
        
        if (validTempFiles.length === 0) {
            const errorDetails = {
                totalChunks: chunks.length,
                provider: actualProvider || jobData.provider,
                scriptLength: jobData.script.length,
                voice: jobData.voice
            };
            console.error('❌ Nenhuma parte de áudio foi gerada com sucesso. Detalhes:', errorDetails);
            throw new Error(`Nenhuma parte de áudio foi gerada com sucesso. Verifique os logs do servidor para mais detalhes. Provider: ${errorDetails.provider}, Voz: ${errorDetails.voice}`);
        }
        
        // Log de sucesso parcial se nem todos os chunks foram gerados
        if (validTempFiles.length < chunks.length) {
            console.warn(`⚠️ Apenas ${validTempFiles.length} de ${chunks.length} partes foram geradas com sucesso. Continuando com as partes disponíveis...`);
        }
        
        // CASO 1: apenas 1 arquivo → retornar direto
        if (validTempFiles.length === 1) {
            const singleFile = await fs.promises.readFile(validTempFiles[0]);
            const singleBase64 = singleFile.toString('base64');
            job.downloadUrl = `data:audio/${audioExt};base64,${singleBase64}`;
            job.status = 'completed';
            job.progress = job.total;
            job.message = 'Áudio gerado com sucesso!';
            console.log(`🎉 TTS de roteiro concluído (sem concatenação): ${jobId}.${audioExt}`);
            return;
        }
        
        // CASO 2: mais de 1 arquivo E FFmpeg disponível → concatenar com FFmpeg
        if (ffmpegAvailable) {
            job.message = `🔗 Concatenando ${validTempFiles.length} partes com FFmpeg...`;
            console.log(`✅ FFmpeg disponível - concatenando ${validTempFiles.length} arquivos ${audioExt.toUpperCase()}`);
            
            const finalPath = path.join(TEMP_AUDIO_DIR, `${jobId}_final.${audioExt}`);
            const listFilePath = path.join(TEMP_AUDIO_DIR, `${jobId}_filelist.txt`);
            const fileListContent = validTempFiles
                .map(fp => `file '${fp.replace(/\\/g, '/')}'`)
                .join('\n');
            
            await fs.promises.writeFile(listFilePath, fileListContent, 'utf8');
            tempFilePaths.push(listFilePath);
            
            await new Promise((resolve, reject) => {
                ffmpeg()
                    .input(listFilePath)
                    .inputOptions(['-f', 'concat', '-safe', '0'])
                    .outputOptions(['-c', 'copy'])
                    .output(finalPath)
                    .on('start', (cmd) => {
                        console.log(`🎬 [TTS] FFmpeg iniciado para concatenação: ${cmd}`);
                    })
                    .on('progress', (progress) => {
                        if (progress.percent) {
                            job.message = `🔗 Concatenando com FFmpeg: ${Math.round(progress.percent)}%`;
                        }
                    })
                    .on('end', async () => {
                        console.log(`✅ [TTS] FFmpeg concluído: ${finalPath}`);
                        resolve();
                    })
                    .on('error', (err) => {
                        console.error(`❌ [TTS] Erro no FFmpeg: ${err.message}`);
                        reject(err);
                    })
                    .run();
            });
            
            // Ler arquivo final
            const finalAudio = await fs.promises.readFile(finalPath);
            const finalBase64 = finalAudio.toString('base64');
            job.downloadUrl = `data:audio/${audioExt};base64,${finalBase64}`;
            tempFilePaths.push(finalPath);
            
            // Registrar arquivo final no banco de dados para controle de armazenamento
            if (jobData.userId) {
                await registerUserStorage(jobData.userId, finalPath, finalAudio.length, 'audio');
                // Remover registros das partes individuais já que temos o arquivo final
                for (const partPath of validTempFiles) {
                    await unregisterUserStorage(jobData.userId, partPath);
                }
            }
        } else {
            // CASO 3: FFmpeg não disponível → retornar partes separadas
            job.message = `⚠️ ${validTempFiles.length} partes geradas (FFmpeg não disponível para concatenação)`;
            job.partDownloads = validTempFiles.map((filePath, idx) => {
                const fileBase64 = fs.readFileSync(filePath).toString('base64');
                return {
                    part: idx + 1,
                    downloadUrl: `data:audio/${audioExt};base64,${fileBase64}`,
                    filename: `parte_${idx + 1}.${audioExt}`
                };
            });
            job.status = 'partial';
        }
        
        job.status = job.status === 'partial' ? 'partial' : 'completed';
        job.progress = job.total;
        job.message = job.status === 'completed' ? 'Áudio gerado com sucesso!' : job.message;
        
    } catch (error) {
        console.error(`Erro no trabalho TTS ${jobId}:`, error);
        job.status = 'failed';
        job.message = error.message || 'Ocorreu um erro desconhecido.';
        
        // Reembolsar créditos em caso de erro
        if (jobData.useAdminApi && jobData.adminApi) {
            try {
                const estimatedTokens = Math.ceil(jobData.script.length / 4);
                await refundCredits(jobData.userId, estimatedTokens * 0.1, 'Erro na geração de TTS');
            } catch (refundError) {
                console.error('Erro ao reembolsar créditos:', refundError);
            }
        }
    } finally {
        // Limpar arquivos temporários e remover registros do banco de dados
        for (const filePath of tempFilePaths) {
            try {
                // Remover registro do banco de dados antes de deletar o arquivo
                if (jobData.userId) {
                    await unregisterUserStorage(jobData.userId, filePath);
                }
                await fs.promises.unlink(filePath);
            } catch (unlinkError) {
                console.warn(`Não foi possível excluir o arquivo temporário ${filePath}: ${unlinkError.message}`);
            }
        }
        job.finishedAt = new Date();
    }
}


// === ROTAS DE GESTÃO DE API KEYS ===

app.post('/api/keys/save', authenticateToken, async (req, res) => {
    const { service_name, api_key } = req.body;
    const userId = req.user.id;

    if (!service_name || !api_key) {
        return res.status(400).json({ msg: 'Serviço e Chave de API são obrigatórios.' });
    }

    // Verificar se é uma API que requer plano premium (Claude, Gemini, OpenAI)
    const premiumApis = ['claude', 'gemini', 'openai'];
    if (premiumApis.includes(service_name.toLowerCase())) {
        try {
            // Verificar plano do usuário
            const user = await db.get('SELECT plan, subscription_plan, isAdmin FROM users WHERE id = ?', [userId]);
            if (!user) {
                return res.status(404).json({ msg: 'Usuário não encontrado.' });
            }
            
            const userPlan = user.subscription_plan || user.plan || 'plan-free';
            const hasPremiumPlan = userPlan === 'plan-master' || 
                                  userPlan === 'plan-master-annual' || 
                                  userPlan === 'plan-start-annual' || 
                                  userPlan === 'plan-turbo-annual' ||
                                  (user.isAdmin === 1 || user.isAdmin === true || String(user.isAdmin) === '1');
            
            if (!hasPremiumPlan) {
                return res.status(403).json({ 
                    msg: 'Você precisa ter o plano MASTER ou um plano ANUAL para usar suas próprias chaves de API. Faça upgrade para desbloquear este recurso.',
                    requiresUpgrade: true
                });
            }
        } catch (planErr) {
            console.error('Erro ao verificar plano do usuário:', planErr);
            return res.status(500).json({ msg: 'Erro ao verificar plano do usuário.' });
        }
    }

    try {
        const encryptedKey = encrypt(api_key);
        
        await db.run(
            `INSERT INTO user_api_keys (user_id, service_name, api_key) 
             VALUES (?, ?, ?)
             ON CONFLICT(user_id, service_name) 
             DO UPDATE SET api_key = excluded.api_key, created_at = CURRENT_TIMESTAMP`,
            [userId, service_name, encryptedKey]
        );

        res.status(200).json({ msg: `Chave de API para ${service_name} salva com sucesso!` });
    
    } catch (err) {
        console.error('Erro ao salvar chave de API:', err);
        res.status(500).json({ msg: 'Erro no servidor ao salvar a chave.' });
    }
});

app.get('/api/keys/status', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    try {
        const keys = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
        
        // Função para mascarar chave
        const maskKey = (key, serviceName) => {
            if (!key) return '';
            try {
                const decrypted = decrypt(key);
                if (!decrypted) return '';
                
                // Mostrar primeiros 4 caracteres e últimos 4 caracteres
                if (decrypted.length > 12) {
                    const prefix = decrypted.substring(0, 4);
                    const suffix = decrypted.substring(decrypted.length - 4);
                    return `${prefix}${'•'.repeat(Math.min(decrypted.length - 8, 20))}${suffix}`;
                }
                return '••••••••';
            } catch (err) {
                // Se falhar ao descriptografar, ainda mostrar que existe
                return '••••••••';
            }
        };
        
        const status = {};
        keys.forEach(k => {
            status[k.service_name] = {
                exists: true,
                masked: maskKey(k.api_key, k.service_name)
            };
        });
        
        // Incluir todos os serviços possíveis
        const allServices = ['gemini', 'openai', 'claude', 'imagefx', 'youtube'];
        allServices.forEach(service => {
            if (!status[service]) {
                status[service] = { exists: false, masked: '' };
            }
        });
        
        res.status(200).json(status);
    } catch (err) {
        console.error('Erro ao buscar status das chaves:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

app.post('/api/keys/validate-all', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    try {
        const keysData = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
        
        if (keysData.length === 0) {
            return res.status(400).json({ msg: 'Nenhuma chave de API foi salva ainda.' });
        }

        const allowedServices = new Set(['gemini', 'openai', 'claude', 'imagefx', 'youtube']);
        const filteredKeysData = keysData.filter(key => allowedServices.has(key.service_name));
        const ignoredServices = keysData.filter(key => !allowedServices.has(key.service_name));

        if (ignoredServices.length > 0) {
            console.warn(`[Validação de Chaves] Ignorando serviços não suportados: ${ignoredServices.map(s => s.service_name).join(', ')}`);
        }

        if (filteredKeysData.length === 0) {
            return res.status(400).json({ msg: 'Nenhuma chave dos serviços suportados (Gemini, Claude, OpenAI, YouTube ou ImageFX) foi encontrada para validação.' });
        }

        const validationPromises = filteredKeysData.map(async (keyData) => {
            const decryptedKey = decrypt(keyData.api_key);
            if (!decryptedKey) {
                return { service: keyData.service_name, success: false, error: 'Falha ao desencriptar' };
            }

            switch (keyData.service_name) {
                case 'gemini':
                    const geminiResult = await validateGeminiKey(decryptedKey);
                    return { service: 'gemini', ...geminiResult };
                case 'openai':
                    const openaiResult = await validateOpenAIKey(decryptedKey);
                    return { service: 'openai', ...openaiResult };
                case 'claude':
                    const claudeResult = await validateClaudeKey(decryptedKey);
                    return { service: 'claude', ...claudeResult };
                case 'youtube':
                    const youtubeResult = await validateYouTubeKey(decryptedKey);
                    return { service: 'youtube', ...youtubeResult };
                case 'imagefx':
                    return { service: 'imagefx', success: true };
                default:
                    return { service: keyData.service_name, success: false, error: 'Serviço desconhecido' };
            }
        });

        const results = await Promise.all(validationPromises);
        
        // Adicionar informações sobre o tipo de chave detectado
        const resultsWithDetails = results.map(result => {
            if (result.service === 'gemini' && result.success && result.type) {
                return {
                    ...result,
                    message: result.message || (result.type === 'gemini-api' ? 'Chave de API do Gemini válida' : 'Chave do Google Cloud válida'),
                    warning: result.warning || null
                };
            }
            return result;
        });
        
        res.status(200).json({ 
            msg: 'Validação concluída.',
            results: resultsWithDetails
        });

    } catch (err) {
        console.error('Erro ao validar chaves:', err);
        res.status(500).json({ msg: 'Erro no servidor durante a validação.' });
    }
});


// === FUNÇÕES AUXILIARES DE ANÁLISE ===

// Função para determinar se um vídeo é realmente viral
function isViralVideo(views, days, viewsPerDay) {
    // Critérios para considerar um vídeo como viral:
    // 1. Mínimo de 100.000 views totais
    // 2. Mínimo de 10.000 views/dia (para vídeos recentes)
    // 3. Ou mínimo de 50.000 views/dia nos primeiros 7 dias
    // 4. Para vídeos mais antigos (>30 dias), mínimo de 500.000 views totais
    
    if (days <= 0) {
        // Sem informação de dias, usar apenas views totais
        return views >= 500000; // 500k+ views sem info de tempo = provavelmente viral
    }
    
    if (days <= 7) {
        // Vídeo muito recente: precisa de crescimento explosivo
        return viewsPerDay >= 50000 || views >= 500000;
    } else if (days <= 30) {
        // Vídeo recente: precisa de bom crescimento
        return viewsPerDay >= 10000 || views >= 300000;
    } else {
        // Vídeo mais antigo: precisa de views totais altas
        return views >= 1000000; // 1M+ views para vídeos antigos
    }
}

// === ROTAS DE ANÁLISE (O CORAÇÃO DO SAAS) ===

app.post('/api/analyze/titles', authenticateToken, async (req, res) => {
    // Log defensivo do corpo recebido
    try {
        console.log('[Análise] Body recebido tipo:', typeof req.body);
        console.log('[Análise] Campos:', {
            videoUrl: req.body?.videoUrl,
            model: req.body?.model,
            selectedModel: req.body?.selectedModel,
            folderId: req.body?.folderId
        });
    } catch {}

    const rawModel = (req.body && (req.body.model ?? req.body.selectedModel)) ?? '';
    const model = typeof rawModel === 'string' ? rawModel.trim() : '';
    const videoUrl = typeof req.body?.videoUrl === 'string' ? req.body.videoUrl.trim() : '';
    const folderId = req.body?.folderId;
    const language = req.body?.language || 'Português'; // Idioma padrão: Português
    const userId = req.user.id;

    if (!videoUrl || !model) {
        return res.status(400).json({ msg: 'URL do vídeo e modelo de IA são obrigatórios.' });
    }
    
    try {
        // Verificar se o banco de dados está disponível
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível. Aguarde alguns instantes.' });
        }
        
        // --- ETAPA 1: Mineração de Dados (YouTube) ---
        console.log(`[Análise] A iniciar mineração para: ${videoUrl}`);
        let videoId;
        try {
            videoId = ytdl.getVideoID(videoUrl);
        } catch (err) {
            return res.status(400).json({ msg: 'URL do YouTube inválida.' });
        }

        // Tentar usar chave específica do YouTube primeiro, depois fallback para Gemini
        let youtubeApiKey = null;
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
            if (!youtubeApiKey && youtubeKeyData.api_key && !youtubeKeyData.api_key.includes(':')) {
                // Chave pode não estar criptografada
                youtubeApiKey = youtubeKeyData.api_key;
            }
        }
        
        // Se não tem chave do YouTube, tentar usar Gemini (pode funcionar se for chave do Google Cloud)
        if (!youtubeApiKey) {
            const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
                if (!youtubeApiKey && geminiKeyData.api_key && !geminiKeyData.api_key.includes(':')) {
                    youtubeApiKey = geminiKeyData.api_key;
                }
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ 
                msg: 'Nenhuma chave de API do YouTube configurada. Configure uma chave do YouTube Data API v3 nas Configurações. A chave do Gemini não funciona para a API do YouTube.' 
            });
        }

        const videoDetails = await callYouTubeDataAPI(videoId, youtubeApiKey);
        
        let transcriptText;
        let fullTranscript = null;
        try {
            const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
            fullTranscript = transcriptData.map(t => t.text).join(' ');
            transcriptText = fullTranscript.substring(0, 500); // Apenas início para o prompt
        } catch (err) {
            console.warn(`[Análise] Não foi possível obter transcrição para ${videoId}. A continuar sem ela.`);
            transcriptText = "(Transcrição não disponível)";
            fullTranscript = null;
        }
        
        console.log(`[Análise] Vídeo encontrado: ${videoDetails.title}`);

        // --- ETAPA 1.5: Traduzir título original para português ---
        let translatedTitle = videoDetails.title;
        try {
            const translatePrompt = `Traduza o seguinte título de vídeo do YouTube para português brasileiro (PT-BR). Mantenha o sentido, impacto e estrutura original. Retorne APENAS a tradução, sem explicações ou formatação.
Título original: "${videoDetails.title}"

Tradução em PT-BR:`;
            
            // Usar o modelo escolhido pelo usuário para tradução
            let translateText;
            
            // Mapear modelo do frontend para serviço e modelo correto
            let translateService;
            let translateModel = model;
            if (model.startsWith('gemini') || model.includes('gemini')) {
                translateService = 'gemini';
                translateModel = model.includes('2.5-pro') ? 'gemini-2.5-pro' : (model.includes('2.5-flash') ? 'gemini-2.5-flash' : 'gemini-2.0-flash');
            } else if (model.startsWith('claude') || model.includes('claude') || model.includes('sonnet')) {
                translateService = 'claude';
                translateModel = model.includes('3.7') ? 'claude-3-7-sonnet-20250219' : model;
            } else if (model.startsWith('gpt') || model.includes('gpt') || model.includes('openai')) {
                translateService = 'openai';
                translateModel = model.includes('4o') ? 'gpt-4o' : model;
            } else {
                // Fallback: tentar detectar pelo modelo
                translateService = 'gemini';
                translateModel = 'gemini-2.0-flash';
            }
            
            // Buscar chave do serviço correspondente
            const translateKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, translateService]);
            if (translateKeyData) {
                const translateKey = decrypt(translateKeyData.api_key) || translateKeyData.api_key;
                
                if (translateService === 'claude') {
                    const translateResponse = await callClaudeAPI(translatePrompt, translateKey, translateModel);
                    translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
                } else if (translateService === 'openai') {
                    const translateResponse = await callOpenAIAPI(translatePrompt, translateKey, translateModel);
                    translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
                } else {
                    const translateResponse = await callGeminiAPI(translatePrompt, translateKey, translateModel);
                    translateText = translateResponse.titles.trim();
                }
            } else {
                // Fallback: usar sistema de preferência se não tiver chave do modelo escolhido
                let translateProvider = await getPreferredAIProvider(userId, ['claude', 'openai', 'gemini']);
                
                // Verificar se realmente deve usar laozhang (evitar uso indevido)
                if (translateProvider && translateProvider.service === 'laozhang') {
                    const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
                    if (!creditsCheck.shouldUse) {
                        // Não deve usar laozhang, tentar buscar API própria diretamente
                        console.log('[Análise] Laozhang retornado mas usuário não deve usar créditos, buscando API própria...');
                        translateProvider = null;
                        // Buscar diretamente as chaves do usuário
                        for (const svc of ['claude', 'openai', 'gemini']) {
                            try {
                                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
                                if (keyData && keyData.api_key) {
                                    const key = decrypt(keyData.api_key);
                                    if (key) {
                                        translateProvider = { service: svc, apiKey: key, model: svc === 'claude' ? 'claude-3-7-sonnet-20250219' : (svc === 'openai' ? 'gpt-4o' : 'gemini-2.5-pro') };
                                        break;
                                    }
                                }
                            } catch {}
                        }
                    }
                }
                
                if (translateProvider && translateProvider.service === 'laozhang') {
                    const translateResponse = await callLaozhangAPI(
                        translatePrompt, 
                        translateProvider.apiKey, 
                        translateProvider.model, 
                        null, 
                        userId, 
                        '/api/analyze/titles', 
                        JSON.stringify({ endpoint: '/api/analyze/titles', operation: 'translate', model: translateProvider.model })
                    );
                    translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
                } else if (translateProvider && translateProvider.service === 'claude') {
                    const translateResponse = await callClaudeAPI(translatePrompt, translateProvider.apiKey, translateProvider.model);
                    translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
                } else if (translateProvider && translateProvider.service === 'openai') {
                    const translateResponse = await callOpenAIAPI(translatePrompt, translateProvider.apiKey, translateProvider.model);
                    translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
                } else {
                    // Último fallback: Gemini
                    const translateResponse = await callGeminiAPI(translatePrompt, geminiApiKey, 'gemini-2.0-flash');
                    translateText = translateResponse.titles.trim();
                }
            }
            
            // Limpar a resposta (remover markdown, aspas, etc)
            translatedTitle = translateText.replace(/^["']|["']$/g, '').replace(/```json|```/g, '').trim();
            // Alguns modelos podem devolver array JSON ["..."]; normalizar para string
            if (translatedTitle.startsWith('[')) {
                try {
                    const arr = JSON.parse(translatedTitle);
                    if (Array.isArray(arr) && typeof arr[0] === 'string') {
                        translatedTitle = arr[0].trim();
                    }
                } catch {}
            }
            if (translatedTitle.length > 200) {
                translatedTitle = translatedTitle.substring(0, 200);
            }
            console.log(`[Análise] Título traduzido: ${translatedTitle}`);
        } catch (err) {
            console.warn(`[Análise] Falha ao traduzir título, usando original: ${err.message}`);
            translatedTitle = videoDetails.title;
        }

        // --- ETAPA 2: IA - Análise de Título e Geração (PROMPT REFINADO) ---
        const viewsPerDay = Math.round(videoDetails.views / Math.max(videoDetails.days, 1));
        const isViral = isViralVideo(videoDetails.views, videoDetails.days, viewsPerDay);
        
        // Contexto de performance baseado na classificação real
        let performanceContext;
        let viralContext;
        
        if (isViral) {
            if (videoDetails.days > 0) {
                performanceContext = `Este vídeo VIRALIZOU com ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias (média de ${viewsPerDay.toLocaleString()} views/dia) - um desempenho EXCEPCIONAL que indica alta viralização.`;
            } else {
                performanceContext = `Este vídeo VIRALIZOU com ${videoDetails.views.toLocaleString()} views - um desempenho EXCEPCIONAL que indica alta viralização.`;
            }
            viralContext = 'que VIRALIZOU';
        } else {
            // Vídeo não viral - ser honesto sobre a performance
            if (videoDetails.days > 0) {
                const performanceLevel = viewsPerDay < 100 
                    ? 'baixo desempenho' 
                    : viewsPerDay < 1000 
                        ? 'desempenho moderado' 
                        : 'bom desempenho';
                performanceContext = `Este vídeo tem ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias (média de ${viewsPerDay.toLocaleString()} views/dia) - ${performanceLevel}. Este vídeo NÃO viralizou, mas pode ser analisado para identificar elementos que podem ser melhorados para criar versões com maior potencial viral.`;
            } else {
                performanceContext = `Este vídeo tem ${videoDetails.views.toLocaleString()} views. Este vídeo NÃO viralizou, mas pode ser analisado para identificar elementos que podem ser melhorados para criar versões com maior potencial viral.`;
            }
            viralContext = 'de referência';
        }

        // Quantidade de títulos a gerar: sempre 5 por modelo
        // No modo multimodal, cada modelo gera 5 títulos, totalizando 15 (5 x 3)
        const titlesRequired = 5;
        const languageInstruction = language === 'Português'
            ? 'EM PORTUGUÊS BRASILEIRO (PT-BR)'
            : language === 'Inglês'
                ? 'EM INGLÊS (EN)'
                : language === 'Espanhol'
                    ? 'EM ESPANHOL (ES)'
                    : 'EM PORTUGUÊS BRASILEIRO (PT-BR)';
        const languageExplanation = language === 'Português'
            ? 'EM PORTUGUÊS BRASILEIRO'
            : language === 'Inglês'
                ? 'EM INGLÊS'
                : language === 'Espanhol'
                    ? 'EM ESPANHOL'
                    : 'EM PORTUGUÊS BRASILEIRO';

        const MIN_IMPACT_SCORE = 7;
        const titlePrompt = buildTitleRefinePrompt({
            originalTitle: videoDetails.title,
            translatedTitle,
            performanceContext,
            descriptionStart: videoDetails.description ? videoDetails.description.substring(0, 300) : 'N/A',
            transcriptStart: transcriptText ? transcriptText.substring(0, 500) : '(Transcrição não disponível)',
            languageInstruction,
            titlesRequired,
            minImpact: MIN_IMPACT_SCORE
        });
        
        let allGeneratedTitles = [];
        let modelUsedForDisplay = model;
        let finalAnalysisData;
        let finalNicheData;
        
        // --- INÍCIO DA LÓGICA DO DISTRIBUIDOR (SWITCHER) ---
        if (model === 'all') {
            // Comparação multimodal SEM laozhang (usa chaves próprias)
            modelUsedForDisplay = 'Comparação (Gemini, Claude, OpenAI)';

            const keysData = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
            const keys = {};
            keysData.forEach(k => { keys[k.service_name] = decrypt(k.api_key); });

            if (!keys.gemini || !keys.claude || !keys.openai) {
                return res.status(400).json({ msg: 'Para "Comparar", precisa de ter as chaves de Gemini, Claude E OpenAI configuradas.' });
            }

            console.log('[Análise-All] A chamar IA em paralelo (APIs próprias)...');
            const MIN_IMPACT_SCORE = 7;
            const serviceConfigs = [
                { name: 'Gemini', apiFunc: callGeminiAPI, apiKey: keys.gemini, model: 'gemini-2.5-pro' },
                { name: 'Claude', apiFunc: callClaudeAPI, apiKey: keys.claude, model: 'claude-3-7-sonnet-20250219' },
                { name: 'OpenAI', apiFunc: callOpenAIAPI, apiKey: keys.openai, model: 'gpt-4o' }
            ];
            // Primeiro round em paralelo
            const promises = serviceConfigs.map(cfg => cfg.apiFunc(titlePrompt, cfg.apiKey, cfg.model));
            const results = await Promise.allSettled(promises);

            let firstSuccessfulAnalysis = null;
            for (let index = 0; index < results.length; index++) {
                const result = results[index];
                const cfg = serviceConfigs[index];
                const serviceName = cfg?.name || ['Gemini', 'Claude', 'OpenAI'][index];

                // Se o 1º round falhar, não derrubar a rota: apenas registrar e seguir (vamos tentar preencher com outras IAs)
                if (result.status !== 'fulfilled') {
                    console.error(`[Análise-All] Falha com ${serviceName}:`, result.reason?.message || result.reason);
                    continue;
                }

                // Envolver todo o processamento em try-catch para não quebrar o multimodal se uma IA falhar
                try {
                // extrair texto do 1º round
                const rawText = typeof result.value === 'string'
                    ? result.value
                    : (result.value && typeof result.value.titles === 'string' ? result.value.titles : '');
                const parsedData = parseTitleAnalysisResponse(rawText, serviceName, titlesRequired);
                if (!firstSuccessfulAnalysis) firstSuccessfulAnalysis = parsedData;

                    // Completar 5 aprovados com refinamento rápido (modo multimodal otimizado)
                const passing = await generatePassingTitlesWithRefine({
                    apiFunc: cfg.apiFunc,
                    apiKey: cfg.apiKey,
                    model: cfg.model,
                    serviceName,
                    basePromptBuilder: buildTitleRefinePrompt,
                    buildArgs: {
                        originalTitle: videoDetails.title,
                        translatedTitle,
                        performanceContext,
                        descriptionStart: videoDetails.description ? videoDetails.description.substring(0, 300) : 'N/A',
                        transcriptStart: transcriptText ? transcriptText.substring(0, 500) : '(Transcrição não disponível)',
                        languageInstruction
                    },
                    titlesRequired,
                    minImpact: MIN_IMPACT_SCORE,
                        maxRefines: 1  // Reduzido para 1 tentativa extra (modo multimodal mais rápido)
                });

                // Não falhar: adicionar o que passou (>=7) e seguir; depois tentamos preencher o total até 15.
                console.log(`[Análise Multimodal] ${serviceName}: ${passing.length}/${titlesRequired} títulos aprovados (Impacto >= ${MIN_IMPACT_SCORE})`);
                passing.forEach(t => allGeneratedTitles.push({ ...t, model: serviceName }));
                } catch (parseError) {
                    console.error(`[Análise Multimodal] Erro ao processar ${serviceName}:`, parseError.message);
                    // Continuar com as outras IAs mesmo se esta falhar
                    continue;
                }
            }
            
            if (!firstSuccessfulAnalysis) throw new Error("Todas as IAs falharam em retornar uma análise válida.");

            // Se alguma IA não conseguiu 5, tentar preencher até 15 usando as IAs que funcionaram
            const targetTotal = titlesRequired * 3; // 15
            const maxFillRounds = 3; // no máximo 3 rodadas extras para preencher
            let fillRound = 0;
            while (allGeneratedTitles.length < targetTotal && fillRound < maxFillRounds) {
                const remaining = targetTotal - allGeneratedTitles.length;
                // Preferir IAs que já responderam (mantém consistência)
                for (const cfg of serviceConfigs) {
                    if (allGeneratedTitles.length >= targetTotal) break;
                    const needNow = Math.min(remaining, titlesRequired);
                    const avoidAll = allGeneratedTitles.map(t => t.titulo);
                    try {
                        const more = await generatePassingTitlesWithRefine({
                            apiFunc: cfg.apiFunc,
                            apiKey: cfg.apiKey,
                            model: cfg.model,
                            serviceName: cfg.name,
                            basePromptBuilder: buildTitleRefinePrompt,
                            buildArgs: {
                                originalTitle: videoDetails.title,
                                translatedTitle,
                                performanceContext,
                                descriptionStart: videoDetails.description ? videoDetails.description.substring(0, 300) : 'N/A',
                                transcriptStart: transcriptText ? transcriptText.substring(0, 500) : '(Transcrição não disponível)',
                                languageInstruction,
                                avoidTitles: avoidAll
                            },
                            titlesRequired: needNow,
                            minImpact: MIN_IMPACT_SCORE,
                            maxRefines: 0  // Sem refinamento extra no preenchimento (mais rápido)
                        });
                        more.forEach(t => allGeneratedTitles.push({ ...t, model: cfg.name }));
                    } catch (e) {
                        console.warn(`[Análise Multimodal] Não foi possível preencher com ${cfg.name}:`, e.message);
                    }
                }
                fillRound++;
            }

            // Garantia: não exceder 15
            if (allGeneratedTitles.length > targetTotal) {
                allGeneratedTitles = allGeneratedTitles.slice(0, targetTotal);
            }
            
            // Log final do total de títulos multimodal
            console.log(`[Análise Multimodal] ✅ Total combinado: ${allGeneratedTitles.length} títulos (esperado: 15 = 5 de cada modelo)`);
            
            // SEMPRE usar dados derivados pelo backend (não depender da IA para análise e nicho)
            // Isso garante que análise e subnicho sempre estarão presentes
            const derivedNiche = deriveNicheAndSubnicheFromContext({
                originalTitle: videoDetails.title,
                translatedTitle,
                descriptionStart: videoDetails.description ? videoDetails.description.substring(0, 300) : '',
                transcriptStart: transcriptText || ''
            });
            finalNicheData = derivedNiche;
            finalAnalysisData = deriveTitleAnalysis({
                originalTitle: videoDetails.title,
                translatedTitle,
                views: videoDetails.views,
                days: videoDetails.days
            });
            
            // Se a primeira análise da IA tiver dados válidos, mesclar com os derivados (priorizar derivados)
            if (firstSuccessfulAnalysis && firstSuccessfulAnalysis.analiseOriginal) {
                // Manter análise derivada como principal, mas pode usar dados adicionais da IA se necessário
                console.log(`[Análise Multimodal] Análise da IA disponível, usando dados derivados como principal`);
            }
            
            console.log(`[Análise Multimodal] Dados derivados - Nicho: ${finalNicheData.niche}, Subnicho: ${finalNicheData.subniche}`);
            console.log(`[Análise Multimodal] Análise gerada:`, finalAnalysisData);
        } else {
            // --- LÓGICA DE MODELO ÚNICO (opcionalmente laozhang) ---
            let service;
            let decryptedKey;
            let apiCallFunction;
            let useLaozhang = false;
            
            // Verificar se laozhang está como padrão
            try {
                const laozhangDefaultSetting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
                const laozhangUseAsDefault = laozhangDefaultSetting && (
                    laozhangDefaultSetting.value === 'true' || 
                    laozhangDefaultSetting.value === '1' ||
                    JSON.parse(laozhangDefaultSetting.value) === true
                );
                
                if (laozhangUseAsDefault) {
                    const laozhangKey = await getLaozhangApiKey();
                    if (laozhangKey) {
                        service = 'laozhang';
                        decryptedKey = laozhangKey;
                        apiCallFunction = callLaozhangAPI;
                        useLaozhang = true;
                        console.log('[Análise-Laozhang.ai] Usando Laozhang.ai como padrão (configuração do admin)');
                    }
                }
            } catch (err) {
                console.warn('[Análise] Erro ao verificar laozhang.ai:', err.message);
            }
            
            // Preferência do usuário por créditos -> laozhang
            if (!useLaozhang) {
                const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
                const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
                if (useCredits) {
                    const laozhangKey = await getLaozhangApiKey();
                    if (laozhangKey) {
                        service = 'laozhang';
                        decryptedKey = laozhangKey;
                        apiCallFunction = callLaozhangAPI;
                        useLaozhang = true;
                        console.log('[Análise-Laozhang.ai] Usando Laozhang.ai (preferência: usar créditos)');
                    }
                }
            }
            
            // Caso contrário, usar API própria do usuário
            if (!useLaozhang) {
                if (model.startsWith('gemini')) service = 'gemini';
                else if (model.startsWith('claude')) service = 'claude';
                else if (model.startsWith('gpt')) service = 'openai';
                else service = 'gemini'; // fallback
                
                const userKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                if (!userKeyData) return res.status(400).json({ msg: `Nenhuma Chave de API do ${service} configurada.` });
                
                decryptedKey = decrypt(userKeyData.api_key);
                if (!decryptedKey) return res.status(500).json({ msg: 'Falha ao desencriptar a sua chave de API.' });

                if (service === 'gemini') apiCallFunction = callGeminiAPI;
                else if (service === 'claude') apiCallFunction = callClaudeAPI;
                else apiCallFunction = callOpenAIAPI;
            }

            // --- ETAPA 2: Chamar API selecionada (único modelo) ---
            let apiResponse;
            let rawResponse;
            console.log(`[Análise] Chamando ${useLaozhang ? 'Laozhang.ai' : service} com modelo ${model}...`);
            
            if (service === 'laozhang') {
                apiResponse = await apiCallFunction(titlePrompt, decryptedKey, model, null, userId, '/api/analyze/titles', JSON.stringify({ endpoint: '/api/analyze/titles', model, operation: 'single' }));
                rawResponse = typeof apiResponse === 'string' ? apiResponse : (apiResponse.titles || JSON.stringify(apiResponse));
            } else {
                apiResponse = await apiCallFunction(titlePrompt, decryptedKey, model);
                rawResponse = typeof apiResponse === 'string' ? apiResponse : apiResponse.titles;
            }
            
            console.log('[Análise] Resposta bruta (primeiros 500 chars):', String(rawResponse || '').substring(0, 500));
            
            // --- ETAPA 2.1: Extrair dados da resposta ---
            let parsedData;
            try {
                parsedData = parseTitleAnalysisResponse(rawResponse, service === 'laozhang' ? 'Laozhang.ai' : service, titlesRequired);
            } catch (parseErr) {
                console.error('[Análise] Erro ao parsear resposta:', parseErr.message);
                throw new Error('A resposta da IA não está no formato esperado.');
            }
            
            // Verificar se há títulos sugeridos
            if (!parsedData.titulosSugeridos || parsedData.titulosSugeridos.length === 0) {
                throw new Error('A IA não retornou títulos sugeridos.');
            }
            
            // Registrar títulos (SCORE 2 por backend) + gate Impacto>=7 com até 3 refinamentos
            const MIN_IMPACT_SCORE = 7;
            const passing = await generatePassingTitlesWithRefine({
                apiFunc: apiCallFunction,
                apiKey: decryptedKey,
                model,
                serviceName: service === 'laozhang' ? 'Laozhang.ai' : service,
                basePromptBuilder: buildTitleRefinePrompt,
                buildArgs: {
                    originalTitle: videoDetails.title,
                    translatedTitle,
                    performanceContext,
                    descriptionStart: videoDetails.description ? videoDetails.description.substring(0, 300) : 'N/A',
                    transcriptStart: transcriptText ? transcriptText.substring(0, 500) : '(Transcrição não disponível)',
                    languageInstruction
                },
                titlesRequired,
                minImpact: MIN_IMPACT_SCORE,
                maxRefines: 2
            });
            if (passing.length < titlesRequired) {
                throw new Error(`Não foi possível gerar ${titlesRequired} títulos com 🔥 Impacto ≥ ${MIN_IMPACT_SCORE}/10. Tente novamente.`);
            }

            allGeneratedTitles = passing.map(t => ({
                ...t,
                model: service === 'laozhang' ? 'Laozhang.ai' : model
            }));
            
            // SEMPRE usar dados derivados pelo backend (garantir que análise e subnicho sempre existam)
            const derivedNiche = deriveNicheAndSubnicheFromContext({
                originalTitle: videoDetails.title,
                translatedTitle,
                descriptionStart: videoDetails.description ? videoDetails.description.substring(0, 300) : '',
                transcriptStart: transcriptText || ''
            });
            finalNicheData = derivedNiche;
            finalAnalysisData = deriveTitleAnalysis({
                originalTitle: videoDetails.title,
                translatedTitle,
                views: videoDetails.views,
                days: videoDetails.days
            });
            
            // Se a análise da IA tiver dados válidos, pode mesclar (mas usar derivados como principal)
            if (parsedData && parsedData.analiseOriginal && parsedData.analiseOriginal.motivoSucesso !== 'N/A') {
                console.log(`[Análise] Análise da IA disponível, usando dados derivados como principal`);
            }
            
            console.log(`[Análise] Dados derivados - Nicho: ${finalNicheData.niche}, Subnicho: ${finalNicheData.subniche}`);
            console.log(`[Análise] Análise gerada:`, finalAnalysisData);
        }
        // --- FIM DA LÓGICA DO DISTRIBUIDOR ---

        // Log final: verificar quantos títulos foram gerados no total
        console.log(`[Análise] ✅ Total de títulos gerados: ${allGeneratedTitles.length}`);
        const titlesByModelFinal = {};
        allGeneratedTitles.forEach(t => {
            const model = t.model || 'Desconhecido';
            titlesByModelFinal[model] = (titlesByModelFinal[model] || 0) + 1;
        });
        console.log(`[Análise] Títulos por modelo antes de salvar:`, titlesByModelFinal);
        
        console.log('[Análise] Títulos gerados com sucesso.');

        // --- ETAPA 3: Salvar no Banco de Dados ---
        let analysisId;
        try {
             const analysisResult = await db.run(
                `INSERT INTO analyzed_videos (user_id, folder_id, youtube_video_id, video_url, original_title, translated_title, original_views, original_comments, original_days, original_thumbnail_url, detected_niche, detected_subniche, analysis_data_json, full_transcript) 
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                    userId, folderId || null, videoId, videoUrl, videoDetails.title, translatedTitle, videoDetails.views,
                    videoDetails.comments, videoDetails.days, videoDetails.thumbnailUrl,
                    finalNicheData.niche, finalNicheData.subniche, JSON.stringify(finalAnalysisData), fullTranscript
                ]
            );
            analysisId = analysisResult.lastID;

            console.log(`[Análise] Salvando ${allGeneratedTitles.length} títulos no banco de dados...`);
            console.log(`[Análise] Detalhes dos títulos a serem salvos:`, allGeneratedTitles.map(t => ({ model: t.model, titulo: t.titulo?.substring(0, 50) })));
            
            let savedCount = 0;
            for (const titleData of allGeneratedTitles) {
                try {
                    await db.run(
                        'INSERT INTO generated_titles (video_analysis_id, title_text, model_used, pontuacao, impact_score, explicacao, formula) VALUES (?, ?, ?, ?, ?, ?, ?)',
                        [analysisId, titleData.titulo, titleData.model, titleData.pontuacao, titleData.impact_score ?? null, titleData.explicacao, titleData.formula ?? null]
                    );
                    savedCount++;
                } catch (saveErr) {
                    console.error(`[Análise] Erro ao salvar título:`, saveErr.message, titleData);
                }
            }
            
            // Verificar quantos títulos foram salvos
            const savedTitles = await db.all('SELECT model_used, COUNT(*) as count FROM generated_titles WHERE video_analysis_id = ? GROUP BY model_used', [analysisId]);
            console.log(`[Análise] Total de títulos salvos: ${savedCount} de ${allGeneratedTitles.length}`);
            console.log(`[Análise] Títulos salvos por modelo:`, savedTitles);
            console.log(`[Análise] Análise ${analysisId} salva no histórico (Pasta: ${folderId || 'Nenhuma'}).`);
        } catch (dbErr) {
            console.error("[Análise] FALHA AO SALVAR NO BANCO DE DADOS:", dbErr.message);
        }

        // --- ETAPA 4: Calcular Receita e RPM baseado no nicho ---
        let estimatedRevenueUSD = 0;
        let estimatedRevenueBRL = 0;
        let rpmUSD = 2.0;
        let rpmBRL = 11.0;
        
        try {
            // Calcular receita e RPM sempre, mesmo se o nicho não foi detectado
            const nicheToUse = (finalNicheData && finalNicheData.niche) ? finalNicheData.niche : null;
            const rpm = getRPMByNiche(nicheToUse); // getRPMByNiche retorna padrão se niche for null
            
            // Verificar se rpm foi retornado corretamente
            if (!rpm || typeof rpm !== 'object' || typeof rpm.usd !== 'number' || typeof rpm.brl !== 'number') {
                console.warn('[Análise] RPM inválido, usando valores padrão', { rpm, niche: nicheToUse });
                // Usar valores padrão se rpm for inválido
                const defaultRPM = { usd: 2.0, brl: 11.0 };
                const views = parseInt(videoDetails.views) || 0;
                estimatedRevenueUSD = (views / 1000) * defaultRPM.usd;
                estimatedRevenueBRL = (views / 1000) * defaultRPM.brl;
                rpmUSD = defaultRPM.usd;
                rpmBRL = defaultRPM.brl;
            } else {
                const views = parseInt(videoDetails.views) || 0;
                estimatedRevenueUSD = (views / 1000) * rpm.usd;
                estimatedRevenueBRL = (views / 1000) * rpm.brl;
                rpmUSD = rpm.usd;
                rpmBRL = rpm.brl;
            }
            
            // Garantir que todas as variáveis estão definidas e são números válidos
            if (typeof estimatedRevenueUSD !== 'number' || isNaN(estimatedRevenueUSD)) {
                console.warn('[Análise] estimatedRevenueUSD inválido, recalculando', { estimatedRevenueUSD, rpm, views: videoDetails.views });
                const views = parseInt(videoDetails.views) || 0;
                estimatedRevenueUSD = (views / 1000) * rpm.usd;
                estimatedRevenueBRL = (views / 1000) * rpm.brl;
            }
            
            console.log('[Análise] Receita calculada:', {
                views: videoDetails.views,
                niche: nicheToUse || 'padrão',
                rpmUSD,
                rpmBRL,
                estimatedRevenueUSD: estimatedRevenueUSD.toFixed(2),
                estimatedRevenueBRL: estimatedRevenueBRL.toFixed(2)
            });
        } catch (revenueErr) {
            console.error('[Análise] Erro ao calcular receita:', revenueErr);
            // Usar valores padrão em caso de erro
            const views = parseInt(videoDetails.views) || 0;
            estimatedRevenueUSD = (views / 1000) * 2.0;
            estimatedRevenueBRL = (views / 1000) * 11.0;
            rpmUSD = 2.0;
            rpmBRL = 11.0;
        }

        // --- ETAPA 5: Enviar Resposta (com IDs dos títulos, receita e RPM) ---
        const finalTitlesWithIds = await db.all('SELECT id, title_text as titulo, model_used as model, pontuacao, impact_score, explicacao, formula, is_checked FROM generated_titles WHERE video_analysis_id = ?', [analysisId]);

        // NÃO salvar automaticamente - apenas quando o usuário marcar o checkbox
        // O salvamento será feito quando o usuário marcar o título como selecionado
        console.log(`[Biblioteca] Títulos gerados aguardando seleção do usuário para salvar na biblioteca`);
        
        // Garantir que todas as variáveis estão definidas antes de enviar
        // Formatar modelo para exibição se necessário
        const formatModelForResponse = (modelName) => {
            if (!modelName) return 'GPT-4o';
            if (modelName === 'GPT-4o (2025)' || modelName === 'Claude 3.7 Sonnet (Fev/25)' || modelName === 'Gemini 2.5 Pro (2025)') {
                return modelName.replace(' (2025)', '').replace(' (Fev/25)', '');
            }
            if (modelName.includes('claude-3-7-sonnet') || modelName.includes('Claude 3.7 Sonnet')) {
                return 'Claude 3.7 Sonnet';
            } else if (modelName.includes('gemini-2.5-pro') || modelName.includes('Gemini 2.5 Pro')) {
                return 'Gemini 2.5 Pro';
            } else if (modelName.includes('gpt-4o') || modelName.includes('GPT-4o')) {
                return 'GPT-4o';
            }
            return modelName;
        };
        
        // Garantir que os títulos do banco tenham o modelo formatado corretamente
        const formattedTitles = (finalTitlesWithIds || []).map(t => ({
            ...t,
            model: formatModelForResponse(t.model || model)
        }));
        
        const responseData = {
            niche: finalNicheData?.niche || 'N/A',
            subniche: finalNicheData?.subniche || 'N/A',
            analiseOriginal: finalAnalysisData || {},
            titulosSugeridos: formattedTitles,
            modelUsed: formatModelForResponse(model) || 'GPT-4o', 
            videoDetails: { 
                ...videoDetails, 
                videoId: videoId, 
                originalTitle: videoDetails.title, // Título original no idioma original
                translatedTitle: translatedTitle || videoDetails.title, // Tradução em PT-BR (sempre disponível)
                estimatedRevenueUSD: typeof estimatedRevenueUSD === 'number' ? estimatedRevenueUSD : 0,
                estimatedRevenueBRL: typeof estimatedRevenueBRL === 'number' ? estimatedRevenueBRL : 0,
                rpmUSD: typeof rpmUSD === 'number' ? rpmUSD : 2.0,
                rpmBRL: typeof rpmBRL === 'number' ? rpmBRL : 11.0
            },
            language: language, // Idioma escolhido para os títulos gerados
            folderId: folderId || null
        };
        
        // Log para debug - garantir que análise e subnicho estão presentes
        console.log('[Análise] Enviando resposta:', {
            niche: responseData.niche,
            subniche: responseData.subniche,
            hasAnaliseOriginal: !!responseData.analiseOriginal,
            analiseOriginal: responseData.analiseOriginal,
            hasEstimatedRevenueUSD: typeof responseData.videoDetails.estimatedRevenueUSD !== 'undefined',
            estimatedRevenueUSD: responseData.videoDetails.estimatedRevenueUSD,
            hasRpmUSD: typeof responseData.videoDetails.rpmUSD !== 'undefined',
            rpmUSD: responseData.videoDetails.rpmUSD
        });

        // Garantir que análise e subnicho sempre estão presentes na resposta
        if (!responseData.analiseOriginal || Object.keys(responseData.analiseOriginal).length === 0) {
            console.warn('[Análise] ⚠️ Análise vazia detectada, usando dados derivados');
            responseData.analiseOriginal = finalAnalysisData || {
                motivoSucesso: 'Análise gerada automaticamente pelo sistema',
                formulaTitulo: 'Fórmula derivada do título original'
            };
        }
        
        if (!responseData.niche || responseData.niche === 'N/A') {
            console.warn('[Análise] ⚠️ Nicho não detectado, usando dados derivados');
            responseData.niche = finalNicheData?.niche || 'Entretenimento';
        }
        
        if (!responseData.subniche || responseData.subniche === 'N/A') {
            console.warn('[Análise] ⚠️ Subnicho não detectado, usando dados derivados');
            responseData.subniche = finalNicheData?.subniche || 'Geral';
        }

        res.status(200).json(responseData);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/analyze/titles]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao processar a análise.' });
    }
});

// Rota alternativa que SEMPRE usa Laozhang.ai para análise de títulos
app.post('/api/analyze/titles/laozhang', authenticateToken, async (req, res) => {
    const { videoUrl, model: requestedModel, folderId, language } = req.body;
    const userId = req.user.id;
    const selectedLanguage = language || 'Português'; // Idioma padrão: Português
    
    // Garantir que modelToUse seja o modelo original do frontend para exibição
    const modelToUse = requestedModel || 'gpt-4o';

    if (!videoUrl) {
        return res.status(400).json({ msg: 'URL do vídeo é obrigatória.' });
    }
    
    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível. Aguarde alguns instantes.' });
        }

        // Determinar qual modelo usar (se especificado, usar ele; senão, usar gpt-4o como padrão)
        let modelToUse = requestedModel || 'gpt-4o';
        // Mapear modelos para os nomes corretos da laozhang.ai
        if (modelToUse === 'gpt-4o') {
            modelToUse = 'gpt-4o';
        } else if (modelToUse === 'claude-3-7-sonnet-20250219') {
            modelToUse = 'claude-3-7-sonnet-20250219';
        } else if (modelToUse === 'gemini-2.5-pro') {
            modelToUse = 'gemini-2.5-pro';
        }

        // Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem plano que permite API própria OU não tem API própria configurada
        // REGRA CRÍTICA: Se preferência NÃO está marcada E usuário tem plano que permite E tem API própria → usar API própria
        let useLaozhang = false;
        let apiKeyToUse = null;
        let serviceToUse = null;
        let apiCallFunction = null;
        
        try {
            const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
            
            if (creditsCheck.shouldUse) {
                // Se deve usar créditos, usar laozhang.ai
                const laozhangKey = await getLaozhangApiKey();
                if (laozhangKey) {
                    useLaozhang = true;
                    apiKeyToUse = laozhangKey;
                    serviceToUse = 'laozhang';
                    apiCallFunction = callLaozhangAPI;
                    console.log(`[Análise Laozhang] ✅ Usando Laozhang.ai (${creditsCheck.reason})`);
                } else {
                    console.warn('[Análise Laozhang] ⚠️ Laozhang.ai não configurada, tentando usar APIs próprias do usuário');
                }
            } else {
                console.log(`[Análise Laozhang] ✅ Usando API própria (${creditsCheck.reason})`);
            }
        } catch (err) {
            console.warn('[Análise Laozhang] Erro ao verificar uso de créditos:', err.message);
        }
        
        // Se não usar laozhang.ai, usar APIs próprias do usuário
        if (!useLaozhang) {
            // Determinar qual serviço usar baseado no modelo
            if (modelToUse.includes('claude') || modelToUse.includes('sonnet')) {
                serviceToUse = 'claude';
            } else if (modelToUse.includes('gemini')) {
                serviceToUse = 'gemini';
            } else if (modelToUse.includes('gpt') || modelToUse.includes('openai')) {
                serviceToUse = 'openai';
            } else {
                serviceToUse = 'gemini'; // fallback
            }
            
            // Buscar API key do serviço apropriado
            const keyData = await db.get(
                'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                [userId, serviceToUse]
            );
            
            if (!keyData || !keyData.api_key) {
                return res.status(400).json({ 
                    msg: `API key do ${serviceToUse === 'openai' ? 'OpenAI' : serviceToUse === 'gemini' ? 'Gemini' : 'Claude'} não configurada. Configure nas Configurações.` 
                });
            }
            
            apiKeyToUse = decrypt(keyData.api_key);
            if (!apiKeyToUse) {
                return res.status(500).json({ msg: 'Erro ao descriptografar API key.' });
            }
            
            // Definir função de API apropriada
            if (serviceToUse === 'gemini') {
                apiCallFunction = callGeminiAPI;
            } else if (serviceToUse === 'claude') {
                apiCallFunction = callClaudeAPI;
            } else {
                apiCallFunction = callOpenAIAPI;
            }
        }

        // Mineração de dados (mesma lógica da rota original)
        console.log(`[Análise Laozhang] A iniciar mineração para: ${videoUrl}`);
        let videoId;
        try {
            videoId = ytdl.getVideoID(videoUrl);
        } catch (err) {
            return res.status(400).json({ msg: 'URL do YouTube inválida.' });
        }

        // Tentar usar chave específica do YouTube primeiro, depois fallback para Gemini
        let youtubeApiKey = null;
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
            if (!youtubeApiKey && youtubeKeyData.api_key && !youtubeKeyData.api_key.includes(':')) {
                // Chave pode não estar criptografada
                youtubeApiKey = youtubeKeyData.api_key;
            }
            console.log('[Análise Laozhang] Usando chave do YouTube configurada');
        }
        
        // Se não tem chave do YouTube, tentar usar Gemini (pode funcionar se for chave do Google Cloud)
        if (!youtubeApiKey) {
            const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
                if (!youtubeApiKey && geminiKeyData.api_key && !geminiKeyData.api_key.includes(':')) {
                    youtubeApiKey = geminiKeyData.api_key;
                }
                console.log('[Análise Laozhang] Usando chave do Gemini como fallback para YouTube');
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ 
                msg: 'Nenhuma chave de API do YouTube configurada. Configure uma chave do YouTube Data API v3 nas Configurações.' 
            });
        }

        const videoDetails = await callYouTubeDataAPI(videoId, youtubeApiKey);
        
        let transcriptText;
        let fullTranscript = null;
        try {
            const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
            fullTranscript = transcriptData.map(t => t.text).join(' ');
            transcriptText = fullTranscript.substring(0, 500);
        } catch (err) {
            console.warn(`[Análise Laozhang] Não foi possível obter transcrição para ${videoId}.`);
            transcriptText = "(Transcrição não disponível)";
            fullTranscript = null;
        }
        
        console.log(`[Análise Laozhang] Vídeo encontrado: ${videoDetails.title}`);

        // Tradução: para evitar requisições duplicadas ao provedor, usar o título original diretamente
        // Se desejar tradução, podemos incluir no mesmo prompt de análise futuramente
        let translatedTitle = videoDetails.title;

        // Criar prompt de análise (mesmo da rota original, mas simplificado para laozhang)
        const viewsPerDay = Math.round(videoDetails.views / Math.max(videoDetails.days, 1));
        const isViral = isViralVideo(videoDetails.views, videoDetails.days, viewsPerDay);
        
        const languageInstruction = selectedLanguage === 'Português' ? 'EM PORTUGUÊS BRASILEIRO (PT-BR)' : selectedLanguage === 'Inglês' ? 'EM INGLÊS (EN)' : selectedLanguage === 'Espanhol' ? 'EM ESPANHOL (ES)' : 'EM PORTUGUÊS BRASILEIRO (PT-BR)';
        const titlesRequired = 5;
        const MIN_IMPACT_SCORE = 7;
        const performanceContext = `Este vídeo tem ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias (média de ${viewsPerDay.toLocaleString()} views/dia) e foi classificado como ${isViral ? 'VIRAL' : 'Popular'}.`;
        const titlePrompt = buildTitleRefinePrompt({
            originalTitle: videoDetails.title,
            translatedTitle,
            performanceContext,
            descriptionStart: 'N/A',
            transcriptStart: transcriptText ? transcriptText.substring(0, 500) : '(Transcrição não disponível)',
            languageInstruction,
            titlesRequired,
            minImpact: MIN_IMPACT_SCORE
        });

        // Chamar API apropriada (Laozhang ou API própria)
        let response;
        let responseText;
        
        if (useLaozhang) {
            console.log('[Análise Laozhang] A chamar Laozhang.ai...');
            response = await callLaozhangAPI(
                titlePrompt, 
                apiKeyToUse, 
                modelToUse, 
                null, 
                userId, 
                '/api/analyze/titles/laozhang', 
                JSON.stringify({ endpoint: '/api/analyze/titles/laozhang', model: modelToUse })
            );
            // callLaozhangAPI retorna string diretamente agora
            responseText = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        } else {
            console.log(`[Análise Laozhang] A chamar API própria (${serviceToUse})...`);
            const apiResponse = await apiCallFunction(titlePrompt, apiKeyToUse, modelToUse);
            // APIs próprias retornam objeto com propriedade titles
            responseText = typeof apiResponse === 'string' ? apiResponse.trim() : (apiResponse.titles || JSON.stringify(apiResponse));
        }
        console.log(`[Análise Laozhang] Resposta recebida (primeiros 500 chars):`, responseText.substring(0, 500));
        const serviceNameForParse = useLaozhang ? 'Laozhang.ai' : (serviceToUse === 'openai' ? 'OpenAI' : serviceToUse === 'claude' ? 'Claude' : 'Gemini');
        const parsedData = parseTitleAnalysisResponse(responseText, serviceNameForParse, 5);
        const passing = await generatePassingTitlesWithRefine({
            apiFunc: apiCallFunction,
            apiKey: apiKeyToUse,
            model: modelToUse,
            serviceName: serviceNameForParse,
            basePromptBuilder: buildTitleRefinePrompt,
            buildArgs: {
                originalTitle: videoDetails.title,
                translatedTitle,
                performanceContext,
                descriptionStart: 'N/A',
                transcriptStart: transcriptText ? transcriptText.substring(0, 500) : '(Transcrição não disponível)',
                languageInstruction
            },
            titlesRequired,
            minImpact: MIN_IMPACT_SCORE,
            maxRefines: 2
        });
        if (passing.length < titlesRequired) throw new Error(`Não foi possível gerar ${titlesRequired} títulos com 🔥 Impacto ≥ ${MIN_IMPACT_SCORE}/10. Tente novamente.`);
        
        if (!parsedData.analiseOriginal) {
            throw new Error("A IA retornou uma análise incompleta.");
        }
        
        const finalNicheData = { 
            niche: parsedData.niche || 'Entretenimento', 
            subniche: parsedData.subniche || 'N/A' 
        };
        const finalAnalysisData = parsedData.analiseOriginal;
        // Função para formatar modelo do frontend para exibição
        const formatModelForDisplay = (modelName) => {
            if (!modelName) return 'GPT-4o';
            // Se já está no formato de exibição do frontend, retornar formatado
            if (modelName === 'GPT-4o (2025)' || modelName === 'Claude 3.7 Sonnet (Fev/25)' || modelName === 'Gemini 2.5 Pro (2025)') {
                return modelName.replace(' (2025)', '').replace(' (Fev/25)', '');
            }
            // Mapear formatos técnicos para nomes amigáveis
            if (modelName.includes('claude-3-7-sonnet') || modelName.includes('Claude 3.7 Sonnet')) {
                return 'Claude 3.7 Sonnet';
            } else if (modelName.includes('gemini-2.5-pro') || modelName.includes('Gemini 2.5 Pro')) {
                return 'Gemini 2.5 Pro';
            } else if (modelName.includes('gpt-4o') || modelName.includes('GPT-4o')) {
                return 'GPT-4o';
            } else if (modelName.includes('claude')) {
                return 'Claude 3.7 Sonnet';
            } else if (modelName.includes('gemini')) {
                return 'Gemini 2.5 Pro';
            } else if (modelName.includes('gpt')) {
                return 'GPT-4o';
            }
            return modelName;
        };
        
        // Usar o modelo original do frontend (modelToUse) para exibição, não o mapeado para API
        // modelToUse vem do req.body.model que é o modelo selecionado no frontend
        const modelNameForDisplay = formatModelForDisplay(modelToUse);
        console.log(`[Análise Laozhang] Modelo para exibição: "${modelToUse}" -> Formatado: "${modelNameForDisplay}"`);
        const allGeneratedTitles = passing.map(t => ({
            ...t,
            impact_score: computeImpactVisualScore(t.titulo),
            model: modelNameForDisplay
        }));

        // Salvar no banco
        let analysisId;
        try {
             const analysisResult = await db.run(
                `INSERT INTO analyzed_videos (user_id, folder_id, youtube_video_id, video_url, original_title, translated_title, original_views, original_comments, original_days, original_thumbnail_url, detected_niche, detected_subniche, analysis_data_json, full_transcript) 
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                    userId, folderId || null, videoId, videoUrl, videoDetails.title, translatedTitle, videoDetails.views,
                    videoDetails.comments, videoDetails.days, videoDetails.thumbnailUrl,
                    finalNicheData.niche, finalNicheData.subniche, JSON.stringify(finalAnalysisData), fullTranscript
                ]
            );
            analysisId = analysisResult.lastID;

            for (const titleData of allGeneratedTitles) {
                await db.run(
                    'INSERT INTO generated_titles (video_analysis_id, title_text, model_used, pontuacao, impact_score, explicacao, formula) VALUES (?, ?, ?, ?, ?, ?, ?)',
                    [analysisId, titleData.titulo, titleData.model, titleData.pontuacao, titleData.impact_score ?? null, titleData.explicacao, titleData.formula ?? null]
                );
            }
            console.log(`[Análise Laozhang] Análise ${analysisId} salva no histórico.`);
        } catch (dbErr) {
            console.error("[Análise Laozhang] FALHA AO SALVAR NO BANCO DE DADOS:", dbErr.message);
        }

        // Calcular receita (mesma lógica)
        let estimatedRevenueUSD = 0;
        let estimatedRevenueBRL = 0;
        let rpmUSD = 2.0;
        let rpmBRL = 11.0;
        
        try {
            const nicheToUse = finalNicheData.niche || null;
            const rpm = getRPMByNiche(nicheToUse);
            if (rpm && typeof rpm === 'object' && typeof rpm.usd === 'number' && typeof rpm.brl === 'number') {
                const views = parseInt(videoDetails.views) || 0;
                estimatedRevenueUSD = (views / 1000) * rpm.usd;
                estimatedRevenueBRL = (views / 1000) * rpm.brl;
                rpmUSD = rpm.usd;
                rpmBRL = rpm.brl;
            }
        } catch (err) {
            console.warn('[Análise Laozhang] Erro ao calcular receita:', err);
        }

        res.status(200).json({
            niche: finalNicheData.niche,
            subniche: finalNicheData.subniche,
            analiseOriginal: finalAnalysisData,
            titulosSugeridos: allGeneratedTitles,
            modelUsed: modelNameForDisplay || 'GPT-4o',
            videoDetails: {
                ...videoDetails,
                videoId: videoId,
                originalTitle: videoDetails.title, // Título original no idioma original
                translatedTitle: translatedTitle || videoDetails.title, // Tradução em PT-BR (sempre disponível)
                estimatedRevenueUSD: estimatedRevenueUSD,
                estimatedRevenueBRL: estimatedRevenueBRL,
                rpmUSD: rpmUSD,
                rpmBRL: rpmBRL
            },
            language: selectedLanguage, // Idioma escolhido para os títulos gerados
            folderId: folderId || null
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/analyze/titles/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao processar a análise.' });
    }
});

app.put('/api/titles/:titleId/check', authenticateToken, async (req, res) => {
    const { titleId } = req.params;
    const { is_checked } = req.body;
    const userId = req.user.id;

    try {
        console.log(`[Biblioteca] Recebida requisição para atualizar título ${titleId}, is_checked: ${is_checked}, userId: ${userId}`);
        
        // Buscar informações do título antes de atualizar
        const titleData = await db.get(`
            SELECT gt.id, gt.title_text, gt.pontuacao, gt.impact_score, gt.video_analysis_id, av.detected_niche, av.detected_subniche, av.original_views, av.analysis_data_json
            FROM generated_titles gt
            INNER JOIN analyzed_videos av ON gt.video_analysis_id = av.id
            WHERE gt.id = ? AND av.user_id = ?
        `, [titleId, userId]);

        if (!titleData) {
            console.error(`[Biblioteca] Título ${titleId} não encontrado para usuário ${userId}`);
            return res.status(404).json({ msg: 'Título não encontrado ou não pertence a este utilizador.' });
        }
        
        console.log(`[Biblioteca] Dados do título encontrado:`, {
            id: titleData.id,
            title: titleData.title_text?.substring(0, 50),
            niche: titleData.detected_niche,
            subniche: titleData.detected_subniche,
            views: titleData.original_views,
            score: titleData.pontuacao
        });

        // Atualiza o status do título específico
        const result = await db.run(
            `UPDATE generated_titles SET is_checked = ? 
             WHERE id = ? AND video_analysis_id IN (SELECT id FROM analyzed_videos WHERE user_id = ?)`,
            [is_checked, titleId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Título não encontrado ou não pertence a este utilizador.' });
        }

        // Se o título foi marcado (is_checked = true), salvar na biblioteca
        if (is_checked) {
            try {
                console.log(`[Biblioteca] Tentando salvar título marcado: ${titleId} para usuário ${userId}`);
                const cleanTitle = titleData.title_text.replace(/^\[.*?\]\s*/, ''); // Remove prefixo [Gemini], [Claude], etc
                const analysisData = titleData.analysis_data_json ? JSON.parse(titleData.analysis_data_json) : null;
                
                console.log(`[Biblioteca] Título limpo: "${cleanTitle.substring(0, 50)}..."`);
                console.log(`[Biblioteca] Dados:`, {
                    niche: titleData.detected_niche,
                    subniche: titleData.detected_subniche,
                    views: titleData.original_views,
                    score: titleData.pontuacao,
                    formula: analysisData?.formulaTitulo || null
                });
                
                // Verificar se já existe na biblioteca para evitar duplicatas
                const existing = await db.get(
                    'SELECT id FROM viral_titles_library WHERE user_id = ? AND title = ?',
                    [userId, cleanTitle]
                );

                if (existing) {
                    console.log(`[Biblioteca] Título já existe na biblioteca (ID: ${existing.id}), pulando inserção`);
                } else {
                    const result = await db.run(
                        `INSERT INTO viral_titles_library (user_id, title, niche, subniche, original_views, formula_type, viral_score)
                         VALUES (?, ?, ?, ?, ?, ?, ?)`,
                        [userId, cleanTitle, titleData.detected_niche, titleData.detected_subniche, titleData.original_views, analysisData?.formulaTitulo || null, titleData.pontuacao || null]
                    );
                    console.log(`[Biblioteca] ✅ Título "${cleanTitle.substring(0, 50)}..." salvo na biblioteca (ID: ${result.lastID})`);
                }
            } catch (libErr) {
                console.error('[Biblioteca] ❌ Erro ao salvar título marcado na biblioteca:', libErr);
                console.error('[Biblioteca] Stack trace:', libErr.stack);
            }
        } else {
            console.log(`[Biblioteca] Título ${titleId} foi desmarcado, não será salvo na biblioteca`);
        }

        res.status(200).json({ msg: 'Status do título atualizado.' });
    } catch (err) {
        console.error('Erro ao atualizar status do título:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});
// Função helper para mapear estilos de arte para prompts específicos otimizados (mesmos estilos de prompts e imagens)
function getStyleSpecificPrompt(style, includePhrases) {
    // Mapear estilos do gerador de thumbnails para os estilos de prompts/imagens
    const styleMapping = {
        'Hiper-realista': 'photorealistic',
        'Fotografia de alta definicao (8K)': 'photorealistic',
        'Estilo cinematico (luz dramatica)': 'cinematic',
        'Foco nitido, alto detalhe': 'photorealistic',
        'Longa Exposicao': 'documentary',
        'Preto e Branco': 'documentary',
        'Fotografia Macro': 'photorealistic',
        'Diorama Cinematográfico Narrativo': 'cinematic-diorama',
        'Cinematic Diorama': 'cinematic-diorama',
        'Diorama Narrativo': 'cinematic-diorama',
        'Narrativa Diorama': 'cinematic-diorama',
        'Realismo Miniaturizado': 'cinematic-diorama'
    };
    
    // Se o estilo já for um dos estilos de prompts/imagens, usar diretamente
    const mappedStyle = styleMapping[style] || style;
    
    // Usar os mesmos sufixos de estilo que são usados em prompts/imagens
    const styleSuffixes = {
        'photorealistic': 'Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyperrealistic, ultra high definition, 8K resolution, extreme sharpness, maximum detail, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography, taken with a high-end camera like a Sony α7 IV, detailed skin texture with pores visible in 8K, natural lighting, real textures with visible imperfections in ultra HD, real lighting with real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, extreme detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, National Geographic quality, BBC documentary style',
        'cinematic': 'Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, cinematic, dramatic lighting, film grain, anamorphic lens, color grading, movie still, Hollywood style, epic composition, dramatic shadows, professional color grading, cinematic composition, film noir lighting style, dramatic atmosphere',
        'documentary': 'Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, documentary style, natural lighting, authentic, candid photography, real moments, journalistic approach, raw and unfiltered',
        'cinematic-narrative': 'Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, cinematic narrative, storytelling composition, dramatic angles, emotional depth, visual storytelling, film photography',
        'anime': 'anime style, Japanese animation, vibrant colors, expressive characters, detailed backgrounds, manga-inspired, cel-shaded',
        'cartoon': 'cartoon style, animated, colorful, expressive, playful, hand-drawn aesthetic, vibrant palette',
        'cartoon-premium': 'premium cartoon style, high-quality animation, detailed character design, rich colors, professional animation studio quality',
        'fantasy': 'fantasy art, magical atmosphere, epic scale, mystical lighting, enchanted, otherworldly, detailed fantasy illustration',
        'stick-figure': 'stick figure style, minimalist line art, simple black lines on white background, clean and minimal',
        'whiteboard': 'whiteboard animation style, clean white background, hand-drawn illustrations, educational, clear and simple',
        'tech-minimalist': 'tech minimalist, clean design, modern aesthetic, geometric shapes, minimal color palette, futuristic, sleek',
        'spiritual-minimalist': 'spiritual minimalist, serene atmosphere, soft lighting, peaceful composition, meditative, zen aesthetic',
        'viral-vibrant': 'viral vibrant style, high contrast, saturated colors, bold composition, eye-catching, social media optimized, vibrant and energetic',
        'modern-documentary': 'modern documentary style, dynamic, contemporary, authentic moments, modern cinematography',
        'analog-horror': 'analog horror style, VHS quality, grainy texture, retro horror aesthetic, vintage feel',
        'dark-theater': 'dark theater style, dramatic stage lighting, intense shadows, theatrical composition',
        'naturalist-drama': 'naturalist drama style, realistic, emotional, authentic human moments',
        'spiritual-neorealism': 'spiritual neorealism style, transcendent realism, mystical atmosphere',
        'psychological-surrealism': 'psychological surrealism style, dreamlike images, abstract reality',
        'fragmented-memory': 'fragmented memory style, collage aesthetic, fragmented composition',
        'fragmented-narrative': 'fragmented narrative style, collage style, layered visual narrative',
        'dream-real': 'dream-real style, liminal space between dream and reality, ethereal atmosphere',
        'vhs-nostalgic': 'VHS nostalgic style, retro 80s/90s aesthetic, vintage quality, analog grain',
        'cinematic-diorama': 'Cinematic diorama-style scene, miniature environment designed like a handcrafted scale model, diorama-style environment, scale model aesthetic, handcrafted set. Stylized human figures with simplified, sculpted features and faceted geometry, low-detail facial features, sculpted characters, stylized human figures. Story-driven composition, dramatic cinematic lighting with practical light sources, soft volumetric shadows, low-key lighting, cinematic lighting. Shallow depth of field, tilt-shift effect, tilt-shift perspective, narrative camera angle, story-driven camera angle, diorama perspective, cinematic depth of field. Matte textures, subtle imperfections, handcrafted textures, matte surfaces, handcrafted look. Emotional storytelling atmosphere, frozen moment in time, metaphorical visual, staged scene, narrative depth, miniature scene aesthetic, maquette-style environment'
    };
    
    return styleSuffixes[mappedStyle] || styleSuffixes['photorealistic'];
}

// Função helper para gerar âncora visual global baseada no estilo escolhido
function getGlobalVisualAnchor(style) {
    const defaultStyle = style || 'photorealistic';
    
    // Estilos que usam a âncora de diorama (estilo atual fixo)
    const dioramaStyles = ['cinematic-diorama'];
    
    // Se for diorama, usar a âncora fixa atual
    if (dioramaStyles.includes(defaultStyle)) {
        return `
🧩 GLOBAL VISUAL IDENTITY — LOCKED:

The entire story exists inside a cinematic narrative diorama.
All environments are handcrafted miniature scale models,
the world feels like a physical maquette filmed up close.

All characters, including close-ups and portraits,
must appear as stylized sculpted figures,
never as real human faces.

All faces must retain a sculpted, physical miniature appearance.
No natural photographic skin softness.
Faces should look like crafted figures, not real people,
even in close-up shots.

Consistent semi-stylized realism across all scenes,
no photorealistic skin, no natural human softness.

Matte materials, handcrafted textures,
subtle imperfections, physical model feel.

Cinematic depth of field,
controlled perspective,
subtle tilt-shift to reinforce miniature scale.

Every frame must look like a frozen cinematic moment
from the same miniature world.

⚠️ This text NEVER changes. NEVER.
⚠️ If a scene looks like it could be a real photograph, it's wrong.
⚠️ It must look like a filmed miniature, not a filmed person.

🚫 NEGATIVE PROMPT — ÚLTIMO REFORÇO:
photorealistic humans,
hyper-detailed skin,
real-world full scale environments,
life-size architecture,
photographic realism,
cinema movie still look,
video game graphics,
cartoon style,
anime style,
plastic or glossy materials,
stop-motion puppets,
toy-like exaggeration,
full-scale real world,
wide open real locations,
global illumination,
neutral camera angles,
real human skin texture,
natural photographic portrait,
beauty photography lighting,
hyper-smooth faces,
ultra-real close-up photography,
photographic portrait,
beauty photography,
natural skin translucency,
cinema realism close-up

⚠️ If any of these appear visually, the scene has failed.

WHAT CAN VARY (WITHOUT BREAKING STYLE):
✅ Lighting (warm / cold)
✅ Time of day
✅ Emotion
✅ Action
✅ Narrative framing

WHAT NEVER VARIES:
❌ Scale
❌ Character type (always stylized sculpted figures)
❌ Material (always matte, handcrafted)
❌ Camera language (always story-driven)
❌ Realism level (always semi-stylized, never photorealistic)

SCENE VALIDATION CHECKLIST (ALL MUST BE YES):
- Does it look like a physical miniature?
- Could it fit on a table?
- Do people look like sculpted figures, not actors?
- Do close-ups look like stylized sculptures, not real faces?
- Does light look controlled, not randomly natural?
- Does it look like a frame from the same film as all others?

If any answer is NO → regenerate the scene.

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "as if filmed inside a handcrafted scale model"
- "the environment feels like a physical miniature set"
- "miniature world with cinematic lighting"
`;
    }
    
    // Para outros estilos, usar a descrição do estilo específico
    const stylePrompt = getStyleSpecificPrompt(defaultStyle, true);
    
    // Criar âncora visual baseada no estilo
    const styleAnchors = {
        'photorealistic': `
📸 GLOBAL VISUAL IDENTITY — PHOTOREALISTIC:

All scenes must maintain photorealistic quality with ultra-high-definition detail.
Real-world photography aesthetic, professional camera quality.
Natural human features, realistic skin textures, authentic environments.
Professional photography lighting, real-world depth of field.
Every frame must look like a professional photograph.

⚠️ CRITICAL: Maintain photorealistic quality throughout all scenes.
⚠️ Use real-world proportions, natural lighting, authentic textures.

🚫 NEGATIVE PROMPT:
cartoon style, anime style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized, artistic interpretation, miniature, diorama,
toy-like, exaggerated features, non-realistic proportions

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "professional photography, ultra-high-definition"
- "real-world photography, authentic detail"
- "photorealistic quality, natural lighting"
`,
        'cinematic': `
🎬 GLOBAL VISUAL IDENTITY — CINEMATIC:

All scenes must maintain cinematic Hollywood-style quality.
Dramatic lighting, film-like composition, emotional depth.
Professional cinematography, movie still aesthetic.
Epic composition, dramatic shadows, controlled color palette.
Every frame must look like a frame from a Hollywood film.

⚠️ CRITICAL: Maintain cinematic quality throughout all scenes.
⚠️ Use dramatic lighting, film composition, emotional storytelling.

🚫 NEGATIVE PROMPT:
documentary style, natural lighting, flat composition, cartoon style,
anime style, illustration, drawing, artwork, digital art, render, 3D, CGI,
stylized, artistic interpretation, miniature, diorama, toy-like

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "cinematic composition, dramatic lighting"
- "Hollywood-style cinematography, film-like quality"
- "dramatic film aesthetic, emotional depth"
`,
        'documentary': `
📹 GLOBAL VISUAL IDENTITY — DOCUMENTARY:

All scenes must maintain documentary-style authenticity.
Natural lighting, authentic moments, journalistic approach.
Real-world photography, candid moments, authentic human experiences.
Natural color grading, realistic environments, genuine emotions.
Every frame must look like a documentary photograph.

⚠️ CRITICAL: Maintain documentary authenticity throughout all scenes.
⚠️ Use natural lighting, authentic moments, journalistic approach.

🚫 NEGATIVE PROMPT:
cinematic style, dramatic lighting, staged scenes, cartoon style,
anime style, illustration, drawing, artwork, digital art, render, 3D, CGI,
stylized, artistic interpretation, miniature, diorama, toy-like, exaggerated

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "documentary photography, authentic moment"
- "journalistic approach, natural lighting"
- "real-world authenticity, candid photography"
`,
        'anime': `
🌸 GLOBAL VISUAL IDENTITY — ANIME:

All scenes must maintain anime-style aesthetic.
Japanese animation style, vibrant colors, expressive characters.
Manga-inspired visuals, cel-shaded appearance, detailed backgrounds.
Anime composition, expressive character design, vibrant palette.
Every frame must look like an anime frame.

⚠️ CRITICAL: Maintain anime style throughout all scenes.
⚠️ Use vibrant colors, expressive characters, anime composition.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
cartoon style (Western), illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "anime style, Japanese animation"
- "manga-inspired, vibrant colors"
- "cel-shaded anime aesthetic, expressive characters"
`,
        'cartoon': `
🎨 GLOBAL VISUAL IDENTITY — CARTOON:

All scenes must maintain cartoon-style aesthetic.
Colorful, expressive, playful, hand-drawn aesthetic.
Vibrant palette, animated style, expressive characters.
Playful composition, colorful backgrounds, animated quality.
Every frame must look like a cartoon frame.

⚠️ CRITICAL: Maintain cartoon style throughout all scenes.
⚠️ Use vibrant colors, expressive design, playful aesthetic.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, illustration, drawing, artwork, digital art, render, 3D, CGI,
stylized realism, miniature, diorama, realistic proportions

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "cartoon style, colorful and expressive"
- "animated aesthetic, playful design"
- "hand-drawn cartoon style, vibrant palette"
`,
        'cartoon-premium': `
✨ GLOBAL VISUAL IDENTITY — PREMIUM CARTOON:

All scenes must maintain premium cartoon-style aesthetic.
High-quality animation, sophisticated color palette, professional lighting.
Detailed character design, rich colors, professional animation studio quality.
Premium animation composition, sophisticated design, professional quality.
Every frame must look like a premium animation frame.

⚠️ CRITICAL: Maintain premium cartoon style throughout all scenes.
⚠️ Use sophisticated colors, professional animation quality, detailed design.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, simple cartoon, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "premium cartoon style, high-quality animation"
- "professional animation studio quality, sophisticated design"
- "premium animation aesthetic, detailed character design"
`,
        'fantasy': `
✨ GLOBAL VISUAL IDENTITY — FANTASY:

All scenes must maintain fantasy-style aesthetic.
Magical atmosphere, epic scale, mystical lighting, enchanted elements.
Otherworldly visuals, detailed fantasy illustration, magical composition.
Epic fantasy composition, mystical elements, enchanted atmosphere.
Every frame must look like a fantasy illustration.

⚠️ CRITICAL: Maintain fantasy style throughout all scenes.
⚠️ Use magical elements, mystical lighting, epic scale.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, real-world

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "fantasy art, magical atmosphere"
- "epic fantasy scale, mystical lighting"
- "enchanted fantasy aesthetic, otherworldly visuals"
`,
        'stick-figure': `
👤 GLOBAL VISUAL IDENTITY — STICK FIGURE:

All scenes must maintain stick figure-style aesthetic.
Minimalist line art, simple black lines on white background.
Clean and minimal, simple composition, minimalist design.
Basic line art composition, minimal elements, clean aesthetic.
Every frame must look like a stick figure drawing.

⚠️ CRITICAL: Maintain stick figure style throughout all scenes.
⚠️ Use simple lines, minimal design, clean composition.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, detailed illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, complex design

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "stick figure style, minimalist line art"
- "simple black lines, clean and minimal"
- "minimalist stick figure aesthetic, simple design"
`,
        'whiteboard': `
📝 GLOBAL VISUAL IDENTITY — WHITEBOARD:

All scenes must maintain whiteboard animation-style aesthetic.
Clean white background, hand-drawn illustrations, educational style.
Clear and simple, minimalist aesthetic, educational composition.
Whiteboard composition, hand-drawn elements, clean design.
Every frame must look like a whiteboard illustration.

⚠️ CRITICAL: Maintain whiteboard style throughout all scenes.
⚠️ Use clean white background, hand-drawn elements, simple design.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, complex backgrounds

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "whiteboard animation style, clean white background"
- "hand-drawn illustrations, educational aesthetic"
- "whiteboard style, clear and simple design"
`,
        'tech-minimalist': `
💻 GLOBAL VISUAL IDENTITY — TECH MINIMALIST:

All scenes must maintain tech minimalist-style aesthetic.
Clean design, modern aesthetic, geometric shapes, minimal color palette.
Futuristic, sleek, minimalist design, modern composition.
Tech composition, geometric elements, minimal design.
Every frame must look like a tech minimalist design.

⚠️ CRITICAL: Maintain tech minimalist style throughout all scenes.
⚠️ Use clean design, geometric shapes, minimal palette.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, complex design

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "tech minimalist, clean design"
- "modern aesthetic, geometric shapes"
- "futuristic minimalist aesthetic, sleek design"
`,
        'spiritual-minimalist': `
🧘 GLOBAL VISUAL IDENTITY — SPIRITUAL MINIMALIST:

All scenes must maintain spiritual minimalist-style aesthetic.
Serene atmosphere, soft lighting, peaceful composition, meditative quality.
Zen aesthetic, soft illumination, peaceful design, meditative composition.
Spiritual composition, serene elements, peaceful aesthetic.
Every frame must look like a spiritual minimalist design.

⚠️ CRITICAL: Maintain spiritual minimalist style throughout all scenes.
⚠️ Use serene atmosphere, soft lighting, peaceful design.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, dramatic lighting

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "spiritual minimalist, serene atmosphere"
- "meditative aesthetic, soft lighting"
- "zen aesthetic, peaceful composition"
`,
        'viral-vibrant': `
🔥 GLOBAL VISUAL IDENTITY — VIRAL VIBRANT:

All scenes must maintain viral vibrant-style aesthetic.
High contrast, saturated colors, bold composition, eye-catching design.
Social media optimized, vibrant and energetic, bold visual impact.
Viral composition, high contrast, saturated palette, energetic design.
Every frame must look like a viral social media image.

⚠️ CRITICAL: Maintain viral vibrant style throughout all scenes.
⚠️ Use high contrast, saturated colors, bold composition.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, muted colors

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "viral vibrant style, high contrast"
- "saturated colors, bold composition"
- "social media optimized, vibrant and energetic"
`,
        'modern-documentary': `
📺 GLOBAL VISUAL IDENTITY — MODERN DOCUMENTARY:

All scenes must maintain modern documentary-style aesthetic.
Dynamic contemporary lighting, authentic moments, modern color grading.
Modern cinematography, contemporary approach, authentic visual style.
Modern documentary composition, contemporary elements, authentic design.
Every frame must look like a modern documentary frame.

⚠️ CRITICAL: Maintain modern documentary style throughout all scenes.
⚠️ Use contemporary lighting, authentic moments, modern approach.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, classic documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, vintage aesthetic

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "modern documentary style, dynamic contemporary"
- "authentic moments, modern color grading"
- "contemporary cinematography, modern aesthetic"
`,
        'analog-horror': `
👻 GLOBAL VISUAL IDENTITY — ANALOG HORROR:

All scenes must maintain analog horror-style aesthetic.
VHS quality grain, retro horror aesthetic, low-fi texture, analog degradation.
Vintage feel, retro horror composition, analog quality, vintage aesthetic.
Analog horror composition, VHS quality, retro elements, vintage design.
Every frame must look like an analog horror frame.

⚠️ CRITICAL: Maintain analog horror style throughout all scenes.
⚠️ Use VHS quality, retro aesthetic, analog degradation.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, high quality

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "analog horror style, VHS quality"
- "retro horror aesthetic, low-fi texture"
- "analog degradation, vintage feel"
`,
        'dark-theater': `
🎪 GLOBAL VISUAL IDENTITY — DARK THEATER:

All scenes must maintain dark theater-style aesthetic.
Dramatic stage lighting, intense shadows, theatrical illumination.
Theatrical composition, dramatic lighting, stage aesthetic, intense design.
Dark theater composition, dramatic shadows, theatrical elements.
Every frame must look like a dark theater stage.

⚠️ CRITICAL: Maintain dark theater style throughout all scenes.
⚠️ Use dramatic stage lighting, intense shadows, theatrical design.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, natural lighting

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "dark theater style, dramatic stage lighting"
- "intense shadows, theatrical illumination"
- "theatrical composition, dramatic lighting"
`,
        'naturalist-drama': `
🎭 GLOBAL VISUAL IDENTITY — NATURALIST DRAMA:

All scenes must maintain naturalist drama-style aesthetic.
Realistic emotional lighting, authentic human moments, natural color palette.
Realistic composition, emotional depth, authentic design, natural aesthetic.
Naturalist drama composition, realistic elements, emotional design.
Every frame must look like a naturalist drama frame.

⚠️ CRITICAL: Maintain naturalist drama style throughout all scenes.
⚠️ Use realistic lighting, authentic moments, natural palette.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, dramatic lighting

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "naturalist drama style, realistic emotional"
- "authentic human moments, natural color palette"
- "realistic composition, emotional depth"
`,
        'spiritual-neorealism': `
🌟 GLOBAL VISUAL IDENTITY — SPIRITUAL NEOREALISM:

All scenes must maintain spiritual neorealism-style aesthetic.
Transcendent realistic lighting, mystical atmosphere, spiritual color grading.
Transcendent composition, mystical elements, spiritual design, transcendent aesthetic.
Spiritual neorealism composition, transcendent elements, mystical design.
Every frame must look like a spiritual neorealism frame.

⚠️ CRITICAL: Maintain spiritual neorealism style throughout all scenes.
⚠️ Use transcendent lighting, mystical atmosphere, spiritual design.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, mundane aesthetic

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "spiritual neorealism style, transcendent realistic"
- "mystical atmosphere, spiritual color grading"
- "transcendent composition, mystical elements"
`,
        'psychological-surrealism': `
🌀 GLOBAL VISUAL IDENTITY — PSYCHOLOGICAL SURREALISM:

All scenes must maintain psychological surrealism-style aesthetic.
Dreamlike lighting, abstract reality, surreal color palette.
Surreal composition, dreamlike elements, abstract design, surreal aesthetic.
Psychological surrealism composition, dreamlike elements, abstract design.
Every frame must look like a psychological surrealism frame.

⚠️ CRITICAL: Maintain psychological surrealism style throughout all scenes.
⚠️ Use dreamlike lighting, abstract reality, surreal design.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, realistic reality

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "psychological surrealism style, dreamlike lighting"
- "abstract reality, surreal color palette"
- "surreal composition, dreamlike elements"
`,
        'fragmented-memory': `
🧩 GLOBAL VISUAL IDENTITY — FRAGMENTED MEMORY:

All scenes must maintain fragmented memory-style aesthetic.
Collage aesthetic, fragmented composition, layered lighting.
Fragmented composition, collage elements, layered design, fragmented aesthetic.
Fragmented memory composition, collage elements, layered design.
Every frame must look like a fragmented memory frame.

⚠️ CRITICAL: Maintain fragmented memory style throughout all scenes.
⚠️ Use collage aesthetic, fragmented composition, layered design.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, unified composition

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "fragmented memory style, collage aesthetic"
- "fragmented composition, layered lighting"
- "collage elements, fragmented design"
`,
        'fragmented-narrative': `
📖 GLOBAL VISUAL IDENTITY — FRAGMENTED NARRATIVE:

All scenes must maintain fragmented narrative-style aesthetic.
Fragmented narrative style, collage composition, layered visual narrative.
Fragmented composition, collage elements, layered narrative, fragmented aesthetic.
Fragmented narrative composition, collage elements, layered design.
Every frame must look like a fragmented narrative frame.

⚠️ CRITICAL: Maintain fragmented narrative style throughout all scenes.
⚠️ Use fragmented composition, collage elements, layered narrative.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, unified narrative

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "fragmented narrative style, collage composition"
- "layered visual narrative, fragmented design"
- "collage elements, fragmented narrative"
`,
        'dream-real': `
💭 GLOBAL VISUAL IDENTITY — DREAM-REAL:

All scenes must maintain dream-real-style aesthetic.
Liminal space lighting, ethereal atmosphere, dream-reality blend.
Liminal composition, ethereal elements, dream-reality design, liminal aesthetic.
Dream-real composition, ethereal elements, liminal design.
Every frame must look like a dream-real frame.

⚠️ CRITICAL: Maintain dream-real style throughout all scenes.
⚠️ Use liminal lighting, ethereal atmosphere, dream-reality blend.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, realistic reality

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "dream-real style, liminal space lighting"
- "ethereal atmosphere, dream-reality blend"
- "liminal composition, ethereal elements"
`,
        'vhs-nostalgic': `
📼 GLOBAL VISUAL IDENTITY — VHS NOSTALGIC:

All scenes must maintain VHS nostalgic-style aesthetic.
Retro 80s/90s quality, vintage grain, analog texture, nostalgic aesthetic.
Vintage composition, retro elements, nostalgic design, vintage aesthetic.
VHS nostalgic composition, retro elements, vintage design.
Every frame must look like a VHS nostalgic frame.

⚠️ CRITICAL: Maintain VHS nostalgic style throughout all scenes.
⚠️ Use retro quality, vintage grain, analog texture.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, high quality

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "VHS nostalgic style, retro 80s/90s"
- "vintage grain, analog texture"
- "retro aesthetic, nostalgic design"
`,
        'cinematic-narrative': `
🎭 GLOBAL VISUAL IDENTITY — CINEMATIC NARRATIVE:

All scenes must maintain cinematic narrative-style aesthetic.
Story-driven lighting, emotional depth, narrative composition, dramatic shadows.
Storytelling composition, emotional elements, narrative design, storytelling aesthetic.
Cinematic narrative composition, story-driven elements, emotional design.
Every frame must look like a cinematic narrative frame.

⚠️ CRITICAL: Maintain cinematic narrative style throughout all scenes.
⚠️ Use story-driven lighting, emotional depth, narrative composition.

🚫 NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, flat composition

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "cinematic narrative style, story-driven lighting"
- "emotional depth, narrative composition"
- "storytelling composition, emotional elements"
`
    };
    
    // Retornar a âncora específica do estilo ou a padrão (photorealistic)
    return styleAnchors[defaultStyle] || styleAnchors['photorealistic'];
}

// Função helper para gerar descrição SEO otimizada com emojis
function generateOptimizedSEODescription(title, subniche, language) {
    const emojiMap = {
        'pt': {
            'Marketing Digital': '📱💼',
            'YouTube': '🎥📺',
            'TikTok': '🎵📱',
            'Instagram': '📸✨',
            'Negócios': '💼🚀',
            'Educação': '📚🎓',
            'Tecnologia': '💻🔧',
            'Saúde': '💪🏥',
            'Fitness': '🏋️💪',
            'Viagem': '✈️🌍',
            'Culinária': '🍳👨‍🍳',
            'Entretenimento': '🎬🎭'
        },
        'en': {
            'Digital Marketing': '📱💼',
            'YouTube': '🎥📺',
            'TikTok': '🎵📱',
            'Instagram': '📸✨',
            'Business': '💼🚀',
            'Education': '📚🎓',
            'Technology': '💻🔧',
            'Health': '💪🏥',
            'Fitness': '🏋️💪',
            'Travel': '✈️🌍',
            'Cooking': '🍳👨‍🍳',
            'Entertainment': '🎬🎭'
        },
        'es': {
            'Marketing Digital': '📱💼',
            'YouTube': '🎥📺',
            'TikTok': '🎵📱',
            'Instagram': '📸✨',
            'Negocios': '💼🚀',
            'Educación': '📚🎓',
            'Tecnología': '💻🔧',
            'Salud': '💪🏥',
            'Fitness': '🏋️💪',
            'Viajes': '✈️🌍',
            'Cocina': '🍳👨‍🍳',
            'Entretenimiento': '🎬🎭'
        }
    };
    
    const langCode = language === 'Português' ? 'pt' : language === 'Inglês' ? 'en' : 'es';
    const emojis = emojiMap[langCode] || emojiMap['pt'];
    const nicheEmoji = emojis[subniche] || '🎯';
    
    if (langCode === 'pt') {
        return `${nicheEmoji} ${title}

📌 Neste vídeo você vai descobrir:
✅ Tudo sobre ${subniche}
✅ Estratégias comprovadas que funcionam
✅ Dicas exclusivas para resultados rápidos

🎯 Se você quer dominar ${subniche}, este vídeo é para você!

💡 Deixe seu like se este conteúdo te ajudou! 👍
📢 Compartilhe com quem precisa ver isso!
🔔 Ative o sininho para não perder nenhum conteúdo!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📚 CONTEÚDO DO VÍDEO:
Neste vídeo completo, você vai aprender tudo sobre ${subniche} e como aplicar estratégias eficazes para alcançar seus objetivos.

🎬 O QUE VOCÊ VAI APRENDER:
• Como dominar ${subniche}
• Estratégias práticas e aplicáveis
• Dicas exclusivas de especialistas
• Erros comuns a evitar

💼 SOBRE O CANAL:
Aqui você encontra conteúdo de qualidade sobre ${subniche}, com dicas práticas, tutoriais e estratégias que realmente funcionam.

🔗 LINKS IMPORTANTES:
📱 Siga-nos nas redes sociais para mais conteúdo exclusivo!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#${subniche.replace(/\s+/g, '')} #YouTube #Conteúdo #Dicas #Tutorial`;
    } else if (langCode === 'en') {
        return `${nicheEmoji} ${title}

📌 In this video you'll discover:
✅ Everything about ${subniche}
✅ Proven strategies that work
✅ Exclusive tips for quick results

🎯 If you want to master ${subniche}, this video is for you!

💡 Leave a like if this content helped you! 👍
📢 Share with those who need to see this!
🔔 Turn on notifications to never miss content!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📚 VIDEO CONTENT:
In this complete video, you'll learn everything about ${subniche} and how to apply effective strategies to achieve your goals.

🎬 WHAT YOU'LL LEARN:
• How to master ${subniche}
• Practical and applicable strategies
• Exclusive expert tips
• Common mistakes to avoid

💼 ABOUT THE CHANNEL:
Here you'll find quality content about ${subniche}, with practical tips, tutorials and strategies that really work.

🔗 IMPORTANT LINKS:
📱 Follow us on social media for more exclusive content!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#${subniche.replace(/\s+/g, '')} #YouTube #Content #Tips #Tutorial`;
    } else {
        return `${nicheEmoji} ${title}

📌 En este video descubrirás:
✅ Todo sobre ${subniche}
✅ Estrategias probadas que funcionan
✅ Consejos exclusivos para resultados rápidos

🎯 Si quieres dominar ${subniche}, ¡este video es para ti!

💡 ¡Dale like si este contenido te ayudó! 👍
📢 ¡Comparte con quien necesita ver esto!
🔔 ¡Activa las notificaciones para no perderte contenido!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📚 CONTENIDO DEL VIDEO:
En este video completo, aprenderás todo sobre ${subniche} y cómo aplicar estrategias efectivas para alcanzar tus objetivos.

🎬 LO QUE APRENDERÁS:
• Cómo dominar ${subniche}
• Estrategias prácticas y aplicables
• Consejos exclusivos de expertos
• Errores comunes a evitar

💼 SOBRE EL CANAL:
Aquí encontrarás contenido de calidad sobre ${subniche}, con consejos prácticos, tutoriales y estrategias que realmente funcionan.

🔗 ENLACES IMPORTANTES:
📱 ¡Síguenos en redes sociales para más contenido exclusivo!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#${subniche.replace(/\s+/g, '')} #YouTube #Contenido #Consejos #Tutorial`;
    }
}

// Função helper para gerar as 12 regras de thumbnail viral do YouTube
function getThumbnailViralRules(selectedRule = 'auto', selectedTitle = '') {
    const rules = {
        'rule1': {
            name: 'Regra da Clareza Imediata (1 segundo)',
            description: 'O cérebro precisa entender a thumbnail em menos de 1 segundo. Se houver confusão, o clique cai.',
            checklist: ['1 ideia principal', '1 personagem', '1 emoção', '1 objeto-chave'],
            instructions: 'A thumbnail DEVE ser compreendida em menos de 1 segundo. Use APENAS: 1 ideia principal, 1 personagem, 1 emoção, 1 objeto-chave. Elimine qualquer elemento que cause confusão ou distração.'
        },
        'rule2': {
            name: 'Regra do Assunto Único',
            description: 'Nada divide a atenção. A thumbnail boa é sempre uma história em uma imagem.',
            instructions: 'Foque em UM ÚNICO assunto dominante. Nada deve competir pela atenção. A thumbnail deve contar uma história completa em uma única imagem, sem elementos que dividam o foco.'
        },
        'rule3': {
            name: 'Regra do Rosto Grande',
            description: 'Rostos com forte expressão emocional aumentam CTR de 20% a 60%.',
            expressions: ['choque', 'surpresa', 'medo', 'raiva', 'felicidade extrema'],
            instructions: 'Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A expressão facial DEVE ser EXTREMA e EMOCIONAL: choque, surpresa, medo, raiva ou felicidade extrema. O rosto deve ser o elemento dominante e a primeira coisa que o olho vê.'
        },
        'rule4': {
            name: 'Regra do Contraste Brutal',
            description: 'Se não tiver contraste, a thumbnail fica invisível.',
            contrasts: ['texto vs fundo', 'personagem vs fundo', 'cores complementares (azul/laranja, amarelo/roxo)'],
            instructions: 'Use CONTRASTE BRUTAL entre: texto e fundo, personagem e fundo, cores complementares (azul/laranja, amarelo/roxo). O contraste deve ser tão forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.'
        },
        'rule5': {
            name: 'Regra da Cor Estratégica',
            description: 'Cada cor ativa um gatilho.',
            colors: {
                'Amarelo': 'atenção imediata',
                'Vermelho': 'urgência / perigo',
                'Azul': 'confiança',
                'Verde': 'dinheiro / solução',
                'Preto': 'premium / mistério'
            },
            instructions: 'Use cores estratégicas que ativem gatilhos mentais: Amarelo (atenção imediata), Vermelho (urgência/perigo), Azul (confiança), Verde (dinheiro/solução), Preto (premium/mistério). Escolha a cor baseada na emoção que o título transmite.'
        },
        'rule6': {
            name: 'Regra dos Terços',
            description: 'Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso dá harmonia e aumenta o foco natural.',
            instructions: 'Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos terços (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.'
        },
        'rule7': {
            name: 'Regra do Texto Ultra Curto',
            description: 'Texto deve ter 2 a 4 palavras, nunca mais.',
            examples: ['Ele mentiu', 'Descobri isso', 'Ninguém viu', 'Proibido'],
            instructions: 'O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Exemplos: "Ele mentiu", "Descobri isso", "Ninguém viu", "Proibido". Textos longos matam o CTR. Seja brutalmente direto e impactante.'
        },
        'rule8': {
            name: 'Regra do Zoom Emocional',
            description: 'Aparece sempre um elemento gigante que amplifica a emoção ou o conflito.',
            examples: ['uma conta bancária gigante', 'uma faca gigante', 'uma lupa gigante', 'um número gigante'],
            instructions: 'Use um elemento GIGANTE que amplifique a emoção ou conflito: uma conta bancária gigante, uma faca gigante, uma lupa gigante, um número gigante. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.'
        },
        'rule9': {
            name: 'Regra do Mistério',
            description: 'Toda thumbnail viral tem uma pergunta implícita.',
            examples: ['algo escondido atrás de blur', 'objeto cortado pela metade', 'pessoa olhando para fora do quadro', 'seta apontando para algo fora da tela'],
            instructions: 'Crie uma pergunta implícita na thumbnail usando: algo escondido atrás de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela. O espectador DEVE sentir curiosidade sobre o que está fora da imagem.'
        },
        'rule10': {
            name: 'Regra dos Pontos de Fuga',
            description: 'Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.',
            elements: ['setas', 'linhas diagonais', 'perspectiva'],
            instructions: 'Use linhas visuais que guiem o olhar para o foco: setas, linhas diagonais, perspectiva. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal (personagem ou objeto).'
        },
        'rule11': {
            name: 'Regra do Espaço Negativo',
            description: 'Deixar áreas vazias acentua o foco. Sem isso, a imagem vira bagunça.',
            instructions: 'Deixe áreas vazias (espaço negativo) que acentuem o foco no elemento principal. O espaço vazio cria respiração visual e faz o elemento principal "pular" da imagem. Sem espaço negativo, a thumbnail vira bagunça visual.'
        },
        'rule12': {
            name: 'Regra da Coerência com o Título',
            description: 'Thumbnail e título precisam contar a mesma história, mas com ângulos diferentes.',
            instructions: 'A thumbnail e o título DEVEM contar a mesma história, mas com ângulos diferentes: Título = contexto, Thumbnail = emoção. A thumbnail deve amplificar a emoção que o título promete, criando uma sinergia perfeita.'
        }
    };
    
    if (selectedRule === 'auto') {
        // IA deve identificar qual regra melhor se encaixa baseado no título
        return {
            mode: 'auto',
            instructions: `Analise o título "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral melhor se encaixa. Aplique a regra identificada de forma rigorosa. Se múltiplas regras se aplicarem, priorize a que tiver maior impacto no CTR.`,
            allRules: rules
        };
    } else {
        const rule = rules[selectedRule];
        if (!rule) {
            return { mode: 'auto', instructions: 'Regra não encontrada. Use modo automático.', allRules: rules };
        }
        return {
            mode: 'manual',
            rule: rule,
            instructions: rule.instructions
        };
    }
}

// === ROTAS PARA THUMBNAILS DE REFERÊNCIA ===

// Upload de thumbnail de referência
app.post('/api/thumbnail-references/upload', authenticateToken, async (req, res) => {
    try {
        const { thumbnail_base64, folder_id, channel_name, niche, subniche, description } = req.body;
        const userId = req.user.id;

        if (!thumbnail_base64) {
            return res.status(400).json({ msg: 'Thumbnail em base64 é obrigatória.' });
        }

        // Validar formato base64
        if (!thumbnail_base64.startsWith('data:image/')) {
            return res.status(400).json({ msg: 'Formato de imagem inválido. Use base64 com data URI.' });
        }

        // Verificar se a coluna folder_id existe na tabela
        let hasFolderId = false;
        try {
            const tableInfo = await db.all("PRAGMA table_info(thumbnail_references)");
            hasFolderId = tableInfo.some(col => col.name === 'folder_id');
            
            // Se não existir, criar a coluna
            if (!hasFolderId) {
                await db.run('ALTER TABLE thumbnail_references ADD COLUMN folder_id INTEGER');
                await db.run('CREATE INDEX IF NOT EXISTS idx_thumbnail_ref_folder ON thumbnail_references(folder_id)');
                hasFolderId = true;
            }
        } catch (e) {
            console.warn('[Thumbnail Ref] Erro ao verificar/criar coluna folder_id:', e.message);
        }

        // Validar se a pasta pertence ao usuário (se folder_id for fornecido)
        if (folder_id && hasFolderId) {
            try {
                const folder = await db.get('SELECT id FROM analysis_folders WHERE id = ? AND user_id = ?', [folder_id, userId]);
                if (!folder) {
                    return res.status(400).json({ msg: 'Pasta não encontrada ou não pertence ao usuário.' });
                }
            } catch (e) {
                console.warn('[Thumbnail Ref] Erro ao validar pasta:', e.message);
            }
        }

        // Inserir com ou sem folder_id dependendo da estrutura da tabela
        let result;
        if (hasFolderId) {
            result = await db.run(
                `INSERT INTO thumbnail_references (user_id, thumbnail_base64, folder_id, channel_name, niche, subniche, description)
                 VALUES (?, ?, ?, ?, ?, ?, ?)`,
                [userId, thumbnail_base64, folder_id || null, channel_name || null, niche || null, subniche || null, description || null]
            );
        } else {
            result = await db.run(
                `INSERT INTO thumbnail_references (user_id, thumbnail_base64, channel_name, niche, subniche, description)
                 VALUES (?, ?, ?, ?, ?, ?)`,
                [userId, thumbnail_base64, channel_name || null, niche || null, subniche || null, description || null]
            );
        }

        // Analisar estilo automaticamente após upload (se tiver niche/subniche)
        let autoAnalyzeResult = null;
        if (niche || subniche) {
            try {
                // Buscar thumbnails de referência do nicho/subnicho
                let refQuery = 'SELECT id, thumbnail_base64 FROM thumbnail_references WHERE user_id = ?';
                const refParams = [userId];
                
                if (folder_id) {
                    refQuery += ' AND (folder_id = ? OR folder_id IS NULL)';
                    refParams.push(folder_id);
                }
                if (subniche) {
                    refQuery += ' AND (subniche = ? OR subniche IS NULL)';
                    refParams.push(subniche);
                }
                if (niche) {
                    refQuery += ' AND (niche = ? OR niche IS NULL)';
                    refParams.push(niche);
                }
                
                refQuery += ' ORDER BY created_at DESC LIMIT 10';
                const thumbnailReferences = await db.all(refQuery, refParams);
                
                if (thumbnailReferences && thumbnailReferences.length >= 1) {
                    // Buscar API key automaticamente
                    let apiKey = null;
                    let service = null;
                    let modelToUse = null;
                    
                    const services = ['claude', 'openai', 'gemini'];
                    for (const svc of services) {
                        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
                        if (keyData && keyData.api_key) {
                            try {
                                apiKey = decrypt(keyData.api_key);
                                service = svc;
                                if (svc === 'claude') modelToUse = 'claude-3-7-sonnet-20250219';
                                else if (svc === 'openai') modelToUse = 'gpt-4o';
                                else modelToUse = 'gemini-2.5-pro';
                                break;
                            } catch (e) {
                                continue;
                            }
                        }
                    }
                    
                    if (apiKey) {
                        // Preparar imagens para análise
                        const additionalImages = thumbnailReferences.map(ref => ref.thumbnail_base64).filter(Boolean);
                        
                        // Criar prompt para análise de estilo
                        const analysisPrompt = `Você é um ESPECIALISTA EM ANÁLISE DE ESTILO VISUAL DE THUMBNAILS.

Analise as ${thumbnailReferences.length} thumbnail(s) de referência fornecidas e identifique os ELEMENTOS VISUAIS COMUNS e o ESTILO PADRÃO usado.

IMPORTANTE: Sua tarefa é criar TRÊS (3) PROMPTS PADRÕES DIFERENTES que descrevam o estilo visual destas thumbnails de forma FIEL, cada um com uma abordagem ligeiramente diferente, mas todos mantendo a identidade visual do canal/nicho.

CRÍTICO - FIDELIDADE AO ESTILO:
- Seja EXTREMAMENTE FIEL ao estilo visual das thumbnails de referência
- Replique fielmente: composição, cores, tipografia, elementos visuais
- Mantenha a identidade visual do canal/nicho
- Cada prompt deve ser uma variação fiel, não uma reinvenção completa

ANALISE OS SEGUINTES ELEMENTOS:
1. Composição visual (layout, enquadramento, posicionamento de elementos)
2. Paleta de cores dominante (cores principais, contrastes)
3. Estilo de tipografia (fontes, tamanhos, efeitos, posicionamento)
4. Elementos visuais recorrentes (objetos, símbolos, elementos decorativos)
5. Iluminação e atmosfera (clara/escura, dramática/suave)
6. Estilo geral (realista/cartoon/cinematográfico/minimalista)
7. Regras de design específicas (regra dos terços, contraste, hierarquia visual)

RESPONDA APENAS COM UM OBJETO JSON:
{
  "prompt_1": "Primeiro prompt detalhado em inglês que descreve o estilo visual padrão destas thumbnails de forma fiel, focando na composição e elementos principais. Seja específico e detalhado.",
  "prompt_2": "Segundo prompt detalhado em inglês que descreve o mesmo estilo visual, mas com foco diferente (ex: cores e tipografia). Mantenha a fidelidade ao estilo original.",
  "prompt_3": "Terceiro prompt detalhado em inglês que descreve o mesmo estilo visual, mas com ênfase em outros aspectos (ex: iluminação e atmosfera). Continue sendo fiel ao estilo original."
}

IMPORTANTE: Os 3 prompts devem ser variações fiéis do mesmo estilo, não estilos completamente diferentes. Todos devem manter a identidade visual do canal/nicho.`;

                        // Chamar API para análise
                        let analysisResponse;
                        if (service === 'claude') {
                            analysisResponse = await callClaudeAPI(analysisPrompt, apiKey, modelToUse, null, null, additionalImages);
                        } else if (service === 'openai') {
                            analysisResponse = await callOpenAIAPI(analysisPrompt, apiKey, modelToUse, null, additionalImages);
                        } else {
                            analysisResponse = await callGeminiAPI(analysisPrompt, apiKey, modelToUse, null, additionalImages);
                        }
                        
                        const analysisText = typeof analysisResponse === 'string' ? analysisResponse : (analysisResponse.titles || JSON.stringify(analysisResponse));
                        const parsedAnalysis = parseAIResponse(analysisText, service);
                        
                        // Validar que os 3 prompts foram gerados
                        if (parsedAnalysis.prompt_1 && parsedAnalysis.prompt_2 && parsedAnalysis.prompt_3) {
                            const prompt1 = parsedAnalysis.prompt_1;
                            const prompt2 = parsedAnalysis.prompt_2;
                            const prompt3 = parsedAnalysis.prompt_3;

                            // Verificar se já existe um prompt padrão para atualizar
                            let checkQuery = 'SELECT id FROM thumbnail_style_prompts WHERE user_id = ?';
                            const checkParams = [userId];
                            
                            if (niche) {
                                checkQuery += ' AND niche = ?';
                                checkParams.push(niche);
                            } else {
                                checkQuery += ' AND niche IS NULL';
                            }
                            
                            if (subniche) {
                                checkQuery += ' AND subniche = ?';
                                checkParams.push(subniche);
                            } else {
                                checkQuery += ' AND subniche IS NULL';
                            }
                            
                            if (folder_id) {
                                checkQuery += ' AND folder_id = ?';
                                checkParams.push(folder_id);
                            } else {
                                checkQuery += ' AND folder_id IS NULL';
                            }
                            
                            const existingPrompt = await db.get(checkQuery, checkParams);
                            
                            if (existingPrompt) {
                                await db.run(
                                    `UPDATE thumbnail_style_prompts 
                                     SET prompt_1 = ?, prompt_2 = ?, prompt_3 = ?, 
                                         standard_prompt = ?, updated_at = CURRENT_TIMESTAMP
                                     WHERE id = ?`,
                                    [prompt1, prompt2, prompt3, prompt1, existingPrompt.id]
                                );
                                await db.run(
                                    `UPDATE thumbnail_style_prompts 
                                     SET prompt_selected = 1 
                                     WHERE id = ? AND (prompt_selected IS NULL OR prompt_selected = 0)`,
                                    [existingPrompt.id]
                                );
                                autoAnalyzeResult = { success: true, updated: true, id: existingPrompt.id };
                            } else {
                                const insertResult = await db.run(
                                    `INSERT INTO thumbnail_style_prompts (user_id, niche, subniche, folder_id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected, updated_at)
                                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1, CURRENT_TIMESTAMP)`,
                                    [userId, niche || null, subniche || null, folder_id || null, prompt1, prompt2, prompt3, prompt1]
                                );
                                autoAnalyzeResult = { success: true, created: true, id: insertResult.lastID };
                            }
                        }
                    }
                }
            } catch (autoErr) {
                console.warn('[Thumbnail Ref] Erro na análise automática de estilo:', autoErr.message);
                // Não falhar o upload se a análise automática falhar
            }
        }

        res.status(200).json({ 
            msg: 'Thumbnail de referência salva com sucesso.',
            id: result.lastID,
            styleAnalyzed: autoAnalyzeResult ? true : false
        });
    } catch (err) {
        console.error('Erro ao salvar thumbnail de referência:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Listar thumbnails de referência
app.get('/api/thumbnail-references', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { folder_id, channel_name, niche, subniche } = req.query;

        // Verificar se a coluna folder_id existe, se não, usar query sem ela
        let query = 'SELECT id, thumbnail_base64, channel_name, niche, subniche, description, created_at FROM thumbnail_references WHERE user_id = ?';
        const params = [userId];
        
        // Tentar adicionar folder_id se a coluna existir
        try {
            const tableInfo = await db.all("PRAGMA table_info(thumbnail_references)");
            const hasFolderId = tableInfo.some(col => col.name === 'folder_id');
            if (hasFolderId) {
                query = 'SELECT id, thumbnail_base64, folder_id, channel_name, niche, subniche, description, created_at FROM thumbnail_references WHERE user_id = ?';
            }
        } catch (e) {
            // Se der erro ao verificar, usar query sem folder_id
            console.warn('[Thumbnail Ref] Erro ao verificar estrutura da tabela:', e.message);
        }

        if (folder_id) {
            try {
                const tableInfo = await db.all("PRAGMA table_info(thumbnail_references)");
                const hasFolderId = tableInfo.some(col => col.name === 'folder_id');
                if (hasFolderId) {
                    query += ' AND (folder_id = ? OR folder_id IS NULL)';
                    params.push(folder_id);
                }
            } catch (e) {
                // Ignorar se coluna não existir
            }
        }
        if (channel_name) {
            query += ' AND channel_name = ?';
            params.push(channel_name);
        }
        if (niche) {
            query += ' AND niche = ?';
            params.push(niche);
        }
        if (subniche) {
            query += ' AND subniche = ?';
            params.push(subniche);
        }

        query += ' ORDER BY created_at DESC';

        const references = await db.all(query, params);

        // Retornar com base64 para exibição na interface
        res.status(200).json({ references });
    } catch (err) {
        console.error('Erro ao listar thumbnails de referência:', err);
        res.status(500).json({ msg: 'Erro no servidor: ' + err.message });
    }
});

// Obter thumbnail de referência específica (com base64)
app.get('/api/thumbnail-references/:id', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { id } = req.params;

        const reference = await db.get(
            'SELECT * FROM thumbnail_references WHERE id = ? AND user_id = ?',
            [id, userId]
        );

        if (!reference) {
            return res.status(404).json({ msg: 'Thumbnail de referência não encontrada.' });
        }

        res.status(200).json({ reference });
    } catch (err) {
        console.error('Erro ao buscar thumbnail de referência:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Analisar thumbnails de referência e gerar prompt padrão
app.post('/api/thumbnail-references/analyze-style', authenticateToken, async (req, res) => {
    try {
        const { niche, subniche, folder_id, force_reanalyze, model } = req.body;
        const userId = req.user.id;

        // Buscar thumbnails de referência do nicho/subnicho
        let refQuery = 'SELECT id, thumbnail_base64, channel_name, niche, subniche, description FROM thumbnail_references WHERE user_id = ?';
        const refParams = [userId];
        
        if (folder_id) {
            refQuery += ' AND (folder_id = ? OR folder_id IS NULL)';
            refParams.push(folder_id);
        }
        if (subniche) {
            refQuery += ' AND (subniche = ? OR subniche IS NULL)';
            refParams.push(subniche);
        }
        if (niche) {
            refQuery += ' AND (niche = ? OR niche IS NULL)';
            refParams.push(niche);
        }
        
        refQuery += ' ORDER BY created_at DESC LIMIT 10';
        
        const thumbnailReferences = await db.all(refQuery, refParams);
        
        if (!thumbnailReferences || thumbnailReferences.length === 0) {
            return res.status(400).json({ msg: 'Nenhuma thumbnail de referência encontrada para este nicho/subnicho.' });
        }

        // Verificar se já existe um prompt padrão e se não precisa re-analisar
        if (!force_reanalyze) {
            let existingPromptQuery = 'SELECT id, standard_prompt FROM thumbnail_style_prompts WHERE user_id = ?';
            const existingPromptParams = [userId];
            
            if (folder_id) {
                existingPromptQuery += ' AND (folder_id = ? OR folder_id IS NULL)';
                existingPromptParams.push(folder_id);
            }
            if (subniche) {
                existingPromptQuery += ' AND (subniche = ? OR subniche IS NULL)';
                existingPromptParams.push(subniche);
            }
            if (niche) {
                existingPromptQuery += ' AND (niche = ? OR niche IS NULL)';
                existingPromptParams.push(niche);
            }
            
            const existingPrompt = await db.get(existingPromptQuery, existingPromptParams);
            if (existingPrompt) {
                return res.status(200).json({ 
                    prompt: existingPrompt.standard_prompt,
                    message: 'Prompt padrão já existe. Use force_reanalyze=true para re-analisar.',
                    id: existingPrompt.id
                });
            }
        }

        // Buscar API key para análise - usar modelo selecionado ou escolher automaticamente
        let apiKey = null;
        let service = null;
        let modelToUse = null;
        
        if (model && model !== 'auto') {
            // Usar modelo especificado pelo usuário
            if (model.includes('claude') || model === 'claude-3-7-sonnet-20250219') {
                service = 'claude';
                modelToUse = 'claude-3-7-sonnet-20250219';
            } else if (model.includes('gpt') || model === 'gpt-4o') {
                service = 'openai';
                modelToUse = 'gpt-4o';
            } else if (model.includes('gemini') || model === 'gemini-2.5-pro') {
                service = 'gemini';
                modelToUse = 'gemini-2.5-pro';
            }
            
            // Buscar API key para o serviço especificado
            if (service) {
                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                if (keyData && keyData.api_key) {
                    try {
                        apiKey = decrypt(keyData.api_key);
                    } catch (e) {
                        // Se falhar, tentar automático
                        service = null;
                        modelToUse = null;
                    }
                } else {
                    // Se não tiver a chave do modelo especificado, tentar automático
                    service = null;
                    modelToUse = null;
                }
            }
        }
        
        // Se não especificado ou falhou, usar prioridade automática (claude > openai > gemini)
        if (!apiKey) {
            const services = ['claude', 'openai', 'gemini'];
            for (const svc of services) {
                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
                if (keyData && keyData.api_key) {
                    try {
                        apiKey = decrypt(keyData.api_key);
                        service = svc;
                        if (svc === 'claude') modelToUse = 'claude-3-7-sonnet-20250219';
                        else if (svc === 'openai') modelToUse = 'gpt-4o';
                        else modelToUse = 'gemini-2.5-pro';
                        break;
                    } catch (e) {
                        continue;
                    }
                }
            }
        }
        
        if (!apiKey) {
            return res.status(400).json({ msg: 'Nenhuma API key configurada. Configure pelo menos uma API (Claude, OpenAI ou Gemini) nas Configurações.' });
        }

        // Preparar imagens para análise
        const additionalImages = thumbnailReferences.map(ref => ref.thumbnail_base64).filter(Boolean);
        
        // Criar prompt para análise de estilo - ANÁLISE ULTRA ANALÍTICA E DETALHADA
        const analysisPrompt = `Você é um ESPECIALISTA EM ANÁLISE DE ESTILO VISUAL DE THUMBNAILS e IDENTIDADE VISUAL DE CANAIS.

Analise as ${thumbnailReferences.length} thumbnail(s) de referência fornecidas com EXTREMA ATENÇÃO AOS DETALHES e identifique TODOS os elementos que compõem a IDENTIDADE VISUAL ÚNICA deste canal/nicho.

IMPORTANTE: Sua tarefa é criar TRÊS (3) PROMPTS PADRÕES DIFERENTES que descrevam o estilo visual destas thumbnails de forma EXTREMAMENTE FIEL e DETALHADA, cada um com uma abordagem ligeiramente diferente, mas todos mantendo a identidade visual do canal/nicho.

CRÍTICO - ANÁLISE ANALÍTICA PROFUNDA:
- Seja EXTREMAMENTE FIEL ao estilo visual das thumbnails de referência
- Analise CADA DETALHE visual que compõe a identidade do canal
- Replique fielmente: composição, cores, tipografia, elementos visuais
- Mantenha a identidade visual do canal/nicho para QUALQUER nicho
- Cada prompt deve ser uma variação fiel, não uma reinvenção completa

ANALISE DETALHADA DOS SEGUINTES ELEMENTOS (SEJA ESPECÍFICO E DETALHADO):

1. COMPOSIÇÃO VISUAL (Layout e Estrutura):
   - Posicionamento exato do personagem/sujeito principal (centro, esquerda, direita, porcentagem do frame)
   - Enquadramento (close-up, médio, plano geral)
   - Proporção sujeito vs. fundo (ex: 60% sujeito, 40% fundo)
   - Regra dos terços aplicada? Como?
   - Hierarquia visual dos elementos
   - Espaçamento e margens
   - Simetria ou assimetria

2. PALETA DE CORES DOMINANTE (Análise Cromática Detalhada):
   - Cores primárias exatas (ex: dourado #D4AF37, azul escuro #1a1a2e)
   - Cores secundárias
   - Gradientes e transições de cor
   - Contraste de cores (alto, médio, baixo)
   - Temperatura de cor (quente, fria, mista)
   - Saturação (vibrante, desaturada, natural)
   - Distribuição espacial das cores (onde cada cor aparece)

3. ESTILO DE TIPOGRAFIA (Análise Tipográfica Completa):
   - Família de fonte (serif, sans-serif, display, script)
   - Tamanho relativo (grande, médio, pequeno)
   - Peso da fonte (bold, regular, light)
   - Efeitos aplicados (sombra, brilho, gradiente, relevo, contorno)
   - Cor da tipografia (dourado, branco, preto, gradiente)
   - Posicionamento exato (inferior, superior, centro)
   - Alinhamento (centralizado, esquerda, direita)
   - Espaçamento entre letras (kerning)
   - Estilo de capitalização (MAIÚSCULAS, minúsculas, Title Case)
   - Efeitos de camada (stroke, drop shadow, outer glow, bevel & emboss)

4. ELEMENTOS VISUAIS RECORRENTES (Inventário Completo):
   - Objetos que aparecem consistentemente
   - Símbolos e ícones recorrentes
   - Elementos decorativos
   - Padrões visuais
   - Texturas
   - Formas geométricas

5. ILUMINAÇÃO E ATMOSFERA (Análise de Luz Detalhada):
   - Tipo de iluminação (dramática, suave, natural, artificial)
   - Direção da luz (frontal, lateral, traseira, superior)
   - Contraste de iluminação (alto, médio, baixo)
   - Sombras (suaves, duras, dramáticas)
   - Atmosfera geral (épica, misteriosa, dramática, clara)
   - Efeitos de luz (lens flare, god rays, rim light)

6. ESTILO GERAL E QUALIDADE (Classificação Visual):
   - Nível de realismo (foto-realista, semi-realista, estilizado)
   - Estilo artístico (cinematográfico, documentário, ilustrativo)
   - Qualidade visual (4K, HD, estilizado)
   - Nível de detalhamento (ultra detalhado, detalhado, simplificado)

7. REGRAS DE DESIGN ESPECÍFICAS (Princípios Aplicados):
   - Regra dos terços (como aplicada)
   - Contraste visual (alto, médio, baixo)
   - Hierarquia visual (o que chama atenção primeiro)
   - Equilíbrio visual (simétrico, assimétrico)
   - Profundidade (plano, médio, profundo)

8. ELEMENTOS DE IDENTIDADE VISUAL ÚNICA:
   - Características distintivas que tornam este estilo único
   - Padrões que se repetem em todas as thumbnails
   - "Assinatura visual" do canal
   - Elementos que devem SEMPRE estar presentes

RESPONDA APENAS COM UM OBJETO JSON:
{
  "prompt_1": "Primeiro prompt EXTREMAMENTE DETALHADO em inglês (600-1200 palavras) que descreve o estilo visual padrão destas thumbnails de forma fiel, focando na composição, posicionamento exato, paleta de cores específica, tipografia detalhada e elementos principais. Seja ESPECÍFICO com medidas, porcentagens, cores exatas, posicionamento preciso.",
  "prompt_2": "Segundo prompt EXTREMAMENTE DETALHADO em inglês (600-1200 palavras) que descreve o mesmo estilo visual, mas com foco em cores específicas, tipografia detalhada (fonte, tamanho, efeitos), iluminação e atmosfera. Mantenha a fidelidade ao estilo original com TODOS os detalhes.",
  "prompt_3": "Terceiro prompt EXTREMAMENTE DETALHADO em inglês (600-1200 palavras) que descreve o mesmo estilo visual, mas com ênfase em elementos visuais recorrentes, regras de design específicas, e identidade visual única. Continue sendo fiel ao estilo original com ANÁLISE PROFUNDA."
}

CRÍTICO: 
- Os 3 prompts devem ser variações fiéis do mesmo estilo, não estilos diferentes
- Todos devem manter a identidade visual do canal/nicho
- Seja ESPECÍFICO: use medidas, porcentagens, cores exatas, posicionamento preciso
- Descreva CADA detalhe que compõe a identidade visual
- Os prompts devem ser aplicáveis a QUALQUER nicho mantendo a identidade visual`;

        // Chamar API para análise
        let analysisResponse;
        if (service === 'claude') {
            analysisResponse = await callClaudeAPI(analysisPrompt, apiKey, modelToUse, null, null, additionalImages);
        } else if (service === 'openai') {
            analysisResponse = await callOpenAIAPI(analysisPrompt, apiKey, modelToUse, null, additionalImages);
        } else {
            analysisResponse = await callGeminiAPI(analysisPrompt, apiKey, modelToUse, null, additionalImages);
        }
        
        const analysisText = typeof analysisResponse === 'string' ? analysisResponse : (analysisResponse.titles || JSON.stringify(analysisResponse));
        const parsedAnalysis = parseAIResponse(analysisText, service);
        
        // Validar que os 3 prompts foram gerados
        if (!parsedAnalysis.prompt_1 || !parsedAnalysis.prompt_2 || !parsedAnalysis.prompt_3) {
            // Fallback: se não tiver os 3, tentar usar standard_prompt e criar variações
            if (parsedAnalysis.standard_prompt) {
                parsedAnalysis.prompt_1 = parsedAnalysis.standard_prompt;
                parsedAnalysis.prompt_2 = parsedAnalysis.standard_prompt;
                parsedAnalysis.prompt_3 = parsedAnalysis.standard_prompt;
            } else {
                throw new Error('A IA não retornou os 3 prompts esperados.');
            }
        }
        
        const prompt1 = parsedAnalysis.prompt_1;
        const prompt2 = parsedAnalysis.prompt_2;
        const prompt3 = parsedAnalysis.prompt_3;

        // Verificar se já existe um prompt padrão para atualizar
        // Construir query que trata NULLs corretamente
        let checkQuery = 'SELECT id FROM thumbnail_style_prompts WHERE user_id = ?';
        const checkParams = [userId];
        
        if (niche) {
            checkQuery += ' AND niche = ?';
            checkParams.push(niche);
        } else {
            checkQuery += ' AND niche IS NULL';
        }
        
        if (subniche) {
            checkQuery += ' AND subniche = ?';
            checkParams.push(subniche);
        } else {
            checkQuery += ' AND subniche IS NULL';
        }
        
        if (folder_id) {
            checkQuery += ' AND folder_id = ?';
            checkParams.push(folder_id);
        } else {
            checkQuery += ' AND folder_id IS NULL';
        }
        
        const existingPrompt = await db.get(checkQuery, checkParams);
        
        let result;
        if (existingPrompt) {
            // Atualizar existente com os 3 prompts
            // Manter prompt_selected se já existir, caso contrário usar 1
            result = await db.run(
                `UPDATE thumbnail_style_prompts 
                 SET prompt_1 = ?, prompt_2 = ?, prompt_3 = ?, 
                     standard_prompt = ?, updated_at = CURRENT_TIMESTAMP
                 WHERE id = ?`,
                [prompt1, prompt2, prompt3, prompt1, existingPrompt.id]
            );
            
            // Se prompt_selected não existir ou for NULL, definir como 1
            await db.run(
                `UPDATE thumbnail_style_prompts 
                 SET prompt_selected = 1 
                 WHERE id = ? AND (prompt_selected IS NULL OR prompt_selected = 0)`,
                [existingPrompt.id]
            );
        } else {
            // Inserir novo com os 3 prompts
            result = await db.run(
                `INSERT INTO thumbnail_style_prompts (user_id, niche, subniche, folder_id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected, updated_at)
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1, CURRENT_TIMESTAMP)`,
                [userId, niche || null, subniche || null, folder_id || null, prompt1, prompt2, prompt3, prompt1]
            );
        }

        // Buscar o registro atualizado para retornar todos os dados
        const updatedRecord = await db.get('SELECT * FROM thumbnail_style_prompts WHERE id = ?', [existingPrompt ? existingPrompt.id : result.lastID]);

        res.status(200).json({ 
            msg: 'Estilo analisado e 3 prompts salvos com sucesso.',
            prompts: {
                prompt_1: updatedRecord.prompt_1 || prompt1,
                prompt_2: updatedRecord.prompt_2 || prompt2,
                prompt_3: updatedRecord.prompt_3 || prompt3
            },
            prompt_selected: updatedRecord.prompt_selected || 1,
            id: updatedRecord.id
        });
    } catch (err) {
        console.error('Erro ao analisar estilo das thumbnails:', err);
        res.status(500).json({ msg: 'Erro no servidor: ' + err.message });
    }
});

// Obter prompts padrão para um nicho/subnicho
app.get('/api/thumbnail-style-prompts', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { niche, subniche, folder_id } = req.query;

        let query = 'SELECT id, niche, subniche, folder_id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected, analyzed_at, updated_at FROM thumbnail_style_prompts WHERE user_id = ?';
        const params = [userId];

        if (folder_id) {
            query += ' AND (folder_id = ? OR folder_id IS NULL)';
            params.push(folder_id);
        }
        if (subniche) {
            query += ' AND (subniche = ? OR subniche IS NULL)';
            params.push(subniche);
        }
        if (niche) {
            query += ' AND (niche = ? OR niche IS NULL)';
            params.push(niche);
        }

        query += ' ORDER BY updated_at DESC LIMIT 1';

        const promptData = await db.get(query, params);

        if (!promptData) {
            // Retornar 200 com dados vazios ao invés de 404 para não gerar erro no frontend
            return res.status(200).json({ prompt: null, prompts: null });
        }

        // Determinar qual prompt usar (prompt_selected ou fallback para prompt_1 ou standard_prompt)
        const selectedPromptNum = promptData.prompt_selected || 1;
        let selectedPrompt = null;
        if (promptData.prompt_1 || promptData.prompt_2 || promptData.prompt_3) {
            if (selectedPromptNum === 1 && promptData.prompt_1) selectedPrompt = promptData.prompt_1;
            else if (selectedPromptNum === 2 && promptData.prompt_2) selectedPrompt = promptData.prompt_2;
            else if (selectedPromptNum === 3 && promptData.prompt_3) selectedPrompt = promptData.prompt_3;
            else selectedPrompt = promptData.prompt_1 || promptData.prompt_2 || promptData.prompt_3;
        } else {
            selectedPrompt = promptData.standard_prompt;
        }

        res.status(200).json({ 
            prompt: {
                ...promptData,
                standard_prompt: selectedPrompt
            },
            prompts: {
                prompt_1: promptData.prompt_1 || promptData.standard_prompt,
                prompt_2: promptData.prompt_2 || promptData.standard_prompt,
                prompt_3: promptData.prompt_3 || promptData.standard_prompt
            },
            prompt_selected: selectedPromptNum
        });
    } catch (err) {
        console.error('Erro ao buscar prompt padrão:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Selecionar qual dos 3 prompts usar como padrão
app.post('/api/thumbnail-style-prompts/select', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { niche, subniche, folder_id, prompt_number } = req.body;

        if (!prompt_number || (prompt_number !== 1 && prompt_number !== 2 && prompt_number !== 3)) {
            return res.status(400).json({ msg: 'prompt_number deve ser 1, 2 ou 3.' });
        }

        // Buscar o registro (mesma lógica do GET)
        let query = 'SELECT id FROM thumbnail_style_prompts WHERE user_id = ?';
        const params = [userId];

        if (folder_id !== undefined && folder_id !== null && folder_id !== '') {
            query += ' AND (folder_id = ? OR folder_id IS NULL)';
            params.push(folder_id);
        }

        if (subniche) {
            query += ' AND (subniche = ? OR subniche IS NULL)';
            params.push(subniche);
        }

        if (niche) {
            query += ' AND (niche = ? OR niche IS NULL)';
            params.push(niche);
        }

        query += ' ORDER BY updated_at DESC LIMIT 1';

        const promptData = await db.get(query, params);

        if (!promptData) {
            return res.status(404).json({ msg: 'Nenhum prompt padrão encontrado para este nicho/subnicho.' });
        }

        // Atualizar prompt_selected
        await db.run(
            'UPDATE thumbnail_style_prompts SET prompt_selected = ? WHERE id = ?',
            [prompt_number, promptData.id]
        );

        res.status(200).json({ 
            msg: `Prompt ${prompt_number} selecionado como padrão.`,
            prompt_selected: prompt_number
        });
    } catch (err) {
        console.error('Erro ao selecionar prompt padrão:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Deletar thumbnail de referência
app.delete('/api/thumbnail-references/:id', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { id } = req.params;

        const result = await db.run(
            'DELETE FROM thumbnail_references WHERE id = ? AND user_id = ?',
            [id, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Thumbnail de referência não encontrada.' });
        }

        res.status(200).json({ msg: 'Thumbnail de referência deletada com sucesso.' });
    } catch (err) {
        console.error('Erro ao deletar thumbnail de referência:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Endpoint unificado: Gera thumbnail completa (imagem + headline + SEO + tags) baseado no título e estilo de referência
app.post('/api/generate/thumbnail/complete', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        let { title, niche, subniche, folder_id, language = 'pt-BR', style = 'photorealistic', theme_key, variations = 2, ai_model, prompt_variant, include_4k_badge = false } = req.body;

        if (!title || !title.trim()) {
            return res.status(400).json({ msg: 'Título é obrigatório.' });
        }
        
        // Normalizar folder_id: converter string vazia para null e garantir que seja número
        if (folder_id === '' || folder_id === '0' || folder_id === 0) {
            folder_id = null;
        } else if (folder_id) {
            folder_id = parseInt(folder_id, 10);
            if (isNaN(folder_id)) folder_id = null;
        }
        
        console.log('[Thumbnail Complete] Buscando prompt para:', { userId, folder_id, niche, subniche });

        // 1. Buscar prompt padrão do estilo de referência
        // Prioridade: folder_id específico > subniche > niche > geral
        let promptData = null;
        
        // Primeiro, tentar buscar por pasta específica (se folder_id fornecido)
        if (folder_id) {
            let query = 'SELECT id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected, folder_id, niche, subniche FROM thumbnail_style_prompts WHERE user_id = ? AND folder_id = ?';
            const params = [userId, folder_id];
            
            // Adicionar filtros opcionais de nicho/subnicho para refinar a busca
            if (subniche) {
                query += ' AND (subniche = ? OR subniche IS NULL)';
                params.push(subniche);
            }
            if (niche) {
                query += ' AND (niche = ? OR niche IS NULL)';
                params.push(niche);
            }
            query += ' ORDER BY updated_at DESC LIMIT 1';
            
            console.log('[Thumbnail Complete] Buscando por pasta específica:', { query, params });
            promptData = await db.get(query, params);
            if (promptData) {
                console.log('[Thumbnail Complete] Prompt encontrado na pasta específica:', { id: promptData.id, folder_id: promptData.folder_id });
            } else {
                console.log('[Thumbnail Complete] Nenhum prompt encontrado na pasta específica:', folder_id);
            }
        }
        
        // Se não encontrou na pasta específica, tentar por subniche
        if (!promptData && subniche) {
            let query = 'SELECT id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected FROM thumbnail_style_prompts WHERE user_id = ? AND subniche = ?';
            const params = [userId, subniche];
            if (niche) {
                query += ' AND (niche = ? OR niche IS NULL)';
                params.push(niche);
            }
            query += ' ORDER BY updated_at DESC LIMIT 1';
            
            console.log('[Thumbnail Complete] Buscando por subniche:', { query, params });
            promptData = await db.get(query, params);
            if (promptData) {
                console.log('[Thumbnail Complete] Prompt encontrado por subniche:', { id: promptData.id });
            }
        }
        
        // Se não encontrou, tentar por niche
        if (!promptData && niche) {
            let query = 'SELECT id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected FROM thumbnail_style_prompts WHERE user_id = ? AND niche = ?';
            const params = [userId, niche];
            query += ' ORDER BY updated_at DESC LIMIT 1';
            
            console.log('[Thumbnail Complete] Buscando por niche:', { query, params });
            promptData = await db.get(query, params);
            if (promptData) {
                console.log('[Thumbnail Complete] Prompt encontrado por niche:', { id: promptData.id });
            }
        }
        
        // Se ainda não encontrou, buscar qualquer prompt do usuário (fallback)
        if (!promptData) {
            let query = 'SELECT id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected FROM thumbnail_style_prompts WHERE user_id = ?';
            const params = [userId];
            query += ' ORDER BY updated_at DESC LIMIT 1';
            
            console.log('[Thumbnail Complete] Buscando qualquer prompt do usuário (fallback)');
            promptData = await db.get(query, params);
            if (promptData) {
                console.log('[Thumbnail Complete] Prompt encontrado (fallback):', { id: promptData.id });
            }
        }
        
        if (!promptData) {
            return res.status(400).json({ 
                msg: folder_id 
                    ? 'Nenhum estilo de referência encontrado para esta pasta. Faça upload de thumbnails de referência para esta pasta primeiro.' 
                    : 'Nenhum estilo de referência encontrado. Faça upload de thumbnails de referência primeiro.' 
            });
        }

        // Preparar os 3 prompts de referência + 1 com junção dos 3
        const prompt1 = promptData.prompt_1 || '';
        const prompt2 = promptData.prompt_2 || '';
        const prompt3 = promptData.prompt_3 || '';
        
        // Criar prompt combinado (junção dos 3)
        const combinedPrompt = [prompt1, prompt2, prompt3]
            .filter(p => p && p.trim().length > 0)
            .join('\n\n---\n\n'); // Separador entre prompts
        
        console.log('[Thumbnail Complete] Prompts disponíveis:', {
            hasPrompt1: !!prompt1,
            hasPrompt2: !!prompt2,
            hasPrompt3: !!prompt3,
            hasCombinedPrompt: !!combinedPrompt,
            prompt1Length: prompt1.length,
            prompt2Length: prompt2.length,
            prompt3Length: prompt3.length,
            combinedPromptLength: combinedPrompt.length
        });
        
        // Verificar se temos pelo menos um prompt
        if (!prompt1 && !prompt2 && !prompt3) {
            return res.status(400).json({ msg: 'Nenhum prompt de referência encontrado. Faça upload de thumbnails de referência primeiro.' });
        }

        // 2. Detectar tema e ambientação do título
        const titleText = title.trim();
        const theme = (() => {
            const s = titleText.toLowerCase();
            // Detectar Petra/Nabateus primeiro (antes de egito, pois pode ter palavras similares)
            if (s.includes('petra') || s.includes('nabateu') || s.includes('nabataean') || s.includes('nabataeus') || 
                (s.includes('deserto') && (s.includes('império') || s.includes('imperio') || s.includes('cidade')))) {
                return 'petra';
            }
            if (s.includes('faraó') || s.includes('egito') || s.includes('egip') || s.includes('pirâmide') || s.includes('piramide')) return 'egito';
            if (s.includes('neandertal') || s.includes('neanderthal') || s.includes('neandertais') || s.includes('neandertales')) return 'prehistoria';
            if (s.includes('inca') || s.includes('atahualpa') || s.includes('moctezuma') || s.includes('azteca') || s.includes('aztecas') || s.includes('mexica')) return 'america_pre_colombiana';
            if (s.includes('viking') || s.includes('vikings')) return 'viking';
            if (s.includes('roma') || s.includes('romano') || s.includes('romanos') || s.includes('roman') || s.includes('império') || s.includes('imperio') || s.includes('bárbaro') || s.includes('barbaro')) return 'roma';
            if (s.includes('segunda guerra') || s.includes('world war') || s.includes('guerra mundial')) return 'ww2';
            if (s.includes('cristandade') || s.includes('cristão') || s.includes('cristian') || s.includes('cathedral') || s.includes('catedral')) return 'cristandade';
            return 'default';
        })();
        
        console.log('[Thumbnail Complete] Tema detectado:', theme, 'para título:', titleText);

        // 3. Buscar ambientação do banco de dados ou usar mapeamento padrão
        let dbMatch = null;
        if (theme_key) {
            await ensureAmbientationsTable();
            dbMatch = await db.get('SELECT * FROM niche_ambientations WHERE user_id = ? AND theme_key = ? LIMIT 1', [userId, theme_key]);
        }
        if (!dbMatch) {
            dbMatch = await detectAmbientationFromTitle(userId, titleText, niche);
        }

        // 4. Mapeamento de temas com personagens e elementos
        const themes = {
            petra: {
                subject: 'Nabataean figure with traditional desert attire and ornate jewelry',
                acessorios: 'gold and silver jewelry, ornate headdress, desert robes',
                ambiente: 'desert cliffs, carved stone monuments, Petra\'s Al-Khazneh, rose-red sandstone',
                elementos: 'ancient carved facades, desert canyons, Nabataean architecture, rock-cut tombs'
            },
            egito: { 
                subject: 'ancient Egyptian figure with royal collar and nemes headdress', 
                acessorios: 'gold necklaces and ceremonial regalia', 
                ambiente: 'desert dunes, pyramids, pharaoh temples, golden sun', 
                elementos: 'hieroglyph walls, golden crown, architect tools' 
            },
            prehistoria: { 
                subject: 'rugged Neanderthal with thick brow ridges, deep-set eyes, and weathered skin', 
                acessorios: 'primitive fur and animal hides, no metal or feathers', 
                ambiente: 'icy mountains, glacial valleys, burning forests', 
                elementos: 'fur clothing, primitive tools, ice age forests, mammoth silhouettes' 
            },
            america_pre_colombiana: { 
                subject: 'Mesoamerican leader with traditional attire and ceremonial elements', 
                acessorios: 'ornate jewelry and ritual accessories', 
                ambiente: 'jungles, stepped pyramids, volcanic eruptions', 
                elementos: 'ancient temples, stone sculptures, ritual smoke' 
            },
            viking: { 
                subject: 'Viking warrior with axe and thick beard', 
                acessorios: 'fur, leather armor, iron helmet', 
                ambiente: 'stormy oceans, burning ships, icy fjords', 
                elementos: 'longships, shields, ravens' 
            },
            roma: { 
                subject: 'Roman figure with laurel wreath and toga, classical lighting', 
                acessorios: 'laurel wreath, toga, military regalia', 
                ambiente: 'colosseum, roman columns, marble statues, ancient Rome', 
                elementos: 'legion standards, roman architecture, battle scenes, barbarian silhouettes' 
            },
            ww2: { 
                subject: 'civilian silhouette amid wartime ruins', 
                acessorios: 'period clothing, military uniforms', 
                ambiente: 'ruined cities, smoke, searchlights', 
                elementos: 'tanks, helmets, barbed wire, destruction' 
            },
            cristandade: { 
                subject: 'historical figure near cathedral light', 
                acessorios: 'religious vestments, ceremonial items', 
                ambiente: 'gothic cathedrals, stained glass light, stone plazas', 
                elementos: 'crosses, incense smoke, candles' 
            },
            default: { 
                subject: 'historical figure with authentic attire matching the title theme', 
                acessorios: 'period-appropriate accessories', 
                ambiente: 'dramatic scenery matching the title', 
                elementos: 'contextual props and elements' 
            }
        };

        // 5. Obter elementos do tema detectado
        // Priorizar o tema detectado do título sobre dados do banco
        let themeData = themes[theme] || themes.default;
        
        // Se o banco retornou dados, usar apenas se não conflitar com o tema detectado
        if (dbMatch) {
            // Se o tema detectado é específico (não 'default'), priorizar os dados do tema
            if (theme !== 'default' && themes[theme]) {
                themeData = {
                    subject: dbMatch.subject && dbMatch.subject.toLowerCase().includes(themeData.subject.toLowerCase().split(' ')[0]) 
                        ? dbMatch.subject : themeData.subject,
                    acessorios: dbMatch.acessorios || themeData.acessorios,
                    ambiente: dbMatch.ambiente && dbMatch.ambiente.toLowerCase().includes(themeData.ambiente.toLowerCase().split(',')[0].trim())
                        ? dbMatch.ambiente : themeData.ambiente,
                    elementos: dbMatch.elementos || themeData.elementos
                };
            } else {
                // Se tema é 'default', usar dados do banco se disponíveis
            themeData = {
                subject: dbMatch.subject || themeData.subject,
                acessorios: dbMatch.acessorios || themeData.acessorios,
                ambiente: dbMatch.ambiente || themeData.ambiente,
                elementos: dbMatch.elementos || themeData.elementos
            };
        }
        }
        
        console.log('[Thumbnail Complete] ThemeData usado:', {
            theme: theme,
            subject: themeData.subject?.substring(0, 50),
            ambiente: themeData.ambiente?.substring(0, 50)
        });

        // Função para adaptar um prompt baseado no título e tema
        // IMPORTANTE: Preservar TODAS as instruções de estilo visual do prompt de referência
        // Mas adaptar o conteúdo específico (estruturas, personagens) para o tema do título
        const adaptPromptForTitle = (promptToAdapt) => {
            if (!promptToAdapt) return '';
            
            let adapted = String(promptToAdapt);
            
            // 1. Substituir placeholders do título (se existirem)
        const placeholders = [/\[\s*T[ÍI]TULO\s*\]/gi, /\{\s*TITLE\s*\}/gi, /<\s*TITLE\s*>/gi, /\{\{\s*title\s*\}\}/gi, /\[TITLE\]/g];
        for (const rx of placeholders) {
                if (rx.test(adapted)) {
                    adapted = adapted.replace(rx, `"${titleText}"`);
            }
        }

            // 2. Substituir placeholders de personagem, ambiente, elementos (se existirem)
            adapted = adapted.replace(/\{PERSONAGEM\}/gi, themeData.subject);
            adapted = adapted.replace(/\{ACESSORIOS\}/gi, themeData.acessorios || '');
            adapted = adapted.replace(/\{AMBIENTE\}/gi, themeData.ambiente);
            adapted = adapted.replace(/\{ELEMENTOS_DE_FUNDO\}/gi, themeData.elementos);

            // 3. ADAPTAR CONTEÚDO ESPECÍFICO do prompt de referência para o tema do título
            // Substituir referências a temas diferentes (maya, aztec, etc.) por elementos do tema atual
            
            // Adaptar estruturas antigas genéricas para o tema específico
            if (theme === 'petra' || titleText.toLowerCase().includes('petra') || titleText.toLowerCase().includes('nabateu')) {
                // Para Petra: substituir referências a pirâmides maias/astecas por estruturas de Petra
                // Corrigir artigo "a" para "an" quando substituir por "ancient"
                adapted = adapted.replace(/like\s+a\s+(?:mayan\/aztec|mayan|aztec|maya)\s+pyramid/gi, 'like an ancient Nabataean carved stone structure like Petra\'s Al-Khazneh');
                adapted = adapted.replace(/mayan\/aztec pyramid/gi, 'ancient Nabataean carved stone structure like Petra\'s Al-Khazneh');
                adapted = adapted.replace(/mayan|aztec|maya pyramid/gi, 'ancient Nabataean carved stone monument');
                adapted = adapted.replace(/monumental ancient structure.*?like.*?pyramid/gi, 'monumental ancient Nabataean carved stone structure like Petra\'s Treasury');
                adapted = adapted.replace(/like\s+a\s+pyramid/gi, 'like an ancient Nabataean carved stone monument');
                adapted = adapted.replace(/pyramid/gi, (match, offset, string) => {
                    // Verificar contexto - se está falando de estrutura antiga, adaptar para Petra
                    const before = string.substring(Math.max(0, offset - 50), offset).toLowerCase();
                    const after = string.substring(offset + match.length, Math.min(string.length, offset + match.length + 50)).toLowerCase();
                    if (before.includes('ancient') || before.includes('structure') || before.includes('monumental') || before.includes('like a')) {
                        // Corrigir artigo se necessário
                        if (before.trim().endsWith('like a')) {
                            return 'an ancient Nabataean carved stone monument';
                        }
                        return 'ancient Nabataean carved stone monument';
                    }
                    return match;
                });
                
                // Corrigir "like a ancient" para "like an ancient"
                adapted = adapted.replace(/like\s+a\s+ancient/gi, 'like an ancient');
                
                // Adaptar cidade circular para cidade nabateia
                adapted = adapted.replace(/circular island city/gi, 'ancient Nabataean city carved into rose-red desert cliffs');
                adapted = adapted.replace(/island city/gi, 'ancient Nabataean desert city');
                adapted = adapted.replace(/cityscape/gi, 'ancient Nabataean cityscape carved into stone');
            } else if (theme === 'egito') {
                // Para Egito: substituir referências a pirâmides maias/astecas por estruturas egípcias
                adapted = adapted.replace(/mayan\/aztec pyramid/gi, 'ancient Egyptian pyramid');
                adapted = adapted.replace(/mayan|aztec|maya pyramid/gi, 'ancient Egyptian pyramid');
                adapted = adapted.replace(/circular island city/gi, 'ancient Egyptian city');
                adapted = adapted.replace(/island city/gi, 'ancient Egyptian city');
            }
            
            // 4. ADICIONAR PERSONAGEM E AMBIENTAÇÃO do tema detectado se não estiverem presentes
            // Verificar se já menciona personagem do tema específico
            const subjectKeywords = themeData.subject.toLowerCase().split(' ').filter(w => w.length > 4);
            const hasThemeSubject = subjectKeywords.some(keyword => adapted.toLowerCase().includes(keyword));
            
            // Verificar se já menciona estruturas/ambientação do tema
            const ambienteKeywords = themeData.ambiente.toLowerCase().split(',').map(w => w.trim()).filter(w => w.length > 3);
            const hasAmbiente = ambienteKeywords.some(keyword => adapted.toLowerCase().includes(keyword));
            
            // Verificar se o prompt já menciona o tema de forma genérica (ancient structure, monument, etc.)
            const hasGenericAncient = /(?:ancient|monumental|historical).*?(?:structure|monument|building|city|civilization)/gi.test(adapted);
            
            // Só adicionar personagem/ambiente se NÃO estiver presente E se o prompt não for muito específico sobre outro tema
            // Não adicionar se o prompt já tem conteúdo rico sobre estruturas antigas
            // DESABILITADO: Adicionar personagem estava cortando o texto original
            // As substituições de conteúdo (pyramid -> Nabataean structure) já adaptam o prompt suficiente
            /*
            if (!hasThemeSubject && !hasGenericAncient && themeData.subject) {
                // Verificar se o prompt começa com verbo de ação
                const actionVerbMatch = adapted.match(/^(create|design|generate|position|feature|address)\s+/i);
                
                if (actionVerbMatch) {
                    // Se começa com "Create a high-impact..." ou similar, inserir após "a/an/the"
                    const articleMatch = adapted.match(/^(create|design|generate|position|feature|address)\s+(?:a|an|the)\s+/i);
                    if (articleMatch) {
                        // Inserir personagem após o artigo
                        adapted = adapted.replace(/^(create|design|generate|position|feature|address)\s+(?:a|an|the)\s+/i, 
                            `$1 a cinematic thumbnail featuring ${themeData.subject}, `);
                } else {
                        // Inserir após o verbo
                        adapted = adapted.replace(/^(create|design|generate|position|feature|address)\s+/i, 
                            `$1 a cinematic thumbnail featuring ${themeData.subject}, `);
                    }
                } else {
                    // Adicionar no início se não começar com verbo de ação
                    adapted = `Generate a cinematic thumbnail featuring ${themeData.subject}, ${adapted}`;
                }
            }
            */
            
            // DESABILITADO: Adicionar ambientação estava criando duplicações e cortando texto
            // As substituições de conteúdo (city -> Nabataean city, etc.) já adaptam o prompt suficiente
            /*
            if (!hasAmbiente && !hasGenericAncient && themeData.ambiente) {
                // Adicionar ambientação de forma integrada, não no final
                // Procurar por menções de "background" ou "setting" para inserir próximo
                if (adapted.toLowerCase().includes('background') || adapted.toLowerCase().includes('setting')) {
                    // Já tem menção a background, não adicionar duplicado
                } else if (adapted.toLowerCase().includes('position') || adapted.toLowerCase().includes('frame')) {
                    // Inserir após menção de posicionamento
                    adapted = adapted.replace(/(position|frame|occupying).*?(?:\n|\.|,)/i, 
                        `$& Background setting: ${themeData.ambiente}. Include contextual elements: ${themeData.elementos}.`);
        } else {
                    // Adicionar de forma integrada no meio do prompt, não no final
                    // Procurar primeira menção de "structure" ou "monument" para inserir após
                    const structureMatch = adapted.match(/(?:structure|monument|building|city).*?(?:\n|\.|,)/i);
                    if (structureMatch) {
                        adapted = adapted.replace(/(?:structure|monument|building|city).*?(?:\n|\.|,)/i, 
                            `$& Background setting: ${themeData.ambiente}. Include contextual elements: ${themeData.elementos}.`);
            }
        }
            }
            */
            
            // 5. Remover apenas padrões de erro de renderização
            const errorTextPatterns = [
                /(?:MPITELOW|ALLCAPES|FRIGH|YELAPOS|NOT NOT|EXTRAD|BOLAPS|FRIGHT|YFDLOW|ALLLAPS|IMPOSSICTLC|COPELIITIACOM|PELTOS).*?\./gi,
                /CRITICAL.*?REMOVE.*?CORNER.*?MARKNGS.*?\./gi,
                /HEADLINDE.*?\./gi
            ];
            
            for (const pattern of errorTextPatterns) {
                adapted = adapted.replace(pattern, '').replace(/\s{2,}/g, ' ').trim();
            }
            
            // 6. Limpar apenas espaços múltiplos, preservando toda a estrutura do prompt
            adapted = adapted.replace(/\s{3,}/g, ' ').trim();
            
            return adapted;
        };
        
        // Adaptar cada um dos 4 prompts
        const adaptedPrompt1 = adaptPromptForTitle(prompt1);
        const adaptedPrompt2 = adaptPromptForTitle(prompt2);
        const adaptedPrompt3 = adaptPromptForTitle(prompt3);
        const adaptedCombinedPrompt = adaptPromptForTitle(combinedPrompt);
        
        console.log('[Thumbnail Complete] Prompts adaptados:', {
            prompt1Length: adaptedPrompt1.length,
            prompt2Length: adaptedPrompt2.length,
            prompt3Length: adaptedPrompt3.length,
            combinedPromptLength: adaptedCombinedPrompt.length
        });
        
        // Manter basePrompt para compatibilidade (usar prompt1 como padrão)
        const basePrompt = adaptedPrompt1;
        
        console.log('[Thumbnail Complete] Prompts adaptados e prontos:');
        console.log('[Thumbnail Complete] Prompt 1 original length:', prompt1.length);
        console.log('[Thumbnail Complete] Prompt 1 adaptado length:', adaptedPrompt1.length);
        console.log('[Thumbnail Complete] Prompt 1 original (primeiros 500 chars):', prompt1.substring(0, 500));
        console.log('[Thumbnail Complete] Prompt 1 adaptado (primeiros 500 chars):', adaptedPrompt1.substring(0, 500));
        console.log('[Thumbnail Complete] Verificando preservação de elementos importantes:');
        console.log('  - Tem "holographic":', adaptedPrompt1.toLowerCase().includes('holographic'));
        console.log('  - Tem "blueprint":', adaptedPrompt1.toLowerCase().includes('blueprint'));
        console.log('  - Tem "teal":', adaptedPrompt1.toLowerCase().includes('teal'));
        console.log('  - Tem "golden":', adaptedPrompt1.toLowerCase().includes('golden'));
        console.log('  - Tem "4K" ou "ULTRAHD":', /4k|ultrahd/i.test(adaptedPrompt1));
        console.log('  - Tem cores hex (#):', /#[0-9a-f]{6}/i.test(adaptedPrompt1));

        // 4. Gerar headline de impacto e descrição SEO usando IA
        let apiKey = null;
        let service = null;
        let modelToUse = null;
        
        // Se ai_model foi fornecido, usar o modelo especificado
        if (ai_model) {
            if (ai_model.includes('claude') || ai_model === 'claude-3-7-sonnet-20250219') {
                service = 'claude';
                modelToUse = 'claude-3-7-sonnet-20250219';
            } else if (ai_model.includes('gpt') || ai_model === 'gpt-4o') {
                service = 'openai';
                modelToUse = 'gpt-4o';
            } else if (ai_model.includes('gemini') || ai_model === 'gemini-2.5-pro') {
                service = 'gemini';
                modelToUse = 'gemini-2.5-pro';
            }
            
            // Buscar API key para o serviço especificado
            if (service) {
                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                if (keyData && keyData.api_key) {
                    try {
                        apiKey = decrypt(keyData.api_key);
                    } catch (e) {
                        service = null;
                        modelToUse = null;
                    }
                } else {
                    service = null;
                    modelToUse = null;
                }
            }
        }
        
        // Se não especificado ou falhou, usar prioridade automática
        if (!apiKey) {
            const services = ['claude', 'openai', 'gemini'];
            for (const svc of services) {
                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
                if (keyData && keyData.api_key) {
                    try {
                        apiKey = decrypt(keyData.api_key);
                        service = svc;
                        if (svc === 'claude') modelToUse = 'claude-3-7-sonnet-20250219';
                        else if (svc === 'openai') modelToUse = 'gpt-4o';
                        else modelToUse = 'gemini-2.5-pro';
                        break;
                    } catch (e) {
                        continue;
                    }
                }
            }
        }

        if (!apiKey) {
            return res.status(400).json({ msg: 'Nenhuma API key configurada. Configure pelo menos uma API nas Configurações.' });
        }

        // Mapeamento de idiomas para o prompt
        const languageMap = {
            'pt-BR': 'Português (Brasil)',
            'pt-PT': 'Português (Portugal)',
            'pt': 'Português (Brasil)',
            'en-US': 'English',
            'en-GB': 'English',
            'en': 'English',
            'es-ES': 'Español',
            'es-419': 'Español',
            'es': 'Español',
            'fr': 'Français',
            'de': 'Deutsch',
            'it': 'Italiano',
            'ja': '日本語',
            'ko': '한국어',
            'zh': '中文',
            'ru': 'Русский'
        };
        const languageName = languageMap[language] || languageMap['pt-BR'];

        // Prompt para gerar 3 headlines e SEO
        const seoPrompt = `Com base no título do vídeo: "${titleText}"

IDIOMA DE RESPOSTA: ${languageName}

Gere TUDO NO IDIOMA ${languageName}:
1. TRÊS VARIAÇÕES DE HEADLINES DE IMPACTO (máximo 6 palavras cada, chamativas, virais, que gerem curiosidade) - cada uma com um ângulo diferente
2. Uma DESCRIÇÃO SEO otimizada (2-3 frases, inclua palavras-chave relevantes, seja persuasiva) no idioma ${languageName}
3. PRINCIPAIS TAGS (10-15 tags separadas por vírgula, relevantes ao tema) no idioma ${languageName}

RESPONDA APENAS COM JSON:
{
  "headline1": "PRIMEIRA HEADLINE DE IMPACTO",
  "headline2": "SEGUNDA HEADLINE DE IMPACTO",
  "headline3": "TERCEIRA HEADLINE DE IMPACTO",
  "seoDescription": "Descrição SEO otimizada aqui...",
  "tags": "tag1, tag2, tag3, tag4, tag5..."
}`;

        let seoResponse;
        if (service === 'claude') {
            seoResponse = await callClaudeAPI(seoPrompt, apiKey, modelToUse);
        } else if (service === 'openai') {
            seoResponse = await callOpenAIAPI(seoPrompt, apiKey, modelToUse);
        } else {
            seoResponse = await callGeminiAPI(seoPrompt, apiKey, modelToUse);
        }

        const seoText = typeof seoResponse === 'string' ? seoResponse : (seoResponse.titles || JSON.stringify(seoResponse));
        const parsedSEO = parseAIResponse(seoText, service);
        
        console.log('[Thumbnail Complete] SEO parseado:', {
            hasHeadline1: !!parsedSEO.headline1,
            hasHeadline2: !!parsedSEO.headline2,
            hasHeadline3: !!parsedSEO.headline3,
            hasHeadline: !!parsedSEO.headline,
            hasSeoDescription: !!parsedSEO.seoDescription,
            hasTags: !!parsedSEO.tags,
            parsedKeys: Object.keys(parsedSEO)
        });
        
        // Extrair as 3 headlines geradas com fallbacks melhorados
        const headline1 = parsedSEO.headline1 || parsedSEO.headline || parsedSEO.headline_1 || titleText.split(':')[0].trim();
        const headline2 = parsedSEO.headline2 || parsedSEO.headline_2 || headline1; // Se não tiver, usar headline1 como fallback
        const headline3 = parsedSEO.headline3 || parsedSEO.headline_3 || headline1; // Se não tiver, usar headline1 como fallback
        
        console.log('[Thumbnail Complete] Headlines extraídas:', {
            headline1: headline1,
            headline2: headline2,
            headline3: headline3
        });
        
        // Gerar descrição SEO e tags base para todas as variações
        const baseSeoDescription = parsedSEO.seoDescription || `Descubra tudo sobre ${titleText}. Conteúdo exclusivo e detalhado.`;
        const baseTags = parsedSEO.tags ? parsedSEO.tags.split(',').map(t => t.trim()).filter(Boolean) : [];

        // Gerar descrições e tags específicas para cada headline
        const generateVariationSEO = async (headline, index) => {
            if (!headline) return { description: baseSeoDescription, tags: baseTags };
            
            try {
                const variationSeoPrompt = `Você é um especialista em SEO, marketing de conteúdo e viralização no YouTube.

TÍTULO DO VÍDEO: "${titleText}"
HEADLINE ESPECÍFICA: "${headline}"

IDIOMA DE RESPOSTA: ${languageName}

IMPORTANTE: Esta é a variação ${index} de 4. Cada variação DEVE ter uma descrição SEO e tags ÚNICAS e DIFERENTES das outras, otimizadas para ALTA VIRALIZAÇÃO no YouTube.

REGRAS DO YOUTUBE:
- Descrições devem ser autênticas e não enganosas
- Não usar clickbait excessivo
- Focar em valor real para o espectador
- Usar palavras-chave naturalmente

Gere NO IDIOMA ${languageName}:
1. Uma DESCRIÇÃO SEO otimizada para VIRALIZAÇÃO (2–3 frases bem formatadas, com pontuação correta, usando vírgulas e pontos) que:
   - Combine o título do vídeo com esta headline específica "${headline}"
   - Seja EXTREMAMENTE persuasiva e gere CURIOSIDADE máxima
   - Use palavras-chave de ALTO VOLUME de busca no YouTube
   - Crie URGÊNCIA e INTERESSE IMEDIATO
   - Use gatilhos mentais (mistério, segredo, verdade, revelação, ninguém explica, etc.)
   - Seja DIFERENTE e ÚNICA das outras variações
   - Seja otimizada para ALGORITMO do YouTube (engajamento, retenção, CTR)
   
2. PRINCIPAIS TAGS (string separada por vírgulas) que:
   - Sejam relevantes ao título E à headline específica "${headline}"
   - Incluam palavras-chave de ALTO VOLUME relacionadas a "${headline}" e ao contexto do vídeo
   - Sejam DIFERENTES e ÚNICAS das outras variações
   - Tenham ENTRE 400 e 500 CARACTERES no TOTAL (conte o número de caracteres da string completa)
   - Não usar hashtags, não repetir termos consecutivamente e manter idioma ${languageName}

RESPONDA APENAS COM JSON VÁLIDO (sem markdown, sem código):
{
  "seoDescription": "Descrição SEO única, formatada corretamente e otimizada para viralização no YouTube para esta headline específica...",
  "tags": "tag1, tag2, tag3, tag4, tag5, ... (string entre 400 e 500 caracteres no total)"
}`;
                
                let variationSeoResponse;
                if (service === 'claude') {
                    variationSeoResponse = await callClaudeAPI(variationSeoPrompt, apiKey, modelToUse);
                } else if (service === 'openai') {
                    variationSeoResponse = await callOpenAIAPI(variationSeoPrompt, apiKey, modelToUse);
                } else {
                    variationSeoResponse = await callGeminiAPI(variationSeoPrompt, apiKey, modelToUse);
                }
                
                const variationSeoText = typeof variationSeoResponse === 'string' ? variationSeoResponse : (variationSeoResponse.titles || JSON.stringify(variationSeoResponse));
                const parsedVariationSEO = parseAIResponse(variationSeoText, service);
                
                // Garantir que temos descrição e tags válidas
                const finalDescription = parsedVariationSEO.seoDescription || parsedVariationSEO.description || baseSeoDescription;
                
                // Processar tags: pode vir como string ou array
                let finalTags;
                if (parsedVariationSEO.tags) {
                    if (typeof parsedVariationSEO.tags === 'string') {
                        // Se for string, dividir por vírgula e limpar
                        finalTags = parsedVariationSEO.tags.split(',').map(t => t.trim()).filter(Boolean);
                    } else if (Array.isArray(parsedVariationSEO.tags)) {
                        // Se já for array, usar diretamente
                        finalTags = parsedVariationSEO.tags.map(t => typeof t === 'string' ? t.trim() : String(t)).filter(Boolean);
                    } else {
                        // Se for outro tipo, converter para string e processar
                        finalTags = String(parsedVariationSEO.tags).split(',').map(t => t.trim()).filter(Boolean);
                    }
                } else {
                    finalTags = baseTags;
                }
                
                // Garantir que temos pelo menos algumas tags
                if (!finalTags || finalTags.length === 0) {
                    finalTags = baseTags;
                }
                
                // Ajustar comprimento da string de tags para 400–500 caracteres
                const toWordPool = (txt) => Array.from(new Set(String(txt).toLowerCase().split(/[^a-zA-ZÀ-ÿ0-9]+/).filter(w => w && w.length > 2)));
                const pool = Array.from(new Set([
                    ...toWordPool(titleText),
                    ...toWordPool(headline),
                    'história','mistério','arqueologia','segredos','civilização','antigas','verdade','descoberta','expedição','deserto','rocha','templo'
                ]));
                let tagsStr = finalTags.join(', ');
                const minLen = 400, maxLen = 500;
                if (tagsStr.length < minLen) {
                    for (let w of pool) {
                        if (!tagsStr.includes(w)) {
                            tagsStr += (tagsStr ? ', ' : '') + w;
                        }
                        if (tagsStr.length >= minLen) break;
                    }
                }
                if (tagsStr.length > maxLen) {
                    // cortar no último separador antes de maxLen
                    const cut = tagsStr.lastIndexOf(', ', maxLen);
                    tagsStr = cut > 0 ? tagsStr.slice(0, cut) : tagsStr.slice(0, maxLen);
                }
                
                console.log(`[Thumbnail Complete] SEO gerado para variação ${index}:`, {
                    hasDescription: !!finalDescription,
                    descriptionLength: finalDescription.length,
                    descriptionPreview: finalDescription.substring(0, 100) + '...',
                    tagsCount: finalTags.length,
                    tagsPreview: finalTags.slice(0, 5).join(', ') + '...'
                });
                
                return {
                    description: finalDescription.trim(), // Garantir que está limpo
                    tags: tagsStr // Manter como string com 400–500 caracteres
                };
            } catch (err) {
                console.warn(`[Thumbnail Complete] Erro ao gerar SEO para variação ${index}, usando base:`, err.message);
                return { description: baseSeoDescription, tags: baseTags };
            }
        };
        
        // Gerar SEO para cada variação
        console.log('[Thumbnail Complete] Gerando SEO único para cada variação...');
        const variation1SEO = await generateVariationSEO(headline1, 1);
        console.log('[Thumbnail Complete] Variação 1 SEO:', {
            descriptionLength: variation1SEO.description?.length || 0,
            tagsCount: Array.isArray(variation1SEO.tags) ? variation1SEO.tags.length : (variation1SEO.tags ? variation1SEO.tags.split(',').length : 0),
            descriptionPreview: variation1SEO.description?.substring(0, 100) || 'N/A'
        });
        
        const variation2SEO = await generateVariationSEO(headline2, 2);
        console.log('[Thumbnail Complete] Variação 2 SEO:', {
            descriptionLength: variation2SEO.description?.length || 0,
            tagsCount: Array.isArray(variation2SEO.tags) ? variation2SEO.tags.length : (variation2SEO.tags ? variation2SEO.tags.split(',').length : 0),
            descriptionPreview: variation2SEO.description?.substring(0, 100) || 'N/A'
        });
        
        const variation3SEO = await generateVariationSEO(headline3, 3);
        console.log('[Thumbnail Complete] Variação 3 SEO:', {
            descriptionLength: variation3SEO.description?.length || 0,
            tagsCount: Array.isArray(variation3SEO.tags) ? variation3SEO.tags.length : (variation3SEO.tags ? variation3SEO.tags.split(',').length : 0),
            descriptionPreview: variation3SEO.description?.substring(0, 100) || 'N/A'
        });
        
        const variation4SEO = await generateVariationSEO(headline1, 4); // Usar headline1 para a 4ª variação (junção)
        console.log('[Thumbnail Complete] Variação 4 SEO:', {
            descriptionLength: variation4SEO.description?.length || 0,
            tagsCount: Array.isArray(variation4SEO.tags) ? variation4SEO.tags.length : (variation4SEO.tags ? variation4SEO.tags.split(',').length : 0),
            descriptionPreview: variation4SEO.description?.substring(0, 100) || 'N/A'
        });

        // 5. Preparar as 4 variações: 
        // - Variação 1: Prompt 1 + headline1
        // - Variação 2: Prompt 2 + headline2
        // - Variação 3: Prompt 3 + headline3
        // - Variação 4: Prompt Combinado (junção dos 3) + headline1
        // IMPORTANTE: Usar o prompt de referência quase inteiro, apenas adicionando a headline
        // Instruções mínimas para não interferir com o prompt padrão de referência
        const negativeBlock = `Remove corner markings, logos, watermarks, labels and badges. Do not render any text, words, letters, captions, typography, font names or color codes anywhere in the image.`;
        
        // Instruções sem overlay de texto: manter estilo e impedir qualquer legenda/texto
        const variations_data = [
            {
                promptBase: adaptedPrompt1, // Prompt 1 (preservado quase inteiro)
                headline: headline1,
                hasHeadline: false,
                seoDescription: variation1SEO.description,
                tags: variation1SEO.tags,
                promptName: 'Prompt 1'
            },
            {
                promptBase: adaptedPrompt2, // Prompt 2 (preservado quase inteiro)
                headline: headline2,
                hasHeadline: false,
                seoDescription: variation2SEO.description,
                tags: variation2SEO.tags,
                promptName: 'Prompt 2'
            },
            {
                promptBase: adaptedPrompt3, // Prompt 3 (preservado quase inteiro)
                headline: headline3,
                hasHeadline: false,
                seoDescription: variation3SEO.description,
                tags: variation3SEO.tags,
                promptName: 'Prompt 3'
            },
            {
                promptBase: adaptedCombinedPrompt, // Prompt Combinado (preservado quase inteiro)
                headline: headline1, // Usar headline1 para a junção
                hasHeadline: false,
                seoDescription: variation4SEO.description,
                tags: variation4SEO.tags,
                promptName: 'Prompt Combinado'
            }
        ];

        // 6. Gerar imagens para cada variação
        const images = [];
        console.log(`[Thumbnail Complete] Iniciando geração de ${variations_data.length} variações de imagens...`);
        console.log(`[Thumbnail Complete] 🔍 Verificando dados das variações antes de gerar imagens:`);
        variations_data.forEach((v, idx) => {
            console.log(`  Variação ${idx + 1} (${v.promptName}):`, {
                headline: v.headline || 'N/A',
                hasSeoDesc: !!v.seoDescription,
                seoDescLength: v.seoDescription ? v.seoDescription.length : 0,
                seoDescPreview: v.seoDescription ? v.seoDescription.substring(0, 100) + '...' : 'N/A',
                hasTags: !!v.tags,
                tagsType: Array.isArray(v.tags) ? 'array' : typeof v.tags,
                tagsLength: Array.isArray(v.tags) ? v.tags.length : (v.tags ? String(v.tags).length : 0),
                tagsPreview: Array.isArray(v.tags) ? v.tags.slice(0, 3).join(', ') + '...' : (v.tags ? String(v.tags).substring(0, 100) + '...' : 'N/A')
            });
        });
        
        for (let i = 0; i < variations_data.length; i++) {
            const variation = variations_data[i];
            // Construir prompt final usando o promptBase específico de cada variação
            // IMPORTANTE: O prompt de referência deve ser usado quase inteiro
            // Apenas adicionar a headline de forma que não interfira com as instruções de estilo
            const promptBase = variation.promptBase || basePrompt;
            
            // Construir prompt final sem qualquer overlay/legenda/texto na imagem
            let finalPrompt;
            
            let cleanedPrompt = promptBase;
            
            // Remover placeholders de texto genéricos e qualquer instrução de overlay
            cleanedPrompt = cleanedPrompt
                .replace(/\[TITLE\]|\[TÍTULO\]|\{TITLE\}|\{TÍTULO\}/gi, '')
                .replace(/text\s*overlay.*$/gim, '')
                .replace(/add\s*text.*$/gim, '')
                .replace(/caption.*$/gim, '')
                .replace(/font.*montserrat.*$/gim, '')
                .replace(/#[0-9a-f]{3,6}/gim, '')
                .replace(/\b(32pt|tracking|kerning|stroke|outline|drop\s*shadow|glow)\b/gi, '');
            // Remover indicadores visuais comuns de texto/etiquetas
            cleanedPrompt = cleanedPrompt
                .replace(/\b(4k|badge|label|corner\s*markings)\b/gi, '')
                .replace(/impossible\s+engineering/gi, '')
                .replace(/\bno\s+[a-z][a-z]+/gi, '');
            
            // Regras de texto/caption conforme seletor de 4K
            const allow4k = !!include_4k_badge;
            const textRules = allow4k 
                ? `Renderize APENAS um pequeno selo "4K" no canto superior direito. NÃO RENDERIZE nenhum outro texto, legendas, números, nomes de fontes ou códigos de cor.`
                : `NÃO RENDERIZE QUALQUER TEXTO, LEGENDAS, NÚMEROS, LETRAS, TIPOGRAFIA, NOMES DE FONTES OU CÓDIGOS DE COR NA IMAGEM.`;
            
            // Negativos padrões (sempre remover logos e watermarks; badges/labels só quando não permitir 4K)
            const negativeBlockFinal = allow4k 
                ? `Remove logos and watermarks.` 
                : negativeBlock;
            
            // Instrução opcional do selo 4K (quando permitido)
            const badgeInstruction = allow4k 
                ? `Adicione um selo "4K" discreto no canto superior direito (pequeno, alta legibilidade, sem outros textos).`
                : ``;
            
            finalPrompt = `${cleanedPrompt}

${textRules}
${badgeInstruction}

${negativeBlockFinal}`;
            
            try {
                console.log(`[Thumbnail Complete] Gerando variação ${i + 1}/${variations_data.length}...`);
                console.log(`[Thumbnail Complete] Prompt usado: ${variation.promptName || 'Padrão'}`);
                console.log(`[Thumbnail Complete] Headline: ${variation.headline || 'SEM HEADLINE'}`);
                console.log(`[Thumbnail Complete] Tamanho do prompt base: ${promptBase.length} caracteres`);
                console.log(`[Thumbnail Complete] Prompt final (primeiros 300 chars): ${finalPrompt.substring(0, 300)}...`);
                
                // Usar URL mais confiável (127.0.0.1 ao invés de localhost)
                const imageFxUrl = `http://127.0.0.1:${PORT}/api/generate/imagefx`;
                console.log(`[Thumbnail Complete] Chamando endpoint: ${imageFxUrl}`);
                
                // Criar AbortController para timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 120000); // 2 minutos
                
                try {
                    const genResp = await fetch(imageFxUrl, {
                method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json', 
                            'Authorization': req.headers['authorization'] || '' 
                        },
                        body: JSON.stringify({ 
                            prompt: finalPrompt, 
                            niche: niche || 'Entretenimento', 
                            subniche: subniche || 'Geral', 
                            style: style || 'photorealistic', 
                            saveToLibrary: true 
                        }),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                
                    if (!genResp.ok) {
                        let errorText = await genResp.text();
                        let errorMessage = errorText;
                        
                        // Tentar parsear como JSON para extrair mensagem mais específica
                        try {
                            const errorJson = JSON.parse(errorText);
                            if (errorJson.msg) {
                                errorMessage = errorJson.msg;
                            } else if (errorJson.message) {
                                errorMessage = errorJson.message;
                            }
                        } catch (e) {
                            // Se não for JSON, usar o texto como está
                        }
                        
                        console.error(`[Thumbnail Complete] Erro HTTP ${genResp.status} ao gerar imagem ${i + 1}:`, errorMessage);
                        
                        // Se for erro 401, incluir informação específica
                        if (genResp.status === 401) {
                            throw new Error(`Erro ao gerar imagem ${i + 1}: ${genResp.status} - ${errorMessage}`);
                        }
                        
                        throw new Error(`Erro ao gerar imagem ${i + 1}: ${genResp.status} - ${errorMessage.substring(0, 200)}`);
                    }
                    
            const genData = await genResp.json();
                    console.log(`[Thumbnail Complete] Resposta da geração ${i + 1}:`, {
                        hasImageUrl: !!genData.imageUrl,
                        hasImage: !!genData.image,
                        hasResult: !!genData.result,
                        savedToLibrary: !!genData.savedToLibrary,
                        imageUrlType: typeof genData.imageUrl,
                        imageType: typeof genData.image,
                        imageUrlLength: genData.imageUrl ? String(genData.imageUrl).length : 0,
                        imageLength: genData.image ? String(genData.image).length : 0
                    });
                    
                    // Priorizar imageUrl (URL completa), depois image (base64), depois result
                    let imageUrl = genData.imageUrl || genData.image || genData.result || null;
                    
                    // Se imageUrl é base64 mas não tem prefixo data:, adicionar
                    if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('data:')) {
                        imageUrl = `data:image/png;base64,${imageUrl}`;
                    }
                    
                    if (!imageUrl) {
                        console.error(`[Thumbnail Complete] Nenhuma URL de imagem retornada para variação ${i + 1}`);
                        console.error(`[Thumbnail Complete] Dados recebidos:`, JSON.stringify(genData).substring(0, 500));
                        throw new Error(`Nenhuma imagem foi gerada para a variação ${i + 1}`);
                    }
                    
                    console.log(`[Thumbnail Complete] URL da imagem ${i + 1}: ${imageUrl.substring(0, 100)}...`);
                    
                    // Garantir que temos a headline correta - usar diretamente da variação
                    // Variação 0 = headline1 (Prompt 1), Variação 1 = headline2 (Prompt 2), 
                    // Variação 2 = headline3 (Prompt 3), Variação 3 = headline1 (Prompt Combinado)
                    const headlineMap = [headline1, headline2, headline3, headline1];
                    // Priorizar o headline da variação, depois usar o mapeamento
                    const headlineValue = (variation.headline !== undefined && variation.headline !== null) 
                        ? variation.headline 
                        : headlineMap[i];
                    // IMPORTANTE: Usar os dados de SEO específicos da variação, não os base
                    // As variações já têm seoDescription e tags únicos gerados por generateVariationSEO
                    const seoDescValue = variation.seoDescription || baseSeoDescription;
                    // Tags já vêm como string ajustada (400–500 chars) de generateVariationSEO
                    let tagsValue = variation.tags ? String(variation.tags) : (Array.isArray(baseTags) ? baseTags.join(', ') : (baseTags || ''));
                    
                    console.log(`[Thumbnail Complete] Dados da variação ${i + 1}:`, {
                        variationHeadline: variation.headline,
                        variationSeoDescription: variation.seoDescription ? variation.seoDescription.substring(0, 100) : 'N/A',
                        variationTags: tagsValue.substring(0, 100),
                        mappedHeadline: headlineMap[i],
                        finalHeadline: headlineValue,
                        hasHeadline: variation.hasHeadline,
                        seoDescriptionLength: seoDescValue ? seoDescValue.length : 0,
                        seoDescriptionPreview: seoDescValue ? seoDescValue.substring(0, 100) : 'N/A',
                        tagsLength: tagsValue ? tagsValue.length : 0,
                        tagsPreview: tagsValue ? tagsValue.substring(0, 100) : 'N/A'
                    });
                    
            images.push({
                        imageUrl: imageUrl,
                        image: imageUrl, // Compatibilidade: também incluir como 'image'
                savedToLibrary: !!genData.savedToLibrary,
                        libraryId: genData.libraryId || null,
                        headline: headlineValue, // Headline específica desta variação
                        headlineText: headlineValue, // Para o campo "Headline de Impacto" - CRÍTICO: sempre retornar a headline correta
                        hasHeadline: variation.hasHeadline !== false, // Garantir que seja true se tiver headline
                        seoDescription: seoDescValue, // Descrição SEO única desta variação
                        tags: tagsValue, // Tags únicas desta variação (formato string)
                        promptUsed: finalPrompt, // Prompt completo usado para gerar esta imagem (para copiar)
                        promptName: variation.promptName || `Variação ${i + 1}` // Nome do prompt usado
                    });
                    
                    console.log(`[Thumbnail Complete] ✅ Variação ${i + 1} adicionada ao array:`, {
                        headline: headlineValue || 'NULL',
                        headlineText: headlineValue || 'NULL',
                        seoDescLength: seoDescValue ? seoDescValue.length : 0,
                        tagsLength: tagsValue ? tagsValue.length : 0,
                        promptName: variation.promptName || 'N/A'
                    });
                    
                    console.log(`[Thumbnail Complete] ✅ Variação ${i + 1} gerada com sucesso - Headline: "${headlineValue || 'SEM HEADLINE'}"`);
                } catch (imgError) {
                    clearTimeout(timeoutId);
                    if (imgError.name === 'AbortError') {
                        console.error(`[Thumbnail Complete] Timeout ao gerar variação ${i + 1} (2 minutos)`);
                        imgError.message = `Timeout: A geração da imagem ${i + 1} demorou mais de 2 minutos`;
                    }
                    console.error(`[Thumbnail Complete] Erro ao gerar variação ${i + 1}:`, imgError.message);
                    // Continuar gerando outras variações mesmo se uma falhar
                    // Mas adicionar erro na resposta
                    images.push({
                        imageUrl: null,
                        savedToLibrary: false,
                        libraryId: null,
                        headline: variation.headline || null,
                        headlineText: variation.headline || null,
                        hasHeadline: variation.hasHeadline,
                        seoDescription: variation.seoDescription || baseSeoDescription,
                        tags: Array.isArray(variation.tags) ? variation.tags.join(', ') : (variation.tags || baseTags.join(', ')),
                        error: imgError.message
                    });
                }
            } catch (outerError) {
                console.error(`[Thumbnail Complete] Erro externo ao gerar variação ${i + 1}:`, outerError.message);
                images.push({
                    imageUrl: null,
                    savedToLibrary: false,
                    libraryId: null,
                    headline: variation.headline || null,
                    headlineText: variation.headline || null,
                    hasHeadline: variation.hasHeadline,
                    seoDescription: variation.seoDescription || baseSeoDescription,
                    tags: Array.isArray(variation.tags) ? variation.tags.join(', ') : (variation.tags || baseTags.join(', ')),
                    error: outerError.message
                });
            }
        }
        
        // Verificar se pelo menos uma imagem foi gerada
        const successfulImages = images.filter(img => img.imageUrl !== null);
        if (successfulImages.length === 0) {
            console.error('[Thumbnail Complete] ❌ Nenhuma imagem foi gerada com sucesso');
            
            // Verificar se todos os erros são de autenticação (401)
            const allAuthErrors = images.every(img => {
                const errorMsg = (img.error || '').toLowerCase();
                return errorMsg.includes('401') || 
                       errorMsg.includes('authentication') || 
                       errorMsg.includes('cookies do imagefx') ||
                       errorMsg.includes('expirados') ||
                       errorMsg.includes('invalid authentication');
            });
            
            // Verificar se algum erro específico menciona cookies do ImageFX
            const hasImageFxAuthError = images.some(img => {
                const errorMsg = (img.error || '').toLowerCase();
                return errorMsg.includes('cookies do imagefx') || 
                       errorMsg.includes('imagefx expirados');
            });
            
            if (allAuthErrors || hasImageFxAuthError) {
                // Retornar erro 401 específico para autenticação
                return res.status(401).json({ 
                    msg: 'Cookies do ImageFX expirados ou inválidos. Por favor, atualize os cookies nas Configurações.',
                    requiresAuth: true,
                    errors: images.map((img, idx) => ({ variation: idx + 1, error: img.error || 'Erro de autenticação' }))
                });
            }
            
            // Caso contrário, retornar erro 500 genérico
            return res.status(500).json({ 
                msg: 'Nenhuma imagem foi gerada. Verifique se o serviço de geração de imagens está funcionando e se há API keys configuradas.',
                errors: images.map((img, idx) => ({ variation: idx + 1, error: img.error || 'Erro desconhecido' }))
            });
        }
        
        console.log(`[Thumbnail Complete] ✅ ${successfulImages.length}/${variations_data.length} imagens geradas com sucesso`);
        
        // Filtrar apenas imagens bem-sucedidas para retornar ao frontend
        const successfulVariations = images.filter(img => img.imageUrl !== null);
        
        console.log(`[Thumbnail Complete] Preparando resposta com ${successfulVariations.length} variações:`);
        successfulVariations.forEach((img, idx) => {
            console.log(`  - Variação ${idx + 1}: ${img.headline || 'SEM HEADLINE'}, URL: ${img.imageUrl ? 'SIM' : 'NÃO'}`);
        });

        // 7. Retornar resultado completo com as 3 headlines e variação sem headline
        // Cada variação já tem sua própria seoDescription e tags
        // Função auxiliar para formatar descrição (remover quebras de linha extras, espaços múltiplos)
        const formatDescription = (desc) => {
            if (!desc) return '';
            return String(desc)
                .replace(/\n{2,}/g, '\n') // Remover múltiplas quebras de linha
                .replace(/\s{2,}/g, ' ') // Remover múltiplos espaços
                .trim();
        };
        
        // Função auxiliar para formatar tags (sempre retornar string)
        const formatTags = (tags) => {
            if (!tags) return '';
            if (Array.isArray(tags)) {
                return tags.filter(Boolean).join(', ');
            }
            if (typeof tags === 'string') {
                return tags.trim();
            }
            return String(tags).trim();
        };
        
        const responseData = {
            success: true,
            title: titleText,
            headlines: {
                headline1: headline1,
                headline2: headline2,
                headline3: headline3,
                none: null // Opção para sem headline
            },
            // Lista de headlines para seleção (incluindo opção "sem headline")
            // IMPORTANTE: Estas são as "frases de impacto" que o usuário pode selecionar para gerar novamente
            headlineOptions: [
                { id: 'headline1', text: headline1 || 'Headline 1', value: headline1 || null },
                { id: 'headline2', text: headline2 || 'Headline 2', value: headline2 || null },
                { id: 'headline3', text: headline3 || 'Headline 3', value: headline3 || null },
                { id: 'none', text: 'Sem Headline', value: null }
            ],
            // Manter descrição e tags base para compatibilidade, mas cada variação tem suas próprias
            seoDescription: formatDescription(baseSeoDescription),
            tags: formatTags(baseTags),
            variations: successfulVariations.map((v, idx) => {
                // Mapear headlines baseado no índice: 
                // 0=headline1 (Prompt 1), 1=headline2 (Prompt 2), 2=headline3 (Prompt 3), 3=headline1 (Prompt Combinado)
                const headlineMap = [headline1, headline2, headline3, headline1];
                
                // Priorizar: 1) headline da variação, 2) headlineText da variação, 3) mapeamento por índice
                let headlineValue = v.headline !== undefined && v.headline !== null ? v.headline : 
                                   (v.headlineText !== undefined && v.headlineText !== null ? v.headlineText : 
                                   headlineMap[idx]);
                
                // Se ainda não tiver, usar o mapeamento por índice como fallback final
                if (!headlineValue) {
                    headlineValue = headlineMap[idx];
                }
                
                const finalSeoDesc = formatDescription(v.seoDescription || baseSeoDescription);
                const finalTags = formatTags(v.tags || baseTags);
                
                console.log(`[Thumbnail Complete] Formatando variação ${idx + 1}:`, {
                    promptName: v.promptName || `Variação ${idx + 1}`,
                    vHeadline: v.headline,
                    vHeadlineText: v.headlineText,
                    mappedHeadline: headlineMap[idx],
                    finalHeadline: headlineValue,
                    hasHeadline: v.hasHeadline,
                    seoDescLength: finalSeoDesc.length,
                    tagsLength: finalTags.length
                });
                
                // IMPORTANTE: SEMPRE usar os dados específicos da variação se existirem
                // Priorizar: 1) dados da variação (v.seoDescription, v.tags), 2) dados formatados, 3) dados base
                const finalSeoDescToUse = v.seoDescription 
                    ? formatDescription(v.seoDescription) 
                    : (finalSeoDesc || formatDescription(baseSeoDescription));
                const finalTagsToUse = v.tags 
                    ? formatTags(v.tags) 
                    : (finalTags || formatTags(baseTags));
                
                // Garantir que o promptUsed esteja presente
                const promptUsedValue = v.promptUsed || null;
                
                console.log(`[Thumbnail Complete] 🔍 Mapeando variação ${idx + 1}:`, {
                    vHeadline: v.headline,
                    vHeadlineText: v.headlineText,
                    finalHeadline: headlineValue,
                    vSeoDesc: v.seoDescription ? v.seoDescription.substring(0, 50) + '...' : 'N/A',
                    finalSeoDesc: finalSeoDescToUse ? finalSeoDescToUse.substring(0, 50) + '...' : 'N/A',
                    vTags: v.tags ? (typeof v.tags === 'string' ? v.tags.substring(0, 50) : String(v.tags).substring(0, 50)) + '...' : 'N/A',
                    finalTags: finalTagsToUse ? finalTagsToUse.substring(0, 50) + '...' : 'N/A',
                    hasPromptUsed: !!promptUsedValue,
                    promptName: v.promptName
                });
                
                return {
                    ...v,
                    // CRÍTICO: Garantir que headlineText está sempre presente e correto
                    headline: headlineValue,
                    headlineText: headlineValue || 'N/A', // Este é o campo que o frontend usa para "Headline de Impacto" - NUNCA deve ser null/undefined
                    hasHeadline: headlineValue && headlineValue !== 'N/A' ? true : false, // true se tiver headline válida
                    promptName: v.promptName || `Variação ${idx + 1}`, // Nome do prompt usado
                    promptUsed: promptUsedValue, // Prompt completo usado para gerar esta imagem (para copiar)
                    // Formatar descrição corretamente - SEMPRE usar dados específicos da variação se existirem
                    seoDescription: finalSeoDescToUse,
                    // Formatar tags corretamente (sempre string) - SEMPRE usar dados específicos da variação se existirem
                    tags: finalTagsToUse
                };
            }),
            images: successfulVariations.map((v, idx) => {
                // Mapear headlines baseado no índice: 
                // 0=headline1 (Prompt 1), 1=headline2 (Prompt 2), 2=headline3 (Prompt 3), 3=headline1 (Prompt Combinado)
                const headlineMap = [headline1, headline2, headline3, headline1];
                
                // Priorizar: 1) headline da variação, 2) headlineText da variação, 3) mapeamento por índice
                let headlineValue = v.headline !== undefined && v.headline !== null ? v.headline : 
                                   (v.headlineText !== undefined && v.headlineText !== null ? v.headlineText : 
                                   headlineMap[idx]);
                
                // Se ainda não tiver, usar o mapeamento por índice como fallback final
                if (!headlineValue) {
                    headlineValue = headlineMap[idx];
                }
                
                // IMPORTANTE: SEMPRE usar os dados específicos da variação se existirem
                // Priorizar: 1) dados da variação (v.seoDescription, v.tags), 2) dados base formatados
                const finalSeoDescToUse = v.seoDescription 
                    ? formatDescription(v.seoDescription) 
                    : formatDescription(v.seoDescription || baseSeoDescription);
                const finalTagsToUse = v.tags 
                    ? formatTags(v.tags) 
                    : formatTags(v.tags || baseTags);
                
                // Garantir que o promptUsed esteja presente
                const promptUsedValue = v.promptUsed || null;
                
                return {
                    ...v,
                    headline: headlineValue,
                    headlineText: headlineValue || 'N/A', // CRÍTICO: Campo usado pelo frontend - NUNCA deve ser null/undefined
                    hasHeadline: headlineValue && headlineValue !== 'N/A' ? true : false, // true se tiver headline válida
                    promptName: v.promptName || `Variação ${idx + 1}`, // Nome do prompt usado
                    promptUsed: promptUsedValue, // Prompt completo usado para gerar esta imagem (para copiar)
                    seoDescription: finalSeoDescToUse, // SEMPRE usar dados específicos da variação se existirem
                    tags: finalTagsToUse // SEMPRE usar dados específicos da variação se existirem
                };
            }) // Compatibilidade: também retornar como 'images'
        };
        
        console.log(`[Thumbnail Complete] Enviando resposta com ${responseData.variations.length} variações`);
        console.log(`[Thumbnail Complete] Headlines disponíveis:`, {
            headline1: headline1,
            headline2: headline2,
            headline3: headline3
        });
        console.log(`[Thumbnail Complete] HeadlineOptions:`, responseData.headlineOptions);
        console.log(`[Thumbnail Complete] Resumo das variações:`);
        responseData.variations.forEach((v, idx) => {
            console.log(`  Variação ${idx + 1}:`, {
                headline: v.headline || 'NULL/SEM HEADLINE',
                headlineText: v.headlineText || 'NULL/SEM HEADLINE',
                hasHeadline: v.hasHeadline,
                headlineType: typeof v.headlineText,
                headlineLength: v.headlineText ? v.headlineText.length : 0,
                promptName: v.promptName || 'N/A',
                hasPromptUsed: !!v.promptUsed,
                promptUsedLength: v.promptUsed ? v.promptUsed.length : 0,
                promptUsedPreview: v.promptUsed ? v.promptUsed.substring(0, 100) + '...' : 'N/A',
                seoDescPreview: v.seoDescription ? v.seoDescription.substring(0, 50) + '...' : 'N/A',
                seoDescLength: v.seoDescription ? v.seoDescription.length : 0,
                tagsPreview: v.tags ? v.tags.substring(0, 50) + '...' : 'N/A',
                tagsLength: v.tags ? v.tags.length : 0
            });
        });
        
        // Log detalhado da primeira variação para debug
        if (responseData.variations.length > 0) {
            const firstVar = responseData.variations[0];
            console.log(`[Thumbnail Complete] 🔍 DEBUG - Primeira variação completa:`, JSON.stringify({
                headline: firstVar.headline,
                headlineText: firstVar.headlineText,
                promptName: firstVar.promptName,
                promptUsed: firstVar.promptUsed ? firstVar.promptUsed.substring(0, 200) + '...' : null,
                seoDescription: firstVar.seoDescription ? firstVar.seoDescription.substring(0, 200) + '...' : null,
                tags: firstVar.tags ? firstVar.tags.substring(0, 200) + '...' : null
            }, null, 2));
        }
        
        // Log final antes de retornar - verificar estrutura completa
        console.log(`[Thumbnail Complete] 📤 Retornando resposta final:`, {
            totalVariations: responseData.variations.length,
            totalImages: responseData.images.length,
            hasHeadlines: {
                headline1: !!responseData.headlines.headline1,
                headline2: !!responseData.headlines.headline2,
                headline3: !!responseData.headlines.headline3
            },
            variationsWithData: responseData.variations.map((v, idx) => ({
                index: idx + 1,
                hasHeadline: !!v.headlineText && v.headlineText !== 'N/A',
                headlineText: v.headlineText || 'N/A',
                hasPromptUsed: !!v.promptUsed,
                hasSeoDesc: !!v.seoDescription,
                hasTags: !!v.tags,
                promptName: v.promptName
            }))
        });
        
        res.status(200).json(responseData);

    } catch (err) {
        console.error('[Thumbnail Complete] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar thumbnail completa.' });
    }
});

app.post('/api/analyze/thumbnail', authenticateToken, async (req, res) => {
    let { videoId, selectedTitle, model, niche, subniche, language, includePhrases, style, customPrompt, thumbnailRule, theme_key, folder_id } = req.body;
    const userId = req.user.id;

    if (!videoId || !selectedTitle || !model || !niche || !subniche || !language || includePhrases === undefined || !style) {
        return res.status(400).json({ msg: 'Dados insuficientes para gerar ideias de thumbnail.' });
    }
    
    console.log(`[Análise-Thumb] Gerando thumbnails para pasta/canal: ${folder_id || 'Nenhuma pasta selecionada'}`);
    
    // Se thumbnailRule não for fornecido, usar 'auto'
    thumbnailRule = thumbnailRule || 'auto';

    try {
        // --- 1. Identificar serviço e verificar preferências ---
        let service;
        
        // Mapear modelos corretamente
        if (model === 'gpt-4o') {
            service = 'openai';
            model = 'gpt-4o';
        } else if (model === 'claude-3-7-sonnet-20250219') {
            service = 'claude';
            model = 'claude-3-7-sonnet-20250219';
        } else if (model === 'gemini-2.5-pro') {
            service = 'gemini';
            model = 'gemini-2.5-pro';
        } else if (model.startsWith('gemini')) {
            service = 'gemini';
        } else if (model.startsWith('claude')) {
            service = 'claude';
        } else if (model.startsWith('gpt')) {
            service = 'openai';
        } else {
            service = 'gemini'; // Fallback
            model = 'gemini-2.5-pro';
        }

        // Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem plano que permite API própria OU não tem API própria configurada
        // REGRA CRÍTICA: Se preferência NÃO está marcada E usuário tem plano que permite E tem API própria → usar API própria
        let useLaozhang = false;
        let decryptedKey = null;
        
        try {
            let preferenceOrder = ['claude', 'openai', 'gemini'];
            if (service === 'gemini') preferenceOrder = ['gemini', 'claude', 'openai'];
            else if (service === 'claude') preferenceOrder = ['claude', 'openai', 'gemini'];
            else if (service === 'openai') preferenceOrder = ['openai', 'claude', 'gemini'];
            
            const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
            
            if (creditsCheck.shouldUse) {
                // Se deve usar créditos, usar laozhang.ai
                const laozhangKey = await getLaozhangApiKey();
                if (laozhangKey) {
                    useLaozhang = true;
                    decryptedKey = laozhangKey;
                    console.log(`[Analyze Thumbnail] ✅ Usando Laozhang.ai (${creditsCheck.reason})`);
                } else {
                    console.warn('[Analyze Thumbnail] ⚠️ Laozhang.ai não configurada, tentando usar APIs próprias do usuário');
                }
            } else {
                console.log(`[Analyze Thumbnail] ✅ Usando API própria (${creditsCheck.reason})`);
            }
        } catch (err) {
            console.warn('[Analyze Thumbnail] Erro ao verificar uso de créditos:', err.message);
        }
        
        // Se não usar laozhang.ai, buscar API própria do usuário
        if (!useLaozhang) {
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (!keyData) return res.status(400).json({ msg: `Chave de API do ${service} não configurada.` });
            decryptedKey = decrypt(keyData.api_key);
            if (!decryptedKey) return res.status(500).json({ msg: 'Falha ao desencriptar a sua chave de API.' });
        }
        
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        const geminiApiKey = decrypt(geminiKeyData.api_key);
        if (!geminiApiKey) return res.status(400).json({ msg: 'Chave do Gemini (necessária para o YouTube) não encontrada.' });

        // --- 2. Buscar dados do vídeo original ---
        const videoDetails = await callYouTubeDataAPI(videoId, geminiApiKey);
        
        // --- 2.5. Buscar análise original para pegar a fórmula do título ---
        let formulaTitulo = null;
        let motivoSucesso = null;
        try {
            const originalAnalysis = await db.get(
                'SELECT analysis_data_json FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                [videoId, userId]
            );
            if (originalAnalysis && originalAnalysis.analysis_data_json) {
                const analysisData = JSON.parse(originalAnalysis.analysis_data_json);
                if (analysisData.formulaTitulo) {
                    formulaTitulo = analysisData.formulaTitulo;
                }
                if (analysisData.motivoSucesso) {
                    motivoSucesso = analysisData.motivoSucesso;
                }
            }
        } catch (err) {
            console.warn(`[Análise-Thumb] Não foi possível buscar análise original: ${err.message}`);
        }
        
        // --- 2.6. Buscar thumbnails de referência do canal/nicho ---
        let thumbnailReferences = [];
        try {
            // PRIORIDADE 1: Buscar thumbnails de referência da PASTA/CANAL específica primeiro
            if (folder_id) {
                const folderRefs = await db.all(
                    'SELECT id, thumbnail_base64, channel_name, niche, subniche, description, folder_id FROM thumbnail_references WHERE user_id = ? AND folder_id = ? ORDER BY created_at DESC LIMIT 5',
                    [userId, folder_id]
                );
                
                if (folderRefs && folderRefs.length > 0) {
                    thumbnailReferences = folderRefs;
                    console.log(`[Análise-Thumb] ✅ Encontradas ${thumbnailReferences.length} thumbnail(s) de referência para o CANAL/PASTA ID ${folder_id} (prioridade máxima)`);
                }
            }
            
            // PRIORIDADE 2: Se não houver thumbnails da pasta, buscar por nicho/subnicho
            if (thumbnailReferences.length === 0) {
                let refQuery = 'SELECT id, thumbnail_base64, channel_name, niche, subniche, description, folder_id FROM thumbnail_references WHERE user_id = ?';
                const refParams = [userId];
                
                // Buscar por subniche, niche ou sem filtro específico (para pegar thumbnails gerais também)
                // Priorizar subniche, depois niche, depois qualquer thumbnail do usuário
                if (subniche || niche) {
                    refQuery += ' AND (';
                    const conditions = [];
                    if (subniche) {
                        conditions.push('subniche = ?');
                        refParams.push(subniche);
                    }
                    if (niche) {
                        conditions.push('niche = ?');
                        refParams.push(niche);
                    }
                    // Também incluir thumbnails sem filtro específico (NULL)
                    conditions.push('(subniche IS NULL AND niche IS NULL)');
                    refQuery += conditions.join(' OR ') + ')';
                }
                
                // Excluir thumbnails que já têm uma pasta específica (pois são de outros canais)
                refQuery += ' AND folder_id IS NULL';
                refQuery += ' ORDER BY created_at DESC LIMIT 5'; // Limitar a 5 thumbnails de referência
                
                const refs = await db.all(refQuery, refParams);
                thumbnailReferences = refs || [];
                
                if (thumbnailReferences.length > 0) {
                    console.log(`[Análise-Thumb] ✅ Encontradas ${thumbnailReferences.length} thumbnail(s) de referência para o nicho/subnicho (fallback)`);
                } else {
                    console.log(`[Análise-Thumb] ⚠️ Nenhuma thumbnail de referência encontrada para esta pasta ou nicho/subnicho`);
                }
            }
        } catch (err) {
            console.warn(`[Análise-Thumb] Erro ao buscar thumbnails de referência: ${err.message}`);
        }
        
        // --- 3. Criar o prompt multimodal (PROMPT REFINADO ou CUSTOMIZADO) ---
        let thumbPrompt;
        
        // Pré-calcular ambientação dinâmica pelo título (ou tema manual) ANTES de construir o prompt
        const themeKeyManual = theme_key || null;
        let dbMatchLocal = null;
        if (themeKeyManual) {
            await ensureAmbientationsTable();
            dbMatchLocal = await db.get('SELECT * FROM niche_ambientations WHERE user_id = ? AND theme_key = ? LIMIT 1', [userId, themeKeyManual]);
        }
        if (!dbMatchLocal) {
            dbMatchLocal = await detectAmbientationFromTitle(userId, selectedTitle, niche);
        }
        const ambientacaoArr = dbMatchLocal ? String(dbMatchLocal.ambiente || '').split(',').map(s => s.trim()).filter(Boolean) : [];
        const elementosArr = dbMatchLocal ? String(dbMatchLocal.elementos || '').split(',').map(s => s.trim()).filter(Boolean) : [];
        const acessoriosCalc = dbMatchLocal ? String(dbMatchLocal.acessorios || '') : '';
        const personagemCalc = dbMatchLocal && dbMatchLocal.subject ? dbMatchLocal.subject : 'historical figure with authentic attire';
        const ambientacaoCalc = ambientacaoArr.length ? ambientacaoArr.join(', ') : 'landscapes and architecture matching the title theme';
        const elementosDeFundoCalc = elementosArr.length ? elementosArr.join(', ') : 'contextual historical elements';

        // --- 3.1. Se customPrompt for um prompt padrão, adaptar ao título específico ---
        let adaptedCustomPrompt = customPrompt;
        if (customPrompt && customPrompt.trim()) {
            try {
                console.log('[Thumbnail Gen] Adaptando prompt padrão ao título específico...');
                
                // Criar prompt para a IA adaptar o prompt padrão ao título
                const adaptationPrompt = `Você é um especialista em adaptação de prompts visuais para thumbnails do YouTube.

TAREFA: Adapte o prompt padrão abaixo para o título específico do vídeo, mantendo EXATAMENTE a estrutura visual e estilo do prompt padrão, mas ajustando o conteúdo/tema/ambientação para o título fornecido.

PROMPT PADRÃO (ESTRUTURA E ESTILO A MANTER):
"""
${customPrompt}
"""

TÍTULO DO VÍDEO:
"${selectedTitle}"

NICHO/SUBNICHO:
${niche} / ${subniche}

INSTRUÇÕES:
1. Analise o prompt padrão e identifique:
   - Estrutura de composição (layout, posicionamento de elementos)
   - Estilo visual (paleta de cores, tipografia, iluminação)
   - Elementos técnicos (resolução, efeitos, tratamento)
   - Padrões de texto/frases

2. Adapte o prompt para o título "${selectedTitle}":
   - MANTENHA: toda a estrutura visual, estilo, composição, paleta de cores, tipografia
   - AJUSTE: personagem/sujeito, ambientação, cenário, elementos de fundo para corresponder ao tema do título
   - SUBSTITUA: referências genéricas por elementos específicos do título
   - PRESERVE: todos os elementos técnicos e de qualidade (resolução, efeitos, etc.)

3. O prompt adaptado deve:
   - Seguir EXATAMENTE o mesmo formato e estrutura do prompt padrão
   - Manter o mesmo estilo visual e composição
   - Aplicar o tema/contexto do título "${selectedTitle}"
   - Ser específico e detalhado como o prompt padrão

4. Retorne APENAS o prompt adaptado, sem explicações ou comentários adicionais.

PROMPT ADAPTADO:`;

                // Chamar IA para adaptar o prompt
                let adaptedResponse;
                if (useLaozhang) {
                    adaptedResponse = await callLaozhangAPI(
                        adaptationPrompt,
                        decryptedKey,
                        'gpt-4o',
                        null,
                        userId,
                        '/api/analyze/thumbnail',
                        JSON.stringify({ endpoint: '/api/analyze/thumbnail', operation: 'adapt-prompt' })
                    );
                } else if (service === 'openai') {
                    adaptedResponse = await callOpenAIAPI(adaptationPrompt, decryptedKey, model);
                    adaptedResponse = adaptedResponse.titles || adaptedResponse;
                } else if (service === 'claude') {
                    adaptedResponse = await callClaudeAPI(adaptationPrompt, decryptedKey, model);
                    adaptedResponse = adaptedResponse.titles || adaptedResponse;
                } else if (service === 'gemini') {
                    adaptedResponse = await callGeminiAPI(adaptationPrompt, decryptedKey, model);
                    adaptedResponse = adaptedResponse.titles || adaptedResponse;
                }
                
                if (adaptedResponse && typeof adaptedResponse === 'string' && adaptedResponse.trim().length > 100) {
                    adaptedCustomPrompt = adaptedResponse.trim();
                    console.log('[Thumbnail Gen] ✅ Prompt padrão adaptado com sucesso ao título');
                    console.log('[Thumbnail Gen] Prompt adaptado (preview):', adaptedCustomPrompt.substring(0, 300) + '...');
                } else {
                    console.warn('[Thumbnail Gen] ⚠️ Falha ao adaptar prompt, usando prompt padrão original');
                }
            } catch (adaptErr) {
                console.warn('[Thumbnail Gen] Erro ao adaptar prompt padrão:', adaptErr.message);
                console.warn('[Thumbnail Gen] Continuando com prompt padrão original');
            }
        }
        
        if (adaptedCustomPrompt && adaptedCustomPrompt.trim()) {
            // Se houver prompt customizado (original ou adaptado), usar ele como base
            thumbPrompt = `
            Você é um especialista em YouTube, combinando as habilidades de um diretor de arte para thumbnails e um mestre de SEO.

            IMAGEM DE REFERÊNCIA: [A imagem da thumbnail original do vídeo está anexada]
            ${thumbnailReferences.length > 0 ? `
            🎨 THUMBNAILS DE REFERÊNCIA DO CANAL/NICHO (IMPORTANTE - ESTILO DO CANAL):
            ${thumbnailReferences.map((ref, idx) => `[IMAGEM ${idx + 1} DE REFERÊNCIA DO CANAL: A thumbnail de referência ${idx + 1} do canal está anexada${ref.description ? ` (Descrição: ${ref.description})` : ''}]`).join('\n            ')}
            
            ⚠️⚠️⚠️ CRÍTICO - USE AS THUMBNAILS DE REFERÊNCIA DO CANAL COMO ESTILO PRINCIPAL ⚠️⚠️⚠️:
            - Analise cuidadosamente TODAS as ${thumbnailReferences.length} thumbnail(s) de referência do canal que estão anexadas acima.
            - Estas thumbnails representam o ESTILO VISUAL OFICIAL do canal/nicho "${subniche}".
            - A IDEIA 1 DEVE replicar fielmente o estilo visual dessas thumbnails de referência do canal (composição, cores, tipografia, elementos visuais, posicionamento de texto, etc.).
            - Identifique os elementos comuns entre as thumbnails de referência: tipo de composição, paleta de cores, estilo de texto, posicionamento de elementos, iluminação, etc.
            - Replique EXATAMENTE esse estilo visual na IDEIA 1, mantendo a identidade visual do canal.
            - A IDEIA 2 pode ser mais criativa, mas ainda deve respeitar a identidade visual do canal baseada nas thumbnails de referência.
            - Se as thumbnails de referência do canal usarem textos em dourado, composição dividida, close-up dramático ou outros elementos específicos, REPLIQUE-OS FIELMENTE na IDEIA 1.
            ` : ''}
            TÍTULO DO VÍDEO (para contexto): "${selectedTitle}"
            SUBNICHO (Público-Alvo): "${subniche}"
            ESTILO DE ARTE DESEJADO: "${style}"
            IDIOMA DO CONTEÚDO: "${language}"

            🎨🎨🎨 PROMPT ADAPTADO DO ESTILO DO CANAL/NICHO PARA O TÍTULO "${selectedTitle}" 🎨🎨🎨:
            ${adaptedCustomPrompt}
            
            🌍🌍🌍 AMBIENTAÇÃO DETECTADA PELO TÍTULO "${selectedTitle}" (APLICAR AO CONTEÚDO) 🌍🌍🌍:
            ${dbMatchLocal ? `
            - PERSONAGEM/SUJEITO: ${personagemCalc}
            - AMBIENTAÇÃO/CENÁRIO: ${ambientacaoCalc}
            - ELEMENTOS DE FUNDO: ${elementosDeFundoCalc}
            ${acessoriosCalc ? `- ACESSÓRIOS: ${acessoriosCalc}` : ''}
            
            ⚠️ CRÍTICO: Use esta ambientação detectada pelo título para definir o CONTEÚDO da thumbnail, mantendo o ESTILO VISUAL do prompt padrão acima.
            ` : `
            - A ambientação será detectada automaticamente pelo título "${selectedTitle}".
            - Use elementos visuais relacionados ao tema do título, mantendo o estilo visual do prompt padrão.
            `}
            
            ⚠️⚠️⚠️ CRÍTICO - O PROMPT PADRÃO É APENAS ESTILO VISUAL - APLICAR AO TÍTULO "${selectedTitle}" ⚠️⚠️⚠️:
            - O PROMPT PADRÃO acima define APENAS o ESTILO VISUAL (composição, cores, tipografia, elementos, iluminação, atmosfera).
            - O CONTEÚDO das thumbnails deve ser SOBRE O TÍTULO "${selectedTitle}" que o usuário escolheu.
            - NÃO use o conteúdo do prompt padrão. Use APENAS o estilo visual dele.
            - NÃO crie um prompt novo. APLIQUE o estilo do prompt padrão ao título "${selectedTitle}".
            
            PROCESSO OBRIGATÓRIO:
            1. EXTRAIA do prompt padrão APENAS os elementos de ESTILO VISUAL:
               - Tipo de composição (ex: "close-up dramático", "composição dividida", "cena épica")
               - Paleta de cores (ex: "dourado e azul escuro", "tons terrosos", "vermelho e preto")
               - Estilo de tipografia (ex: "textos dourados serifados com bevel/emboss", "fonte bold com outline preto")
               - Elementos visuais recorrentes (ex: "pirâmides ao fundo", "navios", "fogo", "tempestades", "silhuetas")
               - Iluminação e atmosfera (ex: "iluminação dramática", "céu tempestuoso", "chiaroscuro", "luz dourada")
               - Estilo geral (ex: "cinematográfico", "documental", "épico", "realista")
            
            2. IGNORE o conteúdo/tema do prompt padrão. O conteúdo deve ser sobre "${selectedTitle}".
            
            3. APLIQUE o estilo extraído ao criar thumbnails sobre o título "${selectedTitle}":
               - Use a mesma composição (ex: se o estilo é "close-up", faça close-up mas do assunto relacionado a "${selectedTitle}")
               - Use a mesma paleta de cores
               - Use o mesmo estilo de tipografia
               - Adapte os elementos visuais ao tema de "${selectedTitle}" (mantendo o estilo visual)
               - Use a mesma iluminação e atmosfera
               - Mantenha o estilo geral
            
            4. RESULTADO: Thumbnails sobre "${selectedTitle}" mas com o estilo visual do prompt padrão.
            
            EXEMPLO:
            - Se o prompt padrão diz "close-up de líder indígena com textos dourados" mas o título é sobre tecnologia inca:
              → Use "close-up" (estilo) + "textos dourados" (estilo) + "tecnologia inca" (conteúdo do título)
              → RESULTADO: "close-up de tecnologia inca com textos dourados"
            
            ⚠️ NÃO REPLIQUE O PROMPT PADRÃO. APLIQUE APENAS O ESTILO AO TÍTULO ESCOLHIDO.

            ⚠️ ATENÇÃO CRÍTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, não ilustrações, desenhos ou renderizações. A descriçãoThumbnail deve descrever uma FOTO REAL tirada por um fotógrafo profissional em um local real, com pessoas reais e objetos reais.
            
            🎨 IDENTIFICAÇÃO E REPLICAÇÃO DE ESTILOS ÉPICOS/CINEMATOGRÁFICOS:
            
            Analise a IMAGEM DE REFERÊNCIA e identifique qual estilo visual ela utiliza. Se identificar algum dos estilos abaixo, REPLIQUE-O FIELMENTE na IDEIA 1, apenas melhorando a qualidade:
            
            📐 ESTILO 1: COMPOSIÇÃO DIVIDIDA (ESQUERDA/DIREITA):
            - Imagem dividida verticalmente em duas metades contrastantes
            - Lado esquerdo: geralmente cenas de paz/grandiosidade (cidades antigas, paisagens douradas, céu claro)
            - Lado direito: geralmente cenas de conflito/ameaça (tempestades, navios, exércitos, céu escuro)
            - Figura central ou próxima ao centro conectando os dois lados
            - Contraste dramático entre luz (esquerda) e escuridão (direita)
            - Texto grande em dourado (#FFD700) na parte inferior, fonte serifada ornamentada com efeito emboss/bevel
            - Exemplos: Atahualpa (cidade dourada vs navios tempestuosos), Malinche (mapa vs batalha naval)
            
            📐 ESTILO 2: CLOSE-UP DRAMÁTICO COM BACKGROUND ÉPICO:
            - Figura histórica em close-up ocupando 40-60% da imagem (rosto e parte superior do corpo)
            - Expressão intensa e direta para a câmera
            - Background dividido ou com elementos épicos (pirâmides, navios, batalhas, fogo)
            - Iluminação dramática com chiaroscuro (luz forte vs sombras profundas)
            - Texto grande em dourado na parte inferior
            - Exemplos: Faraó com pirâmides ao fundo, líder indígena com cidade antiga
            
            📐 ESTILO 3: CENA ÉPICA COM ELEMENTOS DE DESTRUIÇÃO:
            - Cena de batalha ou conflito histórico
            - Elementos de fogo, fumaça, tempestades
            - Navios em chamas, exércitos, destruição
            - Céu tempestuoso com nuvens escuras
            - Figuras em primeiro plano com expressões dramáticas
            - Texto grande em dourado/amarelo com outline preto
            - Exemplos: Batalhas navais, conquistas, segredos dos faraós
            
            📐 ESTILO 4: FIGURA HISTÓRICA COM ELEMENTOS SIMBÓLICOS:
            - Figura histórica em destaque (faraó, líder, conquistador)
            - Trajes elaborados e autênticos (coroas, armaduras, roupas tradicionais)
            - Elementos simbólicos ao redor (pirâmides, navios, mapas, hieróglifos)
            - Composição vertical ou horizontal com figura dominante
            - Texto grande em dourado com fonte serifada ornamentada
            - Exemplos: Faraó com pirâmides, líder indígena com coroa elaborada
            
            ⚠️ REGRAS PARA REPLICAÇÃO FIEL:
            1. Se a thumbnail original usar COMPOSIÇÃO DIVIDIDA, mantenha EXATAMENTE essa estrutura (mesma divisão, mesmo contraste, mesma posição dos elementos)
            2. Se a thumbnail original usar CLOSE-UP DRAMÁTICO, mantenha o mesmo enquadramento e proporção da figura
            3. Se a thumbnail original usar TEXTOS EM DOURADO, mantenha a mesma cor (#FFD700), fonte serifada e efeitos (emboss, bevel, glow)
            4. Se a thumbnail original usar ELEMENTOS ÉPICOS (pirâmides, navios, fogo), mantenha os mesmos elementos na mesma posição
            5. Se a thumbnail original usar CONTRASTE LUZ/ESQUERIDÃO, mantenha o mesmo esquema de iluminação
            6. Se a thumbnail original usar FIGURAS HISTÓRICAS, mantenha o mesmo tipo de figura, trajes e expressão
            7. Apenas MELHORE: nitidez 8K, contraste mais forte, cores mais saturadas, iluminação mais dramática, texto com efeitos Photoshop mais refinados
            
            ${(() => {
                const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
                if (ruleData.mode === 'auto') {
                    return `\n            🔍 MODO AUTOMÁTICO - ANÁLISE DE REGRA:\n            Analise o título "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPLÍCITA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.\n\n            📋 AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE (ALGORITMO OFICIAL):\n\n            1️⃣ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO):\n            O cérebro precisa entender a thumbnail em menos de 1 segundo. Se houver confusão, o clique cai.\n            Checklist OBRIGATÓRIO: 1 ideia principal, 1 personagem, 1 emoção, 1 objeto-chave.\n            A thumbnail DEVE ser compreendida instantaneamente. Elimine qualquer elemento que cause confusão ou distração.\n\n            2️⃣ REGRA DO ASSUNTO ÚNICO:\n            Nada divide a atenção. A thumbnail boa é sempre uma história em uma imagem.\n            Foque em UM ÚNICO assunto dominante. Nada deve competir pela atenção. A thumbnail deve contar uma história completa em uma única imagem, sem elementos que dividam o foco.\n\n            3️⃣ REGRA DO ROSTO GRANDE:\n            Rostos com forte expressão emocional aumentam CTR de 20% a 60%.\n            Expressões mais fortes: choque, surpresa, medo, raiva, felicidade extrema.\n            Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A expressão facial DEVE ser EXTREMA e EMOCIONAL. O rosto deve ser o elemento dominante e a primeira coisa que o olho vê.\n\n            4️⃣ REGRA DO CONTRASTE BRUTAL:\n            Se não tiver contraste, a thumbnail fica invisível.\n            Use CONTRASTE BRUTAL entre: texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n            O contraste deve ser tão forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.\n\n            5️⃣ REGRA DA COR ESTRATÉGICA:\n            Cada cor ativa um gatilho:\n            - Amarelo: atenção imediata\n            - Vermelho: urgência / perigo\n            - Azul: confiança\n            - Verde: dinheiro / solução\n            - Preto: premium / mistério\n            Escolha a cor baseada na emoção que o título transmite.\n\n            6️⃣ REGRA DOS TERÇOS:\n            Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso dá harmonia e aumenta o foco natural.\n            Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos terços (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.\n\n            7️⃣ REGRA DO TEXTO ULTRA CURTO:\n            Texto deve ter 2 a 4 palavras, nunca mais.\n            Exemplos: "Ele mentiu", "Descobri isso", "Ninguém viu", "Proibido".\n            O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Textos longos matam o CTR. Seja brutalmente direto e impactante.\n\n            8️⃣ REGRA DO ZOOM EMOCIONAL:\n            Aparece sempre um elemento gigante que amplifica a emoção ou o conflito.\n            Exemplos: uma conta bancária gigante, uma faca gigante, uma lupa gigante, um número gigante.\n            Use um elemento GIGANTE que amplifique a emoção ou conflito. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.\n\n            9️⃣ REGRA DO MISTÉRIO:\n            Toda thumbnail viral tem uma pergunta implícita.\n            Exemplos: algo escondido atrás de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela.\n            Crie uma pergunta implícita na thumbnail. O espectador DEVE sentir curiosidade sobre o que está fora da imagem.\n\n            🔟 REGRA DOS PONTOS DE FUGA:\n            Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.\n            Sinalizações: setas, linhas diagonais, perspectiva.\n            Use linhas visuais que guiem o olhar para o foco. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal.\n\n            1️⃣1️⃣ REGRA DO ESPAÇO NEGATIVO:\n            Deixar áreas vazias acentua o foco. Sem isso, a imagem vira bagunça.\n            Deixe áreas vazias (espaço negativo) que acentuem o foco no elemento principal. O espaço vazio cria respiração visual e faz o elemento principal "pular" da imagem.\n\n            1️⃣2️⃣ REGRA DA COERÊNCIA COM O TÍTULO:\n            Thumbnail e título precisam contar a mesma história, mas com ângulos diferentes.\n            Título = contexto, Thumbnail = emoção.\n            A thumbnail e o título DEVEM contar a mesma história, mas com ângulos diferentes. A thumbnail deve amplificar a emoção que o título promete, criando uma sinergia perfeita.\n\n            ⚠️ CRÍTICO: Identifique qual regra melhor se encaixa no título "${selectedTitle}" e aplique-a de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.`;
                } else {
                    return `\n            📋 REGRA SELECIONADA: ${ruleData.rule.name}\n            ${ruleData.rule.description}\n\n            ${ruleData.rule.checklist ? `✅ Checklist: ${ruleData.rule.checklist.join(', ')}` : ''}\n            ${ruleData.rule.expressions ? `😮 Expressões recomendadas: ${ruleData.rule.expressions.join(', ')}` : ''}\n            ${ruleData.rule.contrasts ? `🎨 Contrastes: ${ruleData.rule.contrasts.join(', ')}` : ''}\n            ${ruleData.rule.colors ? `🌈 Cores estratégicas: ${Object.entries(ruleData.rule.colors).map(([k, v]) => `${k} (${v})`).join(', ')}` : ''}\n            ${ruleData.rule.examples ? `💡 Exemplos: ${ruleData.rule.examples.join(', ')}` : ''}\n            ${ruleData.rule.elements ? `➡️ Elementos: ${ruleData.rule.elements.join(', ')}` : ''}\n\n            ⚠️ CRÍTICO: Aplique esta regra de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail:\n            ${ruleData.instructions}`;
                }
            })()}
            
            🎯 OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando técnicas de Thumbnail Designer profissional:
            - TEXTO PROFISSIONAL (COMO PHOTOSHOP): O texto DEVE parecer feito no Photoshop por um designer profissional. Use múltiplos efeitos de camada (stroke, drop shadow com valores específicos, outer glow, bevel and emboss), tipografia profissional com kerning perfeito, renderização profissional com anti-aliasing. Grande, estilizado, cores vibrantes (amarelo/vermelho/branco com outline preto), efeitos visuais profissionais com valores específicos (distância, spread, tamanho, opacidade, ângulo), posicionamento estratégico (topo/centro), ocupando 25-35% da imagem. O texto DEVE ter qualidade de agência de design, não amador.
            - COMPOSIÇÃO: Regra dos terços, hierarquia visual clara, elemento principal em destaque
            - CORES: Alto contraste, cores complementares, saturação otimizada, fundo que faz o texto "pular"
            - EMOÇÃO: Expressões faciais intensas, momentos de tensão, curiosidade visual
            - ELEMENTOS VIRAIS: FOMO (medo de perder), surpresa, contraste dramático, storytelling visual
            
            SUA TAREFA:
            Crie DUAS (2) ideias distintas para uma nova thumbnail baseadas no prompt personalizado acima.
            
            ⚠️⚠️⚠️ CRÍTICO - ORDEM DAS IDEIAS ⚠️⚠️⚠️
            ${hasStandardPrompt ? `
            ⚠️⚠️⚠️ ATENÇÃO CRÍTICA: PROMPT PADRÃO ESTÁ ATIVO - USAR APENAS O ESTILO VISUAL ⚠️⚠️⚠️
            - O PROMPT PADRÃO acima é APENAS ESTILO VISUAL (como criar), NÃO é o conteúdo (o que criar).
            - O CONTEÚDO das thumbnails DEVE ser sobre o título "${selectedTitle}" que o usuário escolheu.
            - Ambas as IDEIAS devem APLICAR o estilo visual do prompt padrão ao título "${selectedTitle}".
            - NÃO use o conteúdo/tema do prompt padrão. Use APENAS os elementos de estilo (composição, cores, tipografia, iluminação, atmosfera).
            - EXTRAIA o estilo do prompt padrão e APLIQUE ao tema de "${selectedTitle}".

            ` : ''}
            - **IDEIA 1 (RÉPLICA E MELHORIA DA THUMBNAIL ORIGINAL DO VÍDEO):** 
              * OBRIGATÓRIO: Esta ideia DEVE replicar e melhorar a thumbnail ORIGINAL do vídeo ao qual foram feitos os títulos.
              ${hasStandardPrompt ? `* APLIQUE O ESTILO DO PROMPT PADRÃO: Use os elementos de estilo do prompt padrão (composição, cores, tipografia, iluminação) mantendo o conteúdo relacionado ao título "${selectedTitle}".\n` : ''}
              * Analise cuidadosamente a IMAGEM DE REFERÊNCIA (thumbnail original do vídeo) que está anexada.
              * IDENTIFIQUE O ESTILO VISUAL ESPECÍFICO da thumbnail original (composição dividida, close-up dramático, cena épica, figura histórica, etc.) usando a seção "🎨 IDENTIFICAÇÃO E REPLICAÇÃO DE ESTILOS ÉPICOS/CINEMATOGRÁFICOS" acima.
              ${hasStandardPrompt ? `* INTEGRE O ESTILO DO PROMPT PADRÃO: Mantenha a estrutura da thumbnail original, mas aplique os elementos de estilo do prompt padrão (cores, tipografia, iluminação, atmosfera).\n` : ''}
              * Replique a estrutura da thumbnail original quase 1:1: mantenha EXATAMENTE a mesma composição, ângulo de câmera, enquadramento, posição dos personagens/objetos, paleta de cores, quantidade de texto, posição do texto, elementos visuais principais e storytelling.
              * Se a thumbnail usar COMPOSIÇÃO DIVIDIDA: mantenha EXATAMENTE a mesma divisão vertical, mesmo contraste luz/escuridão, mesma posição dos elementos em cada lado.
              * Se a thumbnail usar TEXTOS EM DOURADO: mantenha a mesma cor (#FFD700), fonte serifada ornamentada, efeitos emboss/bevel, mesma posição e tamanho.
              * Se a thumbnail usar ELEMENTOS ÉPICOS (pirâmides, navios, fogo, tempestades): mantenha os mesmos elementos na mesma posição e proporção.
              * Se a thumbnail usar FIGURAS HISTÓRICAS: mantenha o mesmo tipo de figura, trajes, expressão e enquadramento.
              * PRESERVE o poder viral da thumbnail original que gerou milhões de views.
              * Apenas ELEVE A QUALIDADE: mais nitidez (8K), contraste reforçado, iluminação cinematográfica profissional, correções de cor profissionais, tratamento de pele profissional, brilho nos olhos, textura realista, limpeza de ruídos, adicione luzes/sombras profissionais, aplique efeitos de texto Photoshop com valores específicos (stroke, drop shadow, outer glow, bevel & emboss).
              * NÃO altere o storytelling principal, apenas entregue a versão definitiva com acabamento premium.
              * Resultado: praticamente igual à thumbnail original, mas com sensação de upgrade premium e leitura instantânea mais clara e clicável.
              * IMPORTANTE: Se a thumbnail original não estiver disponível ou não puder ser analisada, ainda assim mantenha o mesmo conceito visual e estrutura, apenas melhorando a qualidade.
            
            - **IDEIA 2 (THUMBNAIL MELHORADA E OTIMIZADA):** 
              * Esta é uma versão COMPLETAMENTE NOVA, melhorada e otimizada para CTR alto (30%+).
              * Crie um conceito totalmente novo com foco em CTR máximo: novo enquadramento, nova composição, novos elementos que gerem curiosidade extrema.
              * Use gatilhos agressivos (perigo, segredo revelado, números gigantes, setas, antes/depois, close dramático) e cores super contrastantes.
              * Construa um storytelling diferente, alinhado ao título "${selectedTitle}", que prometa algo ainda mais irresistível que a versão original.
              * O texto deve ser redesenhado para máxima legibilidade mobile, com layer styles profissionais e valores precisos.
              * Pode mudar cenário, personagens, enquadramento e paleta, explorando um novo gancho visual com FOMO extremo, contraste máximo, expressões dramáticas e elementos que não existem na thumb original.
              * Objetivo: criar uma thumbnail inédita que pareça "campanha de performance", otimizada para CTR alto e retenção visual imediata.
              * Esta versão deve ser AINDA MELHOR que a original, com técnicas avançadas de viralização.

            PARA CADA UMA DAS 2 IDEIAS, GERE:
            1.  **"seoDescription"**: Uma descrição de vídeo para o YouTube, EXTREMAMENTE OTIMIZADA PARA SEO E VIRALIZAÇÃO, com:
               - Emojis estratégicos e relevantes (use emojis que representem o nicho e subnicho)
               - Parágrafos bem estruturados com quebras de linha
               - Chamadas para ação (CTA) claras e persuasivas
               - Uso estratégico de palavras-chave relevantes para o título "${selectedTitle}" e subnicho "${subniche}"
               - Formatação profissional com separadores visuais (━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━)
               - Seções organizadas: introdução, conteúdo do vídeo, sobre o canal, links importantes, hashtags
               - Linguagem persuasiva e envolvente que gere curiosidade e urgência
               - A descrição deve estar no idioma "${language}" e ter entre 300-500 palavras
               - IMPORTANTE: Use emojis de forma estratégica (não exagere, mas use para destacar seções importantes)
               - Inclua hashtags relevantes no final
               - Seja específico sobre o que o espectador vai aprender/ganhar
               
            2.  **"seoTags"**: Um array de strings com as 15-25 tags MAIS RELEVANTES E ESTRATÉGICAS para o vídeo (LIMITE MÁXIMO: 300 caracteres no total, incluindo vírgulas e espaços. NÃO ultrapasse 300 caracteres), incluindo:
               - Tags de cauda curta (1-2 palavras): termos populares e competitivos relacionados ao título "${selectedTitle}" e subnicho "${subniche}"
               - Tags de cauda longa (3-5 palavras): termos mais específicos e menos competitivos que capturam intenção de busca
               - Tags de nicho: termos específicos do subnicho "${subniche}"
               - Tags de tendência: termos que estão em alta no momento relacionados ao tema
               - Tags de formato: termos como "tutorial", "dicas", "como fazer", "guia completo", "passo a passo", etc.
               - Tags de plataforma: termos relacionados à plataforma (YouTube, TikTok, Instagram, etc.)
               - Tags de emoção: termos que capturam a emoção do título (ex: "surpresa", "revelação", "mistério", "urgência", "choque")
               - Tags de benefício: termos que descrevem o que o espectador vai ganhar/aprender
               - Tags de palavra-chave principal: extrair as palavras-chave mais importantes do título "${selectedTitle}"
               - Tags de sinônimos: variações e sinônimos das palavras-chave principais
               - IMPORTANTE: As tags devem ser EXTREMAMENTE RELEVANTES ao título "${selectedTitle}" e ao subnicho "${subniche}"
               - Evite tags genéricas que não agregam valor
               - Priorize tags que tenham volume de busca mas não sejam extremamente competitivas
               - Misture tags em português/inglês/espanhol conforme o idioma "${language}"
               - LIMITE MÁXIMO: 300 caracteres no total (incluindo vírgulas e espaços). NÃO ultrapasse 300 caracteres.
               - Cada tag deve ter entre 1-5 palavras, sendo a maioria com 2-3 palavras para otimizar o uso do espaço
               - Priorize tags mais relevantes e estratégicas. Se necessário, reduza a quantidade de tags para não ultrapassar 300 caracteres.
            3.  **"frasesDeGancho"**: Um array com 5 frases CURTAS de impacto (ganchos) para a thumbnail, OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne um array vazio [].' : `
                ⚠️⚠️⚠️ CRÍTICO E OBRIGATÓRIO - IDIOMA DAS FRASES DE GANCHO ⚠️⚠️⚠️
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Português' ? `
                ✅ CORRETO (Português): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : language === 'Inglês' ? `
                ✅ CORRETO (Inglês): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : `
                ✅ CORRETO (Espanhol): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante", "La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGATÓRIAS:
                1. Se "${language}" for "Português", TODAS as 5 frases DEVEM estar em PORTUGUÊS (Brasil)
                2. Se "${language}" for "Inglês", TODAS as 5 frases DEVEM estar em INGLÊS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em inglês se o idioma escolhido for português ou espanhol
                5. NUNCA, JAMAIS retorne frases em português se o idioma escolhido for inglês ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for português ou inglês
                7. Cada frase deve ter 2 a 4 palavras, no máximo
                8. As frases devem ser impactantes e relacionadas ao título "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases estão no idioma "${language}"?
                - Nenhuma frase está em inglês se "${language}" for português ou espanhol?
                - Nenhuma frase está em português se "${language}" for inglês ou espanhol?
                - Nenhuma frase está em espanhol se "${language}" for português ou inglês?
                
                Se alguma resposta for NÃO, CORRIJA as frases antes de retornar o JSON.
                `}
            4.  **"descricaoThumbnail"**: Um prompt EXTREMAMENTE DETALHADO e VÍVIDO, em INGLÊS, para uma IA de geração de imagem. ${!includePhrases ? 'NÃO inclua nenhum placeholder para texto. A thumbnail deve ser APENAS imagem, sem texto ou frases de gancho.' : 'A descrição DEVE incluir OBRIGATORIAMENTE o placeholder exato "[FRASE DE GANCHO AQUI]" em algum lugar da descrição, onde o texto da thumbnail será inserido. CRÍTICO: O placeholder "[FRASE DE GANCHO AQUI]" DEVE aparecer literalmente na descrição. Quando mencionar o texto, descreva-o como se fosse criado no Photoshop por um designer profissional: use termos como "Professional Photoshop-quality text design displaying [FRASE DE GANCHO AQUI]", "professional layer effects", "Photoshop stroke effect", "professional drop shadow with specific values (distance, spread, size, opacity, angle)", "professional outer glow", "professional bevel and emboss", "professional typography with perfect kerning", "professional text rendering with anti-aliasing", "looks like it was designed by a professional graphic designer". O texto DEVE ter múltiplos efeitos de camada do Photoshop com valores específicos, não apenas descrições genéricas. Fonte estilizada profissional, grande e impactante, cores vibrantes e contrastantes, efeitos visuais profissionais (sombra com valores específicos, brilho, outline, gradiente), posicionamento estratégico, tamanho grande que ocupa 25-35% da imagem. IMPORTANTE: Sempre inclua o texto "[FRASE DE GANCHO AQUI]" literalmente na descrição, por exemplo: "with professional text design displaying [FRASE DE GANCHO AQUI]" ou "featuring large bold text that says [FRASE DE GANCHO AQUI]".'}

${customPrompt && customPrompt.trim() ? `\n⚠️⚠️⚠️ CRÍTICO - O PROMPT PADRÃO É APENAS ESTILO - APLICAR AO TÍTULO "${selectedTitle}" ⚠️⚠️⚠️:\nA descriçãoThumbnail DEVE APLICAR APENAS O ESTILO VISUAL do prompt padrão acima ao título "${selectedTitle}".\n\nPROCESSO OBRIGATÓRIO:\n1. EXTRAIA do prompt padrão APENAS os elementos de ESTILO VISUAL (composição, cores, tipografia, elementos visuais, iluminação, atmosfera).\n2. IGNORE o conteúdo/tema do prompt padrão. O conteúdo DEVE ser sobre "${selectedTitle}".\n3. APLIQUE o estilo extraído ao criar uma thumbnail sobre "${selectedTitle}".\n4. RESULTADO: Thumbnail sobre "${selectedTitle}" mas com o estilo visual do prompt padrão.\n\nEXEMPLO PRÁTICO:\n- Prompt padrão: "close-up dramático de líder indígena com textos dourados serifados"\n- Título escolhido: "${selectedTitle}" (ex: sobre tecnologia inca)\n- RESULTADO: "close-up dramático de [elementos relacionados a ${selectedTitle}] com textos dourados serifados"\n\n⚠️ NÃO USE O CONTEÚDO DO PROMPT PADRÃO. USE APENAS O ESTILO E APLIQUE AO TÍTULO "${selectedTitle}".\n\n🚫 OBRIGATÓRIO - INSTRUÇÕES DE EXCLUSÃO (SEMPRE INCLUIR NA descricaoThumbnail):\nA descricaoThumbnail DEVE SEMPRE incluir estas instruções de exclusão no final:\n"Exclude mesoamerican pyramids, feathered headdress, conquistadors, Spanish ships, jaguar motifs, and any aztec elements unless specifically relevant to the detected theme. Exclude any logos, watermarks, channel badges or branding marks. Do not render channel names or corner marks."\n\n⚠️ CRÍTICO: Estas instruções de exclusão são OBRIGATÓRIAS e devem ser incluídas em TODAS as descrições de thumbnail, independentemente do prompt padrão usado.\n` : ''}
            
            CRÍTICO PARA A "descricaoThumbnail" - DEVE SER FOTOGRAFIA REAL ULTRA HD 8K, NÃO ILUSTRAÇÃO:
            - OBRIGATÓRIO: A descrição DEVE começar EXATAMENTE com: "Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, real lighting, real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, 8K resolution, extreme sharpness, maximum detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography quality"
            
            - ENFATIZE REPETIDAMENTE E OBRIGATORIAMENTE: "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail", "every pore visible", "every texture crisp", "perfect focus", "ultra sharp", "no blur except intentional depth of field", "no artifacts", "no compression", "no pixelation", "perfect clarity", "real photograph", "shot on location", "documentary photography", "realistic textures with imperfections", "natural lighting with real shadows", "real depth of field", "real bokeh effects", "professional color grading", "high dynamic range (HDR)", "sharp focus on subject", "real camera grain", "real-world photography", "actual photograph", "photographed in real life", "real person", "real object", "real environment", "National Geographic quality", "BBC documentary style", "professional photography", "photorealistic", "hyper-realistic"
            
            - NUNCA, JAMAIS use estes termos: "illustration", "drawing", "artwork", "digital art", "render", "3D render", "CGI", "cartoon", "anime", "sketch", "painting", "stylized", "artistic", "concept art", "digital painting", "graphic design", "vector", "comic", "fantasy art", "artistic interpretation", "stylized", "artistic style", "digital illustration"
            
            - SEMPRE use APENAS estes termos: "photograph", "photo", "photography", "shot", "captured", "documentary photo", "realistic capture", "professional photography", "real-world photography", "actual photograph", "photographed", "real-life photography", "on-location photography", "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail"
            
            - IMPORTANTE: Descreva como se fosse uma FOTO REAL ULTRA HD 8K tirada por um fotógrafo profissional. Mencione detalhes realistas como: "real skin texture with pores and natural imperfections visible in 8K detail", "real fabric texture with visible fibers and weave patterns in ultra HD", "real stone texture with weathering, cracks, and imperfections visible in perfect 8K clarity", "real shadows cast by real light sources with perfect sharpness", "real depth of field blur with perfect bokeh", "real camera lens distortion", "real chromatic aberration", "real lens flare", "real motion blur if applicable", "every detail visible in 8K resolution", "extreme sharpness and clarity", "no compression artifacts", "perfect focus on subject"

            REGRAS IMPORTANTES:
            - A "descricaoThumbnail" é OBRIGATORIAMENTE em INGLÊS.
            - "seoDescription", "seoTags" e "frasesDeGancho" são OBRIGATORIAMENTE no idioma "${language}".
            ${!includePhrases ? '- IMPORTANTE: A "descricaoThumbnail" NÃO deve mencionar texto, palavras ou frases. Apenas descreva elementos visuais, composição, cores, iluminação, etc.' : ''}
            - Seja extremamente específico e detalhado nas descrições visuais. Use termos técnicos de fotografia profissional, cinematografia e psicologia visual quando apropriado.
            - Foque em elementos que maximizem CTR: expressões faciais intensas, momentos de tensão, curiosidade visual, contraste dramático, composição impactante.
            
            EXEMPLOS DE COMO DESCREVER PARA GARANTIR REALISMO:
            - Em vez de "um guerreiro maia", escreva: "a real person dressed as a Mayan warrior, photographed on location, real skin texture with pores and natural imperfections, real fabric of the costume with visible texture and wrinkles, real feathers in the headdress with natural variations"
            - Em vez de "uma pirâmide antiga", escreva: "a real ancient Mayan pyramid photographed on location, real weathered stone with cracks and imperfections, real moss and vegetation growing on the stones, real shadows cast by the sun, real depth of field blur in the background"
            - Em vez de "luz mística", escreva: "real natural lighting from the sun, real shadows cast by real objects, real depth of field, real bokeh in the background, real camera lens flare if the sun is in frame"
            - SEMPRE mencione: "real", "actual", "photographed", "shot on location", "documentary style", "real-world", "actual photograph"
            
            TÉCNICAS DE THUMBNAIL VIRAL PARA O TEXTO (quando includePhrases = true) - DESIGN PROFISSIONAL COMO PHOTOSHOP - CTR ACIMA DE 25%:
            
            📝 DESCRIÇÃO OBRIGATÓRIA DO TEXTO - DEVE PARECER FEITO NO PHOTOSHOP POR UM DESIGNER PROFISSIONAL:
            O texto DEVE ser descrito como se fosse criado no Photoshop com técnicas profissionais de design gráfico:
            
            1. TIPOGRAFIA PROFISSIONAL:
               - "Professional typography, Photoshop-quality text design"
               - "Large, bold, professionally designed text occupying 25-35% of the image height"
               - "Massive, oversized typography with professional letter spacing and kerning"
               - "Thick, chunky, professionally rendered letters"
               - "Typography that looks like it was designed by a professional graphic designer"
               - "High-end text design, magazine-quality typography"
            
            2. CORES PROFISSIONAIS E EFEITOS DE CAMADA (Layer Effects do Photoshop):
               - "Bright yellow (#FFD700) text with professional Photoshop layer effects: thick black stroke (6-8px), white drop shadow with distance 8px, spread 5px, size 12px, opacity 80%, angle 135 degrees"
               - "Pure white text with professional red stroke (6px), black drop shadow with blur radius 10px, and subtle outer glow effect in yellow"
               - "Neon orange (#FF6600) text with black stroke (7px), professional drop shadow with multiple layers, and yellow outer glow with spread 8px"
               - "Electric blue (#00FFFF) text with white stroke (6px), black shadow with distance 10px, and professional bevel and emboss effect"
               - "Bright red (#FF0000) text with yellow stroke (5px), white drop shadow, and professional gradient overlay from yellow to orange"
               - "Lime green (#00FF00) text with black stroke (8px), white glow effect, and professional inner shadow"
               - IMPORTANTE: Descreva como efeitos de camada do Photoshop (layer effects), não apenas "outline" ou "shadow"
               
               🏆 ESTILO ÉPICO - TEXTOS EM DOURADO (Para thumbnails históricas/épicas):
               - Se a thumbnail original usar textos em dourado, DESCREVA EXATAMENTE assim:
               - "Large, bold, ornate serif font text in golden yellow (#FFD700) with professional Photoshop layer effects: thick black stroke (8-10px width, position outside), professional bevel and emboss effect (style: emboss, technique: smooth, depth 150%, size 8px, softness 3px, highlight mode: screen with opacity 75%, shadow mode: multiply with opacity 50%), white drop shadow (distance 12px, spread 6px, size 15px, opacity 85%, angle 135°), subtle outer glow in golden yellow (spread 10px, size 20px, opacity 60%), positioned at the bottom center of the image, occupying 30-35% of the image height, professional ornate serif typography (Trajan Pro, Cinzel, or similar historical/regal font style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, looks like it was designed by a professional graphic designer for a historical epic movie poster"
               - "Golden embossed text with metallic finish, professional 3D effect, regal and majestic appearance, historical epic typography style"
            
            3. FONTES PROFISSIONAIS:
               - "Professional bold sans-serif font (Impact, Bebas Neue, Montserrat Black, or similar premium font)"
               - "Thick, chunky, professionally designed block letters"
               - "Modern, high-end typography with perfect letter spacing"
               - "YouTube viral thumbnail professional font style"
               - "Bold, condensed font with professional kerning and tracking"
               - "Premium typography, no serifs, maximum readability, professional design"
               - "Typography that looks like it came from a professional design agency"
            
            4. EFEITOS PROFISSIONAIS DO PHOTOSHOP (Layer Styles):
               - "Professional Photoshop stroke effect: thick black outline (6-8px width), position: outside, blend mode: normal, opacity: 100%"
               - "Professional drop shadow: distance 10px, spread 5px, size 12px, angle 135°, opacity 80%, color black, blend mode: multiply"
               - "Professional outer glow effect: spread 8px, size 15px, opacity 75%, color matching text or contrasting"
               - "Professional bevel and emboss effect: style: emboss, technique: smooth, depth 100%, size 5px, softness 2px"
               - "Professional gradient overlay: linear gradient from bright color to darker shade, angle 90°, opacity 80%"
               - "Professional inner shadow: distance 3px, choke 0%, size 5px, opacity 60%"
               - "Professional color overlay: solid color with blend mode overlay or soft light, opacity 50%"
               - "Text appears to pop out from the image with professional 3D effect"
               - "Professional text rendering with anti-aliasing, crisp edges, perfect clarity"
            
            5. COMPOSIÇÃO PROFISSIONAL:
               - "Positioned at the top center of the image with professional alignment"
               - "Bottom third of the image with professional composition and high contrast background"
               - "Centered horizontally, upper third vertically, following rule of thirds"
               - "Strategically placed to not cover important visual elements, professional layout"
               - "Text area has professional semi-transparent dark background (black overlay with 40% opacity) for better readability"
               - "Professional text box or banner behind text with gradient or solid color, rounded corners optional"
            
            6. CONTRASTE E VISIBILIDADE PROFISSIONAL:
               - "High contrast against the background, professionally optimized"
               - "Text stands out dramatically from the image with professional design techniques"
               - "Eye-catching text overlay that immediately draws attention, professional composition"
               - "Text that pops from the image with maximum visibility, professional rendering"
               - "Text is the first thing the eye is drawn to, professional visual hierarchy"
               - "Background is professionally darkened (vignette effect) or lightened behind text for maximum contrast"
               - "Professional color grading applied to background to make text stand out"
            
            7. EXEMPLO COMPLETO DE DESCRIÇÃO PROFISSIONAL:
               "Professional Photoshop-quality text design: Large, bold, stylized text '[FRASE DE GANCHO AQUI]' in bright yellow (#FFD700) with professional layer effects: thick black stroke (7px width, position outside), white drop shadow (distance 10px, spread 5px, size 12px, opacity 80%, angle 135°), subtle outer glow in white (spread 6px, size 10px, opacity 70%), positioned at the top center of the image, occupying 30% of the image height, professional bold sans-serif font (Impact or Bebas Neue style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, high contrast viral thumbnail text style, eye-catching and attention-grabbing, text appears to pop out from the image with professional 3D effect, maximum visibility for high CTR, looks like it was designed by a professional graphic designer in Photoshop"
            
            8. REGRAS DE OURO PARA DESIGN PROFISSIONAL:
               - O texto DEVE parecer feito no Photoshop por um designer profissional
               - O texto DEVE ter múltiplos efeitos de camada (stroke, shadow, glow, bevel)
               - O texto DEVE ter valores específicos de efeitos (distância, spread, tamanho, opacidade)
               - O texto DEVE ter tipografia profissional com kerning e tracking perfeitos
               - O texto DEVE ter renderização profissional (anti-aliasing, crisp edges)
               - O texto DEVE ter composição profissional (regra dos terços, hierarquia visual)
               - O texto DEVE parecer de qualidade de agência de design, não amador

            RESPONDA APENAS COM UM OBJETO JSON VÁLIDO, com a seguinte estrutura:
            {
              "ideias": [
                {
                  "seoDescription": "Descrição completa e otimizada para o YouTube aqui...",
                  "seoTags": ["tag1", "tag2", "tag3", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"]' : language === 'Inglês' ? '["He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"]' : '["Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'A detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'A detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                },
                {
                  "seoDescription": "Outra descrição completa e otimizada...",
                  "seoTags": ["tagA", "tagB", "tagC", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"]' : language === 'Inglês' ? '["The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything", "Surprising Revelation"]' : '["La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'Another detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'Another detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                }
              ]
            }
        `;
        } else {
            // Prompt padrão baseado na fórmula do título e otimizado por modelo
            const formulaContext = formulaTitulo ? `\n            FÓRMULA DO TÍTULO VIRAL IDENTIFICADA: "${formulaTitulo}"\n            MOTIVO DO SUCESSO: "${motivoSucesso || 'Análise não disponível'}"\n            \n            IMPORTANTE: Use esta fórmula como base para criar thumbnails que complementem e reforcem o mesmo gatilho mental e estratégia que tornaram o título viral.` : '';
            
            // Contexto de performance do vídeo - usar mesma classificação viral
            const viewsPerDayThumb = videoDetails.views && videoDetails.days 
                ? Math.round(videoDetails.views / Math.max(videoDetails.days, 1))
                : 0;
            const isViralThumb = isViralVideo(videoDetails.views || 0, videoDetails.days || 0, viewsPerDayThumb);
            
            const videoPerformanceContext = isViralThumb
                ? (videoDetails.views && videoDetails.days 
                    ? `\n            🚀 CONTEXTO DO VÍDEO VIRAL:\n            Esta thumbnail VIRALIZOU junto com o vídeo que alcançou ${videoDetails.views.toLocaleString()} views em apenas ${videoDetails.days} dias (média de ${viewsPerDayThumb.toLocaleString()} views/dia). Esta thumbnail foi parte do sucesso viral e precisa ser adaptada para o seu subnicho mantendo o mesmo poder de viralização.`
                    : `\n            🚀 CONTEXTO DO VÍDEO VIRAL:\n            Esta thumbnail VIRALIZOU junto com o vídeo que alcançou ${videoDetails.views.toLocaleString()} views. Esta thumbnail foi parte do sucesso viral e precisa ser adaptada para o seu subnicho mantendo o mesmo poder de viralização.`)
                : (videoDetails.views && videoDetails.days 
                    ? `\n            🚀 CONTEXTO DO VÍDEO DE REFERÊNCIA:\n            Esta thumbnail pertence a um vídeo que alcançou ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias (média de ${viewsPerDayThumb.toLocaleString()} views/dia). Este vídeo NÃO viralizou, mas a thumbnail pode ser analisada e melhorada para criar versões com maior potencial viral.`
                    : `\n            🚀 CONTEXTO DO VÍDEO DE REFERÊNCIA:\n            Esta thumbnail pertence a um vídeo que alcançou ${videoDetails.views.toLocaleString()} views. Este vídeo NÃO viralizou, mas a thumbnail pode ser analisada e melhorada para criar versões com maior potencial viral.`);
            
            // Prompts otimizados por modelo
            if (service === 'claude') {
                thumbPrompt = `
            Você é um ESPECIALISTA EM THUMBNAILS VIRAIS NO YOUTUBE, combinando as habilidades de um diretor de arte profissional e um estrategista de viralização com experiência em criar thumbnails que gerem MILHÕES DE VIEWS e ALTO CTR (acima de 25%).
            
            ⚠️⚠️⚠️ ATENÇÃO CRÍTICA - IDIOMA DAS FRASES DE GANCHO ⚠️⚠️⚠️
            O idioma selecionado é: "${language}"
            Se "${language}" for "Português", TODAS as frases de gancho DEVEM estar em PORTUGUÊS.
            Se "${language}" for "Inglês", TODAS as frases de gancho DEVEM estar em INGLÊS.
            Se "${language}" for "Espanhol", TODAS as frases de gancho DEVEM estar em ESPANHOL.
            NUNCA, JAMAIS retorne frases em inglês se o idioma for português ou espanhol.
            NUNCA, JAMAIS retorne frases em português se o idioma for inglês ou espanhol.
            NUNCA, JAMAIS retorne frases em espanhol se o idioma for português ou inglês.
            ANTES DE RETORNAR O JSON, VERIFIQUE SE TODAS AS 5 FRASES ESTÃO NO IDIOMA CORRETO "${language}".${formulaContext}${videoPerformanceContext}

            🎯 PROMPT DE ANÁLISE DE THUMBS (DIRETO DO VÍDEO VIRAL):
            Este vídeo ${isViralThumb ? 'COM ESTA THUMBNAIL VIRALIZOU' : 'DE REFERÊNCIA tem esta thumbnail'}, com o título: "${videoDetails.title}"
            
            OBJETIVO: Criar thumbnails que gerem MILHÕES DE VIEWS e ALTO CTR (acima de 25%) para canais milionários.
            
            Quero que você me dê uma ADAPTAÇÃO para meu SUBNICHO de "${subniche}" com o título: "${selectedTitle}"
            
            REGRAS CRÍTICAS:
            - Mantenha o PODER VIRAL da thumbnail original que gerou milhões de views
            - Adapte para o meu subnicho e título, mas SEMPRE mantenha a capacidade de gerar alto CTR e milhões de views
            - Analise PROFUNDAMENTE o que tornou a thumbnail original viral (composição, cores, elementos visuais, expressões, texto, contraste, psicologia visual)
            - Identifique os ELEMENTOS VIRAIS COMPROVADOS que funcionaram e mantenha-os na adaptação
            - Melhore o que for possível (cores mais vibrantes, contraste maior, composição mais impactante, iluminação mais dramática)
            - Crie thumbnails que TENHAM POTENCIAL PARA VIRALIZAR e gerar milhões de views como a original

            IMAGEM DE REFERÊNCIA: [A imagem da thumbnail original do vídeo VIRAL está anexada - analise cuidadosamente o que tornou esta thumbnail viral e gerou milhões de views]${formulaContext}

            IMAGEM DE REFERÊNCIA: [A imagem da thumbnail original do vídeo está anexada]
            ${thumbnailReferences.length > 0 ? `
            🎨 THUMBNAILS DE REFERÊNCIA DO CANAL/NICHO (IMPORTANTE - ESTILO DO CANAL):
            ${thumbnailReferences.map((ref, idx) => `[IMAGEM ${idx + 1} DE REFERÊNCIA DO CANAL: A thumbnail de referência ${idx + 1} do canal está anexada${ref.description ? ` (Descrição: ${ref.description})` : ''}]`).join('\n            ')}
            
            ⚠️⚠️⚠️ CRÍTICO - USE AS THUMBNAILS DE REFERÊNCIA DO CANAL COMO ESTILO PRINCIPAL ⚠️⚠️⚠️:
            - Analise cuidadosamente TODAS as ${thumbnailReferences.length} thumbnail(s) de referência do canal que estão anexadas acima.
            - Estas thumbnails representam o ESTILO VISUAL OFICIAL do canal/nicho "${subniche}".
            - A IDEIA 1 DEVE replicar fielmente o estilo visual dessas thumbnails de referência do canal (composição, cores, tipografia, elementos visuais, posicionamento de texto, etc.).
            - Identifique os elementos comuns entre as thumbnails de referência: tipo de composição, paleta de cores, estilo de texto, posicionamento de elementos, iluminação, etc.
            - Replique EXATAMENTE esse estilo visual na IDEIA 1, mantendo a identidade visual do canal.
            - A IDEIA 2 pode ser mais criativa, mas ainda deve respeitar a identidade visual do canal baseada nas thumbnails de referência.
            - Se as thumbnails de referência do canal usarem textos em dourado, composição dividida, close-up dramático ou outros elementos específicos, REPLIQUE-OS FIELMENTE na IDEIA 1.
            ` : ''}
            TÍTULO DO VÍDEO (para contexto): "${selectedTitle}"
            SUBNICHO (Público-Alvo): "${subniche}"
            ESTILO DE ARTE DESEJADO: "${style}"
            IDIOMA DO CONTEÚDO: "${language}"

            ⚠️ ATENÇÃO CRÍTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, não ilustrações, desenhos ou renderizações. A descriçãoThumbnail deve descrever uma FOTO REAL tirada por um fotógrafo profissional em um local real, com pessoas reais e objetos reais.
            
            🎨 IDENTIFICAÇÃO E REPLICAÇÃO DE ESTILOS ÉPICOS/CINEMATOGRÁFICOS:
            
            Analise a IMAGEM DE REFERÊNCIA e identifique qual estilo visual ela utiliza. Se identificar algum dos estilos abaixo, REPLIQUE-O FIELMENTE na IDEIA 1, apenas melhorando a qualidade:
            
            📐 ESTILO 1: COMPOSIÇÃO DIVIDIDA (ESQUERDA/DIREITA):
            - Imagem dividida verticalmente em duas metades contrastantes
            - Lado esquerdo: geralmente cenas de paz/grandiosidade (cidades antigas, paisagens douradas, céu claro)
            - Lado direito: geralmente cenas de conflito/ameaça (tempestades, navios, exércitos, céu escuro)
            - Figura central ou próxima ao centro conectando os dois lados
            - Contraste dramático entre luz (esquerda) e escuridão (direita)
            - Texto grande em dourado (#FFD700) na parte inferior, fonte serifada ornamentada com efeito emboss/bevel
            - Exemplos: Atahualpa (cidade dourada vs navios tempestuosos), Malinche (mapa vs batalha naval)
            
            📐 ESTILO 2: CLOSE-UP DRAMÁTICO COM BACKGROUND ÉPICO:
            - Figura histórica em close-up ocupando 40-60% da imagem (rosto e parte superior do corpo)
            - Expressão intensa e direta para a câmera
            - Background dividido ou com elementos épicos (pirâmides, navios, batalhas, fogo)
            - Iluminação dramática com chiaroscuro (luz forte vs sombras profundas)
            - Texto grande em dourado na parte inferior
            - Exemplos: Faraó com pirâmides ao fundo, líder indígena com cidade antiga
            
            📐 ESTILO 3: CENA ÉPICA COM ELEMENTOS DE DESTRUIÇÃO:
            - Cena de batalha ou conflito histórico
            - Elementos de fogo, fumaça, tempestades
            - Navios em chamas, exércitos, destruição
            - Céu tempestuoso com nuvens escuras
            - Figuras em primeiro plano com expressões dramáticas
            - Texto grande em dourado/amarelo com outline preto
            - Exemplos: Batalhas navais, conquistas, segredos dos faraós
            
            📐 ESTILO 4: FIGURA HISTÓRICA COM ELEMENTOS SIMBÓLICOS:
            - Figura histórica em destaque (faraó, líder, conquistador)
            - Trajes elaborados e autênticos (coroas, armaduras, roupas tradicionais)
            - Elementos simbólicos ao redor (pirâmides, navios, mapas, hieróglifos)
            - Composição vertical ou horizontal com figura dominante
            - Texto grande em dourado com fonte serifada ornamentada
            - Exemplos: Faraó com pirâmides, líder indígena com coroa elaborada
            
            ⚠️ REGRAS PARA REPLICAÇÃO FIEL:
            1. Se a thumbnail original usar COMPOSIÇÃO DIVIDIDA, mantenha EXATAMENTE essa estrutura (mesma divisão, mesmo contraste, mesma posição dos elementos)
            2. Se a thumbnail original usar CLOSE-UP DRAMÁTICO, mantenha o mesmo enquadramento e proporção da figura
            3. Se a thumbnail original usar TEXTOS EM DOURADO, mantenha a mesma cor (#FFD700), fonte serifada e efeitos (emboss, bevel, glow)
            4. Se a thumbnail original usar ELEMENTOS ÉPICOS (pirâmides, navios, fogo), mantenha os mesmos elementos na mesma posição
            5. Se a thumbnail original usar CONTRASTE LUZ/ESQUERIDÃO, mantenha o mesmo esquema de iluminação
            6. Se a thumbnail original usar FIGURAS HISTÓRICAS, mantenha o mesmo tipo de figura, trajes e expressão
            7. Apenas MELHORE: nitidez 8K, contraste mais forte, cores mais saturadas, iluminação mais dramática, texto com efeitos Photoshop mais refinados
            
            ${(() => {
                const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
                if (ruleData.mode === 'auto') {
                    return `\n            🔍 MODO AUTOMÁTICO - ANÁLISE DE REGRA:\n            Analise o título "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPLÍCITA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.\n\n            📋 AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE (ALGORITMO OFICIAL):\n\n            1️⃣ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO):\n            O cérebro precisa entender a thumbnail em menos de 1 segundo. Se houver confusão, o clique cai.\n            Checklist OBRIGATÓRIO: 1 ideia principal, 1 personagem, 1 emoção, 1 objeto-chave.\n            A thumbnail DEVE ser compreendida instantaneamente. Elimine qualquer elemento que cause confusão ou distração.\n\n            2️⃣ REGRA DO ASSUNTO ÚNICO:\n            Nada divide a atenção. A thumbnail boa é sempre uma história em uma imagem.\n            Foque em UM ÚNICO assunto dominante. Nada deve competir pela atenção. A thumbnail deve contar uma história completa em uma única imagem, sem elementos que dividam o foco.\n\n            3️⃣ REGRA DO ROSTO GRANDE:\n            Rostos com forte expressão emocional aumentam CTR de 20% a 60%.\n            Expressões mais fortes: choque, surpresa, medo, raiva, felicidade extrema.\n            Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A expressão facial DEVE ser EXTREMA e EMOCIONAL. O rosto deve ser o elemento dominante e a primeira coisa que o olho vê.\n\n            4️⃣ REGRA DO CONTRASTE BRUTAL:\n            Se não tiver contraste, a thumbnail fica invisível.\n            Use CONTRASTE BRUTAL entre: texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n            O contraste deve ser tão forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.\n\n            5️⃣ REGRA DA COR ESTRATÉGICA:\n            Cada cor ativa um gatilho:\n            - Amarelo: atenção imediata\n            - Vermelho: urgência / perigo\n            - Azul: confiança\n            - Verde: dinheiro / solução\n            - Preto: premium / mistério\n            Escolha a cor baseada na emoção que o título transmite.\n\n            6️⃣ REGRA DOS TERÇOS:\n            Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso dá harmonia e aumenta o foco natural.\n            Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos terços (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.\n\n            7️⃣ REGRA DO TEXTO ULTRA CURTO:\n            Texto deve ter 2 a 4 palavras, nunca mais.\n            Exemplos: "Ele mentiu", "Descobri isso", "Ninguém viu", "Proibido".\n            O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Textos longos matam o CTR. Seja brutalmente direto e impactante.\n\n            8️⃣ REGRA DO ZOOM EMOCIONAL:\n            Aparece sempre um elemento gigante que amplifica a emoção ou o conflito.\n            Exemplos: uma conta bancária gigante, uma faca gigante, uma lupa gigante, um número gigante.\n            Use um elemento GIGANTE que amplifique a emoção ou conflito. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.\n\n            9️⃣ REGRA DO MISTÉRIO:\n            Toda thumbnail viral tem uma pergunta implícita.\n            Exemplos: algo escondido atrás de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela.\n            Crie uma pergunta implícita na thumbnail. O espectador DEVE sentir curiosidade sobre o que está fora da imagem.\n\n            🔟 REGRA DOS PONTOS DE FUGA:\n            Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.\n            Sinalizações: setas, linhas diagonais, perspectiva.\n            Use linhas visuais que guiem o olhar para o foco. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal.\n\n            1️⃣1️⃣ REGRA DO ESPAÇO NEGATIVO:\n            Deixar áreas vazias acentua o foco. Sem isso, a imagem vira bagunça.\n            Deixe áreas vazias (espaço negativo) que acentuem o foco no elemento principal. O espaço vazio cria respiração visual e faz o elemento principal "pular" da imagem.\n\n            1️⃣2️⃣ REGRA DA COERÊNCIA COM O TÍTULO:\n            Thumbnail e título precisam contar a mesma história, mas com ângulos diferentes.\n            Título = contexto, Thumbnail = emoção.\n            A thumbnail e o título DEVEM contar a mesma história, mas com ângulos diferentes. A thumbnail deve amplificar a emoção que o título promete, criando uma sinergia perfeita.\n\n            ⚠️ CRÍTICO: Identifique qual regra melhor se encaixa no título "${selectedTitle}" e aplique-a de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.`;
                } else {
                    return `\n            📋 REGRA SELECIONADA: ${ruleData.rule.name}\n            ${ruleData.rule.description}\n\n            ${ruleData.rule.checklist ? `✅ Checklist: ${ruleData.rule.checklist.join(', ')}` : ''}\n            ${ruleData.rule.expressions ? `😮 Expressões recomendadas: ${ruleData.rule.expressions.join(', ')}` : ''}\n            ${ruleData.rule.contrasts ? `🎨 Contrastes: ${ruleData.rule.contrasts.join(', ')}` : ''}\n            ${ruleData.rule.colors ? `🌈 Cores estratégicas: ${Object.entries(ruleData.rule.colors).map(([k, v]) => `${k} (${v})`).join(', ')}` : ''}\n            ${ruleData.rule.examples ? `💡 Exemplos: ${ruleData.rule.examples.join(', ')}` : ''}\n            ${ruleData.rule.elements ? `➡️ Elementos: ${ruleData.rule.elements.join(', ')}` : ''}\n\n            ⚠️ CRÍTICO: Aplique esta regra de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail:\n            ${ruleData.instructions}`;
                }
            })()}
            
            🎯 OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando técnicas de Thumbnail Designer profissional:
            - TEXTO PROFISSIONAL (COMO PHOTOSHOP): O texto DEVE parecer feito no Photoshop por um designer profissional. Use múltiplos efeitos de camada (stroke, drop shadow com valores específicos, outer glow, bevel and emboss), tipografia profissional com kerning perfeito, renderização profissional com anti-aliasing. Grande, estilizado, cores vibrantes (amarelo/vermelho/branco com outline preto), efeitos visuais profissionais com valores específicos (distância, spread, tamanho, opacidade, ângulo), posicionamento estratégico (topo/centro), ocupando 25-35% da imagem. O texto DEVE ter qualidade de agência de design, não amador.
            - COMPOSIÇÃO: Regra dos terços, hierarquia visual clara, elemento principal em destaque
            - CORES: Alto contraste, cores complementares, saturação otimizada, fundo que faz o texto "pular"
            - EMOÇÃO: Expressões faciais intensas, momentos de tensão, curiosidade visual
            - ELEMENTOS VIRAIS: FOMO (medo de perder), surpresa, contraste dramático, storytelling visual
            
            SUA TAREFA (OTIMIZADA PARA VIRALIZAÇÃO - CLAUDE):
            Analise a thumbnail VIRAL de referência e crie DUAS (2) adaptações que mantenham o PODER VIRAL original, mas adaptadas para o subnicho "${subniche}" e o título "${selectedTitle}".
            
            ⚠️⚠️⚠️ CRÍTICO - ORDEM DAS IDEIAS ⚠️⚠️⚠️
            - **IDEIA 1 (RÉPLICA APRIMORADA DA ORIGINAL):** 
              * OBRIGATÓRIO: Esta ideia DEVE replicar e melhorar a thumbnail ORIGINAL do vídeo ao qual foram feitos os títulos.
              * Analise cuidadosamente a IMAGEM DE REFERÊNCIA (thumbnail original do vídeo) que está anexada.
              * Replique a estrutura da thumbnail de referência quase 1:1: mantenha EXATAMENTE a mesma composição, ângulo de câmera, enquadramento, posição dos personagens/objetos, paleta de cores, quantidade de texto, posição do texto, elementos visuais principais e storytelling.
              * PRESERVE o poder viral da thumbnail original que gerou milhões de views.
              * Apenas ELEVE A QUALIDADE: mais nitidez (8K), contraste reforçado, iluminação cinematográfica profissional, correções de cor profissionais, tratamento de pele profissional, brilho nos olhos, textura realista, limpeza de ruídos, adicione luzes/sombras profissionais, aplique efeitos de texto Photoshop com valores específicos (stroke, drop shadow, outer glow, bevel & emboss).
              * NÃO altere o storytelling principal, apenas entregue a versão definitiva com acabamento premium.
              * Resultado: praticamente igual à thumbnail original, mas com sensação de upgrade premium e leitura instantânea mais clara e clicável.
              * IMPORTANTE: Se a thumbnail original não estiver disponível ou não puder ser analisada, ainda assim mantenha o mesmo conceito visual e estrutura, apenas melhorando a qualidade.
            
            - **IDEIA 2 (THUMBNAIL MELHORADA E OTIMIZADA):** 
              * Esta é uma versão COMPLETAMENTE NOVA, melhorada e otimizada para CTR alto (30%+).
              * Crie um conceito totalmente novo com foco em CTR máximo: novo enquadramento, nova composição, novos elementos que gerem curiosidade extrema.
              * Use gatilhos agressivos (perigo, segredo revelado, números gigantes, setas, antes/depois, close dramático) e cores super contrastantes.
              * Construa um storytelling diferente, alinhado ao título "${selectedTitle}", que prometa algo ainda mais irresistível que a versão original.
              * O texto deve ser redesenhado para máxima legibilidade mobile, com layer styles profissionais e valores precisos.
              * Pode mudar cenário, personagens, enquadramento e paleta, explorando um novo gancho visual com FOMO extremo, contraste máximo, expressões dramáticas e elementos que não existem na thumb original.
              * Objetivo: criar uma thumbnail inédita que pareça "campanha de performance", otimizada para CTR alto e retenção visual imediata.
              * Esta versão deve ser AINDA MELHOR que a original, com técnicas avançadas de viralização.
              * LEMBRE-SE: Deve ser descrito como uma FOTO REAL, e o texto precisa parecer produzido no Photoshop por um designer profissional com múltiplos efeitos de camada e valores específicos.

            PARA CADA UMA DAS 2 IDEIAS, GERE:
            1.  **"seoDescription"**: Uma descrição de vídeo para o YouTube, EXTREMAMENTE OTIMIZADA PARA SEO E VIRALIZAÇÃO, com:
               - Emojis estratégicos e relevantes (use emojis que representem o nicho e subnicho)
               - Parágrafos bem estruturados com quebras de linha
               - Chamadas para ação (CTA) claras e persuasivas
               - Uso estratégico de palavras-chave relevantes para o título "${selectedTitle}" e subnicho "${subniche}"
               - Formatação profissional com separadores visuais (━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━)
               - Seções organizadas: introdução, conteúdo do vídeo, sobre o canal, links importantes, hashtags
               - Linguagem persuasiva e envolvente que gere curiosidade e urgência
               - A descrição deve estar no idioma "${language}" e ter entre 300-500 palavras
               - IMPORTANTE: Use emojis de forma estratégica (não exagere, mas use para destacar seções importantes)
               - Inclua hashtags relevantes no final
               - Seja específico sobre o que o espectador vai aprender/ganhar
               
            2.  **"seoTags"**: Um array de strings com as 15-25 tags MAIS RELEVANTES E ESTRATÉGICAS para o vídeo (LIMITE MÁXIMO: 300 caracteres no total, incluindo vírgulas e espaços. NÃO ultrapasse 300 caracteres), incluindo:
               - Tags de cauda curta (1-2 palavras): termos populares e competitivos relacionados ao título "${selectedTitle}" e subnicho "${subniche}"
               - Tags de cauda longa (3-5 palavras): termos mais específicos e menos competitivos que capturam intenção de busca
               - Tags de nicho: termos específicos do subnicho "${subniche}"
               - Tags de tendência: termos que estão em alta no momento relacionados ao tema
               - Tags de formato: termos como "tutorial", "dicas", "como fazer", "guia completo", "passo a passo", etc.
               - Tags de plataforma: termos relacionados à plataforma (YouTube, TikTok, Instagram, etc.)
               - Tags de emoção: termos que capturam a emoção do título (ex: "surpresa", "revelação", "mistério", "urgência", "choque")
               - Tags de benefício: termos que descrevem o que o espectador vai ganhar/aprender
               - Tags de palavra-chave principal: extrair as palavras-chave mais importantes do título "${selectedTitle}"
               - Tags de sinônimos: variações e sinônimos das palavras-chave principais
               - IMPORTANTE: As tags devem ser EXTREMAMENTE RELEVANTES ao título "${selectedTitle}" e ao subnicho "${subniche}"
               - Evite tags genéricas que não agregam valor
               - Priorize tags que tenham volume de busca mas não sejam extremamente competitivas
               - Misture tags em português/inglês/espanhol conforme o idioma "${language}"
               - LIMITE MÁXIMO: 300 caracteres no total (incluindo vírgulas e espaços). NÃO ultrapasse 300 caracteres.
               - Cada tag deve ter entre 1-5 palavras, sendo a maioria com 2-3 palavras para otimizar o uso do espaço
               - Priorize tags mais relevantes e estratégicas. Se necessário, reduza a quantidade de tags para não ultrapassar 300 caracteres.
            3.  **"frasesDeGancho"**: Um array com 5 frases CURTAS de impacto (ganchos) para a thumbnail, OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne um array vazio [].' : `
                ⚠️⚠️⚠️ CRÍTICO E OBRIGATÓRIO - IDIOMA DAS FRASES DE GANCHO ⚠️⚠️⚠️
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Português' ? `
                ✅ CORRETO (Português): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : language === 'Inglês' ? `
                ✅ CORRETO (Inglês): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : `
                ✅ CORRETO (Espanhol): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante", "La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGATÓRIAS:
                1. Se "${language}" for "Português", TODAS as 5 frases DEVEM estar em PORTUGUÊS (Brasil)
                2. Se "${language}" for "Inglês", TODAS as 5 frases DEVEM estar em INGLÊS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em inglês se o idioma escolhido for português ou espanhol
                5. NUNCA, JAMAIS retorne frases em português se o idioma escolhido for inglês ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for português ou inglês
                7. Cada frase deve ter 2 a 4 palavras, no máximo
                8. As frases devem ser impactantes e relacionadas ao título "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases estão no idioma "${language}"?
                - Nenhuma frase está em inglês se "${language}" for português ou espanhol?
                - Nenhuma frase está em português se "${language}" for inglês ou espanhol?
                - Nenhuma frase está em espanhol se "${language}" for português ou inglês?
                
                Se alguma resposta for NÃO, CORRIJA as frases antes de retornar o JSON.
                `}
            4.  **"descricaoThumbnail"**: Um prompt EXTREMAMENTE DETALHADO e VÍVIDO, em INGLÊS, para uma IA de geração de imagem. ${!includePhrases ? 'NÃO inclua nenhum placeholder para texto. A thumbnail deve ser APENAS imagem, sem texto ou frases de gancho. Descreva apenas elementos visuais, composição, cores, iluminação, etc.' : 'A descrição DEVE incluir OBRIGATORIAMENTE o placeholder exato "[FRASE DE GANCHO AQUI]" em algum lugar da descrição, onde o texto da thumbnail será inserido. CRÍTICO: O placeholder "[FRASE DE GANCHO AQUI]" DEVE aparecer literalmente na descrição. Quando mencionar o texto, descreva-o como se fosse criado no Photoshop por um designer profissional: use termos como "Professional Photoshop-quality text design displaying [FRASE DE GANCHO AQUI]", "professional layer effects", "Photoshop stroke effect", "professional drop shadow with specific values (distance, spread, size, opacity, angle)", "professional outer glow", "professional bevel and emboss", "professional typography with perfect kerning", "professional text rendering with anti-aliasing", "looks like it was designed by a professional graphic designer". O texto DEVE ter múltiplos efeitos de camada do Photoshop com valores específicos, não apenas descrições genéricas. Fonte estilizada profissional, grande e impactante, cores vibrantes e contrastantes, efeitos visuais profissionais (sombra com valores específicos, brilho, outline, gradiente), posicionamento estratégico, tamanho grande que ocupa 25-35% da imagem. IMPORTANTE: Sempre inclua o texto "[FRASE DE GANCHO AQUI]" literalmente na descrição, por exemplo: "with professional text design displaying [FRASE DE GANCHO AQUI]" ou "featuring large bold text that says [FRASE DE GANCHO AQUI]".'}
            
            CRÍTICO PARA A "descricaoThumbnail" - DEVE SER FOTOGRAFIA REAL ULTRA HD 8K, NÃO ILUSTRAÇÃO:
            - OBRIGATÓRIO: A descrição DEVE começar EXATAMENTE com: "Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, real lighting, real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, 8K resolution, extreme sharpness, maximum detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography quality"
            
            - ENFATIZE REPETIDAMENTE E OBRIGATORIAMENTE: "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail", "every pore visible", "every texture crisp", "perfect focus", "ultra sharp", "no blur except intentional depth of field", "no artifacts", "no compression", "no pixelation", "perfect clarity", "real photograph", "shot on location", "documentary photography", "realistic textures with imperfections", "natural lighting with real shadows", "real depth of field", "real bokeh effects", "professional color grading", "high dynamic range (HDR)", "sharp focus on subject", "real camera grain", "real-world photography", "actual photograph", "photographed in real life", "real person", "real object", "real environment", "National Geographic quality", "BBC documentary style", "professional photography", "photorealistic", "hyper-realistic"
            
            - NUNCA, JAMAIS use estes termos: "illustration", "drawing", "artwork", "digital art", "render", "3D render", "CGI", "cartoon", "anime", "sketch", "painting", "stylized", "artistic", "concept art", "digital painting", "graphic design", "vector", "comic", "fantasy art", "artistic interpretation", "stylized", "artistic style", "digital illustration"
            
            - SEMPRE use APENAS estes termos: "photograph", "photo", "photography", "shot", "captured", "documentary photo", "realistic capture", "professional photography", "real-world photography", "actual photograph", "photographed", "real-life photography", "on-location photography", "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail"
            
            - IMPORTANTE: Descreva como se fosse uma FOTO REAL ULTRA HD 8K tirada por um fotógrafo profissional. Mencione detalhes realistas como: "real skin texture with pores and natural imperfections visible in 8K detail", "real fabric texture with visible fibers and weave patterns in ultra HD", "real stone texture with weathering, cracks, and imperfections visible in perfect 8K clarity", "real shadows cast by real light sources with perfect sharpness", "real depth of field blur with perfect bokeh", "real camera lens distortion", "real chromatic aberration", "real lens flare", "real motion blur if applicable", "every detail visible in 8K resolution", "extreme sharpness and clarity", "no compression artifacts", "perfect focus on subject"

            REGRAS IMPORTANTES:
            - A "descricaoThumbnail" é OBRIGATORIAMENTE em INGLÊS.
            - "seoDescription", "seoTags" e "frasesDeGancho" são OBRIGATORIAMENTE no idioma "${language}".
            ${!includePhrases ? '- IMPORTANTE: A "descricaoThumbnail" NÃO deve mencionar texto, palavras ou frases. Apenas descreva elementos visuais, composição, cores, iluminação, etc.' : ''}
            - Seja extremamente específico e detalhado nas descrições visuais. Use termos técnicos de fotografia profissional, cinematografia e psicologia visual quando apropriado.
            - Foque em elementos que maximizem CTR: expressões faciais intensas, momentos de tensão, curiosidade visual, contraste dramático, composição impactante.
            
            EXEMPLOS DE COMO DESCREVER PARA GARANTIR REALISMO:
            - Em vez de "um guerreiro maia", escreva: "a real person dressed as a Mayan warrior, photographed on location, real skin texture with pores and natural imperfections, real fabric of the costume with visible texture and wrinkles, real feathers in the headdress with natural variations"
            - Em vez de "uma pirâmide antiga", escreva: "a real ancient Mayan pyramid photographed on location, real weathered stone with cracks and imperfections, real moss and vegetation growing on the stones, real shadows cast by the sun, real depth of field blur in the background"
            - Em vez de "luz mística", escreva: "real natural lighting from the sun, real shadows cast by real objects, real depth of field, real bokeh in the background, real camera lens flare if the sun is in frame"
            - SEMPRE mencione: "real", "actual", "photographed", "shot on location", "documentary style", "real-world", "actual photograph"
            
            TÉCNICAS DE THUMBNAIL VIRAL PARA O TEXTO (quando includePhrases = true) - DESIGN PROFISSIONAL COMO PHOTOSHOP - CTR ACIMA DE 25%:
            
            📝 DESCRIÇÃO OBRIGATÓRIA DO TEXTO - DEVE PARECER FEITO NO PHOTOSHOP POR UM DESIGNER PROFISSIONAL:
            O texto DEVE ser descrito como se fosse criado no Photoshop com técnicas profissionais de design gráfico:
            
            1. TIPOGRAFIA PROFISSIONAL:
               - "Professional typography, Photoshop-quality text design"
               - "Large, bold, professionally designed text occupying 25-35% of the image height"
               - "Massive, oversized typography with professional letter spacing and kerning"
               - "Thick, chunky, professionally rendered letters"
               - "Typography that looks like it was designed by a professional graphic designer"
               - "High-end text design, magazine-quality typography"
            
            2. CORES PROFISSIONAIS E EFEITOS DE CAMADA (Layer Effects do Photoshop):
               - "Bright yellow (#FFD700) text with professional Photoshop layer effects: thick black stroke (6-8px), white drop shadow with distance 8px, spread 5px, size 12px, opacity 80%, angle 135 degrees"
               - "Pure white text with professional red stroke (6px), black drop shadow with blur radius 10px, and subtle outer glow effect in yellow"
               - "Neon orange (#FF6600) text with black stroke (7px), professional drop shadow with multiple layers, and yellow outer glow with spread 8px"
               - "Electric blue (#00FFFF) text with white stroke (6px), black shadow with distance 10px, and professional bevel and emboss effect"
               - "Bright red (#FF0000) text with yellow stroke (5px), white drop shadow, and professional gradient overlay from yellow to orange"
               - "Lime green (#00FF00) text with black stroke (8px), white glow effect, and professional inner shadow"
               - IMPORTANTE: Descreva como efeitos de camada do Photoshop (layer effects), não apenas "outline" ou "shadow"
               
               🏆 ESTILO ÉPICO - TEXTOS EM DOURADO (Para thumbnails históricas/épicas):
               - Se a thumbnail original usar textos em dourado, DESCREVA EXATAMENTE assim:
               - "Large, bold, ornate serif font text in golden yellow (#FFD700) with professional Photoshop layer effects: thick black stroke (8-10px width, position outside), professional bevel and emboss effect (style: emboss, technique: smooth, depth 150%, size 8px, softness 3px, highlight mode: screen with opacity 75%, shadow mode: multiply with opacity 50%), white drop shadow (distance 12px, spread 6px, size 15px, opacity 85%, angle 135°), subtle outer glow in golden yellow (spread 10px, size 20px, opacity 60%), positioned at the bottom center of the image, occupying 30-35% of the image height, professional ornate serif typography (Trajan Pro, Cinzel, or similar historical/regal font style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, looks like it was designed by a professional graphic designer for a historical epic movie poster"
               - "Golden embossed text with metallic finish, professional 3D effect, regal and majestic appearance, historical epic typography style"
            
            3. FONTES PROFISSIONAIS:
               - "Professional bold sans-serif font (Impact, Bebas Neue, Montserrat Black, or similar premium font)"
               - "Thick, chunky, professionally designed block letters"
               - "Modern, high-end typography with perfect letter spacing"
               - "YouTube viral thumbnail professional font style"
               - "Bold, condensed font with professional kerning and tracking"
               - "Premium typography, no serifs, maximum readability, professional design"
               - "Typography that looks like it came from a professional design agency"
            
            4. EFEITOS PROFISSIONAIS DO PHOTOSHOP (Layer Styles):
               - "Professional Photoshop stroke effect: thick black outline (6-8px width), position: outside, blend mode: normal, opacity: 100%"
               - "Professional drop shadow: distance 10px, spread 5px, size 12px, angle 135°, opacity 80%, color black, blend mode: multiply"
               - "Professional outer glow effect: spread 8px, size 15px, opacity 75%, color matching text or contrasting"
               - "Professional bevel and emboss effect: style: emboss, technique: smooth, depth 100%, size 5px, softness 2px"
               - "Professional gradient overlay: linear gradient from bright color to darker shade, angle 90°, opacity 80%"
               - "Professional inner shadow: distance 3px, choke 0%, size 5px, opacity 60%"
               - "Professional color overlay: solid color with blend mode overlay or soft light, opacity 50%"
               - "Text appears to pop out from the image with professional 3D effect"
               - "Professional text rendering with anti-aliasing, crisp edges, perfect clarity"
            
            5. COMPOSIÇÃO PROFISSIONAL:
               - "Positioned at the top center of the image with professional alignment"
               - "Bottom third of the image with professional composition and high contrast background"
               - "Centered horizontally, upper third vertically, following rule of thirds"
               - "Strategically placed to not cover important visual elements, professional layout"
               - "Text area has professional semi-transparent dark background (black overlay with 40% opacity) for better readability"
               - "Professional text box or banner behind text with gradient or solid color, rounded corners optional"
            
            6. CONTRASTE E VISIBILIDADE PROFISSIONAL:
               - "High contrast against the background, professionally optimized"
               - "Text stands out dramatically from the image with professional design techniques"
               - "Eye-catching text overlay that immediately draws attention, professional composition"
               - "Text that pops from the image with maximum visibility, professional rendering"
               - "Text is the first thing the eye is drawn to, professional visual hierarchy"
               - "Background is professionally darkened (vignette effect) or lightened behind text for maximum contrast"
               - "Professional color grading applied to background to make text stand out"
            
            7. EXEMPLO COMPLETO DE DESCRIÇÃO PROFISSIONAL:
               "Professional Photoshop-quality text design: Large, bold, stylized text '[FRASE DE GANCHO AQUI]' in bright yellow (#FFD700) with professional layer effects: thick black stroke (7px width, position outside), white drop shadow (distance 10px, spread 5px, size 12px, opacity 80%, angle 135°), subtle outer glow in white (spread 6px, size 10px, opacity 70%), positioned at the top center of the image, occupying 30% of the image height, professional bold sans-serif font (Impact or Bebas Neue style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, high contrast viral thumbnail text style, eye-catching and attention-grabbing, text appears to pop out from the image with professional 3D effect, maximum visibility for high CTR, looks like it was designed by a professional graphic designer in Photoshop"
            
            8. REGRAS DE OURO PARA DESIGN PROFISSIONAL:
               - O texto DEVE parecer feito no Photoshop por um designer profissional
               - O texto DEVE ter múltiplos efeitos de camada (stroke, shadow, glow, bevel)
               - O texto DEVE ter valores específicos de efeitos (distância, spread, tamanho, opacidade)
               - O texto DEVE ter tipografia profissional com kerning e tracking perfeitos
               - O texto DEVE ter renderização profissional (anti-aliasing, crisp edges)
               - O texto DEVE ter composição profissional (regra dos terços, hierarquia visual)
               - O texto DEVE parecer de qualidade de agência de design, não amador

            RESPONDA APENAS COM UM OBJETO JSON VÁLIDO, com a seguinte estrutura:
            {
              "ideias": [
                {
                  "seoDescription": "Descrição completa e otimizada para o YouTube aqui...",
                  "seoTags": ["tag1", "tag2", "tag3", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"]' : language === 'Inglês' ? '["He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"]' : '["Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'A detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'A detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                },
                {
                  "seoDescription": "Outra descrição completa e otimizada...",
                  "seoTags": ["tagA", "tagB", "tagC", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"]' : language === 'Inglês' ? '["The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything", "Surprising Revelation"]' : '["La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'Another detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'Another detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                }
              ]
            }
        `;
            } else if (service === 'gemini') {
                thumbPrompt = `
            Você é um ESPECIALISTA EM THUMBNAILS VIRAIS NO YOUTUBE, combinando as habilidades de um diretor de arte profissional e um estrategista de viralização com experiência em criar thumbnails que geram MILHÕES DE VIEWS e ALTO CTR (acima de 25%).
            
            ⚠️⚠️⚠️ ATENÇÃO CRÍTICA - IDIOMA DAS FRASES DE GANCHO ⚠️⚠️⚠️
            O idioma selecionado é: "${language}"
            Se "${language}" for "Português", TODAS as frases de gancho DEVEM estar em PORTUGUÊS.
            Se "${language}" for "Inglês", TODAS as frases de gancho DEVEM estar em INGLÊS.
            Se "${language}" for "Espanhol", TODAS as frases de gancho DEVEM estar em ESPANHOL.
            NUNCA, JAMAIS retorne frases em inglês se o idioma for português ou espanhol.
            NUNCA, JAMAIS retorne frases em português se o idioma for inglês ou espanhol.
            NUNCA, JAMAIS retorne frases em espanhol se o idioma for português ou inglês.
            ANTES DE RETORNAR O JSON, VERIFIQUE SE TODAS AS 5 FRASES ESTÃO NO IDIOMA CORRETO "${language}".${formulaContext}${videoPerformanceContext}

            🎯 PROMPT DE ANÁLISE DE THUMBS (DIRETO DO VÍDEO VIRAL):
            Este vídeo ${isViralThumb ? 'COM ESTA THUMBNAIL VIRALIZOU' : 'DE REFERÊNCIA tem esta thumbnail'}, com o título: "${videoDetails.title}"
            
            OBJETIVO: Criar thumbnails que gerem MILHÕES DE VIEWS e ALTO CTR (acima de 25%) para canais milionários.
            
            Quero que você me dê uma ADAPTAÇÃO para meu SUBNICHO de "${subniche}" com o título: "${selectedTitle}"
            
            REGRAS CRÍTICAS:
            - Mantenha o PODER VIRAL da thumbnail original que gerou milhões de views
            - Adapte para o meu subnicho e título, mas SEMPRE mantenha a capacidade de gerar alto CTR e milhões de views
            - Analise PROFUNDAMENTE o que tornou a thumbnail original viral (composição, cores, elementos visuais, expressões, texto, contraste, psicologia visual)
            - Identifique os ELEMENTOS VIRAIS COMPROVADOS que funcionaram e mantenha-os na adaptação
            - Melhore o que for possível (cores mais vibrantes, contraste maior, composição mais impactante, iluminação mais dramática)
            - Crie thumbnails que TENHAM POTENCIAL PARA VIRALIZAR e gerar milhões de views como a original

            IMAGEM DE REFERÊNCIA: [A imagem da thumbnail original do vídeo VIRAL está anexada - analise cuidadosamente o que tornou esta thumbnail viral e gerou milhões de views]${formulaContext}

            IMAGEM DE REFERÊNCIA: [A imagem da thumbnail original do vídeo está anexada]
            ${thumbnailReferences.length > 0 ? `
            🎨 THUMBNAILS DE REFERÊNCIA DO CANAL/NICHO (IMPORTANTE - ESTILO DO CANAL):
            ${thumbnailReferences.map((ref, idx) => `[IMAGEM ${idx + 1} DE REFERÊNCIA DO CANAL: A thumbnail de referência ${idx + 1} do canal está anexada${ref.description ? ` (Descrição: ${ref.description})` : ''}]`).join('\n            ')}
            
            ⚠️⚠️⚠️ CRÍTICO - USE AS THUMBNAILS DE REFERÊNCIA DO CANAL COMO ESTILO PRINCIPAL ⚠️⚠️⚠️:
            - Analise cuidadosamente TODAS as ${thumbnailReferences.length} thumbnail(s) de referência do canal que estão anexadas acima.
            - Estas thumbnails representam o ESTILO VISUAL OFICIAL do canal/nicho "${subniche}".
            - A IDEIA 1 DEVE replicar fielmente o estilo visual dessas thumbnails de referência do canal (composição, cores, tipografia, elementos visuais, posicionamento de texto, etc.).
            - Identifique os elementos comuns entre as thumbnails de referência: tipo de composição, paleta de cores, estilo de texto, posicionamento de elementos, iluminação, etc.
            - Replique EXATAMENTE esse estilo visual na IDEIA 1, mantendo a identidade visual do canal.
            - A IDEIA 2 pode ser mais criativa, mas ainda deve respeitar a identidade visual do canal baseada nas thumbnails de referência.
            - Se as thumbnails de referência do canal usarem textos em dourado, composição dividida, close-up dramático ou outros elementos específicos, REPLIQUE-OS FIELMENTE na IDEIA 1.
            ` : ''}
            TÍTULO DO VÍDEO (para contexto): "${selectedTitle}"
            SUBNICHO (Público-Alvo): "${subniche}"
            ESTILO DE ARTE DESEJADO: "${style}"
            IDIOMA DO CONTEÚDO: "${language}"

            ⚠️ ATENÇÃO CRÍTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, não ilustrações, desenhos ou renderizações. A descriçãoThumbnail deve descrever uma FOTO REAL tirada por um fotógrafo profissional em um local real, com pessoas reais e objetos reais.
            
            🎨 IDENTIFICAÇÃO E REPLICAÇÃO DE ESTILOS ÉPICOS/CINEMATOGRÁFICOS:
            
            Analise a IMAGEM DE REFERÊNCIA e identifique qual estilo visual ela utiliza. Se identificar algum dos estilos abaixo, REPLIQUE-O FIELMENTE na IDEIA 1, apenas melhorando a qualidade:
            
            📐 ESTILO 1: COMPOSIÇÃO DIVIDIDA (ESQUERDA/DIREITA):
            - Imagem dividida verticalmente em duas metades contrastantes
            - Lado esquerdo: geralmente cenas de paz/grandiosidade (cidades antigas, paisagens douradas, céu claro)
            - Lado direito: geralmente cenas de conflito/ameaça (tempestades, navios, exércitos, céu escuro)
            - Figura central ou próxima ao centro conectando os dois lados
            - Contraste dramático entre luz (esquerda) e escuridão (direita)
            - Texto grande em dourado (#FFD700) na parte inferior, fonte serifada ornamentada com efeito emboss/bevel
            - Exemplos: Atahualpa (cidade dourada vs navios tempestuosos), Malinche (mapa vs batalha naval)
            
            📐 ESTILO 2: CLOSE-UP DRAMÁTICO COM BACKGROUND ÉPICO:
            - Figura histórica em close-up ocupando 40-60% da imagem (rosto e parte superior do corpo)
            - Expressão intensa e direta para a câmera
            - Background dividido ou com elementos épicos (pirâmides, navios, batalhas, fogo)
            - Iluminação dramática com chiaroscuro (luz forte vs sombras profundas)
            - Texto grande em dourado na parte inferior
            - Exemplos: Faraó com pirâmides ao fundo, líder indígena com cidade antiga
            
            📐 ESTILO 3: CENA ÉPICA COM ELEMENTOS DE DESTRUIÇÃO:
            - Cena de batalha ou conflito histórico
            - Elementos de fogo, fumaça, tempestades
            - Navios em chamas, exércitos, destruição
            - Céu tempestuoso com nuvens escuras
            - Figuras em primeiro plano com expressões dramáticas
            - Texto grande em dourado/amarelo com outline preto
            - Exemplos: Batalhas navais, conquistas, segredos dos faraós
            
            📐 ESTILO 4: FIGURA HISTÓRICA COM ELEMENTOS SIMBÓLICOS:
            - Figura histórica em destaque (faraó, líder, conquistador)
            - Trajes elaborados e autênticos (coroas, armaduras, roupas tradicionais)
            - Elementos simbólicos ao redor (pirâmides, navios, mapas, hieróglifos)
            - Composição vertical ou horizontal com figura dominante
            - Texto grande em dourado com fonte serifada ornamentada
            - Exemplos: Faraó com pirâmides, líder indígena com coroa elaborada
            
            ⚠️ REGRAS PARA REPLICAÇÃO FIEL:
            1. Se a thumbnail original usar COMPOSIÇÃO DIVIDIDA, mantenha EXATAMENTE essa estrutura (mesma divisão, mesmo contraste, mesma posição dos elementos)
            2. Se a thumbnail original usar CLOSE-UP DRAMÁTICO, mantenha o mesmo enquadramento e proporção da figura
            3. Se a thumbnail original usar TEXTOS EM DOURADO, mantenha a mesma cor (#FFD700), fonte serifada e efeitos (emboss, bevel, glow)
            4. Se a thumbnail original usar ELEMENTOS ÉPICOS (pirâmides, navios, fogo), mantenha os mesmos elementos na mesma posição
            5. Se a thumbnail original usar CONTRASTE LUZ/ESQUERIDÃO, mantenha o mesmo esquema de iluminação
            6. Se a thumbnail original usar FIGURAS HISTÓRICAS, mantenha o mesmo tipo de figura, trajes e expressão
            7. Apenas MELHORE: nitidez 8K, contraste mais forte, cores mais saturadas, iluminação mais dramática, texto com efeitos Photoshop mais refinados
            
            ${(() => {
                const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
                if (ruleData.mode === 'auto') {
                    return `\n            🔍 MODO AUTOMÁTICO - ANÁLISE DE REGRA:\n            Analise o título "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPLÍCITA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.\n\n            📋 AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE (ALGORITMO OFICIAL):\n\n            1️⃣ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO):\n            O cérebro precisa entender a thumbnail em menos de 1 segundo. Se houver confusão, o clique cai.\n            Checklist OBRIGATÓRIO: 1 ideia principal, 1 personagem, 1 emoção, 1 objeto-chave.\n            A thumbnail DEVE ser compreendida instantaneamente. Elimine qualquer elemento que cause confusão ou distração.\n\n            2️⃣ REGRA DO ASSUNTO ÚNICO:\n            Nada divide a atenção. A thumbnail boa é sempre uma história em uma imagem.\n            Foque em UM ÚNICO assunto dominante. Nada deve competir pela atenção. A thumbnail deve contar uma história completa em uma única imagem, sem elementos que dividam o foco.\n\n            3️⃣ REGRA DO ROSTO GRANDE:\n            Rostos com forte expressão emocional aumentam CTR de 20% a 60%.\n            Expressões mais fortes: choque, surpresa, medo, raiva, felicidade extrema.\n            Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A expressão facial DEVE ser EXTREMA e EMOCIONAL. O rosto deve ser o elemento dominante e a primeira coisa que o olho vê.\n\n            4️⃣ REGRA DO CONTRASTE BRUTAL:\n            Se não tiver contraste, a thumbnail fica invisível.\n            Use CONTRASTE BRUTAL entre: texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n            O contraste deve ser tão forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.\n\n            5️⃣ REGRA DA COR ESTRATÉGICA:\n            Cada cor ativa um gatilho:\n            - Amarelo: atenção imediata\n            - Vermelho: urgência / perigo\n            - Azul: confiança\n            - Verde: dinheiro / solução\n            - Preto: premium / mistério\n            Escolha a cor baseada na emoção que o título transmite.\n\n            6️⃣ REGRA DOS TERÇOS:\n            Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso dá harmonia e aumenta o foco natural.\n            Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos terços (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.\n\n            7️⃣ REGRA DO TEXTO ULTRA CURTO:\n            Texto deve ter 2 a 4 palavras, nunca mais.\n            Exemplos: "Ele mentiu", "Descobri isso", "Ninguém viu", "Proibido".\n            O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Textos longos matam o CTR. Seja brutalmente direto e impactante.\n\n            8️⃣ REGRA DO ZOOM EMOCIONAL:\n            Aparece sempre um elemento gigante que amplifica a emoção ou o conflito.\n            Exemplos: uma conta bancária gigante, uma faca gigante, uma lupa gigante, um número gigante.\n            Use um elemento GIGANTE que amplifique a emoção ou conflito. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.\n\n            9️⃣ REGRA DO MISTÉRIO:\n            Toda thumbnail viral tem uma pergunta implícita.\n            Exemplos: algo escondido atrás de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela.\n            Crie uma pergunta implícita na thumbnail. O espectador DEVE sentir curiosidade sobre o que está fora da imagem.\n\n            🔟 REGRA DOS PONTOS DE FUGA:\n            Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.\n            Sinalizações: setas, linhas diagonais, perspectiva.\n            Use linhas visuais que guiem o olhar para o foco. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal.\n\n            1️⃣1️⃣ REGRA DO ESPAÇO NEGATIVO:\n            Deixar áreas vazias acentua o foco. Sem isso, a imagem vira bagunça.\n            Deixe áreas vazias (espaço negativo) que acentuem o foco no elemento principal. O espaço vazio cria respiração visual e faz o elemento principal "pular" da imagem.\n\n            1️⃣2️⃣ REGRA DA COERÊNCIA COM O TÍTULO:\n            Thumbnail e título precisam contar a mesma história, mas com ângulos diferentes.\n            Título = contexto, Thumbnail = emoção.\n            A thumbnail e o título DEVEM contar a mesma história, mas com ângulos diferentes. A thumbnail deve amplificar a emoção que o título promete, criando uma sinergia perfeita.\n\n            ⚠️ CRÍTICO: Identifique qual regra melhor se encaixa no título "${selectedTitle}" e aplique-a de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.`;
                } else {
                    return `\n            📋 REGRA SELECIONADA: ${ruleData.rule.name}\n            ${ruleData.rule.description}\n\n            ${ruleData.rule.checklist ? `✅ Checklist: ${ruleData.rule.checklist.join(', ')}` : ''}\n            ${ruleData.rule.expressions ? `😮 Expressões recomendadas: ${ruleData.rule.expressions.join(', ')}` : ''}\n            ${ruleData.rule.contrasts ? `🎨 Contrastes: ${ruleData.rule.contrasts.join(', ')}` : ''}\n            ${ruleData.rule.colors ? `🌈 Cores estratégicas: ${Object.entries(ruleData.rule.colors).map(([k, v]) => `${k} (${v})`).join(', ')}` : ''}\n            ${ruleData.rule.examples ? `💡 Exemplos: ${ruleData.rule.examples.join(', ')}` : ''}\n            ${ruleData.rule.elements ? `➡️ Elementos: ${ruleData.rule.elements.join(', ')}` : ''}\n\n            ⚠️ CRÍTICO: Aplique esta regra de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail:\n            ${ruleData.instructions}`;
                }
            })()}
            
            🎯 OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando técnicas de Thumbnail Designer profissional:
            - TEXTO PROFISSIONAL (COMO PHOTOSHOP): O texto DEVE parecer feito no Photoshop por um designer profissional. Use múltiplos efeitos de camada (stroke, drop shadow com valores específicos, outer glow, bevel and emboss), tipografia profissional com kerning perfeito, renderização profissional com anti-aliasing. Grande, estilizado, cores vibrantes (amarelo/vermelho/branco com outline preto), efeitos visuais profissionais com valores específicos (distância, spread, tamanho, opacidade, ângulo), posicionamento estratégico (topo/centro), ocupando 25-35% da imagem. O texto DEVE ter qualidade de agência de design, não amador.
            - COMPOSIÇÃO: Regra dos terços, hierarquia visual clara, elemento principal em destaque
            - CORES: Alto contraste, cores complementares, saturação otimizada, fundo que faz o texto "pular"
            - EMOÇÃO: Expressões faciais intensas, momentos de tensão, curiosidade visual
            - ELEMENTOS VIRAIS: FOMO (medo de perder), surpresa, contraste dramático, storytelling visual
            
            SUA TAREFA (OTIMIZADA PARA VIRALIZAÇÃO - GEMINI):
            Analise a thumbnail VIRAL de referência e crie DUAS (2) adaptações que mantenham o PODER VIRAL original, mas adaptadas para o subnicho "${subniche}" e o título "${selectedTitle}".
            
            - **IDEIA 1 (RÉPLICA APRIMORADA DA ORIGINAL):** 
              * Copie a mesma estrutura da thumbnail de referência (ângulo da câmera, pose dos personagens, direção do olhar, escala dos elementos, posição do texto).
              * Mantenha a paleta de cores, quantidade de texto, ícones, props e o storytelling visual original.
              * Apenas eleve a execução: mais nitidez, contraste calibrado, recorte perfeito, tratamento de pele profissional, brilho nos olhos, texto com efeitos Photoshop refinados (stroke, drop shadow com valores específicos, outer glow, bevel & emboss).
              * Pequenos ajustes permitidos: limpar ruído visual, alinhar melhor elementos, reforçar a narrativa com micro detalhes, mas sem alterar a ideia central.
              * Resultado deve parecer uma versão “directors cut” da mesma thumbnail – quase idêntica, porém mais moderna e com sensação premium.
            
            - **IDEIA 2 (TURBO CTR INOVADOR):** 
              * Desapegue da composição original e proponha um conceito totalmente novo voltado para CTR 30%+.
              * Use novos enquadramentos, close dramático ou cena cinematográfica inédita que amplifique o gancho do título "${selectedTitle}".
              * Aplique gatilhos agressivos de curiosidade e FOMO (expressões extremas, contraste brutal, elementos inesperados).
              * Redesenhe texto, cores, objetos e iluminação para maximizar leitura instantânea em telas pequenas.
              * Traga um storytelling visual diferente (antes/depois, contagem regressiva, perigo iminente, segredo revelado etc.) que não existe na thumb original.
              * LEMBRE-SE: Deve ser descrito como uma FOTO REAL, e o texto precisa parecer produzido no Photoshop por um designer profissional com múltiplos efeitos de camada e valores específicos.

            PARA CADA UMA DAS 2 IDEIAS, GERE:
            1.  **"seoDescription"**: Uma descrição de vídeo para o YouTube, EXTREMAMENTE OTIMIZADA PARA SEO E VIRALIZAÇÃO, com:
               - Emojis estratégicos e relevantes (use emojis que representem o nicho e subnicho)
               - Parágrafos bem estruturados com quebras de linha
               - Chamadas para ação (CTA) claras e persuasivas
               - Uso estratégico de palavras-chave relevantes para o título "${selectedTitle}" e subnicho "${subniche}"
               - Formatação profissional com separadores visuais (━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━)
               - Seções organizadas: introdução, conteúdo do vídeo, sobre o canal, links importantes, hashtags
               - Linguagem persuasiva e envolvente que gere curiosidade e urgência
               - A descrição deve estar no idioma "${language}" e ter entre 300-500 palavras
               - IMPORTANTE: Use emojis de forma estratégica (não exagere, mas use para destacar seções importantes)
               - Inclua hashtags relevantes no final
               - Seja específico sobre o que o espectador vai aprender/ganhar
               
            2.  **"seoTags"**: Um array de strings com as 15-25 tags MAIS RELEVANTES E ESTRATÉGICAS para o vídeo (LIMITE MÁXIMO: 300 caracteres no total, incluindo vírgulas e espaços. NÃO ultrapasse 300 caracteres), incluindo:
               - Tags de cauda curta (1-2 palavras): termos populares e competitivos relacionados ao título "${selectedTitle}" e subnicho "${subniche}"
               - Tags de cauda longa (3-5 palavras): termos mais específicos e menos competitivos que capturam intenção de busca
               - Tags de nicho: termos específicos do subnicho "${subniche}"
               - Tags de tendência: termos que estão em alta no momento relacionados ao tema
               - Tags de formato: termos como "tutorial", "dicas", "como fazer", "guia completo", "passo a passo", etc.
               - Tags de plataforma: termos relacionados à plataforma (YouTube, TikTok, Instagram, etc.)
               - Tags de emoção: termos que capturam a emoção do título (ex: "surpresa", "revelação", "mistério", "urgência", "choque")
               - Tags de benefício: termos que descrevem o que o espectador vai ganhar/aprender
               - Tags de palavra-chave principal: extrair as palavras-chave mais importantes do título "${selectedTitle}"
               - Tags de sinônimos: variações e sinônimos das palavras-chave principais
               - IMPORTANTE: As tags devem ser EXTREMAMENTE RELEVANTES ao título "${selectedTitle}" e ao subnicho "${subniche}"
               - Evite tags genéricas que não agregam valor
               - Priorize tags que tenham volume de busca mas não sejam extremamente competitivas
               - Misture tags em português/inglês/espanhol conforme o idioma "${language}"
               - LIMITE MÁXIMO: 300 caracteres no total (incluindo vírgulas e espaços). NÃO ultrapasse 300 caracteres.
               - Cada tag deve ter entre 1-5 palavras, sendo a maioria com 2-3 palavras para otimizar o uso do espaço
               - Priorize tags mais relevantes e estratégicas. Se necessário, reduza a quantidade de tags para não ultrapassar 300 caracteres.
            3.  **"frasesDeGancho"**: Um array com 5 frases CURTAS de impacto (ganchos) para a thumbnail, OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne um array vazio [].' : `
                ⚠️⚠️⚠️ CRÍTICO E OBRIGATÓRIO - IDIOMA DAS FRASES DE GANCHO ⚠️⚠️⚠️
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Português' ? `
                ✅ CORRETO (Português): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : language === 'Inglês' ? `
                ✅ CORRETO (Inglês): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : `
                ✅ CORRETO (Espanhol): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante", "La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGATÓRIAS:
                1. Se "${language}" for "Português", TODAS as 5 frases DEVEM estar em PORTUGUÊS (Brasil)
                2. Se "${language}" for "Inglês", TODAS as 5 frases DEVEM estar em INGLÊS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em inglês se o idioma escolhido for português ou espanhol
                5. NUNCA, JAMAIS retorne frases em português se o idioma escolhido for inglês ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for português ou inglês
                7. Cada frase deve ter 2 a 4 palavras, no máximo
                8. As frases devem ser impactantes e relacionadas ao título "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases estão no idioma "${language}"?
                - Nenhuma frase está em inglês se "${language}" for português ou espanhol?
                - Nenhuma frase está em português se "${language}" for inglês ou espanhol?
                - Nenhuma frase está em espanhol se "${language}" for português ou inglês?
                
                Se alguma resposta for NÃO, CORRIJA as frases antes de retornar o JSON.
                `}
            4.  **"descricaoThumbnail"**: Um prompt EXTREMAMENTE DETALHADO e VÍVIDO, em INGLÊS, para uma IA de geração de imagem. ${!includePhrases ? 'NÃO inclua nenhum placeholder para texto. A thumbnail deve ser APENAS imagem, sem texto ou frases de gancho. Descreva apenas elementos visuais, composição, cores, iluminação, etc.' : 'A descrição DEVE incluir OBRIGATORIAMENTE o placeholder exato "[FRASE DE GANCHO AQUI]" em algum lugar da descrição, onde o texto da thumbnail será inserido. CRÍTICO: O placeholder "[FRASE DE GANCHO AQUI]" DEVE aparecer literalmente na descrição. Quando mencionar o texto, descreva-o como se fosse criado no Photoshop por um designer profissional: use termos como "Professional Photoshop-quality text design displaying [FRASE DE GANCHO AQUI]", "professional layer effects", "Photoshop stroke effect", "professional drop shadow with specific values (distance, spread, size, opacity, angle)", "professional outer glow", "professional bevel and emboss", "professional typography with perfect kerning", "professional text rendering with anti-aliasing", "looks like it was designed by a professional graphic designer". O texto DEVE ter múltiplos efeitos de camada do Photoshop com valores específicos, não apenas descrições genéricas. Fonte estilizada profissional, grande e impactante, cores vibrantes e contrastantes, efeitos visuais profissionais (sombra com valores específicos, brilho, outline, gradiente), posicionamento estratégico, tamanho grande que ocupa 25-35% da imagem. IMPORTANTE: Sempre inclua o texto "[FRASE DE GANCHO AQUI]" literalmente na descrição, por exemplo: "with professional text design displaying [FRASE DE GANCHO AQUI]" ou "featuring large bold text that says [FRASE DE GANCHO AQUI]".'}
            
            CRÍTICO PARA A "descricaoThumbnail" - DEVE SER FOTOGRAFIA REAL ULTRA HD 8K, NÃO ILUSTRAÇÃO:
            - OBRIGATÓRIO: A descrição DEVE começar EXATAMENTE com: "Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, real lighting, real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, 8K resolution, extreme sharpness, maximum detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography quality"
            
            - ENFATIZE REPETIDAMENTE E OBRIGATORIAMENTE: "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail", "every pore visible", "every texture crisp", "perfect focus", "ultra sharp", "no blur except intentional depth of field", "no artifacts", "no compression", "no pixelation", "perfect clarity", "real photograph", "shot on location", "documentary photography", "realistic textures with imperfections", "natural lighting with real shadows", "real depth of field", "real bokeh effects", "professional color grading", "high dynamic range (HDR)", "sharp focus on subject", "real camera grain", "real-world photography", "actual photograph", "photographed in real life", "real person", "real object", "real environment", "National Geographic quality", "BBC documentary style", "professional photography", "photorealistic", "hyper-realistic"
            
            - NUNCA, JAMAIS use estes termos: "illustration", "drawing", "artwork", "digital art", "render", "3D render", "CGI", "cartoon", "anime", "sketch", "painting", "stylized", "artistic", "concept art", "digital painting", "graphic design", "vector", "comic", "fantasy art", "artistic interpretation", "stylized", "artistic style", "digital illustration"
            
            - SEMPRE use APENAS estes termos: "photograph", "photo", "photography", "shot", "captured", "documentary photo", "realistic capture", "professional photography", "real-world photography", "actual photograph", "photographed", "real-life photography", "on-location photography", "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail"
            
            - IMPORTANTE: Descreva como se fosse uma FOTO REAL ULTRA HD 8K tirada por um fotógrafo profissional. Mencione detalhes realistas como: "real skin texture with pores and natural imperfections visible in 8K detail", "real fabric texture with visible fibers and weave patterns in ultra HD", "real stone texture with weathering, cracks, and imperfections visible in perfect 8K clarity", "real shadows cast by real light sources with perfect sharpness", "real depth of field blur with perfect bokeh", "real camera lens distortion", "real chromatic aberration", "real lens flare", "real motion blur if applicable", "every detail visible in 8K resolution", "extreme sharpness and clarity", "no compression artifacts", "perfect focus on subject"

            REGRAS IMPORTANTES:
            - A "descricaoThumbnail" é OBRIGATORIAMENTE em INGLÊS.
            - "seoDescription", "seoTags" e "frasesDeGancho" são OBRIGATORIAMENTE no idioma "${language}".
            ${!includePhrases ? '- IMPORTANTE: A "descricaoThumbnail" NÃO deve mencionar texto, palavras ou frases. Apenas descreva elementos visuais, composição, cores, iluminação, etc.' : ''}
            - Seja extremamente específico e detalhado nas descrições visuais. Use termos técnicos de fotografia profissional, cinematografia e psicologia visual quando apropriado.
            - Foque em elementos que maximizem CTR: expressões faciais intensas, momentos de tensão, curiosidade visual, contraste dramático, composição impactante.
            
            EXEMPLOS DE COMO DESCREVER PARA GARANTIR REALISMO:
            - Em vez de "um guerreiro maia", escreva: "a real person dressed as a Mayan warrior, photographed on location, real skin texture with pores and natural imperfections, real fabric of the costume with visible texture and wrinkles, real feathers in the headdress with natural variations"
            - Em vez de "uma pirâmide antiga", escreva: "a real ancient Mayan pyramid photographed on location, real weathered stone with cracks and imperfections, real moss and vegetation growing on the stones, real shadows cast by the sun, real depth of field blur in the background"
            - Em vez de "luz mística", escreva: "real natural lighting from the sun, real shadows cast by real objects, real depth of field, real bokeh in the background, real camera lens flare if the sun is in frame"
            - SEMPRE mencione: "real", "actual", "photographed", "shot on location", "documentary style", "real-world", "actual photograph"
            
            TÉCNICAS DE THUMBNAIL VIRAL PARA O TEXTO (quando includePhrases = true) - DESIGN PROFISSIONAL COMO PHOTOSHOP - CTR ACIMA DE 25%:
            
            📝 DESCRIÇÃO OBRIGATÓRIA DO TEXTO - DEVE PARECER FEITO NO PHOTOSHOP POR UM DESIGNER PROFISSIONAL:
            O texto DEVE ser descrito como se fosse criado no Photoshop com técnicas profissionais de design gráfico:
            
            1. TIPOGRAFIA PROFISSIONAL:
               - "Professional typography, Photoshop-quality text design"
               - "Large, bold, professionally designed text occupying 25-35% of the image height"
               - "Massive, oversized typography with professional letter spacing and kerning"
               - "Thick, chunky, professionally rendered letters"
               - "Typography that looks like it was designed by a professional graphic designer"
               - "High-end text design, magazine-quality typography"
            
            2. CORES PROFISSIONAIS E EFEITOS DE CAMADA (Layer Effects do Photoshop):
               - "Bright yellow (#FFD700) text with professional Photoshop layer effects: thick black stroke (6-8px), white drop shadow with distance 8px, spread 5px, size 12px, opacity 80%, angle 135 degrees"
               - "Pure white text with professional red stroke (6px), black drop shadow with blur radius 10px, and subtle outer glow effect in yellow"
               - "Neon orange (#FF6600) text with black stroke (7px), professional drop shadow with multiple layers, and yellow outer glow with spread 8px"
               - "Electric blue (#00FFFF) text with white stroke (6px), black shadow with distance 10px, and professional bevel and emboss effect"
               - "Bright red (#FF0000) text with yellow stroke (5px), white drop shadow, and professional gradient overlay from yellow to orange"
               - "Lime green (#00FF00) text with black stroke (8px), white glow effect, and professional inner shadow"
               - IMPORTANTE: Descreva como efeitos de camada do Photoshop (layer effects), não apenas "outline" ou "shadow"
               
               🏆 ESTILO ÉPICO - TEXTOS EM DOURADO (Para thumbnails históricas/épicas):
               - Se a thumbnail original usar textos em dourado, DESCREVA EXATAMENTE assim:
               - "Large, bold, ornate serif font text in golden yellow (#FFD700) with professional Photoshop layer effects: thick black stroke (8-10px width, position outside), professional bevel and emboss effect (style: emboss, technique: smooth, depth 150%, size 8px, softness 3px, highlight mode: screen with opacity 75%, shadow mode: multiply with opacity 50%), white drop shadow (distance 12px, spread 6px, size 15px, opacity 85%, angle 135°), subtle outer glow in golden yellow (spread 10px, size 20px, opacity 60%), positioned at the bottom center of the image, occupying 30-35% of the image height, professional ornate serif typography (Trajan Pro, Cinzel, or similar historical/regal font style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, looks like it was designed by a professional graphic designer for a historical epic movie poster"
               - "Golden embossed text with metallic finish, professional 3D effect, regal and majestic appearance, historical epic typography style"
            
            3. FONTES PROFISSIONAIS:
               - "Professional bold sans-serif font (Impact, Bebas Neue, Montserrat Black, or similar premium font)"
               - "Thick, chunky, professionally designed block letters"
               - "Modern, high-end typography with perfect letter spacing"
               - "YouTube viral thumbnail professional font style"
               - "Bold, condensed font with professional kerning and tracking"
               - "Premium typography, no serifs, maximum readability, professional design"
               - "Typography that looks like it came from a professional design agency"
            
            4. EFEITOS PROFISSIONAIS DO PHOTOSHOP (Layer Styles):
               - "Professional Photoshop stroke effect: thick black outline (6-8px width), position: outside, blend mode: normal, opacity: 100%"
               - "Professional drop shadow: distance 10px, spread 5px, size 12px, angle 135°, opacity 80%, color black, blend mode: multiply"
               - "Professional outer glow effect: spread 8px, size 15px, opacity 75%, color matching text or contrasting"
               - "Professional bevel and emboss effect: style: emboss, technique: smooth, depth 100%, size 5px, softness 2px"
               - "Professional gradient overlay: linear gradient from bright color to darker shade, angle 90°, opacity 80%"
               - "Professional inner shadow: distance 3px, choke 0%, size 5px, opacity 60%"
               - "Professional color overlay: solid color with blend mode overlay or soft light, opacity 50%"
               - "Text appears to pop out from the image with professional 3D effect"
               - "Professional text rendering with anti-aliasing, crisp edges, perfect clarity"
            
            5. COMPOSIÇÃO PROFISSIONAL:
               - "Positioned at the top center of the image with professional alignment"
               - "Bottom third of the image with professional composition and high contrast background"
               - "Centered horizontally, upper third vertically, following rule of thirds"
               - "Strategically placed to not cover important visual elements, professional layout"
               - "Text area has professional semi-transparent dark background (black overlay with 40% opacity) for better readability"
               - "Professional text box or banner behind text with gradient or solid color, rounded corners optional"
            
            6. CONTRASTE E VISIBILIDADE PROFISSIONAL:
               - "High contrast against the background, professionally optimized"
               - "Text stands out dramatically from the image with professional design techniques"
               - "Eye-catching text overlay that immediately draws attention, professional composition"
               - "Text that pops from the image with maximum visibility, professional rendering"
               - "Text is the first thing the eye is drawn to, professional visual hierarchy"
               - "Background is professionally darkened (vignette effect) or lightened behind text for maximum contrast"
               - "Professional color grading applied to background to make text stand out"
            
            7. EXEMPLO COMPLETO DE DESCRIÇÃO PROFISSIONAL:
               "Professional Photoshop-quality text design: Large, bold, stylized text '[FRASE DE GANCHO AQUI]' in bright yellow (#FFD700) with professional layer effects: thick black stroke (7px width, position outside), white drop shadow (distance 10px, spread 5px, size 12px, opacity 80%, angle 135°), subtle outer glow in white (spread 6px, size 10px, opacity 70%), positioned at the top center of the image, occupying 30% of the image height, professional bold sans-serif font (Impact or Bebas Neue style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, high contrast viral thumbnail text style, eye-catching and attention-grabbing, text appears to pop out from the image with professional 3D effect, maximum visibility for high CTR, looks like it was designed by a professional graphic designer in Photoshop"
            
            8. REGRAS DE OURO PARA DESIGN PROFISSIONAL:
               - O texto DEVE parecer feito no Photoshop por um designer profissional
               - O texto DEVE ter múltiplos efeitos de camada (stroke, shadow, glow, bevel)
               - O texto DEVE ter valores específicos de efeitos (distância, spread, tamanho, opacidade)
               - O texto DEVE ter tipografia profissional com kerning e tracking perfeitos
               - O texto DEVE ter renderização profissional (anti-aliasing, crisp edges)
               - O texto DEVE ter composição profissional (regra dos terços, hierarquia visual)
               - O texto DEVE parecer de qualidade de agência de design, não amador

            RESPONDA APENAS COM UM OBJETO JSON VÁLIDO, com a seguinte estrutura:
            {
              "ideias": [
                {
                  "seoDescription": "Descrição completa e otimizada para o YouTube aqui...",
                  "seoTags": ["tag1", "tag2", "tag3", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"]' : language === 'Inglês' ? '["He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"]' : '["Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'A detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'A detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                },
                {
                  "seoDescription": "Outra descrição completa e otimizada...",
                  "seoTags": ["tagA", "tagB", "tagC", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"]' : language === 'Inglês' ? '["The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything", "Surprising Revelation"]' : '["La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'Another detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'Another detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                }
              ]
            }
        `;
            } else { // OpenAI
                thumbPrompt = `
            Você é um especialista em YouTube, combinando as habilidades de um diretor de arte para thumbnails e um mestre de SEO.${formulaContext}

            IMAGEM DE REFERÊNCIA: [A imagem da thumbnail original do vídeo está anexada]
            TÍTULO DO VÍDEO (para contexto): "${selectedTitle}"
            SUBNICHE (Público-Alvo): "${subniche}"
            ESTILO DE ARTE DESEJADO: "${style}"
            IDIOMA DO CONTEÚDO: "${language}"

            ⚠️ ATENÇÃO CRÍTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, não ilustrações, desenhos ou renderizações. A descriçãoThumbnail deve descrever uma FOTO REAL tirada por um fotógrafo profissional em um local real, com pessoas reais e objetos reais.
            
            🎨 IDENTIFICAÇÃO E REPLICAÇÃO DE ESTILOS ÉPICOS/CINEMATOGRÁFICOS:
            
            Analise a IMAGEM DE REFERÊNCIA e identifique qual estilo visual ela utiliza. Se identificar algum dos estilos abaixo, REPLIQUE-O FIELMENTE na IDEIA 1, apenas melhorando a qualidade:
            
            📐 ESTILO 1: COMPOSIÇÃO DIVIDIDA (ESQUERDA/DIREITA):
            - Imagem dividida verticalmente em duas metades contrastantes
            - Lado esquerdo: geralmente cenas de paz/grandiosidade (cidades antigas, paisagens douradas, céu claro)
            - Lado direito: geralmente cenas de conflito/ameaça (tempestades, navios, exércitos, céu escuro)
            - Figura central ou próxima ao centro conectando os dois lados
            - Contraste dramático entre luz (esquerda) e escuridão (direita)
            - Texto grande em dourado (#FFD700) na parte inferior, fonte serifada ornamentada com efeito emboss/bevel
            - Exemplos: Atahualpa (cidade dourada vs navios tempestuosos), Malinche (mapa vs batalha naval)
            
            📐 ESTILO 2: CLOSE-UP DRAMÁTICO COM BACKGROUND ÉPICO:
            - Figura histórica em close-up ocupando 40-60% da imagem (rosto e parte superior do corpo)
            - Expressão intensa e direta para a câmera
            - Background dividido ou com elementos épicos (pirâmides, navios, batalhas, fogo)
            - Iluminação dramática com chiaroscuro (luz forte vs sombras profundas)
            - Texto grande em dourado na parte inferior
            - Exemplos: Faraó com pirâmides ao fundo, líder indígena com cidade antiga
            
            📐 ESTILO 3: CENA ÉPICA COM ELEMENTOS DE DESTRUIÇÃO:
            - Cena de batalha ou conflito histórico
            - Elementos de fogo, fumaça, tempestades
            - Navios em chamas, exércitos, destruição
            - Céu tempestuoso com nuvens escuras
            - Figuras em primeiro plano com expressões dramáticas
            - Texto grande em dourado/amarelo com outline preto
            - Exemplos: Batalhas navais, conquistas, segredos dos faraós
            
            📐 ESTILO 4: FIGURA HISTÓRICA COM ELEMENTOS SIMBÓLICOS:
            - Figura histórica em destaque (faraó, líder, conquistador)
            - Trajes elaborados e autênticos (coroas, armaduras, roupas tradicionais)
            - Elementos simbólicos ao redor (pirâmides, navios, mapas, hieróglifos)
            - Composição vertical ou horizontal com figura dominante
            - Texto grande em dourado com fonte serifada ornamentada
            - Exemplos: Faraó com pirâmides, líder indígena com coroa elaborada
            
            ⚠️ REGRAS PARA REPLICAÇÃO FIEL:
            1. Se a thumbnail original usar COMPOSIÇÃO DIVIDIDA, mantenha EXATAMENTE essa estrutura (mesma divisão, mesmo contraste, mesma posição dos elementos)
            2. Se a thumbnail original usar CLOSE-UP DRAMÁTICO, mantenha o mesmo enquadramento e proporção da figura
            3. Se a thumbnail original usar TEXTOS EM DOURADO, mantenha a mesma cor (#FFD700), fonte serifada e efeitos (emboss, bevel, glow)
            4. Se a thumbnail original usar ELEMENTOS ÉPICOS (pirâmides, navios, fogo), mantenha os mesmos elementos na mesma posição
            5. Se a thumbnail original usar CONTRASTE LUZ/ESQUERIDÃO, mantenha o mesmo esquema de iluminação
            6. Se a thumbnail original usar FIGURAS HISTÓRICAS, mantenha o mesmo tipo de figura, trajes e expressão
            7. Apenas MELHORE: nitidez 8K, contraste mais forte, cores mais saturadas, iluminação mais dramática, texto com efeitos Photoshop mais refinados
            
            ${(() => {
                const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
                if (ruleData.mode === 'auto') {
                    return `\n            🔍 MODO AUTOMÁTICO - ANÁLISE DE REGRA:\n            Analise o título "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPLÍCITA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.\n\n            📋 AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE (ALGORITMO OFICIAL):\n\n            1️⃣ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO):\n            O cérebro precisa entender a thumbnail em menos de 1 segundo. Se houver confusão, o clique cai.\n            Checklist OBRIGATÓRIO: 1 ideia principal, 1 personagem, 1 emoção, 1 objeto-chave.\n            A thumbnail DEVE ser compreendida instantaneamente. Elimine qualquer elemento que cause confusão ou distração.\n\n            2️⃣ REGRA DO ASSUNTO ÚNICO:\n            Nada divide a atenção. A thumbnail boa é sempre uma história em uma imagem.\n            Foque em UM ÚNICO assunto dominante. Nada deve competir pela atenção. A thumbnail deve contar uma história completa em uma única imagem, sem elementos que dividam o foco.\n\n            3️⃣ REGRA DO ROSTO GRANDE:\n            Rostos com forte expressão emocional aumentam CTR de 20% a 60%.\n            Expressões mais fortes: choque, surpresa, medo, raiva, felicidade extrema.\n            Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A expressão facial DEVE ser EXTREMA e EMOCIONAL. O rosto deve ser o elemento dominante e a primeira coisa que o olho vê.\n\n            4️⃣ REGRA DO CONTRASTE BRUTAL:\n            Se não tiver contraste, a thumbnail fica invisível.\n            Use CONTRASTE BRUTAL entre: texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n            O contraste deve ser tão forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.\n\n            5️⃣ REGRA DA COR ESTRATÉGICA:\n            Cada cor ativa um gatilho:\n            - Amarelo: atenção imediata\n            - Vermelho: urgência / perigo\n            - Azul: confiança\n            - Verde: dinheiro / solução\n            - Preto: premium / mistério\n            Escolha a cor baseada na emoção que o título transmite.\n\n            6️⃣ REGRA DOS TERÇOS:\n            Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso dá harmonia e aumenta o foco natural.\n            Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos terços (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.\n\n            7️⃣ REGRA DO TEXTO ULTRA CURTO:\n            Texto deve ter 2 a 4 palavras, nunca mais.\n            Exemplos: "Ele mentiu", "Descobri isso", "Ninguém viu", "Proibido".\n            O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Textos longos matam o CTR. Seja brutalmente direto e impactante.\n\n            8️⃣ REGRA DO ZOOM EMOCIONAL:\n            Aparece sempre um elemento gigante que amplifica a emoção ou o conflito.\n            Exemplos: uma conta bancária gigante, uma faca gigante, uma lupa gigante, um número gigante.\n            Use um elemento GIGANTE que amplifique a emoção ou conflito. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.\n\n            9️⃣ REGRA DO MISTÉRIO:\n            Toda thumbnail viral tem uma pergunta implícita.\n            Exemplos: algo escondido atrás de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela.\n            Crie uma pergunta implícita na thumbnail. O espectador DEVE sentir curiosidade sobre o que está fora da imagem.\n\n            🔟 REGRA DOS PONTOS DE FUGA:\n            Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.\n            Sinalizações: setas, linhas diagonais, perspectiva.\n            Use linhas visuais que guiem o olhar para o foco. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal.\n\n            1️⃣1️⃣ REGRA DO ESPAÇO NEGATIVO:\n            Deixar áreas vazias acentua o foco. Sem isso, a imagem vira bagunça.\n            Deixe áreas vazias (espaço negativo) que acentuem o foco no elemento principal. O espaço vazio cria respiração visual e faz o elemento principal "pular" da imagem.\n\n            1️⃣2️⃣ REGRA DA COERÊNCIA COM O TÍTULO:\n            Thumbnail e título precisam contar a mesma história, mas com ângulos diferentes.\n            Título = contexto, Thumbnail = emoção.\n            A thumbnail e o título DEVEM contar a mesma história, mas com ângulos diferentes. A thumbnail deve amplificar a emoção que o título promete, criando uma sinergia perfeita.\n\n            ⚠️ CRÍTICO: Identifique qual regra melhor se encaixa no título "${selectedTitle}" e aplique-a de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.`;
                } else {
                    return `\n            📋 REGRA SELECIONADA: ${ruleData.rule.name}\n            ${ruleData.rule.description}\n\n            ${ruleData.rule.checklist ? `✅ Checklist: ${ruleData.rule.checklist.join(', ')}` : ''}\n            ${ruleData.rule.expressions ? `😮 Expressões recomendadas: ${ruleData.rule.expressions.join(', ')}` : ''}\n            ${ruleData.rule.contrasts ? `🎨 Contrastes: ${ruleData.rule.contrasts.join(', ')}` : ''}\n            ${ruleData.rule.colors ? `🌈 Cores estratégicas: ${Object.entries(ruleData.rule.colors).map(([k, v]) => `${k} (${v})`).join(', ')}` : ''}\n            ${ruleData.rule.examples ? `💡 Exemplos: ${ruleData.rule.examples.join(', ')}` : ''}\n            ${ruleData.rule.elements ? `➡️ Elementos: ${ruleData.rule.elements.join(', ')}` : ''}\n\n            ⚠️ CRÍTICO: Aplique esta regra de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail:\n            ${ruleData.instructions}`;
                }
            })()}
            
            🎯 OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando técnicas de Thumbnail Designer profissional:
            - TEXTO PROFISSIONAL (COMO PHOTOSHOP): O texto DEVE parecer feito no Photoshop por um designer profissional. Use múltiplos efeitos de camada (stroke, drop shadow com valores específicos, outer glow, bevel and emboss), tipografia profissional com kerning perfeito, renderização profissional com anti-aliasing. Grande, estilizado, cores vibrantes (amarelo/vermelho/branco com outline preto), efeitos visuais profissionais com valores específicos (distância, spread, tamanho, opacidade, ângulo), posicionamento estratégico (topo/centro), ocupando 25-35% da imagem. O texto DEVE ter qualidade de agência de design, não amador.
            - COMPOSIÇÃO: Regra dos terços, hierarquia visual clara, elemento principal em destaque
            - CORES: Alto contraste, cores complementares, saturação otimizada, fundo que faz o texto "pular"
            - EMOÇÃO: Expressões faciais intensas, momentos de tensão, curiosidade visual
            - ELEMENTOS VIRAIS: FOMO (medo de perder), surpresa, contraste dramático, storytelling visual
            
            SUA TAREFA (OTIMIZADA PARA VIRALIZAÇÃO - GPT):
            Analise a thumbnail VIRAL de referência (IMAGEM DE REFERÊNCIA anexada) e crie DUAS (2) adaptações que mantenham o PODER VIRAL original, mas adaptadas para o subnicho "${subniche}" e o título "${selectedTitle}".
            
            ⚠️⚠️⚠️ CRÍTICO - ORDEM DAS IDEIAS ⚠️⚠️⚠️
            - **IDEIA 1 (RÉPLICA E MELHORIA DA THUMBNAIL ORIGINAL DO VÍDEO):** 
              * OBRIGATÓRIO: Esta ideia DEVE replicar e melhorar a thumbnail ORIGINAL do vídeo ao qual foram feitos os títulos.
              * Analise cuidadosamente a IMAGEM DE REFERÊNCIA (thumbnail original do vídeo) que está anexada.
              * Replique a estrutura da thumbnail de referência quase 1:1: mantenha EXATAMENTE ângulo de câmera, enquadramento, posição dos personagens/objetos, quantidade e posição do texto, paleta de cores e elementos de cenário.
              * PRESERVE exatamente o storytelling visual da thumbnail original que gerou milhões de views, apenas elevando a qualidade (recortes perfeitos, tratamento de pele profissional, brilho nos olhos, textura realista, correção de cor cinematográfica).
              * Ajustes permitidos: aumentar nitidez (8K), reforçar contraste, limpar ruídos, adicionar luzes/sombras profissionais e aplicar efeitos de texto Photoshop com valores específicos (stroke, drop shadow, outer glow, bevel & emboss).
              * Resultado: praticamente igual à thumb original, mas com sensação de upgrade premium e leitura instantânea mais clara e clicável.
              * IMPORTANTE: Se a thumbnail original não estiver disponível ou não puder ser analisada, ainda assim mantenha o mesmo conceito visual e estrutura, apenas melhorando a qualidade.
            
            - **IDEIA 2 (THUMBNAIL MELHORADA E OTIMIZADA):** 
              * Esta é uma versão COMPLETAMENTE NOVA, melhorada e otimizada para CTR alto (30%+).
              * Crie um conceito totalmente novo com foco em CTR máximo: novo enquadramento, nova composição, novos elementos que gerem curiosidade extrema.
              * Use gatilhos agressivos (perigo, segredo revelado, números gigantes, setas, antes/depois, close dramático) e cores super contrastantes.
              * Construa um storytelling diferente, alinhado ao título "${selectedTitle}", que prometa algo ainda mais irresistível que a versão original.
              * O texto deve ser redesenhado para máxima legibilidade mobile, com layer styles profissionais e valores precisos.
              * Objetivo: criar uma thumbnail inédita que pareça "campanha de performance", otimizada para CTR alto e retenção visual imediata.
              * Esta versão deve ser AINDA MELHOR que a original, com técnicas avançadas de viralização.

            PARA CADA UMA DAS 2 IDEIAS, GERE:
            1.  **"seoDescription"**: Uma descrição de vídeo para o YouTube, EXTREMAMENTE OTIMIZADA PARA SEO E VIRALIZAÇÃO, com:
               - Emojis estratégicos e relevantes (use emojis que representem o nicho e subnicho)
               - Parágrafos bem estruturados com quebras de linha
               - Chamadas para ação (CTA) claras e persuasivas
               - Uso estratégico de palavras-chave relevantes para o título "${selectedTitle}" e subnicho "${subniche}"
               - Formatação profissional com separadores visuais (━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━)
               - Seções organizadas: introdução, conteúdo do vídeo, sobre o canal, links importantes, hashtags
               - Linguagem persuasiva e envolvente que gere curiosidade e urgência
               - A descrição deve estar no idioma "${language}" e ter entre 300-500 palavras
               - IMPORTANTE: Use emojis de forma estratégica (não exagere, mas use para destacar seções importantes)
               - Inclua hashtags relevantes no final
               - Seja específico sobre o que o espectador vai aprender/ganhar
               
            2.  **"seoTags"**: Um array de strings com as 15-25 tags MAIS RELEVANTES E ESTRATÉGICAS para o vídeo (LIMITE MÁXIMO: 300 caracteres no total, incluindo vírgulas e espaços. NÃO ultrapasse 300 caracteres), incluindo:
               - Tags de cauda curta (1-2 palavras): termos populares e competitivos relacionados ao título "${selectedTitle}" e subnicho "${subniche}"
               - Tags de cauda longa (3-5 palavras): termos mais específicos e menos competitivos que capturam intenção de busca
               - Tags de nicho: termos específicos do subnicho "${subniche}"
               - Tags de tendência: termos que estão em alta no momento relacionados ao tema
               - Tags de formato: termos como "tutorial", "dicas", "como fazer", "guia completo", "passo a passo", etc.
               - Tags de plataforma: termos relacionados à plataforma (YouTube, TikTok, Instagram, etc.)
               - Tags de emoção: termos que capturam a emoção do título (ex: "surpresa", "revelação", "mistério", "urgência", "choque")
               - Tags de benefício: termos que descrevem o que o espectador vai ganhar/aprender
               - Tags de palavra-chave principal: extrair as palavras-chave mais importantes do título "${selectedTitle}"
               - Tags de sinônimos: variações e sinônimos das palavras-chave principais
               - IMPORTANTE: As tags devem ser EXTREMAMENTE RELEVANTES ao título "${selectedTitle}" e ao subnicho "${subniche}"
               - Evite tags genéricas que não agregam valor
               - Priorize tags que tenham volume de busca mas não sejam extremamente competitivas
               - Misture tags em português/inglês/espanhol conforme o idioma "${language}"
               - LIMITE MÁXIMO: 300 caracteres no total (incluindo vírgulas e espaços). NÃO ultrapasse 300 caracteres.
               - Cada tag deve ter entre 1-5 palavras, sendo a maioria com 2-3 palavras para otimizar o uso do espaço
               - Priorize tags mais relevantes e estratégicas. Se necessário, reduza a quantidade de tags para não ultrapassar 300 caracteres.
            3.  **"frasesDeGancho"**: Um array com 5 frases CURTAS de impacto (ganchos) para a thumbnail, OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne um array vazio [].' : `
                ⚠️⚠️⚠️ CRÍTICO E OBRIGATÓRIO - IDIOMA DAS FRASES DE GANCHO ⚠️⚠️⚠️
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Português' ? `
                ✅ CORRETO (Português): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : language === 'Inglês' ? `
                ✅ CORRETO (Inglês): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : `
                ✅ CORRETO (Espanhol): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante", "La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGATÓRIAS:
                1. Se "${language}" for "Português", TODAS as 5 frases DEVEM estar em PORTUGUÊS (Brasil)
                2. Se "${language}" for "Inglês", TODAS as 5 frases DEVEM estar em INGLÊS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em inglês se o idioma escolhido for português ou espanhol
                5. NUNCA, JAMAIS retorne frases em português se o idioma escolhido for inglês ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for português ou inglês
                7. Cada frase deve ter 2 a 4 palavras, no máximo
                8. As frases devem ser impactantes e relacionadas ao título "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases estão no idioma "${language}"?
                - Nenhuma frase está em inglês se "${language}" for português ou espanhol?
                - Nenhuma frase está em português se "${language}" for inglês ou espanhol?
                - Nenhuma frase está em espanhol se "${language}" for português ou inglês?
                
                Se alguma resposta for NÃO, CORRIJA as frases antes de retornar o JSON.
                `}
            4.  **"descricaoThumbnail"**: Um prompt EXTREMAMENTE DETALHADO e VÍVIDO, em INGLÊS, para uma IA de geração de imagem. ${!includePhrases ? 'NÃO inclua nenhum placeholder para texto. A thumbnail deve ser APENAS imagem, sem texto ou frases de gancho. Descreva apenas elementos visuais, composição, cores, iluminação, etc.' : 'A descrição DEVE incluir OBRIGATORIAMENTE o placeholder exato "[FRASE DE GANCHO AQUI]" em algum lugar da descrição, onde o texto da thumbnail será inserido. CRÍTICO: O placeholder "[FRASE DE GANCHO AQUI]" DEVE aparecer literalmente na descrição. Quando mencionar o texto, descreva-o como se fosse criado no Photoshop por um designer profissional: use termos como "Professional Photoshop-quality text design displaying [FRASE DE GANCHO AQUI]", "professional layer effects", "Photoshop stroke effect", "professional drop shadow with specific values (distance, spread, size, opacity, angle)", "professional outer glow", "professional bevel and emboss", "professional typography with perfect kerning", "professional text rendering with anti-aliasing", "looks like it was designed by a professional graphic designer". O texto DEVE ter múltiplos efeitos de camada do Photoshop com valores específicos, não apenas descrições genéricas. Fonte estilizada profissional, grande e impactante, cores vibrantes e contrastantes, efeitos visuais profissionais (sombra com valores específicos, brilho, outline, gradiente), posicionamento estratégico, tamanho grande que ocupa 25-35% da imagem. IMPORTANTE: Sempre inclua o texto "[FRASE DE GANCHO AQUI]" literalmente na descrição, por exemplo: "with professional text design displaying [FRASE DE GANCHO AQUI]" ou "featuring large bold text that says [FRASE DE GANCHO AQUI]".'}
            
            CRÍTICO PARA A "descricaoThumbnail" - DEVE SER FOTOGRAFIA REAL ULTRA HD 8K, NÃO ILUSTRAÇÃO:
            - OBRIGATÓRIO: A descrição DEVE começar EXATAMENTE com: "Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, real lighting, real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, 8K resolution, extreme sharpness, maximum detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography quality"
            
            - ENFATIZE REPETIDAMENTE E OBRIGATORIAMENTE: "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail", "every pore visible", "every texture crisp", "perfect focus", "ultra sharp", "no blur except intentional depth of field", "no artifacts", "no compression", "no pixelation", "perfect clarity", "real photograph", "shot on location", "documentary photography", "realistic textures with imperfections", "natural lighting with real shadows", "real depth of field", "real bokeh effects", "professional color grading", "high dynamic range (HDR)", "sharp focus on subject", "real camera grain", "real-world photography", "actual photograph", "photographed in real life", "real person", "real object", "real environment", "National Geographic quality", "BBC documentary style", "professional photography", "photorealistic", "hyper-realistic"
            
            - NUNCA, JAMAIS use estes termos: "illustration", "drawing", "artwork", "digital art", "render", "3D render", "CGI", "cartoon", "anime", "sketch", "painting", "stylized", "artistic", "concept art", "digital painting", "graphic design", "vector", "comic", "fantasy art", "artistic interpretation", "stylized", "artistic style", "digital illustration"
            
            - SEMPRE use APENAS estes termos: "photograph", "photo", "photography", "shot", "captured", "documentary photo", "realistic capture", "professional photography", "real-world photography", "actual photograph", "photographed", "real-life photography", "on-location photography", "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail"
            
            - IMPORTANTE: Descreva como se fosse uma FOTO REAL ULTRA HD 8K tirada por um fotógrafo profissional. Mencione detalhes realistas como: "real skin texture with pores and natural imperfections visible in 8K detail", "real fabric texture with visible fibers and weave patterns in ultra HD", "real stone texture with weathering, cracks, and imperfections visible in perfect 8K clarity", "real shadows cast by real light sources with perfect sharpness", "real depth of field blur with perfect bokeh", "real camera lens distortion", "real chromatic aberration", "real lens flare", "real motion blur if applicable", "every detail visible in 8K resolution", "extreme sharpness and clarity", "no compression artifacts", "perfect focus on subject"

            REGRAS IMPORTANTES:
            - A "descricaoThumbnail" é OBRIGATORIAMENTE em INGLÊS.
            - "seoDescription", "seoTags" e "frasesDeGancho" são OBRIGATORIAMENTE no idioma "${language}".
            ${!includePhrases ? '- IMPORTANTE: A "descricaoThumbnail" NÃO deve mencionar texto, palavras ou frases. Apenas descreva elementos visuais, composição, cores, iluminação, etc.' : ''}
            - Seja extremamente específico e detalhado nas descrições visuais. Use termos técnicos de fotografia profissional, cinematografia e psicologia visual quando apropriado.
            - Foque em elementos que maximizem CTR: expressões faciais intensas, momentos de tensão, curiosidade visual, contraste dramático, composição impactante.
            
            EXEMPLOS DE COMO DESCREVER PARA GARANTIR REALISMO:
            - Em vez de "um guerreiro maia", escreva: "a real person dressed as a Mayan warrior, photographed on location, real skin texture with pores and natural imperfections, real fabric of the costume with visible texture and wrinkles, real feathers in the headdress with natural variations"
            - Em vez de "uma pirâmide antiga", escreva: "a real ancient Mayan pyramid photographed on location, real weathered stone with cracks and imperfections, real moss and vegetation growing on the stones, real shadows cast by the sun, real depth of field blur in the background"
            - Em vez de "luz mística", escreva: "real natural lighting from the sun, real shadows cast by real objects, real depth of field, real bokeh in the background, real camera lens flare if the sun is in frame"
            - SEMPRE mencione: "real", "actual", "photographed", "shot on location", "documentary style", "real-world", "actual photograph"
            
            TÉCNICAS DE THUMBNAIL VIRAL PARA O TEXTO (quando includePhrases = true) - DESIGN PROFISSIONAL COMO PHOTOSHOP - CTR ACIMA DE 25%:
            
            📝 DESCRIÇÃO OBRIGATÓRIA DO TEXTO - DEVE PARECER FEITO NO PHOTOSHOP POR UM DESIGNER PROFISSIONAL:
            O texto DEVE ser descrito como se fosse criado no Photoshop com técnicas profissionais de design gráfico:
            
            1. TIPOGRAFIA PROFISSIONAL:
               - "Professional typography, Photoshop-quality text design"
               - "Large, bold, professionally designed text occupying 25-35% of the image height"
               - "Massive, oversized typography with professional letter spacing and kerning"
               - "Thick, chunky, professionally rendered letters"
               - "Typography that looks like it was designed by a professional graphic designer"
               - "High-end text design, magazine-quality typography"
            
            2. CORES PROFISSIONAIS E EFEITOS DE CAMADA (Layer Effects do Photoshop):
               - "Bright yellow (#FFD700) text with professional Photoshop layer effects: thick black stroke (6-8px), white drop shadow with distance 8px, spread 5px, size 12px, opacity 80%, angle 135 degrees"
               - "Pure white text with professional red stroke (6px), black drop shadow with blur radius 10px, and subtle outer glow effect in yellow"
               - "Neon orange (#FF6600) text with black stroke (7px), professional drop shadow with multiple layers, and yellow outer glow with spread 8px"
               - "Electric blue (#00FFFF) text with white stroke (6px), black shadow with distance 10px, and professional bevel and emboss effect"
               - "Bright red (#FF0000) text with yellow stroke (5px), white drop shadow, and professional gradient overlay from yellow to orange"
               - "Lime green (#00FF00) text with black stroke (8px), white glow effect, and professional inner shadow"
               - IMPORTANTE: Descreva como efeitos de camada do Photoshop (layer effects), não apenas "outline" ou "shadow"
               
               🏆 ESTILO ÉPICO - TEXTOS EM DOURADO (Para thumbnails históricas/épicas):
               - Se a thumbnail original usar textos em dourado, DESCREVA EXATAMENTE assim:
               - "Large, bold, ornate serif font text in golden yellow (#FFD700) with professional Photoshop layer effects: thick black stroke (8-10px width, position outside), professional bevel and emboss effect (style: emboss, technique: smooth, depth 150%, size 8px, softness 3px, highlight mode: screen with opacity 75%, shadow mode: multiply with opacity 50%), white drop shadow (distance 12px, spread 6px, size 15px, opacity 85%, angle 135°), subtle outer glow in golden yellow (spread 10px, size 20px, opacity 60%), positioned at the bottom center of the image, occupying 30-35% of the image height, professional ornate serif typography (Trajan Pro, Cinzel, or similar historical/regal font style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, looks like it was designed by a professional graphic designer for a historical epic movie poster"
               - "Golden embossed text with metallic finish, professional 3D effect, regal and majestic appearance, historical epic typography style"
            
            3. FONTES PROFISSIONAIS:
               - "Professional bold sans-serif font (Impact, Bebas Neue, Montserrat Black, or similar premium font)"
               - "Thick, chunky, professionally designed block letters"
               - "Modern, high-end typography with perfect letter spacing"
               - "YouTube viral thumbnail professional font style"
               - "Bold, condensed font with professional kerning and tracking"
               - "Premium typography, no serifs, maximum readability, professional design"
               - "Typography that looks like it came from a professional design agency"
            
            4. EFEITOS PROFISSIONAIS DO PHOTOSHOP (Layer Styles):
               - "Professional Photoshop stroke effect: thick black outline (6-8px width), position: outside, blend mode: normal, opacity: 100%"
               - "Professional drop shadow: distance 10px, spread 5px, size 12px, angle 135°, opacity 80%, color black, blend mode: multiply"
               - "Professional outer glow effect: spread 8px, size 15px, opacity 75%, color matching text or contrasting"
               - "Professional bevel and emboss effect: style: emboss, technique: smooth, depth 100%, size 5px, softness 2px"
               - "Professional gradient overlay: linear gradient from bright color to darker shade, angle 90°, opacity 80%"
               - "Professional inner shadow: distance 3px, choke 0%, size 5px, opacity 60%"
               - "Professional color overlay: solid color with blend mode overlay or soft light, opacity 50%"
               - "Text appears to pop out from the image with professional 3D effect"
               - "Professional text rendering with anti-aliasing, crisp edges, perfect clarity"
            
            5. COMPOSIÇÃO PROFISSIONAL:
               - "Positioned at the top center of the image with professional alignment"
               - "Bottom third of the image with professional composition and high contrast background"
               - "Centered horizontally, upper third vertically, following rule of thirds"
               - "Strategically placed to not cover important visual elements, professional layout"
               - "Text area has professional semi-transparent dark background (black overlay with 40% opacity) for better readability"
               - "Professional text box or banner behind text with gradient or solid color, rounded corners optional"
            
            6. CONTRASTE E VISIBILIDADE PROFISSIONAL:
               - "High contrast against the background, professionally optimized"
               - "Text stands out dramatically from the image with professional design techniques"
               - "Eye-catching text overlay that immediately draws attention, professional composition"
               - "Text that pops from the image with maximum visibility, professional rendering"
               - "Text is the first thing the eye is drawn to, professional visual hierarchy"
               - "Background is professionally darkened (vignette effect) or lightened behind text for maximum contrast"
               - "Professional color grading applied to background to make text stand out"
            
            7. EXEMPLO COMPLETO DE DESCRIÇÃO PROFISSIONAL:
               "Professional Photoshop-quality text design: Large, bold, stylized text '[FRASE DE GANCHO AQUI]' in bright yellow (#FFD700) with professional layer effects: thick black stroke (7px width, position outside), white drop shadow (distance 10px, spread 5px, size 12px, opacity 80%, angle 135°), subtle outer glow in white (spread 6px, size 10px, opacity 70%), positioned at the top center of the image, occupying 30% of the image height, professional bold sans-serif font (Impact or Bebas Neue style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, high contrast viral thumbnail text style, eye-catching and attention-grabbing, text appears to pop out from the image with professional 3D effect, maximum visibility for high CTR, looks like it was designed by a professional graphic designer in Photoshop"
            
            8. REGRAS DE OURO PARA DESIGN PROFISSIONAL:
               - O texto DEVE parecer feito no Photoshop por um designer profissional
               - O texto DEVE ter múltiplos efeitos de camada (stroke, shadow, glow, bevel)
               - O texto DEVE ter valores específicos de efeitos (distância, spread, tamanho, opacidade)
               - O texto DEVE ter tipografia profissional com kerning e tracking perfeitos
               - O texto DEVE ter renderização profissional (anti-aliasing, crisp edges)
               - O texto DEVE ter composição profissional (regra dos terços, hierarquia visual)
               - O texto DEVE parecer de qualidade de agência de design, não amador

            RESPONDA APENAS COM UM OBJETO JSON VÁLIDO, com a seguinte estrutura:
            {
              "ideias": [
                {
                  "seoDescription": "Descrição completa e otimizada para o YouTube aqui...",
                  "seoTags": ["tag1", "tag2", "tag3", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"]' : language === 'Inglês' ? '["He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"]' : '["Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'A detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'A detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                },
                {
                  "seoDescription": "Outra descrição completa e otimizada...",
                  "seoTags": ["tagA", "tagB", "tagC", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"]' : language === 'Inglês' ? '["The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything", "Surprising Revelation"]' : '["La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'Another detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'Another detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                }
              ]
            }
        `;
            }
        }
        
        // --- 4. Chamar a API Multimodal com fallback ---
        let apiCallFunction;
        if (useLaozhang) {
            apiCallFunction = callLaozhangAPI;
        } else {
            if (service === 'gemini') apiCallFunction = callGeminiAPI;
            else if (service === 'claude') apiCallFunction = callClaudeAPI;
            else if (service === 'openai') apiCallFunction = callOpenAIAPI;
        }
        
        console.log(`[Análise-Thumb] A chamar ${useLaozhang ? 'Laozhang.ai' : service} com o modelo ${model}...`);
        
        let response;
        let parsedData;
        let successfulService = useLaozhang ? 'laozhang' : service;
        
        try {
            if (useLaozhang) {
                response = await callLaozhangAPI(
                    thumbPrompt, 
                    decryptedKey, 
                    model, 
                    videoDetails.thumbnailUrl, 
                    userId, 
                    '/api/analyze/thumbnail', 
                    JSON.stringify({ endpoint: '/api/analyze/thumbnail', model })
                );
                // callLaozhangAPI retorna string diretamente
                response = typeof response === 'string' ? response.trim() : JSON.stringify(response);
                response = { titles: response };
            } else {
                // Preparar imagens adicionais (thumbnails de referência)
                const additionalImages = thumbnailReferences.map(ref => ref.thumbnail_base64).filter(Boolean);
                
                // Chamar API apropriada com múltiplas imagens
                if (service === 'claude') {
                    response = await callClaudeAPI(thumbPrompt, decryptedKey, model, videoDetails.thumbnailUrl, null, additionalImages);
                } else if (service === 'openai') {
                    response = await callOpenAIAPI(thumbPrompt, decryptedKey, model, videoDetails.thumbnailUrl, additionalImages);
                } else if (service === 'gemini') {
                    response = await callGeminiAPI(thumbPrompt, decryptedKey, model, videoDetails.thumbnailUrl, additionalImages);
                } else {
                    response = await apiCallFunction(thumbPrompt, decryptedKey, model, videoDetails.thumbnailUrl);
                }
            }
            parsedData = parseAIResponse(response.titles, successfulService);
            
            if (!parsedData.ideias || !Array.isArray(parsedData.ideias) || parsedData.ideias.length === 0) {
                throw new Error("A IA não retornou o array 'ideias' esperado.");
            }
        } catch (firstError) {
            console.warn(`[Análise-Thumb] Falha com ${service}:`, firstError.message);
            
            // Tentar fallback para outros modelos se o primeiro falhar
            const fallbackServices = service === 'gemini' 
                ? ['claude', 'openai'] 
                : service === 'claude' 
                    ? ['openai', 'gemini'] 
                    : ['gemini', 'claude'];
            
            let fallbackSuccess = false;
            
            for (const fallbackService of fallbackServices) {
                try {
                    console.log(`[Análise-Thumb] Tentando fallback com ${fallbackService}...`);
                    
                    const fallbackKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, fallbackService]);
                    if (!fallbackKeyData) {
                        console.warn(`[Análise-Thumb] Chave de API do ${fallbackService} não configurada para fallback.`);
                        continue;
                    }
                    
                    const fallbackDecryptedKey = decrypt(fallbackKeyData.api_key);
                    if (!fallbackDecryptedKey) {
                        console.warn(`[Análise-Thumb] Falha ao desencriptar chave do ${fallbackService}.`);
                        continue;
                    }
                    
                    let fallbackModel = model;
                    if (fallbackService === 'claude') fallbackModel = 'claude-3-5-haiku-20241022';
                    else if (fallbackService === 'openai') fallbackModel = 'gpt-4o';
                    else if (fallbackService === 'gemini') fallbackModel = 'gemini-2.0-flash';
                    
                    let fallbackApiCallFunction;
                    if (fallbackService === 'gemini') fallbackApiCallFunction = callGeminiAPI;
                    else if (fallbackService === 'claude') fallbackApiCallFunction = callClaudeAPI;
                    else fallbackApiCallFunction = callOpenAIAPI;
                    
                    response = await fallbackApiCallFunction(thumbPrompt, fallbackDecryptedKey, fallbackModel, videoDetails.thumbnailUrl);
                    parsedData = parseAIResponse(response.titles, fallbackService);
                    
                    if (!parsedData.ideias || !Array.isArray(parsedData.ideias) || parsedData.ideias.length === 0) {
                        throw new Error("A IA não retornou o array 'ideias' esperado.");
                    }
                    
                    successfulService = fallbackService;
                    fallbackSuccess = true;
                    console.log(`[Análise-Thumb] Sucesso com fallback ${fallbackService}!`);
                    break;
                } catch (fallbackError) {
                    console.warn(`[Análise-Thumb] Fallback ${fallbackService} também falhou:`, fallbackError.message);
                    continue;
                }
            }
            
            if (!fallbackSuccess) {
                throw new Error(`Todas as IAs falharam. Último erro: ${firstError.message}`);
            }
        }

        // --- 5. Validar e processar dados antes de enviar ---

        // Nota: A ambientação já foi calculada anteriormente (linhas 15168-15184) e as variáveis estão disponíveis:
        // ambientacaoArr, elementosArr, acessoriosCalc, personagemCalc, ambientacaoCalc, elementosDeFundoCalc
        
        // Validar e corrigir tags (limite de 300 caracteres) e frases de gancho (idioma correto)
        if (parsedData.ideias && Array.isArray(parsedData.ideias)) {
            parsedData.ideias = parsedData.ideias.map((idea, index) => {
                // Validar tags - limitar a 300 caracteres
                if (idea.seoTags && Array.isArray(idea.seoTags)) {
                    let tagsString = idea.seoTags.join(', ');
                    if (tagsString.length > 300) {
                        // Reduzir tags até ficar dentro do limite
                        let reducedTags = [];
                        let currentLength = 0;
                        for (const tag of idea.seoTags) {
                            const tagWithComma = reducedTags.length > 0 ? ', ' + tag : tag;
                            if (currentLength + tagWithComma.length <= 300) {
                                reducedTags.push(tag);
                                currentLength += tagWithComma.length;
                            } else {
                                break;
                            }
                        }
                        idea.seoTags = reducedTags;
                        console.log(`[Thumbnail] Tags reduzidas de ${idea.seoTags.length + (idea.seoTags.length - reducedTags.length)} para ${reducedTags.length} para respeitar limite de 300 caracteres`);
                    }
                }
                
                // Validar frases de gancho - garantir que estejam no idioma correto
                if (idea.frasesDeGancho && Array.isArray(idea.frasesDeGancho) && includePhrases) {
                    // Verificar se as frases estão no idioma correto (análise básica)
                    const isPortuguese = language === 'Português';
                    const isSpanish = language === 'Espanhol';
                    const isEnglish = language === 'Inglês';
                    
                    // Palavras comuns em português que não aparecem em inglês/espanhol
                    const portugueseWords = ['que', 'não', 'você', 'com', 'para', 'mais', 'muito', 'isso', 'aqui', 'agora', 'também', 'sempre', 'depois', 'antes', 'ainda', 'então', 'assim', 'mesmo', 'todo', 'toda', 'todos', 'todas', 'ele', 'ela', 'eles', 'elas', 'nosso', 'nossa', 'seus', 'suas', 'desse', 'dessa', 'deles', 'delas'];
                    const spanishWords = ['que', 'no', 'tú', 'con', 'para', 'más', 'muy', 'esto', 'aquí', 'ahora', 'también', 'siempre', 'después', 'antes', 'aún', 'entonces', 'así', 'mismo', 'todo', 'toda', 'todos', 'todas', 'él', 'ella', 'ellos', 'ellas', 'nuestro', 'nuestra', 'sus', 'de', 'del', 'de la'];
                    
                    idea.frasesDeGancho = idea.frasesDeGancho.map(frase => {
                        if (!frase || typeof frase !== 'string') return frase;
                        
                        const fraseLower = frase.toLowerCase();
                        let needsTranslation = false;
                        
                        if (isPortuguese) {
                            // Verificar se tem palavras em português
                            const hasPortugueseWords = portugueseWords.some(word => fraseLower.includes(word));
                            // Se não tem palavras portuguesas e tem palavras comuns em inglês, provavelmente está em inglês
                            if (!hasPortugueseWords && (fraseLower.includes('the ') || fraseLower.includes(' a ') || fraseLower.includes('this ') || fraseLower.includes('that '))) {
                                needsTranslation = true;
                            }
                        } else if (isSpanish) {
                            // Verificar se tem palavras em espanhol
                            const hasSpanishWords = spanishWords.some(word => fraseLower.includes(word));
                            // Se não tem palavras espanholas e tem palavras comuns em inglês, provavelmente está em inglês
                            if (!hasSpanishWords && (fraseLower.includes('the ') || fraseLower.includes(' a ') || fraseLower.includes('this ') || fraseLower.includes('that '))) {
                                needsTranslation = true;
                            }
                        } else if (isEnglish) {
                            // Se tem palavras portuguesas/espanholas, provavelmente não está em inglês
                            if (portugueseWords.some(word => fraseLower.includes(word)) || spanishWords.some(word => fraseLower.includes(word))) {
                                needsTranslation = true;
                            }
                        }
                        
                        // Se precisa traduzir, retornar a frase original (a IA deve ter gerado corretamente, mas vamos apenas logar)
                        if (needsTranslation) {
                            console.warn(`[Thumbnail] Frase de gancho pode estar no idioma errado: "${frase}" (idioma esperado: ${language})`);
                        }
                        
                        return frase;
                    });
                }
                
                // Modularizar a descricaoThumbnail sem operações assíncronas dentro do map
                const baseTemplate = `Generate a historical cinematic thumbnail depicting {PERSONAGEM} wearing {ACESSORIOS} against {AMBIENTE}. Position the subject in the foreground taking up 60% of the frame with an epic background showing {ELEMENTOS_DE_FUNDO}. Use high contrast lighting with gold or cold tones depending on theme and a dramatic sky with storm clouds or environmental effects. The title should be in bold, imposing gold text with a subtle glow effect. The overall mood should be cinematic, realistic and historically significant with ultra-high detail.`;
                let built = baseTemplate
                    .replace('{PERSONAGEM}', personagemCalc)
                    .replace('{ACESSORIOS}', acessoriosCalc || 'authentic period accessories')
                    .replace('{AMBIENTE}', ambientacaoCalc)
                    .replace('{ELEMENTOS_DE_FUNDO}', elementosDeFundoCalc || 'contextual historical elements');
                if (includePhrases) {
                    built += `\nProfessional Photoshop-quality text design displaying [FRASE DE GANCHO AQUI], with multiple layer effects (stroke, drop shadow, outer glow, bevel and emboss), perfect kerning, anti-aliasing, large bold serif gold typography at bottom.`;
                }
                built += `\nExclude mesoamerican pyramids, feathered headdress, conquistadors, Spanish ships unless specifically relevant to the detected theme. CRITICAL - REMOVE ALL CORNER MARKINGS: Exclude any logos, watermarks, channel badges, branding marks, corner icons, decorative elements, or any visual elements in the four corners of the image (top-left, top-right, bottom-left, bottom-right). The image must be completely clean in all four corners.`;
                idea.descricaoThumbnail = built;
                
                // Calcular score viral baseado no algoritmo do YouTube
                const viralScore = calculateThumbnailViralScore(idea.descricaoThumbnail, index, parsedData.ideias.length);
                idea.viralScore = viralScore;
                
                return idea;
            });
        }

        // --- 6. Enviar resposta ---

        // NÃO salvar thumbnails automaticamente - apenas quando o usuário gerar a imagem e salvar na biblioteca
        // As thumbnails serão salvas apenas quando o usuário gerar a imagem com ImageFX e clicar em "Salvar na Biblioteca"
        console.log(`[Biblioteca] ${parsedData.ideias.length} ideias de thumbnails geradas. Aguardando geração de imagem pelo usuário para salvar na biblioteca.`);

        res.status(200).json(parsedData.ideias);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/analyze/thumbnail]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao gerar ideias de thumbnail.' });
    }
});

// === ROTA LAOZHANG PARA ANÁLISE DE THUMBNAIL ===
// Nota: Esta rota usa a mesma lógica da rota original, mas sempre usa Laozhang API
// A implementação completa seguiria o mesmo padrão, mas simplificamos para usar callLaozhangAPI
app.post('/api/analyze/thumbnail/laozhang', authenticateToken, async (req, res) => {
    let { videoId, selectedTitle, model, selectedModel, niche, subniche, language, includePhrases, style, customPrompt, thumbnailRule, folder_id } = req.body;
    // Usar 'model' se 'selectedModel' não estiver presente (compatibilidade)
    const modelToUse = model || selectedModel;
    const userId = req.user.id;

    if (!videoId || !selectedTitle || !niche || !subniche || !language || includePhrases === undefined || !style) {
        return res.status(400).json({ msg: 'Dados insuficientes para gerar ideias de thumbnail.' });
    }
    
    console.log(`[Thumbnail Laozhang] Gerando thumbnails para pasta/canal: ${folder_id || 'Nenhuma pasta selecionada'}`);
    
    // Se thumbnailRule não for fornecido, usar 'auto'
    thumbnailRule = thumbnailRule || 'auto';

    try {
        // Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem plano que permite API própria OU não tem API própria configurada
        // REGRA CRÍTICA: Se preferência NÃO está marcada E usuário tem plano que permite E tem API própria → usar API própria
        
        // Determinar ordem de preferência baseado no modelo
        let preferenceOrder = ['claude', 'openai', 'gemini'];
        if (modelToUse && modelToUse.includes('gemini')) preferenceOrder = ['gemini', 'claude', 'openai'];
        else if (modelToUse && modelToUse.includes('claude')) preferenceOrder = ['claude', 'openai', 'gemini'];
        else if (modelToUse && modelToUse.includes('gpt')) preferenceOrder = ['openai', 'claude', 'gemini'];
        
        const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
        
        let useLaozhang = false;
        let apiKeyToUse = null;
        let serviceToUse = null;
        let apiCallFunction = null;
        
        if (creditsCheck.shouldUse) {
            // Se deve usar créditos, usar laozhang.ai
            const laozhangKey = await getLaozhangApiKey();
            if (laozhangKey) {
                useLaozhang = true;
                apiKeyToUse = laozhangKey;
                serviceToUse = 'laozhang';
                apiCallFunction = callLaozhangAPI;
                console.log(`[Thumbnail] ✅ Usando Laozhang.ai (${creditsCheck.reason})`);
            } else {
                console.warn('[Thumbnail] ⚠️ Laozhang.ai não configurada, tentando usar APIs próprias do usuário');
            }
        } else {
            console.log(`[Thumbnail] ✅ Usando API própria (${creditsCheck.reason})`);
        }
        
        // Se não usar laozhang.ai, usar APIs próprias do usuário
        if (!useLaozhang) {
            // Determinar serviço baseado no modelo
            if (modelToUse && modelToUse.includes('gemini')) serviceToUse = 'gemini';
            else if (modelToUse && modelToUse.includes('claude')) serviceToUse = 'claude';
            else if (modelToUse && modelToUse.includes('gpt')) serviceToUse = 'openai';
            else serviceToUse = 'gemini'; // fallback
            
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, serviceToUse]);
            if (!keyData) return res.status(400).json({ msg: `Chave de API do ${serviceToUse} não configurada.` });
            
            apiKeyToUse = decrypt(keyData.api_key);
            if (!apiKeyToUse) return res.status(500).json({ msg: 'Falha ao descriptografar a sua chave de API.' });
            
            if (serviceToUse === 'gemini') apiCallFunction = callGeminiAPI;
            else if (serviceToUse === 'claude') apiCallFunction = callClaudeAPI;
            else apiCallFunction = callOpenAIAPI;
        }

        if (useLaozhang) {
            // Mapear para modelo Laozhang
            if (modelToUse === 'gpt-4o' || modelToUse === 'GPT-4o (2025)') {
                modelForAPI = 'gpt-4o';
            } else if (modelToUse === 'claude-3-7-sonnet-20250219' || modelToUse === 'Claude 3.7 Sonnet (Fev/25)') {
                modelForAPI = 'claude-3-7-sonnet-20250219';
            } else if (modelToUse === 'gemini-2.5-pro' || modelToUse === 'Gemini 2.5 Pro (2025)') {
                modelForAPI = 'gemini-2.5-pro';
            } else if (modelToUse && modelToUse.includes('claude')) {
                modelForAPI = 'claude-3-7-sonnet-20250219';
            } else if (modelToUse && modelToUse.includes('gemini')) {
                modelForAPI = 'gemini-2.5-pro';
            } else if (modelToUse && modelToUse.includes('gpt')) {
                modelForAPI = 'gpt-4o';
            } else {
                console.warn(`[Thumbnail] ⚠️ Modelo não reconhecido: "${modelToUse}", usando 'gpt-4o' como fallback`);
                modelForAPI = 'gpt-4o';
            }
        } else {
            // Usar modelo original para API própria
            modelForAPI = modelToUse;
        }
        console.log(`[Thumbnail] Modelo recebido: "${modelToUse}" -> Mapeado para API: "${modelForAPI}" (${useLaozhang ? 'Laozhang' : serviceToUse})`);

        // Buscar chave do YouTube primeiro (prioridade)
        let videoDetails = null;
        let youtubeApiKey = null;
        
        try {
            const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
            if (youtubeKeyData && youtubeKeyData.api_key) {
                // Tentar descriptografar se estiver criptografada
                if (youtubeKeyData.api_key.includes(':')) {
                    try {
                        youtubeApiKey = decrypt(youtubeKeyData.api_key);
                    } catch (decryptErr) {
                        console.warn('[Thumbnail Laozhang] Erro ao descriptografar chave do YouTube, tentando usar diretamente:', decryptErr.message);
                        youtubeApiKey = youtubeKeyData.api_key;
                    }
                } else {
                    youtubeApiKey = youtubeKeyData.api_key;
                }
                
                if (youtubeApiKey) {
                    console.log('[Thumbnail Laozhang] Tentando usar chave do YouTube...');
                    try {
                        videoDetails = await callYouTubeDataAPI(videoId, youtubeApiKey);
                        console.log('[Thumbnail Laozhang] ✅ Sucesso com chave do YouTube');
                    } catch (youtubeErr) {
                        console.warn('[Thumbnail Laozhang] Erro ao usar chave do YouTube:', youtubeErr.message);
                        videoDetails = null;
                    }
                }
            }
        } catch (err) {
            console.warn('[Thumbnail Laozhang] Erro ao buscar chave do YouTube:', err.message);
        }
        
        // Se não funcionou com YouTube, tentar Gemini como fallback
        if (!videoDetails) {
            try {
                const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
                if (geminiKeyData && geminiKeyData.api_key) {
                    let geminiApiKey = null;
                    if (geminiKeyData.api_key.includes(':')) {
                        try {
                            geminiApiKey = decrypt(geminiKeyData.api_key);
                        } catch (decryptErr) {
                            console.warn('[Thumbnail Laozhang] Erro ao descriptografar chave do Gemini, tentando usar diretamente:', decryptErr.message);
                            geminiApiKey = geminiKeyData.api_key;
                        }
                    } else {
                        geminiApiKey = geminiKeyData.api_key;
                    }
                    
                    if (geminiApiKey) {
                        console.log('[Thumbnail Laozhang] Tentando usar chave do Gemini como fallback...');
                        try {
                            videoDetails = await callYouTubeDataAPI(videoId, geminiApiKey);
                            console.log('[Thumbnail Laozhang] ✅ Sucesso com chave do Gemini');
                        } catch (geminiErr) {
                            console.warn('[Thumbnail Laozhang] Erro ao usar chave do Gemini:', geminiErr.message);
                        }
                    }
                }
            } catch (err) {
                console.warn('[Thumbnail Laozhang] Erro ao buscar chave do Gemini:', err.message);
            }
        }

        if (!videoDetails) {
            return res.status(400).json({ 
                msg: 'Não foi possível buscar dados do vídeo. Verifique se a chave do YouTube Data API v3 está configurada corretamente nas Configurações. A chave do Gemini pode não funcionar para a API do YouTube.' 
            });
        }

        // Usar o mesmo prompt da rota original com todas as melhorias
        // Buscar análise original para pegar a fórmula do título
        let formulaTitulo = null;
        let motivoSucesso = null;
        try {
            const originalAnalysis = await db.get(
                'SELECT analysis_data_json FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                [videoId, userId]
            );
            if (originalAnalysis && originalAnalysis.analysis_data_json) {
                const analysisData = JSON.parse(originalAnalysis.analysis_data_json);
                if (analysisData.formulaTitulo) {
                    formulaTitulo = analysisData.formulaTitulo;
                }
                if (analysisData.motivoSucesso) {
                    motivoSucesso = analysisData.motivoSucesso;
                }
            }
        } catch (err) {
            console.warn(`[Análise-Thumb Laozhang] Não foi possível buscar análise original: ${err.message}`);
        }
        
        // --- Buscar thumbnails de referência do canal/nicho ---
        let thumbnailReferences = [];
        try {
            // PRIORIDADE 1: Buscar thumbnails de referência da PASTA/CANAL específica primeiro
            if (folder_id) {
                const folderRefs = await db.all(
                    'SELECT id, thumbnail_base64, channel_name, niche, subniche, description, folder_id FROM thumbnail_references WHERE user_id = ? AND folder_id = ? ORDER BY created_at DESC LIMIT 5',
                    [userId, folder_id]
                );
                
                if (folderRefs && folderRefs.length > 0) {
                    thumbnailReferences = folderRefs;
                    console.log(`[Thumbnail Laozhang] ✅ Encontradas ${thumbnailReferences.length} thumbnail(s) de referência para o CANAL/PASTA ID ${folder_id} (prioridade máxima)`);
                }
            }
            
            // PRIORIDADE 2: Se não houver thumbnails da pasta, buscar por nicho/subnicho
            if (thumbnailReferences.length === 0) {
                let refQuery = 'SELECT id, thumbnail_base64, channel_name, niche, subniche, description, folder_id FROM thumbnail_references WHERE user_id = ?';
                const refParams = [userId];
                
                // Buscar por subniche, niche ou sem filtro específico (para pegar thumbnails gerais também)
                if (subniche || niche) {
                    refQuery += ' AND (';
                    const conditions = [];
                    if (subniche) {
                        conditions.push('subniche = ?');
                        refParams.push(subniche);
                    }
                    if (niche) {
                        conditions.push('niche = ?');
                        refParams.push(niche);
                    }
                    // Também incluir thumbnails sem filtro específico (NULL)
                    conditions.push('(subniche IS NULL AND niche IS NULL)');
                    refQuery += conditions.join(' OR ') + ')';
                }
                
                // Excluir thumbnails que já têm uma pasta específica (pois são de outros canais)
                refQuery += ' AND folder_id IS NULL';
                refQuery += ' ORDER BY created_at DESC LIMIT 5'; // Limitar a 5 thumbnails de referência
                
                const refs = await db.all(refQuery, refParams);
                thumbnailReferences = refs || [];
                
                if (thumbnailReferences.length > 0) {
                    console.log(`[Thumbnail Laozhang] ✅ Encontradas ${thumbnailReferences.length} thumbnail(s) de referência para o nicho/subnicho (fallback)`);
                } else {
                    console.log(`[Thumbnail Laozhang] ⚠️ Nenhuma thumbnail de referência encontrada para esta pasta ou nicho/subnicho`);
                }
            }
        } catch (err) {
            console.warn(`[Thumbnail Laozhang] Erro ao buscar thumbnails de referência: ${err.message}`);
        }
        
        const formulaContext = formulaTitulo ? `\n            FÓRMULA DO TÍTULO VIRAL IDENTIFICADA: "${formulaTitulo}"\n            MOTIVO DO SUCESSO: "${motivoSucesso || 'Análise não disponível'}"\n            \n            IMPORTANTE: Use esta fórmula como base para criar thumbnails que complementem e reforcem o mesmo gatilho mental e estratégia que tornaram o título viral.` : '';
        
        // Pré-calcular ambientação dinâmica pelo título (ou tema manual) ANTES de construir o prompt
        const themeKeyManual = req.body.theme_key || null;
        let dbMatchLocal = null;
        if (themeKeyManual) {
            await ensureAmbientationsTable();
            dbMatchLocal = await db.get('SELECT * FROM niche_ambientations WHERE user_id = ? AND theme_key = ? LIMIT 1', [userId, themeKeyManual]);
        }
        if (!dbMatchLocal) {
            dbMatchLocal = await detectAmbientationFromTitle(userId, selectedTitle, niche);
        }
        const ambientacaoArr = dbMatchLocal ? String(dbMatchLocal.ambiente || '').split(',').map(s => s.trim()).filter(Boolean) : [];
        const elementosArr = dbMatchLocal ? String(dbMatchLocal.elementos || '').split(',').map(s => s.trim()).filter(Boolean) : [];
        const acessoriosCalc = dbMatchLocal ? String(dbMatchLocal.acessorios || '') : '';
        const personagemCalc = dbMatchLocal && dbMatchLocal.subject ? dbMatchLocal.subject : 'historical figure with authentic attire';
        const ambientacaoCalc = ambientacaoArr.length ? ambientacaoArr.join(', ') : 'landscapes and architecture matching the title theme';
        const elementosDeFundoCalc = elementosArr.length ? elementosArr.join(', ') : 'contextual historical elements';
        
        // --- Adaptar prompt padrão ao título específico ---
        let adaptedCustomPrompt = customPrompt;
        if (customPrompt && customPrompt.trim()) {
            try {
                console.log('[Thumbnail Laozhang] Adaptando prompt padrão ao título específico...');
                
                // Criar prompt para a IA adaptar o prompt padrão ao título
                const adaptationPrompt = `Você é um especialista em adaptação de prompts visuais para thumbnails do YouTube.

TAREFA: Adapte o prompt padrão abaixo para o título específico do vídeo, mantendo EXATAMENTE a estrutura visual e estilo do prompt padrão, mas ajustando o conteúdo/tema/ambientação para o título fornecido.

PROMPT PADRÃO (ESTRUTURA E ESTILO A MANTER):
"""
${customPrompt}
"""

TÍTULO DO VÍDEO:
"${selectedTitle}"

NICHO/SUBNICHO:
${niche} / ${subniche}

INSTRUÇÕES:
1. Analise o prompt padrão e identifique:
   - Estrutura de composição (layout, posicionamento de elementos)
   - Estilo visual (paleta de cores, tipografia, iluminação)
   - Elementos técnicos (resolução, efeitos, tratamento)
   - Padrões de texto/frases

2. Adapte o prompt para o título "${selectedTitle}":
   - MANTENHA: toda a estrutura visual, estilo, composição, paleta de cores, tipografia
   - AJUSTE: personagem/sujeito, ambientação, cenário, elementos de fundo para corresponder ao tema do título
   - SUBSTITUA: referências genéricas por elementos específicos do título
   - PRESERVE: todos os elementos técnicos e de qualidade (resolução, efeitos, etc.)

3. O prompt adaptado deve:
   - Seguir EXATAMENTE o mesmo formato e estrutura do prompt padrão
   - Manter o mesmo estilo visual e composição
   - Aplicar o tema/contexto do título "${selectedTitle}"
   - Ser específico e detalhado como o prompt padrão

4. Retorne APENAS o prompt adaptado, sem explicações ou comentários adicionais.

PROMPT ADAPTADO:`;

                // Chamar IA para adaptar o prompt
                let adaptedResponse;
                if (useLaozhang) {
                    adaptedResponse = await apiCallFunction(
                        adaptationPrompt,
                        apiKeyToUse,
                        'gpt-4o',
                        null,
                        userId,
                        '/api/analyze/thumbnail/laozhang',
                        JSON.stringify({ endpoint: '/api/analyze/thumbnail/laozhang', operation: 'adapt-prompt' })
                    );
                } else if (serviceToUse === 'openai') {
                    adaptedResponse = await apiCallFunction(adaptationPrompt, apiKeyToUse, modelForAPI);
                    adaptedResponse = adaptedResponse.titles || adaptedResponse;
                } else if (serviceToUse === 'claude') {
                    adaptedResponse = await apiCallFunction(adaptationPrompt, apiKeyToUse, modelForAPI);
                    adaptedResponse = adaptedResponse.titles || adaptedResponse;
                } else if (serviceToUse === 'gemini') {
                    adaptedResponse = await apiCallFunction(adaptationPrompt, apiKeyToUse, modelForAPI);
                    adaptedResponse = adaptedResponse.titles || adaptedResponse;
                }
                
                if (adaptedResponse && typeof adaptedResponse === 'string' && adaptedResponse.trim().length > 100) {
                    adaptedCustomPrompt = adaptedResponse.trim();
                    console.log('[Thumbnail Laozhang] ✅ Prompt padrão adaptado com sucesso ao título');
                    console.log('[Thumbnail Laozhang] Prompt adaptado (preview):', adaptedCustomPrompt.substring(0, 300) + '...');
                } else {
                    console.warn('[Thumbnail Laozhang] ⚠️ Falha ao adaptar prompt, usando prompt padrão original');
                }
            } catch (adaptErr) {
                console.warn('[Thumbnail Laozhang] Erro ao adaptar prompt padrão:', adaptErr.message);
                console.warn('[Thumbnail Laozhang] Continuando com prompt padrão original');
            }
        }
        
        // Se customPrompt foi fornecido (prompt padrão do estilo), integrá-lo ao prompt do sistema
        // em vez de substituí-lo completamente, para manter a estrutura JSON necessária
        const hasStandardPrompt = adaptedCustomPrompt && adaptedCustomPrompt.trim();
        console.log(`[Thumbnail Laozhang] customPrompt adaptado recebido: ${hasStandardPrompt ? 'SIM (' + adaptedCustomPrompt.length + ' caracteres, usado APENAS como estilo visual)' : 'NÃO'}`);
        if (hasStandardPrompt) {
            console.log(`[Thumbnail Laozhang] Estilo visual bloqueado a partir do prompt adaptado (preview 200 chars): ${adaptedCustomPrompt.substring(0, 200)}...`);
        }
        
        const thumbPrompt = `
Você é um ESPECIALISTA EM THUMBNAILS VIRAIS NO YOUTUBE, combinando as habilidades de um diretor de arte profissional e um estrategista de viralização com experiência em criar thumbnails que gerem MILHÕES DE VIEWS e ALTO CTR (acima de 25%).${formulaContext}

${hasStandardPrompt ? `\n🎨🎨🎨 PROMPT ADAPTADO DO ESTILO DO CANAL/NICHO PARA O TÍTULO "${selectedTitle}" 🎨🎨🎨:\n${adaptedCustomPrompt}\n\n🌍🌍🌍 AMBIENTAÇÃO DETECTADA PELO TÍTULO "${selectedTitle}" (APLICAR AO CONTEÚDO) 🌍🌍🌍:\n${dbMatchLocal ? `\n- PERSONAGEM/SUJEITO: ${personagemCalc}\n- AMBIENTAÇÃO/CENÁRIO: ${ambientacaoCalc}\n- ELEMENTOS DE FUNDO: ${elementosDeFundoCalc}\n${acessoriosCalc ? `- ACESSÓRIOS: ${acessoriosCalc}` : ''}\n\n⚠️ CRÍTICO: Use esta ambientação detectada pelo título para definir o CONTEÚDO da thumbnail, mantendo o ESTILO VISUAL do prompt padrão acima.\n` : `\n- A ambientação será detectada automaticamente pelo título "${selectedTitle}".\n- Use elementos visuais relacionados ao tema do título, mantendo o estilo visual do prompt padrão.\n`}\n\n⚠️⚠️⚠️ CRÍTICO - O PROMPT PADRÃO É APENAS ESTILO VISUAL - APLICAR AO TÍTULO "${selectedTitle}" ⚠️⚠️⚠️:\n- O PROMPT PADRÃO acima define APENAS o ESTILO VISUAL (composição, cores, tipografia, elementos, iluminação, atmosfera).\n- O CONTEÚDO das thumbnails deve ser SOBRE O TÍTULO "${selectedTitle}" que o usuário escolheu.\n- Use a AMBIENTAÇÃO DETECTADA acima para definir o conteúdo (personagem, cenário, elementos).\n- NÃO use o conteúdo do prompt padrão. Use APENAS o estilo visual dele.\n- NÃO crie um prompt novo. APLIQUE o estilo do prompt padrão ao título "${selectedTitle}" usando a ambientação detectada.\n\nPROCESSO OBRIGATÓRIO:\n1. EXTRAIA do prompt padrão APENAS os elementos de ESTILO VISUAL:\n   - Tipo de composição (ex: "close-up dramático", "composição dividida", "cena épica")\n   - Paleta de cores (ex: "dourado e azul escuro", "tons terrosos", "vermelho e preto")\n   - Estilo de tipografia (ex: "textos dourados serifados com bevel/emboss", "fonte bold com outline preto")\n   - Iluminação e atmosfera (ex: "iluminação dramática", "céu tempestuoso", "chiaroscuro", "luz dourada")\n   - Estilo geral (ex: "cinematográfico", "documental", "épico", "realista")\n\n2. USE a AMBIENTAÇÃO DETECTADA para definir o CONTEÚDO:\n   - Personagem/Sujeito: ${personagemCalc}\n   - Cenário/Ambientação: ${ambientacaoCalc}\n   - Elementos de fundo: ${elementosDeFundoCalc}\n   ${acessoriosCalc ? `- Acessórios: ${acessoriosCalc}` : ''}\n\n3. APLIQUE o estilo extraído + a ambientação detectada ao criar thumbnails sobre "${selectedTitle}":\n   - Use a mesma composição do prompt padrão (ex: se o estilo é "close-up", faça close-up do ${personagemCalc})\n   - Use a mesma paleta de cores do prompt padrão\n   - Use o mesmo estilo de tipografia do prompt padrão\n   - Use a AMBIENTAÇÃO DETECTADA (${ambientacaoCalc}) como cenário\n   - Use os ELEMENTOS DE FUNDO DETECTADOS (${elementosDeFundoCalc})\n   - Use a mesma iluminação e atmosfera do prompt padrão\n   - Mantenha o estilo geral do prompt padrão\n\n4. RESULTADO: Thumbnails sobre "${selectedTitle}" com o ESTILO VISUAL do prompt padrão + CONTEÚDO baseado na ambientação detectada pelo título.\n\nEXEMPLO:\n- Prompt padrão: "close-up dramático com textos dourados serifados, iluminação dramática"\n- Título: "${selectedTitle}" (ex: sobre neandertais)\n- Ambientação detectada: ${personagemCalc}, ${ambientacaoCalc}, ${elementosDeFundoCalc}\n- RESULTADO: "close-up dramático de ${personagemCalc} em ${ambientacaoCalc} com textos dourados serifados, iluminação dramática"\n\n⚠️ NÃO REPLIQUE O CONTEÚDO DO PROMPT PADRÃO. USE A AMBIENTAÇÃO DETECTADA PELO TÍTULO.\n` : ''}

IMAGEM DE REFERÊNCIA: [A imagem da thumbnail original do vídeo está anexada]
${thumbnailReferences.length > 0 ? `
🎨 THUMBNAILS DE REFERÊNCIA DO CANAL/NICHO (IMPORTANTE - ESTILO DO CANAL):
${thumbnailReferences.map((ref, idx) => `[IMAGEM ${idx + 1} DE REFERÊNCIA DO CANAL: A thumbnail de referência ${idx + 1} do canal está anexada${ref.description ? ` (Descrição: ${ref.description})` : ''}]`).join('\n')}

⚠️⚠️⚠️ CRÍTICO - USE AS THUMBNAILS DE REFERÊNCIA DO CANAL COMO ESTILO PRINCIPAL ⚠️⚠️⚠️:
- Analise cuidadosamente TODAS as ${thumbnailReferences.length} thumbnail(s) de referência do canal que estão anexadas acima.
- Estas thumbnails representam o ESTILO VISUAL OFICIAL do canal/nicho "${subniche}".
- A IDEIA 1 DEVE replicar fielmente o estilo visual dessas thumbnails de referência do canal (composição, cores, tipografia, elementos visuais, posicionamento de texto, etc.).
- Identifique os elementos comuns entre as thumbnails de referência: tipo de composição, paleta de cores, estilo de texto, posicionamento de elementos, iluminação, etc.
- Replique EXATAMENTE esse estilo visual na IDEIA 1, mantendo a identidade visual do canal.
- A IDEIA 2 pode ser mais criativa, mas ainda deve respeitar a identidade visual do canal baseada nas thumbnails de referência.
- Se as thumbnails de referência do canal usarem textos em dourado, composição dividida, close-up dramático ou outros elementos específicos, REPLIQUE-OS FIELMENTE na IDEIA 1.
` : ''}
TÍTULO DO VÍDEO: "${selectedTitle}"
SUBNICHO: "${subniche}"
ESTILO DE ARTE: "${style}"
IDIOMA: "${language}"

⚠️ ATENÇÃO CRÍTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, não ilustrações, desenhos ou renderizações. A descriçãoThumbnail deve descrever uma FOTO REAL tirada por um fotógrafo profissional em um local real, com pessoas reais e objetos reais.

${(() => {
    const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
    if (ruleData.mode === 'auto') {
        return `\n🔍 MODO AUTOMÁTICO - ANÁLISE DE REGRA:\nAnalise o título "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPLÍCITA na descrição da thumbnail.\n\n📋 AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE:\n\n1️⃣ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO): Checklist: 1 ideia principal, 1 personagem, 1 emoção, 1 objeto-chave.\n\n2️⃣ REGRA DO ASSUNTO ÚNICO: Nada divide a atenção. Foque em UM ÚNICO assunto dominante.\n\n3️⃣ REGRA DO ROSTO GRANDE: Rostos com forte expressão emocional aumentam CTR de 20% a 60%. Expressões: choque, surpresa, medo, raiva, felicidade extrema.\n\n4️⃣ REGRA DO CONTRASTE BRUTAL: Use contraste entre texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n\n5️⃣ REGRA DA COR ESTRATÉGICA: Amarelo (atenção), Vermelho (urgência), Azul (confiança), Verde (dinheiro), Preto (premium/mistério).\n\n6️⃣ REGRA DOS TERÇOS: Posicione o assunto nos cruzamentos dos "9 quadrantes".\n\n7️⃣ REGRA DO TEXTO ULTRA CURTO: Texto deve ter 2 a 4 palavras. Exemplos: "Ele mentiu", "Descobri isso", "Ninguém viu".\n\n8️⃣ REGRA DO ZOOM EMOCIONAL: Use um elemento GIGANTE que amplifique a emoção (conta bancária gigante, faca gigante, lupa gigante, número gigante).\n\n9️⃣ REGRA DO MISTÉRIO: Crie uma pergunta implícita (algo escondido atrás de blur, objeto cortado pela metade, pessoa olhando para fora do quadro).\n\n🔟 REGRA DOS PONTOS DE FUGA: Use linhas visuais (setas, linhas diagonais, perspectiva) que guiem o olhar para o foco.\n\n1️⃣1️⃣ REGRA DO ESPAÇO NEGATIVO: Deixe áreas vazias que acentuem o foco no elemento principal.\n\n1️⃣2️⃣ REGRA DA COERÊNCIA COM O TÍTULO: Título = contexto, Thumbnail = emoção. Devem contar a mesma história com ângulos diferentes.\n\n⚠️ CRÍTICO: Identifique qual regra melhor se encaixa e aplique-a de forma EXPLÍCITA na descrição da thumbnail.`;
    } else {
        return `\n📋 REGRA SELECIONADA: ${ruleData.rule.name}\n${ruleData.rule.description}\n\n⚠️ CRÍTICO: Aplique esta regra de forma EXPLÍCITA e RIGOROSA:\n${ruleData.instructions}`;
    }
})()}

🎯 OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando técnicas profissionais e as regras acima.

SUA TAREFA:
Crie DUAS (2) ideias distintas para thumbnail:

⚠️⚠️⚠️ CRÍTICO - ORDEM DAS IDEIAS ⚠️⚠️⚠️
${hasStandardPrompt ? `
⚠️⚠️⚠️ ATENÇÃO CRÍTICA: PROMPT PADRÃO ESTÁ ATIVO - USAR APENAS O ESTILO VISUAL ⚠️⚠️⚠️
- O PROMPT PADRÃO acima é APENAS ESTILO VISUAL (como criar), NÃO é o conteúdo (o que criar).
- O CONTEÚDO das thumbnails DEVE ser sobre o título "${selectedTitle}" que o usuário escolheu.
- Ambas as IDEIAS devem APLICAR o estilo visual do prompt padrão ao título "${selectedTitle}".
- NÃO use o conteúdo/tema do prompt padrão. Use APENAS os elementos de estilo (composição, cores, tipografia, iluminação, atmosfera).
- EXTRAIA o estilo do prompt padrão e APLIQUE ao tema de "${selectedTitle}".

` : ''}
- **IDEIA 1 (RÉPLICA E MELHORIA DA THUMBNAIL ORIGINAL DO VÍDEO):** 
  * OBRIGATÓRIO: Esta ideia DEVE replicar e melhorar a thumbnail ORIGINAL do vídeo ao qual foram feitos os títulos.
  ${hasStandardPrompt ? `* APLIQUE O ESTILO DO PROMPT PADRÃO: Use os elementos de estilo do prompt padrão (composição, cores, tipografia, iluminação) mantendo o conteúdo relacionado ao título "${selectedTitle}".\n` : ''}
  * Analise cuidadosamente a IMAGEM DE REFERÊNCIA (thumbnail original do vídeo) que está anexada.
  ${hasStandardPrompt ? `* INTEGRE O ESTILO DO PROMPT PADRÃO: Mantenha a estrutura da thumbnail original, mas aplique os elementos de estilo do prompt padrão (cores, tipografia, iluminação, atmosfera) ao título "${selectedTitle}".\n` : ''}
  * Replique a estrutura da thumbnail de referência quase 1:1: mantenha EXATAMENTE a mesma composição, ângulo de câmera, enquadramento, posição dos personagens/objetos, paleta de cores, quantidade de texto, posição do texto, elementos visuais principais e storytelling.
  * PRESERVE o poder viral da thumbnail original que gerou milhões de views.
  * Apenas ELEVE A QUALIDADE: mais nitidez (8K), contraste reforçado, iluminação cinematográfica profissional, correções de cor profissionais, tratamento de pele profissional, brilho nos olhos, textura realista, limpeza de ruídos, adicione luzes/sombras profissionais, aplique efeitos de texto Photoshop com valores específicos.
  * NÃO altere o storytelling principal, apenas entregue a versão definitiva com acabamento premium.
  * Resultado: praticamente igual à thumbnail original, mas com sensação de upgrade premium e leitura instantânea mais clara e clicável.

- **IDEIA 2 (THUMBNAIL MELHORADA E OTIMIZADA):** 
  * Esta é uma versão COMPLETAMENTE NOVA, melhorada e otimizada para CTR alto (30%+).
  ${hasStandardPrompt ? `* APLIQUE O ESTILO DO PROMPT PADRÃO: Crie uma thumbnail NOVA sobre o título "${selectedTitle}" usando os elementos de estilo do prompt padrão (composição, cores, tipografia, iluminação, atmosfera).\n` : ''}
  * Crie um conceito totalmente novo com foco em CTR máximo: novo enquadramento, nova composição, novos elementos que gerem curiosidade extrema.
  * Use gatilhos agressivos (perigo, segredo revelado, números gigantes, setas, antes/depois, close dramático) e cores super contrastantes.
  ${hasStandardPrompt ? `* MANTENHA O ESTILO DO CANAL: Use os elementos visuais do prompt padrão (ex: textos dourados, close-up dramático, composição dividida, etc.) mas adaptados ao título "${selectedTitle}".\n` : ''}
  * Construa um storytelling diferente, alinhado ao título "${selectedTitle}", que prometa algo ainda mais irresistível que a versão original.
  * O texto deve ser redesenhado para máxima legibilidade mobile, com layer styles profissionais e valores precisos.
  * Esta versão deve ser AINDA MELHOR que a original, com técnicas avançadas de viralização.

PARA CADA UMA DAS 2 IDEIAS, GERE:
1. **"seoDescription"**: Descrição EXTREMAMENTE OTIMIZADA para SEO e viralização (300-500 palavras), com emojis estratégicos, parágrafos estruturados, CTAs claras, palavras-chave relevantes, formatação profissional com separadores visuais, seções organizadas (introdução, conteúdo, sobre canal, links, hashtags), linguagem persuasiva que gere curiosidade e urgência, no idioma "${language}".

2. **"seoTags"**: Array com 15-25 tags MAIS RELEVANTES (LIMITE MÁXIMO: 300 caracteres no total, incluindo vírgulas e espaços. NÃO ultrapasse 300 caracteres), incluindo: tags de cauda curta (1-2 palavras), tags de cauda longa (3-5 palavras), tags de nicho, tags de tendência, tags de formato, tags de emoção, tags de benefício, tags de palavra-chave principal, tags de sinônimos. Todas RELEVANTES ao título "${selectedTitle}" e subnicho "${subniche}", no idioma "${language}". Priorize tags mais relevantes e estratégicas. Se necessário, reduza a quantidade de tags para não ultrapassar 300 caracteres.

3. **"frasesDeGancho"**: Array com 5 frases CURTAS de impacto (2-4 palavras cada), OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne array vazio [].' : `
                ⚠️⚠️⚠️ CRÍTICO E OBRIGATÓRIO - IDIOMA DAS FRASES DE GANCHO ⚠️⚠️⚠️
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Português' ? `
                ✅ CORRETO (Português): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : language === 'Inglês' ? `
                ✅ CORRETO (Inglês): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : `
                ✅ CORRETO (Espanhol): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante", "La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGATÓRIAS:
                1. Se "${language}" for "Português", TODAS as 5 frases DEVEM estar em PORTUGUÊS (Brasil)
                2. Se "${language}" for "Inglês", TODAS as 5 frases DEVEM estar em INGLÊS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em inglês se o idioma escolhido for português ou espanhol
                5. NUNCA, JAMAIS retorne frases em português se o idioma escolhido for inglês ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for português ou inglês
                7. Cada frase deve ter 2 a 4 palavras, no máximo
                8. As frases devem ser impactantes e relacionadas ao título "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases estão no idioma "${language}"?
                - Nenhuma frase está em inglês se "${language}" for português ou espanhol?
                - Nenhuma frase está em português se "${language}" for inglês ou espanhol?
                - Nenhuma frase está em espanhol se "${language}" for português ou inglês?
                
                Se alguma resposta for NÃO, CORRIJA as frases antes de retornar o JSON.
                `}

4. **"descricaoThumbnail"**: Prompt EXTREMAMENTE DETALHADO em INGLÊS para IA de geração de imagem. ${!includePhrases ? 'NÃO inclua placeholder para texto. Apenas elementos visuais.' : 'DEVE incluir placeholder "[FRASE DE GANCHO AQUI]" com descrição profissional de texto Photoshop (layer effects, stroke, drop shadow, outer glow, bevel & emboss, tipografia profissional, valores específicos).'} 

${hasStandardPrompt ? `\n⚠️⚠️⚠️ CRÍTICO - O PROMPT PADRÃO É APENAS ESTILO - APLICAR AO TÍTULO "${selectedTitle}" ⚠️⚠️⚠️:\nA descriçãoThumbnail DEVE APLICAR APENAS O ESTILO VISUAL do prompt padrão acima ao título "${selectedTitle}".\n\nPROCESSO OBRIGATÓRIO:\n1. EXTRAIA do prompt padrão APENAS os elementos de ESTILO VISUAL:\n   - Tipo de composição (close-up, composição dividida, cena épica, etc.)\n   - Paleta de cores (dourado, azul escuro, vermelho, preto, etc.)\n   - Estilo de tipografia (dourado serifado, bevel/emboss, outline preto, etc.)\n   - Elementos visuais recorrentes (pirâmides, navios, fogo, tempestades, silhuetas, etc.)\n   - Iluminação e atmosfera (dramática, stormy, chiaroscuro, luz dourada, etc.)\n   - Estilo geral (cinematográfico, documental, épico, realista, etc.)\n\n2. IGNORE o conteúdo/tema do prompt padrão. O conteúdo DEVE ser sobre "${selectedTitle}".\n\n3. APLIQUE o estilo extraído ao criar uma thumbnail sobre "${selectedTitle}":\n   - Use a mesma composição mas com elementos relacionados a "${selectedTitle}"\n   - Use a mesma paleta de cores\n   - Use o mesmo estilo de tipografia\n   - Adapte os elementos visuais ao tema de "${selectedTitle}" (mantendo o estilo)\n   - Use a mesma iluminação e atmosfera\n   - Mantenha o estilo geral\n\n4. RESULTADO: Thumbnail sobre "${selectedTitle}" mas com o estilo visual do prompt padrão.\n\nEXEMPLO PRÁTICO:\n- Prompt padrão: "close-up dramático de líder indígena com textos dourados serifados, iluminação dramática, céu tempestuoso"\n- Título escolhido: "${selectedTitle}" (ex: sobre tecnologia inca)\n- RESULTADO: "close-up dramático de [elementos relacionados a ${selectedTitle}] com textos dourados serifados, iluminação dramática, céu tempestuoso"\n\n⚠️ NÃO USE O CONTEÚDO DO PROMPT PADRÃO. USE APENAS O ESTILO E APLIQUE AO TÍTULO "${selectedTitle}".\n\n🚫 OBRIGATÓRIO - INSTRUÇÕES DE EXCLUSÃO (SEMPRE INCLUIR NA descricaoThumbnail):\nA descricaoThumbnail DEVE SEMPRE incluir estas instruções de exclusão no final:\n"Exclude mesoamerican pyramids, feathered headdress, conquistadors, Spanish ships, jaguar motifs, and any aztec elements unless specifically relevant to the detected theme. Exclude any logos, watermarks, channel badges or branding marks. Do not render channel names or corner marks."\n\n⚠️ CRÍTICO: Estas instruções de exclusão são OBRIGATÓRIAS e devem ser incluídas em TODAS as descrições de thumbnail, independentemente do prompt padrão usado.\n` : ''}

DEVE começar com: "${getStyleSpecificPrompt(style, includePhrases)}" ${hasStandardPrompt ? `e APLICAR o estilo visual do PROMPT PADRÃO acima ao título "${selectedTitle}", mantendo todos os elementos de estilo (composição, cores, tipografia, iluminação, atmosfera) mas adaptando o conteúdo ao tema do título.` : 'e aplicar as regras de thumbnail viral identificadas acima de forma EXPLÍCITA.'}

Retorne APENAS JSON válido:
{
  "ideias": [
    {
      "seoDescription": "Descrição completa e otimizada...",
      "seoTags": ["tag1", "tag2", ...],
      "frasesDeGancho": ${includePhrases ? '["Frase 1", "Frase 2", "Frase 3", "Frase 4", "Frase 5"]' : '[]'},
      "descricaoThumbnail": "Ultra-high-definition (8K) professional photograph... ${includePhrases ? '[FRASE DE GANCHO AQUI]' : ''}..."
    },
    {
      "seoDescription": "Outra descrição completa e otimizada...",
      "seoTags": ["tagA", "tagB", ...],
      "frasesDeGancho": ${includePhrases ? '["Outra 1", "Outra 2", "Outra 3", "Outra 4", "Outra 5"]' : '[]'},
      "descricaoThumbnail": "Ultra-high-definition (8K) professional photograph... ${includePhrases ? '[FRASE DE GANCHO AQUI]' : ''}..."
    }
  ]
}`;

        // Chamar API apropriada
        let response;
        if (useLaozhang) {
            response = await callLaozhangAPI(
                thumbPrompt,
                apiKeyToUse,
                modelForAPI,
                videoDetails.thumbnailUrl,
                userId,
                '/api/analyze/thumbnail/laozhang',
                JSON.stringify({ endpoint: '/api/analyze/thumbnail/laozhang', model: modelForAPI })
            );
            // callLaozhangAPI retorna string diretamente
            response = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        } else {
            // Preparar imagens adicionais (thumbnails de referência)
            const additionalImages = thumbnailReferences.map(ref => ref.thumbnail_base64).filter(Boolean);
            
            // Chamar API apropriada com múltiplas imagens
            if (serviceToUse === 'claude') {
                response = await callClaudeAPI(thumbPrompt, apiKeyToUse, modelForAPI, videoDetails.thumbnailUrl, null, additionalImages);
            } else if (serviceToUse === 'openai') {
                response = await callOpenAIAPI(thumbPrompt, apiKeyToUse, modelForAPI, videoDetails.thumbnailUrl, additionalImages);
            } else if (serviceToUse === 'gemini') {
                response = await callGeminiAPI(thumbPrompt, apiKeyToUse, modelForAPI, videoDetails.thumbnailUrl, additionalImages);
            } else {
                response = await apiCallFunction(thumbPrompt, apiKeyToUse, modelForAPI, videoDetails.thumbnailUrl);
            }
            
            // APIs próprias retornam objeto com propriedade titles
            if (response && typeof response === 'object' && response.titles) {
                response = response.titles;
            }
        }

        // Parsear resposta usando função robusta existente
        let parsedData;
        const rawResponse = typeof response === 'string' ? response : JSON.stringify(response);
        
        try {
            // Usar a função parseAIResponse que já tem tratamento robusto para JSON malformado
            parsedData = parseAIResponse(rawResponse, 'Thumbnail Laozhang');
            
            // Verificar se o JSON tem a estrutura esperada
            if (!parsedData || typeof parsedData !== 'object') {
                throw new Error('Resposta da IA não retornou um objeto JSON válido.');
            }
            
            // Verificar se tem "ideias" no objeto parseado
            if (!parsedData.ideias) {
                throw new Error('Resposta da IA não contém o campo "ideias" esperado.');
            }
        } catch (e) {
            console.log('[Thumbnail Laozhang] Erro no parse inicial, tentando extrair JSON completo...');
            
            // Tentar extrair JSON completo usando contagem de chaves
            try {
                // Primeiro, encontrar onde está "ideias"
                const ideiasIndex = rawResponse.indexOf('"ideias"');
                if (ideiasIndex === -1) {
                    throw new Error('Campo "ideias" não encontrado na resposta.');
                }
                
                // Encontrar o início do objeto que contém "ideias" (procurar para trás)
                let objStart = rawResponse.lastIndexOf('{', ideiasIndex);
                if (objStart === -1) {
                    // Se não encontrou, tentar encontrar qualquer { antes de "ideias"
                    objStart = rawResponse.indexOf('{');
                }
                
                if (objStart !== -1) {
                    // Extrair JSON completo a partir do objeto encontrado
                    const jsonFromStart = extractCompleteJson(rawResponse.substring(objStart));
                    if (jsonFromStart) {
                        const fixedJson = fixJsonWithUnescapedNewlines(jsonFromStart);
                        parsedData = JSON.parse(fixedJson);
                        console.log('[Thumbnail Laozhang] ✅ JSON extraído e parseado com sucesso usando contagem de chaves');
                    } else {
                        throw new Error('Não foi possível extrair JSON completo usando contagem de chaves.');
                    }
                } else {
                    throw new Error('Não foi possível encontrar início do objeto JSON.');
                }
            } catch (extractError) {
                console.error('[Thumbnail Laozhang] Erro ao extrair JSON:', extractError.message);
                console.error('[Thumbnail Laozhang] Erro original:', e.message);
                console.error('[Thumbnail Laozhang] Resposta (primeiros 2000 chars):', rawResponse.substring(0, 2000));
                throw new Error(`Erro ao processar resposta da IA: ${e.message}. Tentativa de extração também falhou: ${extractError.message}`);
            }
        }

        if (!parsedData.ideias || !Array.isArray(parsedData.ideias) || parsedData.ideias.length === 0) {
            throw new Error("A IA não retornou o array 'ideias' esperado.");
        }

        // Validar e processar dados antes de enviar (mesma lógica da rota principal)
        // Nota: A ambientação já foi calculada anteriormente (linhas 16960-16986) e as variáveis estão disponíveis:
        // ambientacaoArr, elementosArr, acessoriosCalc, personagemCalc, ambientacaoCalc, elementosDeFundoCalc

        if (parsedData.ideias && Array.isArray(parsedData.ideias)) {
            parsedData.ideias = parsedData.ideias.map((idea, index) => {
                // Validar tags - limitar a 300 caracteres
                if (idea.seoTags && Array.isArray(idea.seoTags)) {
                    let tagsString = idea.seoTags.join(', ');
                    if (tagsString.length > 300) {
                        // Reduzir tags até ficar dentro do limite
                        let reducedTags = [];
                        let currentLength = 0;
                        for (const tag of idea.seoTags) {
                            const tagWithComma = reducedTags.length > 0 ? ', ' + tag : tag;
                            if (currentLength + tagWithComma.length <= 300) {
                                reducedTags.push(tag);
                                currentLength += tagWithComma.length;
                            } else {
                                break;
                            }
                        }
                        idea.seoTags = reducedTags;
                        console.log(`[Thumbnail Laozhang] Tags reduzidas para respeitar limite de 300 caracteres`);
                    }
                }
                
                // Validar frases de gancho - garantir que estejam no idioma correto
                if (idea.frasesDeGancho && Array.isArray(idea.frasesDeGancho) && includePhrases) {
                    const isPortuguese = language === 'Português';
                    const isSpanish = language === 'Espanhol';
                    const portugueseWords = ['que', 'não', 'você', 'com', 'para', 'mais', 'muito', 'isso', 'aqui', 'agora', 'também', 'sempre', 'depois', 'antes', 'ainda', 'então', 'assim', 'mesmo', 'todo', 'toda', 'todos', 'todas', 'ele', 'ela', 'eles', 'elas'];
                    const spanishWords = ['que', 'no', 'tú', 'con', 'para', 'más', 'muy', 'esto', 'aquí', 'ahora', 'también', 'siempre', 'después', 'antes', 'aún', 'entonces', 'así', 'mismo', 'todo', 'toda', 'todos', 'todas', 'él', 'ella', 'ellos', 'ellas'];
                    
                    idea.frasesDeGancho = idea.frasesDeGancho.map(frase => {
                        if (!frase || typeof frase !== 'string') return frase;
                        const fraseLower = frase.toLowerCase();
                        let needsTranslation = false;
                        
                        if (isPortuguese && !portugueseWords.some(word => fraseLower.includes(word)) && (fraseLower.includes('the ') || fraseLower.includes(' a ') || fraseLower.includes('this '))) {
                            needsTranslation = true;
                        } else if (isSpanish && !spanishWords.some(word => fraseLower.includes(word)) && (fraseLower.includes('the ') || fraseLower.includes(' a ') || fraseLower.includes('this '))) {
                            needsTranslation = true;
                        }
                        
                        if (needsTranslation) {
                            console.warn(`[Thumbnail Laozhang] Frase de gancho pode estar no idioma errado: "${frase}" (idioma esperado: ${language})`);
                        }
                        
                        return frase;
                    });
                }
                
                // Modularizar a descricaoThumbnail: aplicar estilo fixo e ambientação dinâmica pelo título
                const baseTemplate = `Generate a historical cinematic thumbnail depicting {PERSONAGEM} wearing {ACESSORIOS} against {AMBIENTE}. Position the subject in the foreground taking up 60% of the frame with an epic background showing {ELEMENTOS_DE_FUNDO}. Use high contrast lighting with gold or cold tones depending on theme and a dramatic sky with storm clouds or environmental effects. The title should be in bold, imposing gold text with a subtle glow effect. The overall mood should be cinematic, realistic and historically significant with ultra-high detail.`;
                let built = baseTemplate
                    .replace('{PERSONAGEM}', personagemCalc)
                    .replace('{ACESSORIOS}', acessoriosCalc || 'authentic period accessories')
                    .replace('{AMBIENTE}', ambientacaoCalc)
                    .replace('{ELEMENTOS_DE_FUNDO}', elementosDeFundoCalc || 'contextual historical elements');
                if (includePhrases) {
                    built += `\nProfessional Photoshop-quality text design displaying [FRASE DE GANCHO AQUI], with multiple layer effects (stroke, drop shadow, outer glow, bevel and emboss), perfect kerning, anti-aliasing, large bold serif gold typography at bottom.`;
                }
                built += `\nExclude mesoamerican pyramids, feathered headdress, conquistadors, Spanish ships unless specifically relevant to the detected theme. CRITICAL - REMOVE ALL CORNER MARKINGS: Exclude any logos, watermarks, channel badges, branding marks, corner icons, decorative elements, or any visual elements in the four corners of the image (top-left, top-right, bottom-left, bottom-right). The image must be completely clean in all four corners.`;
                idea.descricaoThumbnail = built;

                // Calcular score viral baseado no algoritmo do YouTube
                const viralScore = calculateThumbnailViralScore(idea.descricaoThumbnail, index, parsedData.ideias.length);
                idea.viralScore = viralScore;
                
                return idea;
            });
        }

        res.status(200).json(parsedData.ideias);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/analyze/thumbnail/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao gerar ideias de thumbnail.' });
    }
});

// === ROTA PARA GERAR PROMPTS DE CENA ===
app.post('/api/generate/scene-prompts', authenticateToken, async (req, res) => {
    const { script, model, style, imageModel, mode, wordsPerScene, unit, characters, selectedModel, isVO3, expectedScenes } = req.body;
    const userId = req.user.id;
    const forVO3 = isVO3 === true || isVO3 === 'true' || isVO3 === 1; // Suporta boolean, string ou número

    if (!script || !script.trim()) {
        return res.status(400).json({ msg: 'O roteiro é obrigatório.' });
    }

    if (!model) {
        return res.status(400).json({ msg: 'O modelo de IA é obrigatório.' });
    }

    try {
        // Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem plano que permite API própria OU não tem API própria configurada
        // REGRA CRÍTICA: Se preferência NÃO está marcada E usuário tem plano que permite E tem API própria → usar API própria
        let service = 'gemini';
        if (model.includes('claude') || model.includes('sonnet')) {
            service = 'claude';
        } else if (model.includes('gpt') || model.includes('openai')) {
            service = 'openai';
        }

        const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
        let decryptedKey = null;
        let useLaozhang = false;
        let laozhangApiKey = null;

        if (creditsCheck.shouldUse) {
            // Usar créditos (laozhang.ai)
            console.log(`[Scene Prompts] ✅ Usando créditos (${creditsCheck.reason})`);
            laozhangApiKey = await getLaozhangApiKey();
            if (laozhangApiKey) {
                useLaozhang = true;
            } else {
                return res.status(500).json({ msg: 'Sistema de créditos não configurado. Entre em contato com o suporte.' });
            }
        } else {
            // Usar API própria
            console.log(`[Scene Prompts] ✅ Usando API própria (${creditsCheck.reason})`);
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (!keyData) {
                return res.status(400).json({ msg: `Chave de API do ${service} não configurada. Configure nas Configurações.` });
            }

            decryptedKey = decrypt(keyData.api_key);
            if (!decryptedKey) {
                return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
            }
        }

        // Usar o número exato enviado pelo frontend, ou calcular se não foi enviado
        const wordCount = script.trim().split(/\s+/).filter(Boolean).length;
        let estimatedScenes, minScenes, maxScenes;
        
        if (expectedScenes && parseInt(expectedScenes) > 0) {
            // Usar o número exato do frontend
            estimatedScenes = parseInt(expectedScenes);
            minScenes = estimatedScenes;
            maxScenes = estimatedScenes;
            console.log(`[Scene Prompts] Usando número exato do frontend: ${estimatedScenes} cenas`);
        } else {
            // Calcular número estimado de cenas baseado no modo (fallback)
            if (mode === 'manual' && wordsPerScene) {
                const unitType = unit || 'words'; // 'words' ou 'seconds'
                const value = parseInt(wordsPerScene);
                
                if (unitType === 'seconds') {
                    // Modo manual por segundos: assumir ~2.5 palavras por segundo de narração
                    const wordsPerSecond = 2.5;
                    const wordsPerInterval = value * wordsPerSecond;
                    estimatedScenes = Math.max(1, Math.round(wordCount / wordsPerInterval));
                    minScenes = Math.max(1, Math.floor(wordCount / (wordsPerInterval * 1.4)));
                    maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / (wordsPerInterval * 0.6)));
                } else {
                    // Modo manual: baseado em palavras por cena
                    estimatedScenes = Math.max(1, Math.round(wordCount / value));
                    minScenes = Math.max(1, Math.floor(wordCount / (value * 1.4)));
                    maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / (value * 0.6)));
                }
            } else {
                // Modo automático: 1 cena a cada ~90 palavras
                estimatedScenes = Math.max(1, Math.round(wordCount / 90));
                minScenes = Math.max(1, Math.floor(wordCount / 140));
                maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / 60));
            }
        }

        // ============================================
        // CAMADA 1: ÂNCORA VISUAL GLOBAL (VERSÃO DEFINITIVA FINAL)
        // ============================================
        // REGRA DE OURO: Se uma cena parecer que poderia ser uma foto real, ela está errada.
        // Ela precisa parecer uma miniatura filmada, não uma pessoa filmada.
        // Este texto nunca muda. Nunca.
        const GLOBAL_VISUAL_ANCHOR = `
🧩 GLOBAL VISUAL IDENTITY — LOCKED:

The entire story exists inside a cinematic narrative diorama.
All environments are handcrafted miniature scale models,
the world feels like a physical maquette filmed up close.

All characters, including close-ups and portraits,
must appear as stylized sculpted figures,
never as real human faces.

All faces must retain a sculpted, physical miniature appearance.
No natural photographic skin softness.
Faces should look like crafted figures, not real people,
even in close-up shots.

Consistent semi-stylized realism across all scenes,
no photorealistic skin, no natural human softness.

Matte materials, handcrafted textures,
subtle imperfections, physical model feel.

Cinematic depth of field,
controlled perspective,
subtle tilt-shift to reinforce miniature scale.

Every frame must look like a frozen cinematic moment
from the same miniature world.

⚠️ This text NEVER changes. NEVER.
⚠️ If a scene looks like it could be a real photograph, it's wrong.
⚠️ It must look like a filmed miniature, not a filmed person.

🚫 NEGATIVE PROMPT — ÚLTIMO REFORÇO:
photorealistic humans,
hyper-detailed skin,
real-world full scale environments,
life-size architecture,
photographic realism,
cinema movie still look,
video game graphics,
cartoon style,
anime style,
plastic or glossy materials,
stop-motion puppets,
toy-like exaggeration,
full-scale real world,
wide open real locations,
global illumination,
neutral camera angles,
real human skin texture,
natural photographic portrait,
beauty photography lighting,
hyper-smooth faces,
ultra-real close-up photography,
photographic portrait,
beauty photography,
natural skin translucency,
cinema realism close-up

⚠️ If any of these appear visually, the scene has failed.

WHAT CAN VARY (WITHOUT BREAKING STYLE):
✅ Lighting (warm / cold)
✅ Time of day
✅ Emotion
✅ Action
✅ Narrative framing

WHAT NEVER VARIES:
❌ Scale
❌ Character type (always stylized sculpted figures)
❌ Material (always matte, handcrafted)
❌ Camera language (always story-driven)
❌ Realism level (always semi-stylized, never photorealistic)

SCENE VALIDATION CHECKLIST (ALL MUST BE YES):
- Does it look like a physical miniature?
- Could it fit on a table?
- Do people look like sculpted figures, not actors?
- Do close-ups look like stylized sculptures, not real faces?
- Does light look controlled, not randomly natural?
- Does it look like a frame from the same film as all others?

If any answer is NO → regenerate the scene.

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "as if filmed inside a handcrafted scale model"
- "the environment feels like a physical miniature set"
- "miniature world with cinematic lighting"
`;

        // ============================================
        // CAMADA 2: ESTILO (MODIFICADORES)
        // ============================================
        // O estilo apenas modula iluminação, contraste, paleta, mood
        // NÃO pode alterar: tipo de personagem, escala, câmera, realismo
        const styleModifiers = {
            'photorealistic': 'High contrast lighting, sharp focus, professional photography aesthetic, saturated colors.',
            'cinematic': 'Dramatic cinematic lighting, low-key illumination, strong shadows, emotional tension, film-like contrast, controlled color palette.',
            'cinematic-diorama': 'Dramatic cinematic lighting with practical light sources, low-key illumination, strong volumetric shadows, emotional storytelling atmosphere, warm color palette with desaturated shadows.',
            'documentary': 'Natural lighting, authentic moments, journalistic approach, realistic color grading.',
            'cinematic-narrative': 'Story-driven lighting, emotional depth, narrative composition, dramatic shadows.',
            'anime': 'Vibrant colors, expressive lighting, high saturation, dynamic contrast.',
            'cartoon': 'Colorful palette, expressive lighting, high contrast, playful mood.',
            'cartoon-premium': 'Premium animation quality, sophisticated color palette, professional lighting.',
            'fantasy': 'Magical lighting, epic atmosphere, enchanted color palette, mystical elements.',
            'stick-figure': 'Minimalist lighting, simple lines, white background, clean aesthetic.',
            'whiteboard': 'Clean educational lighting, hand-drawn illustrations, minimalist aesthetic.',
            'tech-minimalist': 'Modern clean lighting, futuristic aesthetic, minimalist design.',
            'spiritual-minimalist': 'Serene lighting, meditative atmosphere, zen aesthetic, soft illumination.',
            'viral-vibrant': 'High contrast, saturated colors, social media optimized, vibrant palette.',
            'modern-documentary': 'Dynamic contemporary lighting, authentic moments, modern color grading.',
            'analog-horror': 'VHS quality grain, retro horror aesthetic, low-fi texture, analog degradation.',
            'dark-theater': 'Dramatic stage lighting, intense shadows, theatrical illumination.',
            'naturalist-drama': 'Realistic emotional lighting, authentic human moments, natural color palette.',
            'spiritual-neorealism': 'Transcendent realistic lighting, mystical atmosphere, spiritual color grading.',
            'psychological-surrealism': 'Dreamlike lighting, abstract reality, surreal color palette.',
            'fragmented-memory': 'Collage aesthetic, fragmented composition, layered lighting.',
            'fragmented-narrative': 'Fragmented narrative style, collage composition, layered visual narrative.',
            'dream-real': 'Liminal space lighting, ethereal atmosphere, dream-reality blend.',
            'vhs-nostalgic': 'VHS nostalgic aesthetic, retro 80s/90s quality, vintage grain, analog texture.'
        };
        
        // Modificador adicional opcional para refinar ainda mais o estilo
        const styleModifier = style && style !== 'none' && styleModifiers[style] 
            ? `\n\n🎨 REFINAMENTO DE ESTILO (${style}):\n${styleModifiers[style]}\n\n⚠️ Este refinamento complementa a Âncora Visual Global acima, ajustando detalhes de iluminação, contraste e paleta de cores.` 
            : '';
        const imageModelInstruction = imageModel ? ` Os prompts devem ser otimizados para ${imageModel}.` : '';
        const charactersInstruction = characters ? `\n\nPERSONAGENS CONSISTENTES:\n${characters}\n\nIMPORTANTE: Use essas descrições de personagens de forma consistente em todas as cenas onde eles aparecerem.` : '';
        
        // Instruções específicas para VO3
        const vo3Instructions = forVO3 ? `
        
⚠️⚠️⚠️ MODO VO3 ATIVADO - OTIMIZAÇÃO PARA GERAÇÃO DE VÍDEO ⚠️⚠️⚠️
Os prompts devem ser OTIMIZADOS ESPECIFICAMENTE para o modelo VO3 (geração de vídeo).

REGRAS CRÍTICAS PARA VO3:
1. MOVIMENTO E AÇÃO: Cada prompt DEVE descrever movimento, ação ou transição. VO3 precisa de elementos dinâmicos para gerar vídeo fluido.
   - Use verbos de ação: "walking", "running", "flying", "rotating", "approaching", "receding", "panning", "zooming"
   - Descreva direção de movimento: "from left to right", "approaching camera", "flying away", "spinning clockwise"
   - Inclua transições: "fade in", "slow reveal", "gradual zoom", "smooth pan"

2. SFX (EFEITOS SONOROS) EMBUTIDOS: Cada prompt DEVE incluir descrições de efeitos sonoros relevantes para a cena, usando a sintaxe: [SFX: descrição do som]
   - Exemplos: [SFX: distant explosion, rumbling], [SFX: footsteps on gravel, crunching], [SFX: wind howling, atmospheric], [SFX: engine revving, mechanical], [SFX: water splashing, liquid], [SFX: door creaking, wooden], [SFX: birds chirping, nature], [SFX: crowd murmuring, ambient], [SFX: glass breaking, shattering], [SFX: thunder rumbling, weather]
   - Inclua SFX que faça sentido para a ação visual descrita
   - Use 1-3 SFX por cena, dependendo da complexidade
   - SFX deve estar ENTRE PARÊNTESES QUADRADOS no formato [SFX: nome do som, categoria]

3. DURAÇÃO E RITMO: Indique o ritmo/tempo da cena quando relevante
   - "slow motion", "time-lapse", "real-time", "fast-paced", "leisurely pace"

4. CONTINUIDADE VISUAL: Mantenha consistência entre cenas consecutivas
   - Se uma cena termina com um personagem à esquerda, a próxima pode começar com ele à direita (mostrando movimento)
   - Descreva posições relativas que permitam transições suaves

5. ELEMENTOS CINEMATOGRÁFICOS PARA VÍDEO:
   - Movimentos de câmera: "camera panning left", "dolly forward", "crane shot rising", "handheld following"
   - Profundidade dinâmica: "foreground elements moving", "background parallax", "layered movement"
   - Mudanças de foco: "rack focus from A to B", "shallow focus transitioning"

FORMATO DO PROMPT PARA VO3:
Cada prompt_text deve seguir este padrão:
"[Descrição visual detalhada com movimento e ação] [SFX: som1, categoria1] [SFX: som2, categoria2] [Movimento de câmera] [Ritmo/tempo]"

EXEMPLO DE PROMPT VO3:
"Aerial view of a military helicopter flying low over a desert landscape, rotor blades spinning rapidly, dust clouds trailing behind, camera tracking the helicopter from behind and slightly above, smooth forward motion, golden hour lighting casting long shadows, [SFX: helicopter rotor blades, mechanical] [SFX: wind rushing, atmospheric] [SFX: distant engine roar, vehicle] - fast-paced action sequence, dynamic camera movement"` : '';

        const prompt = `${GLOBAL_VISUAL_ANCHOR}${styleModifier}

Você é um especialista em criação de prompts para ${forVO3 ? 'geração de vídeo (VO3)' : 'geração de imagens'} usando IA.

TAREFA:
Analise o roteiro fornecido e crie prompts detalhados para cada cena do vídeo. Cada prompt deve descrever visualmente o que deve aparecer ${forVO3 ? 'no vídeo' : 'na imagem'} para aquela parte do roteiro.${vo3Instructions}

ROTEIRO:
"""
${script}
"""

INSTRUÇÕES:
1. 🔒 OBRIGATÓRIO: TODAS as cenas DEVEM seguir a ÂNCORA VISUAL GLOBAL acima. Esta é a base visual definida pelo estilo escolhido (${selectedStyle}).
2. 🎨 O estilo "${selectedStyle}" foi selecionado pelo usuário. TODOS os prompts devem seguir este estilo visual consistentemente.
3. ⚠️⚠️⚠️ CRÍTICO - NÚMERO EXATO DE CENAS ⚠️⚠️⚠️: Você DEVE gerar EXATAMENTE ${estimatedScenes} cenas. NÃO mais, NÃO menos. O frontend espera ${estimatedScenes} cenas e você DEVE entregar todas elas. Se a resposta ficar muito longa, continue mesmo assim. É OBRIGATÓRIO gerar todas as ${estimatedScenes} cenas.
4. Cada prompt deve ter entre ${forVO3 ? '800-1500' : '600-1200'} caracteres${forVO3 ? ' (VO3 precisa de mais detalhes para movimento e SFX)' : ''}
5. Cada prompt deve ser em INGLÊS e otimizado para ${forVO3 ? 'geração de vídeo (VO3)' : 'geração de imagens'}
6. Seja específico e detalhado: descreva composição, iluminação, cores, atmosfera, personagens, cenário${forVO3 ? ', movimento, ação, transições e efeitos sonoros' : ''}
7. Use termos técnicos de fotografia/cinematografia quando apropriado${imageModelInstruction}${charactersInstruction}
8. ⚠️ CRÍTICO: Cada prompt_text DEVE incluir os elementos da Âncora Visual Global. Não gere cenas com estética diferente (stop-motion, realismo fotográfico, cartoon, game, etc.). Todas as cenas devem pertencer ao mesmo mundo visual.
9. 🔧 REFORÇO DE ESCALA: Cada prompt_text DEVE incluir UMA das frases de reforço (alternando entre cenas):
   - "as if filmed inside a handcrafted scale model"
   - "the environment feels like a physical miniature set"
   - "miniature world with cinematic lighting"
   Alternar entre essas três frases para evitar repetição óbvia, mas sempre incluir uma delas para reforçar a escala de miniatura.

FORMATO DE RESPOSTA (JSON):
{
  "scenes": [
    {
      "scene_number": 1,
      "scene_description": "Breve descrição da cena em português",
      "prompt_text": "Prompt detalhado em inglês para ${forVO3 ? 'geração de vídeo VO3 com SFX embutido' : 'geração de imagem'} (${forVO3 ? '800-1500' : '600-1200'} caracteres)${forVO3 ? ' - DEVE incluir [SFX: ...] e descrições de movimento' : ''}"
    },
    {
      "scene_number": 2,
      "scene_description": "Breve descrição da cena em português",
      "prompt_text": "Prompt detalhado em inglês para ${forVO3 ? 'geração de vídeo VO3 com SFX embutido' : 'geração de imagem'} (${forVO3 ? '800-1500' : '600-1200'} caracteres)${forVO3 ? ' - DEVE incluir [SFX: ...] e descrições de movimento' : ''}"
    }
  ]
}

IMPORTANTE:
- Responda APENAS com o JSON válido, sem texto adicional
- Certifique-se de que cada prompt_text tem entre ${forVO3 ? '800-1500' : '600-1200'} caracteres
${forVO3 ? '- TODOS os prompts DEVE incluir pelo menos 1-3 SFX no formato [SFX: nome do som, categoria]\n- TODOS os prompts DEVE descrever movimento, ação ou transição para VO3\n' : ''}
⚠️⚠️⚠️ REGRA ABSOLUTA - NÚMERO DE CENAS ⚠️⚠️⚠️:
- Você DEVE gerar EXATAMENTE ${estimatedScenes} cenas. NÃO ${minScenes}, NÃO ${maxScenes}, mas EXATAMENTE ${estimatedScenes} cenas.
- O JSON DEVE conter um array "scenes" com EXATAMENTE ${estimatedScenes} objetos.
- NÃO pare antes de gerar todas as ${estimatedScenes} cenas, mesmo que a resposta fique muito longa.
- Se você gerar menos de ${estimatedScenes} cenas, a resposta será considerada INCOMPLETA e REJEITADA.
- O roteiro tem ${wordCount} palavras, o que justifica ${estimatedScenes} cenas. Gere TODAS elas.
- Comece pela cena 1 e continue até a cena ${estimatedScenes}. NÃO pule nenhuma cena.
- É CRÍTICO e OBRIGATÓRIO que o array "scenes" tenha EXATAMENTE ${estimatedScenes} elementos.`;

        let apiCallFunction;
        let response;
        
        if (useLaozhang && laozhangApiKey) {
            // Usar créditos (laozhang.ai)
            console.log(`[Scene Prompts] Gerando prompts com laozhang.ai (créditos) - modelo: ${model}... (timeout: ${scenePromptsTimeout/1000}s)`);
            // Passar o timeout calculado no operationType para o callLaozhangAPI ajustar
            response = await callLaozhangAPI(prompt, laozhangApiKey, model, null, userId, '/api/generate/scene-prompts', JSON.stringify({ endpoint: '/api/generate/scene-prompts', model, estimatedScenes, timeout: scenePromptsTimeout }));
        } else {
            // Usar API própria
            if (service === 'gemini') {
                apiCallFunction = callGeminiAPI;
                response = await apiCallFunction(prompt, decryptedKey, model);
            } else if (service === 'claude') {
                console.log(`[Scene Prompts] Gerando prompts com ${service} (API própria) - modelo: ${model}... (timeout: ${scenePromptsTimeout/1000}s)`);
                response = await callClaudeAPI(prompt, decryptedKey, model, null, scenePromptsTimeout);
            } else {
                apiCallFunction = callOpenAIAPI;
                response = await apiCallFunction(prompt, decryptedKey, model);
            }
            
            if (!response) {
                console.log(`[Scene Prompts] Gerando prompts com ${service} (API própria) - modelo: ${model}...`);
            }
        }

        // Parsear resposta
        let scenesData;
        let rawResponse = response;
        
        if (typeof response === 'string') {
            rawResponse = response.trim();
        } else {
            rawResponse = JSON.stringify(response);
        }
        
        console.log('[Scene Prompts] Resposta bruta (primeiros 1000 chars):', rawResponse.substring(0, 1000));
        
        // Verificar se a API recusou a requisição (apenas se for uma mensagem de erro clara, não JSON válido)
        // Primeiro, tentar verificar se há JSON válido na resposta
        const hasValidJson = rawResponse.match(/\{[\s\S]*"scenes"[\s\S]*\}/) || rawResponse.match(/\{[\s\S]*"scene_number"[\s\S]*\}/);
        
        // Se não há JSON válido, verificar se é uma mensagem de erro da API
        if (!hasValidJson) {
            const errorPatterns = [
                /^I'm sorry,?\s+I can't assist/i,
                /^I'm sorry,?\s+I cannot/i,
                /^I'm unable to assist/i,
                /^I cannot fulfill/i,
                /^I must decline/i,
                /^I can't help with that/i,
                /^I'm not able to/i,
                /^This request violates/i,
                /^I cannot comply/i
            ];
            
            const trimmedResponse = rawResponse.trim();
            const isError = errorPatterns.some(pattern => pattern.test(trimmedResponse));
            
            // Também verificar se é uma resposta muito curta (menos de 100 chars) que começa com mensagem de erro
            if (isError || (trimmedResponse.length < 100 && trimmedResponse.toLowerCase().startsWith("i'm sorry"))) {
                console.error('[Scene Prompts] API recusou a requisição:', rawResponse.substring(0, 500));
                throw new Error(`A API de IA recusou processar o prompt. Isso pode acontecer se o conteúdo violar as políticas de uso da API. Tente simplificar o roteiro ou remover conteúdo sensível. Resposta: ${rawResponse.substring(0, 500)}`);
            }
        }
        
        // Tentar parsear diretamente
        try {
            scenesData = JSON.parse(rawResponse);
        } catch (e) {
            console.log('[Scene Prompts] Tentativa 1 de parsing falhou, tentando extrair JSON...');
            
            // Tentar extrair JSON usando regex mais robusto
            const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    scenesData = JSON.parse(jsonMatch[0]);
                } catch (e2) {
                    console.log('[Scene Prompts] Tentativa 2 de parsing falhou, tentando corrigir JSON...');
                    
                    // Tentar corrigir JSON comum (remover markdown, code blocks, etc)
                    let cleanedJson = jsonMatch[0]
                        .replace(/```json\s*/g, '')
                        .replace(/```\s*/g, '')
                        .replace(/^[^{]*/, '')
                        .replace(/[^}]*$/, '');
                    
                    try {
                        scenesData = JSON.parse(cleanedJson);
                    } catch (e3) {
                        console.log('[Scene Prompts] Tentativa 3 de parsing falhou, tentando extrair scenes diretamente...');
                        
                        // Última tentativa: procurar por "scenes" no texto
                        const scenesMatch = rawResponse.match(/"scenes"\s*:\s*\[[\s\S]*\]/);
                        if (scenesMatch) {
                            try {
                                scenesData = JSON.parse(`{${scenesMatch[0]}}`);
                            } catch (e4) {
                                console.error('[Scene Prompts] Erro no parsing:', e4.message);
                                throw new Error(`Resposta da IA não contém JSON válido. Erro: ${e4.message}`);
                            }
                        } else {
                            throw new Error(`Resposta da IA não contém JSON válido. Primeiros 500 caracteres: ${rawResponse.substring(0, 500)}`);
                        }
                    }
                }
            } else {
                throw new Error(`Nenhum JSON encontrado na resposta. Primeiros 500 caracteres: ${rawResponse.substring(0, 500)}`);
            }
        }

        // Validar estrutura - verificar se há campos aninhados (como "titles" contendo JSON string)
        if (!scenesData) {
            throw new Error('Resposta da IA está vazia ou inválida.');
        }
        
        // Se a resposta tem um campo que contém JSON string, parsear novamente
        if (scenesData.titles && typeof scenesData.titles === 'string') {
            try {
                const parsedTitles = JSON.parse(scenesData.titles);
                if (parsedTitles.scenes) {
                    scenesData = parsedTitles;
                }
            } catch (e) {
                console.log('[Scene Prompts] Campo titles não é JSON válido, continuando...');
            }
        }
        
        // Se a resposta tem um campo que contém JSON string em outro formato
        if (scenesData.content && typeof scenesData.content === 'string') {
            try {
                const parsedContent = JSON.parse(scenesData.content);
                if (parsedContent.scenes) {
                    scenesData = parsedContent;
                }
            } catch (e) {
                console.log('[Scene Prompts] Campo content não é JSON válido, continuando...');
            }
        }
        
        // Verificar se scenes existe diretamente ou em algum nível aninhado
        if (!scenesData.scenes) {
            // Procurar em todos os níveis
            const findScenes = (obj) => {
                if (Array.isArray(obj)) {
                    return obj;
                }
                if (typeof obj === 'object' && obj !== null) {
                    if (obj.scenes && Array.isArray(obj.scenes)) {
                        return obj.scenes;
                    }
                    for (const key in obj) {
                        const found = findScenes(obj[key]);
                        if (found) return found;
                    }
                }
                return null;
            };
            
            const foundScenes = findScenes(scenesData);
            if (foundScenes) {
                scenesData = { scenes: foundScenes };
            } else {
                console.error('[Scene Prompts] Estrutura de resposta inválida:', JSON.stringify(scenesData).substring(0, 1000));
                throw new Error('A IA não retornou a estrutura esperada. Verifique se a resposta contém um campo "scenes".');
            }
        }
        
        if (!Array.isArray(scenesData.scenes)) {
            console.error('[Scene Prompts] Campo scenes não é array:', typeof scenesData.scenes);
            throw new Error('O campo "scenes" da resposta não é um array válido.');
        }
        
        if (scenesData.scenes.length === 0) {
            throw new Error('A IA retornou um array de cenas vazio. Tente novamente com um roteiro mais detalhado.');
        }
        
        // Validar cada cena
        const validScenes = scenesData.scenes.filter(scene => 
            scene && 
            (scene.prompt_text || scene.prompt || scene.text) &&
            (scene.scene_description || scene.description || scene.scene_number || scene.number)
        );
        
        if (validScenes.length === 0) {
            throw new Error('Nenhuma cena válida encontrada na resposta da IA. Verifique o formato esperado.');
        }
        
        // Normalizar estrutura das cenas
        scenesData.scenes = validScenes.map((scene, index) => ({
            scene_number: scene.scene_number || scene.number || index + 1,
            scene_description: scene.scene_description || scene.description || `Cena ${index + 1}`,
            prompt_text: scene.prompt_text || scene.prompt || scene.text || ''
        }));
        
        console.log(`[Scene Prompts] ✅ ${scenesData.scenes.length} cenas parseadas com sucesso!`);
        
        // Verificar se gerou todas as cenas esperadas e tentar gerar as faltantes até completar
        let totalAttempts = 0;
        const maxTotalAttempts = 5; // Máximo de 5 tentativas totais para gerar todas as cenas
        
        while (scenesData.scenes.length < estimatedScenes && totalAttempts < maxTotalAttempts) {
            const missingScenes = estimatedScenes - scenesData.scenes.length;
            console.warn(`[Scene Prompts] ⚠️ Apenas ${scenesData.scenes.length} cenas foram geradas, mas esperávamos ${estimatedScenes} cenas. Faltam ${missingScenes} cenas. Tentativa ${totalAttempts + 1}/${maxTotalAttempts}...`);
            
            // Tentar gerar as cenas faltantes usando a função de retry
            try {
                let apiCallFunction;
                if (useLaozhang && laozhangApiKey) {
                    apiCallFunction = (prompt, key, model) => callLaozhangAPI(prompt, key, model, null, userId, '/api/generate/scene-prompts', JSON.stringify({ endpoint: '/api/generate/scene-prompts', model }));
                } else if (service === 'gemini') {
                    apiCallFunction = callGeminiAPI;
                } else if (service === 'claude') {
                    // Usar o timeout calculado anteriormente (scenePromptsTimeout)
                    apiCallFunction = (prompt, key, model) => callClaudeAPI(prompt, key, model, null, scenePromptsTimeout);
                } else {
                    apiCallFunction = callOpenAIAPI;
                }
                
                const additionalScenes = await generateScenesWithRetries({
                    apiFunc: apiCallFunction,
                    apiKey: useLaozhang ? laozhangApiKey : decryptedKey,
                    model: model,
                    script: script,
                    styleInstruction: styleModifier,
                    imageModelInstruction: imageModelInstruction,
                    charactersInstruction: charactersInstruction,
                    estimatedScenes: missingScenes,
                    minScenes: missingScenes, // Exigir exatamente o número faltante
                    maxScenes: missingScenes, // Exigir exatamente o número faltante
                    wordCount: wordCount,
                    serviceLabel: useLaozhang ? 'Laozhang' : service,
                    maxAttempts: 3
                });
                
                if (additionalScenes && additionalScenes.length > 0) {
                    // Ajustar números das cenas para continuar a sequência
                    const lastSceneNumber = scenesData.scenes.length;
                    additionalScenes.forEach((scene, idx) => {
                        scene.scene_number = lastSceneNumber + idx + 1;
                    });
                    scenesData.scenes = scenesData.scenes.concat(additionalScenes);
                    console.log(`[Scene Prompts] ✅ ${additionalScenes.length} cenas adicionais geradas! Total: ${scenesData.scenes.length}/${estimatedScenes} cenas.`);
                } else {
                    console.warn(`[Scene Prompts] ⚠️ Nenhuma cena adicional foi gerada nesta tentativa.`);
                }
            } catch (retryError) {
                console.error(`[Scene Prompts] Erro ao tentar gerar cenas faltantes:`, retryError.message);
            }
            
            totalAttempts++;
            
            // Se ainda faltam cenas mas já tentamos várias vezes, parar para evitar loop infinito
            if (scenesData.scenes.length < estimatedScenes && totalAttempts >= maxTotalAttempts) {
                console.warn(`[Scene Prompts] ⚠️ Atingido limite de tentativas (${maxTotalAttempts}). Geradas ${scenesData.scenes.length}/${estimatedScenes} cenas.`);
                break;
            }
        }
        
        if (scenesData.scenes.length < estimatedScenes) {
            console.warn(`[Scene Prompts] ⚠️ Apenas ${scenesData.scenes.length} cenas foram geradas, mas esperávamos ${estimatedScenes} cenas.`);
        } else {
            console.log(`[Scene Prompts] ✅ Todas as ${estimatedScenes} cenas foram geradas com sucesso!`);
        }

        // Função auxiliar para limpar nome do modelo (remover fornecedores)
        const cleanModelName = (model) => {
            if (!model) return 'GPT-4o';
            let clean = String(model)
                .replace(/laozhang\.ai/gi, '')
                .replace(/laozhang/gi, '')
                .replace(/openai/gi, '')
                .replace(/anthropic/gi, '')
                .replace(/google/gi, '')
                .trim();
            clean = clean.replace(/^(laozhang-|claude-|gemini-|gpt-|openai-|anthropic-)/i, '');
            clean = clean.replace(/-(laozhang|claude|gemini|gpt|openai|anthropic)$/i, '');
            // Mapear para nomes amigáveis
            if (clean.includes('gpt-4o')) return 'GPT-4o';
            if (clean.includes('claude-3-7-sonnet') || clean.includes('sonnet-3-7')) return 'Claude 3.7 Sonnet';
            if (clean.includes('claude-sonnet-4') || clean.includes('sonnet-4')) return 'Claude Sonnet 4';
            if (clean.includes('gemini-2.5-pro')) return 'Gemini 2.5 Pro';
            return clean || 'GPT-4o';
        };
        
        // Usar selectedModel se fornecido (modelo selecionado no frontend), senão usar model
        const modelToReturn = cleanModelName(selectedModel || model);
        
        res.json({
            msg: `${scenesData.scenes.length} prompts de cena gerados com sucesso!${scenesData.scenes.length < minScenes ? ` (Esperávamos ${estimatedScenes} cenas, mas apenas ${scenesData.scenes.length} foram geradas. Tente novamente ou use um modelo com maior limite de tokens.)` : ''}`,
            scenes: scenesData.scenes,
            modelUsed: modelToReturn, // Retornar apenas o nome do modelo (sem fornecedor)
            expectedScenes: estimatedScenes,
            generatedScenes: scenesData.scenes.length
        });

    } catch (err) {
        console.error('[Scene Prompts] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar prompts de cena.' });
    }
});

// Rota alternativa que SEMPRE usa Laozhang.ai
app.post('/api/generate/scene-prompts/laozhang', authenticateToken, async (req, res) => {
    const { script, style, imageModel, mode, wordsPerScene, unit, characters, selectedModel, isVO3, expectedScenes } = req.body;
    const userId = req.user.id;
    const forVO3 = isVO3 === true || isVO3 === 'true' || isVO3 === 1; // Suporta boolean, string ou número

    if (!script || !script.trim()) {
        return res.status(400).json({ msg: 'O roteiro é obrigatório.' });
    }

    try {
        // Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem plano que permite API própria OU não tem API própria configurada
        // REGRA CRÍTICA: Se preferência NÃO está marcada E usuário tem plano que permite E tem API própria → usar API própria
        
        // Determinar modelo a partir do selectedModel
        let model = selectedModel || 'gpt-4o';
        let service = 'gemini';
        if (model.includes('claude') || model.includes('sonnet')) {
            service = 'claude';
        } else if (model.includes('gpt') || model.includes('openai')) {
            service = 'openai';
        }
        
        // Determinar ordem de preferência baseado no modelo
        let preferenceOrder = ['claude', 'openai', 'gemini'];
        if (service === 'gemini') preferenceOrder = ['gemini', 'claude', 'openai'];
        else if (service === 'claude') preferenceOrder = ['claude', 'openai', 'gemini'];
        else if (service === 'openai') preferenceOrder = ['openai', 'claude', 'gemini'];
        
        const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
        
        let useLaozhang = false;
        let apiKeyToUse = null;
        let serviceToUse = null;
        let apiCallFunction = null;
        
        if (creditsCheck.shouldUse) {
            // Se deve usar créditos, usar laozhang.ai
            const laozhangKey = await getLaozhangApiKey();
            if (laozhangKey) {
                useLaozhang = true;
                apiKeyToUse = laozhangKey;
                serviceToUse = 'laozhang';
                apiCallFunction = callLaozhangAPI;
                console.log(`[Scene Prompts] ✅ Usando Laozhang.ai (${creditsCheck.reason})`);
            } else {
                console.warn('[Scene Prompts] ⚠️ Laozhang.ai não configurada, tentando usar APIs próprias do usuário');
            }
        } else {
            console.log(`[Scene Prompts] ✅ Usando API própria (${creditsCheck.reason})`);
        }
        
        // Se não usar laozhang.ai, usar APIs próprias do usuário
        if (!useLaozhang) {
            serviceToUse = service;
            
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (!keyData) {
                return res.status(400).json({ msg: `Chave de API do ${service} não configurada. Configure nas Configurações.` });
            }
            
            apiKeyToUse = decrypt(keyData.api_key);
            if (!apiKeyToUse) {
                return res.status(500).json({ msg: 'Falha ao descriptografar a chave de API.' });
            }
            
            // Calcular uma estimativa segura de cenas PARA timeout (não usar estimatedScenes aqui,
            // porque ele só é inicializado mais abaixo e causava TDZ: "Cannot access 'estimatedScenes' before initialization")
            const wordCountForTimeout = script.trim().split(/\s+/).filter(Boolean).length;
            const estimatedScenesForTimeout = (() => {
                const explicit = parseInt(expectedScenes, 10);
                if (!Number.isNaN(explicit) && explicit > 0) return explicit;
                
                if (mode === 'manual' && wordsPerScene) {
                    const value = parseInt(wordsPerScene, 10);
                    if (!Number.isNaN(value) && value > 0) {
                        const unitType = unit || 'words'; // 'words' ou 'seconds'
                        if (unitType === 'seconds') {
                            // ~2.5 palavras por segundo de narração
                            const wordsPerSecond = 2.5;
                            const wordsPerInterval = value * wordsPerSecond;
                            return Math.max(1, Math.round(wordCountForTimeout / wordsPerInterval));
                        }
                        return Math.max(1, Math.round(wordCountForTimeout / value));
                    }
                }
                
                // Fallback automático: ~1 cena a cada 90 palavras
                return Math.max(1, Math.round(wordCountForTimeout / 90));
            })();
            
            // Calcular timeout dinamicamente baseado no número de cenas esperadas
            // Base: 5 minutos (300s) + 2 segundos por cena adicional acima de 20
            const baseTimeout = 300000; // 5 minutos
            const timeoutPerScene = 2000; // 2 segundos por cena
            const baseScenes = 20;
            const calculatedTimeout = baseTimeout + (Math.max(0, estimatedScenesForTimeout - baseScenes) * timeoutPerScene);
            // Limitar a 20 minutos máximo (1200000ms) para evitar timeouts muito longos
            const scenePromptsTimeout = Math.min(1200000, Math.max(300000, calculatedTimeout));
            
            console.log(`[Scene Prompts] Timeout calculado: ${scenePromptsTimeout/1000}s (${estimatedScenesForTimeout} cenas esperadas)`);
            
            if (service === 'gemini') {
                apiCallFunction = callGeminiAPI;
            } else if (service === 'claude') {
                // Criar wrapper para passar timeout customizado
                apiCallFunction = async (prompt, key, model) => {
                    return await callClaudeAPI(prompt, key, model, null, scenePromptsTimeout);
                };
            } else {
                apiCallFunction = callOpenAIAPI;
            }
        }

        // Usar o número exato enviado pelo frontend, ou calcular se não foi enviado
        const wordCount = script.trim().split(/\s+/).filter(Boolean).length;
        let estimatedScenes, minScenes, maxScenes;
        
        if (expectedScenes && parseInt(expectedScenes) > 0) {
            // Usar o número exato do frontend
            estimatedScenes = parseInt(expectedScenes);
            minScenes = estimatedScenes;
            maxScenes = estimatedScenes;
            console.log(`[Scene Prompts Laozhang] Usando número exato do frontend: ${estimatedScenes} cenas`);
        } else {
            // Calcular número estimado de cenas baseado no modo (fallback)
            if (mode === 'manual' && wordsPerScene) {
                const unitType = unit || 'words'; // 'words' ou 'seconds'
                const value = parseInt(wordsPerScene);
                
                if (unitType === 'seconds') {
                    // Modo manual por segundos: assumir ~2.5 palavras por segundo de narração
                    const wordsPerSecond = 2.5;
                    const wordsPerInterval = value * wordsPerSecond;
                    estimatedScenes = Math.max(1, Math.round(wordCount / wordsPerInterval));
                    minScenes = Math.max(1, Math.floor(wordCount / (wordsPerInterval * 1.4)));
                    maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / (wordsPerInterval * 0.6)));
                } else {
                    // Modo manual: baseado em palavras por cena
                    estimatedScenes = Math.max(1, Math.round(wordCount / value));
                    minScenes = Math.max(1, Math.floor(wordCount / (value * 1.4)));
                    maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / (value * 0.6)));
                }
            } else {
                estimatedScenes = Math.max(1, Math.round(wordCount / 90));
                minScenes = Math.max(1, Math.floor(wordCount / 140));
                maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / 60));
            }
        }

        // ============================================
        // CAMADA 1: ÂNCORA VISUAL GLOBAL (DINÂMICA BASEADA NO ESTILO)
        // ============================================
        // A âncora visual agora é gerada dinamicamente baseada no estilo escolhido pelo usuário
        const selectedStyle = style || 'photorealistic';
        const GLOBAL_VISUAL_ANCHOR = getGlobalVisualAnchor(selectedStyle);

        // ============================================
        // CAMADA 2: ESTILO (MODIFICADORES)
        // ============================================
        // O estilo apenas modula iluminação, contraste, paleta, mood
        // NÃO pode alterar: tipo de personagem, escala, câmera, realismo
        const styleModifiers = {
            'photorealistic': 'High contrast lighting, sharp focus, professional photography aesthetic, saturated colors.',
            'cinematic': 'Dramatic cinematic lighting, low-key illumination, strong shadows, emotional tension, film-like contrast, controlled color palette.',
            'cinematic-diorama': 'Dramatic cinematic lighting with practical light sources, low-key illumination, strong volumetric shadows, emotional storytelling atmosphere, warm color palette with desaturated shadows.',
            'documentary': 'Natural lighting, authentic moments, journalistic approach, realistic color grading.',
            'cinematic-narrative': 'Story-driven lighting, emotional depth, narrative composition, dramatic shadows.',
            'anime': 'Vibrant colors, expressive lighting, high saturation, dynamic contrast.',
            'cartoon': 'Colorful palette, expressive lighting, high contrast, playful mood.',
            'cartoon-premium': 'Premium animation quality, sophisticated color palette, professional lighting.',
            'fantasy': 'Magical lighting, epic atmosphere, enchanted color palette, mystical elements.',
            'stick-figure': 'Minimalist lighting, simple lines, white background, clean aesthetic.',
            'whiteboard': 'Clean educational lighting, hand-drawn illustrations, minimalist aesthetic.',
            'tech-minimalist': 'Modern clean lighting, futuristic aesthetic, minimalist design.',
            'spiritual-minimalist': 'Serene lighting, meditative atmosphere, zen aesthetic, soft illumination.',
            'viral-vibrant': 'High contrast, saturated colors, social media optimized, vibrant palette.',
            'modern-documentary': 'Dynamic contemporary lighting, authentic moments, modern color grading.',
            'analog-horror': 'VHS quality grain, retro horror aesthetic, low-fi texture, analog degradation.',
            'dark-theater': 'Dramatic stage lighting, intense shadows, theatrical illumination.',
            'naturalist-drama': 'Realistic emotional lighting, authentic human moments, natural color palette.',
            'spiritual-neorealism': 'Transcendent realistic lighting, mystical atmosphere, spiritual color grading.',
            'psychological-surrealism': 'Dreamlike lighting, abstract reality, surreal color palette.',
            'fragmented-memory': 'Collage aesthetic, fragmented composition, layered lighting.',
            'fragmented-narrative': 'Fragmented narrative style, collage composition, layered visual narrative.',
            'dream-real': 'Liminal space lighting, ethereal atmosphere, dream-reality blend.',
            'vhs-nostalgic': 'VHS nostalgic aesthetic, retro 80s/90s quality, vintage grain, analog texture.'
        };
        
        // Modificador adicional opcional para refinar ainda mais o estilo
        const styleModifier = style && style !== 'none' && styleModifiers[style] 
            ? `\n\n🎨 REFINAMENTO DE ESTILO (${style}):\n${styleModifiers[style]}\n\n⚠️ Este refinamento complementa a Âncora Visual Global acima, ajustando detalhes de iluminação, contraste e paleta de cores.` 
            : '';
        const imageModelInstruction = imageModel ? ` Os prompts devem ser otimizados para ${imageModel}.` : '';
        const charactersInstruction = characters ? `\n\nPERSONAGENS CONSISTENTES:\n${characters}\n\nIMPORTANTE: Use essas descrições de personagens de forma consistente em todas as cenas onde eles aparecerem.` : '';
        
        // Instruções específicas para VO3 (mesmas da rota principal)
        const vo3Instructions = forVO3 ? `
        
⚠️⚠️⚠️ MODO VO3 ATIVADO - OTIMIZAÇÃO PARA GERAÇÃO DE VÍDEO ⚠️⚠️⚠️
Os prompts devem ser OTIMIZADOS ESPECIFICAMENTE para o modelo VO3 (geração de vídeo).

REGRAS CRÍTICAS PARA VO3:
1. MOVIMENTO E AÇÃO: Cada prompt DEVE descrever movimento, ação ou transição. VO3 precisa de elementos dinâmicos para gerar vídeo fluido.
   - Use verbos de ação: "walking", "running", "flying", "rotating", "approaching", "receding", "panning", "zooming"
   - Descreva direção de movimento: "from left to right", "approaching camera", "flying away", "spinning clockwise"
   - Inclua transições: "fade in", "slow reveal", "gradual zoom", "smooth pan"

2. SFX (EFEITOS SONOROS) EMBUTIDOS: Cada prompt DEVE incluir descrições de efeitos sonoros relevantes para a cena, usando a sintaxe: [SFX: descrição do som]
   - Exemplos: [SFX: distant explosion, rumbling], [SFX: footsteps on gravel, crunching], [SFX: wind howling, atmospheric], [SFX: engine revving, mechanical], [SFX: water splashing, liquid], [SFX: door creaking, wooden], [SFX: birds chirping, nature], [SFX: crowd murmuring, ambient], [SFX: glass breaking, shattering], [SFX: thunder rumbling, weather]
   - Inclua SFX que faça sentido para a ação visual descrita
   - Use 1-3 SFX por cena, dependendo da complexidade
   - SFX deve estar ENTRE PARÊNTESES QUADRADOS no formato [SFX: nome do som, categoria]

3. DURAÇÃO E RITMO: Indique o ritmo/tempo da cena quando relevante
   - "slow motion", "time-lapse", "real-time", "fast-paced", "leisurely pace"

4. CONTINUIDADE VISUAL: Mantenha consistência entre cenas consecutivas
   - Se uma cena termina com um personagem à esquerda, a próxima pode começar com ele à direita (mostrando movimento)
   - Descreva posições relativas que permitam transições suaves

5. ELEMENTOS CINEMATOGRÁFICOS PARA VÍDEO:
   - Movimentos de câmera: "camera panning left", "dolly forward", "crane shot rising", "handheld following"
   - Profundidade dinâmica: "foreground elements moving", "background parallax", "layered movement"
   - Mudanças de foco: "rack focus from A to B", "shallow focus transitioning"

FORMATO DO PROMPT PARA VO3:
Cada prompt_text deve seguir este padrão:
"[Descrição visual detalhada com movimento e ação] [SFX: som1, categoria1] [SFX: som2, categoria2] [Movimento de câmera] [Ritmo/tempo]"

EXEMPLO DE PROMPT VO3:
"Aerial view of a military helicopter flying low over a desert landscape, rotor blades spinning rapidly, dust clouds trailing behind, camera tracking the helicopter from behind and slightly above, smooth forward motion, golden hour lighting casting long shadows, [SFX: helicopter rotor blades, mechanical] [SFX: wind rushing, atmospheric] [SFX: distant engine roar, vehicle] - fast-paced action sequence, dynamic camera movement"` : '';

        const prompt = `${GLOBAL_VISUAL_ANCHOR}${styleModifier}

Você é um especialista em criação de prompts para ${forVO3 ? 'geração de vídeo (VO3)' : 'geração de imagens'} usando IA.

TAREFA:
Analise o roteiro fornecido e crie prompts detalhados para cada cena do vídeo. Cada prompt deve descrever visualmente o que deve aparecer ${forVO3 ? 'no vídeo' : 'na imagem'} para aquela parte do roteiro.${vo3Instructions}

ROTEIRO:
"""
${script}
"""

INSTRUÇÕES:
1. 🔒 OBRIGATÓRIO: TODAS as cenas DEVEM seguir a ÂNCORA VISUAL GLOBAL acima. Esta é a base visual definida pelo estilo escolhido (${selectedStyle}).
2. 🎨 O estilo "${selectedStyle}" foi selecionado pelo usuário. TODOS os prompts devem seguir este estilo visual consistentemente.
3. ⚠️⚠️⚠️ CRÍTICO - NÚMERO EXATO DE CENAS ⚠️⚠️⚠️: Você DEVE gerar EXATAMENTE ${estimatedScenes} cenas. NÃO mais, NÃO menos. O frontend espera ${estimatedScenes} cenas e você DEVE entregar todas elas. Se a resposta ficar muito longa, continue mesmo assim. É OBRIGATÓRIO gerar todas as ${estimatedScenes} cenas.
4. Cada prompt deve ter entre ${forVO3 ? '800-1500' : '600-1200'} caracteres${forVO3 ? ' (VO3 precisa de mais detalhes para movimento e SFX)' : ''}
5. Cada prompt deve ser em INGLÊS e otimizado para ${forVO3 ? 'geração de vídeo (VO3)' : 'geração de imagens'}
6. Seja específico e detalhado: descreva composição, iluminação, cores, atmosfera, personagens, cenário${forVO3 ? ', movimento, ação, transições e efeitos sonoros' : ''}
7. Use termos técnicos de fotografia/cinematografia quando apropriado${imageModelInstruction}${charactersInstruction}
8. ⚠️ CRÍTICO: Cada prompt_text DEVE seguir o estilo "${selectedStyle}" consistentemente. Todas as cenas devem pertencer ao mesmo mundo visual definido pela Âncora Visual Global.
9. 🔧 REFORÇO DE ESTILO: Cada prompt_text DEVE incluir elementos específicos do estilo "${selectedStyle}" conforme definido na Âncora Visual Global acima. Use as frases de reforço apropriadas para o estilo escolhido.

FORMATO DE RESPOSTA (JSON):
{
  "scenes": [
    {
      "scene_number": 1,
      "scene_description": "Breve descrição da cena",
      "prompt_text": "Prompt detalhado em inglês para ${forVO3 ? 'geração de vídeo VO3 com SFX embutido' : 'geração de imagem'} (${forVO3 ? '800-1500' : '600-1200'} caracteres)${forVO3 ? ' - DEVE incluir [SFX: ...] e descrições de movimento' : ''}"
    },
    ...
  ]
}

IMPORTANTE: 
- Retorne APENAS o JSON, sem texto adicional
- Certifique-se de que cada prompt_text tem entre ${forVO3 ? '800-1500' : '600-1200'} caracteres
${forVO3 ? '- TODOS os prompts DEVE incluir pelo menos 1-3 SFX no formato [SFX: nome do som, categoria]\n- TODOS os prompts DEVE descrever movimento, ação ou transição para VO3\n' : ''}
⚠️⚠️⚠️ REGRA ABSOLUTA - NÚMERO DE CENAS ⚠️⚠️⚠️:
- Você DEVE gerar EXATAMENTE ${estimatedScenes} cenas. NÃO ${minScenes}, NÃO ${maxScenes}, mas EXATAMENTE ${estimatedScenes} cenas.
- O JSON DEVE conter um array "scenes" com EXATAMENTE ${estimatedScenes} objetos.
- NÃO pare antes de gerar todas as ${estimatedScenes} cenas, mesmo que a resposta fique muito longa.
- Se você gerar menos de ${estimatedScenes} cenas, a resposta será considerada INCOMPLETA e REJEITADA.
- O roteiro tem ${wordCount} palavras, o que justifica ${estimatedScenes} cenas. Gere TODAS elas.
- Comece pela cena 1 e continue até a cena ${estimatedScenes}. NÃO pule nenhuma cena.
- É CRÍTICO e OBRIGATÓRIO que o array "scenes" tenha EXATAMENTE ${estimatedScenes} elementos.`;

        // Mapear modelo selecionado para modelo da API (Laozhang ou própria)
        let modelForAPI = null;
        if (useLaozhang) {
            // Mapear para modelo Laozhang
            if (selectedModel === 'gpt-4o' || selectedModel === 'GPT-4o (2025)') {
                modelForAPI = 'gpt-4o';
            } else if (selectedModel === 'claude-3-7-sonnet-20250219' || selectedModel === 'Claude 3.7 Sonnet (Fev/25)') {
                modelForAPI = 'claude-3-7-sonnet-20250219';
            } else if (selectedModel === 'gemini-2.5-pro' || selectedModel === 'Gemini 2.5 Pro (2025)') {
                modelForAPI = 'gemini-2.5-pro';
            } else if (selectedModel && selectedModel.includes('claude')) {
                modelForAPI = 'claude-3-7-sonnet-20250219';
            } else if (selectedModel && selectedModel.includes('gemini')) {
                modelForAPI = 'gemini-2.5-pro';
            } else if (selectedModel && selectedModel.includes('gpt')) {
                modelForAPI = 'gpt-4o';
            } else {
                modelForAPI = selectedModel || 'gpt-4o';
            }
        } else {
            // Usar modelo original para API própria
            modelForAPI = selectedModel || model;
        }
        
        // Se ainda não tem modelo, usar 'gpt-4o' apenas como último recurso
        if (!modelForAPI) {
            console.warn(`[Scene Prompts] ⚠️ Modelo não fornecido ou não reconhecido, usando 'gpt-4o' como fallback`);
            modelForAPI = 'gpt-4o';
        }
        
        console.log(`[Scene Prompts] Modelo recebido: "${selectedModel || 'N/A'}" -> Mapeado para API: "${modelForAPI}" (${useLaozhang ? 'Laozhang' : serviceToUse})`);
        
        // Chamar API apropriada
        let response;
        // Calcular timeout dinamicamente baseado no número de cenas esperadas (antes de chamar a API)
        const baseTimeout = 300000; // 5 minutos
        const timeoutPerScene = 2000; // 2 segundos por cena
        const baseScenes = 20;
        const calculatedTimeout = baseTimeout + (Math.max(0, estimatedScenes - baseScenes) * timeoutPerScene);
        const scenePromptsTimeout = Math.min(1200000, Math.max(300000, calculatedTimeout));
        
        console.log(`[Scene Prompts Laozhang] Timeout calculado: ${scenePromptsTimeout/1000}s (${estimatedScenes} cenas esperadas)`);
        
        if (useLaozhang) {
            response = await callLaozhangAPI(
                prompt, 
                apiKeyToUse, 
                modelForAPI, 
                null, 
                userId, 
                '/api/generate/scene-prompts/laozhang', 
                JSON.stringify({ endpoint: '/api/generate/scene-prompts/laozhang', model: modelForAPI, estimatedScenes, timeout: scenePromptsTimeout })
            );
            // callLaozhangAPI retorna string diretamente
            response = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        } else {
            if (serviceToUse === 'claude') {
                console.log(`[Scene Prompts] Usando timeout estendido de ${scenePromptsTimeout/1000}s para Claude (geração de múltiplas cenas)`);
                response = await callClaudeAPI(prompt, apiKeyToUse, modelForAPI, null, scenePromptsTimeout);
            } else {
                response = await apiCallFunction(prompt, apiKeyToUse, modelForAPI);
            }
            // APIs próprias retornam objeto com propriedade titles
            if (response && typeof response === 'object' && response.titles) {
                response = response.titles;
            } else if (typeof response === 'string') {
                response = response.trim();
            } else {
                response = JSON.stringify(response);
            }
        }

        // Parsear resposta - callLaozhangAPI retorna string diretamente agora
        let scenesData;
        let rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        console.log(`[Scene Prompts] Resposta bruta (primeiros 500 chars):`, rawResponse.substring(0, 500));
        
        // Limpar markdown code blocks primeiro
        rawResponse = rawResponse
            .replace(/^```json\s*/i, '')  // Remover ```json no início
            .replace(/^```\s*/i, '')      // Remover ``` no início
            .replace(/\s*```\s*$/i, '')   // Remover ``` no final
            .trim();
        
        // Verificar se a API recusou a requisição (apenas se for uma mensagem de erro clara, não JSON válido)
        // Primeiro, tentar verificar se há JSON válido na resposta
        const hasValidJson = rawResponse.match(/\{[\s\S]*"scenes"[\s\S]*\}/) || rawResponse.match(/\{[\s\S]*"scene_number"[\s\S]*\}/);
        
        // Se não há JSON válido, verificar se é uma mensagem de erro da API
        if (!hasValidJson) {
            const errorPatterns = [
                /^I'm sorry,?\s+I can't assist/i,
                /^I'm sorry,?\s+I cannot/i,
                /^I'm unable to assist/i,
                /^I cannot fulfill/i,
                /^I must decline/i,
                /^I can't help with that/i,
                /^I'm not able to/i,
                /^This request violates/i,
                /^I cannot comply/i
            ];
            
            const trimmedResponse = rawResponse.trim();
            const isError = errorPatterns.some(pattern => pattern.test(trimmedResponse));
            
            // Também verificar se é uma resposta muito curta (menos de 100 chars) que começa com mensagem de erro
            if (isError || (trimmedResponse.length < 100 && trimmedResponse.toLowerCase().startsWith("i'm sorry"))) {
                console.error('[Scene Prompts] API recusou a requisição:', rawResponse.substring(0, 500));
                throw new Error(`A API de IA recusou processar o prompt. Isso pode acontecer se o conteúdo violar as políticas de uso da API. Tente simplificar o roteiro ou remover conteúdo sensível. Resposta: ${rawResponse.substring(0, 500)}`);
            }
        }
        
        try {
            // Tentar parsear diretamente
            scenesData = JSON.parse(rawResponse);
        } catch (e) {
            console.log('[Scene Prompts] Tentativa 1 de parsing falhou, tentando extrair JSON...');
            // Tentar extrair JSON usando regex (procurar por { ... } completo)
            const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    let jsonStr = jsonMatch[0];
                    // Limpar mais caracteres problemáticos
                    jsonStr = jsonStr
                        .replace(/```json\s*/gi, '')
                        .replace(/```\s*/g, '')
                        .replace(/^[^{]*/, '')  // Remover texto antes do {
                        .replace(/[^}]*$/, ''); // Remover texto depois do }
                    
                    scenesData = JSON.parse(jsonStr);
                } catch (e2) {
                    console.log('[Scene Prompts] Tentativa 2 de parsing falhou, tentando corrigir JSON truncado...');
                    // Tentar encontrar o array de scenes diretamente
                    const scenesArrayMatch = rawResponse.match(/"scenes"\s*:\s*\[([\s\S]*?)\]/);
                    if (scenesArrayMatch) {
                        try {
                            // Tentar construir JSON válido com o array encontrado
                            let scenesArrayStr = scenesArrayMatch[1];
                            // Tentar fechar o array corretamente
                            if (!scenesArrayStr.trim().endsWith('}')) {
                                // Procurar por objetos de cena completos
                                const sceneObjects = scenesArrayStr.match(/\{[^{}]*\}/g);
                                if (sceneObjects && sceneObjects.length > 0) {
                                    scenesArrayStr = sceneObjects.join(',\n');
                                }
                            }
                            scenesData = JSON.parse(`{"scenes": [${scenesArrayStr}]}`);
                        } catch (e3) {
                            console.log('[Scene Prompts] Tentativa 3 de parsing falhou, tentando extrair cenas individuais...');
                            // Última tentativa: extrair cenas individuais parseando objetos JSON completos
                            const simpleScenePattern = /\{\s*"scene_number"\s*:\s*\d+[\s\S]*?\}/g;
                            const simpleMatches = rawResponse.match(simpleScenePattern);
                            if (simpleMatches && simpleMatches.length > 0) {
                                const parsedScenes = [];
                                for (const sceneStr of simpleMatches) {
                                    try {
                                        const scene = JSON.parse(sceneStr);
                                        if (scene.scene_number && (scene.prompt_text || scene.prompt || scene.text)) {
                                            parsedScenes.push({
                                                scene_number: scene.scene_number || scene.number || parsedScenes.length + 1,
                                                scene_description: scene.scene_description || scene.description || `Cena ${parsedScenes.length + 1}`,
                                                prompt_text: scene.prompt_text || scene.prompt || scene.text || ''
                                            });
                                        }
                                    } catch (parseErr) {
                                        console.warn('[Scene Prompts] Erro ao parsear cena individual:', parseErr.message);
                                    }
                                }
                                if (parsedScenes.length > 0) {
                                    scenesData = { scenes: parsedScenes };
                                    console.log(`[Scene Prompts] ✅ Extraídas ${parsedScenes.length} cenas parseando objetos individuais!`);
                                } else {
                                    throw new Error(`Não foi possível extrair cenas da resposta. Primeiros 1000 caracteres: ${rawResponse.substring(0, 1000)}`);
                                }
                            } else {
                                throw new Error(`Não foi possível extrair cenas da resposta. Primeiros 1000 caracteres: ${rawResponse.substring(0, 1000)}`);
                            }
                        }
                    } else {
                        throw new Error(`Nenhum JSON encontrado na resposta. Primeiros 500 caracteres: ${rawResponse.substring(0, 500)}`);
                    }
                }
            } else {
                throw new Error(`Nenhum JSON encontrado na resposta. Primeiros 500 caracteres: ${rawResponse.substring(0, 500)}`);
            }
        }

        if (!scenesData.scenes || !Array.isArray(scenesData.scenes)) {
            // Tentar encontrar scenes em diferentes níveis
            console.log('[Scene Prompts] Tentando encontrar scenes em diferentes níveis...');
            console.log('[Scene Prompts] Estrutura completa:', JSON.stringify(scenesData).substring(0, 1000));
            
            // Procurar scenes em qualquer nível
            const findScenes = (obj, path = '') => {
                if (Array.isArray(obj) && obj.length > 0 && obj[0].prompt_text) {
                    return obj;
                }
                if (typeof obj === 'object' && obj !== null) {
                    for (const key in obj) {
                        if (key === 'scenes' && Array.isArray(obj[key])) {
                            return obj[key];
                        }
                        const found = findScenes(obj[key], `${path}.${key}`);
                        if (found) return found;
                    }
                }
                return null;
            };
            
            const foundScenes = findScenes(scenesData);
            if (foundScenes && Array.isArray(foundScenes)) {
                console.log('[Scene Prompts] ✅ Scenes encontradas em nível aninhado!');
                scenesData.scenes = foundScenes;
            } else {
                throw new Error(`A IA não retornou a estrutura esperada. Verifique se a resposta contém um campo "scenes". Estrutura recebida: ${JSON.stringify(scenesData).substring(0, 500)}`);
            }
        }

        const validScenes = scenesData.scenes.filter(scene => 
            scene && 
            (scene.prompt_text || scene.prompt || scene.text) &&
            (scene.scene_description || scene.description || scene.scene_number || scene.number)
        );
        
        if (validScenes.length === 0) {
            throw new Error('Nenhuma cena válida encontrada na resposta da IA.');
        }

        scenesData.scenes = validScenes.map((scene, index) => ({
            scene_number: scene.scene_number || scene.number || (index + 1),
            scene_description: scene.scene_description || scene.description || `Cena ${index + 1}`,
            prompt_text: scene.prompt_text || scene.prompt || scene.text || ''
        }));

        console.log(`[Scene Prompts] ✅ ${scenesData.scenes.length} cenas parseadas com sucesso!`);
        
        // Verificar se gerou todas as cenas esperadas e tentar gerar as faltantes até completar
        let totalAttempts = 0;
        const maxTotalAttempts = 5; // Máximo de 5 tentativas totais para gerar todas as cenas
        
        while (scenesData.scenes.length < estimatedScenes && totalAttempts < maxTotalAttempts) {
            const missingScenes = estimatedScenes - scenesData.scenes.length;
            console.warn(`[Scene Prompts] ⚠️ Apenas ${scenesData.scenes.length} cenas foram geradas, mas esperávamos ${estimatedScenes} cenas. Faltam ${missingScenes} cenas. Tentativa ${totalAttempts + 1}/${maxTotalAttempts}...`);
            
            // Tentar gerar as cenas faltantes usando a função de retry
            try {
                let apiCallFunction;
                if (useLaozhang && apiKeyToUse) {
                    apiCallFunction = (prompt, key, model) => callLaozhangAPI(prompt, key, model, null, userId, '/api/generate/scene-prompts/laozhang', JSON.stringify({ endpoint: '/api/generate/scene-prompts/laozhang', model }));
                } else if (serviceToUse === 'gemini') {
                    apiCallFunction = callGeminiAPI;
                } else if (serviceToUse === 'claude') {
                    // Usar o timeout calculado anteriormente (scenePromptsTimeout)
                    apiCallFunction = (prompt, key, model) => callClaudeAPI(prompt, key, model, null, scenePromptsTimeout);
                } else {
                    apiCallFunction = callOpenAIAPI;
                }
                
                const additionalScenes = await generateScenesWithRetries({
                    apiFunc: apiCallFunction,
                    apiKey: apiKeyToUse,
                    model: model,
                    script: script,
                    styleInstruction: styleModifier,
                    imageModelInstruction: imageModelInstruction,
                    charactersInstruction: charactersInstruction,
                    estimatedScenes: missingScenes,
                    minScenes: missingScenes, // Exigir exatamente o número faltante
                    maxScenes: missingScenes, // Exigir exatamente o número faltante
                    wordCount: wordCount,
                    serviceLabel: useLaozhang ? 'Laozhang' : serviceToUse,
                    maxAttempts: 3
                });
                
                if (additionalScenes && additionalScenes.length > 0) {
                    // Ajustar números das cenas para continuar a sequência
                    const lastSceneNumber = scenesData.scenes.length;
                    additionalScenes.forEach((scene, idx) => {
                        scene.scene_number = lastSceneNumber + idx + 1;
                    });
                    scenesData.scenes = scenesData.scenes.concat(additionalScenes);
                    console.log(`[Scene Prompts] ✅ ${additionalScenes.length} cenas adicionais geradas! Total: ${scenesData.scenes.length}/${estimatedScenes} cenas.`);
                } else {
                    console.warn(`[Scene Prompts] ⚠️ Nenhuma cena adicional foi gerada nesta tentativa.`);
                }
            } catch (retryError) {
                console.error(`[Scene Prompts] Erro ao tentar gerar cenas faltantes:`, retryError.message);
            }
            
            totalAttempts++;
            
            // Se ainda faltam cenas mas já tentamos várias vezes, parar para evitar loop infinito
            if (scenesData.scenes.length < estimatedScenes && totalAttempts >= maxTotalAttempts) {
                console.warn(`[Scene Prompts] ⚠️ Atingido limite de tentativas (${maxTotalAttempts}). Geradas ${scenesData.scenes.length}/${estimatedScenes} cenas.`);
                break;
            }
        }
        
        if (scenesData.scenes.length < estimatedScenes) {
            console.warn(`[Scene Prompts] ⚠️ Apenas ${scenesData.scenes.length} cenas foram geradas, mas esperávamos ${estimatedScenes} cenas.`);
        } else {
            console.log(`[Scene Prompts] ✅ Todas as ${estimatedScenes} cenas foram geradas com sucesso!`);
        }

        // Limpar nome do modelo (remover prefixos de fornecedores)
        const cleanModelName = (model) => {
            if (!model) return 'GPT-4o';
            // Remover prefixos de fornecedores
            let clean = model.replace(/^(laozhang-|claude-|gemini-|gpt-)/i, '');
            // Mapear para nomes amigáveis
            if (clean.includes('gpt-4o')) return 'GPT-4o';
            if (clean.includes('claude-3-7-sonnet') || clean.includes('sonnet-3-7')) return 'Claude 3.7 Sonnet';
            if (clean.includes('claude-sonnet-4') || clean.includes('sonnet-4')) return 'Claude Sonnet 4';
            if (clean.includes('gemini-2.5-pro')) return 'Gemini 2.5 Pro';
            if (clean.includes('gemini-2.5-flash')) return 'Gemini 2.5 Flash';
            return clean || 'GPT-4o';
        };
        
        const modelToReturn = cleanModelName(selectedModel || 'gpt-4o');
        
        res.json({
            msg: `${scenesData.scenes.length} prompts de cena gerados com sucesso!${scenesData.scenes.length < minScenes ? ` (Esperávamos ${estimatedScenes} cenas, mas apenas ${scenesData.scenes.length} foram geradas. Tente novamente.)` : ''}`,
            scenes: scenesData.scenes,
            modelUsed: modelToReturn, // Retornar apenas o nome do modelo (sem fornecedor)
            expectedScenes: estimatedScenes,
            generatedScenes: scenesData.scenes.length
        });

    } catch (err) {
        console.error('[Scene Prompts] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar prompts de cena.' });
    }
});

// === ROTAS DE HISTÓRICO DE PROMPTS DE CENA ===

// Salvar no histórico
app.post('/api/scene-prompts/history', authenticateToken, async (req, res) => {
    const { script, scenes, model, style, mode, wordsPerScene, characters, title } = req.body;
    const userId = req.user.id;

    if (!script || !scenes || !Array.isArray(scenes)) {
        return res.status(400).json({ msg: 'Script e cenas são obrigatórios.' });
    }

    try {
        // Garantir que a tabela existe
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        const result = await db.run(
            `INSERT INTO scene_prompts_history 
             (user_id, title, script, scenes_json, model, style, mode, words_per_scene, characters, scene_count)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
                userId,
                title || `Prompts gerados em ${new Date().toLocaleString('pt-BR')}`,
                script,
                JSON.stringify(scenes),
                model || null,
                style || null,
                mode || 'automatic',
                wordsPerScene || null,
                characters || null,
                scenes.length
            ]
        );

        res.json({ msg: 'Histórico salvo com sucesso!', id: result.lastID });
    } catch (err) {
        console.error('[Scene Prompts History] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao salvar histórico.' });
    }
});

// Listar histórico
app.get('/api/scene-prompts/history', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { limit = 20 } = req.query;

    try {
        // Garantir que a tabela existe
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        const history = await db.all(
            `SELECT id, title, scene_count, model, style, mode, created_at 
             FROM scene_prompts_history 
             WHERE user_id = ? 
             ORDER BY created_at DESC 
             LIMIT ?`,
            [userId, parseInt(limit)]
        );

        res.json({ history: history || [] });
    } catch (err) {
        console.error('[Scene Prompts History] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao carregar histórico.' });
    }
});

// Carregar prompt específico
app.get('/api/scene-prompts/history/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;

    try {
        // Garantir que a tabela existe
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        const item = await db.get(
            `SELECT * FROM scene_prompts_history WHERE id = ? AND user_id = ?`,
            [id, userId]
        );

        if (!item) {
            return res.status(404).json({ msg: 'Prompt não encontrado.' });
        }

        res.json({
            id: item.id,
            title: item.title,
            script: item.script,
            scenes: JSON.parse(item.scenes_json),
            model: item.model,
            style: item.style,
            mode: item.mode,
            wordsPerScene: item.words_per_scene,
            characters: item.characters,
            scene_count: item.scene_count,
            created_at: item.created_at
        });
    } catch (err) {
        console.error('[Scene Prompts History] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao carregar prompt.' });
    }
});

// Deletar prompt do histórico
app.delete('/api/scene-prompts/history/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;

    try {
        // Garantir que a tabela existe
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        const result = await db.run(
            `DELETE FROM scene_prompts_history WHERE id = ? AND user_id = ?`,
            [id, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Prompt não encontrado.' });
        }

        res.json({ msg: 'Prompt excluído com sucesso!' });
    } catch (err) {
        console.error('[Scene Prompts History] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao excluir prompt.' });
    }
});

// === ROTA PARA DETECTAR PERSONAGENS NO ROTEIRO ===
app.post('/api/detect/characters', authenticateToken, async (req, res) => {
    const { script, model } = req.body;
    const userId = req.user.id;

    if (!script || !script.trim()) {
        return res.status(400).json({ msg: 'O roteiro é obrigatório.' });
    }

    if (!model) {
        return res.status(400).json({ msg: 'O modelo de IA é obrigatório.' });
    }

    try {
        // Determinar qual serviço usar baseado no modelo
        let service = 'gemini';
        if (model.includes('claude') || model.includes('sonnet')) {
            service = 'claude';
        } else if (model.includes('gpt') || model.includes('openai')) {
            service = 'openai';
        }

        // Buscar chave de API
        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
        if (!keyData) {
            return res.status(400).json({ msg: `Chave de API do ${service} não configurada. Configure nas Configurações.` });
        }

        const decryptedKey = decrypt(keyData.api_key);
        if (!decryptedKey) {
            return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
        }

        const prompt = `Você é um diretor de elenco especializado em analisar roteiros e identificar personagens para geração de imagens com IA.

**ROTEIRO PARA ANALISAR:**
${script}

---

**INSTRUÇÕES:**
1. Identifique todos os personagens principais e secundários mencionados no roteiro.
2. Para cada personagem, crie uma descrição concisa e prática que inclua:
   - Nome do personagem (ou descrição se não tiver nome)
   - Idade aparente
   - Aparência física (cor de cabelo, olhos, tipo físico, traços distintivos)
   - Vestimentas principais
   - Características visuais importantes para manter consistência

3. **FORMATO DE SAÍDA OBRIGATÓRIO:** Você DEVE retornar um objeto JSON com a seguinte estrutura exata:
{
  "characters": [
    "Nome, idade, descrição física e características visuais",
    "Outro personagem, idade, descrição física e características visuais"
  ]
}

**EXEMPLO DE FORMATO:**
{
  "characters": [
    "João, um homem de 40 anos, cabelo grisalho, óculos, rosto marcado, vestindo terno escuro",
    "Maria, uma jovem de 25 anos, cabelo longo e ruivo, olhos verdes, vestindo vestido casual"
  ]
}

**REGRA CRÍTICA:**
- Retorne APENAS o JSON válido, sem texto adicional antes ou depois
- Cada string no array deve ser uma descrição completa e prática do personagem
- Foque em características visuais que ajudem a manter consistência nas imagens geradas
- Se um personagem não tem nome, use uma descrição clara (ex: "Policial veterano, 50 anos, cabelo grisalho curto, uniforme azul")
- Limite a descrição de cada personagem a uma linha, mas seja completo e detalhado
- Retorne no formato JSON exato especificado acima, com a propriedade "characters" contendo um array de strings

**AGORA ANALISE O ROTEIRO FORNECIDO E RETORNE O JSON COM OS PERSONAGENS IDENTIFICADOS:**`;

        let apiCallFunction;
        if (service === 'gemini') apiCallFunction = callGeminiAPI;
        else if (service === 'claude') apiCallFunction = callClaudeAPI;
        else apiCallFunction = callOpenAIAPI;

        console.log(`[Detect Characters] Detectando personagens com ${service} (modelo: ${model})...`);
        const rawResponse = await apiCallFunction(prompt, decryptedKey, model);

        // Parse robusto da resposta
        let characters = [];
        let parsedData = null;

        // Tentar extrair JSON da resposta
        if (typeof rawResponse === 'string') {
            try {
                parsedData = JSON.parse(rawResponse);
            } catch (e) {
                // Tentar extrair JSON de dentro de markdown ou texto
                const jsonMatch = rawResponse.match(/\{[\s\S]*"characters"[\s\S]*\[[\s\S]*\][\s\S]*\}/);
                if (jsonMatch) {
                    try {
                        parsedData = JSON.parse(jsonMatch[0]);
                    } catch (e2) {
                        console.warn('[Detect Characters] Erro ao parsear JSON extraído:', e2);
                    }
                }
            }
        } else {
            parsedData = rawResponse;
        }

        // Extrair characters de diferentes estruturas possíveis
        if (parsedData) {
            // Caso 1: { characters: [...] }
            if (parsedData.characters && Array.isArray(parsedData.characters)) {
                characters = parsedData.characters;
            }
            // Caso 2: { data: { characters: [...] } }
            else if (parsedData.data && parsedData.data.characters && Array.isArray(parsedData.data.characters)) {
                characters = parsedData.data.characters;
            }
            // Caso 3: { data: [...] }
            else if (parsedData.data && Array.isArray(parsedData.data)) {
                characters = parsedData.data;
            }
            // Caso 4: { titles: "..." } - tentar parsear o conteúdo
            else if (parsedData.titles && typeof parsedData.titles === 'string') {
                try {
                    const titlesParsed = JSON.parse(parsedData.titles);
                    if (titlesParsed.characters && Array.isArray(titlesParsed.characters)) {
                        characters = titlesParsed.characters;
                    } else if (Array.isArray(titlesParsed)) {
                        characters = titlesParsed;
                    }
                } catch (e) {
                    // Tentar extrair JSON do texto
                    const jsonMatch = parsedData.titles.match(/\{[\s\S]*"characters"[\s\S]*\[[\s\S]*\][\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            const extracted = JSON.parse(jsonMatch[0]);
                            if (extracted.characters && Array.isArray(extracted.characters)) {
                                characters = extracted.characters;
                            }
                        } catch (e2) {
                            console.warn('[Detect Characters] Erro ao parsear JSON de titles:', e2);
                        }
                    }
                }
            }
            // Caso 5: Buscar qualquer array no objeto
            else {
                for (const key in parsedData) {
                    if (Array.isArray(parsedData[key])) {
                        characters = parsedData[key];
                        break;
                    }
                }
            }
        }

        // Filtrar e limpar personagens
        if (characters.length > 0) {
            characters = characters
                .filter(char => char && typeof char === 'string' && char.trim().length > 0)
                .map(char => char.trim());
        }

        if (characters.length === 0) {
            return res.status(400).json({ 
                msg: 'Nenhum personagem foi detectado. Verifique se o roteiro contém personagens identificáveis.',
                characters: '',
                charactersList: []
            });
        }

        // Formatar para o campo de texto (uma linha por personagem)
        const charactersText = characters.join('\n');

        console.log(`[Detect Characters] ✅ ${characters.length} personagem(ns) detectado(s)!`);

        res.json({
            msg: `${characters.length} personagem(ns) detectado(s) com sucesso!`,
            characters: charactersText,
            charactersList: characters
        });

    } catch (err) {
        console.error('[Detect Characters] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao detectar personagens.' });
    }
});

// === ROTA LAOZHANG PARA DETECÇÃO DE PERSONAGENS ===
app.post('/api/detect/characters/laozhang', authenticateToken, async (req, res) => {
    const { script, selectedModel } = req.body;
    const userId = req.user.id;

    if (!script || !script.trim()) {
        return res.status(400).json({ msg: 'O roteiro é obrigatório.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Mapear modelo selecionado para modelo Laozhang
        // Se não houver modelo selecionado, usar GPT-4o como padrão
        const laozhangModel = selectedModel === 'Claude 3.7 Sonnet (Fev/25)' ? 'claude-3-7-sonnet-20250219' :
                             selectedModel === 'Gemini 2.5 Pro (2025)' ? 'gemini-2.5-pro' :
                             (!selectedModel || !selectedModel.trim()) ? 'gpt-4o' : selectedModel;

        const prompt = `Você é um diretor de elenco especializado em analisar roteiros e identificar personagens para geração de imagens com IA.

**ROTEIRO PARA ANALISAR:**
${script}

---

**INSTRUÇÕES:**
1. Identifique todos os personagens principais e secundários mencionados no roteiro.
2. Para cada personagem, crie uma descrição concisa e prática que inclua:
   - Nome do personagem (ou descrição se não tiver nome)
   - Idade aparente
   - Aparência física (cor de cabelo, olhos, tipo físico, traços distintivos)
   - Vestimentas principais
   - Características visuais importantes para manter consistência

3. **FORMATO DE SAÍDA OBRIGATÓRIO:** Você DEVE retornar um objeto JSON com a seguinte estrutura exata:
{
  "characters": [
    "Nome, idade, descrição física e características visuais",
    "Outro personagem, idade, descrição física e características visuais"
  ]
}

**EXEMPLO DE FORMATO:**
{
  "characters": [
    "João, um homem de 40 anos, cabelo grisalho, óculos, rosto marcado, vestindo terno escuro",
    "Maria, uma jovem de 25 anos, cabelo longo e ruivo, olhos verdes, vestindo vestido casual"
  ]
}

**REGRA CRÍTICA:**
- Retorne APENAS o JSON válido, sem texto adicional antes ou depois
- Cada string no array deve ser uma descrição completa e prática do personagem
- Foque em características visuais que ajudem a manter consistência nas imagens geradas
- Se um personagem não tem nome, use uma descrição clara (ex: "Policial veterano, 50 anos, cabelo grisalho curto, uniforme azul")
- Limite a descrição de cada personagem a uma linha, mas seja completo e detalhado
- Retorne no formato JSON exato especificado acima, com a propriedade "characters" contendo um array de strings

**AGORA ANALISE O ROTEIRO FORNECIDO E RETORNE O JSON COM OS PERSONAGENS IDENTIFICADOS:**`;

        console.log(`[Detect Characters Laozhang] Detectando personagens com modelo: ${laozhangModel}...`);
        const response = await callLaozhangAPI(
            prompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_detect_characters',
            JSON.stringify({ endpoint: '/api/detect/characters/laozhang', model: laozhangModel })
        );

        // Parse robusto da resposta
        let characters = [];
        let parsedData = null;

        // Tentar extrair JSON da resposta
        const rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        try {
            parsedData = JSON.parse(rawResponse);
        } catch (e) {
            // Tentar extrair JSON de dentro de markdown ou texto
            const jsonMatch = rawResponse.match(/\{[\s\S]*"characters"[\s\S]*\[[\s\S]*\][\s\S]*\}/);
            if (jsonMatch) {
                try {
                    parsedData = JSON.parse(jsonMatch[0]);
                } catch (e2) {
                    console.warn('[Detect Characters Laozhang] Erro ao parsear JSON extraído:', e2);
                }
            }
        }

        // Extrair characters de diferentes estruturas possíveis
        if (parsedData) {
            if (parsedData.characters && Array.isArray(parsedData.characters)) {
                characters = parsedData.characters;
            } else if (parsedData.data && parsedData.data.characters && Array.isArray(parsedData.data.characters)) {
                characters = parsedData.data.characters;
            } else if (parsedData.data && Array.isArray(parsedData.data)) {
                characters = parsedData.data;
            }
        }

        // Filtrar e limpar personagens
        if (characters.length > 0) {
            characters = characters
                .filter(char => char && typeof char === 'string' && char.trim().length > 0)
                .map(char => char.trim());
        }

        if (characters.length === 0) {
            return res.status(400).json({ 
                msg: 'Nenhum personagem foi detectado. Verifique se o roteiro contém personagens identificáveis.',
                characters: '',
                charactersList: []
            });
        }

        // Formatar para o campo de texto (uma linha por personagem)
        const charactersText = characters.join('\n');

        console.log(`[Detect Characters Laozhang] ✅ ${characters.length} personagem(ns) detectado(s)!`);

        res.json({
            msg: `${characters.length} personagem(ns) detectado(s) com sucesso!`,
            characters: charactersText,
            charactersList: characters
        });

    } catch (err) {
        console.error('[Detect Characters Laozhang] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao detectar personagens.' });
    }
});

// === ROTA PARA REESCREVER PROMPT BLOQUEADO ===
app.post('/api/rewrite/blocked-prompt', authenticateToken, async (req, res) => {
    const { prompt, model } = req.body;
    const userId = req.user.id;

    if (!prompt || !prompt.trim()) {
        return res.status(400).json({ msg: 'O prompt é obrigatório.' });
    }

    try {
        const selectedModel = model || 'gpt-4o';
        let service = 'gemini';
        if (selectedModel.includes('claude') || selectedModel.includes('sonnet')) {
            service = 'claude';
        } else if (selectedModel.includes('gpt') || selectedModel.includes('openai')) {
            service = 'openai';
        }

        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
        if (!keyData) {
            return res.status(400).json({ msg: `Chave de API do ${service} não configurada.` });
        }

        const decryptedKey = decrypt(keyData.api_key);
        if (!decryptedKey) {
            return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
        }

        const rewritePrompt = `O prompt a seguir foi bloqueado por violar políticas de conteúdo. Reescreva-o mantendo a essência visual, história e estilo, mas removendo qualquer conteúdo que possa ser considerado inseguro ou inadequado. O prompt reescrito deve ser em INGLÊS e otimizado para geração de imagens.

PROMPT ORIGINAL:
"""${prompt}"""

INSTRUÇÕES:
1. Mantenha a essência visual, composição e estilo do prompt original
2. Remova qualquer referência a violência, conteúdo adulto ou conteúdo inadequado
3. Mantenha a narrativa e a atmosfera geral
4. O prompt reescrito deve ter entre 600-1200 caracteres
5. Responda APENAS com o prompt reescrito, sem explicações adicionais

PROMPT REWRITTEN:`;

        let apiCallFunction;
        if (service === 'gemini') apiCallFunction = callGeminiAPI;
        else if (service === 'claude') apiCallFunction = callClaudeAPI;
        else apiCallFunction = callOpenAIAPI;

        const response = await apiCallFunction(rewritePrompt, decryptedKey, selectedModel);
        
        let rewrittenText = '';
        if (typeof response === 'string') {
            rewrittenText = response.trim();
        } else if (response.titles) {
            rewrittenText = response.titles;
        } else if (response.text) {
            rewrittenText = response.text;
        }
        
        // Limpar o texto
        rewrittenText = rewrittenText
            .replace(/```[\s\S]*?```/g, '')
            .replace(/`/g, '')
            .replace(/^[^"]*["']|["'][^"]*$/g, '')
            .replace(/^(Prompt|Prompt reformulado|Nova versão|Versão reformulada|PROMPT REWRITTEN)[:：]\s*/i, '')
            .replace(/\n+/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
        
        if (!rewrittenText || rewrittenText.length < 50) {
            throw new Error('Prompt reescrito inválido ou muito curto');
        }
        
        // Adicionar sufixos de qualidade se não estiverem presentes
        if (!rewrittenText.includes('photorealistic')) {
            rewrittenText += ', photorealistic, hyperrealistic, cinematic, 8k, ultra high definition, sharp focus, professional photography';
        }

        res.json({
            msg: 'Prompt reescrito com sucesso!',
            rewrittenPrompt: rewrittenText
        });

    } catch (err) {
        console.error('[Rewrite Prompt] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao reescrever prompt.' });
    }
});

// === ROTA LAOZHANG PARA REESCREVER PROMPT BLOQUEADO ===
app.post('/api/rewrite/blocked-prompt/laozhang', authenticateToken, async (req, res) => {
    const { prompt, selectedModel } = req.body;
    const userId = req.user.id;

    if (!prompt || !prompt.trim()) {
        return res.status(400).json({ msg: 'O prompt é obrigatório.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Mapear modelo selecionado para modelo Laozhang
        // Se não houver modelo selecionado, usar GPT-4o como padrão
        const laozhangModel = selectedModel === 'Claude 3.7 Sonnet (Fev/25)' ? 'claude-3-7-sonnet-20250219' :
                             selectedModel === 'Gemini 2.5 Pro (2025)' ? 'gemini-2.5-pro' :
                             (!selectedModel || !selectedModel.trim()) ? 'gpt-4o' : selectedModel;

        const rewritePrompt = `O prompt a seguir foi bloqueado por violar políticas de conteúdo. Reescreva-o mantendo a essência visual, história e estilo, mas removendo qualquer conteúdo que possa ser considerado inseguro ou inadequado. O prompt reescrito deve ser em INGLÊS e otimizado para geração de imagens.

PROMPT ORIGINAL:
"""${prompt}"""

INSTRUÇÕES:
1. Mantenha a essência visual, composição e estilo do prompt original
2. Remova qualquer referência a violência, conteúdo adulto ou conteúdo inadequado
3. Mantenha a narrativa e a atmosfera geral
4. O prompt reescrito deve ter entre 600-1200 caracteres
5. Responda APENAS com o prompt reescrito, sem explicações adicionais

PROMPT REWRITTEN:`;

        const response = await callLaozhangAPI(
            rewritePrompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_rewrite_prompt',
            JSON.stringify({ endpoint: '/api/rewrite/blocked-prompt/laozhang', model: laozhangModel })
        );
        
        let rewrittenText = '';
        if (typeof response === 'string') {
            rewrittenText = response.trim();
        } else if (response.titles) {
            rewrittenText = response.titles;
        } else if (response.text) {
            rewrittenText = response.text;
        }
        
        // Limpar o texto
        rewrittenText = rewrittenText
            .replace(/```[\s\S]*?```/g, '')
            .replace(/`/g, '')
            .replace(/^[^"]*["']|["'][^"]*$/g, '')
            .replace(/^(Prompt|Prompt reformulado|Nova versão|Versão reformulada|PROMPT REWRITTEN)[:：]\s*/i, '')
            .replace(/\n+/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
        
        if (!rewrittenText || rewrittenText.length < 50) {
            throw new Error('Prompt reescrito inválido ou muito curto');
        }
        
        // Adicionar sufixos de qualidade se não estiverem presentes
        if (!rewrittenText.includes('photorealistic')) {
            rewrittenText += ', photorealistic, hyperrealistic, cinematic, 8k, ultra high definition, sharp focus, professional photography';
        }

        res.json({
            msg: 'Prompt reescrito com sucesso!',
            rewrittenPrompt: rewrittenText
        });

    } catch (err) {
        console.error('[Rewrite Prompt Laozhang] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao reescrever prompt.' });
    }
});

// === ROTA PARA REGENERAR IMAGEM COM PROMPT EDITADO ===
app.post('/api/generate/imagefx/regenerate', authenticateToken, async (req, res) => {
    const { prompt, aspectRatio, style } = req.body;
    const userId = req.user.id;

    if (!prompt) {
        return res.status(400).json({ msg: 'O prompt é obrigatório.' });
    }

    try {
        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'imagefx']);
        if (!keyData) {
            return res.status(400).json({ msg: 'Cookies do ImageFX não configurados. Salve-os nas Configurações.' });
        }
        
        const decryptedCookies = decrypt(keyData.api_key);
        if (!decryptedCookies) {
            return res.status(500).json({ msg: 'Falha ao desencriptar os seus cookies.' });
        }
        
        const imageFx = new ImageFX(decryptedCookies);
        
        // Mapeamento de estilos (mesmo do generate/imagefx)
        const styleSuffixes = {
            'photorealistic': 'photorealistic, hyperrealistic, ultra high definition, 8k, sharp focus, professional photography, taken with a high-end camera like a Sony α7 IV, detailed skin texture, natural lighting',
            'cinematic': 'cinematic, dramatic lighting, film grain, anamorphic lens, color grading, movie still, Hollywood style, epic composition',
            'documentary': 'documentary style, natural lighting, authentic, candid photography, real moments, journalistic approach, raw and unfiltered',
            'cinematic-narrative': 'cinematic narrative, storytelling composition, dramatic angles, emotional depth, visual storytelling, film photography',
            'anime': 'anime style, Japanese animation, vibrant colors, expressive characters, detailed backgrounds, manga-inspired, cel-shaded',
            'cartoon': 'cartoon style, animated, colorful, expressive, playful, hand-drawn aesthetic, vibrant palette',
            'cartoon-premium': 'premium cartoon style, high-quality animation, detailed character design, rich colors, professional animation studio quality',
            'fantasy': 'fantasy art, magical atmosphere, epic scale, mystical lighting, enchanted, otherworldly, detailed fantasy illustration',
            'stick-figure': 'stick figure style, minimalist line art, simple black lines on white background, clean and minimal',
            'whiteboard': 'whiteboard animation style, clean white background, hand-drawn illustrations, educational, clear and simple',
            'tech-minimalist': 'tech minimalist, clean design, modern aesthetic, geometric shapes, minimal color palette, futuristic, sleek',
            'spiritual-minimalist': 'spiritual minimalist, serene atmosphere, soft lighting, peaceful composition, meditative, zen aesthetic',
            'viral-vibrant': 'viral vibrant style, high contrast, saturated colors, bold composition, eye-catching, social media optimized, vibrant and energetic',
            'modern-documentary': 'modern documentary style, contemporary aesthetic, dynamic composition, real-world setting, authentic moments',
            'analog-horror': 'analog horror aesthetic, VHS quality, grainy texture, retro horror, distorted colors, unsettling atmosphere, 80s/90s horror',
            'dark-theater': 'dark theater style, dramatic stage lighting, theatrical composition, intense shadows, dramatic performance',
            'naturalist-drama': 'naturalist drama, realistic emotional scenes, natural lighting, authentic human moments, raw emotion',
            'spiritual-neorealism': 'spiritual neorealism, transcendent realism, ethereal lighting, spiritual atmosphere, mystical realism',
            'psychological-surrealism': 'psychological surrealism, dreamlike imagery, surreal composition, psychological depth, abstract reality',
            'fragmented-memory': 'fragmented memory style, collage aesthetic, fragmented composition, memory-like quality, layered imagery',
            'fragmented-narrative': 'fragmented narrative, collage style, mixed media, layered storytelling, fragmented visual narrative',
            'dream-real': 'dream-real style, liminal space between dream and reality, surreal realism, ethereal atmosphere, dreamlike quality',
            'vhs-nostalgic': 'VHS nostalgic, retro 80s/90s aesthetic, vintage quality, nostalgic colors, retro film grain, analog feel'
        };
        
        // Obter sufixo do estilo ou usar padrão
        const styleSuffix = (style && styleSuffixes[style]) ? styleSuffixes[style] : styleSuffixes['photorealistic'];
        let currentPrompt = `${prompt}, ${styleSuffix}`;
        
        const aspectRatioMap = {
            '16:9': AspectRatio.LANDSCAPE,
            '9:16': AspectRatio.PORTRAIT,
            '1:1': AspectRatio.SQUARE
        };
        
        const results = await imageFx.generateImage(currentPrompt, {
            numberOfImages: 1,
            aspectRatio: aspectRatioMap[aspectRatio || '16:9'] || AspectRatio.LANDSCAPE,
            resizeTo16_9: (aspectRatio || '16:9') === '16:9'
        });

        if (!results || results.length === 0) {
            throw new Error('A API não retornou imagens.');
        }

        const imageData = results[0];
        const imageUrl = imageData.url || `data:image/png;base64,${imageData.base64 || ''}`;
        const imageBase64 = imageData.base64 || (imageUrl.startsWith('data:') ? imageUrl.split(',')[1] : null);

        res.status(200).json({ 
            msg: 'Imagem regenerada com sucesso!',
            image: imageBase64 || imageUrl,
            imageUrl: imageUrl,
            prompt: currentPrompt
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/generate/imagefx/regenerate]:', err);
        
        if (err instanceof AccountError || err.message?.includes('cookie') || err.message?.includes('autenticação')) {
            return res.status(401).json({ 
                msg: 'Cookies do ImageFX expirados ou inválidos. Por favor, atualize os cookies nas Configurações.',
                requiresAuth: true
            });
        }
        
        res.status(500).json({ msg: err.message || 'Erro ao regenerar imagem.' });
    }
});

// === ROTA PARA GERAR MÚLTIPLAS IMAGENS (BATCH) ===
app.post('/api/generate/imagefx/batch', authenticateToken, async (req, res) => {
    const { prompts, style, aspectRatio } = req.body;
    const userId = req.user.id;

    if (!prompts || !Array.isArray(prompts) || prompts.length === 0) {
        return res.status(400).json({ msg: 'Uma lista de prompts é obrigatória.' });
    }

    try {
        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'imagefx']);
        if (!keyData) {
            return res.status(400).json({ msg: 'Cookies do ImageFX não configurados. Salve-os nas Configurações.' });
        }
        
        const decryptedCookies = decrypt(keyData.api_key);
        if (!decryptedCookies) {
            return res.status(500).json({ msg: 'Falha ao desencriptar os seus cookies.' });
        }
        
        const imageFx = new ImageFX(decryptedCookies);
        const results = [];
        const errors = [];

        // Gerar imagens em paralelo (máximo 3 por vez para evitar rate limit)
        const batchSize = 3;
        for (let i = 0; i < prompts.length; i += batchSize) {
            const batch = prompts.slice(i, i + batchSize);
            const batchPromises = batch.map(async (prompt, index) => {
                try {
                    const fullPrompt = `${prompt}, photorealistic, hyperrealistic, cinematic, 8k, ultra high definition, sharp focus, professional photography, taken with a high-end camera like a Sony α7 IV, detailed skin texture, natural lighting`;
                    
                    const aspectRatioMap = {
                        '16:9': AspectRatio.LANDSCAPE,
                        '9:16': AspectRatio.PORTRAIT,
                        '1:1': AspectRatio.SQUARE
                    };
                    
                    const images = await imageFx.generateImage(fullPrompt, {
                        aspectRatio: aspectRatioMap[aspectRatio || '16:9'] || AspectRatio.LANDSCAPE,
                        numberOfImages: 1,
                        resizeTo16_9: (aspectRatio || '16:9') === '16:9'
                    });
                    
                    if (images && images.length > 0) {
                        return {
                            prompt: prompt,
                            image: images[0].getImageData(),
                            sceneNumber: i + index + 1,
                            success: true
                        };
                    }
                    throw new Error('Nenhuma imagem gerada');
                } catch (error) {
                    return {
                        prompt: prompt,
                        error: error.message,
                        sceneNumber: i + index + 1,
                        success: false
                    };
                }
            });

            const batchResults = await Promise.all(batchPromises);
            results.push(...batchResults);
        }

        const successCount = results.filter(r => r.success).length;
        const failCount = results.filter(r => !r.success).length;

        res.json({
            msg: `${successCount} imagem(ns) gerada(s) com sucesso${failCount > 0 ? `, ${failCount} falha(s)` : ''}`,
            results: results,
            successCount,
            failCount
        });

    } catch (err) {
        console.error('[ImageFX Batch] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar imagens em lote.' });
    }
});


// === ROTA PARA GERAR IMAGEM COM IMAGEFX ===
app.post('/api/generate/imagefx', authenticateToken, async (req, res) => {
    const { prompt, niche, subniche, style, saveToLibrary } = req.body;
    const userId = req.user.id;

    if (!prompt) {
        return res.status(400).json({ msg: 'Um prompt (descrição da thumbnail) é obrigatório.' });
    }

    try {
        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'imagefx']);
        if (!keyData) {
            return res.status(400).json({ msg: 'Cookies do ImageFX não configurados. Salve-os nas Configurações.' });
        }
        
        const decryptedCookies = decrypt(keyData.api_key);
        if (!decryptedCookies) {
            return res.status(500).json({ msg: 'Falha ao desencriptar os seus cookies.' });
        }
        
        console.log('[ImageFX] A iniciar geração...');
        const imageFx = new ImageFX(decryptedCookies);
        
        // Mapeamento de estilos para sufixos de prompt
        const styleSuffixes = {
            'photorealistic': 'photorealistic, hyperrealistic, ultra high definition, 8k, sharp focus, professional photography, taken with a high-end camera like a Sony α7 IV, detailed skin texture, natural lighting',
            'cinematic': 'cinematic, dramatic lighting, film grain, anamorphic lens, color grading, movie still, Hollywood style, epic composition',
            'documentary': 'documentary style, natural lighting, authentic, candid photography, real moments, journalistic approach, raw and unfiltered',
            'cinematic-narrative': 'cinematic narrative, storytelling composition, dramatic angles, emotional depth, visual storytelling, film photography',
            'anime': 'anime style, Japanese animation, vibrant colors, expressive characters, detailed backgrounds, manga-inspired, cel-shaded',
            'cartoon': 'cartoon style, animated, colorful, expressive, playful, hand-drawn aesthetic, vibrant palette',
            'cartoon-premium': 'premium cartoon style, high-quality animation, detailed character design, rich colors, professional animation studio quality',
            'fantasy': 'fantasy art, magical atmosphere, epic scale, mystical lighting, enchanted, otherworldly, detailed fantasy illustration',
            'stick-figure': 'stick figure style, minimalist line art, simple black lines on white background, clean and minimal',
            'whiteboard': 'whiteboard animation style, clean white background, hand-drawn illustrations, educational, clear and simple',
            'tech-minimalist': 'tech minimalist, clean design, modern aesthetic, geometric shapes, minimal color palette, futuristic, sleek',
            'spiritual-minimalist': 'spiritual minimalist, serene atmosphere, soft lighting, peaceful composition, meditative, zen aesthetic',
            'viral-vibrant': 'viral vibrant style, high contrast, saturated colors, bold composition, eye-catching, social media optimized, vibrant and energetic',
            'modern-documentary': 'modern documentary style, contemporary aesthetic, dynamic composition, real-world setting, authentic moments',
            'analog-horror': 'analog horror aesthetic, VHS quality, grainy texture, retro horror, distorted colors, unsettling atmosphere, 80s/90s horror',
            'dark-theater': 'dark theater style, dramatic stage lighting, theatrical composition, intense shadows, dramatic performance',
            'naturalist-drama': 'naturalist drama, realistic emotional scenes, natural lighting, authentic human moments, raw emotion',
            'spiritual-neorealism': 'spiritual neorealism, transcendent realism, ethereal lighting, spiritual atmosphere, mystical realism',
            'psychological-surrealism': 'psychological surrealism, dreamlike imagery, surreal composition, psychological depth, abstract reality',
            'fragmented-memory': 'fragmented memory style, collage aesthetic, fragmented composition, memory-like quality, layered imagery',
            'fragmented-narrative': 'fragmented narrative, collage style, mixed media, layered storytelling, fragmented visual narrative',
            'dream-real': 'dream-real style, liminal space between dream and reality, surreal realism, ethereal atmosphere, dreamlike quality',
            'vhs-nostalgic': 'VHS nostalgic, retro 80s/90s aesthetic, vintage quality, nostalgic colors, retro film grain, analog feel'
        };
        
        // Obter sufixo do estilo ou usar padrão
        const styleSuffix = styleSuffixes[style] || styleSuffixes['photorealistic'];
        let currentPrompt = `${prompt}, ${styleSuffix}`;
        
        const maxRetries = 5;
        let attempt = 0;
        let images = null;
        let lastError = null;
        
        // Função para detectar se o erro é de política de conteúdo
        const isPolicyError = (error) => {
            if (!error || !error.message) return false;
            const errorStr = error.message.toLowerCase();
            const errorCode = error.code;
            
            return (
                errorCode === 400 && (
                    errorStr.includes('bloqueado') ||
                    errorStr.includes('conteúdo inseguro') ||
                    errorStr.includes('public_error') ||
                    errorStr.includes('prominent_people') ||
                    errorStr.includes('filter_failed') ||
                    errorStr.includes('policy') ||
                    errorStr.includes('unsafe')
                )
            );
        };
        
        // Função para reformular o prompt usando IA
        const reformulatePrompt = async (originalPrompt, errorMessage) => {
            try {
                const services = ['gemini', 'claude', 'openai'];
                let reformulatedPrompt = null;
                
                for (const service of services) {
                    try {
                        const serviceKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                        if (!serviceKeyData) continue;
                        
                        const decryptedKey = decrypt(serviceKeyData.api_key);
                        if (!decryptedKey) continue;
                        
                        let apiCallFunction;
                        let model;
                        if (service === 'gemini') {
                            apiCallFunction = callGeminiAPI;
                            model = 'gemini-2.0-flash';
                        } else if (service === 'claude') {
                            apiCallFunction = callClaudeAPI;
                            model = 'claude-3-5-haiku-20241022';
                        } else {
                            apiCallFunction = callOpenAIAPI;
                            model = 'gpt-4o-mini';
                        }
                        
                        const reformulationPrompt = `O prompt a seguir foi bloqueado por violar políticas de conteúdo. Reescreva-o mantendo a essência visual, história e estilo, mas removendo qualquer conteúdo que possa ser considerado inseguro ou inadequado. O prompt reescrito deve ser em INGLÊS e otimizado para geração de imagens.

PROMPT ORIGINAL:
"""${originalPrompt}"""

INSTRUÇÕES:
1. Mantenha a essência visual, composição e estilo do prompt original
2. Remova qualquer referência a violência, conteúdo adulto ou conteúdo inadequado
3. Mantenha a narrativa e a atmosfera geral
4. O prompt reescrito deve ter entre 600-1200 caracteres
5. Responda APENAS com o prompt reescrito, sem explicações adicionais

PROMPT REWRITTEN:`;

                        const response = await apiCallFunction(reformulationPrompt, decryptedKey, model);
                        
                        let extractedText = '';
                        if (typeof response === 'string') {
                            extractedText = response;
                        } else if (response.titles) {
                            extractedText = response.titles;
                        } else if (response.text) {
                            extractedText = response.text;
                        }
                        
                        reformulatedPrompt = extractedText
                            .replace(/```[\s\S]*?```/g, '')
                            .replace(/`/g, '')
                            .replace(/^[^"]*["']|["'][^"]*$/g, '')
                            .replace(/^(Prompt|Prompt reformulado|Nova versão|Versão reformulada|PROMPT REWRITTEN)[:：]\s*/i, '')
                            .replace(/\n+/g, ' ')
                            .replace(/\s+/g, ' ')
                            .trim();
                        
                        if (reformulatedPrompt && reformulatedPrompt.length > 50 && reformulatedPrompt.length < 2000) {
                            console.log(`[ImageFX] Prompt reformulado usando ${service} (${reformulatedPrompt.length} caracteres)`);
                            if (!reformulatedPrompt.includes('photorealistic')) {
                                reformulatedPrompt += ', photorealistic, hyperrealistic, cinematic, 8k, ultra high definition, sharp focus, professional photography';
                            }
                            break;
                        }
                    } catch (serviceErr) {
                        console.warn(`[ImageFX] Falha ao reformular com ${service}:`, serviceErr.message);
                        continue;
                    }
                }
                
                if (!reformulatedPrompt) {
                    reformulatedPrompt = originalPrompt
                        .replace(/real person|actual person|specific person|celebrity|famous person/gi, 'generic person')
                        + ', generic characters, no specific individuals, artistic representation';
                }
                
                return reformulatedPrompt;
            } catch (err) {
                console.error('[ImageFX] Erro ao reformular prompt:', err);
                return originalPrompt.replace(/real person|actual person|specific person/gi, 'generic person') + ', generic characters';
            }
        };
        
        // Loop de tentativas com reformulação automática
        while (attempt < maxRetries && !images) {
            attempt++;
            try {
                console.log(`[ImageFX] Tentativa ${attempt}/${maxRetries} com prompt: ${currentPrompt.substring(0, 100)}...`);
                
                const results = await imageFx.generateImage(currentPrompt, {
                    numberOfImages: 1,
                    aspectRatio: AspectRatio.LANDSCAPE,
                    resizeTo16_9: true
                });

                if (results && results.length > 0) {
                    images = results;
                    console.log(`[ImageFX] Imagem gerada com sucesso na tentativa ${attempt}`);
                    break;
                }
            } catch (err) {
                lastError = err;
                console.warn(`[ImageFX] Erro na tentativa ${attempt}:`, err.message);
                
                if (isPolicyError(err) && attempt < maxRetries) {
                    console.log(`[ImageFX] Erro de política detectado. Reformulando prompt...`);
                    currentPrompt = await reformulatePrompt(currentPrompt, err.message);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    continue;
                } else {
                    throw err;
                }
            }
        }

        if (!images || images.length === 0) {
            throw new Error(lastError?.message || 'O ImageFX não retornou imagens após múltiplas tentativas.');
        }

        // O generateImage retorna um array de objetos com url, sanitizedPrompt, etc.
        const imageResult = images[0];
        const imageUrl = imageResult.url || '';
        
        // Extrair base64 da URL data:image
        let finalBase64 = null;
        if (imageUrl && imageUrl.startsWith('data:image')) {
            finalBase64 = imageUrl.split(',')[1];
        }
        
        const finalUrl = imageUrl || (finalBase64 ? `data:image/png;base64,${finalBase64}` : '');

        // Salvar automaticamente na biblioteca se solicitado
        let savedId = null;
        if (saveToLibrary && finalUrl) {
            try {
                const result = await db.run(
                    `INSERT INTO viral_thumbnails_library (user_id, thumbnail_url, thumbnail_description, niche, subniche, style, viral_score)
                     VALUES (?, ?, ?, ?, ?, ?, ?)`,
                    [userId, finalUrl, prompt, niche || null, subniche || null, style || null, 8]
                );
                savedId = result.lastID;
                console.log(`[ImageFX] Thumbnail salva na biblioteca com ID ${savedId}`);
            } catch (libErr) {
                console.warn('[ImageFX] Erro ao salvar thumbnail na biblioteca:', libErr.message);
            }
        }

        res.status(200).json({ 
            msg: 'Imagem gerada com sucesso!',
            image: finalBase64,
            imageUrl: finalUrl,
            base64: finalBase64,
            prompt: currentPrompt,
            savedToLibrary: savedId !== null,
            libraryId: savedId,
            attempts: attempt,
            wasRewritten: attempt > 1
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/generate/imagefx]:', err);
        
        // Verificar se é erro de autenticação (cookies expirados)
        if (err instanceof AccountError || err.message?.includes('cookie') || err.message?.includes('autenticação')) {
            return res.status(401).json({ 
                msg: 'Cookies do ImageFX expirados ou inválidos. Por favor, atualize os cookies nas Configurações.',
                requiresAuth: true
            });
        }
        
        // Verificar se é erro do ImageFX com código específico
        if (err.code === 400 && err.message) {
            const errorMsg = err.message;
            if (errorMsg.includes('PUBLIC_ERROR') || errorMsg.includes('filter_failed')) {
                return res.status(500).json({ 
                    msg: 'Não foi possível gerar a imagem após múltiplas tentativas de reformulação. O conteúdo pode violar políticas do gerador de imagens. Tente modificar o prompt manualmente para remover referências a pessoas reais ou conteúdo sensível.',
                    error: errorMsg
                });
            }
        }
        
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao gerar imagem.' });
    }
});

// === ROTA: GERAR THUMBNAIL POR TÍTULO (SEGUINDO PROMPT PADRÃO) ===
app.post('/api/generate/imagefx/by-title', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { title, niche, subniche, folder_id, prompt_variant, language = 'pt-BR', style = 'photorealistic', variations = 1, prompt_ai = 'none', theme_key } = req.body || {};
    try {
        if (!title || !title.trim()) return res.status(400).json({ msg: 'Título é obrigatório.' });
        // Buscar prompt padrão (variação selecionada)
        let query = 'SELECT id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected FROM thumbnail_style_prompts WHERE user_id = ?';
        const params = [userId];
        if (folder_id) { query += ' AND (folder_id = ? OR folder_id IS NULL)'; params.push(folder_id); }
        if (subniche) { query += ' AND (subniche = ? OR subniche IS NULL)'; params.push(subniche); }
        if (niche) { query += ' AND (niche = ? OR niche IS NULL)'; params.push(niche); }
        query += ' ORDER BY updated_at DESC LIMIT 1';
        const promptData = await db.get(query, params);
        if (!promptData) return res.status(400).json({ msg: 'Prompt padrão não encontrado para este nicho/subnicho.' });
        const selectedNum = prompt_variant || promptData.prompt_selected || 1;
        let basePrompt = null;
        if (selectedNum === 1 && promptData.prompt_1) basePrompt = promptData.prompt_1;
        else if (selectedNum === 2 && promptData.prompt_2) basePrompt = promptData.prompt_2;
        else if (selectedNum === 3 && promptData.prompt_3) basePrompt = promptData.prompt_3;
        else basePrompt = promptData.standard_prompt || promptData.prompt_1 || promptData.prompt_2 || promptData.prompt_3;
        if (!basePrompt) return res.status(400).json({ msg: 'Prompt padrão vazio.' });
        // Adaptar ao título sem reescrever o padrão
        const titleText = title.trim();
        const placeholders = [/\\[\\s*T[ÍI]TULO\\s*\\]/gi, /\\{\\s*TITLE\\s*\\}/gi, /<\\s*TITLE\\s*>/gi, /\\{\\{\\s*title\\s*\\}\\}/gi, /\\[TITLE\\]/g];
        let hadPlaceholder = false;
        for (const rx of placeholders) {
            if (rx.test(basePrompt)) {
                basePrompt = basePrompt.replace(rx, `\"${titleText}\"`);
                hadPlaceholder = true;
            }
        }
        // Não injetar o título completo no prompt visual; vamos criar HEADLINE/SUBHEADLINE
        if (!hadPlaceholder) {
            // Apenas mantém o basePrompt sem inserir "Title: ..."
        }
        // Remover instruções de cenário rígidas do prompt base para permitir variação por título
        try {
            const scenePatterns = [
                /background should.*?\\./gi,
                /background.*?(sky|mountain|desert|forest|jungle|city|ships|pyramids|ruins).*?\\./gi,
                /setting:.*?\\./gi,
                /scene shows.*?\\./gi
            ];
            for (const p of scenePatterns) {
                basePrompt = basePrompt.replace(p, '').replace(/\\n{2,}/g, '\\n');
            }
        } catch {}
        // Extração leve de cenário (IA opcional + heurísticas)
        const words = titleText.split(/\\s+/).map(w => w.trim()).filter(Boolean);
        const eraTerms = ['antiguidade','medieval','renascimento','colônia','império','revolução','século','era','dinastia'];
        const placeTerms = ['roma','egito','azteca','inca','maya','espanha','méxico','peru','andino','atlântico','pacífico','deserto','selva','floresta'];
        const detectedEra = words.find(w => eraTerms.includes(w.toLowerCase()));
        const detectedPlace = words.find(w => placeTerms.includes(w.toLowerCase()));
        let scenarioHints = [];
        if (detectedEra) scenarioHints.push(`historical era: ${detectedEra}`);
        if (detectedPlace) scenarioHints.push(`setting: ${detectedPlace}`);
        // Mapeamento de cenários por cultura/tema para elementos visuais característicos
        const sceneMap = [
            { keys: ['azteca','aztecas','mexica','tenochtitlan'], elements: ['aztec pyramids', 'feathered headdress', 'jaguar warrior motifs', 'Spanish ships on horizon', 'smoke of battle', 'ancient temples'] },
            { keys: ['inca','incas','atahualpa','machu','andino','peru'], elements: ['andes mountains', 'Machu Picchu ruins', 'stone terraces', 'lamas', 'conquistador silhouettes', 'stormy sky'] },
            { keys: ['maya','mayas','mayan','chichen','yucatan'], elements: ['step pyramids', 'jungle canopy', 'stone glyphs', 'misty forest', 'sun shafts through foliage'] },
            { keys: ['roma','romanos','roman'], elements: ['colosseum', 'roman columns', 'laurel wreath', 'legion standards', 'marble statues'] },
            { keys: ['egito','egypt','faraó','pharaoh','pyramids','giza'], elements: ['desert dunes', 'pyramids of giza', 'hieroglyph walls', 'golden sun', 'ancient statues'] }
        ];
        const tLower = titleText.toLowerCase();
        let sceneElements = [];
        for (const entry of sceneMap) {
            if (entry.keys.some(k => tLower.includes(k))) {
                sceneElements = entry.elements;
                break;
            }
        }
        // Regras adicionais para Neandertais/DNA
        if (/(neandertal|neanderthal|neandertais)/i.test(titleText)) {
            sceneElements = ['ice age landscape', 'stormy blue-gray sky', 'cave entrance', 'primitive tools', 'human skull silhouette', 'double helix DNA overlay', 'scientific lab glow'];
        }
        // Evitar elementos conflitantes quando tema não é mesoamericano
        let avoidElements = [];
        if (!/(azteca|aztecas|mexica|tenochtitlan)/i.test(titleText)) {
            avoidElements.push('mesoamerican pyramids', 'feathered headdress', 'jaguar warrior motif', 'spanish ships on horizon');
        }
        // Remover sujeito fixo do prompt base (líder com cocar etc.) para permitir troca por título
        try {
            const subjectPatterns = [
                /indigenous leader.*?\\./gi,
                /feathered headdress.*?\\./gi,
                /jaguar warrior.*?\\./gi,
                /conquistador silhouettes.*?\\./gi
            ];
            for (const p of subjectPatterns) {
                basePrompt = basePrompt.replace(p, '').replace(/\\n{2,}/g, '\\n');
            }
            const hardRemovals = [
                /feather(?:ed)?\\s+headdress/gi,
                /headdress/gi,
                /jaguar\\s+warrior/gi,
                /conquistador(s)?/gi,
                /spanish\\s+ships?/gi,
                /mesoamerican/gi,
                /aztec(as)?/gi,
                /pyramids?/gi,
                /logo/gi,
                /watermark/gi,
                /badge/gi,
                /branding/gi
            ];
            for (const p of hardRemovals) {
                basePrompt = basePrompt.replace(p, '');
            }
            basePrompt = basePrompt.replace(/\\s{2,}/g, ' ').trim();
        } catch {}
        // Definir SUJEITO principal conforme título
        let subjectDescription = null;
        if (/(neandertal|neanderthal|neandertais)/i.test(titleText)) {
            subjectDescription = 'stoic Neanderthal male in fur cloak holding stone tools, rugged facial features, scientific overlay subtly present';
        } else if (/(dna|genetic|genética)/i.test(titleText)) {
            subjectDescription = 'scientific composition with double helix DNA as secondary element; keep human silhouette subtle';
        } else if (/(roma|romanos|roman)/i.test(titleText)) {
            subjectDescription = 'Roman figure with laurel wreath and toga, classical lighting';
        } else if (/(egito|egypt|pharaoh|faraó)/i.test(titleText)) {
            subjectDescription = 'ancient Egyptian figure with royal collar, desert lighting';
        }
        // IA opcional para enriquecer hints (não reescrever prompt)
        try {
            if (prompt_ai && prompt_ai !== 'none') {
                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, prompt_ai]);
                if (keyData) {
                    const decryptedKey = decrypt(keyData.api_key);
                    const model = prompt_ai === 'gemini' ? 'gemini-2.0-flash' : (prompt_ai === 'openai' ? 'gpt-4o-mini' : 'claude-3-5-haiku-20241022');
                    const ask = `From the title "${titleText}", extract 3 short scenario hints (setting, era, key elements) that can vary while keeping composition locked. Return as lines: hint: value`;
                    let resp;
                    if (prompt_ai === 'gemini') resp = await callGeminiAPI(ask, decryptedKey, model);
                    else if (prompt_ai === 'openai') resp = await callOpenAIAPI(ask, decryptedKey, model);
                    else resp = await callClaudeAPI(ask, decryptedKey, model);
                    const text = typeof resp === 'string' ? resp : (resp.text || resp.titles || '');
                    const lines = String(text).split(/\\n+/).map(s => s.trim()).filter(Boolean).slice(0, 5);
                    scenarioHints.push(...lines);
                }
            }
        } catch (e) {
            console.warn('[ByTitle] IA de cenário opcional falhou:', e.message);
        }
        const styleLock = 'Keep composition, subject placement, palette, typography and lighting exactly as in channel references. Do not change layout. Maintain gold title text at bottom with dramatic lighting. Do not render any literal text from these instructions.';
        let finalPrompt = `${basePrompt}`;
        // HEADLINE/SUBHEADLINE derivadas do título
        const extractHeadline = (raw) => {
            let head = raw.split(':')[0].trim();
            // Limitar tamanho e capitalizar
            head = head.replace(/^[\\s\\-–]+|[\\s\\-–]+$/g, '');
            return head;
        };
        const extractSub = (raw) => {
            const paren = raw.match(/\\(([^\\)]+)\\)/);
            if (paren && paren[1]) return paren[1].trim();
            const parts = raw.split(':');
            if (parts[1]) {
                // pegar núcleo forte (2–5 palavras)
                let sub = parts[1]
                    .replace(/\\b(sobre|acerca|de|da|do|dos|das|su[a]?|el|la|los|las|the|a)\\b/gi, '')
                    .replace(/[\"']/g, '')
                    .trim();
                // Se ainda muito longo, encurtar
                const words = sub.split(/\\s+/).filter(Boolean);
                if (words.length > 6) sub = words.slice(0, 6).join(' ');
                return sub || parts[1].trim();
            }
            return '';
        };
        const headlineText = extractHeadline(titleText);
        const subText = extractSub(titleText);
        const theme = (() => {
            const s = titleText.toLowerCase();
            if (s.includes('faraó') || s.includes('egito') || s.includes('egip') || s.includes('pirâmide') || s.includes('piramide')) return 'egito';
            if (s.includes('neandertal') || s.includes('neanderthal') || s.includes('neandertais') || s.includes('neandertales')) return 'prehistoria';
            if (s.includes('inca') || s.includes('atahualpa') || s.includes('moctezuma') || s.includes('azteca') || s.includes('aztecas') || s.includes('mexica')) return 'america_pre_colombiana';
            if (s.includes('viking') || s.includes('vikings')) return 'viking';
            if (s.includes('roma') || s.includes('romano') || s.includes('romanos') || s.includes('roman')) return 'roma';
            if (s.includes('segunda guerra') || s.includes('world war') || s.includes('guerra mundial')) return 'ww2';
            if (s.includes('cristandade') || s.includes('cristão') || s.includes('cristian') || s.includes('cathedral') || s.includes('catedral')) return 'cristandade';
            return 'default';
        })();
        const themes = {
            egito: { AMBIENTE: ['desert dunes', 'pyramids', 'pharaoh temples', 'golden sun'], ELEMENTOS: ['hieroglyph walls', 'golden crown', 'architect tools'] },
            prehistoria: { AMBIENTE: ['frozen mountains', 'glacial valleys', 'burning forests'], ELEMENTOS: ['fur clothing', 'primitive tools', 'ice age forests'] },
            america_pre_colombiana: { AMBIENTE: ['jungles', 'stepped pyramids', 'volcanic eruptions'], ELEMENTOS: ['feather headdress', 'obsidian blade', 'conquistador silhouettes'] },
            viking: { AMBIENTE: ['stormy oceans', 'burning ships', 'icy fjords'], ELEMENTOS: ['longships', 'axes', 'ravens'] },
            roma: { AMBIENTE: ['colosseum', 'roman columns', 'marble statues'], ELEMENTOS: ['legion standards', 'laurel wreath', 'toga textures'] },
            ww2: { AMBIENTE: ['ruined cities', 'smoke', 'searchlights'], ELEMENTOS: ['tanks', 'helmets', 'barbed wire'] },
            cristandade: { AMBIENTE: ['gothic cathedrals', 'stained glass light', 'stone plazas'], ELEMENTOS: ['crosses', 'incense smoke', 'candles'] },
            default: { AMBIENTE: ['dramatic scenery', 'smoke', 'conflict'], ELEMENTOS: ['contextual props'] }
        };
        let dbMatch = null;
        if (theme_key) {
            await ensureAmbientationsTable();
            dbMatch = await db.get('SELECT * FROM niche_ambientations WHERE user_id = ? AND theme_key = ? LIMIT 1', [userId, theme_key]);
        }
        if (!dbMatch) {
            dbMatch = await detectAmbientationFromTitle(userId, titleText, niche);
        }
        if (dbMatch) {
            sceneElements = String(dbMatch.ambiente || '').split(',').map(s => s.trim()).filter(Boolean);
            scenarioHints = String(dbMatch.elementos || '').split(',').map(s => s.trim()).filter(Boolean);
            if (!subjectDescription && dbMatch.subject) subjectDescription = dbMatch.subject;
        } else if (themes[theme]) {
            sceneElements = themes[theme].AMBIENTE;
            scenarioHints = themes[theme].ELEMENTOS;
            if (!subjectDescription) {
                if (theme === 'prehistoria') subjectDescription = 'realistic Neanderthal with fur cloak and stone tools';
                else if (theme === 'egito') subjectDescription = 'ancient Egyptian figure with royal collar';
                else if (theme === 'america_pre_colombiana') subjectDescription = 'Mesoamerican leader with traditional attire';
                else if (theme === 'viking') subjectDescription = 'Viking warrior with fur and axe';
                else if (theme === 'roma') subjectDescription = 'Roman figure with laurel wreath and toga';
                else if (theme === 'ww2') subjectDescription = 'civilian silhouette amid wartime ruins';
                else if (theme === 'cristandade') subjectDescription = 'historical figure near cathedral light';
            }
        }
        const personagem = subjectDescription || 'historical figure with authentic attire';
        const ambientacao = (sceneElements && sceneElements.length) ? sceneElements.join(', ') : 'landscapes and architecture matching the title theme';
        const elementosIconicos = [scenarioHints.join('; '), avoidElements.length ? `avoid: ${avoidElements.join(', ')}` : ''].filter(Boolean).join('; ');
        const elementosDeFundo = scenarioHints.join(', ');
        const acessoriosPreset = (dbMatch && dbMatch.acessorios) ? String(dbMatch.acessorios) : (
            theme === 'prehistoria' ? 'primitive fur and animal hides, no metal or feathers' :
            theme === 'egito' ? 'gold necklaces and ceremonial regalia' :
            theme === 'viking' ? 'fur, leather armor, iron helmet' : ''
        );
        // Modularização do prompt padrão: preencher placeholders ou ajustar blocos de cenário/elementos
        let adaptedPrompt = `${basePrompt}`;
        const phMap = { PERSONAGEM: personagem, ACESSORIOS: acessoriosPreset, AMBIENTE: ambientacao, ELEMENTOS_DE_FUNDO: elementosDeFundo };
        let placeholdersFound = false;
        for (const [key, val] of Object.entries(phMap)) {
            const rx = new RegExp(`\\{${key}\\}`, 'gi');
            if (rx.test(adaptedPrompt)) { placeholdersFound = true; adaptedPrompt = adaptedPrompt.replace(rx, val); }
        }
        if (!placeholdersFound) {
            const bgRx = /(background[^\.]*?)(:|should|with) [^\.]*\./i;
            if (bgRx.test(adaptedPrompt)) adaptedPrompt = adaptedPrompt.replace(bgRx, `$1: ${ambientacao}.`);
            const incRx = /(include[^\.]*elements[^\.]*?)(:|such as) [^\.]*\./i;
            if (incRx.test(adaptedPrompt)) adaptedPrompt = adaptedPrompt.replace(incRx, `$1: ${elementosIconicos}.`);
            if (!bgRx.test(adaptedPrompt)) adaptedPrompt += `\\n\\nBackground: ${ambientacao}.`;
            if (!incRx.test(adaptedPrompt)) adaptedPrompt += `\\nInclude elements: ${elementosDeFundo}.`;
        }
        const headlineLine = `Headline: \\\"${headlineText}\\\" (translate to ${language}) in gold all-caps serif with subtle glow; do not render the word 'Headline'.`;
        const subheadlineLine = subText ? `Subheadline: \\\"${subText}\\\" (translate to ${language}) below, smaller, high contrast; do not render the word 'Subheadline'.` : '';
        const negativeBlock = `Exclude mesoamerican pyramids, feathered headdress, conquistadors, Spanish ships, jaguar motifs, and any aztec elements. CRITICAL - REMOVE ALL CORNER MARKINGS: Exclude any logos, watermarks, channel badges, branding marks, corner icons, decorative elements, or any visual elements in the four corners of the image (top-left, top-right, bottom-left, bottom-right). The image must be completely clean in all four corners. Do not render channel names, corner marks, badges, icons, symbols, text, or any decorative elements in the corners.`;
        finalPrompt = `${adaptedPrompt}\\n\\n${headlineLine}\\n${subheadlineLine}\\n\\n${negativeBlock}\\n\\n${styleLock}`;
        // Reutilizar rota de geração
        const images = [];
        for (let i = 0; i < Math.max(1, Math.min(variations, 4)); i++) {
            const genResp = await fetch(`http://localhost:${PORT}/api/generate/imagefx`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': req.headers['authorization'] || '' },
                body: JSON.stringify({ prompt: finalPrompt, niche, subniche, style, saveToLibrary: true })
            });
            const genData = await genResp.json();
            if (!genResp.ok) throw new Error(genData.msg || 'Erro ao gerar imagem');
            images.push({
                imageUrl: genData.imageUrl || genData.image || genData.result || null,
                savedToLibrary: !!genData.savedToLibrary,
                libraryId: genData.libraryId || null
            });
        }
        try { await saveAmbientationSnapshot(userId, niche, theme, titleText, sceneElements, scenarioHints, subjectDescription); } catch {}
        return res.json({ success: true, promptUsed: finalPrompt, images });
    } catch (err) {
        console.error('[ByTitle] Erro:', err);
        return res.status(500).json({ msg: err.message || 'Erro ao gerar por título.' });
    }
});

app.get('/api/ambientations/detect', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const title = String(req.query.title || '');
        const niche = req.query.niche || null;
        const match = await detectAmbientationFromTitle(userId, title, niche);
        if (!match) return res.json({ found: false });
        return res.json({ found: true, data: match });
    } catch (err) {
        return res.status(500).json({ msg: 'Falha ao detectar ambientação.' });
    }
});

app.post('/api/ambientations', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { niche, theme_key, keywords, ambiente, elementos, subject } = req.body || {};
        await ensureAmbientationsTable();
        await db.run(
            `INSERT INTO niche_ambientations (user_id, niche, theme_key, keywords, ambiente, elementos, subject, updated_at)
             VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
            [userId, niche || null, theme_key || null, String(keywords || ''), String(ambiente || ''), String(elementos || ''), String(subject || '')]
        );
        return res.json({ success: true });
    } catch (err) {
        return res.status(500).json({ msg: 'Falha ao salvar ambientação.' });
    }
});

app.post('/api/ambientations/seed', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        await seedDefaultAmbientations(userId);
        return res.json({ success: true });
    } catch (err) {
        return res.status(500).json({ msg: 'Falha ao popular temas padrão.' });
    }
});

app.get('/api/ambientations', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const rows = await db.all('SELECT id, niche, theme_key, keywords, ambiente, elementos, subject FROM niche_ambientations WHERE user_id = ?', [userId]);
        return res.json(rows || []);
    } catch (err) {
        return res.status(500).json({ msg: 'Falha ao listar ambientações.' });
    }
});
// === FUNÇÕES DE TRANSCRIÇÃO COM WHISPER ===

/**
 * Baixa o áudio usando yt-dlp (método mais estável - ignora bugs do ytdl-core)
 */
async function downloadAudioWithYtDlp(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const audioPath = path.join(TEMP_DIR, `${videoId}_${Date.now()}.mp3`);
    
    console.log(`[Whisper] ⏳ Baixando áudio com yt-dlp (método estável): ${videoId}`);
    
    try {
        // Verificar se yt-dlp está disponível
        try {
            await execAsync('yt-dlp --version');
        } catch (versionErr) {
            throw new Error('Ferramenta de download não disponível no servidor.');
        }
        
        // Montar flags estáveis para YouTube (EJS + runtime JS + cookies opcionais)
        const cookiesPath = '/data/youtube.cookies.txt';
        const cookiesFlag = fs.existsSync(cookiesPath) ? `--cookies ${cookiesPath}` : '';
        const outputTemplate = audioPath.replace('.mp3', '.%(ext)s');
        const command = `yt-dlp -f bestaudio --extract-audio --audio-format mp3 ${cookiesFlag} \
            --js-runtimes node --force-ipv4 --sleep-requests 5 --no-check-certificate --restrict-filenames \
            -o "${outputTemplate}" "${videoUrl}"`;
        
        console.log(`[Whisper] Executando: yt-dlp...`);
        
        // Timeout curto para evitar esperas longas (15 segundos)
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Timeout: Download demorou mais de 15 segundos')), 15000);
        });
        
        const execPromise = execAsync(command, {
            maxBuffer: 10 * 1024 * 1024 // 10MB buffer
        });
        
        let stdout, stderr;
        try {
            const result = await Promise.race([execPromise, timeoutPromise]);
            stdout = result.stdout;
            stderr = result.stderr;
        } catch (err) {
            // Detectar bloqueio do YouTube rapidamente
            const errorMessage = err.message || err.stderr || '';
            if (errorMessage.includes('Sign in to confirm you\'re not a bot') || 
                errorMessage.includes('confirm you\'re not a bot') ||
                errorMessage.includes('bot detection')) {
                throw new Error('YouTube bloqueou o acesso. O vídeo requer autenticação ou está protegido contra bots.');
            }
            throw err;
        }
        
        // Verificar stderr para bloqueios mesmo em caso de sucesso parcial
        if (stderr) {
            if (stderr.includes('Sign in to confirm you\'re not a bot') || 
                stderr.includes('confirm you\'re not a bot') ||
                stderr.includes('bot detection')) {
                throw new Error('YouTube bloqueou o acesso. O vídeo requer autenticação ou está protegido contra bots.');
            }
            if (!stderr.includes('WARNING')) {
                console.warn(`[Whisper] Avisos do yt-dlp:`, stderr);
            }
        }
        
        // Verificar se o arquivo foi criado
        if (!fs.existsSync(audioPath)) {
            // yt-dlp pode criar com extensão diferente, procurar arquivo
            const files = fs.readdirSync(TEMP_DIR);
            const audioFile = files.find(f => f.startsWith(videoId) && (f.endsWith('.mp3') || f.endsWith('.m4a') || f.endsWith('.webm')));
            if (audioFile) {
                const foundPath = path.join(TEMP_DIR, audioFile);
                // Se não for MP3, converter
                if (!audioFile.endsWith('.mp3')) {
                    const mp3Path = audioPath;
                    await new Promise((resolve, reject) => {
                        ffmpeg(foundPath)
                            .audioCodec('libmp3lame')
                            .format('mp3')
                            .on('end', () => {
                                fs.unlinkSync(foundPath); // Remover arquivo original
                                resolve();
                            })
                            .on('error', reject)
                            .save(mp3Path);
                    });
                }
                console.log(`[Whisper] ✅ Áudio baixado com yt-dlp: ${audioPath}`);
                return audioPath;
            }
            throw new Error('Arquivo de áudio não foi criado pelo downloader');
        }
        
        console.log(`[Whisper] ✅ Áudio baixado com yt-dlp: ${audioPath}`);
        return audioPath;
    } catch (err) {
        const errorMessage = err.message || '';
        // Detectar bloqueio do YouTube e falhar rapidamente
        if (errorMessage.includes('Sign in to confirm you\'re not a bot') || 
            errorMessage.includes('confirm you\'re not a bot') ||
            errorMessage.includes('bot detection') ||
            errorMessage.includes('YouTube bloqueou')) {
            console.error(`[Whisper] ❌ YouTube bloqueou o acesso (bot detection):`, errorMessage);
            throw new Error('YouTube bloqueou o acesso. Este vídeo requer autenticação ou está protegido contra bots. Tente novamente mais tarde ou use a transcrição manual.');
        }
        console.error(`[Whisper] ❌ Erro ao baixar com yt-dlp:`, errorMessage);
        throw err;
    }
}

/**
 * Baixa o áudio de um vídeo do YouTube e extrai para arquivo MP3
 * Tenta primeiro com ytdl-core, depois com yt-dlp como fallback (100% estável)
 */
async function downloadAndExtractAudio(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const audioPath = path.join(TEMP_DIR, `${videoId}_${Date.now()}.mp3`);
    
    console.log(`[Whisper] ⏳ Baixando áudio do vídeo: ${videoId}`);
    
    // Tentar primeiro com ytdl-core
    try {
        return await new Promise((resolve, reject) => {
            try {
                // Baixar stream de áudio do YouTube
                // dlChunkSize: 0 evita o bug de segmentação de stream
                // highWaterMark: 1 << 25 evita travamento (33MB buffer)
                const stream = ytdl(videoUrl, {
                    quality: 'highestaudio',
                    filter: 'audioonly',
                    dlChunkSize: 0, // Corrige bug de segmentação
                    highWaterMark: 1 << 25 // 33MB buffer - evita travamento
                });
                
                // Verificar se o stream tem dados válidos
                let hasData = false;
                stream.on('data', (chunk) => {
                    hasData = true;
                });
                
                // Timeout curto para detectar se não há dados chegando (3 segundos)
                const dataTimeout = setTimeout(() => {
                    if (!hasData) {
                        stream.destroy();
                        // Tentar yt-dlp quando stream vazio
                        console.log(`[Whisper] Stream vazio detectado, tentando yt-dlp...`);
                        downloadAudioWithYtDlp(videoId)
                            .then(resolve)
                            .catch((ytdlpErr) => {
                                reject(new Error(`Stream vazio e downloader alternativo indisponível.`));
                            });
                    }
                }, 3000); // 3 segundos para detectar falta de dados (reduzido de 5s)
                
                // Converter para MP3 usando FFmpeg (método simplificado do tutorial)
                const ffmpegProcess = ffmpeg(stream)
                    .audioCodec('libmp3lame')
                    .noVideo() // Garantir que só processa áudio
                    .on('start', (commandLine) => {
                        console.log(`[Whisper] FFmpeg iniciado...`);
                    })
                    .on('progress', (progress) => {
                        if (progress.percent) {
                            console.log(`[Whisper] Progresso: ${Math.round(progress.percent)}%`);
                        }
                    })
                    .on('end', () => {
                        clearTimeout(dataTimeout);
                        console.log(`[Whisper] ✅ Áudio extraído com sucesso: ${audioPath}`);
                        resolve(audioPath);
                    })
                    .on('error', (err) => {
                        clearTimeout(dataTimeout);
                        const errorMsg = err.message || '';
                        console.error(`[Whisper] ❌ Erro no FFmpeg:`, errorMsg);
                        
                        // Detectar bloqueio do YouTube rapidamente
                        if (errorMsg.includes('Sign in to confirm you\'re not a bot') || 
                            errorMsg.includes('confirm you\'re not a bot') ||
                            errorMsg.includes('bot detection')) {
                            reject(new Error('YouTube bloqueou o acesso. Este vídeo requer autenticação ou está protegido contra bots.'));
                            return;
                        }
                        
                        // Verificar se é erro relacionado a stream vazio - tentar yt-dlp
                        if (errorMsg.includes('Input stream error') ||
                            errorMsg.includes('pipe') ||
                            errorMsg.includes('EPIPE') ||
                            errorMsg.includes('Stream vazio')) {
                            console.log(`[Whisper] FFmpeg falhou por stream vazio, tentando yt-dlp...`);
                            downloadAudioWithYtDlp(videoId)
                                .then(resolve)
                                .catch((ytdlpErr) => {
                                    reject(new Error(`FFmpeg falhou e downloader alternativo indisponível.`));
                                });
                        } else {
                            reject(new Error(`Erro ao processar áudio: ${errorMsg}`));
                        }
                    })
                    .save(audioPath);
                
                // Tratar erros do stream do YouTube
                stream.on('error', (streamErr) => {
                    clearTimeout(dataTimeout);
                    const errorMsg = streamErr.message || '';
                    console.error(`[Whisper] ❌ Erro no stream do YouTube:`, errorMsg);
                    
                    // Detectar bloqueio do YouTube rapidamente e falhar imediatamente
                    if (errorMsg.includes('Sign in to confirm you\'re not a bot') || 
                        errorMsg.includes('confirm you\'re not a bot') ||
                        errorMsg.includes('bot detection')) {
                        reject(new Error('YouTube bloqueou o acesso. Este vídeo requer autenticação ou está protegido contra bots.'));
                        return;
                    }
                    
                    // Verificar se é o erro conhecido de parsing - tentar yt-dlp como fallback
                    if (errorMsg.includes('Could not parse') ||
                        errorMsg.includes('decipher function') ||
                        errorMsg.includes('Stream URLs will be missing')) {
                        console.log(`[Whisper] ytdl-core falhou, tentando yt-dlp (método 100% estável)...`);
                        // Tentar com yt-dlp
                        downloadAudioWithYtDlp(videoId)
                            .then(resolve)
                            .catch((ytdlpErr) => {
                                const ytdlpErrorMsg = ytdlpErr.message || '';
                                // Se yt-dlp também detectar bloqueio, falhar imediatamente
                                if (ytdlpErrorMsg.includes('YouTube bloqueou') || 
                                    ytdlpErrorMsg.includes('bot') ||
                                    ytdlpErrorMsg.includes('Sign in to confirm')) {
                                    reject(new Error('YouTube bloqueou o acesso. Este vídeo requer autenticação ou está protegido contra bots.'));
                                } else {
                                    console.error(`[Whisper] yt-dlp também falhou:`, ytdlpErrorMsg);
                                    reject(new Error(`Não foi possível baixar o áudio. ytdl-core falhou e yt-dlp não está instalado ou também falhou.`));
                                }
                            });
                    } else {
                        reject(new Error(`Erro ao baixar áudio do YouTube: ${errorMsg}`));
                    }
                });
                
                // Limpar timeout quando stream terminar
                stream.on('end', () => {
                    clearTimeout(dataTimeout);
                });
                
            } catch (err) {
                console.error(`[Whisper] ❌ Erro ao iniciar download com ytdl-core:`, err.message);
                
                // Verificar se é o erro conhecido de parsing - tentar yt-dlp como fallback
                if (err.message && (
                    err.message.includes('Could not parse') ||
                    err.message.includes('decipher function') ||
                    err.message.includes('Stream URLs will be missing')
                )) {
                    console.log(`[Whisper] ytdl-core falhou, tentando yt-dlp (método 100% estável)...`);
                    // Tentar com yt-dlp
                    downloadAudioWithYtDlp(videoId)
                        .then(resolve)
                        .catch((ytdlpErr) => {
                            console.error(`[Whisper] yt-dlp também falhou:`, ytdlpErr.message);
                            reject(new Error(`Não foi possível baixar o áudio. ytdl-core falhou e yt-dlp não está instalado ou também falhou. Instale yt-dlp: pip install -U yt-dlp`));
                        });
                } else {
                    reject(err);
                }
            }
        });
    } catch (err) {
        // Se ytdl-core falhar completamente, tentar yt-dlp
        console.log(`[Whisper] ytdl-core falhou completamente, tentando yt-dlp (método 100% estável)...`);
        try {
            return await downloadAudioWithYtDlp(videoId);
        } catch (ytdlpErr) {
            throw new Error(`Ambos os métodos falharam. ytdl-core: ${err.message.substring(0, 50)}. yt-dlp: ${ytdlpErr.message.substring(0, 50)}.`);
        }
    }
}

/**
 * Transcreve áudio usando OpenAI Whisper
 */
async function transcribeWithWhisper(audioPath, userId) {
    try {
        // Buscar chave da OpenAI
        const openaiKeyData = await db.get(
            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
            [userId, 'openai']
        );
        
        if (!openaiKeyData) {
            throw new Error('Chave de API da OpenAI não configurada. Configure sua chave OpenAI nas configurações.');
        }
        
        const openaiApiKey = decrypt(openaiKeyData.api_key);
        if (!openaiApiKey) {
            throw new Error('Falha ao desencriptar a chave de API da OpenAI.');
        }
        
        // Inicializar cliente OpenAI
        const openai = new OpenAI({
            apiKey: openaiApiKey
        });
        
        console.log(`[Whisper] 🧠 Enviando para transcrição (Whisper)...`);
        
        // Transcrever usando Whisper (método simplificado do tutorial)
        const transcription = await openai.audio.transcriptions.create({
            file: fs.createReadStream(audioPath),
            model: 'whisper-1', // Modelo correto do Whisper
            language: 'pt' // Português por padrão
        });
        
        // A resposta do Whisper pode ser texto direto ou objeto com .text
        const transcriptText = typeof transcription === 'string' ? transcription : transcription.text || transcription;
        
        console.log(`[Whisper] ✅ Transcrição concluída! Tamanho: ${transcriptText.length} caracteres`);
        
        // Limpar arquivo temporário
        try {
            fs.unlinkSync(audioPath);
            console.log(`[Whisper] Arquivo temporário removido: ${audioPath}`);
        } catch (cleanupErr) {
            console.warn(`[Whisper] Aviso: Não foi possível remover arquivo temporário:`, cleanupErr.message);
        }
        
        return transcriptText;
    } catch (err) {
        // Limpar arquivo temporário em caso de erro
        try {
            if (fs.existsSync(audioPath)) {
                fs.unlinkSync(audioPath);
            }
        } catch (cleanupErr) {
            console.warn(`[Whisper] Erro ao limpar arquivo:`, cleanupErr.message);
        }
        throw err;
    }
}

/**
 * Função principal para transcrever vídeo usando Whisper (fallback universal)
 */
async function transcribeVideoWithWhisper(videoId, userId) {
    let audioPath = null;
    try {
        // 1. Baixar e extrair áudio
        audioPath = await downloadAndExtractAudio(videoId);
        
        // 2. Transcrever com Whisper
        const transcript = await transcribeWithWhisper(audioPath, userId);
        
        return transcript;
    } catch (err) {
        // Garantir limpeza do arquivo em caso de erro
        if (audioPath && fs.existsSync(audioPath)) {
            try {
                fs.unlinkSync(audioPath);
            } catch (cleanupErr) {
                console.warn(`[Whisper] Erro ao limpar arquivo após erro:`, cleanupErr.message);
            }
        }
        throw err;
    }
}

/**
 * Busca transcrição usando youtube-transcript (GRATUITO, busca legendas diretamente do YouTube)
 * Este é o método mais rápido e confiável quando o vídeo tem legendas
 */
async function getTranscriptFromYouTubeTranscript(videoId) {
    try {
        console.log(`[YouTube-Transcript] 🔍 Buscando transcrição via youtube-transcript para: ${videoId}`);
        
        // Tentar buscar transcrição com diferentes configurações
        let transcriptData;
        const languages = ['pt', 'en', 'es', null]; // Tentar português, inglês, espanhol, e sem especificar
        
        for (const lang of languages) {
            try {
                if (lang) {
                    console.log(`[YouTube-Transcript] Tentando idioma: ${lang}`);
                    transcriptData = await YoutubeTranscript.fetchTranscript(videoId, { lang });
                } else {
                    console.log(`[YouTube-Transcript] Tentando sem especificar idioma`);
                    transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
                }
                
                if (transcriptData && transcriptData.length > 0) {
                    break; // Sucesso, sair do loop
                }
            } catch (langErr) {
                console.log(`[YouTube-Transcript] Falha com idioma ${lang || 'padrão'}: ${langErr.message}`);
                continue; // Tentar próximo idioma
            }
        }
        
        if (!transcriptData || transcriptData.length === 0) {
            throw new Error('Nenhuma transcrição encontrada em nenhum idioma disponível');
        }
        
        // Juntar todos os textos
        const transcriptText = transcriptData.map(item => item.text).join(' ').trim();
        
        if (!transcriptText || transcriptText.length === 0) {
            throw new Error('Transcrição vazia');
        }
        
        console.log(`[YouTube-Transcript] ✅ Transcrição obtida! (${transcriptText.length} caracteres, ${transcriptData.length} segmentos)`);
        return transcriptText;
    } catch (err) {
        console.warn(`[YouTube-Transcript] ⚠️ Falha:`, err.message);
        throw new Error(`Nenhuma transcrição encontrada: ${err.message}`);
    }
}
/**
 * Busca transcrição usando múltiplos métodos com fallback automático
 * Ordem de prioridade:
 * 1. youtube-transcript (gratuito, mais rápido)
 * 2. Whisper Local (open-source, se instalado)
 */
async function getTranscriptWithFallback(videoUrl, userId, videoTitle = null) {
    const videoId = videoUrl.includes('youtu.be') 
        ? videoUrl.split('youtu.be/')[1]?.split('?')[0]
        : new URL(videoUrl).searchParams.get('v') || videoUrl;
    
    console.log(`[Transcrição] 🎯 Iniciando busca de transcrição com múltiplos métodos para: ${videoId}`);
    
    // Timeout geral de 30 segundos para toda a operação de transcrição
    const overallTimeout = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Timeout: Operação de transcrição demorou mais de 30 segundos')), 30000);
    });
    
    const transcriptionPromise = (async () => {
        // MÉTODO 1: youtube-transcript (GRATUITO, mais rápido)
        try {
            console.log(`[Transcrição] Tentando método 1: youtube-transcript (gratuito)...`);
            const transcript = await getTranscriptFromYouTubeTranscript(videoId);
            console.log(`[Transcrição] ✅✅✅ SUCESSO com youtube-transcript!`);
            return { transcript, source: 'youtube-transcript' };
        } catch (youtubeTranscriptErr) {
            console.warn(`[Transcrição] Método 1 falhou:`, youtubeTranscriptErr.message);
        }
        
        // MÉTODO 2: Whisper Local (open-source, se instalado)
        try {
            console.log(`[Transcrição] Tentando método 2: Whisper Local (open-source)...`);
            
            // Verificar se Whisper está instalado usando método confiável
            if (!checkWhisperInstalled()) {
                console.warn('[Transcrição] ❌ Whisper não encontrado — pulando método local');
                throw new Error('Whisper não está instalado. Instale com: pip install git+https://github.com/openai/whisper.git');
            }
            
            console.log(`[Transcrição] ✅ Whisper detectado e disponível`);
            
            // Para Whisper, usar yt-dlp diretamente (mais confiável que ytdl-core)
            // ytdl-core está tendo problemas com YouTube, então vamos direto para yt-dlp
            console.log(`[Transcrição] Baixando áudio com yt-dlp (método mais confiável)...`);
            let audioPath;
            let isBotBlocked = false;
            
            try {
                audioPath = await downloadAudioWithYtDlp(videoId);
            } catch (ytdlpErr) {
                const errorMsg = ytdlpErr.message || '';
                // Se detectar bloqueio de bot, não tentar ytdl-core (vai falhar também)
                if (errorMsg.includes('YouTube bloqueou') || 
                    errorMsg.includes('bot') ||
                    errorMsg.includes('Sign in to confirm')) {
                    isBotBlocked = true;
                    throw ytdlpErr;
                }
                // Se yt-dlp falhar por outro motivo, tentar com ytdl-core como último recurso
                console.log(`[Transcrição] yt-dlp falhou, tentando ytdl-core como fallback...`);
                try {
                    audioPath = await downloadAndExtractAudio(videoId);
                } catch (ytdlErr) {
                    const ytdlErrorMsg = ytdlErr.message || '';
                    if (ytdlErrorMsg.includes('YouTube bloqueou') || 
                        ytdlErrorMsg.includes('bot') ||
                        ytdlErrorMsg.includes('Sign in to confirm')) {
                        isBotBlocked = true;
                    }
                    throw ytdlErr;
                }
            }
            
            // Se foi bloqueado, não tentar transcrever
            if (isBotBlocked) {
                throw new Error('YouTube bloqueou o acesso. Este vídeo requer autenticação ou está protegido contra bots.');
            }
            
            const transcript = await transcribeWithWhisperLocal(audioPath);
            console.log(`[Transcrição] ✅✅✅ SUCESSO com Whisper Local!`);
            return { transcript, source: 'whisper-local' };
        } catch (whisperErr) {
            const errorMsg = whisperErr.message || '';
            // Se foi bloqueio de bot, falhar imediatamente sem tentar outros métodos
            if (errorMsg.includes('YouTube bloqueou') || 
                errorMsg.includes('bot') ||
                errorMsg.includes('Sign in to confirm')) {
                throw new Error('YouTube bloqueou o acesso. Este vídeo requer autenticação ou está protegido contra bots. Tente novamente mais tarde ou use a transcrição manual.');
            }
            console.warn(`[Transcrição] Método 2 falhou:`, errorMsg);
        }
        
        // Se todos os métodos falharam
        throw new Error('Todos os métodos de transcrição falharam. Tente novamente mais tarde ou cole a transcrição manualmente.');
    })();
    
    // Executar com timeout geral
    try {
        return await Promise.race([transcriptionPromise, overallTimeout]);
    } catch (err) {
        const errorMsg = err.message || '';
        if (errorMsg.includes('Timeout')) {
            throw new Error('A transcrição está demorando muito. O YouTube pode estar bloqueando o acesso. Tente novamente mais tarde ou use a transcrição manual.');
        }
        throw err;
    }
}


/**
 * Verifica se o Whisper está instalado corretamente
 * @returns {boolean} true se Whisper está disponível, false caso contrário
 */
function checkWhisperInstalled() {
    try {
        const output = execSync('python3 -c "import whisper; print(\'OK\')"', {
            encoding: 'utf8',
            timeout: 5000,
            stdio: ['ignore', 'pipe', 'pipe']
        }).toString().trim();
        return output === 'OK';
    } catch (err) {
        return false;
    }
}

// Função para detectar idioma do título baseado em padrões comuns
function detectLanguageFromTitle(title) {
    if (!title || typeof title !== 'string') return null;
    
    const titleLower = title.toLowerCase();
    
    // Padrões para espanhol
    const spanishPatterns = [
        /\b(el|la|los|las|un|una|de|del|en|con|por|para|que|es|son|está|están|se|su|sus|más|muy|también|como|cuando|donde|porque|este|esta|estos|estas)\b/i,
        /[áéíóúñü]/i
    ];
    
    // Padrões para português
    const portuguesePatterns = [
        /\b(o|a|os|as|um|uma|de|do|da|dos|das|em|com|por|para|que|é|são|está|estão|se|seu|sua|seus|suas|mais|muito|também|como|quando|onde|porque|este|esta|estes|estas)\b/i,
        /[áéíóúâêôãõç]/i
    ];
    
    // Padrões para inglês
    const englishPatterns = [
        /\b(the|a|an|and|or|but|in|on|at|to|for|of|with|by|from|as|is|are|was|were|be|been|being|have|has|had|do|does|did|will|would|should|could|may|might|this|that|these|those|what|which|who|when|where|why|how)\b/i
    ];
    
    // Contar ocorrências de cada idioma
    let spanishScore = 0;
    let portugueseScore = 0;
    let englishScore = 0;
    
    spanishPatterns.forEach(pattern => {
        if (pattern.test(title)) spanishScore++;
    });
    
    portuguesePatterns.forEach(pattern => {
        if (pattern.test(title)) portugueseScore++;
    });
    
    englishPatterns.forEach(pattern => {
        if (pattern.test(title)) englishScore++;
    });
    
    // Retornar o idioma com maior score
    if (spanishScore > portugueseScore && spanishScore > englishScore) {
        return 'es';
    } else if (portugueseScore > englishScore) {
        return 'pt';
    } else if (englishScore > 0) {
        return 'en';
    }
    
    // Se não detectar, retornar null (usará fallback)
    return null;
}


/**
 * Transcreve áudio usando Whisper LOCAL (open-source oficial da OpenAI)
 * Requer: pip install -U openai-whisper
 * Documentação: https://github.com/openai/whisper
 * Aceita MP3, WAV, M4A e outros formatos suportados pelo Whisper
 * 
 * Modelos disponíveis:
 * - tiny: ~39M parâmetros, ~1GB VRAM, ~10x mais rápido
 * - base: ~74M parâmetros, ~1GB VRAM, ~7x mais rápido (recomendado)
 * - small: ~244M parâmetros, ~2GB VRAM, ~4x mais rápido
 * - medium: ~769M parâmetros, ~5GB VRAM, ~2x mais rápido
 * - large: ~1550M parâmetros, ~10GB VRAM, 1x (mais preciso)
 * - turbo: ~809M parâmetros, ~6GB VRAM, ~8x mais rápido (otimizado)
 */
async function transcribeWithWhisperLocal(audioPath) {
    try {
        console.log(`[Whisper Local] 🧠 Transcrevendo com Whisper local (open-source oficial da OpenAI)...`);
        
        // Verificar se arquivo existe
        if (!fs.existsSync(audioPath)) {
            throw new Error(`Arquivo de áudio não encontrado: ${audioPath}`);
        }
        
        // Preparar caminho do arquivo de saída
        const outputDir = path.dirname(audioPath);
        const audioName = path.basename(audioPath, path.extname(audioPath));
        const transcriptFile = path.join(outputDir, `${audioName}.txt`);
        
        // Executar Whisper local usando o modelo oficial da OpenAI
        // --model base: modelo base (equilíbrio entre velocidade e qualidade)
        // Sem --language: Whisper detecta automaticamente o idioma (comportamento padrão)
        // --output_format txt: formato texto simples
        // --output_dir: diretório de saída
        // Whisper aceita MP3, WAV, M4A, FLAC, etc automaticamente
        // Usar 'python -m whisper' para garantir que funcione mesmo se não estiver no PATH
    let command = `python3 -m whisper "${audioPath}" --model base --output_format txt --output_dir "${outputDir}"`;
        
        console.log(`[Whisper Local] Executando: python3 -m whisper "${path.basename(audioPath)}" com modelo base (detecção automática de idioma)...`);
        
        try {
            execSync(command, { 
                stdio: 'inherit',
                timeout: 600000 // 10 minutos de timeout
            });
        } catch (pythonErr) {
            console.error(`[Whisper Local] Erro ao executar Whisper:`, pythonErr.message);
            throw new Error(`Falha ao transcrever com Whisper: ${pythonErr.message}`);
        }
        
        // Ler arquivo de transcrição gerado
        if (!fs.existsSync(transcriptFile)) {
            throw new Error('Arquivo de transcrição não foi gerado pelo Whisper');
        }
        
        const transcriptText = fs.readFileSync(transcriptFile, 'utf8').trim();
        
        if (!transcriptText || transcriptText.length === 0) {
            throw new Error('Transcrição vazia - o áudio pode estar sem fala ou muito baixo');
        }
        
        console.log(`[Whisper Local] ✅ Transcrição concluída! Tamanho: ${transcriptText.length} caracteres`);
        
        // Limpar arquivos temporários
        try {
            fs.unlinkSync(audioPath);
            fs.unlinkSync(transcriptFile);
            // Limpar outros arquivos gerados pelo Whisper (JSON, VTT, SRT, etc)
            const files = fs.readdirSync(outputDir);
            files.forEach(file => {
                if (file.startsWith(audioName) && file !== audioName) {
                    try {
                        fs.unlinkSync(path.join(outputDir, file));
                    } catch (e) {
                        // Ignorar erros de limpeza
                    }
                }
            });
        } catch (cleanupErr) {
            console.warn(`[Whisper Local] Aviso: Não foi possível remover alguns arquivos temporários:`, cleanupErr.message);
        }
        
        return transcriptText;
    } catch (err) {
        // Limpar arquivo temporário em caso de erro
        try {
            if (fs.existsSync(audioPath)) {
                fs.unlinkSync(audioPath);
            }
        } catch (cleanupErr) {
            console.warn(`[Whisper Local] Erro ao limpar arquivo:`, cleanupErr.message);
        }
        throw err;
    }
}

/**
 * Baixa vídeo de URL (YouTube ou MP4 direto) e extrai áudio
 */
async function downloadVideoAndExtractAudio(videoUrl) {
    const tempVideo = path.join(TEMP_DIR, `video_${Date.now()}.mp4`);
    const tempAudio = path.join(TEMP_DIR, `audio_${Date.now()}.wav`);
    
    try {
        console.log(`[Download] 🎬 Baixando vídeo de: ${videoUrl}`);
        
        // Verificar se é URL do YouTube
        if (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be')) {
            // Extrair ID do vídeo
            let videoId = null;
            if (videoUrl.includes('youtu.be')) {
                videoId = videoUrl.split('youtu.be/')[1]?.split('?')[0];
            } else {
                const urlObj = new URL(videoUrl);
                videoId = urlObj.searchParams.get('v');
            }
            
            if (videoId) {
                // Usar método existente para baixar áudio do YouTube
                return await downloadAndExtractAudio(videoId);
            }
        }
        
        // Para URLs diretas de vídeo (MP4, etc)
        console.log(`[Download] Baixando vídeo direto...`);
        const response = await axios.get(videoUrl, { 
            responseType: 'arraybuffer',
            timeout: 300000 // 5 minutos
        });
        fs.writeFileSync(tempVideo, response.data);
        
        console.log(`[Download] 🎧 Extraindo áudio...`);
        await new Promise((resolve, reject) => {
            ffmpeg(tempVideo)
                .noVideo()
                .audioCodec('pcm_s16le')
                .audioChannels(1)
                .audioFrequency(16000)
                .save(tempAudio)
                .on('end', resolve)
                .on('error', reject);
        });
        
        // Limpar vídeo temporário
        try {
            fs.unlinkSync(tempVideo);
        } catch (e) {}
        
        return tempAudio;
    } catch (err) {
        // Limpar arquivos temporários em caso de erro
        try {
            if (fs.existsSync(tempVideo)) fs.unlinkSync(tempVideo);
            if (fs.existsSync(tempAudio)) fs.unlinkSync(tempAudio);
        } catch (e) {}
        throw err;
    }
}

// === ROTAS DE TRANSCRIÇÃO ===

/**
 * Rota para transcrever vídeo por URL (YouTube ou MP4 direto)
 * Usa Whisper LOCAL (open-source, sem API Key)
 * GET /api/transcribe?url=https://www.youtube.com/watch?v=XXXXX
 * GET /api/transcribe?url=https://meusite.com/video.mp4
 */
app.get('/api/transcribe', authenticateToken, async (req, res) => {
    const videoUrl = req.query.url;
    
    if (!videoUrl) {
        return res.status(400).json({ 
            error: 'URL obrigatória',
            msg: 'Forneça a URL do vídeo no parâmetro ?url='
        });
    }
    
    let tempAudio = null;
    
    try {
        console.log(`[Transcribe] 🎬 Iniciando transcrição para: ${videoUrl}`);
        
        // 1. Baixar vídeo e extrair áudio
        tempAudio = await downloadVideoAndExtractAudio(videoUrl);
        
        // 2. Transcrever com Whisper local
        const transcript = await transcribeWithWhisperLocal(tempAudio);
        
        console.log(`[Transcribe] ✅ Transcrição concluída!`);
        res.json({ 
            success: true, 
            text: transcript,
            source: 'whisper-local'
        });
    } catch (err) {
        console.error(`[Transcribe] ❌ Erro na transcrição:`, err.message);
        
        // Limpar arquivo temporário em caso de erro
        if (tempAudio && fs.existsSync(tempAudio)) {
            try {
                fs.unlinkSync(tempAudio);
            } catch (e) {}
        }
        
        res.status(500).json({ 
            error: 'Falha ao transcrever vídeo',
            msg: 'Transcrição indisponível no momento. Tente novamente ou cole a transcrição manualmente.'
        });
    }
});

// === ROTAS DE AGENTES DE ROTEIRO ===

/**
 * Função para obter transcrição com sistema de fallback
 * Tenta usar DownSub primeiro, depois YoutubeTranscript, depois outros métodos
 */
async function getTranscriptWithFallback(videoUrl, userId, videoTitle = null) {
    const errors = [];
    
    // MÉTODO 1: Tentar usar API DownSub (se configurada)
    try {
        console.log('[Transcrição] Tentando usar API DownSub...');
        
        // Buscar chave do DownSub do admin
        const downsubApi = await db.get(`
            SELECT api_key FROM api_providers 
            WHERE provider = 'downsub' AND is_active = 1
            LIMIT 1
        `);
        
        if (downsubApi && downsubApi.api_key) {
            let apiKey = null;
            try {
                // Tentar descriptografar primeiro
                apiKey = decrypt(downsubApi.api_key);
            } catch (decryptErr) {
                // Se falhar, pode não estar criptografada
                console.warn('[Transcrição] Erro ao descriptografar chave DownSub, tentando usar diretamente:', decryptErr.message);
                apiKey = downsubApi.api_key;
            }
            
            // Se ainda não tiver chave, usar diretamente (pode não estar criptografada)
            if (!apiKey) {
                apiKey = downsubApi.api_key;
            }
            
            if (apiKey && apiKey.trim().length > 0) {
                console.log('[Transcrição] Chave DownSub encontrada, tentando obter transcrição...');
                const transcript = await getTranscriptFromDownSub(videoUrl, apiKey);
                if (transcript && transcript.trim().length > 0) {
                    console.log('[Transcrição] ✓ Sucesso com DownSub!');
                    return { transcript, source: 'downsub' };
                }
            } else {
                console.warn('[Transcrição] Chave DownSub vazia ou inválida');
            }
        } else {
            console.log('[Transcrição] API DownSub não configurada ou inativa');
        }
    } catch (downsubErr) {
        console.warn('[Transcrição] DownSub falhou:', downsubErr.message);
        errors.push(`DownSub: ${downsubErr.message}`);
    }
    
    // MÉTODO 2: Tentar usar YoutubeTranscript (biblioteca)
    try {
        console.log('[Transcrição] Tentando usar YoutubeTranscript...');
        const videoId = videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be')
            ? (videoUrl.match(/[?&]v=([^&]+)/) || videoUrl.match(/youtu\.be\/([^?]+)/))?.[1]
            : videoUrl;
        
        if (videoId) {
            const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
            const transcript = transcriptData.map(t => t.text).join(' ');
            if (transcript && transcript.trim().length > 0) {
                console.log('[Transcrição] ✓ Sucesso com YoutubeTranscript!');
                return { transcript, source: 'youtube-transcript' };
            }
        }
    } catch (ytErr) {
        console.warn('[Transcrição] YoutubeTranscript falhou:', ytErr.message);
        errors.push(`YoutubeTranscript: ${ytErr.message}`);
    }
    
    // Se todos os métodos falharam
    throw new Error(`Todos os métodos de transcrição falharam. Erros: ${errors.join('; ')}`);
}

// Rota para obter transcrição completa de um vídeo
app.get('/api/video/transcript/:videoId', authenticateToken, async (req, res) => {
    let { videoId } = req.params;
    const userId = req.user.id;

    console.log(`[Transcrição] Rota chamada - Parâmetro recebido: "${videoId}"`);
    console.log(`[Transcrição] User ID: ${userId}`);
    console.log(`[Transcrição] URL completa: ${req.url}`);
    console.log(`[Transcrição] Parâmetros:`, req.params);
    
    // Garantir que a resposta não será fechada prematuramente
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('Keep-Alive', 'timeout=900'); // 15 minutos

    // Validar e limpar o ID do vídeo (fazer isso antes de qualquer coisa)
    // Remover qualquer caractere inválido que possa ter sido adicionado (como :1 no final)
    let cleanVideoId = String(videoId || '').trim();
    
    // Remover sufixos estranhos que podem aparecer (como :1, :2, etc)
    cleanVideoId = cleanVideoId.split(':')[0].split('?')[0].split('#')[0];
    
    // Validar formato básico do videoId do YouTube (11 caracteres alfanuméricos)
    if (!cleanVideoId || cleanVideoId.length < 10) {
        console.error(`[Transcrição] ❌ VideoId inválido: "${videoId}" -> "${cleanVideoId}"`);
        return res.status(400).json({ 
            msg: 'ID do vídeo inválido',
            error: `VideoId recebido: "${videoId}"`
        });
    }
    
    // Se for uma URL completa, extrair o ID
    if (cleanVideoId.includes('youtube.com') || cleanVideoId.includes('youtu.be')) {
        try {
            const urlObj = new URL(cleanVideoId.includes('http') ? cleanVideoId : `https://${cleanVideoId}`);
            if (urlObj.hostname.includes('youtu.be')) {
                cleanVideoId = urlObj.pathname.substring(1);
            } else {
                cleanVideoId = urlObj.searchParams.get('v') || cleanVideoId;
            }
        } catch (urlErr) {
            console.warn(`[Transcrição] Erro ao processar URL, usando como ID: ${cleanVideoId}`);
        }
    }

    // Log adicional para debug
    console.log(`[Transcrição] VideoId limpo: "${cleanVideoId}" (tamanho: ${cleanVideoId.length})`);
    
    try {
        // Primeiro, tentar buscar do banco de dados (cache)
        const analysis = await db.get(
            'SELECT full_transcript FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
            [cleanVideoId, userId]
        );

        if (analysis && analysis.full_transcript) {
            console.log(`[Transcrição] ✓ Transcrição encontrada no cache`);
            return res.status(200).json({ 
                transcript: analysis.full_transcript,
                source: 'database'
            });
        }

        // Buscar título do vídeo do banco de dados para detectar idioma
        let videoTitle = null;
        try {
            const videoData = await db.get(
                'SELECT original_title FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                [cleanVideoId, userId]
            );
            if (videoData && videoData.original_title) {
                videoTitle = videoData.original_title;
                console.log(`[Transcrição] Título encontrado: ${videoTitle}`);
            }
        } catch (titleErr) {
            console.warn(`[Transcrição] Não foi possível buscar título do vídeo:`, titleErr.message);
        }
        
        // Usar sistema de fallback com múltiplos métodos
        console.log(`[Transcrição] Buscando transcrição com sistema de fallback para vídeo ID: ${cleanVideoId}`);
        console.log(`[Transcrição] URL do vídeo: https://www.youtube.com/watch?v=${cleanVideoId}`);
        
        try {
            const videoUrl = `https://www.youtube.com/watch?v=${cleanVideoId}`;
            const result = await getTranscriptWithFallback(videoUrl, userId, videoTitle);
            
            if (result.transcript && result.transcript.trim().length > 0) {
                console.log(`[Transcrição] ✓✓✓ SUCESSO com ${result.source}! (${result.transcript.length} caracteres)`);
                
                // Salvar no banco de dados para cache
                try {
                    await db.run(
                        'UPDATE analyzed_videos SET full_transcript = ? WHERE youtube_video_id = ? AND user_id = ?',
                        [result.transcript, cleanVideoId, userId]
                    );
                } catch (dbErr) {
                    console.warn(`[Transcrição] Aviso: Não foi possível salvar transcrição no banco:`, dbErr.message);
                }
                
                return res.status(200).json({ 
                    transcript: result.transcript,
                    source: result.source
                });
            } else {
                throw new Error('Transcrição vazia retornada');
            }
        } catch (transcriptErr) {
            console.error(`[Transcrição] ✗✗✗ FALHA com todos os métodos:`, transcriptErr.message);
            console.error(`[Transcrição] Stack trace:`, transcriptErr.stack?.substring(0, 300));
            
            // Retornar erro específico
            let userMessage = 'Não foi possível obter a transcrição deste vídeo.';
            let statusCode = 404;
            
            if (transcriptErr.message.includes('Whisper não está instalado')) {
                userMessage = 'Não foi possível obter a transcrição automaticamente neste momento. Tente novamente mais tarde ou cole a transcrição manualmente ao criar o agente de roteiro.';
            } else if (transcriptErr.message.includes('Todos os métodos de transcrição falharam')) {
                userMessage = 'Não foi possível obter a transcrição com nenhum método disponível.\n\nPossíveis soluções:\n1. Verifique se o vídeo possui legendas habilitadas no YouTube\n2. Tente novamente mais tarde\n3. Cole a transcrição manualmente ao criar o agente de roteiro';
            } else {
                userMessage = `Erro ao buscar transcrição: ${transcriptErr.message}`;
            }
            
            if (!res.headersSent) {
                return res.status(statusCode).json({ 
                    msg: userMessage,
                    error: process.env.NODE_ENV === 'development' ? {
                        error: transcriptErr.message,
                        videoId: cleanVideoId,
                        videoUrl: `https://www.youtube.com/watch?v=${cleanVideoId}`
                    } : undefined
                });
            }
        }
    } catch (err) {
        console.error('[ERRO NA ROTA /api/video/transcript]:', err);
        console.error('[ERRO Stack]:', err.stack?.substring(0, 500));
        
        // Garantir que sempre retornamos uma resposta, mesmo em caso de erro
        if (!res.headersSent) {
            try {
                res.status(500).json({ 
                    msg: err.message || 'Erro ao obter transcrição do vídeo.',
                    error: process.env.NODE_ENV === 'development' ? {
                        message: err.message,
                        stack: err.stack?.substring(0, 300)
                    } : undefined
                });
            } catch (responseErr) {
                console.error('[ERRO ao enviar resposta de erro]:', responseErr);
            }
        } else {
            console.warn('[AVISO] Tentativa de enviar resposta quando headers já foram enviados');
        }
    }
});

app.post('/api/video/transcript/analyze', authenticateToken, async (req, res) => {
    const { transcript, videoId, videoTitle, niche, subniche, generateAgent } = req.body || {};
    const userId = req.user.id;

    if (!transcript || typeof transcript !== 'string' || transcript.trim().length < 400) {
        return res.status(400).json({ msg: 'Forneça a transcrição completa (mínimo ~400 caracteres) para gerar a análise.' });
    }

    try {
        const result = await analyzeTranscriptForVirality({
            userId,
            transcript,
            videoTitle,
            niche,
            subniche
        });

        const response = {
            analysis: result.analysis,
            provider: result.provider,
            videoId: videoId || null
        };

        // Se solicitado, gerar agente automaticamente após a análise
        if (generateAgent === true) {
            try {
                const agentResult = await generateAgentFromTranscript({
                    userId,
                    transcript,
                    videoTitle,
                    niche,
                    subniche,
                    analysis: result.analysis
                });
                response.agent = agentResult.agent;
                response.agentProvider = agentResult.provider;
            } catch (agentErr) {
                console.error('[ERRO ao gerar agente automaticamente]:', agentErr);
                response.agentError = agentErr.message;
            }
        }

        res.status(200).json(response);
    } catch (err) {
        console.error('[ERRO /api/video/transcript/analyze]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao analisar o roteiro.' });
    }
});

// === ROTA LAOZHANG PARA ANÁLISE DE TRANSCRIÇÃO ===
app.post('/api/video/transcript/analyze/laozhang', authenticateToken, async (req, res) => {
    const { transcript, videoId, videoTitle, niche, subniche, model: requestedModel } = req.body || {};
    const userId = req.user.id;

    if (!transcript || typeof transcript !== 'string' || transcript.trim().length < 400) {
        return res.status(400).json({ msg: 'Forneça a transcrição completa (mínimo ~400 caracteres) para gerar a análise.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }
        
        // Mapear modelo selecionado para modelo da laozhang.ai
        let modelToUse = requestedModel || 'gpt-4o';
        if (modelToUse === 'gpt-4o' || modelToUse === 'GPT-4o (2025)') {
            modelToUse = 'gpt-4o';
        } else if (modelToUse === 'claude-3-7-sonnet-20250219' || modelToUse === 'Claude 3.7 Sonnet (Fev/25)') {
            modelToUse = 'claude-3-7-sonnet-20250219';
        } else if (modelToUse === 'gemini-2.5-pro' || modelToUse === 'Gemini 2.5 Pro (2025)') {
            modelToUse = 'gemini-2.5-pro';
        }

        const sanitizedTranscript = transcript.trim();
        const truncatedTranscript = sanitizedTranscript.length > 20000
            ? `${sanitizedTranscript.substring(0, 20000)}\n[... conteúdo truncado para análise ...]`
            : sanitizedTranscript;

        const analysisPrompt = `
Você é um ESTRATEGISTA DE CONTEÚDO para YouTube. Analise profundamente o roteiro abaixo e explique POR QUE ele viralizou.

Retorne APENAS um JSON válido no formato:
{
  "resumo": "síntese em 2-3 frases",
  "motivosVirais": ["motivo 1", "motivo 2", "..."],
  "gatilhosEmocionais": ["gatilho 1", "..."],
  "estruturaNarrativa": [
    { "etapa": "Nome curto", "descricao": "O que acontece nessa parte", "tempoAproximado": "0:00-0:45" }
  ],
  "formulaChecklist": [
    {
      "item": "Elemento da fórmula",
      "status": "aplicado" ou "melhorar",
      "porqueFunciona": "Explicação curta",
      "comoAplicarNoMeuConteudo": "Diretriz prática",
      "upgradeSugerido": "Ajuste para ficar 10/10"
    }
  ],
  "diferencialProposto": "Diferencial para deixar ainda melhor",
  "sugestoesAplicacao": ["ação 1", "ação 2"],
  "alertas": ["possíveis riscos ou pontos de atenção"]
}

Regras:
- Idioma: português do Brasil.
- Não copie trechos do roteiro; descreva a fórmula e o raciocínio.
- Mostre como replicar a estrutura sem plagiar.
- Foque em transformar os aprendizados em um checklist acionável.

Contexto do vídeo:
- Título: ${videoTitle || 'N/A'}
- Nicho: ${niche || 'N/A'}
- Subnicho: ${subniche || 'N/A'}

ROTEIRO COMPLETO:
"""${truncatedTranscript}"""`;

        const response = await callLaozhangAPI(
            analysisPrompt,
            laozhangApiKey,
            modelToUse,
            null,
            userId,
            'api_transcript_analyze',
            JSON.stringify({ endpoint: '/api/video/transcript/analyze/laozhang', model: modelToUse })
        );

        // Parsear resposta JSON
        let analysis;
        const rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        try {
            analysis = JSON.parse(rawResponse);
        } catch (e) {
            // Tentar extrair JSON
            const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    analysis = JSON.parse(jsonMatch[0]);
                } catch (e2) {
                    throw new Error('Resposta da IA não contém JSON válido.');
                }
            } else {
                throw new Error('Resposta da IA não contém JSON válido.');
            }
        }

        res.status(200).json({
            analysis: analysis,
            provider: 'laozhang',
            videoId: videoId || null
        });
    } catch (err) {
        console.error('[ERRO /api/video/transcript/analyze/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao analisar o roteiro.' });
    }
});

// Rota para criar um agente de roteiro a partir de um vídeo transcrito
app.post('/api/script-agents/create', authenticateToken, async (req, res) => {
    const { videoId, videoUrl, videoTitle, agentName, niche, subniche, manualTranscript, viralInsights } = req.body;
    const userId = req.user.id;

    if (!videoId || !agentName) {
        return res.status(400).json({ msg: 'ID do vídeo e nome do agente são obrigatórios.' });
    }

    try {
        // PRIORIDADE 1: Usar transcrição manual se fornecida
        let fullTranscript = null;
        
        if (manualTranscript && manualTranscript.trim().length > 0) {
            fullTranscript = manualTranscript.trim();
            console.log(`[Agente] ✅ Usando transcrição manual fornecida pelo usuário (${fullTranscript.length} caracteres)`);
        } else {
            // PRIORIDADE 2: Buscar transcrição do banco de dados
            try {
                const analysis = await db.get(
                    'SELECT full_transcript FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                    [videoId, userId]
                );

                if (analysis && analysis.full_transcript) {
                    fullTranscript = analysis.full_transcript;
                    console.log(`[Agente] ✅ Usando transcrição do banco de dados (${fullTranscript.length} caracteres)`);
                } else {
                    // PRIORIDADE 3: Tentar buscar diretamente do YouTube (fallback antigo)
                    console.log(`[Agente] ⚠️ Transcrição não encontrada no banco, tentando método alternativo...`);
                    const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
                    if (geminiKeyData) {
                        const geminiApiKey = decrypt(geminiKeyData.api_key);
                        if (geminiApiKey) {
                            try {
                                const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
                                fullTranscript = transcriptData.map(t => t.text).join(' ');
                                console.log(`[Agente] ✅ Transcrição obtida via YouTube Transcript (${fullTranscript.length} caracteres)`);
                            } catch (ytErr) {
                                console.warn(`[Agente] ⚠️ Falha ao buscar transcrição via YouTube Transcript:`, ytErr.message);
                            }
                        }
                    }
                }
            } catch (transcriptErr) {
                console.warn('[Agente] Erro ao obter transcrição:', transcriptErr.message);
            }
        }

        // Se não houver transcrição, permitir criar agente básico (será criado com prompt básico)
        if (!fullTranscript || fullTranscript.trim().length < 100) {
            console.warn(`[Agente] ⚠️ Transcrição não disponível ou muito curta (${fullTranscript?.length || 0} caracteres). Criando agente com prompt básico.`);
            // Não retornar erro, mas criar agente com prompt básico baseado apenas no título e nicho
        }

        // Analisar e capturar a fórmula viral durante a criação do agente
        let viralFormulaData = null;
        if (fullTranscript && fullTranscript.trim().length >= 500) {
            try {
                const claudeKeyRow = await db.get(
                    'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                    [userId, 'claude']
                );

                if (claudeKeyRow && claudeKeyRow.api_key) {
                    const claudeApiKey = decrypt(claudeKeyRow.api_key);
                    if (claudeApiKey) {
                        const viralReplicator = new ViralFormulaReplicator();
                        console.log('[Agente] 🔍 Analisando fórmula viral durante criação do agente...');
                        viralFormulaData = await viralReplicator.analyzeViralFormula(
                            fullTranscript,
                            claudeApiKey,
                            videoTitle,
                            niche || subniche || 'geral'
                        );
                        console.log('[Agente] ✅ Fórmula viral capturada e pronta para reutilização futura.');
                    } else {
                        console.warn('[Agente] ⚠️ Falha ao desencriptar API key do Claude para análise de fórmula.');
                    }
                } else {
                    console.warn('[Agente] ⚠️ API key do Claude não configurada. Fórmula viral não será armazenada.');
                }
            } catch (formulaErr) {
                console.error('[Agente] ⚠️ Erro ao analisar fórmula viral durante criação do agente:', formulaErr.message);
            }
        }

        // Buscar provedor de IA preferencial (Claude > GPT > Gemini)
        const aiProvider = await getPreferredAIProvider(userId, ['claude', 'openai', 'gemini']);
        if (!aiProvider) {
            return res.status(400).json({ msg: 'Configure uma chave do Claude, OpenAI ou Gemini para criar agentes.' });
        }

        // Criar prompt para o agente usando IA
        let agentPrompt;
        let insightsSection = '';
        if (viralInsights && typeof viralInsights === 'object') {
            try {
                const serializedInsights = JSON.stringify(viralInsights);
                insightsSection = `\nINSIGHTS DO VÍDEO VIRAL (checklist e diferencial identificados anteriormente):\n${serializedInsights.substring(0, 6000)}\n`;
            } catch (err) {
                console.warn('[Agente] Não foi possível serializar viralInsights:', err.message);
            }
        }
        
        if (fullTranscript && fullTranscript.trim().length >= 100) {
            // Usar o roteiro completo (ou até 50000 caracteres para análise mais profunda)
            const transcriptToAnalyze = fullTranscript.length > 50000 
                ? fullTranscript.substring(0, 50000) + '\n[... roteiro continua ...]'
                : fullTranscript;
            
            agentPrompt = `PASSO 1 - CRIAR ROTEIRO BASE:
Preciso que você me ajude a criar um agente de criação de roteiros em forma de documento no nicho de ${niche || 'N/A'} subnichado em ${subniche || 'N/A'}. 

Vou te mandar uma transcrição de um roteiro e quero que o agente crie roteiros com a mesma estrutura da TRANSCRIÇÃO. O agente deve criar os roteiros com parágrafos longos, cheios, sem quebras de linha excessivas e deve evitar termos técnicos como "capitulo x" ou "parte tal" deve seguir apenas com o conteúdo para facilitar que eu copie o roteiro para um documento. O agente deve produzir roteiros com em média 30 mil caracteres em ptbr. Preciso que o texto seja feito em um bloco único, sem separação por subtítulos ou tópicos e que não possua palavras destacadas em negrito ou algo do tipo. Esse texto vai ser narrado por uma IA, por isso peço que retire todos os travessões ou hifens em palavras ou frases, para que não ocorra nenhum tipo de bug na hora que a IA for narrar esse texto. Corte a introdução da resposta do prompt e vá direto ao texto traduzido. Mantenha a essência de um roteiro feito para youtube, como CTA de like e inscrição no canal.

PASSO 2 - INTRODUÇÃO:
Crie uma introdução breve e impactante para o vídeo com o título "${videoTitle || 'N/A'}" como referência no agente. A introdução deve ser envolvente, criar conexão com o público, gerar identificação imediata, tocar diretamente na dor que o espectador sente e apresentar a promessa de uma solução real e acessível. Use linguagem emocional, simples e direta, como se estivesse falando com alguém que sofre com esse problema há muito tempo. Utilize riqueza de detalhes e storytelling para o público se identificar.

PASSO 3 - CTA DE INSCRIÇÃO:
Crie um CTA de inscrição envolvente e humanizado para um canal desse nicho e subnicho específico voltado ao público que sofre com essa dor específica. O CTA deve incentivar a inscrição de forma acolhedora, sem pressão, destacando os benefícios de acompanhar o canal. Use linguagem simples, direta e emocional. O tom deve transmitir cuidado, confiança e autoridade.

PASSO 4 - CTA DE COMENTÁRIO:
Crie um CTA envolvente, localizado por volta de 1/3 do vídeo, que provoque o espectador a comentar. O trecho deve usar uma pergunta direta, gerar identificação com a dor ou dificuldade da audiência, e ativar emocionalmente a pessoa — como se ela estivesse sendo ouvida pela primeira vez. O texto deve induzir o comentário com uma frase pronta para copiar e colar, e fazer o espectador sentir que sua participação ajuda outras pessoas. Use um tom empático, acolhedor e de conversa íntima, como se estivesse falando com um amigo que sofre em silêncio.

TRANSCRIÇÃO DE REFERÊNCIA:
"""${transcriptToAnalyze}"""

TÍTULO DO VÍDEO: ${videoTitle || 'N/A'}
NICHE: ${niche || 'N/A'}
SUBNICHE: ${subniche || 'N/A'}

INSTRUÇÕES PARA O AGENTE:
Com base na transcrição acima, crie um agente que:
1. Gere roteiros seguindo a mesma estrutura e estilo da transcrição
2. Use a introdução, CTA de inscrição e CTA de comentário criados acima
3. Mantenha o tom, estilo narrativo e elementos virais identificados
4. Produza roteiros completos de aproximadamente 30.000 caracteres
5. Formate o texto como um bloco único, sem quebras excessivas ou formatação especial
6. Remova todos os travessões e hifens que possam causar problemas na narração por IA

Crie:`;
        } else {
            // Se não houver transcrição, criar um prompt básico baseado apenas no título e nicho
            agentPrompt = `Você é um especialista em criar roteiros virais para YouTube. Crie um "agente de roteiro" baseado nas informações disponíveis sobre um vídeo de sucesso.

TÍTULO DO VÍDEO: ${videoTitle || 'N/A'}
NICHE: ${niche || 'N/A'}
SUBNICHE: ${subniche || 'N/A'}

NOTA: A transcrição completa do vídeo não está disponível, mas você deve criar um agente de roteiro baseado no título, nicho e subnicho fornecidos. O agente deve ser capaz de gerar roteiros virais seguindo o padrão sugerido pelo título e contexto do nicho.

Crie:`;
        }

        agentPrompt += `${insightsSection}

IMPORTANTE:
- NÃO copie o texto do roteiro original.
- Extraia apenas a FÓRMULA, estrutura, ritmo e gatilhos que tornam o vídeo viral.
- Use os 4 PASSOS acima (roteiro base, introdução, CTA inscrição, CTA comentário) como base para criar o agente.
- O agente deve ser capaz de receber APENAS um título de vídeo e gerar um roteiro completo seguindo EXATAMENTE a mesma estrutura e fórmula viral do roteiro original analisado.

Responda APENAS com um objeto JSON válido no seguinte formato:
{
  "agent_prompt": "Prompt base detalhado que inclui os 4 PASSOS (roteiro base, introdução, CTA inscrição, CTA comentário) e captura a estrutura e elementos virais do roteiro original. O prompt deve instruir o agente a criar roteiros de ~30.000 caracteres em bloco único, sem formatação especial, sem travessões/hifens, mantendo a essência do YouTube com CTAs de like e inscrição.",
  "agent_instructions": "Instruções completas que explicam: 1) Como usar a introdução criada no PASSO 2, 2) Como usar o CTA de inscrição do PASSO 3, 3) Como usar o CTA de comentário do PASSO 4, 4) A estrutura exata do roteiro (timing, seções, progressão), 5) Os elementos virais que DEVEM ser mantidos em cada replicação, 6) Como adaptar o conteúdo para novos títulos mantendo a essência, 7) Padrões e fórmulas identificadas que geram engajamento.",
  "introduction": "Introdução criada no PASSO 2 que será usada pelo agente",
  "subscriptionCTA": "CTA de inscrição criado no PASSO 3 que será usado pelo agente",
  "commentCTA": "CTA de comentário criado no PASSO 4 que será usado pelo agente"
}`;

        let response;
        let responseText = '';
        
        if (aiProvider.service === 'laozhang') {
            response = await callLaozhangAPI(
                agentPrompt, 
                aiProvider.apiKey, 
                aiProvider.model, 
                null, 
                userId, 
                'api_call', 
                JSON.stringify({ endpoint: '/api/script-agents/create', model: aiProvider.model })
            );
            // callLaozhangAPI retorna string diretamente
            responseText = typeof response === 'string' ? response : JSON.stringify(response);
        } else if (aiProvider.service === 'claude') {
            response = await callClaudeAPI(agentPrompt, aiProvider.apiKey, aiProvider.model);
        } else if (aiProvider.service === 'openai') {
            response = await callOpenAIAPI(agentPrompt, aiProvider.apiKey, aiProvider.model);
        } else {
            response = await callGeminiAPI(agentPrompt, aiProvider.apiKey, aiProvider.model);
        }
        
        // Extrair o texto da resposta (se ainda não foi extraído para laozhang)
        if (aiProvider.service !== 'laozhang') {
            if (response && response.titles) {
                responseText = response.titles;
            } else if (typeof response === 'string') {
                responseText = response;
            } else {
                console.error(`[Agente] Formato de resposta inesperado:`, typeof response);
                throw new Error('Formato de resposta inesperado da API');
            }
        }
        
        console.log(`[Agente] Resposta recebida (primeiros 500 caracteres):`, responseText.substring(0, 500));
        
        let agentPromptText = '';
        let agentInstructions = '';

        try {
            // Como o Gemini está configurado com responseMimeType: "application/json",
            // a resposta deve ser JSON válido diretamente
            let parsed;
            
            // Tentar parsear diretamente como JSON
            try {
                parsed = JSON.parse(responseText);
            } catch (directParseError) {
                // Se falhar, tentar extrair JSON da resposta (pode ter markdown ou texto extra)
                let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    // Tentar encontrar JSON entre markdown code blocks
                    jsonMatch = responseText.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
                    if (jsonMatch && jsonMatch[1]) {
                        parsed = JSON.parse(jsonMatch[1]);
                    } else {
                        throw new Error('Nenhum JSON encontrado na resposta');
                    }
                } else {
                    // Limpar e parsear JSON extraído
                    const cleanedJson = jsonMatch[0]
                        .replace(/```json|```/g, '')
                        .trim();
                    parsed = JSON.parse(cleanedJson);
                }
            }
            
            // Verificar se o JSON tem os campos esperados
            if (parsed && parsed.agent_prompt && parsed.agent_instructions) {
                agentPromptText = parsed.agent_prompt;
                agentInstructions = parsed.agent_instructions;
                
                // Adicionar introdução, CTA de inscrição e CTA de comentário às instruções se disponíveis
                if (parsed.introduction || parsed.subscriptionCTA || parsed.commentCTA) {
                    agentInstructions += '\n\n=== ELEMENTOS ESPECÍFICOS DO AGENTE ===\n';
                    if (parsed.introduction) {
                        agentInstructions += `\nINTRODUÇÃO (usar no início de cada roteiro):\n${parsed.introduction}\n`;
                    }
                    if (parsed.subscriptionCTA) {
                        agentInstructions += `\nCTA DE INSCRIÇÃO (usar no final do roteiro):\n${parsed.subscriptionCTA}\n`;
                    }
                    if (parsed.commentCTA) {
                        agentInstructions += `\nCTA DE COMENTÁRIO (usar por volta de 1/3 do vídeo):\n${parsed.commentCTA}\n`;
                    }
                }
                
                console.log(`[Agente] ✅ Agente criado com sucesso a partir da resposta da IA`);
            } else {
                console.warn(`[Agente] JSON parseado mas campos ausentes. Campos encontrados:`, Object.keys(parsed || {}));
                throw new Error('JSON não contém agent_prompt e agent_instructions');
            }
        } catch (parseError) {
            console.warn(`[Agente] Erro ao parsear resposta do Gemini:`, parseError.message);
            console.log(`[Agente] Resposta completa recebida:`, responseText);
            
            // Fallback: criar um prompt básico baseado no vídeo
            agentPromptText = `Você é um roteirista especializado em criar documentários virais para YouTube. Analise o seguinte padrão comprovado e crie um novo roteiro de documentário cativante e informativo.

**Padrão de Sucesso (baseado no vídeo "${videoTitle}"):**
- Estrutura narrativa envolvente com ganchos poderosos
- Ritmo dinâmico que mantém o espectador engajado
- Informações precisas apresentadas de forma acessível
- Elementos visuais e sonoros que complementam a narrativa

**Nicho:** ${niche || 'N/A'}
**Sub-nicho:** ${subniche || 'N/A'}

Crie roteiros seguindo esta estrutura e estilo, adaptando o conteúdo para novos tópicos dentro do mesmo nicho.`;

            agentInstructions = `Este agente foi criado a partir do vídeo "${videoTitle || 'N/A'}".

**Como usar:**
1. Forneça um novo tópico dentro do nicho "${niche || 'geral'}"
2. O agente gerará um roteiro seguindo a mesma estrutura e estilo do vídeo original
3. Mantenha os elementos que tornaram o vídeo original um sucesso: ganchos poderosos, ritmo envolvente, estrutura narrativa clara

**Elementos virais identificados:**
- Abertura enigmática que captura atenção imediata
- Desenvolvimento progressivo da narrativa
- Informações apresentadas de forma envolvente
- Conclusão que deixa o espectador querendo mais`;
            
            console.log(`[Agente] Usando fallback: prompt básico criado`);
        }

        const viralFormulaJson = viralFormulaData ? JSON.stringify(viralFormulaData) : null;

        // Salvar o agente no banco de dados
        const result = await db.run(
            `INSERT INTO script_agents (user_id, agent_name, niche, subniche, source_video_id, source_video_url, source_video_title, full_transcript, agent_prompt, agent_instructions, viral_formula_json)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, agentName, niche || null, subniche || null, videoId, videoUrl || null, videoTitle || null, fullTranscript, agentPromptText, agentInstructions, viralFormulaJson]
        );

        // Salvar automaticamente em agentes virais
        try {
            // Preparar instruções completas incluindo a fórmula viral se disponível
            let fullInstructions = agentInstructions || agentPromptText || '';
            if (viralFormulaJson) {
                try {
                    const formulaData = JSON.parse(viralFormulaJson);
                    fullInstructions += '\n\n=== FÓRMULA VIRAL IDENTIFICADA ===\n';
                    fullInstructions += JSON.stringify(formulaData, null, 2);
                } catch (e) {
                    fullInstructions += '\n\n=== FÓRMULA VIRAL ===\n' + viralFormulaJson;
                }
            }
            
            // Adicionar informações do vídeo fonte na descrição
            const description = `Agente gerado automaticamente a partir do vídeo "${videoTitle || 'N/A'}". ${niche ? `Nicho: ${niche}` : ''} ${subniche ? `| Subnicho: ${subniche}` : ''}`;
            
            // Verificar se as colunas existem antes de inserir
            // Adicionar colunas se não existirem (migração suave)
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN niche TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna niche:', e.message);
            }
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN subniche TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna subniche:', e.message);
            }
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN formula_json TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna formula_json:', e.message);
            }
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN source_video_id TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna source_video_id:', e.message);
            }
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN source_video_url TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna source_video_url:', e.message);
            }
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN source_video_title TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna source_video_title:', e.message);
            }
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN agent_prompt TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna agent_prompt:', e.message);
            }
            
            await db.run(`
                INSERT INTO viral_agents (
                    user_id, name, description, instructions, model, 
                    niche, subniche, formula_json, source_video_id, 
                    source_video_url, source_video_title, agent_prompt,
                    created_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            `, [
                userId,
                agentName,
                description,
                fullInstructions,
                'gpt-4o', // Modelo padrão
                niche || null,
                subniche || null,
                viralFormulaJson || null,
                videoId || null,
                videoUrl || null,
                videoTitle || null,
                agentPromptText || null
            ]);
            
            console.log('[Agente] ✅ Agente salvo automaticamente em agentes virais com todos os campos');
        } catch (viralAgentErr) {
            console.warn('[Agente] ⚠️ Erro ao salvar em agentes virais:', viralAgentErr.message);
            // Não falhar a criação do agente se não conseguir salvar em viral_agents
        }

        res.status(200).json({
            msg: 'Agente de roteiro criado com sucesso!',
            agentId: result.lastID,
            agent: {
                id: result.lastID,
                name: agentName,
                niche: niche || null,
                subniche: subniche || null,
                hasViralFormula: !!viralFormulaJson
            }
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/create]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao criar agente de roteiro.' });
    }
});

// === ROTA LAOZHANG PARA CRIAÇÃO DE AGENTES ===
app.post('/api/script-agents/create/laozhang', authenticateToken, async (req, res) => {
    const { videoId, videoUrl, videoTitle, agentName, niche, subniche, manualTranscript, viralInsights } = req.body;
    const userId = req.user.id;

    if (!videoId || !agentName) {
        return res.status(400).json({ msg: 'ID do vídeo e nome do agente são obrigatórios.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Buscar transcrição (mesma lógica da rota original)
        let fullTranscript = null;
        if (manualTranscript && manualTranscript.trim().length > 0) {
            fullTranscript = manualTranscript.trim();
        } else {
            const analysis = await db.get(
                'SELECT full_transcript FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                [videoId, userId]
            );
            if (analysis && analysis.full_transcript) {
                fullTranscript = analysis.full_transcript;
            }
        }

        // Criar prompt (mesma lógica da rota original, simplificado)
        let agentPrompt = fullTranscript && fullTranscript.trim().length >= 100
            ? `Você é um ESPECIALISTA EM ANÁLISE DE ROTEIROS VIRAIS para YouTube. Analise o roteiro abaixo e crie um agente de roteiro.

ROTEIRO: ${fullTranscript.substring(0, 20000)}
TÍTULO: ${videoTitle || 'N/A'}
NICHE: ${niche || 'N/A'}
SUBNICHE: ${subniche || 'N/A'}

Retorne JSON:
{
  "agent_prompt": "Prompt base...",
  "agent_instructions": "Instruções detalhadas..."
}`
            : `Crie um agente de roteiro baseado em:
TÍTULO: ${videoTitle || 'N/A'}
NICHE: ${niche || 'N/A'}
SUBNICHE: ${subniche || 'N/A'}

Retorne JSON:
{
  "agent_prompt": "Prompt base...",
  "agent_instructions": "Instruções detalhadas..."
}`;

        const response = await callLaozhangAPI(
            agentPrompt,
            laozhangApiKey,
            'claude-3-7-sonnet-20250219',
            null,
            userId,
            'api_script_agents_create',
            JSON.stringify({ endpoint: '/api/script-agents/create/laozhang', model: 'claude-3-7-sonnet-20250219' })
        );

        // Parsear resposta
        let agentPromptText, agentInstructions;
        let rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        // Limpar caracteres de controle inválidos do JSON
        // Remover quebras de linha e tabs não escapados dentro de strings JSON
        rawResponse = rawResponse
            .replace(/\n/g, '\\n')  // Escapar quebras de linha
            .replace(/\r/g, '\\r')  // Escapar carriage return
            .replace(/\t/g, '\\t')  // Escapar tabs
            .replace(/\f/g, '\\f')  // Escapar form feed
            .replace(/\b/g, '\\b')  // Escapar backspace
            // Mas manter quebras de linha válidas fora de strings (formatação JSON)
            .replace(/\\n(?=\s*[,\}\]])/g, '\n')  // Restaurar quebras de linha válidas após vírgulas/fechamentos
            .replace(/\\n(?=\s*")/g, '\n');      // Restaurar quebras de linha válidas antes de strings
        
        // Tentar extrair JSON de markdown code blocks primeiro
        const codeBlockMatch = rawResponse.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
        if (codeBlockMatch && codeBlockMatch[1]) {
            rawResponse = codeBlockMatch[1];
        }
        
        try {
            // Tentar parse direto
            const parsed = JSON.parse(rawResponse);
            agentPromptText = parsed.agent_prompt || parsed.agentPrompt;
            agentInstructions = parsed.agent_instructions || parsed.agentInstructions;
        } catch (e) {
            console.warn('[Agente Laozhang] Erro ao parsear JSON diretamente, tentando extrair:', e.message);
            
            // Tentar extrair JSON usando regex mais robusto
            const jsonMatch = rawResponse.match(/\{[\s\S]*"agent_prompt"[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    // Limpar caracteres de controle problemáticos antes de parsear
                    let cleanedJson = jsonMatch[0]
                        .replace(/[\x00-\x1F\x7F]/g, '') // Remover caracteres de controle
                        .replace(/([^\\])\n/g, '$1\\n')  // Escapar quebras de linha não escapadas
                        .replace(/([^\\])\r/g, '$1\\r')  // Escapar carriage return não escapados
                        .replace(/([^\\])\t/g, '$1\\t'); // Escapar tabs não escapados
                    
                    const parsed = JSON.parse(cleanedJson);
                    agentPromptText = parsed.agent_prompt || parsed.agentPrompt;
                    agentInstructions = parsed.agent_instructions || parsed.agentInstructions;
                } catch (e2) {
                    console.error('[Agente Laozhang] Erro ao parsear JSON extraído:', e2.message);
                    // Fallback: tentar extrair valores diretamente com regex
                    const promptMatch = rawResponse.match(/"agent_prompt"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
                    const instructionsMatch = rawResponse.match(/"agent_instructions"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
                    
                    if (promptMatch && promptMatch[1]) {
                        agentPromptText = promptMatch[1].replace(/\\n/g, '\n').replace(/\\"/g, '"');
                    }
                    if (instructionsMatch && instructionsMatch[1]) {
                        agentInstructions = instructionsMatch[1].replace(/\\n/g, '\n').replace(/\\"/g, '"');
                    }
                    
                    // Se ainda não conseguiu, usar fallback
                    if (!agentPromptText) {
                        agentPromptText = `Crie roteiros virais para YouTube no nicho ${niche || 'geral'}.`;
                    }
                    if (!agentInstructions) {
                        agentInstructions = `Agente criado a partir do vídeo "${videoTitle || 'N/A'}".`;
                    }
                }
            } else {
                console.warn('[Agente Laozhang] Nenhum JSON encontrado na resposta, usando fallback');
                // Fallback
                agentPromptText = `Crie roteiros virais para YouTube no nicho ${niche || 'geral'}.`;
                agentInstructions = `Agente criado a partir do vídeo "${videoTitle || 'N/A'}".`;
            }
        }
        
        // Garantir que temos valores válidos
        if (!agentPromptText || agentPromptText.trim().length === 0) {
            agentPromptText = `Crie roteiros virais para YouTube no nicho ${niche || 'geral'}.`;
        }
        if (!agentInstructions || agentInstructions.trim().length === 0) {
            agentInstructions = `Agente criado a partir do vídeo "${videoTitle || 'N/A'}".`;
        }

        // Salvar agente
        const result = await db.run(
            `INSERT INTO script_agents (user_id, agent_name, niche, subniche, source_video_id, source_video_url, source_video_title, full_transcript, agent_prompt, agent_instructions)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, agentName, niche || null, subniche || null, videoId, videoUrl || null, videoTitle || null, fullTranscript, agentPromptText, agentInstructions]
        );

        res.status(201).json({
            msg: 'Agente de roteiro criado com sucesso!',
            agentId: result.lastID
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/create/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao criar agente de roteiro.' });
    }
});

// Rota para listar todos os agentes de roteiro do usuário
app.get('/api/script-agents', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const agents = await db.all(
            `SELECT id, agent_name, niche, subniche, source_video_title, usage_count, created_at, updated_at
             FROM script_agents
             WHERE user_id = ?
             ORDER BY updated_at DESC`,
            [userId]
        );

        res.status(200).json({ agents });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents]:', err);
        res.status(500).json({ msg: 'Erro ao listar agentes de roteiro.' });
    }
});

// Rota para obter detalhes de um agente específico
app.get('/api/script-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        const agent = await db.get(
            `SELECT * FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        res.status(200).json({ agent });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId]:', err);
        res.status(500).json({ msg: 'Erro ao buscar agente.' });
    }
});

// Função helper para enviar progresso via SSE
function sendProgress(sessionId, data) {
    const client = sseClients.get(sessionId);
    if (client) {
        client.write(`data: ${JSON.stringify(data)}\n\n`);
    }
}

// Rota SSE para progresso em tempo real (aceita token via header ou query string)
app.get('/api/script-agents/progress/:sessionId', (req, res) => {
    const { sessionId } = req.params;
    
    // Permite token via Authorization header ou query ?token=
    const authHeader = req.headers['authorization'];
    let token = authHeader && authHeader.split(' ')[1];
    if (!token && req.query && req.query.token) {
        token = req.query.token;
    }
    
    if (!token) {
        return res.status(401).json({ msg: 'Token não fornecido.' });
    }
    
    jwt.verify(token, JWT_SECRET, (err) => {
        if (err) {
            return res.status(403).json({ msg: 'Token inválido ou expirado.' });
        }
        
        res.setHeader('Content-Type', 'text/event-stream');
        res.setHeader('Cache-Control', 'no-cache');
        res.setHeader('Connection', 'keep-alive');
        res.flushHeaders();
        
        sseClients.set(sessionId, res);
        console.log(`[SSE] Cliente conectado: ${sessionId}`);
        
        req.on('close', () => {
            sseClients.delete(sessionId);
            console.log(`[SSE] Cliente desconectado: ${sessionId}`);
        });
    });
});

// Rota para gerar roteiro usando um agente
app.post('/api/script-agents/:agentId/generate', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { title, topic, duration, language, cta, model, additionalInstructions, sessionId, parts } = req.body;
    const userId = req.user.id;

    if (!title) {
        return res.status(400).json({ msg: 'Título do vídeo é obrigatório.' });
    }

        // Se não fornecer duração, usar 5 minutos como padrão
        let scriptDuration = duration ? parseInt(duration) : 5;
        
        // Se não fornecer idioma, usar português como padrão
        const scriptLanguage = language || 'pt';
        
        // Configurar CTAs (Call to Action)
        const ctaConfig = {
            inicio: cta?.inicio || false,
            meio: cta?.meio || false,
            final: cta?.final !== undefined ? cta.final : true // Padrão: CTA no final
        };
        
        // Se não fornecer modelo, usar Claude como padrão (recomendado para roteiros)
        const selectedModel = model || 'claude-3-7-sonnet-20250219';
        
        // A duração já vem ajustada do frontend (com 3-5 minutos extras)
        // Não adicionar mais minutos aqui para evitar duplicação
        // Mas aumentar wordsPerMinute para garantir margem de segurança
        const originalDuration = scriptDuration;
        console.log(`[Script Generate] Duração recebida do frontend: ${scriptDuration} minutos (já ajustada)`);

    try {
        console.log(`[Script Generate] Requisição recebida - agentId: ${agentId}, userId: ${userId}, title: ${title}`);
        
        if (!agentId) {
            console.error(`[Script Generate] agentId não fornecido na URL`);
            return res.status(400).json({ msg: 'ID do agente é obrigatório.' });
        }

        // Buscar o agente
        console.log(`[Script Generate] Buscando agente com id=${agentId} e user_id=${userId}`);
        
        // Primeiro, verificar se o agente existe (sem filtro de user_id)
        const agentExists = await db.get(
            `SELECT id, user_id, agent_name FROM script_agents WHERE id = ?`,
            [agentId]
        );
        
        if (!agentExists) {
            console.error(`[Script Generate] Agente ${agentId} não existe no banco de dados`);
            // Listar todos os agentes do usuário para debug
            const userAgents = await db.all(
                `SELECT id, agent_name FROM script_agents WHERE user_id = ?`,
                [userId]
            );
            console.log(`[Script Generate] Agentes disponíveis para user_id=${userId}:`, userAgents);
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }
        
        if (agentExists.user_id !== userId) {
            console.error(`[Script Generate] Agente ${agentId} existe mas pertence ao user_id=${agentExists.user_id}, não ao user_id=${userId}`);
            return res.status(403).json({ msg: 'Você não tem permissão para usar este agente.' });
        }
        
        // Buscar o agente completo
        const agent = await db.get(
            `SELECT * FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );
        
        if (!agent) {
            console.error(`[Script Generate] Erro inesperado: agente existe mas não foi encontrado com filtro user_id`);
            return res.status(500).json({ msg: 'Erro ao buscar agente.' });
        }

        console.log(`[Script Generate] Agente encontrado: ${agent.agent_name || 'Sem nome'}`);

        // Identificar serviço e buscar chave
        let service;
        if (selectedModel.startsWith('gemini')) service = 'gemini';
        else if (selectedModel.startsWith('claude')) service = 'claude';
        else if (selectedModel.startsWith('gpt')) service = 'openai';
        else service = 'gemini';

        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
        if (!keyData) {
            return res.status(400).json({ msg: `Chave de API do ${service} não configurada.` });
        }
        const decryptedKey = decrypt(keyData.api_key);
        if (!decryptedKey) {
            return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
        }

        // Dividir em blocos de 3 minutos para respeitar o front-end
        const BASE_PART_DURATION = 3;
        const idealParts = Math.max(1, Math.ceil(scriptDuration / BASE_PART_DURATION));
        let requestedParts = parseInt(parts, 10);
        if (Number.isNaN(requestedParts) || requestedParts <= 0) {
            requestedParts = null;
        }
        // SEMPRE respeitar o número de partes solicitado pelo frontend
        let numberOfParts = requestedParts || idealParts;
        if (requestedParts) {
            console.log(`[Roteiro] Usando número de partes solicitado pelo frontend: ${requestedParts} (ideal seria ${idealParts})`);
            numberOfParts = requestedParts; // SEMPRE usar o valor do frontend
        } else {
            console.log(`[Roteiro] Nenhuma parte especificada, usando cálculo ideal: ${idealParts}`);
            numberOfParts = idealParts;
        }
        
        const partDurations = [];
        for (let idx = 0; idx < numberOfParts; idx++) {
            if (idx === numberOfParts - 1) {
                const consumed = BASE_PART_DURATION * (numberOfParts - 1);
                const remaining = scriptDuration - consumed;
                partDurations.push(remaining > 0 ? remaining : BASE_PART_DURATION);
            } else {
                partDurations.push(Math.min(BASE_PART_DURATION, scriptDuration));
            }
        }
        
        console.log(`[Roteiro] Duração: ${scriptDuration} minutos. Dividindo em ${numberOfParts} parte(s) (~3 minutos cada). Última parte: ${partDurations[numberOfParts - 1]} minuto(s).`);

        let scriptContent = '';

        // Se for dividido em partes, gerar cada parte separadamente
        if (numberOfParts > 1) {
            console.log(`[Roteiro] Gerando roteiro em ${numberOfParts} partes...`);
            const scriptParts = [];
            
            // Enviar progresso inicial
            if (sessionId) {
                sendProgress(sessionId, {
                    stage: 'generating',
                    progress: 0,
                    currentPart: 0,
                    totalParts: numberOfParts,
                    message: `Iniciando geração de ${numberOfParts} partes...`
                });
            }
            
            for (let partIndex = 0; partIndex < numberOfParts; partIndex++) {
                const isLastPart = partIndex === numberOfParts - 1;
                const currentPartDuration = partDurations[partIndex] || BASE_PART_DURATION;
                const currentPartWords = currentPartDuration * wordsPerMinute;
                const partNumber = partIndex + 1;
                
                console.log(`[Roteiro] Gerando parte ${partNumber}/${numberOfParts} (${currentPartDuration} minutos, ~${currentPartWords} palavras)...`);
                
                const partPrompt = `${agent.agent_prompt || 'Crie um roteiro viral para YouTube seguindo a estrutura e fórmula identificada no roteiro viral original.'}

INSTRUÇÕES DETALHADAS DO AGENTE (FÓRMULA VIRAL):
${agent.agent_instructions || ''}

${additionalInstructions ? `\nINSTRUÇÕES ADICIONAIS DO USUÁRIO:\n${additionalInstructions}\n` : ''}

TÍTULO DO VÍDEO PARA O QUAL DEVO CRIAR O ROTEIRO:
"${title}"

IMPORTANTE: Este é apenas a PARTE ${partNumber} de ${numberOfParts} do roteiro completo.

DURAÇÃO DESTA PARTE: ${currentPartDuration} minutos (${currentPartDuration * 60} segundos)

IDIOMA DO ROTEIRO: ${scriptLanguage === 'pt' ? 'Português (Brasil)' : scriptLanguage === 'pt-PT' ? 'Português (Portugal)' : scriptLanguage === 'es' ? 'Español' : scriptLanguage === 'en' ? 'English' : scriptLanguage === 'fr' ? 'Français' : scriptLanguage === 'de' ? 'Deutsch' : scriptLanguage === 'it' ? 'Italiano' : scriptLanguage === 'ru' ? 'Русский' : scriptLanguage === 'ja' ? '日本語' : scriptLanguage === 'zh' ? '中文' : scriptLanguage}

${(ctaConfig.inicio && partIndex === 0) || (ctaConfig.meio && partIndex === Math.floor(numberOfParts / 2)) || (ctaConfig.final && isLastPart) ? `═══════════════════════════════════════════════════════════════════
⚠️⚠️⚠️ CALL TO ACTION (CTA) - OBRIGATÓRIO E NATURAL ⚠️⚠️⚠️
═══════════════════════════════════════════════════════════════════
${ctaConfig.inicio && partIndex === 0 ? `✅ CTA no INÍCIO (primeiros 30 segundos): 
   - Você DEVE incluir uma chamada para ação NATURAL e ORGÂNICA nos primeiros 30 segundos desta parte
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar forçado
   - Exemplos naturais: "Se você está gostando deste conteúdo, já deixa seu like e se inscreva no canal para não perder os próximos vídeos", "Antes de continuar, se inscreva no canal e ative o sininho para receber notificações", "Se este conteúdo está te ajudando, já deixa seu like e comenta o que achou"
   - O CTA deve fazer parte do fluxo narrativo natural, não deve parecer uma interrupção
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, não uma marcação separada\n` : ''}
${ctaConfig.meio && partIndex === Math.floor(numberOfParts / 2) ? `✅ CTA no MEIO (aproximadamente na metade do vídeo):
   - Você DEVE incluir uma chamada para ação NATURAL e ORGÂNICA no meio desta parte
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar forçado
   - Exemplos naturais: "Se você está aprendendo algo novo aqui, já deixa seu like e compartilha com quem precisa ver isso", "Antes de continuarmos, se inscreva no canal para não perder o restante deste conteúdo", "Se este vídeo está te ajudando, já deixa seu like e comenta suas dúvidas"
   - O CTA deve fazer parte do fluxo narrativo natural, não deve parecer uma interrupção
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, não uma marcação separada\n` : ''}
${ctaConfig.final && isLastPart ? `✅ CTA no FINAL (últimos 30 segundos):
   - Você DEVE incluir uma chamada para ação FORTE, NATURAL e ORGÂNICA nos últimos 30 segundos desta parte
   - Este é o CTA mais importante - deve ser impactante mas ainda assim natural
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar forçado
   - Exemplos naturais: "Se este conteúdo te ajudou, já deixa seu like, se inscreva no canal, ative o sininho, compartilhe com seus amigos e comente o que achou", "Não esqueça de deixar seu like, se inscrever no canal e compartilhar este vídeo com quem precisa ver isso", "Se você gostou deste conteúdo, já deixa seu like, se inscreva no canal, ative o sininho para receber notificações e compartilhe com seus amigos"
   - O CTA deve fazer parte do fluxo narrativo natural, não deve parecer uma interrupção
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, não uma marcação separada
   - CRÍTICO: Este CTA final é essencial para o engajamento do vídeo\n` : ''}
⚠️ REGRAS IMPORTANTES SOBRE CTAs:
- Os CTAs devem ser incluídos de forma NATURAL e ORGÂNICA no texto narrativo
- NÃO use marcações como "[CTA]", "(CTA)", ou qualquer indicação explícita de CTA
- NÃO interrompa o fluxo narrativo abruptamente para incluir o CTA
- O CTA deve fazer parte da narrativa, como se fosse uma conversa natural com o espectador
- Use linguagem conversacional e envolvente
- Seja persuasivo mas genuíno, não forçado
- O CTA deve parecer que faz parte naturalmente do roteiro, não algo adicionado depois
` : ''}

${topic ? `TÓPICO ESPECÍFICO (se fornecido): ${topic}\n` : ''}
NICHE: ${agent.niche || 'N/A'}
SUBNICHE: ${agent.subniche || 'N/A'}

TAREFA:
Crie a PARTE ${partNumber} de ${numberOfParts} do roteiro COMPLETO e DETALHADO para o título acima, seguindo EXATAMENTE a mesma estrutura, ritmo, tom e elementos virais identificados no roteiro original.

O roteiro desta parte deve:
- Ter EXATAMENTE ${currentPartDuration} minutos de duração (${currentPartDuration * 60} segundos)
${!isLastPart ? `- ⚠️ CRÍTICO - ESTRUTURA OBRIGATÓRIA: Esta parte DEVE ter EXATAMENTE 5 PARÁGRAFOS
- Cada parte DEVE ter ENTRE 390 e 450 PALAVRAS (total da parte)
- Cada parágrafo DEVE ter ENTRE 75 e 90 PALAVRAS
- Distribuição ideal: 5 parágrafos × 78-90 palavras cada = 390-450 palavras totais
- Cada parágrafo deve ser separado por uma quebra de linha dupla (espaço em branco entre parágrafos)
- Os 5 parágrafos devem estar bem distribuídos ao longo dos ${currentPartDuration} minutos desta parte
- Estrutura obrigatória: 5 parágrafos distintos e bem definidos, cada um com 75-90 palavras` : `- Esta é a ÚLTIMA parte do roteiro - pode ter um número variável de parágrafos conforme necessário para concluir o conteúdo`}
- Replicar a estrutura narrativa exata do roteiro viral original
- Manter os mesmos elementos virais (ganchos, ritmo, tom, técnicas de engajamento)
- Adaptar o conteúdo para o novo título fornecido
- CRÍTICO: NÃO inclua marcações como "(Música...)", "(Visual:...)", "NARRADOR:", etc.
- O roteiro deve ser APENAS texto puro para voice over, sem direções de cena, música ou visualizações
- Escreva como se estivesse narrando diretamente, sem prefixos ou marcações técnicas
- Manter a fórmula de sucesso que tornou o roteiro original viral
- Distribuir o conteúdo proporcionalmente para preencher os ${currentPartDuration} minutos desta parte

FORMATO DE RESPOSTA OBRIGATÓRIO:
- Responda APENAS com o roteiro em TEXTO SIMPLES (não use JSON, não use estruturas de dados)
- NÃO use formato JSON, não use objetos, não use arrays, não use chaves {}
${!isLastPart ? `- ⚠️ CRÍTICO: Esta parte DEVE ter EXATAMENTE 5 PARÁGRAFOS
- Cada parte DEVE ter ENTRE 390 e 450 PALAVRAS (total da parte)
- Cada parágrafo DEVE ter ENTRE 75 e 90 PALAVRAS
- Distribuição ideal: 5 parágrafos × 78-90 palavras cada = 390-450 palavras totais
- Cada parágrafo deve ser separado por uma quebra de linha dupla (espaço em branco entre parágrafos)
- Estrutura obrigatória: 5 parágrafos distintos e bem definidos, cada um com 75-90 palavras
- Os 5 parágrafos devem estar bem distribuídos ao longo dos ${currentPartDuration} minutos desta parte` : `- Esta é a ÚLTIMA parte - pode ter um número variável de parágrafos conforme necessário para concluir`}
- O roteiro deve ser texto corrido, dividido em parágrafos ou seções claras
- Cada seção pode ter indicação de tempo entre parênteses ou colchetes, mas o conteúdo deve ser texto narrativo direto
- Exemplo de formato correto:
  "[0:00-0:30] Texto do roteiro aqui... 
  
  [0:30-1:30] Continuação do roteiro...
  
  [1:30-3:00] Mais conteúdo..."
  
- NÃO use formato como: {"section": "...", "time": "...", "content": "..."}
- NÃO use listas numeradas ou com marcadores para estruturar o roteiro
- O roteiro deve ser texto narrativo fluido, como se fosse o texto que será narrado no vídeo

REGRAS CRÍTICAS DE DURAÇÃO PARA ESTA PARTE - OBRIGATÓRIO:
- Esta PARTE ${partNumber} do roteiro DEVE ter EXATAMENTE ${currentPartDuration} minutos de duração
${!isLastPart ? `- ⚠️ CRÍTICO: Esta PARTE DEVE ter ENTRE 390 e 450 PALAVRAS (total)
- Esta PARTE DEVE ter EXATAMENTE 5 PARÁGRAFOS
- Cada PARÁGRAFO deve ter ENTRE 75 e 90 PALAVRAS
- Distribuição: 5 parágrafos × 78-90 palavras = 390-450 palavras totais
- META DE PALAVRAS DA PARTE: 390-450 palavras
- META DE PALAVRAS POR PARÁGRAFO: 75-90 palavras` : `- Esta é a ÚLTIMA parte - pode ter número variável de palavras e parágrafos conforme necessário`}
- ⚠️ CRÍTICO: Se você retornar menos de ${currentPartWords - 50} palavras ou mais de ${currentPartWords + 50} palavras, o roteiro será REJEITADO
- ⚠️ CRÍTICO: NÃO retorne JSON vazio, NÃO retorne objetos, NÃO retorne apenas estrutura - ESCREVA O ROTEIRO COMPLETO COM ${currentPartWords} PALAVRAS
- Se esta parte tiver menos de ${currentPartWords} palavras, você DEVE expandir o conteúdo até atingir EXATAMENTE ${currentPartWords} palavras
- Distribua o conteúdo proporcionalmente para preencher TODOS os ${currentPartDuration} minutos desta parte
- IMPORTANTE: Conte as palavras antes de finalizar. Esta parte DEVE ter entre ${currentPartWords} e ${currentPartWords + 50} palavras
- CRÍTICO: Se você não conseguir gerar ${currentPartWords} palavras, continue expandindo o conteúdo até atingir essa quantidade

CONTEXTO DA PARTE:
${partIndex === 0 ? '- Esta é a PRIMEIRA parte do roteiro. Comece com um gancho poderoso e envolvente.' : ''}
${!isLastPart ? `- Esta é a parte ${partNumber} de ${numberOfParts}. Continue a narrativa de forma fluida, desenvolvendo o tema.` : ''}
${isLastPart ? `- Esta é a ÚLTIMA parte do roteiro (parte ${partNumber} de ${numberOfParts}). Conclua de forma impactante e envolvente.` : ''}
${partIndex > 0 ? `- A parte anterior terminou em um ponto específico. Continue naturalmente a partir desse ponto.` : ''}

RESPOSTA FINAL - CRÍTICO:
- Responda APENAS com o roteiro em TEXTO SIMPLES e DIRETO
- NÃO use JSON, NÃO use objetos {}, NÃO use arrays [], NÃO use chaves ou colchetes para estruturar
- NÃO use formato: {"roteiro": "...", "duracao": "...", "estrutura": "..."}
- NÃO use formato: [{"section": "...", "time": "...", "content": "..."}]
- O roteiro deve ser texto corrido, como se você estivesse escrevendo o texto que será narrado
- ⚠️ CRÍTICO - NÃO INCLUA MARCAÇÕES DE PARTE OU TEMPO:
  - NÃO inclua marcações como "PARTE 1", "Parte 1", "PARTE 1 0:00 - 3:00", "Parte 1 0:00 - 3:00"
  - NÃO inclua marcações de tempo como "[0:00-3:00]", "(0:00)", "0:00 - 3:00", "0:00-3:00"
  - NÃO inclua qualquer indicação de número de parte ou intervalo de tempo no texto
  - O roteiro deve ser APENAS texto narrativo puro, sem marcações técnicas
  - Escreva como se estivesse narrando diretamente, sem prefixos, sem marcações de parte ou tempo
  - CRÍTICO: Se você incluir marcações de parte ou tempo, o roteiro será rejeitado
- IMPORTANTE: O roteiro será usado para VOICE OVER, então escreva de forma natural e fluida
- Use pontos finais e dois pontos para separar frases naturalmente
- Exemplo CORRETO de resposta:
  "[0:00-0:30] Em meio às selvas densas da América Central, duas civilizações se enfrentaram...
  
  [0:30-1:30] Os Mayas, mestres do tempo e da escrita, construíram impérios...
  
  [1:30-3:00] As raízes dos Mayas se estendem por séculos, florescendo nas terras baixas..."
  
- Exemplo ERRADO (NÃO FAÇA ISSO):
  {"roteiro": "texto", "duracao": "15 minutos"}
- O texto deve estar pronto para ser copiado e usado diretamente na narração do vídeo
- NÃO inclua NADA além do roteiro em si - nem explicações, nem metadados, nem JSON
- NÃO mencione que é "parte X" no texto do roteiro - escreva como se fosse um roteiro contínuo
- CRÍTICO: NÃO inclua marcações como "(Música...)", "(Visual:...)", "NARRADOR:", etc.
- O roteiro deve ser APENAS texto puro para voice over, sem direções de cena, música ou visualizações
- Escreva como se estivesse narrando diretamente, sem prefixos ou marcações técnicas
- Meta de palavras para ESTA PARTE: ${currentPartWords} palavras para ${currentPartDuration} minutos`;

                // Sistema de retry: tentar gerar a parte até 3x em caso de erro
                let partGenerationSuccess = false;
                let partResponse;
                let retryCount = 0;
                const MAX_RETRIES = 3;
                
                while (!partGenerationSuccess && retryCount < MAX_RETRIES) {
                    try {
                        if (retryCount > 0) {
                            console.log(`[Roteiro] Tentativa ${retryCount + 1}/${MAX_RETRIES} para parte ${partNumber}...`);
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'generating',
                                    progress: Math.min(80, Math.round((partIndex / numberOfParts) * 80)),
                                    currentPart: partNumber,
                                    totalParts: numberOfParts,
                                    message: `Refazendo parte ${partNumber}/${numberOfParts} (tentativa ${retryCount + 1}/${MAX_RETRIES})...`,
                                    details: {
                                        partNumber,
                                        status: 'generating',
                                        percentage: 5,
                                        completedParts: partIndex
                                    }
                                });
                            }
                        } else {
                            console.log(`[Roteiro] Chamando API ${service} para parte ${partNumber}...`);
                            // Enviar progresso da parte atual
                            if (sessionId) {
                                const partProgressStart = Math.min(80, Math.round((partIndex / numberOfParts) * 80));
                                sendProgress(sessionId, {
                                    stage: 'generating',
                                    progress: partProgressStart,
                                    currentPart: partNumber,
                                    totalParts: numberOfParts,
                                    message: `Gerando parte ${partNumber}/${numberOfParts}...`,
                                    details: {
                                        partNumber,
                                        status: 'generating',
                                        percentage: 5,
                                        completedParts: partIndex
                                    }
                                });
                            }
                        }
                        
                        if (service === 'gemini') {
                            partResponse = await callGeminiAPI(partPrompt, decryptedKey, selectedModel);
                        } else if (service === 'claude') {
                            partResponse = await callClaudeAPI(partPrompt, decryptedKey, selectedModel);
                        } else {
                            partResponse = await callOpenAIAPI(partPrompt, decryptedKey, selectedModel);
                        }
                        console.log(`[Roteiro] API ${service} respondeu para parte ${partNumber}`);
                        partGenerationSuccess = true;
                    } catch (partError) {
                        retryCount++;
                        console.error(`[Roteiro] Erro ao gerar parte ${partNumber} (tentativa ${retryCount}/${MAX_RETRIES}):`, partError.message);
                        
                        if (retryCount < MAX_RETRIES) {
                            console.log(`[Roteiro] Aguardando 2 segundos antes de tentar novamente...`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        } else {
                            // Após todas as tentativas, gerar mensagem de erro específica
                            console.error(`[Roteiro] Falha definitiva na parte ${partNumber} após ${MAX_RETRIES} tentativas`);
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'error',
                                    progress: Math.min(80, Math.round((partIndex / numberOfParts) * 80)),
                                    currentPart: partNumber,
                                    totalParts: numberOfParts,
                                    message: `❌ Erro na parte ${partNumber}/${numberOfParts} após ${MAX_RETRIES} tentativas. Continuando...`,
                                    details: {
                                        partNumber,
                                        status: 'error',
                                        percentage: 0,
                                        completedParts: partIndex
                                    }
                                });
                            }
                            throw partError; // Re-throw para ser capturado pelo catch externo
                        }
                    }
                }
                
                // Se chegou aqui, a parte foi gerada com sucesso
                try {

                    // Limpar resposta da parte
                    let partContent = extractTextFromAIResponse(partResponse).trim();
                    partContent = partContent
                        .replace(/^```[\w]*\n?/gm, '')
                        .replace(/```$/gm, '')
                        .replace(/^\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                        .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                        .replace(/"content"\s*:\s*"([^"]+)"/gi, '$1')
                        .replace(/"script"\s*:\s*"([^"]+)"/gi, '$1')
                        .replace(/\{[\s\S]*\}/g, '')
                        .trim();
                    
                    // Remover marcações de roteiro (música, visual, narrador, etc.) - apenas texto para voice over
                    partContent = cleanScriptForVoiceOver(partContent);

                    const partWordCount = partContent.trim().split(/\s+/).filter(w => w.length > 0).length;
                    console.log(`[Roteiro] Parte ${partNumber}/${numberOfParts} gerada: ${partWordCount} palavras (meta: ${currentPartWords})`);

                    // Validar e expandir parte se necessário
                    if (partWordCount < currentPartWords - 50) {
                        console.warn(`[Roteiro] Parte ${partNumber} muito curta: ${partWordCount} palavras. Expandindo...`);
                        if (sessionId) {
                            sendProgress(sessionId, {
                                stage: 'generating',
                                progress: Math.min(82, Math.round((partIndex / numberOfParts) * 80) + 5),
                                currentPart: partNumber,
                                totalParts: numberOfParts,
                                message: `Expandindo parte ${partNumber}/${numberOfParts} para atingir a minutagem...`,
                                details: {
                                    partNumber,
                                    status: 'expanding',
                                    percentage: Math.min(90, Math.round((partWordCount / currentPartWords) * 100)),
                                    completedParts: partIndex
                                }
                            });
                        }
                        const partExpansionPrompt = `O roteiro abaixo é a parte ${partNumber} de ${numberOfParts} e tem apenas ${partWordCount} palavras, mas precisa ter EXATAMENTE ${currentPartWords} palavras.

ROTEIRO DA PARTE ${partNumber} (${partWordCount} palavras - MUITO CURTO):
${partContent}

INSTRUÇÕES:
1. Expanda esta parte para ter EXATAMENTE ${currentPartWords} palavras
2. Mantenha o mesmo estilo e tom
3. Adicione mais detalhes, exemplos, explicações
4. NÃO use JSON, objetos ou arrays - apenas texto corrido
5. Responda APENAS com o roteiro expandido`;

                        try {
                            let expansionResponse;
                            if (service === 'gemini') {
                                expansionResponse = await callGeminiAPI(partExpansionPrompt, decryptedKey, selectedModel);
                            } else if (service === 'claude') {
                                expansionResponse = await callClaudeAPI(partExpansionPrompt, decryptedKey, selectedModel);
                            } else {
                                expansionResponse = await callOpenAIAPI(partExpansionPrompt, decryptedKey, selectedModel);
                            }

                            let expandedPart = extractTextFromAIResponse(expansionResponse).trim();
                            expandedPart = cleanScriptForVoiceOver(expandedPart)
                                .replace(/^```[\w]*\n?/gm, '')
                                .replace(/```$/gm, '')
                                .replace(/^\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                                .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                                .replace(/\{[\s\S]*\}/g, '')
                                .trim();

                            const expandedWordCount = expandedPart.trim().split(/\s+/).filter(w => w.length > 0).length;
                            if (expandedWordCount >= currentPartWords - 50) {
                                partContent = expandedPart;
                                console.log(`[Roteiro] Parte ${partNumber} expandida: ${expandedWordCount} palavras`);
                            }
                        } catch (expansionErr) {
                            console.error(`[Roteiro] Erro ao expandir parte ${partNumber}:`, expansionErr.message);
                        }
                    }

                    scriptParts.push(partContent);
                    
                    if (sessionId) {
                        const completedParts = partNumber;
                        const completionProgress = Math.min(85, Math.round((completedParts / numberOfParts) * 80));
                        const finalPartWords = partContent.trim().split(/\s+/).filter(w => w.length > 0).length;
                        sendProgress(sessionId, {
                            stage: 'generating',
                            progress: completionProgress,
                            currentPart: partNumber,
                            totalParts: numberOfParts,
                            message: `Parte ${partNumber}/${numberOfParts} concluída (${finalPartWords} palavras).`,
                            details: {
                                partNumber,
                                status: 'completed',
                                percentage: 100,
                                completedParts,
                                words: finalPartWords
                            }
                        });
                    }
                } catch (partErr) {
                    console.error(`[Roteiro] ❌ Erro DEFINITIVO ao processar parte ${partNumber} após ${MAX_RETRIES} tentativas:`, partErr.message);
                    
                    // Adicionar mensagem de erro ao array de partes (mantendo a posição)
                    scriptParts.push(`[ERRO NA PARTE ${partNumber}/${numberOfParts}]\n\n❌ Não foi possível gerar esta parte do roteiro após ${MAX_RETRIES} tentativas.\nMotivo: ${partErr.message}\n\nPor favor, gere novamente ou edite manualmente.\n\n[FIM DO ERRO - PARTE ${partNumber}]`);
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'error',
                            progress: Math.min(85, Math.round((partNumber / numberOfParts) * 80)),
                            currentPart: partNumber,
                            totalParts: numberOfParts,
                            message: `❌ Erro definitivo na parte ${partNumber}/${numberOfParts}. Continuando...`,
                            details: {
                                partNumber,
                                status: 'error',
                                percentage: 0,
                                completedParts: partNumber - 1
                            }
                        });
                    }
                    
                    // NÃO INTERROMPE O LOOP - continua gerando as próximas partes
                    console.log(`[Roteiro] Continuando com a próxima parte...`);
                }
            }
            
            // Após todas as partes serem geradas (com sucesso ou erro), continuar o processamento
            console.log(`[Roteiro] Todas as ${numberOfParts} partes foram processadas. Montando roteiro final...`);
            
            // Unir todas as partes em um roteiro completo
            const fullScript = scriptParts.join('\n\n---\n\n');
            const totalWords = fullScript.trim().split(/\s+/).filter(w => w.length > 0).length;
            
            console.log(`[Roteiro] Roteiro final montado: ${totalWords} palavras (${scriptParts.length} partes)`);
            
            // Verificar se há partes com erro
            const hasErrors = scriptParts.some(part => part.includes('[ERRO NA PARTE'));
            if (hasErrors) {
                console.warn(`[Roteiro] ⚠️ Roteiro contém partes com erro. O usuário deverá revisar.`);
            }
            
            // Continuar com a otimização e validação (mesmo com erros em algumas partes)
            if (sessionId) {
                sendProgress(sessionId, {
                    stage: hasErrors ? 'partial_success' : 'optimizing',
                    progress: 85,
                    message: hasErrors ? '⚠️ Roteiro gerado com algumas partes com erro. Otimizando...' : 'Otimizando roteiro...',
                    totalParts: numberOfParts,
                    details: {
                        completedParts: numberOfParts,
                        hasErrors: hasErrors
                    }
                });
            }
            
            // Usar o fullScript já montado com as partes (incluindo erros, se houver)
            scriptContent = fullScript;
        } else {
            // Se não precisa dividir, gerar normalmente
            const scriptPrompt = `${agent.agent_prompt}

TÍTULO DO VÍDEO PARA O QUAL VOCÊ DEVE GERAR O ROTEIRO:
"${title}"

${topic ? `CONTEXTO ADICIONAL FORNECIDO PELO USUÁRIO:
"${topic}"

` : ''}INSTRUÇÕES PARA GERAÇÃO DO ROTEIRO:

O roteiro deve:
- Ter EXATAMENTE ${scriptDuration} minutos de duração (${scriptDuration * 60} segundos)
- Replicar a estrutura narrativa exata do roteiro viral original
- Manter os mesmos elementos virais (ganchos, ritmo, tom, técnicas de engajamento)
- Adaptar o conteúdo para o novo título fornecido
- Incluir timing específico de cada seção para totalizar ${scriptDuration} minutos
- Manter a fórmula de sucesso que tornou o roteiro original viral
- Distribuir o conteúdo proporcionalmente para preencher os ${scriptDuration} minutos

FORMATO DE RESPOSTA OBRIGATÓRIO:
- Responda APENAS com o roteiro em TEXTO SIMPLES (não use JSON, não use estruturas de dados)
- NÃO use formato JSON, não use objetos, não use arrays, não use chaves {}
- O roteiro deve ser texto corrido, dividido em parágrafos ou seções claras
- Cada seção pode ter indicação de tempo entre parênteses ou colchetes, mas o conteúdo deve ser texto narrativo direto
- Exemplo de formato correto:
  "[0:00-0:30] Texto do roteiro aqui... 
  
  [0:30-1:30] Continuação do roteiro...
  
  [1:30-3:00] Mais conteúdo..."
  
- NÃO use formato como: {"section": "...", "time": "...", "content": "..."}
- NÃO use listas numeradas ou com marcadores para estruturar o roteiro
- O roteiro deve ser texto narrativo fluido, como se fosse o texto que será narrado no vídeo

REGRAS CRÍTICAS DE DURAÇÃO - OBRIGATÓRIO:
- O roteiro DEVE ter EXATAMENTE ${scriptDuration} minutos de duração
- O roteiro DEVE ter EXATAMENTE ${scriptDuration * wordsPerMinute} palavras (${wordsPerMinute} palavras por minuto)
- NÃO aceite menos de ${scriptDuration * wordsPerMinute} palavras - o roteiro DEVE ter NO MÍNIMO ${scriptDuration * wordsPerMinute} palavras
- NÃO aceite mais de ${(scriptDuration * wordsPerMinute) + 100} palavras - o roteiro DEVE ter NO MÁXIMO ${(scriptDuration * wordsPerMinute) + 100} palavras
- Se o roteiro tiver menos de ${scriptDuration * wordsPerMinute} palavras, você DEVE expandir o conteúdo até atingir EXATAMENTE ${scriptDuration * wordsPerMinute} palavras
- Distribua o conteúdo proporcionalmente para preencher TODOS os ${scriptDuration} minutos
- Certifique-se de que o tempo total indicado nas seções some ${scriptDuration} minutos (${scriptDuration * 60} segundos)
- IMPORTANTE: Conte as palavras antes de finalizar. O roteiro DEVE ter entre ${scriptDuration * wordsPerMinute} e ${(scriptDuration * wordsPerMinute) + 100} palavras
- CRÍTICO: Se você não conseguir gerar ${scriptDuration * wordsPerMinute} palavras, continue expandindo o conteúdo até atingir essa quantidade

RESPOSTA FINAL - CRÍTICO:
- Responda APENAS com o roteiro em TEXTO SIMPLES e DIRETO
- NÃO use JSON, NÃO use objetos {}, NÃO use arrays [], NÃO use chaves ou colchetes para estruturar
- NÃO use formato: {"roteiro": "...", "duracao": "...", "estrutura": "..."}
- NÃO use formato: [{"section": "...", "time": "...", "content": "..."}]
- O roteiro deve ser texto corrido, como se você estivesse escrevendo o texto que será narrado
- Você pode usar [0:00-0:30] para indicar tempo, mas o resto deve ser texto narrativo puro
- IMPORTANTE: O roteiro será usado para VOICE OVER, então escreva de forma natural e fluida
- Use pontos finais e dois pontos para separar frases naturalmente
- O texto deve estar pronto para ser copiado e usado diretamente na narração do vídeo
- NÃO inclua NADA além do roteiro em si - nem explicações, nem metadados, nem JSON
- Meta de palavras: aproximadamente ${scriptDuration * wordsPerMinute} palavras para ${scriptDuration} minutos`;

            let apiCallFunction;
            if (service === 'gemini') apiCallFunction = callGeminiAPI;
            else if (service === 'claude') apiCallFunction = callClaudeAPI;
            else apiCallFunction = callOpenAIAPI;

            const originalResponse = await apiCallFunction(scriptPrompt, decryptedKey, selectedModel);
            
            // Extrair conteúdo da resposta (pode vir em diferentes formatos)
            scriptContent = extractTextFromAIResponse(originalResponse) || '';

        // Limpar o roteiro: remover explicações, metadados, markdown, JSON, etc.
        // Garantir que a saída seja apenas o roteiro limpo em texto simples
        scriptContent = scriptContent
            // Remover estruturas JSON completas (objetos e arrays)
            .replace(/\{[\s\S]*?"script"[\s\S]*?\}/g, '')
            .replace(/\{[\s\S]*?"section"[\s\S]*?\}/g, '')
            .replace(/\{[\s\S]*?"content"[\s\S]*?\}/g, '')
            .replace(/\{[\s\S]*?"time"[\s\S]*?\}/g, '')
            // Remover arrays JSON
            .replace(/\[[\s\S]*?\{[\s\S]*?\}[\s\S]*?\]/g, '')
            // Extrair apenas o conteúdo de texto de estruturas JSON (se ainda houver)
            .replace(/"content"\s*:\s*"([^"]+)"/gi, '$1')
            .replace(/"text"\s*:\s*"([^"]+)"/gi, '$1')
            .replace(/"script"\s*:\s*"([^"]+)"/gi, '$1')
            // Remover blocos de código markdown
            .replace(/```[\s\S]*?```/g, '')
            // Remover JSON completo entre chaves (mais agressivo)
            .replace(/\{[^{}]*"roteiro"[\s\S]*?\}/g, '')
            .replace(/\{[^{}]*"duracao"[\s\S]*?\}/g, '')
            .replace(/\{[^{}]*"estrutura"[\s\S]*?\}/g, '')
            .replace(/\{[\s\S]{0,5000}\}/g, '')
            // Remover cabeçalhos markdown excessivos
            .replace(/^#{1,6}\s+.+$/gm, '')
            // Remover linhas que começam com "Roteiro:", "Script:", etc (metadados)
            .replace(/^(Roteiro|Script|Conteúdo|Texto|Output|Resultado|Aqui está|Segue|Abaixo está|Este é o|O roteiro é|title|section|time):\s*/gmi, '')
            // Remover explicações comuns no início/fim
            .replace(/\s*(Espero que|Espero|Boa sorte|Bom trabalho|Sucesso|Bom vídeo)\.?$/gmi, '')
            // Remover aspas JSON restantes
            .replace(/^["']|["']$/gm, '')
            // Remover múltiplas quebras de linha (mais de 2)
            .replace(/\n{3,}/g, '\n\n')
            // Limpar espaços no início e fim
            .trim();
        
        // Se o conteúdo ainda estiver muito curto ou vazio após limpeza, tentar extrair texto de JSON
        if (scriptContent.length < 100) {
            try {
                // Tentar encontrar e parsear JSON na resposta original
                const rawText = typeof originalResponse === 'string'
                    ? originalResponse
                    : JSON.stringify(originalResponse || '');
                const jsonMatch = rawText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const jsonObj = JSON.parse(jsonMatch[0]);
                    
                    if (jsonObj.script && Array.isArray(jsonObj.script)) {
                        // Extrair conteúdo de array de objetos (formato do exemplo do usuário)
                        scriptContent = jsonObj.script.map(item => {
                            if (item.content) {
                                const timeStr = item.time ? `[${item.time}] ` : '';
                                return timeStr + item.content;
                            }
                            if (typeof item === 'string') return item;
                            return '';
                        }).filter(Boolean).join('\n\n');
                    } else if (jsonObj.content) {
                        scriptContent = jsonObj.content;
                    } else if (jsonObj.script && typeof jsonObj.script === 'string') {
                        scriptContent = jsonObj.script;
                    } else if (jsonObj.text) {
                        scriptContent = jsonObj.text;
                    }
                }
            } catch (e) {
                // Se falhar ao parsear JSON, tentar extrair texto diretamente
                console.warn('[Roteiro] Erro ao parsear JSON, tentando extração direta:', e.message);
                
                // Tentar extrair conteúdo de strings JSON sem parsear completamente
                const rawText = typeof originalResponse === 'string'
                    ? originalResponse
                    : JSON.stringify(originalResponse || '');
                const contentMatches = rawText.match(/"content"\s*:\s*"([^"]+)"/gi);
                if (contentMatches && contentMatches.length > 0) {
                    scriptContent = contentMatches.map(match => {
                        const extracted = match.match(/"content"\s*:\s*"([^"]+)"/i);
                        return extracted ? extracted[1] : '';
                    }).filter(Boolean).join('\n\n');
                }
            }
        }
        
            // Garantir que o conteúdo final não esteja vazio
            if (!scriptContent || scriptContent.trim().length < 50) {
                console.warn('[Roteiro] Conteúdo muito curto após limpeza, usando resposta original');
                scriptContent = extractTextFromAIResponse(originalResponse) || '';
            }
        }

        // Validar quantidade de palavras e expandir se necessário
        // Usar 130 palavras/minuto de forma rigorosa
        const wordsPerMinuteRigorous = 130;
        const expectedWords = scriptDuration * wordsPerMinuteRigorous;
        // Tolerância mais rigorosa: máximo 10% acima da duração solicitada
        const maxAllowedMinutes = scriptDuration * 1.1; // Máximo 10% acima
        const maxWords = maxAllowedMinutes * wordsPerMinuteRigorous;
        const minWords = expectedWords - 30; // Tolerância mínima de -30 palavras
        
        let wordCount = scriptContent.trim().split(/\s+/).filter(w => w.length > 0).length;
        const estimatedMinutes = Math.round((wordCount / wordsPerMinuteRigorous) * 10) / 10;
        
        console.log(`[Roteiro] Validação rigorosa: ${wordCount} palavras encontradas (${estimatedMinutes} min), esperado: ${expectedWords} palavras (${scriptDuration} min)`);
        console.log(`[Roteiro] Tolerância: ${minWords}-${maxWords} palavras (${scriptDuration}-${maxAllowedMinutes.toFixed(1)} min)`);
        
        // Se o roteiro exceder muito a duração, avisar mas continuar
        if (estimatedMinutes > maxAllowedMinutes) {
            console.warn(`[Roteiro] ⚠️ Roteiro excede a duração solicitada: ${estimatedMinutes} min (solicitado: ${scriptDuration} min, máximo: ${maxAllowedMinutes.toFixed(1)} min)`);
        }

        // Tentar expandir até atingir a quantidade mínima (máximo 3 tentativas)
        let expansionAttempts = 0;
        const maxExpansionAttempts = 3;
        
        while (wordCount < minWords && expansionAttempts < maxExpansionAttempts) {
            expansionAttempts++;
            const wordsNeeded = expectedWords - wordCount;
            const expansionRatio = expectedWords / wordCount; // Quantas vezes precisa expandir
            
            console.warn(`[Roteiro] Tentativa ${expansionAttempts}/${maxExpansionAttempts}: Roteiro muito curto: ${wordCount} palavras (mínimo: ${minWords}). Expandindo...`);
            
            // Criar prompt de expansão mais agressivo
            const expansionPrompt = `O roteiro abaixo tem apenas ${wordCount} palavras, mas precisa ter EXATAMENTE ${expectedWords} palavras para ${scriptDuration} minutos de narração.

IMPORTANTE: 
- NÃO inclua marcações como "(Música...)", "(Visual:...)", "NARRADOR:", etc.
- O roteiro deve ser APENAS texto puro para voice over, sem direções de cena, música ou visualizações
- Escreva como se estivesse narrando diretamente, sem prefixos ou marcações técnicas

ROTEIRO ATUAL (${wordCount} palavras - MUITO CURTO):
${scriptContent}

INSTRUÇÕES CRÍTICAS:
1. Você DEVE expandir este roteiro para ter EXATAMENTE ${expectedWords} palavras (atualmente tem apenas ${wordCount})
2. Você precisa adicionar aproximadamente ${wordsNeeded} palavras a mais
3. Mantenha o mesmo estilo, tom e estrutura narrativa
4. Expanda CADA seção do roteiro proporcionalmente
5. Adicione mais detalhes, exemplos concretos, explicações profundas, desenvolvimento de ideias, contexto histórico, curiosidades, análises mais detalhadas
6. NÃO altere o início ou o final, mas expanda significativamente o conteúdo do meio
7. O roteiro deve continuar sendo texto corrido, SEM JSON, sem objetos, sem arrays
8. Cada parágrafo deve ser expandido com mais informações relevantes
9. Adicione transições mais elaboradas entre as seções
10. Desenvolva mais profundamente cada ideia apresentada
11. CRÍTICO: O roteiro final DEVE ter entre ${expectedWords} e ${expectedWords + 50} palavras
12. Conte mentalmente as palavras enquanto escreve. Se o roteiro não tiver pelo menos ${expectedWords} palavras, continue expandindo até atingir essa quantidade.
13. CRÍTICO: NÃO inclua marcações como "(Música...)", "(Visual:...)", "NARRADOR:", etc.
14. O roteiro deve ser APENAS texto puro para voice over, sem direções de cena, música ou visualizações
15. Escreva como se estivesse narrando diretamente, sem prefixos ou marcações técnicas

RESPOSTA FINAL - CRÍTICO:
Escreva APENAS o texto do roteiro expandido em TEXTO SIMPLES, sem explicações adicionais, sem metadados, NÃO use JSON.
Responda com o roteiro expandido imediatamente, sem envolver em objetos ou formatação especial.`;

            try {
                let expansionResponse;
                let usedService = service;
                
                // Tentar com a API principal
                try {
                if (service === 'gemini') {
                    expansionResponse = await callGeminiAPI(expansionPrompt, decryptedKey, selectedModel);
                } else if (service === 'claude') {
                    expansionResponse = await callClaudeAPI(expansionPrompt, decryptedKey, selectedModel);
                } else {
                    expansionResponse = await callOpenAIAPI(expansionPrompt, decryptedKey, selectedModel);
                    }
                } catch (apiErr) {
                    // Se falhou (503, timeout, etc), tentar API alternativa
                    const errorMsg = apiErr.message || '';
                    if (errorMsg.includes('overloaded') || errorMsg.includes('503') || errorMsg.includes('timeout') || errorMsg.includes('UNAVAILABLE')) {
                        console.warn(`[Roteiro] ⚠️ ${service} falhou (${errorMsg.substring(0, 100)}). Tentando API alternativa...`);
                        
                        // Tentar fallback: Gemini → Claude → OpenAI → (loop)
                        const fallbackOrder = service === 'gemini' 
                            ? ['claude', 'openai'] 
                            : service === 'claude'
                            ? ['openai', 'gemini']
                            : ['claude', 'gemini'];
                        
                        let fallbackSuccess = false;
                        for (const fallbackService of fallbackOrder) {
                            try {
                                const fallbackKey = await db.get(
                                    'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                                    [userId, fallbackService]
                                );
                                
                                if (fallbackKey) {
                                    const fallbackDecryptedKey = decrypt(fallbackKey.api_key);
                                    const fallbackModel = fallbackService === 'gemini' 
                                        ? 'gemini-2.5-pro' 
                                        : fallbackService === 'claude'
                                        ? 'claude-3-7-sonnet-20250219'
                                        : 'gpt-4o';
                                    
                                    console.log(`[Roteiro] 🔄 Tentando ${fallbackService} como fallback...`);
                                    
                                    if (fallbackService === 'gemini') {
                                        expansionResponse = await callGeminiAPI(expansionPrompt, fallbackDecryptedKey, fallbackModel);
                                    } else if (fallbackService === 'claude') {
                                        expansionResponse = await callClaudeAPI(expansionPrompt, fallbackDecryptedKey, fallbackModel);
                                    } else {
                                        expansionResponse = await callOpenAIAPI(expansionPrompt, fallbackDecryptedKey, fallbackModel);
                                    }
                                    
                                    usedService = fallbackService;
                                    fallbackSuccess = true;
                                    console.log(`[Roteiro] ✅ Fallback para ${fallbackService} bem-sucedido!`);
                                    break;
                                }
                            } catch (fallbackErr) {
                                console.warn(`[Roteiro] ⚠️ Fallback ${fallbackService} também falhou: ${fallbackErr.message.substring(0, 100)}`);
                            }
                        }
                        
                        if (!fallbackSuccess) {
                            throw apiErr; // Se todos falharam, lançar erro original
                        }
                    } else {
                        throw apiErr; // Se não é erro de sobrecarga, lançar erro
                    }
                }

                // Limpar resposta de expansão
                let expandedContent = extractTextFromAIResponse(expansionResponse).trim();
                expandedContent = cleanScriptForVoiceOver(expandedContent);
                expandedContent = expandedContent
                    .replace(/^```[\w]*\n?/gm, '')
                    .replace(/```$/gm, '')
                    .replace(/^\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                    .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/"content"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/"script"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/\{[\s\S]*\}/g, '')
                    .replace(/\[[\s\S]*?\]/g, '') // Remover arrays JSON
                    .trim();

                const expandedWordCount = expandedContent.trim().split(/\s+/).filter(w => w.length > 0).length;
                console.log(`[Roteiro] Após tentativa ${expansionAttempts}: ${expandedWordCount} palavras (meta: ${expectedWords})`);

                if (expandedWordCount >= minWords) {
                    scriptContent = expandedContent;
                    wordCount = expandedWordCount;
                    console.log(`[Roteiro] ✅ Expansão bem-sucedida! Roteiro agora tem ${wordCount} palavras.`);
                    break; // Sair do loop se atingiu o mínimo
                } else if (expandedWordCount > wordCount) {
                    // Mesmo que não tenha atingido o mínimo, se expandiu, usar o expandido
                    scriptContent = expandedContent;
                    wordCount = expandedWordCount;
                    console.log(`[Roteiro] Roteiro expandido de ${wordCount} para ${expandedWordCount} palavras, mas ainda abaixo do mínimo. Tentando novamente...`);
                } else {
                    console.warn(`[Roteiro] Expansão não aumentou o número de palavras. Tentando abordagem diferente...`);
                }
            } catch (expansionErr) {
                console.error(`[Roteiro] Erro na tentativa ${expansionAttempts} de expansão:`, expansionErr.message);
                // Continuar para próxima tentativa ou usar o que temos
            }
        }

        // Verificação final - se ainda estiver muito curto, fazer uma última tentativa com prompt diferente
        if (wordCount < minWords) {
            console.warn(`[Roteiro] Roteiro ainda muito curto após ${expansionAttempts} tentativas: ${wordCount} palavras. Fazendo última tentativa...`);
            
            // Última tentativa: pedir para duplicar e expandir o conteúdo
            const finalExpansionPrompt = `O roteiro abaixo precisa ser DUPLICADO e EXPANDIDO para ter EXATAMENTE ${expectedWords} palavras.

IMPORTANTE: 
- NÃO inclua marcações como "(Música...)", "(Visual:...)", "NARRADOR:", etc.
- O roteiro deve ser APENAS texto puro para voice over, sem direções de cena, música ou visualizações
- Escreva como se estivesse narrando diretamente, sem prefixos ou marcações técnicas

ROTEIRO ATUAL (${wordCount} palavras):
${scriptContent}

INSTRUÇÕES FINAIS:
1. Você DEVE criar um roteiro com EXATAMENTE ${expectedWords} palavras
2. Mantenha a estrutura e o estilo, mas EXPANDA CADA IDEIA significativamente
3. Adicione exemplos, detalhes, explicações, contexto, curiosidades
4. Desenvolva cada parágrafo com muito mais profundidade
5. SEM JSON, objetos ou arrays - apenas texto corrido
6. CRÍTICO: NÃO inclua marcações como "(Música...)", "(Visual:...)", "NARRADOR:", etc.
7. O roteiro deve ser APENAS texto puro para voice over, sem direções de cena, música ou visualizações
8. Escreva como se estivesse narrando diretamente, sem prefixos ou marcações técnicas
9. Responda APENAS com o roteiro expandido

RESPOSTA FINAL - CRÍTICO:
Escreva APENAS o texto do roteiro expandido em TEXTO SIMPLES, NÃO use JSON.`;

            try {
                let finalResponse;
                if (service === 'gemini') {
                    finalResponse = await callGeminiAPI(finalExpansionPrompt, decryptedKey, selectedModel);
                } else if (service === 'claude') {
                    finalResponse = await callClaudeAPI(finalExpansionPrompt, decryptedKey, selectedModel);
                } else {
                    finalResponse = await callOpenAIAPI(finalExpansionPrompt, decryptedKey, selectedModel);
                }

                let finalContent = extractTextFromAIResponse(finalResponse).trim()
                    .replace(/^```[\w]*\n?/gm, '')
                    .replace(/```$/gm, '')
                    .replace(/^\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                    .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/\{[\s\S]*\}/g, '')
                    .trim();

                const finalWordCount = finalContent.trim().split(/\s+/).filter(w => w.length > 0).length;
                if (finalWordCount >= minWords) {
                    scriptContent = finalContent;
                    wordCount = finalWordCount;
                    console.log(`[Roteiro] ✅ Última tentativa bem-sucedida! Roteiro agora tem ${wordCount} palavras.`);
                }
            } catch (finalErr) {
                console.error('[Roteiro] Erro na última tentativa de expansão:', finalErr.message);
            }
        }

        // Verificação final - se ainda estiver muito curto, usar o que temos mas avisar
        const finalWordCount = scriptContent.trim().split(/\s+/).filter(w => w.length > 0).length;
        if (finalWordCount < minWords) {
            console.warn(`[Roteiro] ⚠️ Roteiro final ainda abaixo do mínimo após todas as tentativas: ${finalWordCount} palavras (mínimo: ${minWords})`);
            // Em vez de retornar erro, vamos usar o roteiro mesmo que curto, mas adicionar uma nota
            // O sistema vai continuar funcionando, mas o usuário será avisado
            console.log(`[Roteiro] Usando roteiro com ${finalWordCount} palavras (abaixo do ideal de ${expectedWords}, mas funcional)`);
        } else {
            console.log(`[Roteiro] ✅ Roteiro validado com sucesso: ${finalWordCount} palavras (meta: ${expectedWords})`);
        }

        // === OTIMIZAÇÃO DO ROTEIRO ===
        console.log('[Otimizador] 🔍 Analisando roteiro gerado...');
        
        // Progresso: 90% - Iniciando otimização
        if (sessionId) {
            sendProgress(sessionId, {
                stage: 'optimizing',
                progress: 90,
                message: 'Analisando qualidade do roteiro...'
            });
        }
        
        const optimizer = new ScriptOptimizer(agent.niche || 'geral');
        const analysis = optimizer.analyzeScript(scriptContent);
        const optimizationReport = optimizer.generateReport(analysis);
        
        console.log('[Otimizador] 📊 Análise concluída:');
        console.log(`  - Score Geral: ${analysis.overallScore}/10`);
        console.log(`  - Retenção: ${analysis.retentionScore}/10`);
        console.log(`  - Autenticidade: ${analysis.authenticityScore}/10`);
        console.log(`  - Alinhamento: ${analysis.nicheAlignment}/10`);
        console.log(`  - Problemas detectados: ${analysis.problems.length}`);
        console.log(`  - Indicadores de IA: ${analysis.aiIndicators.length}`);
        console.log(`  - Clichês: ${analysis.cliches.length}`);
        
        // === PÓS-PROCESSAMENTO AUTOMÁTICO ===
        // Se score < 8 ou tem muitos problemas, aplicar otimizações automáticas
        let finalScriptContent = scriptContent;
        let needsOptimization = false;
        let optimizationReason = '';
        
        // 🚨 CRÍTICO: SEMPRE otimizar se há inconsistências de nomes (DESASTRE TOTAL)
        if (analysis.nameInconsistencies && analysis.nameInconsistencies.length > 0) {
            needsOptimization = true;
            optimizationReason = `🚨 DESASTRE TOTAL: ${analysis.nameInconsistencies.length} inconsistências de nomes detectadas`;
            console.log(`[Otimizador] 🚨 CRÍTICO: ${analysis.nameInconsistencies.length} inconsistências de nomes! FORÇANDO otimização...`);
        } 
        // Verificar se precisa otimizar por score baixo
        else if (analysis.overallScore < 8) {
            needsOptimization = true;
            optimizationReason = `Score ${analysis.overallScore}/10 está abaixo de 8`;
            console.log(`[Otimizador] 🔧 ${optimizationReason}. Aplicando correções...`);
        } 
        // Verificar se tem muitos clichês
        else if (analysis.cliches.length > 3) {
            needsOptimization = true;
            optimizationReason = `${analysis.cliches.length} clichês detectados`;
            console.log(`[Otimizador] 🔧 ${optimizationReason}. Aplicando correções...`);
        } 
        // Verificar se tem muitos indicadores de IA
        else if (analysis.aiIndicators.length > 2) {
            needsOptimization = true;
            optimizationReason = `${analysis.aiIndicators.length} indicadores de IA detectados`;
            console.log(`[Otimizador] 🔧 ${optimizationReason}. Aplicando correções...`);
        }
        
        if (needsOptimization) {
            // Progresso: 93% - Otimizando
            if (sessionId) {
                sendProgress(sessionId, {
                    stage: 'optimizing',
                    progress: 93,
                    message: 'Removendo repetições e clichês...'
                });
            }
            
            try {
                const originalWordCount = scriptContent.split(/\s+/).filter(w => w.length > 0).length;
                
                // FASE 1: Otimizações Básicas
                if (sessionId) {
                    sendProgress(sessionId, {
                        stage: 'optimizing',
                        progress: 93,
                        message: '🔧 Normalizando nomes de personagens...',
                        details: {
                            phase: 'basic',
                            step: 'normalize_names'
                        }
                    });
                }
                
                finalScriptContent = optimizer.optimizeScript(scriptContent);
                
                if (sessionId) {
                    sendProgress(sessionId, {
                        stage: 'optimizing',
                        progress: 94,
                        message: '🧹 Removendo repetições e clichês...',
                        details: {
                            phase: 'basic',
                            step: 'remove_repetitions'
                        }
                    });
                }
                
                finalScriptContent = removeRepetitions(finalScriptContent);
                finalScriptContent = optimizer.humanizeText(finalScriptContent);
                
                // Garantir que não diminuiu muito o tamanho
                const currentWordCount = finalScriptContent.split(/\s+/).filter(w => w.length > 0).length;
                if (currentWordCount < originalWordCount * 0.85) {
                    console.warn(`[Otimizador] ⚠️ Roteiro reduziu muito: ${originalWordCount} → ${currentWordCount} palavras. Revertendo...`);
                    finalScriptContent = scriptContent; // Reverter para o original
                }
                
                // Re-analisar após otimizações básicas
                let finalAnalysis = optimizer.analyzeScript(finalScriptContent);
                console.log(`[Otimizador] ✅ Otimização básica concluída! Score: ${analysis.overallScore}/10 → ${finalAnalysis.overallScore}/10`);
                
                if (sessionId) {
                    sendProgress(sessionId, {
                        stage: 'optimizing',
                        progress: 94,
                        message: `✅ Fase 1 concluída - Score: ${finalAnalysis.overallScore}/10`,
                        details: {
                            phase: 'basic',
                            step: 'complete',
                            score: finalAnalysis.overallScore,
                            wordCount: currentWordCount
                        }
                    });
                }
                
                // FASE 2: 🎯 REPLICADOR DE FÓRMULA VIRAL (usa fórmula armazenada ou transcrição original)
                const hasOriginalScript = agent.full_transcript && agent.full_transcript.trim().length > 500;
                let storedViralFormula = null;
                if (agent.viral_formula_json) {
                    try {
                        storedViralFormula = JSON.parse(agent.viral_formula_json);
                    } catch (formulaParseErr) {
                        console.warn('[Otimizador] ⚠️ Não foi possível parsear viral_formula_json do agente:', formulaParseErr.message);
                    }
                }
                const canReplicateStructure = !!storedViralFormula || hasOriginalScript;
                
                if (canReplicateStructure) {
                    console.log('[Otimizador] 🎯 Aplicando REPLICADOR DE FÓRMULA VIRAL (obrigatório para manter a estrutura original).');
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'viral_replication',
                            progress: 95,
                            message: storedViralFormula
                                ? '🎯 Aplicando fórmula viral armazenada...'
                                : '🎯 Analisando fórmula viral do roteiro original...',
                            details: {
                                phase: 'viral',
                                step: storedViralFormula ? 'loading_formula' : 'analyzing_formula'
                            }
                        });
                    }
                    
                    try {
                        const claudeKeyData = await db.get(
                            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                            [userId, 'claude']
                        );
                        
                        if (claudeKeyData && claudeKeyData.api_key) {
                            const claudeApiKey = decrypt(claudeKeyData.api_key);
                            const viralReplicator = new ViralFormulaReplicator();
                            
                            let viralFormula = storedViralFormula;
                            
                            // Passo 1: Analisar fórmula viral do roteiro original caso não exista uma armazenada
                            if (!viralFormula && hasOriginalScript) {
                                viralFormula = await viralReplicator.analyzeViralFormula(
                                    agent.full_transcript,
                                    claudeApiKey,
                                    agent.source_video_title || title,
                                    agent.niche
                                );
                                
                                // Armazenar para reutilização futura
                                if (viralFormula) {
                                    try {
                                        await db.run(
                                            `UPDATE script_agents SET viral_formula_json = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                            [JSON.stringify(viralFormula), agent.id]
                                        );
                                        console.log('[Otimizador] 💾 Fórmula viral salva no agente para reutilização.');
                                    } catch (saveErr) {
                                        console.warn('[Otimizador] ⚠️ Não foi possível salvar a fórmula viral no agente:', saveErr.message);
                                    }
                                }
                            }

                            if (!viralFormula) {
                                console.warn('[Otimizador] ⚠️ Fórmula viral não disponível. Pulando replicação.');
                                if (sessionId) {
                                    sendProgress(sessionId, {
                                        stage: 'viral_replication',
                                        progress: 96,
                                        message: '⚠️ Fórmula viral indisponível para replicação',
                                        details: {
                                            phase: 'viral',
                                            step: 'skipped',
                                            reason: 'formula_missing'
                                        }
                                    });
                                }
                                throw new Error('Fórmula viral indisponível');
                            }
                            
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'viral_replication',
                                    progress: 96,
                                    message: storedViralFormula ? '🚀 Aplicando fórmula viral armazenada...' : '🚀 Replicando fórmula viral no novo roteiro...',
                                    details: {
                                        phase: 'viral',
                                        step: storedViralFormula ? 'applying_formula' : 'replicating_formula',
                                        formula: viralFormula
                                    }
                                });
                            }
                            
                            // Passo 2: Replicar fórmula no novo roteiro
                            const replicationResult = await viralReplicator.replicateFormula(
                                viralFormula,
                                title,
                                agent.full_transcript || '[Fórmula carregada sem transcrição completa]',
                                finalScriptContent,
                                claudeApiKey,
                                agent.niche,
                                scriptDuration
                            );
                            
                            if (replicationResult.success) {
                                const newWordCount = replicationResult.replicatedScript.split(/\s+/).filter(w => w.length > 0).length;
                                
                                // Validar que não diminuiu muito
                                if (newWordCount < originalWordCount * 0.85) {
                                    console.warn(`[Otimizador] ⚠️ Replicação diminuiu muito: ${originalWordCount} → ${newWordCount}. Mantendo versão anterior.`);
                                } else {
                                    finalScriptContent = replicationResult.replicatedScript;
                                    console.log('[Otimizador] 🎉 Fórmula viral replicada com sucesso!');
                                    
                                    if (sessionId) {
                                        sendProgress(sessionId, {
                                            stage: 'viral_replication',
                                            progress: 97,
                                            message: '✅ Fórmula viral replicada! Roteiro 10/10',
                                            details: {
                                                phase: 'viral',
                                                step: 'replicated',
                                                newWordCount: newWordCount,
                                                formula: viralFormula
                                            }
                                        });
                                    }
                                    
                                    // Re-analisar após replicação
                                    finalAnalysis = optimizer.analyzeScript(finalScriptContent);
                                    console.log(`[Otimizador] 🚀 Score FINAL após replicação viral: ${finalAnalysis.overallScore}/10`);
                                }
                            }
                        } else {
                            console.warn('[Otimizador] ⚠️ API Key do Claude não encontrada para replicação viral.');
                        }
                    } catch (viralErr) {
                        console.error('[Otimizador] ⚠️ Erro na replicação viral:', viralErr.message);
                        console.log('[Otimizador] Continuando sem replicação viral.');
                    }
                }
                
                // FASE 3: 🤖 VALIDAÇÃO INTELIGENTE COM CLAUDE AI (se score ainda baixo e não tem roteiro original)
                const needsAICorrection = (
                    finalAnalysis.overallScore < 7 ||
                    (finalAnalysis.nameInconsistencies && finalAnalysis.nameInconsistencies.length > 0) ||
                    finalAnalysis.aiIndicators.length > 2 ||
                    finalAnalysis.cliches.length > 5
                );
                
                if (needsAICorrection) {
                    console.log(`[Otimizador] 🤖 Score ${finalAnalysis.overallScore}/10 ainda baixo. Ativando VALIDADOR INTELIGENTE (Claude AI)...`);
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'ai_correction',
                            progress: 95,
                            message: '🤖 Claude AI analisando problemas...',
                            details: {
                                phase: 'ai',
                                step: 'analyzing',
                                currentScore: finalAnalysis.overallScore,
                                problems: finalAnalysis.problems.length,
                                nameInconsistencies: finalAnalysis.nameInconsistencies?.length || 0
                            }
                        });
                    }
                    
                    try {
                        // Buscar API key do Claude
                        const claudeKeyData = await db.get(
                            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                            [userId, 'claude']
                        );
                        
                        if (claudeKeyData && claudeKeyData.api_key) {
                            const claudeApiKey = decrypt(claudeKeyData.api_key);
                            const aiValidator = new AIScriptValidator();
                            
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'ai_correction',
                                    progress: 96,
                                    message: '✍️ Claude AI reescrevendo roteiro...',
                                    details: {
                                        phase: 'ai',
                                        step: 'rewriting'
                                    }
                                });
                            }
                            
                            const validationResult = await aiValidator.validateAndFixScript(
                                finalScriptContent,
                                finalAnalysis,
                                claudeApiKey,
                                agent.niche,
                                title
                            );
                            
                            if (validationResult.success) {
                                const newWordCount = validationResult.correctedScript.split(/\s+/).filter(w => w.length > 0).length;
                                
                                // Validar que não diminuiu o tamanho
                                if (newWordCount < originalWordCount * 0.85) {
                                    console.warn(`[Otimizador] ⚠️ Claude reduziu muito o roteiro: ${originalWordCount} → ${newWordCount}. Mantendo versão anterior.`);
                                    if (sessionId) {
                                        sendProgress(sessionId, {
                                            stage: 'ai_correction',
                                            progress: 97,
                                            message: '⚠️ Roteiro corrigido muito curto, mantendo versão anterior',
                                            details: {
                                                phase: 'ai',
                                                step: 'rejected',
                                                reason: 'too_short'
                                            }
                                        });
                                    }
                                } else {
                                    finalScriptContent = validationResult.correctedScript;
                                    console.log('[Otimizador] 🎉 Claude AI corrigiu o roteiro!');
                                    console.log(`[Otimizador] 📊 Melhorias: ${validationResult.improvements.join(', ')}`);
                                    
                                    if (sessionId) {
                                        sendProgress(sessionId, {
                                            stage: 'ai_correction',
                                            progress: 97,
                                            message: '✅ Claude AI finalizou correção!',
                                            details: {
                                                phase: 'ai',
                                                step: 'corrected',
                                                improvements: validationResult.improvements,
                                                newWordCount: newWordCount
                                            }
                                        });
                                    }
                                    
                                    // Re-analisar após correção da IA
                                    finalAnalysis = optimizer.analyzeScript(finalScriptContent);
                                    console.log(`[Otimizador] 🚀 Score FINAL após Claude: ${finalAnalysis.overallScore}/10`);
                                }
                            }
                        } else {
                            console.warn('[Otimizador] ⚠️ API Key do Claude não encontrada. Pulando validação inteligente.');
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'ai_correction',
                                    progress: 95,
                                    message: '⚠️ API Key do Claude não configurada',
                                    details: {
                                        phase: 'ai',
                                        step: 'skipped',
                                        reason: 'no_api_key'
                                    }
                                });
                            }
                        }
                    } catch (aiErr) {
                        console.error('[Otimizador] ⚠️ Erro na validação com Claude:', aiErr.message);
                        console.log('[Otimizador] Continuando com otimização básica.');
                        if (sessionId) {
                            sendProgress(sessionId, {
                                stage: 'ai_correction',
                                progress: 95,
                                message: `⚠️ Erro no Claude: ${aiErr.message}`,
                                details: {
                                    phase: 'ai',
                                    step: 'error',
                                    error: aiErr.message
                                }
                            });
                        }
                    }
                }
                
                // Atualizar análise final
                analysis.overallScore = finalAnalysis.overallScore;
                analysis.retentionScore = finalAnalysis.retentionScore;
                analysis.authenticityScore = finalAnalysis.authenticityScore;
                analysis.nicheAlignment = finalAnalysis.nicheAlignment;
                analysis.problems = finalAnalysis.problems;
                analysis.cliches = finalAnalysis.cliches;
                analysis.aiIndicators = finalAnalysis.aiIndicators;
                analysis.nameInconsistencies = finalAnalysis.nameInconsistencies || [];
                
                // 🚨 VALIDAÇÃO CRÍTICA: NOTA MÍNIMA 8.5/10
                const MIN_SCORE_REQUIRED = 9;
                if (finalAnalysis.overallScore < MIN_SCORE_REQUIRED) {
                    const errorMsg = `Roteiro não atingiu a nota mínima de ${MIN_SCORE_REQUIRED}/10. Score atual: ${finalAnalysis.overallScore}/10`;
                    console.error(`[Otimizador] ❌ ${errorMsg}`);
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'failed',
                            progress: 98,
                            message: `❌ Score ${finalAnalysis.overallScore}/10 abaixo do mínimo (${MIN_SCORE_REQUIRED})`,
                            details: {
                                phase: 'validation',
                                step: 'failed',
                                score: finalAnalysis.overallScore,
                                minRequired: MIN_SCORE_REQUIRED,
                                problems: finalAnalysis.problems,
                                suggestions: finalAnalysis.suggestions
                            }
                        });
                    }
                    
                    throw new Error(`${errorMsg}\n\nProblemas encontrados:\n${finalAnalysis.problems.join('\n')}\n\nSugestões:\n${finalAnalysis.suggestions.join('\n')}\n\nPor favor, tente:\n1. Usar outro modelo de IA (Claude recomendado)\n2. Fornecer um título mais específico\n3. Revisar o agente de roteiro\n4. Gerar novamente com instruções mais detalhadas`);
                }
                
                // Validar que não há inconsistências críticas
                if (finalAnalysis.nameInconsistencies && finalAnalysis.nameInconsistencies.length > 0) {
                    const errorMsg = `Roteiro ainda contém ${finalAnalysis.nameInconsistencies.length} inconsistências de nomes após otimização`;
                    console.error(`[Otimizador] ❌ ${errorMsg}`);
                    console.error(`Inconsistências: ${finalAnalysis.nameInconsistencies.join(', ')}`);
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'failed',
                            progress: 98,
                            message: '❌ Inconsistências de nomes não corrigidas',
                            details: {
                                phase: 'validation',
                                step: 'failed',
                                nameInconsistencies: finalAnalysis.nameInconsistencies
                            }
                        });
                    }
                    
                    throw new Error(`${errorMsg}:\n${finalAnalysis.nameInconsistencies.join('\n')}\n\nO roteiro não pode ser finalizado com nomes de personagens inconsistentes. Tente gerar novamente.`);
                }
                
                console.log(`[Otimizador] ✅ Validação final aprovada! Score: ${finalAnalysis.overallScore}/10`);
                
                if (sessionId) {
                    sendProgress(sessionId, {
                        stage: 'validating',
                        progress: 98,
                        message: `✅ Validação aprovada! Score: ${finalAnalysis.overallScore}/10`,
                        details: {
                            phase: 'validation',
                            step: 'passed',
                            score: finalAnalysis.overallScore,
                            wordCount: finalScriptContent.split(/\s+/).filter(w => w.length > 0).length
                        }
                    });
                }
                
            } catch (optErr) {
                console.error('[Otimizador] Erro na otimização:', optErr.message);
                console.log('[Otimizador] Usando roteiro original sem otimizações');
                finalScriptContent = scriptContent;
            }
        } else {
            console.log(`[Otimizador] ✅ Roteiro já está em alta qualidade (score ${analysis.overallScore}/10)`);
        }
        
        scriptContent = finalScriptContent;
        
        // Aplicar limpeza final para remover qualquer marcação restante
        scriptContent = cleanScriptForVoiceOver(scriptContent);

        // Salvar o roteiro gerado com análise de otimização
        const scriptResult = await db.run(
            `INSERT INTO generated_scripts (user_id, script_agent_id, title, script_content, model_used, niche, subniche, optimization_score, optimization_report, retention_score, authenticity_score)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, agentId, title, scriptContent, selectedModel, agent.niche, agent.subniche, analysis.overallScore, optimizationReport, analysis.retentionScore, analysis.authenticityScore]
        );

        // Atualizar contador de uso do agente
        await db.run(
            `UPDATE script_agents SET usage_count = usage_count + 1, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
            [agentId]
        );

        // Garantir que scriptContent não esteja vazio
        if (!scriptContent || scriptContent.trim().length === 0) {
            console.error('[Roteiro] Erro: Roteiro gerado está vazio');
            return res.status(500).json({ 
                msg: 'Erro ao gerar roteiro: O conteúdo retornado está vazio. Tente novamente ou use outro modelo de IA.' 
            });
        }

        // Progresso: 100% - Concluído
        if (sessionId) {
            sendProgress(sessionId, {
                stage: 'complete',
                progress: 100,
                message: 'Roteiro gerado com sucesso!',
                viralScore: analysis.overallScore,
                totalParts: numberOfParts,
                details: {
                    score: analysis.overallScore,
                    scriptId: scriptResult.lastID
                }
            });
        }

        res.status(200).json({
            msg: 'Roteiro gerado com sucesso!',
            script: scriptContent,
            scriptId: scriptResult.lastID,
            title: title,
            model: selectedModel,
            duration: scriptDuration,
            language: scriptLanguage,
            wordCount: scriptContent.trim().split(/\s+/).filter(w => w.length > 0).length,
            optimization: {
                overallScore: analysis.overallScore,
                retentionScore: analysis.retentionScore,
                authenticityScore: analysis.authenticityScore,
                nicheAlignment: analysis.nicheAlignment,
                problems: analysis.problems,
                suggestions: analysis.suggestions,
                aiIndicators: analysis.aiIndicators,
                cliches: analysis.cliches,
                nameInconsistencies: analysis.nameInconsistencies || [],
                wasOptimized: needsOptimization,
                optimizationReason: needsOptimization ? optimizationReason : null
            }
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId/generate]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar roteiro.' });
    }
});

// === ROTA LAOZHANG PARA GERAÇÃO DE ROTEIROS ===
app.post('/api/script-agents/:agentId/generate/laozhang', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { title, topic, duration, language, cta, selectedModel, additionalInstructions, sessionId, parts } = req.body;
    const userId = req.user.id;

    console.log(`[Script Laozhang] Requisição recebida - agentId: ${agentId}, userId: ${userId}, title: ${title}`);

    if (!title) {
        return res.status(400).json({ msg: 'Título do vídeo é obrigatório.' });
    }

    if (!agentId) {
        console.error(`[Script Laozhang] agentId não fornecido na URL`);
        return res.status(400).json({ msg: 'ID do agente é obrigatório.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Buscar o agente
        console.log(`[Script Laozhang] Buscando agente com id=${agentId} e user_id=${userId}`);
        
        // Primeiro, verificar se o agente existe (sem filtro de user_id)
        const agentExists = await db.get(
            `SELECT id, user_id, agent_name FROM script_agents WHERE id = ?`,
            [agentId]
        );
        
        if (!agentExists) {
            console.error(`[Script Laozhang] Agente ${agentId} não existe no banco de dados`);
            // Listar todos os agentes do usuário para debug
            const userAgents = await db.all(
                `SELECT id, agent_name FROM script_agents WHERE user_id = ?`,
                [userId]
            );
            console.log(`[Script Laozhang] Agentes disponíveis para user_id=${userId}:`, userAgents);
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }
        
        if (agentExists.user_id !== userId) {
            console.error(`[Script Laozhang] Agente ${agentId} existe mas pertence ao user_id=${agentExists.user_id}, não ao user_id=${userId}`);
            return res.status(403).json({ msg: 'Você não tem permissão para usar este agente.' });
        }
        
        // Buscar o agente completo
        const agent = await db.get(
            `SELECT * FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );
        
        if (!agent) {
            console.error(`[Script Laozhang] Erro inesperado: agente existe mas não foi encontrado com filtro user_id`);
            return res.status(500).json({ msg: 'Erro ao buscar agente.' });
        }

        console.log(`[Script Laozhang] Agente encontrado: ${agent.agent_name || 'Sem nome'}`);

        let scriptDuration = duration ? parseInt(duration) : 5;
        const scriptLanguage = language || 'pt';
        
        // Configurar CTAs (Call to Action)
        const ctaConfig = {
            inicio: cta?.inicio || false,
            meio: cta?.meio || false,
            final: cta?.final !== undefined ? cta.final : true // Padrão: CTA no final
        };
        
        console.log(`[Script Laozhang] CTAs configurados: início=${ctaConfig.inicio}, meio=${ctaConfig.meio}, final=${ctaConfig.final}`);
        
        // Mapear o modelo selecionado (aceitar tanto os valores do frontend quanto os nomes completos)
        let laozhangModel = null;
        if (selectedModel) {
            const modelLower = selectedModel.toLowerCase();
            if (modelLower.includes('claude') || modelLower.includes('sonnet') || selectedModel === 'claude-3-7-sonnet-20250219' || selectedModel === 'Claude 3.7 Sonnet (Fev/25)') {
                laozhangModel = 'claude-3-7-sonnet-20250219';
            } else if (modelLower.includes('gemini') || modelLower.includes('pro') || selectedModel === 'gemini-2.5-pro' || selectedModel === 'Gemini 2.5 Pro (2025)') {
                laozhangModel = 'gemini-2.5-pro';
            } else if (modelLower.includes('gpt') || modelLower.includes('4o') || selectedModel === 'gpt-4o' || selectedModel === 'GPT-4o (2025)') {
                laozhangModel = 'gpt-4o';
            } else {
                // Tentar usar o modelo diretamente
                laozhangModel = selectedModel;
            }
        }
        
        // Se ainda não tem modelo, usar 'gpt-4o' apenas como último recurso
        if (!laozhangModel) {
            console.warn(`[Script Laozhang] ⚠️ Modelo não fornecido, usando 'gpt-4o' como fallback`);
            laozhangModel = 'gpt-4o';
        }
        
        console.log(`[Script Laozhang] Modelo selecionado: "${selectedModel || 'N/A'}" -> Mapeado para API: "${laozhangModel}"`);

        // A duração já vem ajustada do frontend (com 3-5 minutos extras)
        // Não adicionar mais minutos aqui para evitar duplicação
        // Mas aumentar wordsPerMinute para garantir margem de segurança
        const originalDuration = scriptDuration;
        console.log(`[Script Laozhang] Duração recebida do frontend: ${scriptDuration} minutos (já ajustada)`);
        
        // Definir palavras por minuto baseado no modelo
        // Aumentar para garantir que sempre seja suficiente (margem de segurança)
        // GPT: 200 palavras/minuto (aumentado para garantir duração mínima)
        // Claude: 180 palavras/minuto (aumentado para garantir duração mínima)
        // Gemini: 180 palavras/minuto (aumentado para garantir duração mínima)
        let wordsPerMinute = 180; // Base aumentada para todos os modelos
        if (laozhangModel === 'gpt-4o') {
            wordsPerMinute = 200; // Aumentado para 200 para garantir duração mínima
            console.log(`[Script Laozhang] GPT detectado: usando ${wordsPerMinute} palavras/minuto (aumentado para garantir duração mínima)`);
        } else if (laozhangModel === 'claude-3-7-sonnet-20250219') {
            wordsPerMinute = 180; // Aumentado para 180 para garantir duração mínima
            console.log(`[Script Laozhang] Claude detectado: usando ${wordsPerMinute} palavras/minuto (aumentado para garantir duração mínima)`);
        } else {
            wordsPerMinute = 180; // Gemini aumentado para 180
            console.log(`[Script Laozhang] Gemini detectado: usando ${wordsPerMinute} palavras/minuto (aumentado para garantir duração mínima)`);
        }

        // Criar prompt detalhado e específico
        // IMPORTANTE: Incluir palavras-chave para detectar como script request
        const targetWords = scriptDuration * wordsPerMinute;
        
        // Calcular número de partes ANTES de criar o prompt (para usar no prompt)
        // SEMPRE respeitar o número de partes solicitado pelo frontend
        let requestedParts = parseInt(parts, 10);
        if (Number.isNaN(requestedParts) || requestedParts <= 0) {
            requestedParts = null;
        }
        const idealParts = Math.max(1, Math.ceil(scriptDuration / 3));
        const numberOfParts = requestedParts || idealParts;
        if (requestedParts) {
            console.log(`[Script Laozhang] Usando número de partes solicitado pelo frontend: ${requestedParts} (ideal seria ${idealParts})`);
        } else {
            console.log(`[Script Laozhang] Nenhuma parte especificada, usando cálculo ideal: ${idealParts}`);
        }
        
        const prompt = `${agent.agent_prompt || 'Você é um ESPECIALISTA EM ROTEIROS VIRAIS para YouTube. Crie roteiros envolventes, cativantes e otimizados para viralização.'}

═══════════════════════════════════════════════════════════════════
INSTRUÇÕES DETALHADAS DO AGENTE (FÓRMULA VIRAL):
═══════════════════════════════════════════════════════════════════
${agent.agent_instructions || 'Siga a estrutura e fórmula viral identificada no roteiro original analisado.'}

${additionalInstructions ? `\n═══════════════════════════════════════════════════════════════════
INSTRUÇÕES ADICIONAIS DO USUÁRIO:
═══════════════════════════════════════════════════════════════════
${additionalInstructions}\n` : ''}

═══════════════════════════════════════════════════════════════════
PARÂMETROS DO ROTEIRO:
═══════════════════════════════════════════════════════════════════
TÍTULO: "${title}"
DURAÇÃO: ${scriptDuration} minutos (aproximadamente ${targetWords} palavras - ${wordsPerMinute} palavras/minuto)
IDIOMA: ${scriptLanguage === 'pt' ? 'Português (Brasil)' : scriptLanguage === 'en' ? 'Inglês' : 'Espanhol'}
${topic ? `TÓPICO ADICIONAL: ${topic}\n` : ''}
NICHE: ${agent.niche || 'N/A'}
SUBNICHE: ${agent.subniche || 'N/A'}

${(ctaConfig.inicio || ctaConfig.meio || ctaConfig.final) ? `═══════════════════════════════════════════════════════════════════
⚠️⚠️⚠️ CALL TO ACTION (CTA) - OBRIGATÓRIO E NATURAL ⚠️⚠️⚠️
═══════════════════════════════════════════════════════════════════
${ctaConfig.inicio ? `✅ CTA no INÍCIO (primeiros 30 segundos): 
   - Você DEVE incluir uma chamada para ação NATURAL e ORGÂNICA nos primeiros 30 segundos do roteiro
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar forçado
   - Exemplos naturais: "Se você está gostando deste conteúdo, já deixa seu like e se inscreva no canal para não perder os próximos vídeos", "Antes de continuar, se inscreva no canal e ative o sininho para receber notificações", "Se este conteúdo está te ajudando, já deixa seu like e comenta o que achou"
   - O CTA deve fazer parte do fluxo narrativo natural, não deve parecer uma interrupção
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, não uma marcação separada\n` : ''}
${ctaConfig.meio ? `✅ CTA no MEIO (aproximadamente na metade do vídeo):
   - Você DEVE incluir uma chamada para ação NATURAL e ORGÂNICA no meio do roteiro
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar forçado
   - Exemplos naturais: "Se você está aprendendo algo novo aqui, já deixa seu like e compartilha com quem precisa ver isso", "Antes de continuarmos, se inscreva no canal para não perder o restante deste conteúdo", "Se este vídeo está te ajudando, já deixa seu like e comenta suas dúvidas"
   - O CTA deve fazer parte do fluxo narrativo natural, não deve parecer uma interrupção
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, não uma marcação separada\n` : ''}
${ctaConfig.final ? `✅ CTA no FINAL (últimos 30 segundos):
   - Você DEVE incluir uma chamada para ação FORTE, NATURAL e ORGÂNICA nos últimos 30 segundos do roteiro
   - Este é o CTA mais importante - deve ser impactante mas ainda assim natural
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar forçado
   - Exemplos naturais: "Se este conteúdo te ajudou, já deixa seu like, se inscreva no canal, ative o sininho, compartilhe com seus amigos e comente o que achou", "Não esqueça de deixar seu like, se inscrever no canal e compartilhar este vídeo com quem precisa ver isso", "Se você gostou deste conteúdo, já deixa seu like, se inscreva no canal, ative o sininho para receber notificações e compartilhe com seus amigos"
   - O CTA deve fazer parte do fluxo narrativo natural, não deve parecer uma interrupção
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, não uma marcação separada
   - CRÍTICO: Este CTA final é essencial para o engajamento do vídeo\n` : ''}
⚠️ REGRAS IMPORTANTES SOBRE CTAs:
- Os CTAs devem ser incluídos de forma NATURAL e ORGÂNICA no texto narrativo
- NÃO use marcações como "[CTA]", "(CTA)", ou qualquer indicação explícita de CTA
- NÃO interrompa o fluxo narrativo abruptamente para incluir o CTA
- O CTA deve fazer parte da narrativa, como se fosse uma conversa natural com o espectador
- Use linguagem conversacional e envolvente
- Seja persuasivo mas genuíno, não forçado
- O CTA deve parecer que faz parte naturalmente do roteiro, não algo adicionado depois
- CRÍTICO: Se os CTAs não forem incluídos de forma natural, o roteiro será considerado incompleto

` : ''}
═══════════════════════════════════════════════════════════════════
RESPOSTA FINAL - CRÍTICO: ROTEIRO EM TEXTO SIMPLES
═══════════════════════════════════════════════════════════════════
⚠️⚠️⚠️ FORMATO DE RESPOSTA OBRIGATÓRIO ⚠️⚠️⚠️

Você DEVE retornar APENAS o texto do roteiro em TEXTO SIMPLES. NÃO use JSON. NÃO use markdown. NÃO use objetos ou estruturas de dados.

NÃO retorne:
❌ JSON (não use { }, não use "roteiro": "...", não use "script": "...")
❌ Markdown (não use code blocks, não use #, não use **)
❌ Objetos ou estruturas de dados
❌ Metadados ou informações adicionais

RETORNE APENAS:
✅ O texto puro do roteiro
✅ Texto corrido e natural
✅ Direto ao ponto, sem formatações especiais
✅ Apenas o conteúdo do roteiro em si

⚠️⚠️⚠️ DURAÇÃO OBRIGATÓRIA - CRÍTICO ⚠️⚠️⚠️
O roteiro DEVE ter EXATAMENTE ${scriptDuration} minutos de duração quando narrado.
Isso significa NO MÍNIMO ${targetWords} palavras (${scriptDuration} minutos × ${wordsPerMinute} palavras por minuto).
⚠️ CRÍTICO: O roteiro NUNCA pode ter MENOS de ${targetWords} palavras. Se tiver menos, será REJEITADO.
⚠️ CRÍTICO: O roteiro deve ter PELO MENOS ${targetWords} palavras para garantir ${scriptDuration} minutos de narração.
⚠️ CRÍTICO: Se o roteiro tiver menos de ${targetWords} palavras, você DEVE expandir o conteúdo até atingir PELO MENOS ${targetWords} palavras.
⚠️ CRÍTICO: É melhor ter mais palavras do que menos. Se necessário, adicione mais detalhes, exemplos, explicações ou contexto para atingir ${targetWords} palavras.
⚠️ CRÍTICO: Conte as palavras antes de finalizar. O roteiro DEVE ter PELO MENOS ${targetWords} palavras.

EXEMPLO DE FORMATO CORRETO:
Olviden todo lo que saben sobre las guerras antiguas. Olviden los ejércitos, las lanzas y los escudos. Existió una batalla mucho más sofisticada. Una guerra silenciosa librada no en los campos de batalla, sino en los observatorios, en los calendarios, y en la mente de los ingenieros más brillantes de la historia de América.

EXEMPLO DE FORMATO INCORRETO (NÃO FAÇA ISSO):
{
  "roteiro": "Olviden todo lo que saben..."
}

ou

code block json com:
{
  "roteiro": "..."
}

═══════════════════════════════════════════════════════════════════
INSTRUÇÕES FINAIS:
═══════════════════════════════════════════════════════════════════
1. Crie um roteiro completo, envolvente e otimizado para viralização
2. Siga EXATAMENTE a fórmula viral identificada nas instruções do agente
3. Adapte o conteúdo para o título "${title}" mantendo a estrutura viral
4. ⚠️⚠️⚠️ CRÍTICO - DURAÇÃO OBRIGATÓRIA ⚠️⚠️⚠️:
   - O roteiro DEVE ter PELO MENOS ${targetWords} palavras (${scriptDuration} minutos de duração) distribuídas em ${numberOfParts} partes
   - ⚠️ CRÍTICO: O roteiro NUNCA pode ter MENOS de ${targetWords} palavras. Se tiver menos, será REJEITADO.
   - ⚠️ CRÍTICO: É melhor ter mais palavras do que menos. Se necessário, expanda o conteúdo até atingir PELO MENOS ${targetWords} palavras.
   - ⚠️ CRÍTICO: Conte as palavras antes de finalizar. O roteiro DEVE ter PELO MENOS ${targetWords} palavras.
   - ⚠️ CRÍTICO: Você DEVE gerar conteúdo para TODAS as ${numberOfParts} partes. NÃO pare antes de completar todas as partes.
   - ⚠️ CRÍTICO: Se você gerar apenas ${Math.ceil(numberOfParts * 0.35)} partes ou menos, o roteiro estará INCOMPLETO e será REJEITADO.
   - ⚠️ CRÍTICO: Você tem tempo suficiente - NÃO tenha pressa, complete TODAS as partes e garanta PELO MENOS ${targetWords} palavras.
5. Use o idioma ${scriptLanguage === 'pt' ? 'Português (Brasil)' : scriptLanguage === 'en' ? 'Inglês' : 'Espanhol'}
6. ⚠️⚠️⚠️ CRÍTICO - ESTRUTURA DE PARÁGRAFOS E PALAVRAS - GERAR TODAS AS PARTES ⚠️⚠️⚠️:
   - O roteiro DEVE ser dividido em EXATAMENTE ${numberOfParts} PARTES (cada parte = aproximadamente 3 minutos)
   - ⚠️ CRÍTICO: Você DEVE gerar conteúdo para TODAS as ${numberOfParts} partes. NÃO pare antes de completar todas as partes.
   - Cada parte (EXCETO A ÚLTIMA) DEVE ter EXATAMENTE 5 PARÁGRAFOS
   - Cada parte (EXCETO A ÚLTIMA) DEVE ter ENTRE 390 e 450 PALAVRAS (total da parte)
   - Cada parágrafo (EXCETO NA ÚLTIMA PARTE) DEVE ter ENTRE 75 e 90 PALAVRAS
   - Distribuição ideal: 5 parágrafos × 78-90 palavras cada = 390-450 palavras totais por parte
   - Cada parágrafo deve ser separado por uma quebra de linha dupla (espaço em branco entre parágrafos)
   - A última parte pode ter um número variável de parágrafos e palavras conforme necessário para concluir o conteúdo
   - Estrutura obrigatória (você DEVE gerar TODAS estas partes): 
     ${Array.from({ length: numberOfParts }, (_, i) => {
         const partNum = i + 1;
         if (partNum === numberOfParts) {
             return `     * Parte ${partNum} (ÚLTIMA): número variável de parágrafos e palavras (conforme necessário para concluir)`;
         } else {
             return `     * Parte ${partNum}: 5 parágrafos (390-450 palavras totais, 75-90 palavras por parágrafo)`;
         }
     }).join('\n')}
   - ⚠️ CRÍTICO: Você DEVE gerar conteúdo para TODAS as ${numberOfParts} partes listadas acima. NÃO pare na parte ${numberOfParts === 1 ? '1' : numberOfParts > 2 ? '2 ou 3' : '2'}. Continue até completar a parte ${numberOfParts}.
   - Os parágrafos devem estar bem distribuídos ao longo de cada parte
   - IMPORTANTE: Separe claramente cada parágrafo com uma linha em branco
   - CRÍTICO: Conte as palavras de cada parágrafo e da parte completa antes de finalizar
   - CRÍTICO: O roteiro completo DEVE ter ${targetWords} palavras distribuídas entre as ${numberOfParts} partes
7. Escreva APENAS o texto do roteiro, SEM JSON, SEM markdown, SEM formatações especiais
8. ⚠️ CRÍTICO - NÃO INCLUA MARCAÇÕES DE PARTE OU TEMPO:
   - NÃO inclua marcações como "PARTE 1", "Parte 1", "PARTE 1 0:00 - 3:00", "Parte 1 0:00 - 3:00"
   - NÃO inclua marcações de tempo como "[0:00-3:00]", "(0:00)", "0:00 - 3:00", "0:00-3:00"
   - NÃO inclua qualquer indicação de número de parte ou intervalo de tempo no texto
   - O roteiro deve ser APENAS texto narrativo puro, sem marcações técnicas
   - Escreva como se estivesse narrando diretamente, sem prefixos, sem marcações de parte ou tempo
   - CRÍTICO: Se você incluir marcações de parte ou tempo, o roteiro será rejeitado

⚠️⚠️⚠️ LEMBRE-SE: Você DEVE gerar conteúdo para TODAS as ${numberOfParts} partes. O roteiro completo deve ter ${targetWords} palavras. NÃO pare antes de completar todas as ${numberOfParts} partes. Se você parar antes da parte ${numberOfParts}, o roteiro estará incompleto e será rejeitado.

AGORA, CRIE O ROTEIRO COMPLETO COM TODAS AS ${numberOfParts} PARTES (SEM MARCAÇÕES DE PARTE OU TEMPO):`;

        console.log(`[Script Laozhang] Gerando roteiro com modelo: ${laozhangModel}, duração: ${scriptDuration} minutos (${targetWords} palavras), partes: ${numberOfParts}`);
        
        // Enviar progresso inicial
        if (sessionId) {
            sendProgress(sessionId, {
                stage: 'initializing',
                progress: 5,
                message: 'Inicializando geração...',
                totalParts: numberOfParts,
                currentPart: 0,
                details: { totalParts: numberOfParts }
            });
            
            sendProgress(sessionId, {
                stage: 'preparing',
                progress: 10,
                message: `Preparando IA do agente (meta: ${targetWords.toLocaleString()} palavras)...`,
                totalParts: numberOfParts,
                currentPart: 0,
                details: { model: laozhangModel, targetWords, totalParts: numberOfParts }
            });
        }
        
        const startTime = Date.now();
        
        // Simular progresso por partes durante a geração
        let currentPartSimulated = 0;
        const progressInterval = setInterval(() => {
            if (sessionId && currentPartSimulated < numberOfParts) {
                currentPartSimulated++;
                const progress = Math.min(80, 10 + (currentPartSimulated / numberOfParts) * 70);
                sendProgress(sessionId, {
                    stage: 'generating',
                    progress: progress,
                    currentPart: currentPartSimulated,
                    totalParts: numberOfParts,
                    message: `Gerando parte ${currentPartSimulated}/${numberOfParts}...`,
                    details: {
                        partNumber: currentPartSimulated,
                        status: 'generating',
                        percentage: Math.round((currentPartSimulated / numberOfParts) * 100),
                        completedParts: currentPartSimulated - 1
                    }
                });
            }
        }, 2000); // Atualizar a cada 2 segundos
        
        const response = await callLaozhangAPI(
            prompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_script_agents_generate',
            JSON.stringify({ endpoint: '/api/script-agents/:agentId/generate/laozhang', model: laozhangModel })
        );
        
        clearInterval(progressInterval);
        
        console.log(`[Script Laozhang] Resposta recebida do modelo ${laozhangModel}`);
        
        // Marcar todas as partes como concluídas sequencialmente
        if (sessionId) {
            for (let partNum = 1; partNum <= numberOfParts; partNum++) {
                sendProgress(sessionId, {
                    stage: 'generating',
                    progress: Math.min(95, 10 + (partNum / numberOfParts) * 85),
                    currentPart: partNum,
                    totalParts: numberOfParts,
                    message: `Parte ${partNum}/${numberOfParts} concluída!`,
                    details: {
                        partNumber: partNum,
                        status: 'completed',
                        percentage: 100,
                        completedParts: partNum
                    }
                });
                // Pequeno delay entre cada atualização para visualização
                await new Promise(resolve => setTimeout(resolve, 400));
            }
            
            sendProgress(sessionId, {
                stage: 'completed',
                progress: 100,
                currentPart: numberOfParts,
                totalParts: numberOfParts,
                message: 'Roteiro gerado com sucesso!',
                details: { completed: true, completedParts: numberOfParts }
            });
        }

        let scriptContent = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        console.log(`[Script Laozhang] Resposta recebida (primeiros 500 chars):`, scriptContent.substring(0, 500));
        
        // Limpar o roteiro (remover JSON, markdown, etc) - processo mais robusto
        let cleanedScript = scriptContent;
        
        // 1. Remover markdown code blocks
        cleanedScript = cleanedScript.replace(/```[\s\S]*?```/g, '');
        cleanedScript = cleanedScript.replace(/```json[\s\S]*?```/gi, '');
        cleanedScript = cleanedScript.replace(/```text[\s\S]*?```/gi, '');
        
        // 2. Tentar extrair texto de estruturas JSON comuns
        const jsonPatterns = [
            /"roteiro"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /"script"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /"content"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /"texto"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /"text"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /roteiro["']?\s*:\s*["']([^"']+)["']/gi,
            /script["']?\s*:\s*["']([^"']+)["']/gi
        ];
        
        for (const pattern of jsonPatterns) {
            const match = cleanedScript.match(pattern);
            if (match && match[1]) {
                cleanedScript = match[1]
                    .replace(/\\n/g, '\n')
                    .replace(/\\r/g, '\r')
                    .replace(/\\t/g, '\t')
                    .replace(/\\"/g, '"')
                    .replace(/\\'/g, "'")
                    .replace(/\\\\/g, '\\');
                console.log(`[Script Laozhang] Extraído texto de JSON usando padrão: ${pattern}`);
                break;
            }
        }
        
        // 3. Remover estruturas JSON restantes
        cleanedScript = cleanedScript
            .replace(/^[^{]*\{[\s\S]*?"roteiro"\s*:\s*/, '')  // Remove início de JSON até "roteiro":
            .replace(/^[^{]*\{[\s\S]*?"script"\s*:\s*/, '')  // Remove início de JSON até "script":
            .replace(/^[^{]*\{[\s\S]*?"content"\s*:\s*/, '')  // Remove início de JSON até "content":
            .replace(/["']roteiro["']\s*:\s*["']?/gi, '')     // Remove "roteiro": "
            .replace(/["']script["']\s*:\s*["']?/gi, '')      // Remove "script": "
            .replace(/["']content["']\s*:\s*["']?/gi, '')     // Remove "content": "
            .replace(/["']texto["']\s*:\s*["']?/gi, '')       // Remove "texto": "
            .replace(/["']text["']\s*:\s*["']?/gi, '')        // Remove "text": "
            .replace(/^[^{]*\{/, '')                          // Remove { no início
            .replace(/\}[^}]*$/, '')                          // Remove } no final
            .replace(/^[\s\n\r]*["']/, '')                    // Remove " no início
            .replace(/["'][\s\n\r]*$/, '')                    // Remove " no final
            .trim();
        
        // 4. Se ainda parece JSON, tentar parsear e extrair
        if (cleanedScript.trim().startsWith('{') || cleanedScript.trim().startsWith('[')) {
            try {
                const parsed = JSON.parse(cleanedScript);
                if (parsed.roteiro) {
                    cleanedScript = typeof parsed.roteiro === 'string' ? parsed.roteiro : JSON.stringify(parsed.roteiro);
                } else if (parsed.script) {
                    cleanedScript = typeof parsed.script === 'string' ? parsed.script : JSON.stringify(parsed.script);
                } else if (parsed.content) {
                    cleanedScript = typeof parsed.content === 'string' ? parsed.content : JSON.stringify(parsed.content);
                } else if (typeof parsed === 'string') {
                    cleanedScript = parsed;
                }
                console.log(`[Script Laozhang] Parseado JSON e extraído conteúdo`);
            } catch (parseErr) {
                console.warn(`[Script Laozhang] Não foi possível parsear como JSON, usando texto limpo:`, parseErr.message);
            }
        }
        
        // 5. Limpeza final - remover TODAS as marcações para voice over
        cleanedScript = cleanedScript
            // Remover marcações de PARTE X com intervalos de tempo (mais agressivo - múltiplas tentativas)
            .replace(/PARTE\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gi, '') // Remove linha inteira com "PARTE 1 0:00 - 3:00"
            .replace(/Parte\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gi, '') // Remove linha inteira com "Parte 1 0:00 - 3:00"
            .replace(/PARTE\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}/gi, '') // Remove "PARTE 1 0:00 - 3:00" (sem quebra de linha)
            .replace(/Parte\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}/gi, '') // Remove "Parte 1 0:00 - 3:00" (sem quebra de linha)
            .replace(/PARTE\s+\d+.*?(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})/gi, '') // Remove "PARTE 1 0:00 - 3:00" (qualquer variação)
            .replace(/Parte\s+\d+.*?(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})/gi, '') // Remove "Parte 1 0:00 - 3:00" (qualquer variação)
            .replace(/^\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gmi, '') // Remove linha que começa com "0:00 - 3:00"
            .replace(/^\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}\s*/gmi, '') // Remove "0:00 - 3:00" no início da linha (sem quebra)
            .replace(/PARTE\s+\d+\s*$/gmi, '') // Remove "PARTE 1" sozinho no final da linha
            .replace(/Parte\s+\d+\s*$/gmi, '') // Remove "Parte 1" sozinho no final da linha
            // Remover marcações de cenas
            .replace(/^Cena\s+\d+:\s*/gmi, '') // Remove "Cena 1:", "Cena 2:", etc.
            .replace(/^CENA\s+\d+:\s*/gmi, '') // Remove "CENA 1:", "CENA 2:", etc.
            .replace(/^Scene\s+\d+:\s*/gmi, '') // Remove "Scene 1:", "Scene 2:", etc.
            .replace(/^SCENE\s+\d+:\s*/gmi, '') // Remove "SCENE 1:", "SCENE 2:", etc.
            .replace(/^Parte\s+\d+:\s*/gmi, '') // Remove "Parte 1:", "Parte 2:", etc.
            .replace(/^PARTE\s+\d+:\s*/gmi, '') // Remove "PARTE 1:", "PARTE 2:", etc.
            // Remover marcações de tempo
            .replace(/\[?\d{1,2}:\d{2}-\d{1,2}:\d{2}\]?\s*/g, '') // Remove [0:00-0:30]
            .replace(/\(\d{1,2}:\d{2}\)\s*/g, '') // Remove (0:30)
            .replace(/^\d{1,2}:\d{2}\s*/gm, '') // Remove 0:30 no início da linha
            // Remover títulos de seções em maiúsculas
            .replace(/^[A-Z][A-Z\s]+:\s*/gm, '') // Remove títulos em maiúsculas seguidos de dois pontos
            // Limpar aspas
            .replace(/^\s*["']+/, '')  // Remove aspas no início
            .replace(/["']+\s*$/, '')  // Remove aspas no final
            // Limpar espaços e quebras excessivas
            .replace(/\n{3,}/g, '\n\n') // Remove múltiplas quebras de linha
            .replace(/^\s+/gm, '') // Remove espaços no início de cada linha
            .replace(/\s+$/gm, '') // Remove espaços no final de cada linha
            .trim();
        
        // 6. Se o script estiver vazio ou muito curto, usar a resposta original
        if (!cleanedScript || cleanedScript.length < 100) {
            console.warn(`[Script Laozhang] Script limpo muito curto (${cleanedScript?.length || 0} chars), usando resposta original`);
            cleanedScript = scriptContent.trim();
        }
        
        console.log(`[Script Laozhang] Script final (primeiros 300 chars):`, cleanedScript.substring(0, 300));
        
        // Validar e expandir roteiro se necessário
        let wordCount = cleanedScript.split(/\s+/).filter(word => word.length > 0).length;
        const expectedWordCount = targetWords;
        const wordCountDifference = Math.abs(wordCount - expectedWordCount);
        const wordCountPercentage = ((wordCount / expectedWordCount) * 100).toFixed(1);
        
        console.log(`[Script Laozhang] Validação de duração:`);
        console.log(`  - Palavras esperadas: ${expectedWordCount} (${scriptDuration} minutos)`);
        console.log(`  - Palavras geradas: ${wordCount}`);
        console.log(`  - Diferença: ${wordCountDifference} palavras (${wordCountPercentage}% do esperado)`);
        
        // Se o roteiro estiver muito curto (menos de 95% do esperado), expandir
        const minWordCount = Math.floor(expectedWordCount * 0.95); // 95% do esperado como mínimo absoluto
        if (wordCount < minWordCount) {
            const wordsNeeded = minWordCount - wordCount;
            console.warn(`[Script Laozhang] ⚠️⚠️⚠️ CRÍTICO: Roteiro MUITO CURTO! Esperado MÍNIMO: ${minWordCount} palavras, Gerado: ${wordCount} palavras (${wordCountPercentage}%). Faltam ${wordsNeeded} palavras.`);
            console.log(`[Script Laozhang] 🔄 Expandindo roteiro para atingir a duração mínima...`);
            const expansionPrompt = `O roteiro abaixo está muito curto. Ele tem ${wordCount} palavras, mas precisa ter PELO MENOS ${minWordCount} palavras para garantir ${scriptDuration} minutos de duração.

ROTEIRO ATUAL:
${cleanedScript.substring(0, 2000)}

INSTRUÇÕES:
1. EXPANDA o roteiro acima adicionando pelo menos ${wordsNeeded} palavras
2. Mantenha o mesmo estilo, tom e estrutura
3. Adicione mais detalhes, exemplos, explicações ou desenvolvimentos
4. NÃO altere o início ou o final, apenas EXPANDA o conteúdo do meio
5. ⚠️ CRÍTICO: O roteiro expandido DEVE ter PELO MENOS ${minWordCount} palavras (é melhor ter mais do que menos)
6. ⚠️ CRÍTICO: Conte as palavras antes de finalizar. O roteiro DEVE ter PELO MENOS ${minWordCount} palavras
7. Retorne APENAS o roteiro expandido em texto simples, SEM JSON, SEM markdown, SEM marcações de parte ou tempo

ROTEIRO EXPANDIDO:`;

            try {
                const expansionResponse = await callLaozhangAPI(
                    expansionPrompt,
                    laozhangApiKey,
                    laozhangModel,
                    null,
                    userId,
                    'api_script_agents_generate',
                    JSON.stringify({ endpoint: '/api/script-agents/:agentId/generate/laozhang', model: laozhangModel, action: 'expand' })
                );
                
                let expandedScript = typeof expansionResponse === 'string' ? expansionResponse.trim() : JSON.stringify(expansionResponse);
                
                // Limpar o roteiro expandido da mesma forma
                expandedScript = expandedScript
                    .replace(/```[\s\S]*?```/g, '')
                    .replace(/```json[\s\S]*?```/gi, '')
                    .replace(/\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                    .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/\{[\s\S]*\}/g, '')
                    .trim();
                
                const expandedWordCount = expandedScript.split(/\s+/).filter(word => word.length > 0).length;
                
                if (expandedWordCount >= expectedWordCount * 0.8) {
                    cleanedScript = expandedScript;
                    wordCount = expandedWordCount;
                    console.log(`[Script Laozhang] ✅ Roteiro expandido com sucesso! Nova contagem: ${wordCount} palavras (${((wordCount / expectedWordCount) * 100).toFixed(1)}%)`);
                } else {
                    console.warn(`[Script Laozhang] ⚠️ Expansão não foi suficiente. Mantendo roteiro original.`);
                }
            } catch (expandErr) {
                console.error(`[Script Laozhang] Erro ao expandir roteiro:`, expandErr);
                console.warn(`[Script Laozhang] Mantendo roteiro original apesar de estar curto.`);
            }
        } else if (wordCount > expectedWordCount * 1.3) {
            console.warn(`[Script Laozhang] ⚠️ ATENÇÃO: Roteiro muito longo! Esperado: ${expectedWordCount} palavras, Gerado: ${wordCount} palavras (${wordCountPercentage}%)`);
        } else {
            console.log(`[Script Laozhang] ✅ Duração do roteiro está dentro do esperado (${wordCountPercentage}%)`);
        }

        // Salvar roteiro no banco
        // Verificar se as colunas duration_minutes e language existem
        let columnsToInsert = ['user_id', 'script_agent_id', 'title', 'script_content', 'model_used', 'niche', 'subniche'];
        // Limpar nome do modelo para salvar (sem prefixo de fornecedor)
        const cleanModelForSave = (model) => {
            if (!model) return 'GPT-4o';
            // Remover prefixos e mapear para nomes amigáveis
            let clean = model.replace(/^(laozhang-|claude-|gemini-|gpt-)/i, '');
            if (clean.includes('gpt-4o')) return 'GPT-4o';
            if (clean.includes('claude-3-7-sonnet') || clean.includes('sonnet-3-7')) return 'Claude 3.7 Sonnet';
            if (clean.includes('claude-sonnet-4') || clean.includes('sonnet-4')) return 'Claude Sonnet 4';
            if (clean.includes('gemini-2.5-pro')) return 'Gemini 2.5 Pro';
            return clean || 'GPT-4o';
        };
        let valuesToInsert = [userId, agentId, title, cleanedScript, cleanModelForSave(laozhangModel), agent.niche, agent.subniche];
        
        try {
            // Tentar verificar se as colunas existem
            const tableInfo = await db.all(`PRAGMA table_info(generated_scripts)`);
            const columnNames = tableInfo.map(col => col.name);
            
            if (columnNames.includes('duration_minutes')) {
                columnsToInsert.push('duration_minutes');
                valuesToInsert.push(scriptDuration);
            }
            if (columnNames.includes('language')) {
                columnsToInsert.push('language');
                valuesToInsert.push(scriptLanguage);
            }
        } catch (pragmaErr) {
            console.warn('[Script Laozhang] Erro ao verificar colunas, usando apenas colunas básicas:', pragmaErr.message);
        }
        
        const result = await db.run(
            `INSERT INTO generated_scripts (${columnsToInsert.join(', ')})
             VALUES (${columnsToInsert.map(() => '?').join(', ')})`,
            valuesToInsert
        );

        // Enviar progresso final
        if (sessionId) {
            sendProgress(sessionId, {
                stage: 'completed',
                progress: 100,
                message: 'Roteiro gerado com sucesso!',
                details: { completed: true, scriptId: result.lastID }
            });
        }

        res.status(200).json({
            msg: 'Roteiro gerado com sucesso!',
            scriptId: result.lastID,
            script: cleanedScript
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId/generate/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar roteiro.' });
    }
});

// Rota para atualizar um agente
app.put('/api/script-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { agentName, niche, subniche, agentPrompt, agentInstructions } = req.body;
    const userId = req.user.id;

    try {
        const agent = await db.get(
            `SELECT id FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        const updates = [];
        const values = [];

        if (agentName !== undefined) {
            updates.push('agent_name = ?');
            values.push(agentName);
        }
        if (niche !== undefined) {
            updates.push('niche = ?');
            values.push(niche);
        }
        if (subniche !== undefined) {
            updates.push('subniche = ?');
            values.push(subniche);
        }
        if (agentPrompt !== undefined) {
            updates.push('agent_prompt = ?');
            values.push(agentPrompt);
        }
        if (agentInstructions !== undefined) {
            updates.push('agent_instructions = ?');
            values.push(agentInstructions);
        }

        if (updates.length === 0) {
            return res.status(400).json({ msg: 'Nenhum campo para atualizar.' });
        }

        updates.push('updated_at = CURRENT_TIMESTAMP');
        values.push(agentId);

        await db.run(
            `UPDATE script_agents SET ${updates.join(', ')} WHERE id = ?`,
            values
        );

        res.status(200).json({ msg: 'Agente atualizado com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId PUT]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar agente.' });
    }
});
// Rota para deletar um agente
app.delete('/api/script-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        const result = await db.run(
            `DELETE FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        res.status(200).json({ msg: 'Agente deletado com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao deletar agente.' });
    }
});

// Rota para listar roteiros gerados
app.get('/api/scripts', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { agentId } = req.query;

    try {
        let scripts;
        if (agentId) {
            scripts = await db.all(
                `SELECT gs.*, sa.agent_name
                 FROM generated_scripts gs
                 LEFT JOIN script_agents sa ON gs.script_agent_id = sa.id
                 WHERE gs.user_id = ? AND gs.script_agent_id = ?
                 ORDER BY gs.created_at DESC`,
                [userId, agentId]
            );
        } else {
            scripts = await db.all(
                `SELECT gs.*, sa.agent_name
                 FROM generated_scripts gs
                 LEFT JOIN script_agents sa ON gs.script_agent_id = sa.id
                 WHERE gs.user_id = ?
                 ORDER BY gs.created_at DESC`,
                [userId]
            );
        }

        res.status(200).json({ scripts });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts]:', err);
        res.status(500).json({ msg: 'Erro ao listar roteiros.' });
    }
});

// Rota para obter um roteiro específico
app.get('/api/scripts/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scriptId = req.params.id;

    try {
        const script = await db.get(
            `SELECT gs.*, sa.agent_name
             FROM generated_scripts gs
             LEFT JOIN script_agents sa ON gs.script_agent_id = sa.id
             WHERE gs.id = ? AND gs.user_id = ?`,
            [scriptId, userId]
        );

        if (!script) {
            return res.status(404).json({ msg: 'Roteiro não encontrado.' });
        }

        res.json({ script });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts/:id]:', err);
        res.status(500).json({ msg: 'Erro ao obter roteiro.' });
    }
});

// Rota para deletar um roteiro
app.delete('/api/scripts/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scriptId = req.params.id;

    try {
        const result = await db.run(
            `DELETE FROM generated_scripts WHERE id = ? AND user_id = ?`,
            [scriptId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Roteiro não encontrado.' });
        }

        res.json({ msg: 'Roteiro excluído com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir roteiro.' });
    }
});

// ==================== ROTAS PARA AGENTES VIRAIS ====================

// Rota para criar um agente viral
app.post('/api/viral-agents', authenticateToken, async (req, res) => {
    const { name, description, memory, instructions, model } = req.body;
    const userId = req.user.id;

    if (!name || name.trim().length === 0) {
        return res.status(400).json({ msg: 'Nome do agente é obrigatório.' });
    }

    try {
        const result = await db.run(
            `INSERT INTO viral_agents (user_id, name, description, memory, instructions, model)
             VALUES (?, ?, ?, ?, ?, ?)`,
            [userId, name.trim(), description || null, memory || null, instructions || null, model || 'gpt-4o']
        );

        const newAgent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ?`,
            [result.lastID]
        );

        res.status(201).json({
            msg: 'Agente viral criado com sucesso!',
            agent: newAgent
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents POST]:', err);
        res.status(500).json({ msg: 'Erro ao criar agente viral.' });
    }
});

// Rota para listar todos os agentes virais do usuário
app.get('/api/viral-agents', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const agents = await db.all(
            `SELECT va.*, 
                    COUNT(DISTINCT vaf.id) as file_count,
                    COUNT(DISTINCT vac.id) as conversation_count
             FROM viral_agents va
             LEFT JOIN viral_agent_files vaf ON va.id = vaf.agent_id
             LEFT JOIN viral_agent_conversations vac ON va.id = vac.agent_id
             WHERE va.user_id = ?
             GROUP BY va.id
             ORDER BY va.is_favorite DESC, va.updated_at DESC`,
            [userId]
        );

        res.status(200).json({ agents });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents GET]:', err);
        res.status(500).json({ msg: 'Erro ao listar agentes virais.' });
    }
});

// Rota para obter um agente viral específico
app.get('/api/viral-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        const agent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        // Buscar arquivos do agente
        const files = await db.all(
            `SELECT * FROM viral_agent_files WHERE agent_id = ? ORDER BY created_at DESC`,
            [agentId]
        );

        // Buscar conversas do agente
        const conversations = await db.all(
            `SELECT * FROM viral_agent_conversations 
             WHERE agent_id = ? AND user_id = ? 
             ORDER BY updated_at DESC`,
            [agentId, userId]
        );

        res.status(200).json({
            agent: {
                ...agent,
                files,
                conversations
            }
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId GET]:', err);
        res.status(500).json({ msg: 'Erro ao obter agente viral.' });
    }
});

// Rota para atualizar um agente viral
app.put('/api/viral-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { name, description, memory, instructions, is_favorite, model, formula_json, niche, subniche, agent_prompt } = req.body;
    const userId = req.user.id;

    try {
        const agent = await db.get(
            `SELECT id FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        const updates = [];
        const values = [];

        if (name !== undefined) {
            updates.push('name = ?');
            values.push(name.trim());
        }
        if (description !== undefined) {
            updates.push('description = ?');
            values.push(description);
        }
        if (memory !== undefined) {
            updates.push('memory = ?');
            values.push(memory);
        }
        if (instructions !== undefined) {
            updates.push('instructions = ?');
            values.push(instructions);
        }
        if (model !== undefined) {
            updates.push('model = ?');
            values.push(model);
        }
        if (is_favorite !== undefined) {
            updates.push('is_favorite = ?');
            values.push(is_favorite ? 1 : 0);
        }
        if (formula_json !== undefined) {
            updates.push('formula_json = ?');
            values.push(typeof formula_json === 'object' ? JSON.stringify(formula_json) : formula_json);
        }
        if (niche !== undefined) {
            updates.push('niche = ?');
            values.push(niche);
        }
        if (subniche !== undefined) {
            updates.push('subniche = ?');
            values.push(subniche);
        }
        if (agent_prompt !== undefined) {
            updates.push('agent_prompt = ?');
            values.push(agent_prompt);
        }

        if (updates.length === 0) {
            return res.status(400).json({ msg: 'Nenhum campo para atualizar.' });
        }

        updates.push('updated_at = CURRENT_TIMESTAMP');
        values.push(agentId);

        await db.run(
            `UPDATE viral_agents SET ${updates.join(', ')} WHERE id = ?`,
            values
        );

        const updatedAgent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ?`,
            [agentId]
        );

        res.status(200).json({
            msg: 'Agente atualizado com sucesso!',
            agent: updatedAgent
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId PUT]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar agente viral.' });
    }
});

// Rota para deletar um agente viral
app.delete('/api/viral-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        const result = await db.run(
            `DELETE FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        res.status(200).json({ msg: 'Agente deletado com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao deletar agente viral.' });
    }
});

// Rota para adicionar arquivo a um agente viral
app.post('/api/viral-agents/:agentId/files', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { file_name, file_content, file_type, file_size } = req.body;
    const userId = req.user.id;

    if (!file_name || !file_content) {
        return res.status(400).json({ msg: 'Nome e conteúdo do arquivo são obrigatórios.' });
    }

    try {
        // Verificar se o agente pertence ao usuário
        const agent = await db.get(
            `SELECT id FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        const result = await db.run(
            `INSERT INTO viral_agent_files (agent_id, file_name, file_content, file_type, file_size)
             VALUES (?, ?, ?, ?, ?)`,
            [agentId, file_name, file_content, file_type || 'text/plain', file_size || file_content.length]
        );

        const newFile = await db.get(
            `SELECT * FROM viral_agent_files WHERE id = ?`,
            [result.lastID]
        );

        res.status(201).json({
            msg: 'Arquivo adicionado com sucesso!',
            file: newFile
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/files POST]:', err);
        res.status(500).json({ msg: 'Erro ao adicionar arquivo.' });
    }
});

// Rota para listar arquivos de um agente viral
app.get('/api/viral-agents/:agentId/files', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        // Verificar se o agente pertence ao usuário
        const agent = await db.get(
            `SELECT id FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        const files = await db.all(
            `SELECT * FROM viral_agent_files WHERE agent_id = ? ORDER BY created_at DESC`,
            [agentId]
        );

        res.status(200).json({ files });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/files GET]:', err);
        res.status(500).json({ msg: 'Erro ao listar arquivos.' });
    }
});

// Rota para deletar arquivo de um agente viral
app.delete('/api/viral-agents/:agentId/files/:fileId', authenticateToken, async (req, res) => {
    const { agentId, fileId } = req.params;
    const userId = req.user.id;

    try {
        // Verificar se o agente pertence ao usuário
        const agent = await db.get(
            `SELECT id FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        const result = await db.run(
            `DELETE FROM viral_agent_files WHERE id = ? AND agent_id = ?`,
            [fileId, agentId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Arquivo não encontrado.' });
        }

        res.status(200).json({ msg: 'Arquivo deletado com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/files/:fileId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao deletar arquivo.' });
    }
});

// Rota para criar uma nova conversa com um agente viral
app.post('/api/viral-agents/:agentId/conversations', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { title } = req.body;
    const userId = req.user.id;

    try {
        // Verificar se o agente pertence ao usuário
        const agent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        const result = await db.run(
            `INSERT INTO viral_agent_conversations (agent_id, user_id, title)
             VALUES (?, ?, ?)`,
            [agentId, userId, title || 'Nova Conversa']
        );

        const newConversation = await db.get(
            `SELECT * FROM viral_agent_conversations WHERE id = ?`,
            [result.lastID]
        );

        res.status(201).json({
            msg: 'Conversa criada com sucesso!',
            conversation: newConversation
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/conversations POST]:', err);
        res.status(500).json({ msg: 'Erro ao criar conversa.' });
    }
});

// Rota para enviar mensagem para um agente viral (chat) - COM STREAMING
// Função helper para remover avaliação do roteiro e extrair nota/checklist
function removeAvaliacaoFromRoteiro(roteiroTexto) {
    let nota = null;
    let checklist = null;
    let roteiroFinal = roteiroTexto ? roteiroTexto.trim() : '';
    
    if (!roteiroFinal) {
        return { roteiroFinal: '', nota: null, checklist: null };
    }
    
    // Remover a seção completa de avaliação (texto + JSON)
    const avaliacaoRegex = /#\s*📊\s*AVALIAÇÃO\s*DO\s*ROTEIRO[\s\S]*$/i;
    if (avaliacaoRegex.test(roteiroFinal)) {
        // Encontrar onde começa a avaliação
        const avaliacaoIndex = roteiroFinal.search(avaliacaoRegex);
        if (avaliacaoIndex !== -1) {
            // Extrair JSON da avaliação antes de remover
            const parteAvaliacao = roteiroFinal.substring(avaliacaoIndex);
            const jsonMatch = parteAvaliacao.match(/\{[\s\S]*"nota"[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    const avaliacao = JSON.parse(jsonMatch[0]);
                    nota = avaliacao.nota;
                    checklist = avaliacao.checklist || null;
                } catch (e) {
                    // Tentar extrair nota do texto
                    const notaMatch = parteAvaliacao.match(/nota[:\s]*(\d+)\/10/i);
                    if (notaMatch) {
                        nota = parseInt(notaMatch[1]);
                    }
                }
            } else {
                // Tentar extrair nota do texto se não houver JSON
                const notaMatch = parteAvaliacao.match(/nota[:\s]*(\d+)\/10/i);
                if (notaMatch) {
                    nota = parseInt(notaMatch[1]);
                }
            }
            // Remover toda a seção de avaliação
            roteiroFinal = roteiroFinal.substring(0, avaliacaoIndex).trim();
        }
    } else {
        // Se não encontrar a seção completa, tentar remover apenas o JSON
        const jsonMatch = roteiroFinal.match(/\{[\s\S]*"nota"[\s\S]*\}/);
        if (jsonMatch) {
            try {
                const avaliacao = JSON.parse(jsonMatch[0]);
                nota = avaliacao.nota;
                checklist = avaliacao.checklist || null;
                roteiroFinal = roteiroFinal.replace(/\{[\s\S]*"nota"[\s\S]*\}/, '').trim();
            } catch (e) {
                const notaMatch = roteiroFinal.match(/nota[:\s]*(\d+)\/10/i);
                if (notaMatch) {
                    nota = parseInt(notaMatch[1]);
                    roteiroFinal = roteiroFinal.replace(/nota[:\s]*\d+\/10[\s\S]*/i, '').trim();
                }
            }
        }
    }
    
    // Remover também qualquer texto relacionado à avaliação que possa ter ficado
    roteiroFinal = roteiroFinal.replace(/Análise da Avaliação:[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/Pontos Fortes:[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/Área de Melhoria:[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/GANCHO INICIAL[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/ESTRUTURA NARRATIVA[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/ENGAJAMENTO EMOCIONAL[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/DENSIDADE DE VALOR[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/TÉCNICAS DE RETENÇÃO[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/LINGUAGEM E TOM[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/ELEMENTOS ESTRUTURAIS[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/LOOPS ABERTOS[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/VARIAÇÃO EMOCIONAL[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/FINAL SATISFATÓRIO[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/```json[\s\S]*?```/gi, '').trim();
    
    return { roteiroFinal, nota, checklist };
}

app.post('/api/viral-agents/:agentId/chat', authenticateToken, async (req, res) => {
        const { agentId } = req.params;
        const { conversation_id, message, model: requestModel, stream = true } = req.body;
        const userId = req.user.id;

    if (!message || !conversation_id) {
        return res.status(400).json({ msg: 'Mensagem e ID da conversa são obrigatórios.' });
    }

    try {
        // Verificar se o agente pertence ao usuário
        const agent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }
        
        // Usar modelo do agente ou o modelo da requisição
        const modelToUse = requestModel || agent.model || 'gpt-4o';

        // Verificar se a conversa pertence ao usuário e ao agente
        const conversation = await db.get(
            `SELECT * FROM viral_agent_conversations 
             WHERE id = ? AND agent_id = ? AND user_id = ?`,
            [conversation_id, agentId, userId]
        );

        if (!conversation) {
            return res.status(404).json({ msg: 'Conversa não encontrada.' });
        }

        // Salvar mensagem do usuário
        await db.run(
            `INSERT INTO viral_agent_messages (conversation_id, role, content)
             VALUES (?, ?, ?)`,
            [conversation_id, 'user', message]
        );

        // Buscar histórico de mensagens da conversa
        const messageHistory = await db.all(
            `SELECT role, content FROM viral_agent_messages 
             WHERE conversation_id = ? 
             ORDER BY created_at ASC`,
            [conversation_id]
        );

        // Buscar arquivos do agente
        const agentFiles = await db.all(
            `SELECT file_name, file_content FROM viral_agent_files WHERE agent_id = ?`,
            [agentId]
        );

        // Preparar contexto para o Claude (CRÍTICO: sempre incluir memória e instruções)
        // FORMATO RIGOROSO: Priorizar instruções e memória de forma clara e enfática
        let systemPrompt = '';
        
        // INÍCIO: Instrução crítica para seguir as configurações
        systemPrompt += `# ⚠️ INSTRUÇÕES CRÍTICAS - SIGA RIGOROSAMENTE\n\n`;
        systemPrompt += `Você é um agente especializado que DEVE seguir EXATAMENTE as instruções e memória configuradas abaixo.\n`;
        systemPrompt += `NÃO invente ou ignore essas configurações. Elas definem seu comportamento e conhecimento.\n\n`;
        
        // MEMÓRIA PRIMEIRO (contexto sobre o usuário/agente)
        if (agent.memory && agent.memory.trim()) {
            systemPrompt += `# 📝 MEMÓRIA DO AGENTE (CONTEXTO OBRIGATÓRIO)\n`;
            systemPrompt += `A seguir está a memória configurada para este agente. Use essas informações para personalizar suas respostas:\n\n`;
            systemPrompt += `${agent.memory}\n\n`;
            systemPrompt += `---\n\n`;
            console.log('[Viral Agents] ✅ Memória incluída, tamanho:', agent.memory.length);
        } else {
            console.warn('[Viral Agents] ⚠️ Memória vazia ou não definida');
        }
        
        // INSTRUÇÕES (comportamento e formato)
        if (agent.instructions && agent.instructions.trim()) {
            systemPrompt += `# 🎯 INSTRUÇÕES DO AGENTE (SEGUIR OBRIGATORIAMENTE)\n`;
            systemPrompt += `As instruções abaixo definem COMO você deve se comportar e QUAIS regras seguir:\n\n`;
            systemPrompt += `${agent.instructions}\n\n`;
            systemPrompt += `---\n\n`;
            console.log('[Viral Agents] ✅ Instruções incluídas, tamanho:', agent.instructions.length);
        } else {
            console.warn('[Viral Agents] ⚠️ Instruções vazias ou não definidas');
        }
        
        // ARQUIVOS (referências adicionais)
        if (agentFiles.length > 0) {
            systemPrompt += `# 📎 ARQUIVOS DISPONÍVEIS (REFERÊNCIA)\n`;
            systemPrompt += `Use os arquivos abaixo como referência adicional quando relevante:\n\n`;
            agentFiles.forEach(file => {
                systemPrompt += `## ${file.file_name}\n${file.file_content}\n\n`;
            });
            systemPrompt += `---\n\n`;
            console.log('[Viral Agents] ✅ Arquivos incluídos:', agentFiles.length);
        }
        
        // RELEMBRAR: Seguir as configurações
        systemPrompt += `# ⚠️ LEMBRETE FINAL\n`;
        systemPrompt += `- Use a MEMÓRIA para personalizar suas respostas ao contexto do usuário\n`;
        systemPrompt += `- Siga as INSTRUÇÕES rigorosamente para manter consistência\n`;
        systemPrompt += `- Se as instruções pedirem um formato específico, use EXATAMENTE esse formato\n`;
        systemPrompt += `- Se a memória descrever o propósito do agente, mantenha esse propósito em todas as respostas\n\n`;
        
        // INSTRUÇÃO CRÍTICA: Gerar roteiro completo (SEM avaliação)
        systemPrompt += `# 🎬 INSTRUÇÃO FINAL - CRÍTICA\n\n`;
        systemPrompt += `VOCÊ DEVE:\n`;
        systemPrompt += `1. Seguir RIGOROSAMENTE as INSTRUÇÕES e MEMÓRIA configuradas acima\n`;
        systemPrompt += `2. Gerar um ROTEIRO COMPLETO baseado na mensagem do usuário\n`;
        systemPrompt += `3. O roteiro deve ser detalhado, completo e seguir o formato especificado nas instruções\n`;
        systemPrompt += `4. NÃO pare no meio do roteiro - complete TODA a história até o final\n`;
        systemPrompt += `5. NÃO corte o roteiro - continue até concluir completamente a narrativa\n`;
        systemPrompt += `6. Use a memória para personalizar o roteiro ao contexto do usuário\n`;
        systemPrompt += `7. NÃO inclua avaliações, análises ou comentários sobre o roteiro - apenas o roteiro em si\n`;
        systemPrompt += `8. Se o roteiro for longo, continue escrevendo até o final - NÃO pare antes de concluir\n\n`;
        systemPrompt += `IMPORTANTE: Se as instruções pedirem um formato específico de roteiro, use EXATAMENTE esse formato.\n`;
        systemPrompt += `Se a memória descrever o propósito do agente, mantenha esse propósito ao gerar o roteiro.\n`;
        systemPrompt += `CRÍTICO: Você tem até 16384 tokens disponíveis. Use TODOS se necessário para completar o roteiro.\n`;
        systemPrompt += `NÃO pare no meio - continue até o final completo do roteiro.\n\n`;

        // Verificar preferência do usuário: usar créditos (laozhang.ai) ou APIs próprias
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        console.log('[Viral Agents] Preferência do usuário:', { userId, useCredits, userPrefs });
        
        let useLaozhang = false;
        let laozhangApiKey = null;
        
        // REGRA CRÍTICA: Se preferência marcada, SEMPRE usar Laozhang (créditos)
        if (useCredits) {
            // Buscar chave da laozhang.ai usando a função existente
            const laozhangKey = await getLaozhangApiKey();
            console.log('[Viral Agents] Chave Laozhang encontrada:', laozhangKey ? 'Sim' : 'Não', typeof laozhangKey);
            
            if (laozhangKey) {
                // Normalizar a chave (já vem normalizada da função, mas garantir)
                if (typeof laozhangKey === 'string') {
                    laozhangApiKey = laozhangKey.trim();
                } else if (typeof laozhangKey === 'object' && laozhangKey !== null) {
                    // Se ainda for objeto, extrair api_key
                    laozhangApiKey = (laozhangKey.api_key || laozhangKey.key || JSON.stringify(laozhangKey)).trim();
                } else {
                    laozhangApiKey = String(laozhangKey).trim();
                }
                
                console.log('[Viral Agents] Chave Laozhang normalizada:', laozhangApiKey ? `Sim (${laozhangApiKey.length} chars)` : 'Não');
                
                if (laozhangApiKey && laozhangApiKey.length > 10) {
                    useLaozhang = true;
                    console.log('[Viral Agents] ✅ Usando Laozhang.ai (preferência: usar créditos) com modelo:', modelToUse);
                } else {
                    console.error('[Viral Agents] ❌ Chave Laozhang inválida ou muito curta. Tamanho:', laozhangApiKey?.length || 0);
                    return res.status(500).json({ 
                        msg: 'Chave da API Laozhang.ai não configurada ou inválida. Configure no painel admin.' 
                    });
                }
            } else {
                console.error('[Viral Agents] ❌ Chave Laozhang não encontrada, mesmo com preferência marcada');
                return res.status(500).json({ 
                    msg: 'Chave da API Laozhang.ai não configurada. Configure no painel admin ou desmarque a preferência de usar créditos.' 
                });
            }
        } else {
            console.log('[Viral Agents] Preferência não marcada, verificando se deve usar créditos por falta de API própria...');
            // Mesmo sem preferência marcada, verificar se deve usar créditos (sem API própria)
            const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
            if (creditsCheck.shouldUse && !creditsCheck.hasOwnApi) {
                console.log('[Viral Agents] ✅ Usando créditos (sem API própria configurada)');
                const laozhangKey = await getLaozhangApiKey();
                if (laozhangKey) {
                    laozhangApiKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : String(laozhangKey).trim();
                    if (laozhangApiKey && laozhangApiKey.length > 10) {
                        useLaozhang = true;
                    }
                }
            }
        }
        
        // Se não usar laozhang, determinar qual serviço usar baseado no modelo
        let serviceName = 'claude';
        if (!useLaozhang) {
            if (modelToUse && (modelToUse.includes('gpt') || modelToUse.includes('GPT'))) {
                serviceName = 'openai';
            } else if (modelToUse && modelToUse.includes('gemini')) {
                serviceName = 'gemini';
            }

            // Buscar API key do serviço apropriado
            const apiKeyRow = await db.get(
                'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                [userId, serviceName]
            );

            if (!apiKeyRow || !apiKeyRow.api_key) {
                return res.status(400).json({ msg: `API key do ${serviceName === 'openai' ? 'OpenAI' : serviceName === 'gemini' ? 'Gemini' : 'Claude'} não configurada. Configure nas configurações.` });
            }

            var apiKey = decrypt(apiKeyRow.api_key);
            if (!apiKey) {
                return res.status(500).json({ msg: 'Erro ao descriptografar API key.' });
            }
        }

        // Preparar mensagens
        const messages = [];
        
        // Adicionar histórico de mensagens (apenas user e assistant)
        messageHistory.forEach(msg => {
            if (msg.role === 'user' || msg.role === 'assistant') {
                messages.push({
                    role: msg.role,
                    content: msg.content
                });
            }
        });

        let assistantMessage = '';
        
        // Preparar prompt completo para laozhang (usado tanto em streaming quanto não-streaming)
        // IMPORTANTE: Incluir systemPrompt de forma enfática no início
        let fullPrompt = '';
        if (useLaozhang && laozhangApiKey) {
            // Começar com systemPrompt (memória + instruções) de forma muito clara
            if (systemPrompt && systemPrompt.trim()) {
                fullPrompt = `=== CONFIGURAÇÕES DO AGENTE (SEGUIR RIGOROSAMENTE) ===\n\n${systemPrompt}\n\n=== FIM DAS CONFIGURAÇÕES ===\n\n`;
            } else {
                fullPrompt = 'Você é um assistente útil.\n\n';
            }
            
            // Adicionar histórico de conversa
            if (messages.length > 0) {
                fullPrompt += `=== HISTÓRICO DA CONVERSA ===\n\n`;
                messages.forEach(msg => {
                    fullPrompt += `${msg.role === 'user' ? 'Usuário' : 'Assistente'}: ${msg.content}\n\n`;
                });
                fullPrompt += `=== FIM DO HISTÓRICO ===\n\n`;
            }
            
            // Adicionar mensagem atual com instrução clara
            fullPrompt += `=== MENSAGEM ATUAL DO USUÁRIO ===\n\n`;
            fullPrompt += `Usuário: ${message}\n\n`;
            fullPrompt += `=== SUA RESPOSTA (SEGUINDO AS CONFIGURAÇÕES ACIMA) ===\n\n`;
            fullPrompt += `INSTRUÇÕES PARA SUA RESPOSTA:\n`;
            fullPrompt += `1. Siga RIGOROSAMENTE as CONFIGURAÇÕES DO AGENTE acima (memória e instruções)\n`;
            fullPrompt += `2. Gere um ROTEIRO COMPLETO baseado na mensagem do usuário\n`;
            fullPrompt += `3. O roteiro deve ser detalhado e seguir o formato especificado nas instruções\n`;
            fullPrompt += `4. NÃO pare no meio - complete TODA a história/roteiro até o final\n`;
            fullPrompt += `5. NÃO corte o roteiro - continue escrevendo até concluir completamente\n`;
            fullPrompt += `6. Use a memória para personalizar o roteiro ao contexto\n`;
            fullPrompt += `7. NÃO inclua avaliações, análises ou comentários - apenas o roteiro em si\n`;
            fullPrompt += `8. Você tem até 16384 tokens disponíveis - use TODOS se necessário para completar o roteiro\n\n`;
            fullPrompt += `Agora gere sua resposta seguindo essas instruções:\n\n`;
            fullPrompt += `Assistente:`;
            
            console.log('[Viral Agents] 📋 FullPrompt construído, tamanho:', fullPrompt.length);
            console.log('[Viral Agents] 📋 Primeiros 500 chars do fullPrompt:', fullPrompt.substring(0, 500));
        }

        // Se usar laozhang.ai, chamar API laozhang
        if (useLaozhang && laozhangApiKey) {
            console.log('[Viral Agents] 🚀 Iniciando chamada Laozhang.ai com modelo:', modelToUse, 'Stream:', stream);
            
            if (stream) {
                // Streaming com laozhang (usar endpoint direto com streaming)
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                
                try {
                    // Mapear modelo para formato laozhang (manter o mesmo formato)
                    const laozhangModel = modelToUse || 'gpt-4o';
                    console.log('[Viral Agents] 📝 Modelo Laozhang:', laozhangModel);
                    
                    // Preparar mensagens para cálculo de tokens (CRÍTICO: sempre incluir systemPrompt com memória e instruções)
                    const systemContent = systemPrompt && systemPrompt.trim() ? systemPrompt : 'Você é um assistente útil.';
                    console.log('[Viral Agents] 📋 System content incluído no streaming, tamanho:', systemContent.length);
                    const allMessages = [
                        { role: 'system', content: systemContent },
                        ...messages,
                        { role: 'user', content: message }
                    ];
                    
                    // Calcular tokens aproximados (input + output estimado)
                    const promptText = allMessages.map(m => m.content).join('\n');
                    const promptTokens = Math.ceil(promptText.length / 4);
                    // Estimativa para roteiros: baseado no max_tokens configurado (16384)
                    // Usar 80% do max_tokens como estimativa conservadora
                    const estimatedOutputTokens = Math.ceil(16384 * 0.8);
                    const totalTokens = promptTokens + estimatedOutputTokens;
                    
                    console.log('[Viral Agents] 💰 Calculando créditos:', {
                        promptTokens,
                        estimatedOutputTokens,
                        totalTokens
                    });
                    
                    // Debitar créditos ANTES da chamada
                    let creditDebitResult = null;
                    try {
                        const laozhangProviderId = await getLaozhangApiProviderId();
                        if (laozhangProviderId) {
                            creditDebitResult = await checkAndDebitCredits(
                                userId,
                                laozhangProviderId,
                                totalTokens,
                                'viral_agent_chat',
                                JSON.stringify({ agent_id: agentId, conversation_id: conversation_id, model: laozhangModel, stream: true })
                            );
                            console.log(`[Viral Agents] 💰 Créditos debitados: ${creditDebitResult.creditsUsed.toFixed(4)}, Novo saldo: ${creditDebitResult.newBalance.toFixed(4)}`);
                        } else {
                            console.warn('[Viral Agents] ⚠️ Provider Laozhang não encontrado, pulando débito de créditos');
                        }
                    } catch (creditError) {
                        console.error('[Viral Agents] ❌ Erro ao debitar créditos:', creditError.message);
                        // Se não tiver créditos suficientes, lançar erro
                        if (creditError.message.includes('Créditos insuficientes')) {
                            res.write(`data: ${JSON.stringify({ error: creditError.message })}\n\n`);
                            res.end();
                            return;
                        }
                        // Se for outro erro, continuar mas logar
                    }
                    
                    const payload = {
                        model: laozhangModel,
                        messages: allMessages,
                        temperature: 0.7,
                        max_tokens: 16384, // Aumentado para permitir roteiros mais longos
                        stream: true
                    };
                    
                    console.log('[Viral Agents] 📤 Enviando requisição para Laozhang.ai:', {
                        endpoint: LAOZHANG_CHAT_ENDPOINT,
                        model: laozhangModel,
                        messages_count: payload.messages.length,
                        system_prompt_length: systemPrompt?.length || 0
                    });
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 300000);
                    
                    const response = await fetch(LAOZHANG_CHAT_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${laozhangApiKey}`,
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });
                    
                    console.log('[Viral Agents] 📥 Resposta Laozhang:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        const error = await response.json().catch(() => ({ error: { message: 'Erro desconhecido' } }));
                        console.error('[Viral Agents] ❌ Erro Laozhang:', error);
                        res.write(`data: ${JSON.stringify({ error: error.error?.message || error.message || 'Erro ao processar mensagem' })}\n\n`);
                        res.end();
                        return;
                    }
                    
                    console.log('[Viral Agents] ✅ Resposta OK, iniciando leitura do stream...');
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let fullMessage = '';
                    let streamEnded = false;
                    
                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) {
                                streamEnded = true;
                                break;
                            }
                            
                            const chunk = decoder.decode(value, { stream: true });
                            const lines = chunk.split('\n');
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6).trim();
                                    if (!data || data === '[DONE]') {
                                        streamEnded = true;
                                        break;
                                    }
                                    
                                    try {
                                        const parsed = JSON.parse(data);
                                        if (parsed.choices?.[0]?.delta?.content) {
                                            const text = parsed.choices[0].delta.content;
                                            fullMessage += text;
                                            res.write(`data: ${JSON.stringify({ text: text })}\n\n`);
                                        } else if (parsed.choices?.[0]?.message?.content) {
                                            // Algumas APIs retornam conteúdo completo
                                            fullMessage += parsed.choices[0].message.content;
                                            res.write(`data: ${JSON.stringify({ text: parsed.choices[0].message.content })}\n\n`);
                                        }
                                    } catch (e) {
                                        // Ignorar erros de parsing de linhas inválidas
                                        console.warn('[Viral Agents] Erro ao parsear linha:', e.message);
                                    }
                                }
                            }
                            
                            if (streamEnded) break;
                        }
                    } catch (streamError) {
                        console.error('[Viral Agents] Erro durante leitura do stream:', streamError);
                        // Continuar para finalizar mesmo com erro
                    }
                    
                    // Garantir que sempre finalize o stream e salve a mensagem
                    clearTimeout(timeoutId);
                    
                    try {
                        // Extrair nota e checklist
                        let nota = null;
                        let checklist = null;
                        let roteiroFinal = fullMessage.trim();
                        
                        if (roteiroFinal) {
                            // Remover a seção completa de avaliação (texto + JSON)
                            // Procura por "# 📊 AVALIAÇÃO DO ROTEIRO" ou variações e remove tudo até o final
                            const avaliacaoRegex = /#\s*📊\s*AVALIAÇÃO\s*DO\s*ROTEIRO[\s\S]*$/i;
                            if (avaliacaoRegex.test(roteiroFinal)) {
                                // Encontrar onde começa a avaliação
                                const avaliacaoIndex = roteiroFinal.search(avaliacaoRegex);
                                if (avaliacaoIndex !== -1) {
                                    // Extrair JSON da avaliação antes de remover
                                    const parteAvaliacao = roteiroFinal.substring(avaliacaoIndex);
                                    const jsonMatch = parteAvaliacao.match(/\{[\s\S]*"nota"[\s\S]*\}/);
                                    if (jsonMatch) {
                                        try {
                                            const avaliacao = JSON.parse(jsonMatch[0]);
                                            nota = avaliacao.nota;
                                            checklist = avaliacao.checklist || null;
                                        } catch (e) {
                                            // Tentar extrair nota do texto
                                            const notaMatch = parteAvaliacao.match(/nota[:\s]*(\d+)\/10/i);
                                            if (notaMatch) {
                                                nota = parseInt(notaMatch[1]);
                                            }
                                        }
                                    } else {
                                        // Tentar extrair nota do texto se não houver JSON
                                        const notaMatch = parteAvaliacao.match(/nota[:\s]*(\d+)\/10/i);
                                        if (notaMatch) {
                                            nota = parseInt(notaMatch[1]);
                                        }
                                    }
                                    // Remover toda a seção de avaliação
                                    roteiroFinal = roteiroFinal.substring(0, avaliacaoIndex).trim();
                                }
                            } else {
                                // Se não encontrar a seção completa, tentar remover apenas o JSON
                                const jsonMatch = roteiroFinal.match(/\{[\s\S]*"nota"[\s\S]*\}/);
                                if (jsonMatch) {
                                    try {
                                        const avaliacao = JSON.parse(jsonMatch[0]);
                                        nota = avaliacao.nota;
                                        checklist = avaliacao.checklist || null;
                                        roteiroFinal = roteiroFinal.replace(/\{[\s\S]*"nota"[\s\S]*\}/, '').trim();
                                    } catch (e) {
                                        const notaMatch = roteiroFinal.match(/nota[:\s]*(\d+)\/10/i);
                                        if (notaMatch) {
                                            nota = parseInt(notaMatch[1]);
                                            roteiroFinal = roteiroFinal.replace(/nota[:\s]*\d+\/10[\s\S]*/i, '').trim();
                                        }
                                    }
                                }
                            }
                            
                            // Remover também qualquer texto relacionado à avaliação que possa ter ficado
                            roteiroFinal = roteiroFinal.replace(/Análise da Avaliação:[\s\S]*$/i, '').trim();
                            roteiroFinal = roteiroFinal.replace(/Pontos Fortes:[\s\S]*$/i, '').trim();
                            roteiroFinal = roteiroFinal.replace(/Área de Melhoria:[\s\S]*$/i, '').trim();
                            roteiroFinal = roteiroFinal.replace(/GANCHO INICIAL[\s\S]*$/i, '').trim();
                            roteiroFinal = roteiroFinal.replace(/ESTRUTURA NARRATIVA[\s\S]*$/i, '').trim();
                            
                            // Salvar mensagem no banco (CRÍTICO: sempre salvar)
                            await db.run(
                                `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                 VALUES (?, ?, ?)`,
                                [conversation_id, 'assistant', roteiroFinal]
                            );
                            console.log('[Viral Agents] ✅ Mensagem salva no banco, tamanho:', roteiroFinal.length);
                            
                            // Atualizar título da conversa
                            const conversationTitle = await db.get(
                                `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                                [conversation_id]
                            );
                            
                            if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                                const firstPhrase = message.substring(0, 50).trim();
                                const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                                await db.run(
                                    `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                    [title, conversation_id]
                                );
                            } else {
                                await db.run(
                                    `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                    [conversation_id]
                                );
                            }
                            
                            // Enviar evento de finalização (CRÍTICO: sempre enviar)
                            res.write(`data: ${JSON.stringify({ done: true, nota: nota, checklist: checklist })}\n\n`);
                            console.log('[Viral Agents] ✅ Evento done:true enviado');
                        } else {
                            // Se não houver mensagem, ainda assim enviar done
                            console.warn('[Viral Agents] ⚠️ Mensagem vazia, enviando done mesmo assim');
                            res.write(`data: ${JSON.stringify({ done: true, nota: null, checklist: null })}\n\n`);
                        }
                    } catch (saveError) {
                        console.error('[Viral Agents] ❌ Erro ao salvar mensagem:', saveError);
                        // Mesmo com erro ao salvar, enviar done para o frontend
                        res.write(`data: ${JSON.stringify({ done: true, error: 'Erro ao salvar mensagem', nota: null, checklist: null })}\n\n`);
                    }
                    
                    // Sempre finalizar a resposta
                    res.end();
                    console.log('[Viral Agents] ✅ Stream finalizado');
                    return;
                } catch (err) {
                    console.error('[La Casa Dark Core Streaming] Erro:', err);
                    clearTimeout(timeoutId);
                    try {
                        // Tentar salvar mensagem parcial se houver
                        if (fullMessage && fullMessage.trim()) {
                            await db.run(
                                `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                 VALUES (?, ?, ?)`,
                                [conversation_id, 'assistant', fullMessage.trim()]
                            );
                        }
                        // Sempre enviar evento de erro ou finalização
                        res.write(`data: ${JSON.stringify({ done: true, error: err.message || 'Erro no streaming', nota: null, checklist: null })}\n\n`);
                    } catch (finalError) {
                        console.error('[Viral Agents] Erro ao finalizar stream:', finalError);
                        res.write(`data: ${JSON.stringify({ done: true, error: 'Erro crítico no streaming' })}\n\n`);
                    }
                    res.end();
                }
                return;
            } else {
                // Modo não-streaming com laozhang
                try {
                    // Mapear modelo do frontend para formato da laozhang.ai
                    let laozhangModel = null;
                    if (modelToUse) {
                        if (modelToUse === 'gpt-4o' || modelToUse === 'GPT-4o (2025)') {
                            laozhangModel = 'gpt-4o';
                        } else if (modelToUse === 'claude-3-7-sonnet-20250219' || modelToUse === 'Claude 3.7 Sonnet (Fev/25)') {
                            laozhangModel = 'claude-3-7-sonnet-20250219';
                        } else if (modelToUse === 'gemini-2.5-pro' || modelToUse === 'Gemini 2.5 Pro (2025)') {
                            laozhangModel = 'gemini-2.5-pro';
                        } else if (modelToUse.includes('claude')) {
                            laozhangModel = 'claude-3-7-sonnet-20250219';
                        } else if (modelToUse.includes('gemini')) {
                            laozhangModel = 'gemini-2.5-pro';
                        } else if (modelToUse.includes('gpt')) {
                            laozhangModel = 'gpt-4o';
                        } else {
                            laozhangModel = modelToUse;
                        }
                    }
                    
                    // Se ainda não tem modelo, usar 'gpt-4o' apenas como último recurso
                    if (!laozhangModel) {
                        console.warn(`[Viral Agents] ⚠️ Modelo não fornecido, usando 'gpt-4o' como fallback`);
                        laozhangModel = 'gpt-4o';
                    }
                    
                    console.log('[Viral Agents] 📝 Modo não-streaming Laozhang - Modelo recebido:', modelToUse, '-> Mapeado para API:', laozhangModel);
                    console.log('[Viral Agents] 📤 Chamando callLaozhangAPI...');
                    console.log('[Viral Agents] 📋 FullPrompt tamanho:', fullPrompt?.length || 0, 'SystemPrompt incluído:', systemPrompt ? 'Sim' : 'Não');
                    
                    // Garantir que fullPrompt está construído corretamente com systemPrompt enfático
                    if (!fullPrompt || fullPrompt.trim().length === 0) {
                        console.warn('[Viral Agents] ⚠️ FullPrompt vazio, reconstruindo com systemPrompt...');
                        // Reconstruir com formatação enfática
                        if (systemPrompt && systemPrompt.trim()) {
                            fullPrompt = `=== CONFIGURAÇÕES DO AGENTE (SEGUIR RIGOROSAMENTE) ===\n\n${systemPrompt}\n\n=== FIM DAS CONFIGURAÇÕES ===\n\n`;
                        } else {
                            fullPrompt = 'Você é um assistente útil.\n\n';
                        }
                        
                        // Adicionar histórico
                        if (messages.length > 0) {
                            fullPrompt += `=== HISTÓRICO DA CONVERSA ===\n\n`;
                            messages.forEach(msg => {
                                fullPrompt += `${msg.role === 'user' ? 'Usuário' : 'Assistente'}: ${msg.content}\n\n`;
                            });
                            fullPrompt += `=== FIM DO HISTÓRICO ===\n\n`;
                        }
                        
                        // Adicionar mensagem atual
                        fullPrompt += `=== MENSAGEM ATUAL DO USUÁRIO ===\n\n`;
                        fullPrompt += `Usuário: ${message}\n\n`;
                        fullPrompt += `=== SUA RESPOSTA (SEGUINDO AS CONFIGURAÇÕES ACIMA) ===\n\n`;
                        fullPrompt += `Assistente:`;
                    }
                    
                    // Adicionar marcador para callLaozhangAPI detectar como roteiro
                    const promptWithMarker = fullPrompt + '\n\nIMPORTANTE: Gere o roteiro completo em TEXTO SIMPLES, sem usar JSON ou formatações especiais.';
                    console.log('[Viral Agents] 📝 Prompt final tamanho:', promptWithMarker.length);
                    console.log('[Viral Agents] 💰 Chamando callLaozhangAPI com userId:', userId ? 'Sim' : 'Não');
                    assistantMessage = await callLaozhangAPI(promptWithMarker, laozhangApiKey, laozhangModel, null, userId, 'viral_agent_chat', JSON.stringify({ agent_id: agentId, conversation_id: conversation_id, model: laozhangModel }));
                    console.log('[Viral Agents] ✅ Resposta recebida, tamanho:', assistantMessage?.length || 0);
                    
                    // Extrair nota e checklist usando função helper - modo não-streaming laozhang
                    const { roteiroFinal, nota, checklist } = removeAvaliacaoFromRoteiro(assistantMessage);
                    
                    // Salvar roteiro completo (sem a nota)
                    await db.run(
                        `INSERT INTO viral_agent_messages (conversation_id, role, content)
                         VALUES (?, ?, ?)`,
                        [conversation_id, 'assistant', roteiroFinal]
                    );
                    
                    const conversationTitle = await db.get(
                        `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                        [conversation_id]
                    );
                    
                    if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                        const firstPhrase = message.substring(0, 50).trim();
                        const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                        await db.run(
                            `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                            [title, conversation_id]
                        );
                    } else {
                        await db.run(
                            `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                            [conversation_id]
                        );
                    }
                    
                    return res.status(200).json({ response: roteiroFinal, nota: nota, checklist: checklist });
                } catch (err) {
                    console.error('[La Casa Dark Core API] Erro:', err);
                    return res.status(500).json({ msg: err.message || 'Erro ao processar mensagem.' });
                }
            }
        } else if (serviceName === 'claude') {
            // API do Claude
            const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';
            
            // Mapear modelo se necessário
            const modelAliases = {
                'claude-3-5-sonnet-20241022': 'claude-3-7-sonnet-20250219',
                'claude-3-5-sonnet-20240620': 'claude-3-7-sonnet-20250219',
                'claude-3-5-sonnet-latest': 'claude-3-7-sonnet-20250219',
                'claude-3-sonnet-20240229': 'claude-3-7-sonnet-20250219',
                'claude-3.5-sonnet-20241022': 'claude-3-7-sonnet-20250219',
                'claude-3.5-sonnet-20240620': 'claude-3-7-sonnet-20250219',
                'claude-3-haiku-20240307': 'claude-3-7-sonnet-20250219',
                'claude-3.5-haiku-20241022': 'claude-3-7-sonnet-20250219',
                'claude-3-5-haiku-20241022': 'claude-3-7-sonnet-20250219',
                'claude-3-5-haiku-latest': 'claude-3-7-sonnet-20250219',
                'claude-3-opus-20240229': 'claude-opus-4-20250514'
            };
            
            let modelName = modelAliases[modelToUse] || modelToUse;
            const supportedModels = new Set([
                'claude-3-7-sonnet-20250219',
                'claude-sonnet-4-20250514',
                'claude-opus-4-20250514'
            ]);
            
            if (!supportedModels.has(modelName)) {
                if (modelToUse && modelToUse.toLowerCase().includes('opus')) {
                    modelName = 'claude-opus-4-20250514';
                } else if (modelToUse && (modelToUse.toLowerCase().includes('sonnet') || modelToUse.toLowerCase().includes('4'))) {
                    modelName = 'claude-sonnet-4-20250514';
                } else {
                    modelName = 'claude-3-7-sonnet-20250219';
                }
            }
            
            // Preparar mensagens com system prompt
            const claudeMessages = [...messages];
            
            const payload = {
                model: modelName,
                max_tokens: 16384, // Aumentado para permitir roteiros mais longos e completos
                messages: claudeMessages,
                stream: stream // Habilitar streaming
            };
            
            // Adicionar system prompt se houver (CRÍTICO: sempre incluir memória e instruções)
            // Claude usa o campo 'system' que tem alta prioridade e deve seguir rigorosamente
            if (systemPrompt && systemPrompt.trim()) {
                payload.system = systemPrompt;
                console.log('[Viral Agents] ✅ System prompt incluído no payload Claude (memória + instruções), tamanho:', systemPrompt.length);
                console.log('[Viral Agents] 📋 Primeiros 500 chars do system prompt:', systemPrompt.substring(0, 500));
            } else {
                console.warn('[Viral Agents] ⚠️ System prompt vazio ou não definido - Claude pode não seguir instruções!');
            }

            if (stream) {
                // Configurar SSE para streaming
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000); // 5 minutos para roteiros longos

                try {
                    const response = await fetch(CLAUDE_API_URL, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        res.write(`data: ${JSON.stringify({ error: error.error?.message || 'Erro ao processar mensagem' })}\n\n`);
                        res.end();
                        return;
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let fullMessage = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                    if (data === '[DONE]') {
                                        clearTimeout(timeoutId);
                                        
                                        // Extrair nota e checklist usando função helper
                                        const { roteiroFinal, nota, checklist } = removeAvaliacaoFromRoteiro(fullMessage);
                                        
                                        // Salvar roteiro completo (sem a nota)
                                        await db.run(
                                            `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                             VALUES (?, ?, ?)`,
                                            [conversation_id, 'assistant', roteiroFinal]
                                        );
                                        
                                        // Atualizar título da conversa
                                        const conversationTitle = await db.get(
                                            `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                                            [conversation_id]
                                        );
                                        
                                        if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                                            const firstPhrase = message.substring(0, 50).trim();
                                            const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                                            await db.run(
                                                `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                                [title, conversation_id]
                                            );
                                        } else {
                                            await db.run(
                                                `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                                [conversation_id]
                                            );
                                        }
                                        
                                        res.write(`data: ${JSON.stringify({ done: true, nota: nota, checklist: checklist })}\n\n`);
                                        res.end();
                                        return;
                                    }

                                try {
                                    const parsed = JSON.parse(data);
                                    if (parsed.type === 'content_block_delta' && parsed.delta?.text) {
                                        const text = parsed.delta.text;
                                        fullMessage += text;
                                        res.write(`data: ${JSON.stringify({ text: text })}\n\n`);
                                    }
                                } catch (e) {
                                    // Ignorar linhas inválidas
                                }
                            }
                        }
                        
                        // Se o loop terminou sem receber [DONE], finalizar manualmente
                        if (fullMessage.trim()) {
                            clearTimeout(timeoutId);
                            
                            // Extrair nota e checklist usando função helper
                            const { roteiroFinal, nota, checklist } = removeAvaliacaoFromRoteiro(fullMessage);
                            
                            // Salvar mensagem
                            await db.run(
                                `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                 VALUES (?, ?, ?)`,
                                [conversation_id, 'assistant', roteiroFinal]
                            );
                            
                            // Atualizar conversa
                            const conversationTitle = await db.get(
                                `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                                [conversation_id]
                            );
                            
                            if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                                const firstPhrase = message.substring(0, 50).trim();
                                const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                                await db.run(
                                    `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                    [title, conversation_id]
                                );
                            } else {
                                await db.run(
                                    `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                    [conversation_id]
                                );
                            }
                            
                            res.write(`data: ${JSON.stringify({ done: true, nota: nota, checklist: checklist })}\n\n`);
                            res.end();
                            return;
                        }
                    }
                } catch (err) {
                    clearTimeout(timeoutId);
                    console.error('[Claude Streaming] Erro:', err);
                    try {
                        // Tentar salvar mensagem parcial
                        if (fullMessage && fullMessage.trim()) {
                            await db.run(
                                `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                 VALUES (?, ?, ?)`,
                                [conversation_id, 'assistant', fullMessage.trim()]
                            );
                        }
                        res.write(`data: ${JSON.stringify({ done: true, error: err.message || 'Erro no streaming', nota: null, checklist: null })}\n\n`);
                    } catch (finalError) {
                        res.write(`data: ${JSON.stringify({ done: true, error: 'Erro crítico no streaming' })}\n\n`);
                    }
                    res.end();
                }
                return;
            } else {
                // Modo não-streaming (fallback)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000);

                const response = await fetch(CLAUDE_API_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify(payload),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (!response.ok) {
                    console.error('[Claude API] Erro:', result);
                    return res.status(response.status).json({ 
                        msg: result.error?.message || 'Erro ao processar mensagem com Claude.',
                        error: result.error 
                    });
                }

                assistantMessage = result.content[0].text;
            }
            
        } else if (serviceName === 'openai') {
            // API do OpenAI
            const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
            
            const openaiMessages = [];
            if (systemPrompt) {
                openaiMessages.push({
                    role: 'system',
                    content: systemPrompt
                });
            }
            openaiMessages.push(...messages);
            
            const payload = {
                model: modelToUse || 'gpt-4o',
                messages: openaiMessages,
                max_tokens: 16384, // Aumentado para permitir roteiros mais longos e completos
                temperature: 0.7,
                stream: stream
            };
            
            if (stream) {
                // Streaming para OpenAI
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000);

                try {
                    const response = await fetch(OPENAI_API_URL, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        res.write(`data: ${JSON.stringify({ error: error.error?.message || 'Erro ao processar mensagem' })}\n\n`);
                        res.end();
                        return;
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let fullMessage = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') {
                                    clearTimeout(timeoutId);
                                    
                                    // Extrair nota e pontos fortes do JSON (se houver)
                                    let nota = null;
                                    let pontosFortes = [];
                                    let roteiroFinal = fullMessage;
                                    
                                    // Tentar encontrar JSON no final da mensagem
                                    const jsonMatch = fullMessage.match(/\{[\s\S]*"nota"[\s\S]*\}/);
                                    if (jsonMatch) {
                                        try {
                                            const avaliacao = JSON.parse(jsonMatch[0]);
                                            nota = avaliacao.nota;
                                                checklist = avaliacao.checklist || null;
                                            // Remover JSON do roteiro
                                            roteiroFinal = fullMessage.replace(/\{[\s\S]*"nota"[\s\S]*\}/, '').trim();
                                        } catch (e) {
                                            // Se não conseguir parsear, tentar extrair nota manualmente
                                            const notaMatch = fullMessage.match(/nota[:\s]*(\d+)\/10/i);
                                            if (notaMatch) {
                                                nota = parseInt(notaMatch[1]);
                                                roteiroFinal = fullMessage.replace(/nota[:\s]*\d+\/10[\s\S]*/i, '').trim();
                                            }
                                        }
                                    }
                                    
                                    // Salvar roteiro completo (sem a nota)
                                    await db.run(
                                        `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                         VALUES (?, ?, ?)`,
                                        [conversation_id, 'assistant', roteiroFinal]
                                    );
                                    
                                    const conversationTitle = await db.get(
                                        `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                                        [conversation_id]
                                    );
                                    
                                    if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                                        const firstPhrase = message.substring(0, 50).trim();
                                        const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                                        await db.run(
                                            `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                            [title, conversation_id]
                                        );
                                    } else {
                                        await db.run(
                                            `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                            [conversation_id]
                                        );
                                    }
                                    
                                    res.write(`data: ${JSON.stringify({ done: true, nota: nota, checklist: checklist })}\n\n`);
                                    res.end();
                                    return;
                                }

                                try {
                                    const parsed = JSON.parse(data);
                                    if (parsed.choices?.[0]?.delta?.content) {
                                        const text = parsed.choices[0].delta.content;
                                        fullMessage += text;
                                        res.write(`data: ${JSON.stringify({ text: text })}\n\n`);
                                    }
                                } catch (e) {
                                    // Ignorar linhas inválidas
                                }
                            }
                        }
                    }
                } catch (err) {
                    clearTimeout(timeoutId);
                    console.error('[La Casa Dark Core Streaming] Erro:', err);
                    res.write(`data: ${JSON.stringify({ error: err.message || 'Erro no streaming' })}\n\n`);
                    res.end();
                }
                return;
            } else {
                // Modo não-streaming (fallback)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000);

                const response = await fetch(OPENAI_API_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(payload),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (!response.ok) {
                    console.error('[La Casa Dark Core API] Erro:', result);
                    return res.status(response.status).json({ 
                        msg: result.error?.message || 'Erro ao processar mensagem com OpenAI.',
                        error: result.error 
                    });
                }

                assistantMessage = result.choices[0].message.content;
            }
            
        } else if (serviceName === 'gemini') {
            // API do Gemini usando @google/genai
            const { GoogleGenAI } = require('@google/genai');
            const genAI = new GoogleGenAI(apiKey);
            
            // Preparar prompt completo com system prompt, histórico e mensagem atual
            let fullPrompt = '';
            if (systemPrompt) {
                fullPrompt += systemPrompt + '\n\n';
            }
            
            // Adicionar histórico
            messages.forEach(msg => {
                fullPrompt += `${msg.role === 'user' ? 'Usuário' : 'Assistente'}: ${msg.content}\n\n`;
            });
            
            // Adicionar mensagem atual
            fullPrompt += `Usuário: ${message}\nAssistente:`;

            const model = genAI.getGenerativeModel({ model: modelToUse || 'gemini-2.5-pro' });
            const result = await model.generateContent(fullPrompt);
            assistantMessage = result.response.text();
        }

        // Extrair nota e checklist usando função helper - modo não-streaming
        let nota = null;
        let checklist = null;
        const { roteiroFinal, nota: notaExtraida, checklist: checklistExtraido } = removeAvaliacaoFromRoteiro(assistantMessage);
        if (notaExtraida !== null) nota = notaExtraida;
        if (checklistExtraido !== null) checklist = checklistExtraido;
        const pontosFortes = checklist ? Object.keys(checklist).filter(k => checklist[k] === true) : [];
        if (notaExtraida !== null) nota = notaExtraida;
        if (checklistExtraido !== null) checklist = checklistExtraido;
        
        // Salvar roteiro completo (sem a nota)
        await db.run(
            `INSERT INTO viral_agent_messages (conversation_id, role, content)
             VALUES (?, ?, ?)`,
            [conversation_id, 'assistant', roteiroFinal]
        );

        // Atualizar título da conversa com primeira frase da mensagem do usuário (se ainda for "Nova Conversa")
        const conversationTitle = await db.get(
            `SELECT title FROM viral_agent_conversations WHERE id = ?`,
            [conversation_id]
        );
        
        if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
            // Pegar primeira frase da mensagem do usuário (primeiros 50 caracteres)
            const firstPhrase = message.substring(0, 50).trim();
            const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
            
            await db.run(
                `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                [title, conversation_id]
            );
        } else {
            // Apenas atualizar timestamp
            await db.run(
                `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                [conversation_id]
            );
        }

        res.status(200).json({ response: roteiroFinal, nota: nota, checklist: checklist });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/chat POST]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao processar mensagem.' });
    }
});

// Rota para obter mensagens de uma conversa
app.get('/api/viral-agents/:agentId/conversations/:conversationId/messages', authenticateToken, async (req, res) => {
    const { agentId, conversationId } = req.params;
    const userId = req.user.id;

    try {
        // Verificar se a conversa pertence ao usuário e ao agente
        const conversation = await db.get(
            `SELECT * FROM viral_agent_conversations 
             WHERE id = ? AND agent_id = ? AND user_id = ?`,
            [conversationId, agentId, userId]
        );

        if (!conversation) {
            return res.status(404).json({ msg: 'Conversa não encontrada.' });
        }

        const messages = await db.all(
            `SELECT * FROM viral_agent_messages 
             WHERE conversation_id = ? 
             ORDER BY created_at ASC`,
            [conversationId]
        );

        res.status(200).json({ messages });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/conversations/:conversationId/messages GET]:', err);
        res.status(500).json({ msg: 'Erro ao obter mensagens.' });
    }
});

// Rota para deletar uma conversa
app.delete('/api/viral-agents/:agentId/conversations/:conversationId', authenticateToken, async (req, res) => {
    const { agentId, conversationId } = req.params;
    const userId = req.user.id;

    try {
        const result = await db.run(
            `DELETE FROM viral_agent_conversations 
             WHERE id = ? AND agent_id = ? AND user_id = ?`,
            [conversationId, agentId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Conversa não encontrada.' });
        }

        res.status(200).json({ msg: 'Conversa deletada com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/conversations/:conversationId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao deletar conversa.' });
    }
});

// Rota para gerar documento MD de uma conversa
app.get('/api/viral-agents/:agentId/conversations/:conversationId/markdown', authenticateToken, async (req, res) => {
    const { agentId, conversationId } = req.params;
    const userId = req.user.id;

    try {
        // Verificar se o agente pertence ao usuário
        const agent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        // Verificar se a conversa pertence ao usuário e ao agente
        const conversation = await db.get(
            `SELECT * FROM viral_agent_conversations 
             WHERE id = ? AND agent_id = ? AND user_id = ?`,
            [conversationId, agentId, userId]
        );

        if (!conversation) {
            return res.status(404).json({ msg: 'Conversa não encontrada.' });
        }

        // Buscar todas as mensagens da conversa
        const messages = await db.all(
            `SELECT role, content, created_at FROM viral_agent_messages 
             WHERE conversation_id = ? 
             ORDER BY created_at ASC`,
            [conversationId]
        );

        // Gerar conteúdo Markdown
        let mdContent = `# ${conversation.title || 'Conversa'}\n\n`;
        mdContent += `**Agente:** ${agent.name}\n`;
        mdContent += `**Data:** ${new Date(conversation.created_at).toLocaleString('pt-BR')}\n\n`;
        mdContent += `---\n\n`;

        messages.forEach(msg => {
            const roleLabel = msg.role === 'user' ? '**Usuário:**' : '**Assistente:**';
            const timestamp = new Date(msg.created_at).toLocaleString('pt-BR');
            mdContent += `${roleLabel} (${timestamp})\n\n`;
            mdContent += `${msg.content}\n\n`;
            mdContent += `---\n\n`;
        });

        // Retornar como HTML para abrir em nova aba
        const htmlContent = `<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${conversation.title || 'Conversa'} - ${agent.name}</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        pre {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #3a3a3a;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        code {
            background: #2a2a2a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        h1 { color: #f59e0b; border-bottom: 2px solid #f59e0b; padding-bottom: 10px; }
        h2 { color: #fbbf24; margin-top: 30px; }
        hr { border: none; border-top: 1px solid #3a3a3a; margin: 20px 0; }
        .copy-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 1000;
        }
        .copy-btn:hover { background: #d97706; }
    </style>
</head>
<body>
    <button class="copy-btn" onclick="copyAll()">Copiar Tudo</button>
    <pre id="content">${mdContent.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
    <script>
        function copyAll() {
            const content = document.getElementById('content').textContent;
            navigator.clipboard.writeText(content).then(() => {
                alert('Conteúdo copiado!');
            });
        }
    </script>
</body>
</html>`;

        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.send(htmlContent);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/conversations/:conversationId/markdown GET]:', err);
        res.status(500).json({ msg: 'Erro ao gerar documento.' });
    }
});

// ==================== FIM DAS ROTAS PARA AGENTES VIRAIS ====================

// Rota para download de roteiro em formato TXT
app.get('/api/scripts/:id/download/txt', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scriptId = req.params.id;

    try {
        const script = await db.get(
            `SELECT * FROM generated_scripts WHERE id = ? AND user_id = ?`,
            [scriptId, userId]
        );

        if (!script) {
            return res.status(404).json({ msg: 'Roteiro não encontrado.' });
        }

        // Criar conteúdo TXT com cabeçalho
        let txtContent = `TÍTULO: ${script.title}\n`;
        txtContent += `DATA: ${new Date(script.created_at).toLocaleString('pt-BR')}\n`;
        txtContent += `MODELO: ${script.model_used || 'N/A'}\n`;
        if (script.niche) txtContent += `NICHO: ${script.niche}\n`;
        if (script.subniche) txtContent += `SUBNICHO: ${script.subniche}\n`;
        if (script.optimization_score) {
            txtContent += `\nANÁLISE DE OTIMIZAÇÃO:\n`;
            txtContent += `Score Geral: ${script.optimization_score}/10\n`;
            txtContent += `Retenção: ${script.retention_score}/10\n`;
            txtContent += `Autenticidade: ${script.authenticity_score}/10\n`;
        }
        txtContent += `\n${'='.repeat(60)}\n\nROTEIRO:\n\n`;
        txtContent += script.script_content;
        
        if (script.optimization_report) {
            txtContent += `\n\n${'='.repeat(60)}\n\n`;
            txtContent += script.optimization_report;
        }

        // Definir headers para download
        const filename = `roteiro_${script.id}_${script.title.replace(/[^a-z0-9]/gi, '_').substring(0, 50)}.txt`;
        res.setHeader('Content-Type', 'text/plain; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        res.send(txtContent);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts/:id/download/txt]:', err);
        res.status(500).json({ msg: 'Erro ao fazer download do roteiro.' });
    }
});

// Rota para download de roteiro em formato SRT (legendas)
app.get('/api/scripts/:id/download/srt', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scriptId = req.params.id;

    try {
        const script = await db.get(
            `SELECT * FROM generated_scripts WHERE id = ? AND user_id = ?`,
            [scriptId, userId]
        );

        if (!script) {
            return res.status(404).json({ msg: 'Roteiro não encontrado.' });
        }

        // Converter roteiro em formato SRT
        // Estimativa: 150 palavras por minuto, 3-5 palavras por legenda
        const scriptText = script.script_content;
        const sentences = scriptText.split(/[.!?]\s+/).filter(s => s.trim().length > 0);
        
        let srtContent = '';
        let counter = 1;
        let currentTime = 0; // em segundos
        
        for (const sentence of sentences) {
            const words = sentence.trim().split(/\s+/);
            const wordsPerSubtitle = 8; // Máximo de palavras por legenda
            
            // Dividir sentença em partes menores se necessário
            for (let i = 0; i < words.length; i += wordsPerSubtitle) {
                const chunk = words.slice(i, i + wordsPerSubtitle).join(' ');
                const chunkWords = chunk.split(/\s+/).length;
                const duration = (chunkWords / 150) * 60; // 150 palavras por minuto
                
                // Formatar timestamps
                const startTime = formatSRTTime(currentTime);
                const endTime = formatSRTTime(currentTime + duration);
                
                srtContent += `${counter}\n`;
                srtContent += `${startTime} --> ${endTime}\n`;
                srtContent += `${chunk}\n\n`;
                
                counter++;
                currentTime += duration;
            }
        }

        // Definir headers para download
        const filename = `roteiro_${script.id}_${script.title.replace(/[^a-z0-9]/gi, '_').substring(0, 50)}.srt`;
        res.setHeader('Content-Type', 'text/plain; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        res.send(srtContent);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts/:id/download/srt]:', err);
        res.status(500).json({ msg: 'Erro ao fazer download do roteiro em SRT.' });
    }
});

// Função auxiliar para formatar tempo no formato SRT (HH:MM:SS,mmm)
function formatSRTTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const millis = Math.floor((seconds % 1) * 1000);
    
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')},${String(millis).padStart(3, '0')}`;
}


// === ROTAS DE EXPLORAÇÃO DE NICHO ===

app.post('/api/niche/find-subniche', authenticateToken, async (req, res) => {
    const { nichePrincipal, ideiaInicial, model } = req.body;
    const userId = req.user.id;

    if (!nichePrincipal || !ideiaInicial || !model) {
        return res.status(400).json({ msg: 'Todos os campos são obrigatórios.' });
    }

    try {
        const prompt = `
            Você é um ESPECIALISTA EM CRIAÇÃO DE CANAIS MILIONÁRIOS NO YOUTUBE com experiência em identificar oportunidades de subnichos com alto potencial de viralização.
            
            OBJETIVO: Encontrar um subnicho dentro de "${nichePrincipal}" que permita criar um canal MILIONÁRIO com MILHÕES DE VIEWS, ALTO CTR e conteúdo que VIRALIZE.
            
            PROMPT INICIAL PARA EDUCAR O GPT:
            Quero criar um canal no YouTube dentro do nicho de "${nichePrincipal}", inicialmente pensei em abordar "${ideiaInicial}", mas percebi que já há bastante concorrência nesse subnicho. 
            
            Estou em busca de uma ideia de subnicho dentro de "${nichePrincipal}" que:
            - Ainda esteja pouco explorada no YouTube, com pouca ou nenhuma concorrência
            - Tenha alto volume de buscas e interesse crescente
            - Tenha bom potencial de monetização
            - TENHA ALTO POTENCIAL DE VIRALIZAÇÃO e capacidade de gerar milhões de views
            - Permita criar conteúdo com alto CTR (acima de 25%)
            - Tenha oportunidades de criar títulos e thumbnails virais
            
            O objetivo é encontrar uma oportunidade única para criar conteúdo relevante, com forte demanda, baixa competição, e POTENCIAL PARA CRIAR UM CANAL MILIONÁRIO com milhões de views e alto CTR.
            
            Com base em dados atuais e tendências, o que você recomenda? Forneça uma análise detalhada que inclua:
            - O subnicho recomendado e por que ele tem potencial para gerar milhões de views
            - Análise de concorrência e oportunidades
            - Potencial de viralização e alto CTR
            - Estratégias para criar conteúdo que viralize
            - Sugestões de títulos e thumbnails que gerem alto CTR
        `;

        // Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem plano que permite API própria OU não tem API própria configurada
        // REGRA CRÍTICA: Se preferência NÃO está marcada E usuário tem plano que permite E tem API própria → usar API própria
        let useLaozhang = false;
        let apiKeyToUse = null;
        let serviceToUse = null;
        let apiCallFunction = null;
        
        try {
            // Determinar ordem de preferência baseado no modelo
            let preferenceOrder = ['claude', 'openai', 'gemini'];
            if (model.startsWith('gemini')) preferenceOrder = ['gemini', 'claude', 'openai'];
            else if (model.startsWith('claude')) preferenceOrder = ['claude', 'openai', 'gemini'];
            else if (model.startsWith('gpt')) preferenceOrder = ['openai', 'claude', 'gemini'];
            
            const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
            
            if (creditsCheck.shouldUse) {
                // Se deve usar créditos, usar laozhang.ai
                const laozhangKey = await getLaozhangApiKey();
                if (laozhangKey) {
                    useLaozhang = true;
                    apiKeyToUse = laozhangKey;
                    serviceToUse = 'laozhang';
                    apiCallFunction = callLaozhangAPI;
                    console.log(`[Find Subniche] ✅ Usando Laozhang.ai (${creditsCheck.reason})`);
                } else {
                    console.warn('[Find Subniche] ⚠️ Laozhang.ai não configurada, tentando usar APIs próprias do usuário');
                }
            } else {
                console.log(`[Find Subniche] ✅ Usando API própria (${creditsCheck.reason})`);
            }
        } catch (err) {
            console.warn('[Find Subniche] Erro ao verificar uso de créditos:', err.message);
        }
        
        // Se não usar laozhang.ai, usar APIs próprias do usuário
        if (!useLaozhang) {
            let service;
            if (model.startsWith('gemini')) service = 'gemini';
            else if (model.startsWith('claude')) service = 'claude';
            else if (model.startsWith('gpt')) service = 'openai';
            else return res.status(400).json({ msg: 'Modelo de IA inválido.' });
            
            serviceToUse = service;
            
            const userKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (!userKeyData) return res.status(400).json({ msg: `Nenhuma Chave de API do ${service} configurada.` });
            
            apiKeyToUse = decrypt(userKeyData.api_key);
            if (!apiKeyToUse) return res.status(500).json({ msg: 'Falha ao desencriptar a sua chave de API.' });

            if (service === 'gemini') apiCallFunction = callGeminiAPI;
            else if (service === 'claude') apiCallFunction = callClaudeAPI;
            else apiCallFunction = callOpenAIAPI;
        }
        
        // Chamar API apropriada
        let response;
        if (useLaozhang) {
            response = await callLaozhangAPI(
                prompt, 
                apiKeyToUse, 
                model, 
                null, 
                userId, 
                '/api/niche/find-subniche', 
                JSON.stringify({ endpoint: '/api/niche/find-subniche', model })
            );
            // callLaozhangAPI retorna string diretamente
            response = typeof response === 'string' ? response.trim() : JSON.stringify(response);
            response = { titles: response };
        } else {
            response = await apiCallFunction(prompt, apiKeyToUse, model);
        }
        
        const recommendation = parseAIResponse(response.titles, serviceToUse);

        res.status(200).json({ recommendation: recommendation.text || recommendation });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/niche/find-subniche]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});

// === ROTA LAOZHANG PARA ENCONTRAR SUBNICHOS ===
app.post('/api/niche/find-subniche/laozhang', authenticateToken, async (req, res) => {
    const { nichePrincipal, ideiaInicial, selectedModel } = req.body;
    const userId = req.user.id;

    if (!nichePrincipal || !ideiaInicial) {
        return res.status(400).json({ msg: 'Nicho principal e ideia inicial são obrigatórios.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Se não houver modelo selecionado, usar GPT-4o como padrão
        const laozhangModel = selectedModel === 'Claude 3.7 Sonnet (Fev/25)' ? 'claude-3-7-sonnet-20250219' :
                             selectedModel === 'Gemini 2.5 Pro (2025)' ? 'gemini-2.5-pro' :
                             (!selectedModel || !selectedModel.trim()) ? 'gpt-4o' : selectedModel;

        const prompt = `
Você é um ESPECIALISTA EM CRIAÇÃO DE CANAIS MILIONÁRIOS NO YOUTUBE.

OBJETIVO: Encontrar um subnicho dentro de "${nichePrincipal}" que permita criar um canal MILIONÁRIO.

Quero criar um canal no YouTube dentro do nicho de "${nichePrincipal}", inicialmente pensei em abordar "${ideiaInicial}", mas percebi que já há bastante concorrência.

Estou em busca de uma ideia de subnicho dentro de "${nichePrincipal}" que:
- Ainda esteja pouco explorada no YouTube, com pouca ou nenhuma concorrência
- Tenha alto volume de buscas e interesse crescente
- Tenha bom potencial de monetização
- TENHA ALTO POTENCIAL DE VIRALIZAÇÃO e capacidade de gerar milhões de views
- Permita criar conteúdo com alto CTR (acima de 25%)
- Tenha oportunidades de criar títulos e thumbnails virais

IMPORTANTE: Responda APENAS com um JSON válido no seguinte formato (sem texto adicional antes ou depois):

{
  "subnicho_recomendado": "Nome do subnicho recomendado",
  "analise_potencial": "Análise detalhada explicando por que este subnicho tem potencial para gerar milhões de views, incluindo dados de mercado, tendências e oportunidades",
  "analise_concorrencia": "Análise da concorrência atual, mostrando por que há pouca competição e quais são as oportunidades de diferenciação",
  "potencial_viralizacao": "Explicação detalhada do potencial de viralização, incluindo fatores que podem fazer o conteúdo viralizar e gerar milhões de views",
  "estrategias_conteudo": [
    "Estratégia 1 para criar conteúdo que viralize",
    "Estratégia 2 para criar conteúdo que viralize",
    "Estratégia 3 para criar conteúdo que viralize",
    "Estratégia 4 para criar conteúdo que viralize"
  ],
  "sugestoes_titulos_thumbnails": {
    "titulos": [
      "Título viral 1 que gere alto CTR",
      "Título viral 2 que gere alto CTR",
      "Título viral 3 que gere alto CTR",
      "Título viral 4 que gere alto CTR"
    ],
    "thumbnails": [
      {
        "imagem": "Descrição da imagem do thumbnail 1",
        "texto": "Texto do thumbnail 1",
        "cores": "Cores recomendadas para o thumbnail 1"
      },
      {
        "imagem": "Descrição da imagem do thumbnail 2",
        "texto": "Texto do thumbnail 2",
        "cores": "Cores recomendadas para o thumbnail 2"
      },
      {
        "imagem": "Descrição da imagem do thumbnail 3",
        "texto": "Texto do thumbnail 3",
        "cores": "Cores recomendadas para o thumbnail 3"
      },
      {
        "imagem": "Descrição da imagem do thumbnail 4",
        "texto": "Texto do thumbnail 4",
        "cores": "Cores recomendadas para o thumbnail 4"
      }
    ]
  }
}

Responda APENAS com o JSON, sem texto adicional antes ou depois.
`;

        const response = await callLaozhangAPI(
            prompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_niche_find_subniche',
            JSON.stringify({ endpoint: '/api/niche/find-subniche/laozhang', model: laozhangModel })
        );

        // Tentar extrair JSON da resposta
        let recommendation = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        // Tentar parsear JSON se a resposta contém JSON
        try {
            const jsonMatch = recommendation.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                recommendation = parsed;
            }
        } catch (e) {
            console.warn('[Find Subniche] Falha ao parsear JSON, retornando texto:', e.message);
        }
        
        res.status(200).json({ recommendation: recommendation });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/niche/find-subniche/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});

app.post('/api/niche/analyze-competitor', authenticateToken, async (req, res) => {
    const { competitorUrl, model } = req.body;
    const userId = req.user.id;

    if (!competitorUrl || !model) {
        return res.status(400).json({ msg: 'URL do canal e modelo de IA são obrigatórios.' });
    }

    try {
        // 1. Obter chaves de API
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        if (!geminiKeyData) return res.status(400).json({ msg: 'Chave de API do Gemini é necessária para buscar dados do YouTube.' });
        const geminiApiKey = decrypt(geminiKeyData.api_key);
        if (!geminiApiKey) return res.status(500).json({ msg: 'Falha ao desencriptar a chave do Gemini.' });

        // 2. Obter ID do canal a partir da URL
        const match = competitorUrl.match(/youtube\.com\/(?:@([\w.-]+)|channel\/([\w-]+))/);
        if (!match) return res.status(400).json({ msg: 'Formato de URL do canal não suportado.' });
        
        let ytChannelId;
        const handle = match[1];
        const legacyId = match[2];

        if (handle) {
            const searchApiUrl = `https://www.googleapis.com/youtube/v3/search?part=id&q=${handle}&type=channel&maxResults=1&key=${geminiApiKey}`;
            const searchResponse = await fetch(searchApiUrl);
            const searchData = await searchResponse.json();
            if (!searchResponse.ok || !searchData.items || searchData.items.length === 0) {
                throw new Error(`Não foi possível encontrar o canal para o handle: @${handle}.`);
            }
            ytChannelId = searchData.items[0].id.channelId;
        } else {
            ytChannelId = legacyId;
        }
        if (!ytChannelId) throw new Error('Não foi possível determinar o ID do canal.');

        // 3. Buscar vídeos do canal
        const [popularVideos, latestVideos] = await Promise.all([
            getChannelVideosWithDetails(ytChannelId, geminiApiKey, 'viewCount', 10),
            getChannelVideosWithDetails(ytChannelId, geminiApiKey, 'date', 10)
        ]);

        let videoDataForPrompt = "Lista de vídeos publicados pelo canal:\n\n";
        videoDataForPrompt += "--- VÍDEOS MAIS POPULARES ---\n";
        popularVideos.forEach(v => {
            videoDataForPrompt += `- Título: "${v.title}", Visualizações: ${v.views}, Publicado há: ${v.days} dias\n`;
        });
        videoDataForPrompt += "\n--- VÍDEOS MAIS RECENTES ---\n";
        latestVideos.forEach(v => {
            videoDataForPrompt += `- Título: "${v.title}", Visualizações: ${v.views}, Publicado há: ${v.days} dias\n`;
        });

        // 4. Construir o PROMPT 2 (OTIMIZADO PARA CRIAR CANAIS MILIONÁRIOS)
        const prompt = `
            Você é um ESPECIALISTA EM CRIAÇÃO DE CANAIS MILIONÁRIOS NO YOUTUBE com experiência em analisar canais de sucesso e criar estratégias vencedoras.
            
            OBJETIVO: Analisar um canal de sucesso no YouTube e usar essa análise como base para criar um canal MILIONÁRIO com MILHÕES DE VIEWS e ALTO CTR dentro do mesmo nicho.
            
            PROMPT 2 - ANÁLISE DE CANAL COMPETIDOR:
            Preciso da sua ajuda para analisar um canal de sucesso no YouTube e usar essa análise como base para a criação do meu próprio canal dentro do mesmo nicho.
            
            Vou te fornecer as seguintes informações:
            ${videoDataForPrompt}
            
            Com base nesses dados, preciso que você faça uma ANÁLISE PROFUNDA E ESTRATÉGICA e me responda com:
            
            1. **Análise de Nicho e Subnicho:**
               - Qual é o nicho exato desse canal e seu subnicho (se houver)?
               - Por que esse nicho/subnicho funcionou tão bem?
               - Há oportunidades de subnichos pouco explorados com alto potencial de viralização?
            
            2. **Diferenciais de Sucesso:**
               - Quais são os principais diferenciais que tornam esse canal bem-sucedido?
               - O que faz esse canal gerar milhões de views?
               - Quais são os elementos únicos que criam alta taxa de engajamento?
            
            3. **Público-Alvo:**
               - Qual é o público-alvo (perfil demográfico, interesses, comportamento)?
               - Que tipo de conteúdo esse público consome?
               - Quais são as necessidades e desejos não atendidos desse público?
            
            4. **Estratégias de Conteúdo Virais:**
               - Quais estratégias de conteúdo parecem ser as mais eficazes (tipo de vídeo, frequência, estilo de narrativa, títulos, miniaturas, SEO)?
               - Quais padrões ou formatos se repetem nos vídeos de maior sucesso?
               - O que faz os vídeos terem alto CTR e gerarem milhões de views?
               - Quais são as fórmulas de títulos e thumbnails que funcionaram?
            
            5. **Análise de Oportunidades:**
               - Há algo nos comentários que revele desejos ou insatisfações da audiência que eu possa usar como oportunidade? (Simule uma análise de sentimentos com base nos títulos e views)
               - Quais são as oportunidades que eu posso explorar para criar um canal similar, porém com diferenciais competitivos?
               - Como posso criar conteúdo que viralize e gere milhões de views?
            
            6. **Orientação Estratégica para Criar Canal Milionário:**
               - Como devo estruturar o conteúdo do meu canal para gerar milhões de views?
               - Qual linha editorial devo seguir para alto CTR e viralização?
               - Sugestões de nome de canal, temas iniciais e identidade visual que atraiam milhões de views
               - Ideias de roteiros para os primeiros vídeos, baseados no que mais funciona no canal analisado
               - Estratégias para criar títulos e thumbnails que gerem alto CTR (acima de 25%)
               - Como criar conteúdo que viralize e gere engajamento massivo
            
            FOCO: Criar um canal MILIONÁRIO com MILHÕES DE VIEWS, ALTO CTR (acima de 25%), e conteúdo que VIRALIZE.
            
            Analise tudo com atenção e me dê uma resposta estratégica e prática, voltada para resultados e criação de canais milionários, em formato JSON. O JSON deve ter chaves como "analise_nicho", "diferenciais_sucesso", "publico_alvo", "estrategias_conteudo", "padroes_videos", "analise_comentarios", "oportunidades_explorar", e "orientacoes_finais" (que por sua vez contém "estrutura_conteudo", "linha_editorial", "sugestoes_branding", "ideias_roteiros", "estrategias_viralizacao", "titulos_ctr_alto", "thumbnails_virais").
        `;

        // 5. Chamar a IA - Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem plano que permite API própria OU não tem API própria configurada
        // REGRA CRÍTICA: Se preferência NÃO está marcada E usuário tem plano que permite E tem API própria → usar API própria
        let useLaozhang = false;
        let apiKeyToUse = null;
        let serviceToUse = null;
        let apiCallFunction = null;
        
        try {
            // Determinar ordem de preferência baseado no modelo
            let preferenceOrder = ['claude', 'openai', 'gemini'];
            if (model.startsWith('gemini')) preferenceOrder = ['gemini', 'claude', 'openai'];
            else if (model.startsWith('claude')) preferenceOrder = ['claude', 'openai', 'gemini'];
            else if (model.startsWith('gpt')) preferenceOrder = ['openai', 'claude', 'gemini'];
            
            const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
            
            if (creditsCheck.shouldUse) {
                // Se deve usar créditos, usar laozhang.ai
                const laozhangKey = await getLaozhangApiKey();
                if (laozhangKey) {
                    useLaozhang = true;
                    apiKeyToUse = laozhangKey;
                    serviceToUse = 'laozhang';
                    apiCallFunction = callLaozhangAPI;
                    console.log(`[Analyze Competitor] ✅ Usando Laozhang.ai (${creditsCheck.reason})`);
                } else {
                    console.warn('[Analyze Competitor] ⚠️ Laozhang.ai não configurada, tentando usar APIs próprias do usuário');
                }
            } else {
                console.log(`[Analyze Competitor] ✅ Usando API própria (${creditsCheck.reason})`);
            }
        } catch (err) {
            console.warn('[Analyze Competitor] Erro ao verificar uso de créditos:', err.message);
        }
        
        // Se não usar laozhang.ai, usar APIs próprias do usuário
        if (!useLaozhang) {
            let service;
            if (model.startsWith('gemini')) service = 'gemini';
            else if (model.startsWith('claude')) service = 'claude';
            else if (model.startsWith('gpt')) service = 'openai';
            else return res.status(400).json({ msg: 'Modelo de IA inválido.' });
            
            serviceToUse = service;
            
            const userKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (!userKeyData) return res.status(400).json({ msg: `Nenhuma Chave de API do ${service} configurada.` });
            
            apiKeyToUse = decrypt(userKeyData.api_key);
            if (!apiKeyToUse) return res.status(500).json({ msg: 'Falha ao desencriptar a sua chave de API.' });

            if (service === 'gemini') apiCallFunction = callGeminiAPI;
            else if (service === 'claude') apiCallFunction = callClaudeAPI;
            else apiCallFunction = callOpenAIAPI;
        }
        
        // Chamar API apropriada
        let response;
        if (useLaozhang) {
            response = await callLaozhangAPI(
                prompt, 
                apiKeyToUse, 
                model, 
                null, 
                userId, 
                '/api/niche/analyze-competitor', 
                JSON.stringify({ endpoint: '/api/niche/analyze-competitor', model })
            );
            // callLaozhangAPI retorna string diretamente
            response = typeof response === 'string' ? response.trim() : JSON.stringify(response);
            response = { titles: response };
        } else {
            response = await apiCallFunction(prompt, apiKeyToUse, model);
        }
        
        const analysis = parseAIResponse(response.titles, serviceToUse);

        res.status(200).json(analysis);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/niche/analyze-competitor]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});

// === ROTA LAOZHANG PARA ANÁLISE DE CONCORRENTES ===
app.post('/api/niche/analyze-competitor/laozhang', authenticateToken, async (req, res) => {
    const { competitorUrl, selectedModel } = req.body;
    const userId = req.user.id;

    if (!competitorUrl) {
        return res.status(400).json({ msg: 'URL do canal é obrigatória.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Buscar chave do Gemini/YouTube para buscar dados do canal
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        
        let apiKey = null;
        if (youtubeKeyData) {
            apiKey = youtubeKeyData.api_key.includes(':') ? decrypt(youtubeKeyData.api_key) : youtubeKeyData.api_key;
        } else if (geminiKeyData) {
            apiKey = geminiKeyData.api_key.includes(':') ? decrypt(geminiKeyData.api_key) : geminiKeyData.api_key;
        }
        
        if (!apiKey) {
            return res.status(400).json({ msg: 'Chave de API do YouTube ou Gemini é necessária para buscar dados do canal.' });
        }

        // Obter ID do canal (mesma lógica da rota original)
        const match = competitorUrl.match(/youtube\.com\/(?:@([\w.-]+)|channel\/([\w-]+))/);
        if (!match) return res.status(400).json({ msg: 'Formato de URL do canal não suportado.' });
        
        let ytChannelId;
        const handle = match[1];
        const legacyId = match[2];

        if (handle) {
            const searchApiUrl = `https://www.googleapis.com/youtube/v3/search?part=id&q=${handle}&type=channel&maxResults=1&key=${apiKey}`;
            const searchResponse = await fetch(searchApiUrl);
            const searchData = await searchResponse.json();
            if (searchResponse.ok && searchData.items && searchData.items.length > 0) {
                ytChannelId = searchData.items[0].id.channelId;
            }
        }

        if (!ytChannelId && legacyId) {
            ytChannelId = legacyId;
        }

        if (!ytChannelId) {
            return res.status(400).json({ msg: 'Não foi possível identificar o canal a partir da URL fornecida.' });
        }

        // Buscar dados do canal e vídeos (mesma lógica da rota original, simplificada)
        const channelUrl = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${ytChannelId}&key=${apiKey}`;
        const channelResponse = await fetch(channelUrl);
        const channelData = await channelResponse.json();

        if (!channelResponse.ok || !channelData.items || channelData.items.length === 0) {
            return res.status(400).json({ msg: 'Canal não encontrado.' });
        }

        const channel = channelData.items[0];
        const competitorData = await getChannelVideosWithDetails(ytChannelId, apiKey, 'viewCount', 5);

        // Criar prompt para análise - usar GPT-4o como padrão se não houver modelo selecionado
        const laozhangModel = selectedModel === 'Claude 3.7 Sonnet (Fev/25)' ? 'claude-3-7-sonnet-20250219' :
                             selectedModel === 'Gemini 2.5 Pro (2025)' ? 'gemini-2.5-pro' :
                             selectedModel && selectedModel.trim() ? selectedModel : 'gpt-4o';

        const prompt = `
Você é um ESPECIALISTA EM CRIAÇÃO DE CANAIS MILIONÁRIOS NO YOUTUBE.

OBJETIVO: Analisar um canal concorrente de sucesso e fornecer um plano estratégico completo para criar um canal milionário no mesmo nicho.

DADOS DO CANAL ANALISADO:
- NOME: ${channel.snippet.title}
- DESCRIÇÃO: ${channel.snippet.description || 'N/A'}
- INSCRITOS: ${channel.statistics.subscriberCount || 'N/A'}
- TOTAL DE VÍDEOS: ${channel.statistics.videoCount || 'N/A'}
- TOTAL DE VIEWS: ${channel.statistics.viewCount || 'N/A'}

VÍDEOS MAIS POPULARES:
${competitorData.map((v, i) => `${i + 1}. "${v.title}" - ${v.views.toLocaleString('pt-BR')} visualizações`).join('\n')}

IMPORTANTE: Responda APENAS com um JSON válido no seguinte formato (sem texto adicional antes ou depois):

{
  "content_strategies": {
    "overview": "Visão geral das estratégias de conteúdo que fazem este canal ter sucesso",
    "playlist_strategy": "Estratégia de playlists e organização de conteúdo (se aplicável)",
    "storytelling": "Técnicas de storytelling e narrativa utilizadas",
    "engagement_tactics": "Táticas de engajamento que geram milhões de views"
  },
  "title_and_thumbnail_patterns": {
    "title_patterns": "Padrões identificados nos títulos que geram alto CTR e milhões de views",
    "thumbnail_patterns": "Padrões visuais e elementos que aparecem nos thumbnails de sucesso"
  },
  "posting_frequency": {
    "current_frequency": "Análise da frequência atual de postagem do canal",
    "recommendation": "Recomendação de frequência ideal para maximizar views e engajamento"
  },
  "niche_and_subniches": {
    "primary_niche": "Nicho principal identificado",
    "subniches": [
      "Subnicho 1 explorado",
      "Subnicho 2 explorado",
      "Subnicho 3 explorado"
    ]
  },
  "differentiation_opportunities": {
    "live_interactions": "Oportunidades de interação ao vivo que podem diferenciar seu canal",
    "exclusive_interviews": "Oportunidades de entrevistas exclusivas ou conteúdo único",
    "collaborations": "Estratégias de colaboração para aumentar alcance",
    "content_gaps": "Lacunas de conteúdo identificadas que você pode explorar",
    "unique_angles": "Ângulos únicos que você pode usar para se diferenciar"
  },
  "strategic_recommendations": {
    "channel_name_suggestions": [
      "Sugestão de nome 1",
      "Sugestão de nome 2",
      "Sugestão de nome 3"
    ],
    "first_videos_ideas": [
      "Ideia de vídeo inicial 1",
      "Ideia de vídeo inicial 2",
      "Ideia de vídeo inicial 3"
    ],
    "growth_strategy": "Estratégia completa de crescimento para alcançar milhões de views",
    "monetization_opportunities": "Oportunidades de monetização específicas para este nicho"
  }
}

Responda APENAS com o JSON, sem texto adicional antes ou depois.
`;

        const response = await callLaozhangAPI(
            prompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_niche_analyze_competitor',
            JSON.stringify({ endpoint: '/api/niche/analyze-competitor/laozhang', model: laozhangModel })
        );

        // Tentar extrair JSON da resposta
        let analysis = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        // Tentar parsear JSON se a resposta contém JSON
        try {
            const jsonMatch = analysis.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                analysis = parsed;
            }
        } catch (e) {
            console.warn('[Analyze Competitor] Falha ao parsear JSON, retornando texto:', e.message);
        }
        
        res.status(200).json(analysis);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/niche/analyze-competitor/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});


// === ROTAS DE ADMIN ===

app.get('/api/admin/stats', authenticateToken, isAdmin, async (req, res) => {
    try {
        const totalUsers = await db.get('SELECT COUNT(*) as count FROM users');
        const pendingUsers = await db.get('SELECT COUNT(*) as count FROM users WHERE isApproved = 0');
        const onlineUsers = await db.get("SELECT COUNT(*) as count FROM users WHERE last_login_at > datetime('now', '-15 minutes')");
        const logins24h = await db.get("SELECT COUNT(*) as count FROM users WHERE last_login_at > datetime('now', '-24 hours')");

        res.json({
            totalUsers: totalUsers.count,
            pendingUsers: pendingUsers.count,
            onlineUsers: onlineUsers.count,
            logins24h: logins24h.count
        });
    } catch (err) {
        console.error('Erro ao buscar estatísticas admin:', err);
        res.status(500).json({ msg: 'Erro ao buscar estatísticas.' });
    }
});

app.get('/api/admin/users', authenticateToken, isAdmin, async (req, res) => {
    const { search, status } = req.query;
    try {
        let query = 'SELECT id, name, email, whatsapp, isAdmin, isBlocked, isApproved, plan, subscription_plan, created_at FROM users';
        const params = [];
        const conditions = [];

        if (search) {
            conditions.push('(email LIKE ? OR whatsapp LIKE ? OR name LIKE ?)');
            params.push(`%${search}%`, `%${search}%`, `%${search}%`);
        }

        if (status) {
            if (status === 'pending') conditions.push('isApproved = 0');
            if (status === 'active') conditions.push('isApproved = 1 AND isBlocked = 0');
            if (status === 'blocked') conditions.push('isBlocked = 1');
        }

        if (conditions.length > 0) {
            query += ' WHERE ' + conditions.join(' AND ');
        }
        
        const users = await db.all(query, params);
        res.json(users);
    } catch (err) {
        console.error('Erro ao buscar utilizadores admin:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

app.post('/api/admin/users/approve-all', authenticateToken, isAdmin, async (req, res) => {
    try {
        await db.run('UPDATE users SET isApproved = 1 WHERE isApproved = 0');
        res.status(200).json({ msg: 'Todos os utilizadores pendentes foram aprovados.' });
    } catch (err) {
        console.error('Erro ao aprovar todos os utilizadores:', err);
        res.status(500).json({ msg: 'Erro ao aprovar utilizadores.' });
    }
});

app.put('/api/admin/users/:id', authenticateToken, isAdmin, async (req, res) => {
    const { id } = req.params;
    const { name, whatsapp, isAdmin, isBlocked, isApproved } = req.body;
    try {
        await db.run('UPDATE users SET name = ?, whatsapp = ?, isAdmin = ?, isBlocked = ?, isApproved = ? WHERE id = ?', [name, whatsapp, isAdmin, isBlocked, isApproved, id]);
        res.status(200).json({ msg: 'Utilizador atualizado com sucesso.' });
    } catch (err) {
        res.status(500).json({ msg: 'Erro ao atualizar utilizador.' });
    }
});

app.put('/api/admin/users/:id/password', authenticateToken, isAdmin, async (req, res) => {
    const { id } = req.params;
    const { password } = req.body;
    if (!password || password.length < 6) {
        return res.status(400).json({ msg: 'A senha deve ter pelo menos 6 caracteres.' });
    }
    try {
        // Obter dados do usuário antes de atualizar
        const userData = await db.get('SELECT name, email FROM users WHERE id = ?', [id]);
        if (!userData) {
            return res.status(404).json({ msg: 'Usuário não encontrado.' });
        }
        
        const salt = await bcrypt.genSalt(10);
        const password_hash = await bcrypt.hash(password, salt);
        await db.run('UPDATE users SET password_hash = ? WHERE id = ?', [password_hash, id]);
        
        // Enviar email de senha provisória
        try {
            const protocol = req.protocol;
            const host = req.get('host');
            const loginUrl = `${protocol}://${host}/la-casa-dark-core-auth.html`;
            
            await sendTemplateEmail('password_reset', userData.email, {
                nome: userData.name,
                email: userData.email,
                senha_provisoria: password,
                link_acesso: loginUrl
            });
        } catch (emailError) {
            console.error('[EMAIL] Erro ao enviar email de senha provisória:', emailError.message);
            // Não falhar a operação se o email falhar
        }
        
        res.status(200).json({ msg: 'Senha atualizada com sucesso e email enviado.' });
    } catch (err) {
        res.status(500).json({ msg: 'Erro ao atualizar a senha.' });
    }
});

// Função para adicionar créditos automáticos baseado no plano
async function addPlanCredits(userId, planName, isRenewal = false) {
    try {
        // Obter créditos do plano
        const planCredits = await db.get('SELECT monthly_credits FROM plan_credits WHERE plan_name = ?', [planName]);
        if (!planCredits) {
            console.warn(`[PLAN CREDITS] Plano ${planName} não encontrado na tabela plan_credits`);
            return;
        }
        
        const creditsToAdd = planCredits.monthly_credits;
        if (creditsToAdd <= 0) return;
        
        // Verificar se usuário já tem créditos
        let userCredits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [userId]);
        
        if (!userCredits) {
            // Criar registro de créditos
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, ?)', [userId, creditsToAdd]);
        } else {
            // Adicionar créditos
            await db.run(
                'UPDATE user_credits SET balance = balance + ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?',
                [creditsToAdd, userId]
            );
        }
        
        // Registrar transação
        await db.run(`
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description)
            VALUES (?, ?, 'credit', ?)
        `, [userId, creditsToAdd, isRenewal ? `Renovação mensal de créditos - Plano ${planName}` : `Créditos iniciais - Plano ${planName}`]);
        
        // Registrar renovação
        const isAnnual = planName.includes('annual');
        const nextRenewal = new Date();
        nextRenewal.setMonth(nextRenewal.getMonth() + 1);
        
        await db.run(`
            INSERT INTO credit_renewals (user_id, plan_name, credits_added, renewal_date, next_renewal_date, is_annual)
            VALUES (?, ?, ?, CURRENT_TIMESTAMP, ?, ?)
        `, [userId, planName, creditsToAdd, nextRenewal.toISOString(), isAnnual ? 1 : 0]);
        
        console.log(`[PLAN CREDITS] ${creditsToAdd} créditos adicionados ao usuário ${userId} (Plano: ${planName})`);
    } catch (error) {
        console.error('[PLAN CREDITS] Erro ao adicionar créditos:', error);
    }
}

// Função para verificar e renovar créditos mensalmente
async function checkAndRenewCredits() {
    try {
        // Buscar usuários com planos ativos que precisam renovar
        const usersToRenew = await db.all(`
            SELECT u.id, u.subscription_plan, u.plan, cr.next_renewal_date
            FROM users u
            LEFT JOIN credit_renewals cr ON u.id = cr.user_id
            WHERE (u.subscription_plan IS NOT NULL AND u.subscription_plan != 'plan-free')
               OR (u.plan IS NOT NULL AND u.plan != 'plan-free')
            GROUP BY u.id
            HAVING MAX(cr.next_renewal_date) < datetime('now')
               OR MAX(cr.next_renewal_date) IS NULL
        `);
        
        for (const user of usersToRenew) {
            const planName = user.subscription_plan || user.plan;
            if (planName && planName !== 'plan-free') {
                await addPlanCredits(user.id, planName, true);
            }
        }
        
        console.log(`[PLAN CREDITS] Verificação de renovação concluída. ${usersToRenew.length} usuários processados.`);
    } catch (error) {
        console.error('[PLAN CREDITS] Erro ao verificar renovações:', error);
    }
}

// Executar verificação de renovação a cada hora
setInterval(checkAndRenewCredits, 60 * 60 * 1000); // 1 hora

// PUT /api/admin/users/:id/plan - Alterar plano do usuário
app.put('/api/admin/users/:id/plan', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.id);
        const { plan } = req.body;
        
        if (!plan) {
            return res.status(400).json({ message: 'Plano é obrigatório' });
        }
        
        const validPlans = ['plan-free', 'plan-start', 'plan-turbo', 'plan-master', 'plan-start-annual', 'plan-turbo-annual', 'plan-master-annual'];
        if (!validPlans.includes(plan)) {
            return res.status(400).json({ message: 'Plano inválido' });
        }
        
        const user = await db.get('SELECT id, email FROM users WHERE id = ?', [userId]);
        if (!user) {
            return res.status(404).json({ message: 'Usuário não encontrado' });
        }
        
        // Atualizar plano
        await db.run('UPDATE users SET subscription_plan = ?, plan = ? WHERE id = ?', [plan, plan, userId]);
        
        // Adicionar créditos automáticos se não for plano free
        if (plan !== 'plan-free') {
            await addPlanCredits(userId, plan, false);
        }
        
        res.json({ 
            message: 'Plano alterado com sucesso',
            plan: plan
        });
    } catch (error) {
        console.error('Erro ao alterar plano:', error);
        res.status(500).json({ message: 'Erro ao alterar plano' });
    }
});

app.put('/api/admin/users/:id/status', authenticateToken, isAdmin, async (req, res) => {
    const { id } = req.params;
    const { isBlocked } = req.body;
    try {
        await db.run('UPDATE users SET isBlocked = ? WHERE id = ?', [isBlocked, id]);
        res.status(200).json({ msg: `Utilizador ${isBlocked ? 'bloqueado' : 'desbloqueado'} com sucesso.` });
    } catch (err) {
        res.status(500).json({ msg: 'Erro ao alterar o status do utilizador.' });
    }
});

app.delete('/api/admin/users/:id', authenticateToken, isAdmin, async (req, res) => {
    const { id } = req.params;
    if (parseInt(id, 10) === req.user.id) {
        return res.status(400).json({ msg: 'Não pode excluir a sua própria conta de administrador.' });
    }
    try {
        await db.run('DELETE FROM users WHERE id = ?', [id]);
        res.status(200).json({ msg: 'Utilizador excluído com sucesso.' });
    } catch (err) {
        res.status(500).json({ msg: 'Erro ao excluir utilizador.' });
    }
});


// === ROTAS DE PASTAS E HISTÓRICO ===

app.post('/api/folders', authenticateToken, async (req, res) => {
    const { name } = req.body;
    const userId = req.user.id;

    if (!name) {
        return res.status(400).json({ msg: 'O nome da pasta é obrigatório.' });
    }
    try {
        const result = await db.run(
            'INSERT INTO analysis_folders (user_id, name) VALUES (?, ?)',
            [userId, name]
        );
        res.status(201).json({ id: result.lastID, name });
    } catch (err) {
        console.error('Erro ao criar pasta:', err);
        res.status(500).json({ msg: 'Erro no servidor ao criar pasta.' });
    }
});

app.get('/api/folders', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    try {
        const folders = await db.all('SELECT id, name FROM analysis_folders WHERE user_id = ? ORDER BY name', [userId]);
        res.status(200).json(folders);
    } catch (err) {
        console.error('Erro ao listar pastas:', err);
        res.status(500).json({ msg: 'Erro no servidor ao listar pastas.' });
    }
});

app.delete('/api/folders/:folderId', authenticateToken, async (req, res) => {
    const { folderId } = req.params;
    const userId = req.user.id;
    try {
        const result = await db.run(
            'DELETE FROM analysis_folders WHERE id = ? AND user_id = ?',
            [folderId, userId]
        );
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Pasta não encontrada ou não pertence a este utilizador.' });
        }
        res.status(200).json({ msg: 'Pasta excluída com sucesso. As análises foram movidas para o Histórico Geral.' });
    } catch (err) {
        console.error('Erro ao excluir pasta:', err);
        res.status(500).json({ msg: 'Erro no servidor ao excluir pasta.' });
    }
});
app.get('/api/history', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { folderId, page = 1, limit = 50, search, niche, dateFilter } = req.query;
    
    try {
        const pageNum = parseInt(page) || 1;
        const limitNum = parseInt(limit) || 50;
        const offset = (pageNum - 1) * limitNum;
        
        let baseWhere = 'user_id = ?';
        let params = [userId];
        let countParams = [userId];
        
        if (folderId) {
            baseWhere += ' AND folder_id = ?';
            params.push(folderId);
            countParams.push(folderId);
        } else {
            baseWhere += ' AND folder_id IS NULL';
        }
        
        // Filtro de busca
        if (search) {
            baseWhere += ' AND original_title LIKE ?';
            params.push(`%${search}%`);
            countParams.push(`%${search}%`);
        }
        
        // Filtro de nicho
        if (niche) {
            baseWhere += ' AND detected_subniche LIKE ?';
            params.push(`%${niche}%`);
            countParams.push(`%${niche}%`);
        }
        
        // Filtro de data
        if (dateFilter) {
            const now = new Date();
            let dateStart;
            switch (dateFilter) {
                case 'today':
                    dateStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    break;
                case 'week':
                    dateStart = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    break;
                case 'month':
                    dateStart = new Date(now.getFullYear(), now.getMonth(), 1);
                    break;
                case 'year':
                    dateStart = new Date(now.getFullYear(), 0, 1);
                    break;
            }
            if (dateStart) {
                baseWhere += ' AND analyzed_at >= ?';
                params.push(dateStart.toISOString());
                countParams.push(dateStart.toISOString());
            }
        }
        
        let query = `SELECT id, original_title, detected_subniche, analyzed_at FROM analyzed_videos WHERE ${baseWhere} ORDER BY analyzed_at DESC LIMIT ? OFFSET ?`;
        params.push(limitNum, offset);
        
        let countQuery = `SELECT COUNT(*) as total FROM analyzed_videos WHERE ${baseWhere}`;
        
        const [history, totalResult] = await Promise.all([
            db.all(query, params),
            db.get(countQuery, countParams)
        ]);
        
        // Garantir que history é sempre um array
        const historyArray = Array.isArray(history) ? history : [];
        
        const total = totalResult?.total || 0;
        const totalPages = Math.ceil(total / limitNum);
        
        res.status(200).json({
            data: historyArray,
            pagination: {
                page: pageNum,
                limit: limitNum,
                total: total,
                totalPages: totalPages,
                hasNext: pageNum < totalPages,
                hasPrev: pageNum > 1
            }
        });
        
    } catch (err) {
        console.error('Erro ao listar histórico:', err);
        res.status(500).json({ msg: 'Erro no servidor ao listar histórico.' });
    }
});

app.delete('/api/history', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { ids } = req.body;

    if (!ids || !Array.isArray(ids) || ids.length === 0) {
        return res.status(400).json({ msg: 'Nenhum ID de análise fornecido.' });
    }

    try {
        const placeholders = ids.map(() => '?').join(',');
        const result = await db.run(
            `DELETE FROM analyzed_videos WHERE id IN (${placeholders}) AND user_id = ?`,
            [...ids, userId]
        );
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Nenhuma análise encontrada ou não pertence a este utilizador.' });
        }
        
        res.status(200).json({ msg: `${result.changes} análise(s) excluída(s) com sucesso.` });
        
    } catch (err) {
        console.error('Erro ao excluir análises:', err);
        res.status(500).json({ msg: 'Erro no servidor ao excluir análises.' });
    }
});

// Rota para buscar nichos únicos do histórico
app.get('/api/history/niches', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const niches = await db.all(
            `SELECT DISTINCT detected_subniche as niche 
             FROM analyzed_videos 
             WHERE user_id = ? AND detected_subniche IS NOT NULL AND detected_subniche != '' 
             ORDER BY detected_subniche`,
            [userId]
        );

        const nichesArray = niches.map(row => row.niche).filter(Boolean);
        res.status(200).json({ niches: nichesArray });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/history/niches]:', err);
        res.status(500).json({ msg: 'Erro ao buscar nichos.' });
    }
});

app.get('/api/history/load/:analysisId', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { analysisId } = req.params;

    try {
        const analysis = await db.get(
            'SELECT * FROM analyzed_videos WHERE id = ? AND user_id = ?',
            [analysisId, userId]
        );
        if (!analysis) return res.status(404).json({ msg: 'Análise não encontrada.' });

        // Primeiro, verificar quantos títulos existem no total
        const totalCount = await db.get(
            'SELECT COUNT(*) as total FROM generated_titles WHERE video_analysis_id = ?',
            [analysisId]
        );
        console.log(`[Histórico] Total de títulos no banco para análise ${analysisId}: ${totalCount?.total || 0}`);
        
        const titles = await db.all(
            'SELECT id, title_text as titulo, model_used as model, pontuacao, impact_score, explicacao, formula, is_checked FROM generated_titles WHERE video_analysis_id = ? ORDER BY id ASC',
            [analysisId]
        );
        
        // Log para debug: verificar quantos títulos foram carregados e de quais modelos
        console.log(`[Histórico] Carregando análise ${analysisId}: ${titles.length} títulos encontrados (esperado: ${totalCount?.total || 0})`);
        const titlesByModel = {};
        titles.forEach(t => {
            const model = t.model || 'Desconhecido';
            titlesByModel[model] = (titlesByModel[model] || 0) + 1;
        });
        console.log(`[Histórico] Títulos por modelo:`, titlesByModel);
        
        // Se houver discrepância, logar detalhes
        if (titles.length !== (totalCount?.total || 0)) {
            console.error(`[Histórico] ⚠️ DISCREPÂNCIA: ${titles.length} títulos carregados, mas ${totalCount?.total || 0} existem no banco!`);
        }

        // Calcular receita e RPM baseado no nicho
        const rpm = getRPMByNiche(analysis.detected_niche);
        const views = parseInt(analysis.original_views) || 0;
        const estimatedRevenueUSD = (views / 1000) * rpm.usd;
        const estimatedRevenueBRL = (views / 1000) * rpm.brl;

        // Garantir que analiseOriginal sempre tenha dados válidos
        let analiseOriginal;
        try {
            analiseOriginal = JSON.parse(analysis.analysis_data_json || '{}');
            // Se o JSON estiver vazio ou não tiver os campos necessários, gerar novamente
            if (!analiseOriginal.motivoSucesso || !analiseOriginal.formulaTitulo) {
                console.log(`[Histórico] analysis_data_json vazio ou inválido para análise ${analysisId}, gerando novamente...`);
                analiseOriginal = deriveTitleAnalysis({
                    originalTitle: analysis.original_title,
                    translatedTitle: analysis.translated_title,
                    views: analysis.original_views,
                    days: analysis.original_days
                });
            }
        } catch (err) {
            console.warn(`[Histórico] Erro ao parsear analysis_data_json para análise ${analysisId}, gerando novamente:`, err.message);
            analiseOriginal = deriveTitleAnalysis({
                originalTitle: analysis.original_title,
                translatedTitle: analysis.translated_title,
                views: analysis.original_views,
                days: analysis.original_days
            });
        }

        const responseData = {
            niche: analysis.detected_niche || 'N/A',
            subniche: analysis.detected_subniche || 'N/A',
            analiseOriginal: analiseOriginal,
            titulosSugeridos: titles,
            modelUsed: titles.length > 0 ? titles[0].model : 'Carregado',
            videoDetails: {
                title: analysis.original_title,
                translatedTitle: analysis.translated_title || null,
                views: views,
                comments: analysis.original_comments,
                days: analysis.original_days,
                thumbnailUrl: analysis.original_thumbnail_url,
                videoId: analysis.youtube_video_id,
                estimatedRevenueUSD: estimatedRevenueUSD,
                estimatedRevenueBRL: estimatedRevenueBRL,
                rpmUSD: rpm.usd,
                rpmBRL: rpm.brl
            },
            originalVideoUrl: analysis.video_url 
        };
        res.status(200).json(responseData);

    } catch (err) {
        console.error('Erro ao carregar análise:', err);
        res.status(500).json({ msg: 'Erro no servidor ao carregar análise.' });
    }
});


// === ROTAS DE CANAIS MONITORADOS (para análise de canais) ===
app.post('/api/channels/monitor', authenticateToken, async (req, res) => {
    const { channelUrl, channelName } = req.body;
    const userId = req.user.id;

    if (!channelUrl || !channelName) {
        return res.status(400).json({ msg: 'Nome e URL do canal são obrigatórios.' });
    }

    try {
        // Verificar limite de 5 canais por usuário
        const channelCount = await db.get('SELECT COUNT(*) as count FROM monitored_channels WHERE user_id = ?', [userId]);
        if (channelCount && channelCount.count >= 5) {
            return res.status(400).json({ msg: 'Limite de 5 canais monitorados atingido. Exclua um canal antes de adicionar outro.' });
        }

        const result = await db.run(
            'INSERT INTO monitored_channels (user_id, channel_name, channel_url) VALUES (?, ?, ?)',
            [userId, channelName, channelUrl]
        );
        res.status(201).json({ id: result.lastID, channel_name: channelName, channel_url: channelUrl });
    } catch (err) {
        console.error('Erro ao adicionar canal:', err);
        if (err.message.includes('UNIQUE constraint failed')) {
            return res.status(400).json({ msg: 'Este canal já está sendo monitorado por você.' });
        }
        res.status(500).json({ msg: 'Erro no servidor ao adicionar canal.' });
    }
});

app.get('/api/channels/monitor', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    try {
        if (!db) {
            console.error('[Canais Monitorados] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }
        
        const channels = await db.all(
            'SELECT id, channel_name, channel_url, last_checked FROM monitored_channels WHERE user_id = ? ORDER BY channel_name',
            [userId]
        );
        
        console.log(`[Canais Monitorados] Encontrados ${channels.length} canais para usuário ${userId}`);
        res.status(200).json(channels || []);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/monitor]:', err);
        res.status(500).json({ msg: 'Erro no servidor ao listar canais.' });
    }
});

app.delete('/api/channels/monitor/:channelId', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { channelId } = req.params;

    try {
        const result = await db.run(
            'DELETE FROM monitored_channels WHERE id = ? AND user_id = ?',
            [channelId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Canal não encontrado ou não pertence a este utilizador.' });
        }
        
        res.status(200).json({ msg: 'Canal removido com sucesso.' });
    } catch (err) {
        console.error('Erro ao excluir canal:', err);
        res.status(500).json({ msg: 'Erro no servidor ao excluir canal.' });
    }
});

app.get('/api/channels/monitor/:channelId/check', authenticateToken, async (req, res) => {
    const { channelId } = req.params;
    const userId = req.user.id;
    try {
        const channel = await db.get('SELECT channel_url FROM monitored_channels WHERE id = ? AND user_id = ?', [channelId, userId]);
        if (!channel) {
            return res.status(404).json({ msg: 'Canal não encontrado.' });
        }

        // Buscar chave do YouTube primeiro, se não encontrar, usar Gemini como fallback
        let youtubeApiKey = null;
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData && youtubeKeyData.api_key) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
            if (!youtubeApiKey && youtubeKeyData.api_key && !youtubeKeyData.api_key.includes(':')) {
                youtubeApiKey = youtubeKeyData.api_key;
            }
        }
        
        // Se não encontrou chave do YouTube, tentar usar Gemini como fallback
        if (!youtubeApiKey) {
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData && geminiKeyData.api_key) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
                if (!youtubeApiKey && geminiKeyData.api_key && !geminiKeyData.api_key.includes(':')) {
                    youtubeApiKey = geminiKeyData.api_key;
                }
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ msg: 'Chave de API do YouTube ou Gemini é necessária para esta função. Configure uma delas nas configurações.' });
        }

        // Extrair ID do canal da URL (suporta múltiplos formatos)
        let ytChannelId = null;
        let channelUrl = channel.channel_url.trim();
        
        console.log(`[Canais Monitorados] Tentando extrair ID do canal da URL: ${channelUrl}`);
        
        // Se for URL de vídeo, extrair o canal do vídeo
        // Suporta múltiplos formatos: youtube.com/watch?v=, youtu.be/, youtube.com/embed/, etc.
        const videoMatch = channelUrl.match(/(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
        if (videoMatch) {
            try {
                const videoId = videoMatch[1];
                console.log(`[Canais Monitorados] URL de vídeo detectada, ID do vídeo: ${videoId}`);
                const videoUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${youtubeApiKey}`;
                const videoResponse = await fetch(videoUrl);
                const videoData = await videoResponse.json();
                
                if (!videoResponse.ok) {
                    console.error(`[Canais Monitorados] Erro na API do YouTube ao buscar vídeo: ${videoResponse.status}`, videoData);
                } else if (videoData.items && videoData.items.length > 0) {
                    ytChannelId = videoData.items[0].snippet.channelId;
                    console.log(`[Canais Monitorados] Canal ID extraído do vídeo: ${ytChannelId}`);
                } else {
                    console.warn(`[Canais Monitorados] Vídeo não encontrado na API do YouTube: ${videoId}`);
                }
            } catch (videoErr) {
                console.error('[Canais Monitorados] Erro ao extrair canal do vídeo:', videoErr);
            }
        } else {
            console.log(`[Canais Monitorados] URL não é de vídeo, tentando formatos de canal...`);
        }
        
        // Se não encontrou via vídeo, tentar formatos de canal
        if (!ytChannelId) {
            // Regex melhorada para capturar mais formatos, incluindo URLs truncadas
            // Suporta: @handle, /channel/ID, /c/ID, /user/ID, ou ID direto (UC...)
            let match = channelUrl.match(/youtube\.com\/(?:@([\w.-]+)|channel\/([\w-]+)|c\/([\w-]+)|user\/([\w-]+)|(?:embed\/)?([\w-]{24}))/);
            
            // Se não encontrou, tentar formatos alternativos
            if (!match) {
                // Tentar capturar handle mesmo em URLs truncadas ou sem domínio completo
                match = channelUrl.match(/@([\w.-]+)/);
                if (match) {
                    match = [null, match[1], null, null, null, null];
                }
                // Tentar capturar ID de canal direto (UC...)
                else if (channelUrl.match(/^UC[\w-]{22}$/)) {
                    match = [null, null, channelUrl, null, null, null];
                }
            }
            
            if (match) {
                const handle = match[1];
                const legacyId = match[2] || match[3] || match[4] || match[5];

                if (handle) {
                    try {
                        console.log(`[Canais Monitorados] Tentando buscar canal por handle: @${handle}`);
                        // Tentar buscar via channels.list primeiro (mais preciso)
                        const channelsApiUrl = `https://www.googleapis.com/youtube/v3/channels?part=id&forHandle=${encodeURIComponent(handle)}&key=${youtubeApiKey}`;
                        const channelsResponse = await fetch(channelsApiUrl);
                        const channelsData = await channelsResponse.json();
                        
                        if (channelsResponse.ok && channelsData.items && channelsData.items.length > 0) {
                            ytChannelId = channelsData.items[0].id;
                            console.log(`[Canais Monitorados] Canal ID encontrado via channels.list: ${ytChannelId}`);
                        } else {
                            // Fallback: usar search
                            console.log(`[Canais Monitorados] Tentando buscar via search como fallback`);
                            const searchApiUrl = `https://www.googleapis.com/youtube/v3/search?part=id,snippet&q=${encodeURIComponent('@' + handle)}&type=channel&maxResults=1&key=${youtubeApiKey}`;
                            const searchResponse = await fetch(searchApiUrl);
                            const searchData = await searchResponse.json();

                            if (searchResponse.ok && searchData.items && searchData.items.length > 0) {
                                ytChannelId = searchData.items[0].id.channelId;
                                console.log(`[Canais Monitorados] Canal ID encontrado via search: ${ytChannelId}`);
                            } else {
                                console.warn(`[Canais Monitorados] Nenhum canal encontrado para handle: @${handle}`);
                            }
                        }
                    } catch (searchErr) {
                        console.error(`[Canais Monitorados] Erro ao buscar canal por handle:`, searchErr);
                    }
                } else if (legacyId) {
                    // Tentar validar se é um ID de canal válido
                    console.log(`[Canais Monitorados] Tentando validar ID de canal: ${legacyId}`);
                    // IDs de canal do YouTube começam com UC e têm 24 caracteres
                    if (legacyId.length >= 24 || legacyId.startsWith('UC')) {
                        // Verificar se é um ID válido fazendo uma busca
                        try {
                            const validateUrl = `https://www.googleapis.com/youtube/v3/channels?part=id&id=${legacyId}&key=${youtubeApiKey}`;
                            const validateResponse = await fetch(validateUrl);
                            const validateData = await validateResponse.json();
                            
                            if (validateResponse.ok && validateData.items && validateData.items.length > 0) {
                                ytChannelId = legacyId;
                                console.log(`[Canais Monitorados] ID de canal validado: ${ytChannelId}`);
                            } else {
                                console.warn(`[Canais Monitorados] ID de canal não é válido: ${legacyId}`);
                            }
                        } catch (validateErr) {
                            console.error(`[Canais Monitorados] Erro ao validar ID:`, validateErr);
                        }
                    }
                }
            } else {
                console.warn(`[Canais Monitorados] Não foi possível fazer match da URL: ${channelUrl}`);
            }
        }

        if (!ytChannelId) {
            return res.status(400).json({ msg: 'Não foi possível determinar o ID do canal. Verifique se a URL está correta. Formatos suportados: @handle, /channel/ID, /c/ID, /user/ID, ou URL de vídeo.' });
        }

        // Fetch latest, popular, and pinned videos com tratamento de erro robusto
        let latestVideos = [];
        let popularVideos = [];
        let pinnedVideoIds = [];
        
        try {
            const results = await Promise.allSettled([
                getChannelVideosWithDetails(ytChannelId, youtubeApiKey, 'date', 5).catch(err => {
                    console.error('[Canais Monitorados] Erro ao buscar vídeos recentes:', err);
                    return [];
                }),
                getChannelVideosWithDetails(ytChannelId, youtubeApiKey, 'viewCount', 5).catch(err => {
                    console.error('[Canais Monitorados] Erro ao buscar vídeos populares:', err);
                    return [];
                }),
                db.all('SELECT id, youtube_video_id FROM pinned_videos WHERE user_id = ? AND monitored_channel_id = ? ORDER BY pinned_at DESC', [userId, channelId]).catch(err => {
                    console.error('[Canais Monitorados] Erro ao buscar vídeos fixados:', err);
                    return [];
                })
            ]);
            
            if (results[0].status === 'fulfilled') latestVideos = Array.isArray(results[0].value) ? results[0].value : [];
            if (results[1].status === 'fulfilled') popularVideos = Array.isArray(results[1].value) ? results[1].value : [];
            if (results[2].status === 'fulfilled') pinnedVideoIds = Array.isArray(results[2].value) ? results[2].value : [];
        } catch (fetchErr) {
            console.error('[Canais Monitorados] Erro ao buscar vídeos:', fetchErr);
            // Continuar com arrays vazios
        }

        let pinnedVideos = [];
        if (pinnedVideoIds.length > 0) {
            try {
                const idsToFetch = pinnedVideoIds.map(p => p.youtube_video_id).filter(id => id).join(',');
                if (!idsToFetch) {
                    console.warn('[Canais Monitorados] Nenhum ID válido para vídeos fixados');
                } else {
                    const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${idsToFetch}&key=${youtubeApiKey}`;
                    const detailsResponse = await fetch(detailsUrl);
                    
                    if (!detailsResponse.ok) {
                        const errorText = await detailsResponse.text();
                        console.error('[Canais Monitorados] Erro ao buscar vídeos fixados:', detailsResponse.status, errorText.substring(0, 200));
                    } else {
                        const detailsData = await detailsResponse.json();
                        if (detailsData.items && Array.isArray(detailsData.items)) {
                            // Calcular receita e RPM para vídeos fixados
                            pinnedVideos = detailsData.items.map(item => {
                                const pinData = pinnedVideoIds.find(p => p.youtube_video_id === item.id);
                                const views = parseInt(item.statistics.viewCount || 0);
                                // Buscar nicho do canal para calcular RPM correto
                                // Por enquanto usar padrão, pode ser melhorado buscando do user_channels
                                const rpm = getRPMByNiche(null);
                                const estimatedRevenueUSD = (views / 1000) * rpm.usd;
                                const estimatedRevenueBRL = (views / 1000) * rpm.brl;
                                
                                return {
                                    pinId: pinData.id,
                                    videoId: item.id,
                                    title: item.snippet.title,
                                    thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default?.url || '',
                                    views: views,
                                    likes: parseInt(item.statistics.likeCount || 0),
                                    comments: parseInt(item.statistics.commentCount || 0),
                                    estimatedRevenueUSD: estimatedRevenueUSD,
                                    estimatedRevenueBRL: estimatedRevenueBRL,
                                    rpmUSD: rpm.usd,
                                    rpmBRL: rpm.brl
                                };
                            });
                        }
                    }
                }
            } catch (pinnedErr) {
                console.error('[Canais Monitorados] Erro ao processar vídeos fixados:', pinnedErr);
                // Continuar com array vazio
            }
        }
        
        try {
            await db.run('UPDATE monitored_channels SET last_checked = CURRENT_TIMESTAMP WHERE id = ?', [channelId]);
        } catch (updateErr) {
            console.warn('[Canais Monitorados] Erro ao atualizar last_checked:', updateErr);
            // Não bloquear a resposta por causa disso
        }
        
        res.status(200).json({
            latest: Array.isArray(latestVideos) ? latestVideos : [],
            popular: Array.isArray(popularVideos) ? popularVideos : [],
            pinned: Array.isArray(pinnedVideos) ? pinnedVideos : []
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/monitor/:channelId/check]:', err);
        // Sempre retornar JSON, nunca HTML
        res.status(500).json({ msg: err.message || 'Erro ao buscar vídeos do canal.' });
    }
});

app.get('/api/channels/:channelId/pinned', authenticateToken, async (req, res) => {
    const { channelId } = req.params;
    const userId = req.user.id;
    try {
        // Buscar chave do YouTube primeiro, se não encontrar, usar Gemini como fallback
        let youtubeApiKey = null;
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData && youtubeKeyData.api_key) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
            if (!youtubeApiKey && youtubeKeyData.api_key && !youtubeKeyData.api_key.includes(':')) {
                youtubeApiKey = youtubeKeyData.api_key;
            }
        }
        
        // Se não encontrou chave do YouTube, tentar usar Gemini como fallback
        if (!youtubeApiKey) {
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData && geminiKeyData.api_key) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
                if (!youtubeApiKey && geminiKeyData.api_key && !geminiKeyData.api_key.includes(':')) {
                    youtubeApiKey = geminiKeyData.api_key;
                }
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ msg: 'Chave de API do YouTube ou Gemini é necessária. Configure uma delas nas configurações.' });
        }

        const pinnedVideoIds = await db.all('SELECT id, youtube_video_id FROM pinned_videos WHERE user_id = ? AND monitored_channel_id = ? ORDER BY pinned_at DESC', [userId, channelId]);
        
        if (pinnedVideoIds.length === 0) {
            return res.json([]);
        }

        const idsToFetch = pinnedVideoIds.map(p => p.youtube_video_id).join(',');
        const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${idsToFetch}&key=${youtubeApiKey}`;
        const detailsResponse = await fetch(detailsUrl);
        const detailsData = await detailsResponse.json();
        
        let pinnedVideos = [];
        if (detailsResponse.ok && detailsData.items) {
            pinnedVideos = detailsData.items.map(item => {
                const pinData = pinnedVideoIds.find(p => p.youtube_video_id === item.id);
                return {
                    pinId: pinData.id,
                    videoId: item.id,
                    title: item.snippet.title,
                    thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default.url,
                    views: item.statistics.viewCount || 0,
                    likes: item.statistics.likeCount || 0,
                    comments: item.statistics.commentCount || 0,
                };
            });
        }
        res.status(200).json(pinnedVideos);

    } catch (err) {
        console.error('Erro ao buscar vídeos fixados do canal:', err);
        res.status(500).json({ msg: err.message });
    }
});


// === ROTAS DE VÍDEOS (PIN) ===
app.post('/api/videos/pin', authenticateToken, async (req, res) => {
    const { videoId, title, thumbnail, channelId } = req.body;
    const userId = req.user.id;

    if (!videoId || !title || !thumbnail || !channelId) {
        return res.status(400).json({ msg: 'Dados do vídeo e do canal insuficientes.' });
    }

    try {
        const count = await db.get('SELECT COUNT(*) as count FROM pinned_videos WHERE user_id = ? AND monitored_channel_id = ?', [userId, channelId]);
        if (count.count >= 6) {
            return res.status(400).json({ msg: 'Limite de 6 vídeos fixados por canal atingido.' });
        }

        await db.run(
            'INSERT INTO pinned_videos (user_id, monitored_channel_id, youtube_video_id, title, thumbnail_url) VALUES (?, ?, ?, ?, ?)',
            [userId, channelId, videoId, title, thumbnail]
        );
        res.status(201).json({ msg: 'Vídeo fixado com sucesso.' });
    } catch (err) {
        if (err.code === 'SQLITE_CONSTRAINT') {
            return res.status(409).json({ msg: 'Este vídeo já foi fixado neste canal.' });
        }
        console.error("Erro ao fixar vídeo:", err);
        res.status(500).json({ msg: 'Erro no servidor ao fixar vídeo.' });
    }
});

app.delete('/api/videos/unpin/:pinId', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { pinId } = req.params;
    try {
        const result = await db.run(
            'DELETE FROM pinned_videos WHERE id = ? AND user_id = ?',
            [pinId, userId]
        );
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Vídeo fixado não encontrado ou não pertence a este utilizador.' });
        }
        res.status(200).json({ msg: 'Vídeo removido dos fixados.' });
    } catch (err) {
        console.error("Erro ao remover vídeo fixado:", err);
        res.status(500).json({ msg: 'Erro no servidor ao remover vídeo fixado.' });
    }
});

// GET /api/videos/generated - Lista vídeos gerados pelo usuário
app.get('/api/videos/generated', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    
    try {
        const videos = await db.all(
            `SELECT id, operation_id, video_uri, prompt, model, aspect_ratio, resolution, created_at 
             FROM generated_videos 
             WHERE user_id = ? 
             ORDER BY created_at DESC 
             LIMIT 50`,
            [userId]
        );
        
        res.status(200).json({ videos: videos || [] });
    } catch (err) {
        console.error("Erro ao listar vídeos gerados:", err);
        res.status(500).json({ msg: 'Erro no servidor ao listar vídeos gerados.' });
    }
});

// === ROTAS DE ANALYTICS E TRACKING ===

// Registrar tracking de vídeo publicado
app.post('/api/analytics/track', authenticateToken, async (req, res) => {
    const { analysisId, youtubeVideoId, titleUsed, thumbnailUsed, predictedCtr, predictedViews, publishedAt } = req.body;
    const userId = req.user.id;

    if (!youtubeVideoId || !titleUsed) {
        return res.status(400).json({ msg: 'YouTube Video ID e título são obrigatórios.' });
    }

    try {
        const result = await db.run(
            `INSERT INTO video_tracking (user_id, analysis_id, youtube_video_id, title_used, thumbnail_used, predicted_ctr, predicted_views, published_at, channel_id)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, analysisId || null, youtubeVideoId, titleUsed, thumbnailUsed || null, predictedCtr || null, predictedViews || null, publishedAt || new Date().toISOString(), req.body.channelId || null]
        );
        res.status(201).json({ id: result.lastID, msg: 'Tracking iniciado com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/track]:', err);
        res.status(500).json({ msg: 'Erro ao registrar tracking.' });
    }
});

// Função helper para obter RPM baseado no nicho (usada em múltiplas rotas)
// Função para analisar canal e detectar nicho/subnicho automaticamente

// ===== YouTube helpers (evitar search.list: caro e estoura quota) =====
async function getUploadsPlaylistId(channelId, accessToken) {
    const url = `https://www.googleapis.com/youtube/v3/channels?part=contentDetails&id=${encodeURIComponent(channelId)}`;
    const r = await fetch(url, { headers: { 'Authorization': `Bearer ${accessToken}` } });
    if (!r.ok) return null;
    const j = await r.json().catch(() => null);
    const uploads = j?.items?.[0]?.contentDetails?.relatedPlaylists?.uploads;
    return uploads || null;
}

async function getRecentVideoTitlesFromUploads(channelId, accessToken, maxResults = 10) {
    const uploadsId = await getUploadsPlaylistId(channelId, accessToken);
    if (!uploadsId) return [];
    const url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=${encodeURIComponent(uploadsId)}&maxResults=${Math.min(50, Math.max(1, maxResults))}`;
    const r = await fetch(url, { headers: { 'Authorization': `Bearer ${accessToken}` } });
    if (!r.ok) return [];
    const j = await r.json().catch(() => null);
    const titles = (j?.items || [])
        .map(it => it?.snippet?.title || '')
        .filter(t => t && t.toLowerCase() !== 'private video' && t.toLowerCase() !== 'deleted video');
    return titles.slice(0, maxResults);
}

async function getRecentVideoIdsFromUploads(channelId, accessToken, maxResults = 20) {
    const uploadsId = await getUploadsPlaylistId(channelId, accessToken);
    if (!uploadsId) return [];
    const url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=${encodeURIComponent(uploadsId)}&maxResults=${Math.min(50, Math.max(1, maxResults))}`;
    const r = await fetch(url, { headers: { 'Authorization': `Bearer ${accessToken}` } });
    if (!r.ok) return [];
    const j = await r.json().catch(() => null);
    const ids = (j?.items || [])
        .map(it => it?.snippet?.resourceId?.videoId)
        .filter(Boolean);
    return ids.slice(0, maxResults);
}

async function analyzeChannelNiche(channelId, channelName, accessToken, userId) {
    try {
        console.log(`[Análise Canal] 🔍 Iniciando análise do canal ${channelId} (${channelName})...`);
        
        // Buscar os 5 vídeos mais recentes do canal (reduzido para ser mais rápido)
        console.log(`[Análise Canal] 📡 Buscando vídeos do canal (uploads playlist, sem search.list)...`);
        const videoTitles = await getRecentVideoTitlesFromUploads(channelId, accessToken, 5);
        
        if (videoTitles.length === 0) {
            console.warn(`[Análise Canal] ⚠️ Nenhum título válido encontrado nos vídeos`);
            return { niche: 'Entretenimento', subniche: null };
        }
        
        console.log(`[Análise Canal] 📝 Títulos encontrados: ${videoTitles.length} vídeos`);
        
        // Buscar chaves de API do usuário para análise
        const keysData = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
        const keys = {};
        keysData.forEach(k => { keys[k.service_name] = decrypt(k.api_key); });
        
        // Tentar usar Gemini, Claude ou OpenAI (nesta ordem)
        let detectedNiche = null;
        let detectedSubniche = null;
        
        const analysisPrompt = `Você é um especialista em análise de conteúdo do YouTube. Analise os seguintes títulos de vídeos de um canal do YouTube e identifique o NICHO e SUBNICHE do canal.

Títulos dos vídeos:
${videoTitles.map((title, i) => `${i + 1}. ${title}`).join('\n')}

Nome do canal: ${channelName}

Analise os padrões, temas e assuntos recorrentes nos títulos para identificar:
- O NICHO principal (categoria ampla: Entretenimento, Educação, Tecnologia, Finanças, Gaming, etc.)
- O SUBNICHE específico (área mais específica dentro do nicho: Gaming FPS, Finanças Pessoais, Programação Web, etc.)

IMPORTANTE: Responda APENAS com um objeto JSON válido, sem nenhum texto adicional antes ou depois:
{
  "niche": "Nome do nicho principal",
  "subniche": "Nome do subnicho específico ou null se não houver subnicho claro"
}

Seja específico e preciso. Se não conseguir identificar claramente, use "Entretenimento" como nicho padrão e deixe subniche como null.`;

        // Tentar Gemini primeiro
        if (keys.gemini) {
            try {
                const response = await callGeminiAPI(analysisPrompt, keys.gemini, 'gemini-2.0-flash');
                const parsed = parseAIResponse(response.titles, 'gemini');
                if (parsed.niche) {
                    detectedNiche = parsed.niche;
                    detectedSubniche = parsed.subniche || null;
                    console.log(`[Análise Canal] Nicho detectado via Gemini: ${detectedNiche} / ${detectedSubniche}`);
                    return { niche: detectedNiche, subniche: detectedSubniche };
                }
            } catch (err) {
                console.warn(`[Análise Canal] Erro ao usar Gemini: ${err.message}`);
            }
        }
        
        // Tentar Claude
        if (keys.claude) {
            try {
                const response = await callClaudeAPI(analysisPrompt, keys.claude, 'claude-3-5-haiku-20241022');
                const parsed = parseAIResponse(response.titles, 'claude');
                if (parsed.niche) {
                    detectedNiche = parsed.niche;
                    detectedSubniche = parsed.subniche || null;
                    console.log(`[Análise Canal] Nicho detectado via Claude: ${detectedNiche} / ${detectedSubniche}`);
                    return { niche: detectedNiche, subniche: detectedSubniche };
                }
            } catch (err) {
                console.warn(`[Análise Canal] Erro ao usar Claude: ${err.message}`);
            }
        }
        
        // Tentar OpenAI
        if (keys.openai) {
            try {
                const response = await callOpenAIAPI(analysisPrompt, keys.openai, 'gpt-4o-mini');
                const parsed = parseAIResponse(response.titles, 'openai');
                if (parsed.niche) {
                    detectedNiche = parsed.niche;
                    detectedSubniche = parsed.subniche || null;
                    console.log(`[Análise Canal] Nicho detectado via OpenAI: ${detectedNiche} / ${detectedSubniche}`);
                    return { niche: detectedNiche, subniche: detectedSubniche };
                }
            } catch (err) {
                console.warn(`[Análise Canal] Erro ao usar OpenAI: ${err.message}`);
            }
        }
        
        // Se nenhuma IA funcionou, retornar nicho padrão (não null para não ficar travado)
        console.warn(`[Análise Canal] ⚠️ Não foi possível detectar nicho para o canal ${channelId}, usando padrão`);
        return { niche: 'Entretenimento', subniche: null };
        
    } catch (err) {
        console.error(`[Análise Canal] ❌ Erro ao analisar canal ${channelId}:`, err.message);
        console.error(`[Análise Canal] Stack trace:`, err.stack);
        // Retornar nicho padrão em caso de erro para não ficar travado
        return { niche: 'Entretenimento', subniche: null };
    }
}

function getRPMByNiche(niche) {
    if (!niche) return { usd: 2.0, brl: 11.0 }; // Padrão: Entretenimento
    
    const nicheLower = niche.toLowerCase();
    
    // RPMs reais por nicho (USD por 1000 views) - baseado em dados do mercado
    const rpmMap = {
        'finança': { usd: 15.0, brl: 82.5 },
        'financeiro': { usd: 15.0, brl: 82.5 },
        'investimento': { usd: 18.0, brl: 99.0 },
        'investimentos': { usd: 18.0, brl: 99.0 },
        'educação financeira': { usd: 12.0, brl: 66.0 },
        'tecnologia': { usd: 7.0, brl: 38.5 },
        'tech': { usd: 7.0, brl: 38.5 },
        'programação': { usd: 8.0, brl: 44.0 },
        'gaming': { usd: 3.5, brl: 19.25 },
        'jogos': { usd: 3.5, brl: 19.25 },
        'game': { usd: 3.5, brl: 19.25 },
        'educação': { usd: 5.0, brl: 27.5 },
        'educacional': { usd: 5.0, brl: 27.5 },
        'culinária': { usd: 3.0, brl: 16.5 },
        'receitas': { usd: 3.0, brl: 16.5 },
        'fitness': { usd: 4.0, brl: 22.0 },
        'saúde': { usd: 4.5, brl: 24.75 },
        'entretenimento': { usd: 2.0, brl: 11.0 },
        'vlogs': { usd: 2.5, brl: 13.75 },
        'viagens': { usd: 4.0, brl: 22.0 },
        'história': { usd: 3.5, brl: 19.25 },
        'ciência': { usd: 5.5, brl: 30.25 },
        'negócios': { usd: 10.0, brl: 55.0 },
        'empreendedorismo': { usd: 9.0, brl: 49.5 },
        'marketing': { usd: 8.0, brl: 44.0 },
        'vendas': { usd: 9.0, brl: 49.5 }
    };
    
    // Buscar nicho correspondente (busca parcial)
    for (const [key, value] of Object.entries(rpmMap)) {
        if (nicheLower.includes(key)) {
            return value;
        }
    }
    
    // Se não encontrar, retornar padrão baseado em palavras-chave
    if (nicheLower.includes('finance') || nicheLower.includes('dinheiro') || nicheLower.includes('invest')) {
        return { usd: 12.0, brl: 66.0 };
    }
    if (nicheLower.includes('tech') || nicheLower.includes('program') || nicheLower.includes('software')) {
        return { usd: 7.0, brl: 38.5 };
    }
    if (nicheLower.includes('game') || nicheLower.includes('jogo')) {
        return { usd: 3.5, brl: 19.25 };
    }
    if (nicheLower.includes('educ') || nicheLower.includes('curso') || nicheLower.includes('aprend')) {
        return { usd: 5.0, brl: 27.5 };
    }
    
    // Padrão: Entretenimento
    return { usd: 2.0, brl: 11.0 };
}

// Atualizar métricas de vídeo (buscar do YouTube)
app.post('/api/analytics/update/:trackingId', authenticateToken, async (req, res) => {
    const { trackingId } = req.params;
    const userId = req.user.id;

    try {
        // Buscar tracking com informações do canal
        const tracking = await db.get(`
            SELECT vt.youtube_video_id, vt.channel_id, uc.niche 
            FROM video_tracking vt
            LEFT JOIN user_channels uc ON vt.channel_id = uc.id
            WHERE vt.id = ? AND vt.user_id = ?
        `, [trackingId, userId]);
        
        if (!tracking) {
            return res.status(404).json({ msg: 'Tracking não encontrado.' });
        }

        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        if (!geminiKeyData) {
            return res.status(400).json({ msg: 'Chave de API do Gemini é necessária.' });
        }
        const geminiApiKey = decrypt(geminiKeyData.api_key);

        let videoDetails;
        try {
            videoDetails = await callYouTubeDataAPI(tracking.youtube_video_id, geminiApiKey);
        } catch (apiErr) {
            console.error('[Analytics Update] Erro ao buscar dados do YouTube:', apiErr.message);
            return res.status(500).json({ msg: `Erro ao buscar dados do YouTube: ${apiErr.message}` });
        }
        
        // Calcular CTR estimado (YouTube não fornece CTR diretamente, então estimamos)
        // Usar uma fórmula mais realista baseada nas views
        // Vídeos com muitas views geralmente têm CTR mais baixo, vídeos novos podem ter CTR mais alto
        const views = parseInt(videoDetails.views) || 0;
        let estimatedCtr = 0;
        if (views > 0) {
            // Fórmula mais realista: CTR diminui conforme views aumentam
            // Vídeos com 1K views: ~15% CTR, 10K views: ~10% CTR, 100K views: ~5% CTR, 1M views: ~3% CTR
            if (views < 10000) {
                estimatedCtr = 15 - (views / 10000) * 5; // 15% a 10%
            } else if (views < 100000) {
                estimatedCtr = 10 - ((views - 10000) / 90000) * 5; // 10% a 5%
            } else if (views < 1000000) {
                estimatedCtr = 5 - ((views - 100000) / 900000) * 2; // 5% a 3%
            } else {
                estimatedCtr = Math.max(2, 3 - ((views - 1000000) / 10000000) * 1); // 3% a 2%
            }
            estimatedCtr = Math.max(2, Math.min(30, estimatedCtr)); // Limitar entre 2% e 30%
        }
        
        // Calcular receita baseada no RPM do nicho do canal
        const rpm = getRPMByNiche(tracking.niche);
        const estimatedRevenue = (views / 1000) * rpm.usd;

        await db.run(
            `UPDATE video_tracking 
             SET actual_views = ?, actual_likes = ?, actual_comments = ?, actual_ctr = ?, revenue_estimate = ?, last_updated = CURRENT_TIMESTAMP
             WHERE id = ?`,
            [videoDetails.views, videoDetails.likes, videoDetails.comments, estimatedCtr, estimatedRevenue, trackingId]
        );

        // Criar snapshot
        await db.run(
            `INSERT INTO analytics_snapshots (user_id, video_tracking_id, views, likes, comments, ctr)
             VALUES (?, ?, ?, ?, ?, ?)`,
            [userId, trackingId, videoDetails.views, videoDetails.likes, videoDetails.comments, estimatedCtr]
        );

        res.status(200).json({ 
            views: videoDetails.views,
            likes: videoDetails.likes,
            comments: videoDetails.comments,
            ctr: estimatedCtr,
            revenue: estimatedRevenue
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/update]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar métricas.' });
    }
});

// Obter dashboard de analytics
app.get('/api/analytics/dashboard', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    console.log(`[Analytics Dashboard] Requisição recebida para userId: ${userId}`);

    try {
        if (!db) {
            console.error('[Analytics Dashboard] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        // Verificar se a tabela existe e tem dados
        let stats = {
            total_videos: 0,
            total_views: 0,
            total_likes: 0,
            total_comments: 0,
            avg_ctr: 0,
            total_revenue: 0,
            viral_videos: 0
        };
        
        try {
            // Verificar se a tabela existe primeiro
            const tableCheck = await db.get(`
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='video_tracking'
            `);
            
            if (tableCheck) {
                stats = await db.get(`
                    SELECT 
                        COUNT(*) as total_videos,
                        COALESCE(SUM(actual_views), 0) as total_views,
                        COALESCE(SUM(actual_likes), 0) as total_likes,
                        COALESCE(SUM(actual_comments), 0) as total_comments,
                        COALESCE(AVG(actual_ctr), 0) as avg_ctr,
                        COALESCE(SUM(revenue_estimate), 0) as total_revenue,
                        COUNT(CASE WHEN actual_views >= 1000000 THEN 1 END) as viral_videos
                    FROM video_tracking
                    WHERE user_id = ?
                `, [userId]) || stats;
            }
            console.log(`[Analytics Dashboard] Stats encontrados:`, stats);
        } catch (dbErr) {
            console.error('[Analytics Dashboard] Erro ao buscar stats:', dbErr);
            // Manter valores padrão
        }

        let recentVideos = [];
        try {
            // Verificar se a tabela existe primeiro
            const tableCheck = await db.get(`
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='video_tracking'
            `);
            
            if (tableCheck) {
                recentVideos = await db.all(`
                    SELECT vt.id, vt.youtube_video_id, vt.title_used, vt.actual_views, vt.actual_ctr, vt.revenue_estimate, 
                           vt.published_at, vt.tracked_at, vt.channel_id, uc.channel_name
                    FROM video_tracking vt
                    LEFT JOIN user_channels uc ON vt.channel_id = uc.id
                    WHERE vt.user_id = ?
                    ORDER BY COALESCE(vt.published_at, vt.tracked_at) DESC
                    LIMIT 50
                `, [userId]) || [];
            }
            console.log(`[Analytics Dashboard] Vídeos recentes encontrados:`, recentVideos.length);
        } catch (dbErr) {
            console.error('[Analytics Dashboard] Erro ao buscar vídeos recentes:', dbErr);
            recentVideos = [];
        }

        // Usar a função getRPMByNiche definida globalmente acima
        
        // Calcular RPM por canal (baseado no nicho)
        let totalRPMUSD = 0;
        let totalRPMBRL = 0;
        let channelsCount = 0;
        
        try {
            const channelsWithNiche = await db.all(`
                SELECT DISTINCT uc.niche 
                FROM user_channels uc
                INNER JOIN video_tracking vt ON vt.channel_id = uc.id
                WHERE uc.user_id = ? AND uc.niche IS NOT NULL AND uc.niche != ''
            `, [userId]);
            
            if (channelsWithNiche && channelsWithNiche.length > 0) {
                channelsWithNiche.forEach(ch => {
                    const rpm = getRPMByNiche(ch.niche);
                    totalRPMUSD += rpm.usd;
                    totalRPMBRL += rpm.brl;
                    channelsCount++;
                });
                // Média dos RPMs
                totalRPMUSD = totalRPMUSD / channelsCount;
                totalRPMBRL = totalRPMBRL / channelsCount;
            } else {
                // Se não há canais com nicho, usar padrão
                const defaultRPM = getRPMByNiche(null);
                totalRPMUSD = defaultRPM.usd;
                totalRPMBRL = defaultRPM.brl;
            }
        } catch (rpmErr) {
            console.error('[Analytics] Erro ao calcular RPM por nicho:', rpmErr);
            const defaultRPM = getRPMByNiche(null);
            totalRPMUSD = defaultRPM.usd;
            totalRPMBRL = defaultRPM.brl;
        }
        
        // Calcular receita estimada baseada no RPM real do nicho
        const totalViews = parseInt(stats?.total_views || 0);
        const usdToBrlRate = 5.50;
        
        // Calcular receita total: somar receita do banco + receita estimada baseada no RPM do nicho
        // Se há receita no banco, usar ela; senão, calcular baseado no RPM do nicho
        let totalRevenueUSD = parseFloat(stats?.total_revenue || 0);
        
        // Se não há receita no banco mas há views, calcular baseado no RPM do nicho
        if (totalRevenueUSD === 0 && totalViews > 0 && totalRPMUSD > 0) {
            totalRevenueUSD = (totalViews * totalRPMUSD) / 1000;
        }
        // Se há receita no banco, recalcular baseado no RPM do nicho para atualizar
        else if (totalViews > 0 && totalRPMUSD > 0) {
            // Recalcular receita baseada no RPM atual do nicho (mais preciso)
            totalRevenueUSD = (totalViews * totalRPMUSD) / 1000;
        }
        
        const totalRevenueBRL = totalRevenueUSD * usdToBrlRate;
        
        // RPM final (usar o calculado baseado no nicho, ou calcular a partir da receita se houver)
        let rpmUSD = totalRPMUSD;
        let rpmBRL = totalRPMBRL;
        
        // Se não há RPM calculado mas há receita, calcular RPM a partir da receita
        if (rpmUSD === 0 && totalRevenueUSD > 0 && totalViews > 0) {
            rpmUSD = (totalRevenueUSD / totalViews) * 1000;
            rpmBRL = (totalRevenueBRL / totalViews) * 1000;
        }

        // Garantir que recentVideos é sempre um array
        const recentVideosArray = Array.isArray(recentVideos) ? recentVideos : [];
        
        const response = {
            stats: {
                totalVideos: parseInt(stats?.total_videos || 0),
                totalViews: totalViews,
                totalLikes: parseInt(stats?.total_likes || 0),
                totalComments: parseInt(stats?.total_comments || 0),
                avgCtr: parseFloat(stats?.avg_ctr || 0),
                totalRevenue: totalRevenueUSD,
                totalRevenueBRL: totalRevenueBRL,
                rpmUSD: rpmUSD,
                rpmBRL: rpmBRL,
                viralVideos: parseInt(stats?.viral_videos || 0)
            },
            recentVideos: recentVideosArray
        };

        console.log(`[Analytics Dashboard] Enviando resposta:`, JSON.stringify(response).substring(0, 200));
        res.status(200).json(response);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/dashboard]:', err);
        // Sempre retornar JSON válido, nunca HTML
        res.status(500).json({ 
            stats: {
                totalVideos: 0,
                totalViews: 0,
                totalLikes: 0,
                totalComments: 0,
                avgCtr: 0,
                totalRevenue: 0,
                totalRevenueBRL: 0,
                rpmUSD: 2.0,
                rpmBRL: 11.0,
                viralVideos: 0
            },
            recentVideos: [],
            error: err.message || 'Erro no servidor ao buscar dados do dashboard.'
        });
    }
});

// Excluir vídeo do tracking
app.delete('/api/analytics/track/:trackingId', authenticateToken, async (req, res) => {
    const { trackingId } = req.params;
    const userId = req.user.id;

    try {
        if (!db) {
            console.error('[Analytics Delete] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        // Verificar se o tracking pertence ao usuário
        const tracking = await db.get('SELECT id FROM video_tracking WHERE id = ? AND user_id = ?', [trackingId, userId]);
        if (!tracking) {
            return res.status(404).json({ msg: 'Tracking não encontrado ou não pertence a este usuário.' });
        }

        // Excluir snapshots relacionados primeiro (devido à foreign key)
        await db.run('DELETE FROM analytics_snapshots WHERE video_tracking_id = ?', [trackingId]);

        // Excluir o tracking
        const result = await db.run('DELETE FROM video_tracking WHERE id = ? AND user_id = ?', [trackingId, userId]);
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Tracking não encontrado.' });
        }

        console.log(`[Analytics Delete] Vídeo ${trackingId} excluído pelo usuário ${userId}`);
        res.status(200).json({ msg: 'Vídeo excluído do tracking com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/track/:trackingId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir vídeo do tracking.' });
    }
});
// === NOVAS FUNCIONALIDADES DE ANALYTICS E VALIDAÇÃO ===

// 1. ROI Calculator - Calcular receita total gerada pelos vídeos
app.get('/api/analytics/roi', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { startDate, endDate } = req.query;

    try {
        let query = `
            SELECT 
                COUNT(*) as total_videos,
                SUM(actual_views) as total_views,
                SUM(revenue_estimate) as total_revenue,
                AVG(actual_ctr) as avg_ctr,
                SUM(actual_likes) as total_likes,
                SUM(actual_comments) as total_comments
            FROM video_tracking
            WHERE user_id = ? AND actual_views > 0
        `;
        const params = [userId];

        if (startDate) {
            query += ' AND published_at >= ?';
            params.push(startDate);
        }
        if (endDate) {
            query += ' AND published_at <= ?';
            params.push(endDate);
        }

        const stats = await db.get(query, params);

        // Calcular ROI (assumindo que cada análise custa $0.50 ou similar)
        const costPerAnalysis = 0.50;
        const totalCost = (stats.total_videos || 0) * costPerAnalysis;
        const totalRevenue = stats.total_revenue || 0;
        const roi = totalCost > 0 ? ((totalRevenue - totalCost) / totalCost) * 100 : 0;

        res.status(200).json({
            totalVideos: stats.total_videos || 0,
            totalViews: stats.total_views || 0,
            totalRevenue: totalRevenue,
            totalCost: totalCost,
            roi: roi.toFixed(2),
            avgCtr: (stats.avg_ctr || 0).toFixed(2),
            totalLikes: stats.total_likes || 0,
            totalComments: stats.total_comments || 0,
            netProfit: (totalRevenue - totalCost).toFixed(2)
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/roi]:', err);
        res.status(500).json({ msg: 'Erro ao calcular ROI.' });
    }
});

// 2. Leaderboard - Melhores títulos/thumbnails por views
app.get('/api/analytics/leaderboard', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { type = 'all', limit = 10 } = req.query; // type: 'titles', 'thumbnails', 'all'

    try {
        let leaderboard = [];

        if (type === 'titles' || type === 'all') {
            const topTitles = await db.all(`
                SELECT 
                    title_used as item,
                    'title' as type,
                    actual_views as views,
                    actual_ctr as ctr,
                    revenue_estimate as revenue,
                    published_at
                FROM video_tracking
                WHERE user_id = ? AND title_used IS NOT NULL AND actual_views > 0
                ORDER BY actual_views DESC
                LIMIT ?
            `, [userId, parseInt(limit)]);
            leaderboard = leaderboard.concat(topTitles);
        }

        if (type === 'thumbnails' || type === 'all') {
            const topThumbnails = await db.all(`
                SELECT 
                    thumbnail_used as item,
                    'thumbnail' as type,
                    actual_views as views,
                    actual_ctr as ctr,
                    revenue_estimate as revenue,
                    published_at
                FROM video_tracking
                WHERE user_id = ? AND thumbnail_used IS NOT NULL AND actual_views > 0
                ORDER BY actual_views DESC
                LIMIT ?
            `, [userId, parseInt(limit)]);
            leaderboard = leaderboard.concat(topThumbnails);
        }

        // Ordenar por views e limitar
        leaderboard.sort((a, b) => (b.views || 0) - (a.views || 0));
        leaderboard = leaderboard.slice(0, parseInt(limit));

        res.status(200).json({ leaderboard });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/leaderboard]:', err);
        res.status(500).json({ msg: 'Erro ao buscar leaderboard.' });
    }
});

// 3. Heatmap de Sucesso - Fórmulas de título que funcionam melhor por nicho
app.get('/api/analytics/heatmap', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        // Buscar títulos da biblioteca com suas métricas de sucesso
        // Nota: JOIN pode não funcionar se não houver correspondência exata, então fazemos query separada
        const heatmapData = await db.all(`
            SELECT 
                COALESCE(uc.niche, 'Geral') as niche,
                COALESCE(uc.subniche, '') as subniche,
                COUNT(*) as usage_count,
                AVG(vt.actual_views) as avg_views,
                AVG(vt.actual_ctr) as avg_ctr,
                MAX(vt.actual_views) as max_views
            FROM video_tracking vt
            LEFT JOIN user_channels uc ON vt.channel_id = uc.id
            WHERE vt.user_id = ? AND vt.actual_views > 0
            GROUP BY COALESCE(uc.niche, 'Geral'), COALESCE(uc.subniche, '')
            ORDER BY avg_views DESC
        `, [userId]);

        // Também buscar dados da biblioteca de títulos
        const libraryData = await db.all(`
            SELECT 
                niche,
                subniche,
                formula_type,
                COUNT(*) as count,
                AVG(original_views) as avg_views,
                AVG(original_ctr) as avg_ctr
            FROM viral_titles_library
            WHERE user_id = ? AND original_views > 0
            GROUP BY niche, subniche, formula_type
        `, [userId]);

        res.status(200).json({
            tracking: heatmapData,
            library: libraryData
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/heatmap]:', err);
        res.status(500).json({ msg: 'Erro ao buscar heatmap.' });
    }
});

// 4. Score Predictor - IA prevê potencial de views antes de publicar
app.post('/api/analytics/predict-score', authenticateToken, async (req, res) => {
    const { title, thumbnailDescription, niche, subniche } = req.body;
    const userId = req.user.id;

    if (!title) {
        return res.status(400).json({ msg: 'Título é obrigatório.' });
    }

    try {
        // Buscar histórico de sucesso do usuário
        const userHistory = await db.all(`
            SELECT 
                AVG(actual_views) as avg_views,
                AVG(actual_ctr) as avg_ctr,
                COUNT(*) as total_videos
            FROM video_tracking
            WHERE user_id = ? AND actual_views > 0
        `, [userId]);

        // Buscar títulos similares na biblioteca
        const similarTitles = await db.all(`
            SELECT 
                original_views,
                original_ctr,
                viral_score
            FROM viral_titles_library
            WHERE user_id = ? AND niche = ? AND original_views > 0
            ORDER BY original_views DESC
            LIMIT 10
        `, [userId, niche || '']);

        // Calcular score baseado em múltiplos fatores
        let predictedViews = 0;
        let predictedCtr = 0;
        let score = 0;

        // Fator 1: Histórico do usuário
        if (userHistory[0] && userHistory[0].total_videos > 0) {
            predictedViews = userHistory[0].avg_views || 0;
            predictedCtr = userHistory[0].avg_ctr || 0;
        }

        // Fator 2: Títulos similares
        if (similarTitles.length > 0) {
            const avgSimilarViews = similarTitles.reduce((sum, t) => sum + (t.original_views || 0), 0) / similarTitles.length;
            const avgSimilarCtr = similarTitles.reduce((sum, t) => sum + (t.original_ctr || 0), 0) / similarTitles.length;
            
            // Média ponderada: 60% histórico do usuário, 40% títulos similares
            predictedViews = (predictedViews * 0.6) + (avgSimilarViews * 0.4);
            predictedCtr = (predictedCtr * 0.6) + (avgSimilarCtr * 0.4);
        }

        // Fator 3: Análise do título (comprimento, palavras-chave, etc)
        const titleLength = title.length;
        const hasNumbers = /\d/.test(title);
        const hasQuestion = title.includes('?');
        const hasExclamation = title.includes('!');
        const powerWords = ['SECRETO', 'REVELADO', 'ESCONDIDO', 'PROIBIDO', 'CHOCANTE', 'INCRÍVEL', 'NUNCA VISTO'];
        const hasPowerWords = powerWords.some(word => title.toUpperCase().includes(word));

        // Ajustar score baseado em características do título
        let titleScore = 50; // Base
        if (titleLength >= 40 && titleLength <= 60) titleScore += 10; // Tamanho ideal
        if (hasNumbers) titleScore += 5;
        if (hasQuestion) titleScore += 8;
        if (hasExclamation) titleScore += 5;
        if (hasPowerWords) titleScore += 15;

        // Calcular score final (0-100)
        score = Math.min(100, Math.max(0, titleScore + (predictedCtr * 2)));

        // Ajustar views previstas baseado no score
        predictedViews = predictedViews * (score / 50);

        res.status(200).json({
            predictedViews: Math.round(predictedViews),
            predictedCtr: predictedCtr.toFixed(2),
            score: Math.round(score),
            factors: {
                titleLength,
                hasNumbers,
                hasQuestion,
                hasExclamation,
                hasPowerWords,
                userHistory: userHistory[0] || null,
                similarTitlesCount: similarTitles.length
            }
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/predict-score]:', err);
        res.status(500).json({ msg: 'Erro ao prever score.' });
    }
});

// 5. Validação de Título
app.post('/api/analytics/validate-title', authenticateToken, async (req, res) => {
    const { title, niche } = req.body;

    if (!title) {
        return res.status(400).json({ msg: 'Título é obrigatório.' });
    }

    try {
        const validations = {
            length: {
                value: title.length,
                min: 30,
                max: 70,
                ideal: 40,
                passed: title.length >= 30 && title.length <= 70,
                score: title.length >= 40 && title.length <= 60 ? 100 : title.length >= 30 && title.length <= 70 ? 70 : 50
            },
            hasNumbers: {
                value: /\d/.test(title),
                passed: /\d/.test(title),
                score: /\d/.test(title) ? 100 : 50,
                tip: 'Números aumentam CTR em até 20%'
            },
            hasQuestion: {
                value: title.includes('?'),
                passed: title.includes('?'),
                score: title.includes('?') ? 100 : 60,
                tip: 'Perguntas geram curiosidade'
            },
            hasPowerWords: {
                value: ['SECRETO', 'REVELADO', 'ESCONDIDO', 'PROIBIDO', 'CHOCANTE', 'INCRÍVEL', 'NUNCA VISTO', 'EXCLUSIVO'].some(w => title.toUpperCase().includes(w)),
                passed: ['SECRETO', 'REVELADO', 'ESCONDIDO', 'PROIBIDO', 'CHOCANTE', 'INCRÍVEL', 'NUNCA VISTO', 'EXCLUSIVO'].some(w => title.toUpperCase().includes(w)),
                score: ['SECRETO', 'REVELADO', 'ESCONDIDO', 'PROIBIDO', 'CHOCANTE', 'INCRÍVEL', 'NUNCA VISTO', 'EXCLUSIVO'].some(w => title.toUpperCase().includes(w)) ? 100 : 50,
                tip: 'Palavras poderosas aumentam engajamento'
            },
            capitalization: {
                value: title.split(' ').filter(w => w[0] && w[0] === w[0].toUpperCase()).length,
                passed: title.split(' ').filter(w => w[0] && w[0] === w[0].toUpperCase()).length >= 3,
                score: title.split(' ').filter(w => w[0] && w[0] === w[0].toUpperCase()).length >= 3 ? 100 : 70,
                tip: 'Capitalização adequada melhora legibilidade'
            }
        };

        const totalScore = Object.values(validations).reduce((sum, v) => sum + (v.score || 0), 0) / Object.keys(validations).length;
        const passedCount = Object.values(validations).filter(v => v.passed).length;
        const totalChecks = Object.keys(validations).length;

        res.status(200).json({
            title,
            validations,
            overallScore: Math.round(totalScore),
            passedChecks: `${passedCount}/${totalChecks}`,
            recommendation: totalScore >= 80 ? 'excellent' : totalScore >= 60 ? 'good' : 'needs_improvement',
            tips: Object.values(validations).filter(v => !v.passed && v.tip).map(v => v.tip)
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/validate-title]:', err);
        res.status(500).json({ msg: 'Erro ao validar título.' });
    }
});

// Função para calcular score viral de thumbnail baseado no algoritmo do YouTube
function calculateThumbnailViralScore(thumbnailDescription, index, totalThumbnails) {
    if (!thumbnailDescription || typeof thumbnailDescription !== 'string') {
        return 8; // Score padrão se não houver descrição
    }
    
    const descLower = thumbnailDescription.toLowerCase();
    let baseScore = 6; // Score base (mínimo 6)
    
    // Fatores do algoritmo do YouTube que aumentam CTR:
    
    // 1. Presença de rosto humano (aumenta CTR em 20-30%)
    if (/face|rosto|pessoa|person|human|portrait|close-up|closeup/i.test(descLower)) {
        baseScore += 0.8;
    }
    
    // 2. Expressões emocionais fortes (aumenta engajamento)
    const emotionWords = ['surprised', 'surpreso', 'shocked', 'chocado', 'excited', 'animado', 'angry', 'bravo', 'happy', 'feliz', 'fear', 'medo', 'shock', 'choque'];
    const emotionCount = emotionWords.filter(word => descLower.includes(word)).length;
    baseScore += Math.min(emotionCount * 0.3, 1.0);
    
    // 3. Texto na thumbnail (aumenta cliques)
    if (/text|texto|phrase|frase|word|palavra|letter|letra|font|fonte/i.test(descLower)) {
        baseScore += 0.6;
    }
    
    // 4. Alto contraste e cores vibrantes (melhora visibilidade)
    if (/contrast|contraste|bright|brilhante|vibrant|vibrante|color|cor|saturated|saturado/i.test(descLower)) {
        baseScore += 0.5;
    }
    
    // 5. Composição profissional (regra dos terços, centro)
    if (/rule of thirds|terços|center|centro|composition|composição|framing|enquadramento/i.test(descLower)) {
        baseScore += 0.4;
    }
    
    // 6. Elementos que geram curiosidade
    const curiosityElements = ['mystery', 'mistério', 'secret', 'segredo', 'hidden', 'escondido', 'reveal', 'revelar', 'blur', 'desfocado', 'question', 'pergunta'];
    const curiosityCount = curiosityElements.filter(word => descLower.includes(word)).length;
    baseScore += Math.min(curiosityCount * 0.2, 0.6);
    
    // 7. Qualidade técnica (8K, profissional, etc)
    if (/8k|ultra.*high|professional|profissional|cinematic|cinematográfico|arri|red|canon|nikon/i.test(descLower)) {
        baseScore += 0.3;
    }
    
    // 8. Elementos visuais poderosos
    if (/arrow|seta|number|número|before.*after|antes.*depois|comparison|comparação/i.test(descLower)) {
        baseScore += 0.4;
    }
    
    // 9. Iluminação profissional
    if (/lighting|iluminação|dramatic.*light|luz.*dramática|rim.*light|backlight/i.test(descLower)) {
        baseScore += 0.3;
    }
    
    // 10. Variação baseada no índice (para garantir diferentes scores)
    // Primeira thumbnail geralmente é melhor (réplica melhorada)
    // Segunda thumbnail é nova e otimizada
    const indexVariation = index === 0 ? 0.2 : -0.1; // Primeira ligeiramente melhor
    baseScore += indexVariation;
    
    // Adicionar pequena variação aleatória para simular algoritmo do YouTube
    // (variação de -0.3 a +0.3 para tornar mais realista)
    const randomVariation = (Math.random() * 0.6) - 0.3;
    baseScore += randomVariation;
    
    // Garantir que o score fique entre 6.0 e 10.0
    baseScore = Math.max(6.0, Math.min(10.0, baseScore));
    
    // Arredondar para 1 casa decimal
    return Math.round(baseScore * 10) / 10;
}

// 6. Validação de Thumbnail (análise básica)
app.post('/api/analytics/validate-thumbnail', authenticateToken, async (req, res) => {
    const { thumbnailDescription, niche } = req.body;

    if (!thumbnailDescription) {
        return res.status(400).json({ msg: 'Descrição da thumbnail é obrigatória.' });
    }

    try {
        const validations = {
            hasFace: {
                value: /face|rosto|pessoa|person|human/i.test(thumbnailDescription),
                passed: /face|rosto|pessoa|person|human/i.test(thumbnailDescription),
                score: /face|rosto|pessoa|person|human/i.test(thumbnailDescription) ? 100 : 50,
                tip: 'Rostos humanos aumentam CTR em até 30%'
            },
            hasText: {
                value: /text|texto|phrase|frase|word|palavra/i.test(thumbnailDescription),
                passed: /text|texto|phrase|frase|word|palavra/i.test(thumbnailDescription),
                score: /text|texto|phrase|frase|word|palavra/i.test(thumbnailDescription) ? 100 : 60,
                tip: 'Texto na thumbnail aumenta cliques'
            },
            hasContrast: {
                value: /contrast|contraste|bright|brilhante|vibrant|vibrante|color/i.test(thumbnailDescription),
                passed: /contrast|contraste|bright|brilhante|vibrant|vibrante|color/i.test(thumbnailDescription),
                score: /contrast|contraste|bright|brilhante|vibrant|vibrante|color/i.test(thumbnailDescription) ? 100 : 50,
                tip: 'Alto contraste melhora visibilidade'
            },
            hasEmotion: {
                value: /emotion|emoção|expression|expressão|surprised|surpreso|shocked|chocado|excited|animado/i.test(thumbnailDescription),
                passed: /emotion|emoção|expression|expressão|surprised|surpreso|shocked|chocado|excited|animado/i.test(thumbnailDescription),
                score: /emotion|emoção|expression|expressão|surprised|surpreso|shocked|chocado|excited|animado/i.test(thumbnailDescription) ? 100 : 50,
                tip: 'Expressões emocionais geram mais cliques'
            },
            composition: {
                value: 'center' in thumbnailDescription.toLowerCase() || 'rule of thirds' in thumbnailDescription.toLowerCase(),
                passed: 'center' in thumbnailDescription.toLowerCase() || 'rule of thirds' in thumbnailDescription.toLowerCase(),
                score: 'center' in thumbnailDescription.toLowerCase() || 'rule of thirds' in thumbnailDescription.toLowerCase() ? 100 : 70,
                tip: 'Composição adequada melhora impacto visual'
            }
        };

        const totalScore = Object.values(validations).reduce((sum, v) => sum + (v.score || 0), 0) / Object.keys(validations).length;
        const passedCount = Object.values(validations).filter(v => v.passed).length;
        const totalChecks = Object.keys(validations).length;

        res.status(200).json({
            thumbnailDescription,
            validations,
            overallScore: Math.round(totalScore),
            passedChecks: `${passedCount}/${totalChecks}`,
            recommendation: totalScore >= 80 ? 'excellent' : totalScore >= 60 ? 'good' : 'needs_improvement',
            tips: Object.values(validations).filter(v => !v.passed && v.tip).map(v => v.tip)
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/validate-thumbnail]:', err);
        res.status(500).json({ msg: 'Erro ao validar thumbnail.' });
    }
});

// 7. Comparação com Competidores
app.post('/api/analytics/compare-competitors', authenticateToken, async (req, res) => {
    const { title, thumbnailDescription, niche, competitorVideoIds } = req.body;
    const userId = req.user.id;

    if (!title || !competitorVideoIds || !Array.isArray(competitorVideoIds)) {
        return res.status(400).json({ msg: 'Título e lista de IDs de vídeos competidores são obrigatórios.' });
    }

    try {
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        if (!geminiKeyData) {
            return res.status(400).json({ msg: 'Chave de API do Gemini é necessária.' });
        }
        const geminiApiKey = decrypt(geminiKeyData.api_key);

        // Buscar dados dos vídeos competidores
        const competitorData = await Promise.all(
            competitorVideoIds.slice(0, 5).map(async (videoId) => {
                try {
                    const data = await callYouTubeDataAPI(videoId, geminiApiKey);
                    return {
                        videoId,
                        title: data.title,
                        views: data.views,
                        likes: data.likes,
                        comments: data.comments,
                        days: data.days
                    };
                } catch (err) {
                    console.error(`Erro ao buscar vídeo ${videoId}:`, err);
                    return null;
                }
            })
        );

        const validCompetitors = competitorData.filter(c => c !== null);

        if (validCompetitors.length === 0) {
            return res.status(400).json({ msg: 'Nenhum vídeo competidor válido encontrado.' });
        }

        // Calcular métricas médias dos competidores
        const avgViews = validCompetitors.reduce((sum, c) => sum + (c.views || 0), 0) / validCompetitors.length;
        const avgLikes = validCompetitors.reduce((sum, c) => sum + (c.likes || 0), 0) / validCompetitors.length;
        const avgComments = validCompetitors.reduce((sum, c) => sum + (c.comments || 0), 0) / validCompetitors.length;

        // Comparar características do título
        const yourTitleLength = title.length;
        const competitorTitleLengths = validCompetitors.map(c => (c.title || '').length);
        const avgCompetitorTitleLength = competitorTitleLengths.reduce((sum, l) => sum + l, 0) / competitorTitleLengths.length;

        // Análise comparativa
        const comparison = {
            titleLength: {
                yours: yourTitleLength,
                average: Math.round(avgCompetitorTitleLength),
                difference: yourTitleLength - avgCompetitorTitleLength,
                better: Math.abs(yourTitleLength - 50) < Math.abs(avgCompetitorTitleLength - 50)
            },
            performance: {
                avgCompetitorViews: Math.round(avgViews),
                avgCompetitorLikes: Math.round(avgLikes),
                avgCompetitorComments: Math.round(avgComments)
            },
            recommendations: []
        };

        if (yourTitleLength < 30) {
            comparison.recommendations.push('Seu título é muito curto. Títulos entre 40-60 caracteres performam melhor.');
        } else if (yourTitleLength > 70) {
            comparison.recommendations.push('Seu título é muito longo. Considere reduzir para melhorar CTR.');
        }

        if (avgViews > 100000) {
            comparison.recommendations.push(`Competidores têm média de ${Math.round(avgViews / 1000)}K views. Considere estudar seus títulos.`);
        }

        res.status(200).json({
            yourTitle: title,
            competitors: validCompetitors,
            comparison,
            score: comparison.titleLength.better ? 75 : 50
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/compare-competitors]:', err);
        res.status(500).json({ msg: 'Erro ao comparar com competidores.' });
    }
});

// === ROTAS DE BIBLIOTECA DE TÍTULOS VIRAIS ===

// Adicionar título à biblioteca (automático quando análise é feita)
app.post('/api/library/titles', authenticateToken, async (req, res) => {
    const { title, niche, subniche, originalViews, originalCtr, formulaType, keywords, viralScore } = req.body;
    const userId = req.user.id;

    if (!title) {
        return res.status(400).json({ msg: 'Título é obrigatório.' });
    }

    try {
        const result = await db.run(
            `INSERT INTO viral_titles_library (user_id, title, niche, subniche, original_views, original_ctr, formula_type, keywords, viral_score)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, title, niche || null, subniche || null, originalViews || null, originalCtr || null, formulaType || null, keywords || null, viralScore || null]
        );
        res.status(201).json({ id: result.lastID, msg: 'Título adicionado à biblioteca.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles]:', err);
        res.status(500).json({ msg: 'Erro ao adicionar título à biblioteca.' });
    }
});
// Buscar títulos da biblioteca
app.get('/api/library/titles', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { niche, subniche, minViews, minCtr, favorite, search, page = 1, limit = 6 } = req.query;
    console.log(`[Biblioteca Titles] Requisição recebida para userId: ${userId}`, { niche, subniche, minViews, favorite, search, page, limit });

    try {
        if (!db) {
            console.error('[Biblioteca Titles] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const pageNum = parseInt(page) || 1;
        const limitNum = parseInt(limit) || 6;
        const offset = (pageNum - 1) * limitNum;

        let baseQuery = 'SELECT * FROM viral_titles_library WHERE user_id = ?';
        const params = [userId];
        const countParams = [userId];

        if (niche) {
            baseQuery += ' AND niche = ?';
            params.push(niche);
            countParams.push(niche);
        }
        if (subniche) {
            baseQuery += ' AND subniche = ?';
            params.push(subniche);
            countParams.push(subniche);
        }
        if (minViews) {
            baseQuery += ' AND original_views >= ?';
            params.push(parseInt(minViews));
            countParams.push(parseInt(minViews));
        }
        if (minCtr) {
            baseQuery += ' AND original_ctr >= ?';
            params.push(parseFloat(minCtr));
            countParams.push(parseFloat(minCtr));
        }
        if (favorite === 'true') {
            baseQuery += ' AND is_favorite = 1';
        }
        if (search) {
            baseQuery += ' AND title LIKE ?';
            params.push(`%${search}%`);
            countParams.push(`%${search}%`);
        }

        // Contar total de registros - usar countParams que já foi construído acima
        let countQuery = 'SELECT COUNT(*) as total FROM viral_titles_library WHERE user_id = ?';
        
        if (niche) {
            countQuery += ' AND niche = ?';
        }
        if (subniche) {
            countQuery += ' AND subniche = ?';
        }
        if (minViews) {
            countQuery += ' AND original_views >= ?';
        }
        if (minCtr) {
            countQuery += ' AND original_ctr >= ?';
        }
        if (favorite === 'true') {
            countQuery += ' AND is_favorite = 1';
        }
        if (search) {
            countQuery += ' AND title LIKE ?';
        }
        
        const countResult = await db.get(countQuery, countParams);
        const total = countResult?.total || 0;
        const totalPages = Math.ceil(total / limitNum);

        // Query com paginação
        const query = baseQuery + ` ORDER BY created_at DESC LIMIT ? OFFSET ?`;
        params.push(limitNum, offset);

        console.log(`[Biblioteca Titles] Executando query com paginação: página ${pageNum}, limite ${limitNum}`);
        let titles = [];
        try {
            titles = await db.all(query, params);
            console.log(`[Biblioteca Titles] Títulos encontrados: ${titles.length} de ${total} total`);
        } catch (dbErr) {
            console.error('[Biblioteca Titles] Erro ao buscar títulos:', dbErr);
            titles = [];
        }

        // Garantir que titles é sempre um array
        const titlesArray = Array.isArray(titles) ? titles : [];
        res.status(200).json({
            data: titlesArray,
            pagination: {
                page: pageNum,
                limit: limitNum,
                total: total,
                totalPages: totalPages,
                hasNext: pageNum < totalPages,
                hasPrev: pageNum > 1
            }
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles]:', err);
        // Sempre retornar JSON válido (array vazio), nunca HTML
        res.status(200).json([]);
    }
});

// Excluir títulos em lote (mais rápido que 1 request por item)
app.post('/api/library/titles/bulk-delete', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { ids } = req.body || {};
    if (!Array.isArray(ids) || ids.length === 0) {
        return res.status(400).json({ msg: 'IDs inválidos.' });
    }
    try {
        const cleanIds = ids.map(n => parseInt(n)).filter(n => Number.isFinite(n));
        if (!cleanIds.length) return res.status(400).json({ msg: 'IDs inválidos.' });

        const placeholders = cleanIds.map(() => '?').join(',');
        const result = await db.run(
            `DELETE FROM viral_titles_library WHERE user_id = ? AND id IN (${placeholders})`,
            [userId, ...cleanIds]
        );
        return res.status(200).json({ msg: `${result.changes || 0} título(s) excluído(s) com sucesso.` });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles/bulk-delete]:', err);
        return res.status(500).json({ msg: 'Erro ao excluir títulos selecionados.' });
    }
});

// Excluir título da biblioteca
app.delete('/api/library/titles/:id', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const result = await db.run('DELETE FROM viral_titles_library WHERE id = ? AND user_id = ?', [id, userId]);
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Título não encontrado ou não pertence a este usuário.' });
        }

        console.log(`[Biblioteca] Título ${id} excluído pelo usuário ${userId}`);
        res.status(200).json({ msg: 'Título excluído da biblioteca com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir título da biblioteca.' });
    }
});

// Marcar/desmarcar título como favorito
app.put('/api/library/titles/:id/favorite', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const { isFavorite } = req.body;
    const userId = req.user.id;

    try {
        await db.run(
            'UPDATE viral_titles_library SET is_favorite = ? WHERE id = ? AND user_id = ?',
            [isFavorite ? 1 : 0, id, userId]
        );
        res.status(200).json({ msg: 'Favorito atualizado.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles/:id/favorite]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar favorito.' });
    }
});

// === ROTAS DE BIBLIOTECA DE THUMBNAILS VIRAIS ===

// Adicionar thumbnail à biblioteca
app.post('/api/library/thumbnails', authenticateToken, async (req, res) => {
    const { thumbnailUrl, thumbnailDescription, niche, subniche, originalViews, originalCtr, style, elements, viralScore } = req.body;
    const userId = req.user.id;

    if (!thumbnailUrl && !thumbnailDescription) {
        return res.status(400).json({ msg: 'URL da thumbnail ou descrição é obrigatória.' });
    }

    try {
        const result = await db.run(
            `INSERT INTO viral_thumbnails_library (user_id, thumbnail_url, thumbnail_description, niche, subniche, original_views, original_ctr, style, elements, viral_score)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, thumbnailUrl || null, thumbnailDescription || null, niche || null, subniche || null, originalViews || null, originalCtr || null, style || null, elements || null, viralScore || null]
        );
        res.status(201).json({ id: result.lastID, msg: 'Thumbnail adicionada à biblioteca.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails]:', err);
        res.status(500).json({ msg: 'Erro ao adicionar thumbnail à biblioteca.' });
    }
});

// Buscar thumbnails da biblioteca
app.get('/api/library/thumbnails', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { niche, subniche, minViews, minCtr, favorite, style, search, page, limit } = req.query;
    console.log(`[Biblioteca Thumbnails] Requisição recebida para userId: ${userId}`, { niche, minViews, favorite, style, search });

    try {
        if (!db) {
            console.error('[Biblioteca Thumbnails] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        // Compat: se não vier paginação, manter comportamento antigo (até 100 itens)
        const hasPaging = typeof page !== 'undefined' || typeof limit !== 'undefined';

        let baseWhere = ' FROM viral_thumbnails_library WHERE user_id = ?';
        const params = [userId];

        if (niche) {
            baseWhere += ' AND niche = ?';
            params.push(niche);
        }
        if (subniche) {
            baseWhere += ' AND subniche = ?';
            params.push(subniche);
        }
        if (minViews) {
            baseWhere += ' AND original_views >= ?';
            params.push(parseInt(minViews));
        }
        if (minCtr) {
            baseWhere += ' AND original_ctr >= ?';
            params.push(parseFloat(minCtr));
        }
        if (favorite === 'true') {
            baseWhere += ' AND is_favorite = 1';
        }
        if (style) {
            baseWhere += ' AND style = ?';
            params.push(style);
        }
        if (search) {
            baseWhere += ' AND (niche LIKE ? OR subniche LIKE ? OR thumbnail_description LIKE ?)';
            const searchPattern = `%${search}%`;
            params.push(searchPattern, searchPattern, searchPattern);
        }

        if (!hasPaging) {
            const query = `SELECT *${baseWhere} ORDER BY created_at DESC LIMIT 100`;
            console.log(`[Biblioteca Thumbnails] Executando query (legacy):`, query.substring(0, 120));
            const thumbnails = await db.all(query, params);
            return res.status(200).json(Array.isArray(thumbnails) ? thumbnails : []);
        }

        const pageNum = Math.max(1, parseInt(page || 1));
        const limitNum = Math.min(100, Math.max(1, parseInt(limit || 6)));
        const offset = (pageNum - 1) * limitNum;

        const countQuery = `SELECT COUNT(*) as total${baseWhere}`;
        const countRow = await db.get(countQuery, params);
        const total = countRow?.total || 0;
        const totalPages = Math.max(1, Math.ceil(total / limitNum));

        const dataQuery = `SELECT *${baseWhere} ORDER BY created_at DESC LIMIT ? OFFSET ?`;
        const dataParams = [...params, limitNum, offset];
        const rows = await db.all(dataQuery, dataParams);
        const data = Array.isArray(rows) ? rows : [];

        return res.status(200).json({
            data,
            pagination: {
                page: pageNum,
                limit: limitNum,
                total,
                totalPages,
                hasPrev: pageNum > 1,
                hasNext: pageNum < totalPages
            }
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails]:', err);
        // Sempre retornar JSON válido (array vazio), nunca HTML
        res.status(200).json([]);
    }
});

// Excluir thumbnails em lote
app.post('/api/library/thumbnails/bulk-delete', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { ids } = req.body || {};
    if (!Array.isArray(ids) || ids.length === 0) {
        return res.status(400).json({ msg: 'IDs inválidos.' });
    }
    try {
        const cleanIds = ids.map(n => parseInt(n)).filter(n => Number.isFinite(n));
        if (!cleanIds.length) return res.status(400).json({ msg: 'IDs inválidos.' });

        const placeholders = cleanIds.map(() => '?').join(',');
        const result = await db.run(
            `DELETE FROM viral_thumbnails_library WHERE user_id = ? AND id IN (${placeholders})`,
            [userId, ...cleanIds]
        );
        return res.status(200).json({ msg: `${result.changes || 0} thumbnail(s) excluída(s) com sucesso.` });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails/bulk-delete]:', err);
        return res.status(500).json({ msg: 'Erro ao excluir thumbnails selecionadas.' });
    }
});

// Rota para buscar nichos únicos da biblioteca
app.get('/api/library/niches', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        if (!db) {
            console.error('[Biblioteca Niches] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        // Buscar nichos únicos de títulos e thumbnails
        const titlesNiches = await db.all(
            `SELECT DISTINCT niche FROM viral_titles_library WHERE user_id = ? AND niche IS NOT NULL AND niche != ''`,
            [userId]
        );
        
        const thumbnailsNiches = await db.all(
            `SELECT DISTINCT niche FROM viral_thumbnails_library WHERE user_id = ? AND niche IS NOT NULL AND niche != ''`,
            [userId]
        );

        // Combinar e remover duplicatas
        const allNiches = new Set();
        titlesNiches.forEach(row => {
            if (row.niche) allNiches.add(row.niche);
        });
        thumbnailsNiches.forEach(row => {
            if (row.niche) allNiches.add(row.niche);
        });

        const nichesArray = Array.from(allNiches).sort();
        res.status(200).json({ niches: nichesArray });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/niches]:', err);
        res.status(500).json({ msg: 'Erro ao buscar nichos.' });
    }
});

// Excluir thumbnail da biblioteca
app.delete('/api/library/thumbnails/:id', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const result = await db.run('DELETE FROM viral_thumbnails_library WHERE id = ? AND user_id = ?', [id, userId]);
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Thumbnail não encontrada ou não pertence a este usuário.' });
        }

        console.log(`[Biblioteca] Thumbnail ${id} excluída pelo usuário ${userId}`);
        res.status(200).json({ msg: 'Thumbnail excluída da biblioteca com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir thumbnail da biblioteca.' });
    }
});

// Marcar/desmarcar thumbnail como favorito
app.put('/api/library/thumbnails/:id/favorite', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const { isFavorite } = req.body;
    const userId = req.user.id;

    try {
        await db.run(
            'UPDATE viral_thumbnails_library SET is_favorite = ? WHERE id = ? AND user_id = ?',
            [isFavorite ? 1 : 0, id, userId]
        );
        res.status(200).json({ msg: 'Favorito atualizado.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails/:id/favorite]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar favorito.' });
    }
});

// === ROTAS DE INTEGRAÇÃO YOUTUBE API ===

// Throttle simples para tarefas em background (evita spam e estouro de quota)
const ytBgLastRun = {
    niche: new Map(),   // key: `${userId}:${channelId}`
    locale: new Map()   // key: `${userId}:${channelId}`
};
function shouldRunYtBg(map, key, ttlMs) {
    const now = Date.now();
    const last = map.get(key) || 0;
    if (now - last < ttlMs) return false;
    map.set(key, now);
    return true;
}

// Cache leve em memória para analytics (evita múltiplos refresh seguidos gastando quota)
const ytAnalyticsCache = new Map(); // key -> { expiresAt, payload }
function getYtAnalyticsCache(key) {
    const it = ytAnalyticsCache.get(key);
    if (!it) return null;
    if (Date.now() > it.expiresAt) {
        ytAnalyticsCache.delete(key);
        return null;
    }
    return it.payload;
}
function setYtAnalyticsCache(key, payload, ttlMs = 10 * 60 * 1000) {
    ytAnalyticsCache.set(key, { expiresAt: Date.now() + ttlMs, payload });
}

// Iniciar OAuth do YouTube (retorna URL de autorização)
app.get('/api/youtube/oauth/authorize', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const CLIENT_ID = process.env.YOUTUBE_CLIENT_ID || 'YOUR_CLIENT_ID';
    // Log para debug: verificar qual valor está sendo carregado
    console.log(`[YouTube OAuth] 🔍 DEBUG - YOUTUBE_REDIRECT_URI do process.env: ${process.env.YOUTUBE_REDIRECT_URI || 'NÃO DEFINIDO'}`);
    const REDIRECT_URI = process.env.YOUTUBE_REDIRECT_URI || 'http://localhost:5001/api/youtube/oauth/callback';
    // Escopos necessários: upload de vídeos, gerenciar canal e Analytics (+ monetização para receita estimada)
    const SCOPE = 'https://www.googleapis.com/auth/youtube.upload https://www.googleapis.com/auth/youtube https://www.googleapis.com/auth/youtube.readonly https://www.googleapis.com/auth/yt-analytics.readonly https://www.googleapis.com/auth/yt-analytics-monetary.readonly';

    if (CLIENT_ID === 'YOUR_CLIENT_ID') {
        return res.status(500).json({ msg: 'Credenciais do YouTube não configuradas. Configure YOUTUBE_CLIENT_ID no arquivo .env. Veja CONFIGURACAO_YOUTUBE.md para mais informações.' });
    }

    // Validar e limpar REDIRECT_URI
    let cleanRedirectUri = REDIRECT_URI.trim();
    // Remover barra final se houver
    if (cleanRedirectUri.endsWith('/')) {
        cleanRedirectUri = cleanRedirectUri.slice(0, -1);
    }
    
    // Validar formato do REDIRECT_URI
    // Deve ser http://localhost:5001/api/youtube/oauth/callback (não https e não /api/auth/callback/google)
    if (cleanRedirectUri.includes('https://localhost')) {
        console.warn(`[YouTube OAuth] ⚠️ AVISO: REDIRECT_URI está usando HTTPS. Para desenvolvimento local, use HTTP: ${cleanRedirectUri.replace('https://', 'http://')}`);
        // Corrigir automaticamente para HTTP em desenvolvimento local
        if (cleanRedirectUri.includes('localhost') || cleanRedirectUri.includes('127.0.0.1')) {
            cleanRedirectUri = cleanRedirectUri.replace('https://', 'http://');
            console.log(`[YouTube OAuth] ✅ REDIRECT_URI corrigido automaticamente para: ${cleanRedirectUri}`);
        }
    }
    
    // Validar se o caminho está correto
    if (!cleanRedirectUri.includes('/api/youtube/oauth/callback')) {
        console.error(`[YouTube OAuth] ❌ ERRO: REDIRECT_URI incorreto: ${cleanRedirectUri}`);
        console.error(`[YouTube OAuth] O REDIRECT_URI deve terminar com: /api/youtube/oauth/callback`);
        console.error(`[YouTube OAuth] URI atual: ${cleanRedirectUri}`);
        return res.status(500).json({ 
            msg: `REDIRECT_URI configurado incorretamente. O URI deve ser: http://localhost:5001/api/youtube/oauth/callback (ou seu domínio de produção). URI atual: ${cleanRedirectUri}. Verifique a variável YOUTUBE_REDIRECT_URI no arquivo .env e também no Google Cloud Console.` 
        });
    }

    // Criar um state token seguro com o userId
    // Em produção, você deve usar um token JWT ou criptografado
    const stateToken = Buffer.from(JSON.stringify({ userId, timestamp: Date.now() })).toString('base64');

    // Construir URL de autorização com parâmetros corretos
    const authParams = new URLSearchParams({
        client_id: CLIENT_ID,
        redirect_uri: cleanRedirectUri,
        response_type: 'code',
        scope: SCOPE,
        access_type: 'offline',
        prompt: 'consent', // Força seleção de conta mesmo se já logado
        include_granted_scopes: 'true', // Permite múltiplas contas
        state: stateToken
    });

    const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?${authParams.toString()}`;

    console.log(`[YouTube OAuth] URL de autorização gerada para userId: ${userId}`);
    console.log(`[YouTube OAuth] Redirect URI: ${cleanRedirectUri}`);

    res.status(200).json({ authUrl, msg: 'Use esta URL para autorizar o acesso ao YouTube.' });
});

// Callback OAuth (será chamado pelo Google após autorização)
// NOTA: Este endpoint não usa authenticateToken porque o Google redireciona diretamente
// O userId é validado através do state parameter
app.get('/api/youtube/oauth/callback', async (req, res) => {
    const { code, error, state } = req.query;
    
    let userId = null;
    
    // Decodificar state para obter userId
    try {
        if (state) {
            const stateData = JSON.parse(Buffer.from(state, 'base64').toString());
            userId = stateData.userId;
            
            // Validar que o state não é muito antigo (máximo 10 minutos)
            const maxAge = 10 * 60 * 1000; // 10 minutos
            if (Date.now() - stateData.timestamp > maxAge) {
                return res.status(400).send(`
                    <!DOCTYPE html>
                    <html>
                    <head><title>Erro - Token Expirado</title></head>
                    <body style="font-family: Arial; text-align: center; padding: 50px;">
                        <h1>❌ Token Expirado</h1>
                        <p>O token de autorização expirou. Por favor, tente novamente.</p>
                        <button onclick="window.close()">Fechar</button>
                    </body>
                    </html>
                `);
            }
        } else {
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Erro - Estado Inválido</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px;">
                    <h1>❌ Erro na Autorização</h1>
                    <p>Estado inválido. Por favor, tente conectar novamente.</p>
                    <button onclick="window.close()">Fechar</button>
                </body>
                </html>
            `);
        }
    } catch (e) {
        console.error('[YouTube OAuth] Erro ao decodificar state:', e);
        return res.status(400).send(`
            <!DOCTYPE html>
            <html>
            <head><title>Erro - Estado Inválido</title></head>
            <body style="font-family: Arial; text-align: center; padding: 50px;">
                <h1>❌ Erro na Autorização</h1>
                <p>Estado inválido ou corrompido. Por favor, tente conectar novamente.</p>
                <button onclick="window.close()">Fechar</button>
            </body>
            </html>
        `);
    }

    if (error) {
        console.error('[YouTube OAuth] Erro na autorização:', error);
        return res.status(400).send(`
            <!DOCTYPE html>
            <html>
            <head><title>Erro na Autorização</title></head>
            <body style="font-family: Arial; text-align: center; padding: 50px;">
                <h1>❌ Erro na Autorização</h1>
                <p>${error}</p>
                <button onclick="window.close()">Fechar</button>
            </body>
            </html>
        `);
    }

    if (!code) {
        return res.status(400).json({ msg: 'Código de autorização não fornecido.' });
    }

    const CLIENT_ID = process.env.YOUTUBE_CLIENT_ID || 'YOUR_CLIENT_ID';
    const CLIENT_SECRET = process.env.YOUTUBE_CLIENT_SECRET || 'YOUR_CLIENT_SECRET';
    let REDIRECT_URI = process.env.YOUTUBE_REDIRECT_URI || 'http://localhost:5001/api/youtube/oauth/callback';

    // Limpar e validar REDIRECT_URI
    REDIRECT_URI = REDIRECT_URI.trim();
    if (REDIRECT_URI.endsWith('/')) {
        REDIRECT_URI = REDIRECT_URI.slice(0, -1);
    }

    if (CLIENT_ID === 'YOUR_CLIENT_ID' || CLIENT_SECRET === 'YOUR_CLIENT_SECRET') {
        return res.status(500).json({ msg: 'Credenciais do YouTube não configuradas. Configure YOUTUBE_CLIENT_ID e YOUTUBE_CLIENT_SECRET no arquivo .env' });
    }
    try {
        // Trocar code por access_token e refresh_token
        const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                code: code,
                client_id: CLIENT_ID,
                client_secret: CLIENT_SECRET,
                redirect_uri: REDIRECT_URI,
                grant_type: 'authorization_code',
            }),
        });

        if (!tokenResponse.ok) {
            const errorText = await tokenResponse.text();
            console.error('[YouTube OAuth] Erro ao trocar código por token:', errorText);
            return res.status(400).json({ msg: 'Falha ao obter tokens de acesso.' });
        }

        const tokenData = await tokenResponse.json();
        const { access_token, refresh_token, expires_in } = tokenData;

        if (!access_token) {
            return res.status(400).json({ msg: 'Token de acesso não recebido.' });
        }

        // Buscar TODOS os canais da conta Google (até 50 canais)
        // IMPORTANTE: Uma conta Google pode não ter um canal do YouTube criado automaticamente
        // O usuário precisa criar um canal primeiro em youtube.com
        console.log('[YouTube OAuth] 🔍 Buscando canais da conta Google...');
        
        // Tentar primeiro com mine=true (canais próprios)
        let channelsResponse = await fetch('https://www.googleapis.com/youtube/v3/channels?part=snippet,contentDetails&mine=true&maxResults=50', {
            headers: {
                'Authorization': `Bearer ${access_token}`,
            },
        });
        
        let channelsData = null;
        if (channelsResponse.ok) {
            channelsData = await channelsResponse.json();
        }
        
        // Se não encontrar, tentar buscar canais gerenciados pela conta
        if (!channelsResponse.ok || !channelsData?.items || channelsData.items.length === 0) {
            console.log('[YouTube OAuth] 🔄 Tentando buscar canais gerenciados...');
            channelsResponse = await fetch('https://www.googleapis.com/youtube/v3/channels?part=snippet,contentDetails&managedByMe=true&maxResults=50', {
                headers: {
                    'Authorization': `Bearer ${access_token}`,
                },
            });
            if (channelsResponse.ok) {
                channelsData = await channelsResponse.json();
            }
        }

        let availableChannels = [];
        
        if (channelsResponse.ok && channelsData) {
            console.log('[YouTube OAuth] 📊 Resposta da API de canais:', {
                totalResults: channelsData.pageInfo?.totalResults || 0,
                itemsCount: channelsData.items?.length || 0,
                hasItems: !!channelsData.items,
                error: channelsData.error
            });
            
            if (channelsData.error) {
                console.error('[YouTube OAuth] ❌ Erro na API do YouTube:', JSON.stringify(channelsData.error, null, 2));
                const reason = channelsData?.error?.errors?.[0]?.reason;
                const isQuota = reason === 'quotaExceeded' || String(channelsData?.error?.message || '').toLowerCase().includes('quota');

                // O Google às vezes retorna HTML com link relativo "/youtube/v3/getting-started#quota".
                // Se renderizarmos direto, o link aponta para o NOSSO servidor e gera "Cannot GET /youtube/v3/getting-started".
                const sanitizeGoogleErrorHtml = (raw) => {
                    let msg = String(raw || '').trim();
                    if (!msg) return 'Erro desconhecido';
                    // Preservar o link de quota, mas convertê-lo para URL absoluta do Google
                    msg = msg.replace(/<a\s+href="\/youtube\/v3\/getting-started#quota"\s*>quota<\/a>/gi, '[[QUOTA_LINK]]');
                    // Remover qualquer outro HTML
                    msg = msg.replace(/<[^>]*>/g, '');
                    // Escape básico
                    msg = msg
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                    // Restaurar link absoluto
                    msg = msg.replace(
                        '[[QUOTA_LINK]]',
                        '<a href="https://developers.google.com/youtube/v3/getting-started#quota" target="_blank" rel="noopener noreferrer">quota</a>'
                    );
                    return msg;
                };

                const safeMessageHtml = sanitizeGoogleErrorHtml(channelsData.error.message || 'Erro desconhecido');
                return res.status(400).send(`
                    <!DOCTYPE html>
                    <html>
                    <head><title>Erro ao Buscar Canais</title></head>
                    <body style="font-family: Arial; text-align: center; padding: 50px;">
                        <h1>❌ Erro ao Buscar Canais</h1>
                        <p>Erro: ${safeMessageHtml}</p>
                        <p>Código: ${channelsData.error.code || 'N/A'}</p>
                        ${isQuota ? `
                            <div style="max-width: 680px; margin: 20px auto; text-align: left; background: #f5f5f5; padding: 16px; border-radius: 10px;">
                                <h3 style="margin-top:0;">Por que isso aconteceu?</h3>
                                <p>O projeto do Google Cloud que está sendo usado pela integração atingiu o limite diário de requisições da <strong>YouTube Data API v3</strong> (quotaExceeded).</p>
                                <h3>Como resolver</h3>
                                <ol>
                                    <li>Aguarde a renovação da cota (normalmente em algumas horas, dependendo do fuso do Google).</li>
                                    <li>Ou aumente a cota no Google Cloud Console: <em>YouTube Data API v3 → Quotas</em>.</li>
                                    <li>Evite recarregar essa tela várias vezes seguidas (isso consome quota).</li>
                                </ol>
                            </div>
                        ` : ''}
                        <button onclick="window.close()">Fechar</button>
                    </body>
                    </html>
                `);
            }
            
            if (channelsData.items && channelsData.items.length > 0) {
                availableChannels = channelsData.items.map(item => ({
                    id: item.id,
                    name: item.snippet?.title || 'Canal sem nome',
                    thumbnail: item.snippet?.thumbnails?.default?.url || '',
                    description: item.snippet?.description || ''
                }));
                console.log('[YouTube OAuth] ✅ Canais encontrados:', availableChannels.map(c => ({ id: c.id, name: c.name })));
            } else {
                console.warn('[YouTube OAuth] ⚠️ Nenhum canal encontrado na resposta da API');
            }
        } else {
            const errorText = await channelsResponse.text();
            console.error('[YouTube OAuth] ❌ Erro HTTP ao buscar canais:', {
                status: channelsResponse.status,
                statusText: channelsResponse.statusText,
                error: errorText
            });
            
            let errorMessage = 'Erro ao buscar canais do YouTube.';
            try {
                const errorJson = JSON.parse(errorText);
                errorMessage = errorJson.error?.message || errorMessage;
            } catch (e) {
                // Se não for JSON, usar o texto como está
            }

            // Mesma sanitização: evitar link relativo do Google quebrar no nosso servidor
            const safeErrorMessage = String(errorMessage || '')
                .replace(/<a\s+href="\/youtube\/v3\/getting-started#quota"\s*>quota<\/a>/gi, 'quota (https://developers.google.com/youtube/v3/getting-started#quota)')
                .replace(/<[^>]*>/g, '');
            
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Erro ao Buscar Canais</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px;">
                    <h1>❌ Erro ao Buscar Canais</h1>
                    <p>${safeErrorMessage}</p>
                    <p>Status: ${channelsResponse.status}</p>
                    <button onclick="window.close()">Fechar</button>
                </body>
                </html>
            `);
        }

        if (availableChannels.length === 0) {
            console.warn('[YouTube OAuth] ⚠️ Nenhum canal disponível após processar resposta');
            console.warn('[YouTube OAuth] 📋 Dados da resposta:', JSON.stringify(channelsData, null, 2));
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Nenhum Canal Encontrado</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px; max-width: 600px; margin: 0 auto;">
                    <h1>❌ Nenhum Canal Encontrado</h1>
                    <p>Não foi possível encontrar canais nesta conta Google.</p>
                    <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: left;">
                        <h3 style="margin-top: 0;">Possíveis causas:</h3>
                        <ul>
                            <li>A conta Google não tem um canal do YouTube criado</li>
                            <li>Você precisa criar um canal primeiro em <a href="https://www.youtube.com" target="_blank">youtube.com</a></li>
                            <li>A conta usada não é a mesma que possui o canal</li>
                        </ul>
                        <p><strong>Como criar um canal:</strong></p>
                        <ol>
                            <li>Acesse <a href="https://www.youtube.com" target="_blank">youtube.com</a></li>
                            <li>Clique no seu perfil (canto superior direito)</li>
                            <li>Selecione "Criar um canal" ou "Meu canal"</li>
                            <li>Siga as instruções para criar seu canal</li>
                            <li>Depois, tente conectar novamente aqui</li>
                        </ol>
                    </div>
                    <button onclick="window.close()" style="padding: 10px 20px; font-size: 16px; cursor: pointer;">Fechar</button>
                </body>
                </html>
            `);
        }

        // Verificar quantos canais já estão conectados
        const existingChannelsCount = await db.get(
            'SELECT COUNT(*) as count FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
            [userId]
        );
        const currentCount = existingChannelsCount?.count || 0;
        const maxChannels = 10;
        const remainingSlots = maxChannels - currentCount;

        if (remainingSlots <= 0) {
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Limite Atingido</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px;">
                    <h1>❌ Limite de Canais Atingido</h1>
                    <p>Você já tem 10 canais conectados. Desconecte um canal antes de adicionar outro.</p>
                    <button onclick="window.close()">Fechar</button>
                </body>
                </html>
            `);
        }

        // Verificar quais canais já estão conectados
        const existingChannels = await db.all(
            'SELECT channel_id FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
            [userId]
        );
        const existingChannelIds = new Set(existingChannels.map(c => c.channel_id));

        // Filtrar canais já conectados e limitar aos slots disponíveis
        const selectableChannels = availableChannels
            .filter(ch => !existingChannelIds.has(ch.id))
            .slice(0, remainingSlots);

        if (selectableChannels.length === 0) {
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Todos os Canais Já Conectados</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px;">
                    <h1>ℹ️ Todos os Canais Já Estão Conectados</h1>
                    <p>Todos os canais desta conta Google já estão conectados ou você atingiu o limite de 10 canais.</p>
                    <button onclick="window.close()">Fechar</button>
                </body>
                </html>
            `);
        }

        // Calcular quando o token expira
        const expiresAt = expires_in 
            ? new Date(Date.now() + expires_in * 1000).toISOString()
            : null;

        // Armazenar temporariamente os tokens e dados para processamento posterior
        // Usar uma sessão temporária ou passar via state
        const tempSessionId = `temp_${userId}_${Date.now()}`;
        
        // Salvar dados temporários (em produção, use Redis ou similar)
        // Por enquanto, vamos passar via query params criptografados ou usar uma abordagem diferente
        // Vou criar uma rota POST para processar a seleção
        
        // Retornar página de seleção de canais
        const channelsHTML = selectableChannels.map((channel, index) => `
            <div class="channel-item" style="display: flex; align-items: center; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 8px; margin-bottom: 1rem; cursor: pointer; transition: all 0.3s;" 
                 onmouseover="this.style.background='rgba(255,255,255,0.2)'" 
                 onmouseout="this.style.background='rgba(255,255,255,0.1)'"
                 onclick="toggleChannel('${channel.id}', '${channel.name.replace(/'/g, "\\'")}')">
                <input type="checkbox" id="channel_${channel.id}" value="${channel.id}" style="margin-right: 1rem; width: 20px; height: 20px; cursor: pointer;">
                ${channel.thumbnail ? `<img src="${channel.thumbnail}" style="width: 48px; height: 48px; border-radius: 50%; margin-right: 1rem;" alt="${channel.name}">` : ''}
                <div style="flex: 1;">
                    <div style="font-weight: bold; margin-bottom: 0.25rem;">${channel.name}</div>
                    <div style="font-size: 0.85rem; opacity: 0.8;">ID: ${channel.id}</div>
                </div>
            </div>
        `).join('');

        res.status(200).send(`
            <!DOCTYPE html>
            <html>
            <head>
                <title>Selecionar Canais - YouTube</title>
                <style>
                    * { box-sizing: border-box; }
                    body {
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                        margin: 0;
                        padding: 2rem;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        min-height: 100vh;
                    }
                    .container {
                        max-width: 600px;
                        margin: 0 auto;
                        background: rgba(255, 255, 255, 0.1);
                        border-radius: 15px;
                        padding: 2rem;
                        backdrop-filter: blur(10px);
                    }
                    h1 { margin-top: 0; text-align: center; }
                    .info {
                        background: rgba(255, 255, 255, 0.15);
                        padding: 1rem;
                        border-radius: 8px;
                        margin-bottom: 1.5rem;
                        font-size: 0.9rem;
                    }
                    .channel-item:hover {
                        transform: translateX(5px);
                    }
                    .actions {
                        display: flex;
                        gap: 1rem;
                        margin-top: 2rem;
                    }
                    button {
                        flex: 1;
                        padding: 1rem;
                        border: none;
                        border-radius: 8px;
                        font-size: 1rem;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.3s;
                    }
                    .btn-primary {
                        background: white;
                        color: #667eea;
                    }
                    .btn-primary:hover {
                        background: #f0f0f0;
                        transform: scale(1.02);
                    }
                    .btn-secondary {
                        background: rgba(255, 255, 255, 0.2);
                        color: white;
                    }
                    .btn-secondary:hover {
                        background: rgba(255, 255, 255, 0.3);
                    }
                    .btn-primary:disabled {
                        opacity: 0.5;
                        cursor: not-allowed;
                    }
                </style>
            </head>
            <body>
                <div class="container">
                    <h1>🎬 Selecione os Canais</h1>
                    <div class="info">
                        <strong>📊 Encontrados:</strong> ${selectableChannels.length} canal(is) disponível(is)<br>
                        <strong>✅ Você pode selecionar até:</strong> ${remainingSlots} canal(is)
                    </div>
                    <form id="channelsForm">
                        ${channelsHTML}
                    </form>
                    <div class="actions">
                        <button type="button" class="btn-secondary" onclick="window.close()">Cancelar</button>
                        <button type="button" class="btn-primary" id="connectBtn" onclick="connectSelectedChannels()" disabled>
                            Conectar Canais Selecionados (0)
                        </button>
                    </div>
                </div>
                <script>
                    const selectedChannels = new Set();
                    const channelsData = ${JSON.stringify(selectableChannels)};
                    const accessToken = '${access_token}';
                    const refreshToken = '${refresh_token || ''}';
                    const expiresAt = '${expiresAt || ''}';
                    const userId = ${userId};
                    
                    function toggleChannel(channelId, channelName) {
                        const checkbox = document.getElementById('channel_' + channelId);
                        if (selectedChannels.has(channelId)) {
                            selectedChannels.delete(channelId);
                            checkbox.checked = false;
                        } else {
                            selectedChannels.add(channelId);
                            checkbox.checked = true;
                        }
                        updateButton();
                    }
                    
                    function updateButton() {
                        const btn = document.getElementById('connectBtn');
                        const count = selectedChannels.size;
                        btn.disabled = count === 0;
                        btn.textContent = 'Conectar Canais Selecionados (' + count + ')';
                    }
                    
                    async function connectSelectedChannels() {
                        if (selectedChannels.size === 0) return;
                        
                        const btn = document.getElementById('connectBtn');
                        btn.disabled = true;
                        btn.textContent = 'Conectando...';
                        
                        try {
                            // Detectar a URL base automaticamente
                            // Se estiver em localhost, usar porta 5001, senão usar a mesma origem
                            let apiBase;
                            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                                apiBase = 'http://localhost:5001';
                            } else {
                                // Em produção, usar a mesma origem
                                apiBase = window.location.origin;
                            }
                            
                            const response = await fetch(apiBase + '/api/youtube/oauth/connect-channels', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    userId: userId,
                                    channelIds: Array.from(selectedChannels),
                                    accessToken: accessToken,
                                    refreshToken: refreshToken,
                                    expiresAt: expiresAt
                                })
                            });
                            
                            const data = await response.json();
                            
                            if (response.ok) {
                                try {
                                    if (window.opener) {
                                        window.opener.postMessage({ type: 'youtubeChannelsConnected' }, '*');
                                    }
                                } catch (e) {}
                                document.body.innerHTML = \`
                                    <div class="container" style="text-align: center;">
                                        <h1>✅ Canais Conectados com Sucesso!</h1>
                                        <p>\${data.connected} canal(is) conectado(s)</p>
                                        <p>Você pode fechar esta janela e voltar ao dashboard.</p>
                                        <button class="btn-primary" onclick="window.close()">Fechar</button>
                                    </div>
                                \`;
                            } else {
                                throw new Error(data.msg || 'Erro ao conectar canais');
                            }
                        } catch (err) {
                            alert('Erro: ' + err.message);
                            btn.disabled = false;
                            updateButton();
                        }
                    }
                    
                    // Permitir clicar em qualquer lugar do item para selecionar
                    document.querySelectorAll('.channel-item').forEach(item => {
                        item.addEventListener('click', function(e) {
                            if (e.target.type !== 'checkbox') {
                                const checkbox = this.querySelector('input[type="checkbox"]');
                                checkbox.click();
                            }
                        });
                    });
                </script>
            </body>
            </html>
        `);
    } catch (err) {
        console.error('[YouTube OAuth] Erro no callback:', err);
        return res.status(500).json({ msg: `Erro ao processar autorização: ${err.message}` });
    }
});

// === PARTE 2: AUTOMAÇÃO E INTEGRAÇÃO COM YOUTUBE ===

// A.1 - Agendamento Inteligente: IA sugere melhor horário para publicar baseado no nicho
app.post('/api/youtube/suggest-best-time', authenticateToken, async (req, res) => {
    const { niche, subniche, timezone } = req.body;
    const userId = req.user.id;

    if (!niche) {
        return res.status(400).json({ msg: 'Nicho é obrigatório para sugerir horário.' });
    }

    try {
        // Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem plano que permite API própria OU não tem API própria configurada
        // REGRA CRÍTICA: Se preferência NÃO está marcada E usuário tem plano que permite E tem API própria → usar API própria
        const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
        
        let bestTime = null;
        let explanation = '';
        
        // Se deve usar créditos, usar laozhang.ai primeiro
        if (creditsCheck.shouldUse) {
            const laozhangKey = await getLaozhangApiKey();
            if (laozhangKey) {
                try {
                    const prompt = `Você é um especialista em estratégia de YouTube e análise de dados de engajamento.

Analise o nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''} e sugira o MELHOR horário para publicar vídeos neste nicho.

Considere:
1. Horários de pico de engajamento para este nicho específico
2. Fuso horário do público-alvo (principalmente Brasil/América Latina)
3. Dias da semana que performam melhor
4. Padrões de comportamento do público deste nicho

Responda APENAS com um JSON válido no formato:
{
  "bestTime": "HH:MM" (formato 24h, ex: "18:00"),
  "bestDays": ["segunda", "terça", "quarta", "quinta", "sexta", "sábado", "domingo"] (array com os melhores dias),
  "explanation": "Explicação detalhada do porquê este horário é ideal",
  "alternativeTimes": ["HH:MM", "HH:MM"] (2-3 horários alternativos)
}

IMPORTANTE: Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await callLaozhangAPI(prompt, laozhangKey, 'gpt-4o', null, userId, '/api/youtube/suggest-best-time', JSON.stringify({ endpoint: '/api/youtube/suggest-best-time', model: 'gpt-4o' }));
                    const responseText = response.titles || response.text || '';
                    
                    // Tentar extrair JSON da resposta
                    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.bestTime) {
                                bestTime = parsed;
                                explanation = parsed.explanation || '';
                                console.log(`[Agendamento Inteligente] Horário sugerido usando API configurada como padrão: ${parsed.bestTime}`);
                            }
                        } catch (e) {
                            console.warn(`[Agendamento Inteligente] Falha ao parsear JSON:`, e.message);
                        }
                    }
                } catch (serviceErr) {
                    console.warn(`[Agendamento Inteligente] Falha com API configurada como padrão:`, serviceErr.message);
                }
            }
        }
        
        // Se não usar créditos ou se laozhang falhou, usar APIs próprias
        if (!bestTime) {
            // Tentar usar Gemini primeiro, depois Claude, depois OpenAI
            const services = ['gemini', 'claude', 'openai'];

            for (const service of services) {
                try {
                    const serviceKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                    if (!serviceKeyData) continue;

                    const decryptedKey = decrypt(serviceKeyData.api_key);
                    if (!decryptedKey) continue;

                    let apiCallFunction;
                    let model;
                    if (service === 'gemini') {
                        apiCallFunction = callGeminiAPI;
                        model = 'gemini-2.0-flash';
                    } else if (service === 'claude') {
                        apiCallFunction = callClaudeAPI;
                        model = 'claude-3-5-haiku-20241022';
                    } else {
                        apiCallFunction = callOpenAIAPI;
                        model = 'gpt-4o-mini';
                    }

                    const prompt = `Você é um especialista em estratégia de YouTube e análise de dados de engajamento.

Analise o nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''} e sugira o MELHOR horário para publicar vídeos neste nicho.

Considere:
1. Horários de pico de engajamento para este nicho específico
2. Fuso horário do público-alvo (principalmente Brasil/América Latina)
3. Dias da semana que performam melhor
4. Padrões de comportamento do público deste nicho

Responda APENAS com um JSON válido no formato:
{
  "bestTime": "HH:MM" (formato 24h, ex: "18:00"),
  "bestDays": ["segunda", "terça", "quarta", "quinta", "sexta", "sábado", "domingo"] (array com os melhores dias),
  "explanation": "Explicação detalhada do porquê este horário é ideal",
  "alternativeTimes": ["HH:MM", "HH:MM"] (2-3 horários alternativos)
}

IMPORTANTE: Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await apiCallFunction(prompt, decryptedKey, model);
                    const responseText = response.titles || response.text || '';
                    
                    // Tentar extrair JSON da resposta
                    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.bestTime) {
                                bestTime = parsed;
                                explanation = parsed.explanation || '';
                                console.log(`[Agendamento Inteligente] Horário sugerido usando ${service}: ${parsed.bestTime}`);
                                break;
                            }
                        } catch (e) {
                            console.warn(`[Agendamento Inteligente] Falha ao parsear JSON de ${service}:`, e.message);
                        }
                    }
                } catch (serviceErr) {
                    console.warn(`[Agendamento Inteligente] Falha com ${service}:`, serviceErr.message);
                    continue;
                }
            }
        }

        // Fallback: horários padrão baseados em pesquisas gerais
        if (!bestTime) {
            const defaultTimes = {
                'Entretenimento': { bestTime: '18:00', bestDays: ['sexta', 'sábado', 'domingo'], explanation: 'Horário de pico para entretenimento: fim de tarde e fins de semana' },
                'Educação': { bestTime: '19:00', bestDays: ['segunda', 'terça', 'quarta', 'quinta'], explanation: 'Horário ideal para conteúdo educativo: início da noite em dias úteis' },
                'Tecnologia': { bestTime: '20:00', bestDays: ['terça', 'quarta', 'quinta'], explanation: 'Público de tecnologia mais ativo no início da noite' },
                'Finanças': { bestTime: '08:00', bestDays: ['segunda', 'terça', 'quarta'], explanation: 'Horário de trabalho: público financeiro mais ativo pela manhã' }
            };
            
            const nicheKey = Object.keys(defaultTimes).find(k => niche.toLowerCase().includes(k.toLowerCase()));
            bestTime = nicheKey ? defaultTimes[nicheKey] : { bestTime: '18:00', bestDays: ['sexta', 'sábado'], explanation: 'Horário padrão otimizado para engajamento geral' };
            bestTime.alternativeTimes = ['16:00', '20:00'];
        }

        res.status(200).json({
            suggestedTime: bestTime.bestTime,
            suggestedDays: bestTime.bestDays || ['sexta', 'sábado'],
            explanation: bestTime.explanation || explanation,
            alternativeTimes: bestTime.alternativeTimes || []
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/suggest-best-time]:', err);
        res.status(500).json({ msg: 'Erro ao sugerir horário de publicação.' });
    }
});

// A.3 - Auto-tags e Descrição: Preencher automaticamente tags e descrição otimizadas
app.post('/api/youtube/generate-metadata', authenticateToken, async (req, res) => {
    const { title, model: requestedModel, niche, subniche, videoDescription } = req.body;
    const userId = req.user.id;

    if (!title) {
        return res.status(400).json({ msg: 'Título é obrigatório para gerar metadata.' });
    }

    try {
        // Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem plano que permite API própria OU não tem API própria configurada
        // REGRA CRÍTICA: Se preferência NÃO está marcada E usuário tem plano que permite E tem API própria → usar API própria
        const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
        
        console.log(`[Generate Metadata] shouldUseCredits: ${creditsCheck.shouldUse}, reason: ${creditsCheck.reason}, requestedModel: ${requestedModel}`);
        
        let metadata = null;
        
        // Se deve usar créditos, usar laozhang.ai
        if (creditsCheck.shouldUse) {
            console.log('[Generate Metadata] Verificando chave laozhang.ai...');
            const laozhangKey = await getLaozhangApiKey();
            console.log('[Generate Metadata] Chave laozhang.ai encontrada:', laozhangKey ? 'Sim' : 'Não');
            if (laozhangKey) {
                // Determinar modelo a usar
                let modelToUse = 'gpt-4o';
                if (requestedModel) {
                    if (requestedModel.includes('gpt') || requestedModel === 'gpt-4o') {
                        modelToUse = 'gpt-4o';
                    } else if (requestedModel.includes('claude') || requestedModel === 'claude-3-7-sonnet-20250219') {
                        modelToUse = 'claude-3-7-sonnet-20250219';
                    } else if (requestedModel.includes('gemini') || requestedModel === 'gemini-2.5-pro') {
                        modelToUse = 'gemini-2.5-pro';
                    }
                }
                
                try {
                    const prompt = `Você é um ESPECIALISTA EM ALGORITMO DO YOUTUBE e otimização de conteúdo, com conhecimento profundo sobre como o algoritmo do YouTube classifica, recomenda e promove vídeos.

Título do vídeo: "${title}"
${niche ? `Nicho: "${niche}"` : ''}
${subniche ? `Subnicho: "${subniche}"` : ''}
${videoDescription ? `Descrição do conteúdo: "${videoDescription}"` : ''}

Sua tarefa é gerar metadata ALTAMENTE OTIMIZADA PARA O ALGORITMO DO YOUTUBE:

1. DESCRIÇÃO OTIMIZADA PARA O ALGORITMO DO YOUTUBE (MÁXIMO 500 CARACTERES):
   
   ESTRUTURA OBRIGATÓRIA (seguir EXATAMENTE nesta ordem):
   
   a) PRIMEIRA LINHA (Hook + Palavra-chave principal):
      - Repetir a palavra-chave principal do título nas primeiras palavras
      - Criar um hook que desperte curiosidade e aumente CTR
      - Exemplo: "Descubra como [palavra-chave] mudou tudo..."
   
   b) SEGUNDA E TERCEIRA LINHAS (Conteúdo + Contexto):
      - Expandir o tema usando variações da palavra-chave
      - Adicionar contexto que o algoritmo usa para categorizar
      - Incluir termos relacionados que o YouTube associa ao conteúdo
   
   c) QUARTA LINHA (Call-to-Action):
      - CTA direto para aumentar engajamento (inscrever-se, like, comentar)
      - Use emojis estratégicos (máximo 3-4) para aumentar CTR
   
   d) ÚLTIMA LINHA (Hashtags):
      - 2-3 hashtags relevantes (sem # no início, apenas o texto)
      - Use hashtags que o YouTube reconhece como categorias
   
   REGRAS PARA O ALGORITMO:
   - Palavras-chave principais devem aparecer nas primeiras 125 caracteres (YouTube indexa isso)
   - Use termos que o YouTube associa a vídeos virais no nicho
   - Evite palavras genéricas, seja específico
   - Estrutura clara ajuda o algoritmo a entender o conteúdo
   - MÁXIMO 500 caracteres (o algoritmo prioriza descrições concisas)

2. TAGS OTIMIZADAS PARA O ALGORITMO (25-35 tags):

   DISTRIBUIÇÃO ESTRATÉGICA:
   
   a) Palavras-chave principais (8-10 tags):
      - Extrair todas as palavras-chave importantes do título
      - Incluir variações exatas das palavras do título
      - Exemplo: se título tem "jantar família", incluir "jantar", "família", "jantar família"
   
   b) Long-tail keywords (8-10 tags):
      - Frases de busca que pessoas realmente usam
      - Termos de 3-5 palavras que combinam palavras-chave
      - Exemplo: "jantar em família", "história de família", "testamento família"
   
   c) Termos relacionados ao nicho (5-7 tags):
      - Termos que o YouTube associa ao conteúdo similar
      - Palavras que aparecem em vídeos virais do mesmo tema
      - Termos de tendência no nicho
   
   d) Termos em inglês estratégicos (4-6 tags):
      - Traduções das palavras-chave principais
      - Termos internacionais que aumentam alcance
      - Misture português e inglês
   
   ESTRATÉGIA PARA O ALGORITMO:
   - Primeiras 5 tags são as MAIS IMPORTANTES (YouTube prioriza)
   - Use tags que aparecem em vídeos com alta performance no nicho
   - Evite tags genéricas demais (ex: "vídeo", "youtube")
   - Foque em tags específicas que o algoritmo usa para recomendar
   - Total: 25-35 tags (YouTube permite até 500 caracteres em tags)

REGRAS CRÍTICAS PARA O ALGORITMO:
- Descrição: MÁXIMO 500 caracteres, palavras-chave nas primeiras 125
- Tags: 25-35 tags, primeiras 5 são críticas
- SEO: Otimize para busca E recomendação do algoritmo
- Engajamento: CTAs aumentam sinais de engajamento (algoritmo prioriza)
- Idioma: Português (Brasil) para descrição, português + inglês para tags
- Especificidade: Seja específico, não genérico (algoritmo recompensa)

Responda APENAS com um JSON válido no formato:
{
  "description": "Descrição otimizada para algoritmo do YouTube (máximo 500 caracteres)...",
  "tags": ["tag1", "tag2", "tag3", ...] (25-35 tags, primeiras 5 são as mais importantes)
}

IMPORTANTE: A descrição deve seguir EXATAMENTE a estrutura: Hook+Palavra-chave → Conteúdo → CTA → Hashtags

Responda APENAS com o JSON, sem texto adicional.`;

                    console.log(`[Auto-metadata] Chamando API configurada como padrão com modelo ${modelToUse} para gerar metadata`);
                    const response = await callLaozhangAPI(prompt, laozhangKey, modelToUse, null, userId, '/api/youtube/generate-metadata', JSON.stringify({ endpoint: '/api/youtube/generate-metadata', model: modelToUse }));
                    // callLaozhangAPI retorna uma string diretamente, não um objeto
                    const responseText = typeof response === 'string' ? response : (response?.titles || response?.text || response?.content || JSON.stringify(response) || '');
                    
                    console.log(`[Auto-metadata] Resposta recebida da API configurada como padrão (${responseText.length} caracteres)`);
                    console.log(`[Auto-metadata] Primeiros 500 caracteres da resposta:`, responseText.substring(0, 500));
                    
                    // Verificar se a API recusou a requisição (apenas se for uma mensagem de erro clara, não JSON válido)
                    const hasValidJson = responseText.match(/\{[\s\S]*"description"[\s\S]*\}/) || responseText.match(/\{[\s\S]*"tags"[\s\S]*\}/);
                    
                    if (!hasValidJson) {
                        const errorPatterns = [
                            /^I'm sorry,?\s+I can't assist/i,
                            /^I'm sorry,?\s+I cannot/i,
                            /^I'm unable to assist/i,
                            /^I cannot fulfill/i,
                            /^I must decline/i,
                            /^I can't help with that/i,
                            /^I'm not able to/i,
                            /^This request violates/i,
                            /^I cannot comply/i
                        ];
                        
                        const trimmedResponse = responseText.trim();
                        const isError = errorPatterns.some(pattern => pattern.test(trimmedResponse));
                        
                        if (isError || (trimmedResponse.length < 100 && trimmedResponse.toLowerCase().startsWith("i'm sorry"))) {
                            console.error('[Auto-metadata] API recusou a requisição:', responseText.substring(0, 500));
                            throw new Error(`A API de IA recusou processar o prompt. Isso pode acontecer se o conteúdo violar as políticas de uso da API. Tente simplificar o conteúdo ou remover conteúdo sensível.`);
                        }
                    }
                    
                    // Tentar extrair JSON da resposta - usar regex mais robusto para pegar JSON completo
                    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    // Se não encontrar, tentar remover markdown code blocks
                    if (!jsonMatch) {
                        const cleaned = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                        jsonMatch = cleaned.match(/\{[\s\S]*\}/);
                    }
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.description && parsed.tags && Array.isArray(parsed.tags)) {
                                // Garantir que a descrição não ultrapasse 500 caracteres
                                if (parsed.description.length > 500) {
                                    parsed.description = parsed.description.substring(0, 497) + '...';
                                    console.log(`[Auto-metadata] Descrição truncada para 500 caracteres`);
                                }
                                
                                // Limitar tags a 35 e garantir que sejam strings válidas
                                parsed.tags = parsed.tags
                                    .filter(tag => tag && typeof tag === 'string' && tag.trim().length > 0)
                                    .map(tag => tag.trim())
                                    .slice(0, 35);
                                
                                metadata = parsed;
                                console.log(`[Auto-metadata] ✅ Metadata gerada usando API configurada como padrão com modelo ${modelToUse} (${parsed.tags.length} tags, descrição: ${parsed.description.length} caracteres)`);
                            } else {
                                console.warn(`[Auto-metadata] Resposta da API configurada como padrão não tem formato esperado`);
                                console.warn(`[Auto-metadata] Resposta completa:`, responseText.substring(0, 1000));
                            }
                        } catch (e) {
                            console.warn(`[Auto-metadata] Falha ao parsear JSON:`, e.message);
                        }
                    } else {
                        console.warn(`[Auto-metadata] Nenhum JSON encontrado na resposta da API configurada como padrão`);
                    }
                } catch (serviceErr) {
                    console.error(`[Auto-metadata] Erro ao usar API configurada como padrão:`, serviceErr.message);
                    // Se deve usar créditos e laozhang falhou, não tentar APIs próprias
                    if (creditsCheck.shouldUse) {
                        return res.status(500).json({ 
                            msg: 'Erro ao gerar metadata usando sistema de créditos. Verifique se a chave está configurada corretamente no painel admin.' 
                        });
                    }
                }
            } else if (creditsCheck.shouldUse) {
                // Se deve usar créditos mas não tem chave
                return res.status(400).json({ 
                    msg: 'Sistema de créditos não está configurado. Configure a chave no painel admin ou configure uma API própria nas Configurações.' 
                });
            }
        }
        
        // Se não usar créditos ou se laozhang falhou (e não é obrigatório), usar APIs próprias
        if (!metadata && !creditsCheck.shouldUse) {
            // Se o modelo foi especificado, usar APENAS ele (não tentar todos)
            let service = null;
            let targetModel = requestedModel || null;
            
            if (targetModel) {
                // Mapear modelo para serviço - usar APENAS o serviço correspondente
                if (targetModel.includes('gpt') || targetModel === 'gpt-4o') {
                    service = 'openai';
                    targetModel = 'gpt-4o';
                } else if (targetModel.includes('claude') || targetModel === 'claude-3-7-sonnet-20250219') {
                    service = 'claude';
                    targetModel = 'claude-3-7-sonnet-20250219';
                } else if (targetModel.includes('gemini') || targetModel === 'gemini-2.5-pro') {
                    service = 'gemini';
                    targetModel = 'gemini-2.5-pro';
                }
            }
            
            // Se não especificou modelo ou não encontrou correspondência, tentar todos (fallback)
            const services = service ? [service] : ['gemini', 'claude', 'openai'];

            for (const serviceToUse of services) {
                try {
                    const serviceKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, serviceToUse]);
                    if (!serviceKeyData) {
                        if (service) {
                            // Se especificou um modelo mas não tem a chave, retornar erro
                            return res.status(400).json({ 
                                msg: `Chave de API do ${serviceToUse === 'openai' ? 'OpenAI' : serviceToUse === 'claude' ? 'Claude' : 'Gemini'} não configurada. Configure a chave nas Configurações.` 
                            });
                        }
                        continue;
                    }

                    const decryptedKey = decrypt(serviceKeyData.api_key);
                    if (!decryptedKey) {
                        if (service) {
                            return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
                        }
                        continue;
                    }

                    let apiCallFunction;
                    let model;
                    if (serviceToUse === 'gemini') {
                        apiCallFunction = callGeminiAPI;
                        model = targetModel && targetModel.includes('gemini') ? targetModel : 'gemini-2.5-pro';
                    } else if (serviceToUse === 'claude') {
                        apiCallFunction = callClaudeAPI;
                        model = targetModel && targetModel.includes('claude') ? targetModel : 'claude-3-7-sonnet-20250219';
                    } else {
                        apiCallFunction = callOpenAIAPI;
                        model = targetModel && targetModel.includes('gpt') ? targetModel : 'gpt-4o';
                    }
                    
                    console.log(`[Auto-metadata] Usando ${serviceToUse} com modelo ${model}`);

                    const prompt = `Você é um ESPECIALISTA EM ALGORITMO DO YOUTUBE e otimização de conteúdo, com conhecimento profundo sobre como o algoritmo do YouTube classifica, recomenda e promove vídeos.

Título do vídeo: "${title}"
${niche ? `Nicho: "${niche}"` : ''}
${subniche ? `Subnicho: "${subniche}"` : ''}
${videoDescription ? `Descrição do conteúdo: "${videoDescription}"` : ''}

Sua tarefa é gerar metadata ALTAMENTE OTIMIZADA PARA O ALGORITMO DO YOUTUBE:

1. DESCRIÇÃO OTIMIZADA PARA O ALGORITMO DO YOUTUBE (MÁXIMO 500 CARACTERES):
   
   ESTRUTURA OBRIGATÓRIA (seguir EXATAMENTE nesta ordem):
   
   a) PRIMEIRA LINHA (Hook + Palavra-chave principal):
      - Repetir a palavra-chave principal do título nas primeiras palavras
      - Criar um hook que desperte curiosidade e aumente CTR
      - Exemplo: "Descubra como [palavra-chave] mudou tudo..."
   
   b) SEGUNDA E TERCEIRA LINHAS (Conteúdo + Contexto):
      - Expandir o tema usando variações da palavra-chave
      - Adicionar contexto que o algoritmo usa para categorizar
      - Incluir termos relacionados que o YouTube associa ao conteúdo
   
   c) QUARTA LINHA (Call-to-Action):
      - CTA direto para aumentar engajamento (inscrever-se, like, comentar)
      - Use emojis estratégicos (máximo 3-4) para aumentar CTR
   
   d) ÚLTIMA LINHA (Hashtags):
      - 2-3 hashtags relevantes (sem # no início, apenas o texto)
      - Use hashtags que o YouTube reconhece como categorias
   
   REGRAS PARA O ALGORITMO:
   - Palavras-chave principais devem aparecer nas primeiras 125 caracteres (YouTube indexa isso)
   - Use termos que o YouTube associa a vídeos virais no nicho
   - Evite palavras genéricas, seja específico
   - Estrutura clara ajuda o algoritmo a entender o conteúdo
   - MÁXIMO 500 caracteres (o algoritmo prioriza descrições concisas)

2. TAGS OTIMIZADAS PARA O ALGORITMO (25-35 tags):

   DISTRIBUIÇÃO ESTRATÉGICA:
   
   a) Palavras-chave principais (8-10 tags):
      - Extrair todas as palavras-chave importantes do título
      - Incluir variações exatas das palavras do título
      - Exemplo: se título tem "jantar família", incluir "jantar", "família", "jantar família"
   
   b) Long-tail keywords (8-10 tags):
      - Frases de busca que pessoas realmente usam
      - Termos de 3-5 palavras que combinam palavras-chave
      - Exemplo: "jantar em família", "história de família", "testamento família"
   
   c) Termos relacionados ao nicho (5-7 tags):
      - Termos que o YouTube associa ao conteúdo similar
      - Palavras que aparecem em vídeos virais do mesmo tema
      - Termos de tendência no nicho
   
   d) Termos em inglês estratégicos (4-6 tags):
      - Traduções das palavras-chave principais
      - Termos internacionais que aumentam alcance
      - Misture português e inglês
   
   ESTRATÉGIA PARA O ALGORITMO:
   - Primeiras 5 tags são as MAIS IMPORTANTES (YouTube prioriza)
   - Use tags que aparecem em vídeos com alta performance no nicho
   - Evite tags genéricas demais (ex: "vídeo", "youtube")
   - Foque em tags específicas que o algoritmo usa para recomendar
   - Total: 25-35 tags (YouTube permite até 500 caracteres em tags)

REGRAS CRÍTICAS PARA O ALGORITMO:
- Descrição: MÁXIMO 500 caracteres, palavras-chave nas primeiras 125
- Tags: 25-35 tags, primeiras 5 são críticas
- SEO: Otimize para busca E recomendação do algoritmo
- Engajamento: CTAs aumentam sinais de engajamento (algoritmo prioriza)
- Idioma: Português (Brasil) para descrição, português + inglês para tags
- Especificidade: Seja específico, não genérico (algoritmo recompensa)

Responda APENAS com um JSON válido no formato:
{
  "description": "Descrição otimizada para algoritmo do YouTube (máximo 500 caracteres)...",
  "tags": ["tag1", "tag2", "tag3", ...] (25-35 tags, primeiras 5 são as mais importantes)
}

IMPORTANTE: A descrição deve seguir EXATAMENTE a estrutura: Hook+Palavra-chave → Conteúdo → CTA → Hashtags

Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await apiCallFunction(prompt, decryptedKey, model);
                    // A resposta pode ser string direta ou objeto
                    const responseText = typeof response === 'string' ? response : (response?.titles || response?.text || response?.content || JSON.stringify(response) || '');
                    
                    console.log(`[Auto-metadata] Resposta de ${serviceToUse} (modelo ${model}):`, responseText.substring(0, 200));
                    console.log(`[Auto-metadata] Tamanho da resposta: ${responseText.length} caracteres`);
                    
                    // Tentar extrair JSON da resposta - usar regex mais robusto para pegar JSON completo
                    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    // Se não encontrar, tentar remover markdown code blocks
                    if (!jsonMatch) {
                        const cleaned = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                        jsonMatch = cleaned.match(/\{[\s\S]*\}/);
                    }
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.description && parsed.tags && Array.isArray(parsed.tags)) {
                                // Garantir que a descrição não ultrapasse 500 caracteres
                                if (parsed.description.length > 500) {
                                    parsed.description = parsed.description.substring(0, 497) + '...';
                                    console.log(`[Auto-metadata] Descrição truncada para 500 caracteres`);
                                }
                                
                                // Limitar tags a 35 e garantir que sejam strings válidas
                                // IMPORTANTE: Ordenar tags para que as mais importantes fiquem primeiro (YouTube prioriza)
                                parsed.tags = parsed.tags
                                    .filter(tag => tag && typeof tag === 'string' && tag.trim().length > 0)
                                    .map(tag => tag.trim())
                                    .slice(0, 35);
                                
                                metadata = parsed;
                                console.log(`[Auto-metadata] ✅ Metadata gerada usando ${serviceToUse} com modelo ${model} (${parsed.tags.length} tags, descrição: ${parsed.description.length} caracteres)`);
                                console.log(`[Auto-metadata] Primeiras 5 tags (mais importantes):`, parsed.tags.slice(0, 5).join(', '));
                                break; // Parar o loop quando encontrar sucesso
                            }
                        } catch (e) {
                            console.warn(`[Auto-metadata] Falha ao parsear JSON de ${serviceToUse}:`, e.message);
                        }
                    }
                } catch (serviceErr) {
                    console.warn(`[Auto-metadata] Falha com ${serviceToUse}:`, serviceErr.message);
                    // Se especificou um modelo e falhou, retornar erro
                    if (service) {
                        return res.status(500).json({ 
                            msg: `Erro ao gerar metadata usando ${serviceToUse === 'openai' ? 'OpenAI' : serviceToUse === 'claude' ? 'Claude' : 'Gemini'}. Verifique sua chave de API.` 
                        });
                    }
                    continue;
                }
            }
        }

        // Fallback: gerar metadata básica
        if (!metadata) {
            const keywords = title.toLowerCase().split(/\s+/).filter(w => w.length > 3);
            const fallbackDescription = `${title}\n\n${videoDescription || 'Conteúdo exclusivo sobre ' + (subniche || niche || 'este tema') + '. Não perca!'}\n\n🔔 Inscreva-se no canal para mais conteúdo!\n👍 Deixe seu like se gostou!\n💬 Comente o que achou!\n\n#${(subniche || niche || 'youtube').replace(/\s+/g, '')}`;
            
            // Gerar mais tags do fallback
            const baseTags = keywords.slice(0, 20);
            const nicheTags = [niche, subniche].filter(Boolean);
            const relatedTags = niche ? [
                `${niche} brasil`,
                `${niche} youtube`,
                `${niche} 2025`,
                `vídeo ${niche}`,
                `conteúdo ${niche}`
            ] : [];
            
            metadata = {
                description: fallbackDescription.length > 500 ? fallbackDescription.substring(0, 497) + '...' : fallbackDescription,
                tags: [...baseTags, ...nicheTags, ...relatedTags].slice(0, 35)
            };
        }

        // Validação final: garantir que descrição não ultrapasse 500 caracteres
        if (metadata.description && metadata.description.length > 500) {
            metadata.description = metadata.description.substring(0, 497) + '...';
            console.log(`[Auto-metadata] ⚠️ Descrição final truncada para 500 caracteres`);
        }
        
        // Validação final: garantir que tags sejam válidas e limitadas a 35
        if (metadata.tags && Array.isArray(metadata.tags)) {
            metadata.tags = metadata.tags
                .filter(tag => tag && typeof tag === 'string' && tag.trim().length > 0)
                .map(tag => tag.trim())
                .slice(0, 35);
        }
        
        res.status(200).json({
            description: metadata.description,
            tags: metadata.tags
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/generate-metadata]:', err);
        res.status(500).json({ msg: 'Erro ao gerar metadata.' });
    }
});

// === ROTAS DE GERAÇÃO DE VÍDEO (VEO) ===

// Armazenar operações de geração de vídeo em memória (em produção, usar Redis ou banco)
const videoOperations = new Map();

const decodeOperationId = (encodedId) => {
    try {
        let decoded = decodeURIComponent(encodedId);
        decoded = decoded.replace(/^\/+/, '');
        return decoded;
    } catch (error) {
        console.error('[Veo] Erro ao decodificar operationId:', error.message);
        return encodedId;
    }
};

// POST /api/video/generate - Gerar vídeo usando Veo
app.post('/api/video/generate', authenticateToken, async (req, res) => {
    const {
        prompt,
        model = 'sora_video2-15s',
        aspectRatio = '16:9',
        resolution = '720p',
        mode = 'text-to-video',
        startFrame,
        endFrame,
        referenceImages = [],
        styleImage,
        inputVideo,
        isLooping = false
    } = req.body;

    const userId = req.user.id;

    console.log('[Veo] Dados recebidos do frontend:', {
        prompt: prompt ? `"${prompt.substring(0, 50)}..."` : 'VAZIO',
        model,
        mode,
        aspectRatio,
        resolution,
        hasStartFrame: !!startFrame,
        hasEndFrame: !!endFrame,
        hasReferenceImages: referenceImages?.length > 0,
        hasInputVideo: !!inputVideo
    });

    try {
        // Verificar preferência do usuário (usar créditos ou API própria)
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;

        let useLaozhang = false;
        let useAdminApi = false;
        let adminApi = null;
        let apiKey = null;
        let usingPanelVideoKey = false;
        let apiKeySource = null;
        let userGeminiKeyRow = null;

        let laozhangApiKey = null;
        
        // Se usuário prefere usar créditos, usar Laozhang.ai (obrigatório)
        if (useCredits) {
            laozhangApiKey = await getLaozhangApiKey();
            if (laozhangApiKey) {
                // Normalizar a chave
                if (typeof laozhangApiKey === 'object' && laozhangApiKey.api_key) {
                    laozhangApiKey = laozhangApiKey.api_key;
                } else if (typeof laozhangApiKey === 'string') {
                    laozhangApiKey = laozhangApiKey.trim();
                } else {
                    laozhangApiKey = String(laozhangApiKey).trim();
                }
                
                if (laozhangApiKey && laozhangApiKey.length > 10) {
                    useLaozhang = true;
                    apiKeySource = 'laozhang';
                    console.log('[Veo] ✅ Usando Laozhang.ai com créditos (preferência do usuário)');
                } else {
                    console.warn('[Veo] ⚠️ Chave Laozhang inválida ou muito curta');
                    return res.status(400).json({
                        message: 'Chave do provedor externo inválida. Configure corretamente no painel admin.',
                        details: 'A geração via créditos depende da API configurada no painel admin. Configure a chave corretamente.'
                    });
                }
            } else {
                console.warn('[Veo] ⚠️ Preferência por créditos, mas Laozhang.ai não está configurada');
                return res.status(400).json({
                    message: 'Para usar créditos, configure a chave do provedor externo no painel admin.',
                    details: 'A geração via créditos depende da API configurada no painel admin. Configure a chave ou desmarque a opção de créditos.'
                });
            }
        }
        
        // Só buscar outras APIs se não usar laozhang
        if (!useLaozhang) {
            const panelVideoApiKey = await getAdminVideoApiKey();
            if (panelVideoApiKey) {
                apiKey = panelVideoApiKey;
                usingPanelVideoKey = true;
                apiKeySource = 'panel_video';
                console.log('[Veo] Usando chave de vídeo configurada no painel admin');
            }
        }

        // Se não usar Laozhang, buscar chave do usuário ou admin
        if (!useLaozhang && !usingPanelVideoKey) {
            // Buscar chave do usuário
            const geminiKeyData = await db.get('SELECT id, api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            let userApiKey = null;
            if (geminiKeyData && geminiKeyData.api_key) {
                try {
                    userApiKey = decrypt(geminiKeyData.api_key);
                } catch (decryptError) {
                    console.warn('[Veo] Erro ao descriptografar chave do usuário:', decryptError.message);
                    // Se falhar, tentar usar diretamente (pode não estar criptografada)
                    userApiKey = geminiKeyData.api_key;
                }
            }
            if (userApiKey) {
                userGeminiKeyRow = geminiKeyData;
            }
            // Buscar API do admin (qualquer tipo, mas preferir Gemini)
            adminApi = await getDefaultAdminApi();
            let adminApiKey = null;
            
            // Primeiro tentar buscar API Gemini do admin
            if (adminApi && adminApi.provider === 'gemini' && adminApi.api_key) {
                // Tentar descriptografar a chave do admin se necessário
                if (adminApi.api_key.includes(':')) {
                    try {
                        adminApiKey = decrypt(adminApi.api_key);
                    } catch (decryptError) {
                        console.warn('[Veo] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                        adminApiKey = adminApi.api_key;
                    }
                } else {
                    adminApiKey = adminApi.api_key;
                }
            }
            
            // Se não encontrou Gemini, buscar qualquer API do admin ativa
            if (!adminApiKey && adminApi && adminApi.api_key) {
                console.warn('[Veo] API do admin não é Gemini, mas tentando usar mesmo assim');
                if (adminApi.api_key.includes(':')) {
                    try {
                        adminApiKey = decrypt(adminApi.api_key);
                    } catch (decryptError) {
                        adminApiKey = adminApi.api_key;
                    }
                } else {
                    adminApiKey = adminApi.api_key;
                }
            }

            // Decidir qual chave usar
            if (userApiKey) {
                apiKey = userApiKey;
                apiKeySource = 'user_gemini';
                console.log('[Veo] Usando API própria do usuário');
            } else if (adminApiKey) {
                // Fallback: usar API do admin se própria não disponível
                apiKey = adminApiKey;
                useAdminApi = true;
                apiKeySource = 'admin_provider';
                console.log('[Veo] Usando API do admin (API própria não disponível)');
            }
        }

        // Validar API key antes de usar
        if (!useLaozhang && (!apiKey || apiKey.trim() === '')) {
            console.error('[Veo] ❌ API Key não encontrada ou vazia');
            console.error('[Veo] - useCredits:', useCredits);
            console.error('[Veo] - useLaozhang:', useLaozhang);
            
            // Se preferir créditos mas não tem API, sugerir configurar Laozhang.ai ou API Gemini no admin
            if (useCredits) {
                return res.status(400).json({ 
                    message: 'Para usar créditos na geração de vídeo, configure uma API no painel admin.',
                    details: 'Veo requer uma API configurada no painel admin. Configure no painel admin.'
                });
            }
            
            return res.status(400).json({ 
                message: 'Chave de API do Gemini não configurada ou inválida. Veo requer uma chave do Gemini com billing habilitado. Configure no painel admin (tipo Gemini) ou nas suas configurações.' 
            });
        }
        
        // Se usar Laozhang, usar a API da Laozhang.ai com modelo Veo
        if (useLaozhang) {
            const laozhangKey = laozhangApiKey || await getLaozhangApiKey();
            if (!laozhangKey) {
                return res.status(400).json({ 
                    message: 'Provedor externo não configurado no painel admin. Configure a chave de API primeiro.' 
                });
            }
            
            // Mapear modelo do frontend para modelo Laozhang.ai
            // Documentação: https://docs1.laozhang.ai/api-capabilities/veo/veo-31-overview
            // Para 16:9 (paisagem), usar modelos landscape: veo-3.1-landscape-fast ou veo-3.1-landscape
            // Para outros formatos, usar modelos padrão: veo-3.1-fast ou veo-3.1
            let laozhangModel = model;
            
            // Modo fixo: text-to-video (não suporta image-to-video)
            const isImageToVideo = false; // Sempre false para text-to-video
            
            // Determinar se é paisagem (16:9)
            const isLandscape = aspectRatio === '16:9';
            
            // Mapear modelos Sora 2 (apenas 15s - maior qualidade)
            if (model === 'sora_video2-15s' || model === 'sora_video2-landscape-15s' || model.includes('sora_video2')) {
                // Sora 2 de 15s usa modelos específicos conforme aspect ratio
                // sora_video2-15s = Portrait (704×1280, 15s), sora_video2-landscape-15s = Landscape (1280×704, 15s)
                if (isLandscape) {
                    laozhangModel = 'sora_video2-landscape-15s';
                } else {
                    laozhangModel = 'sora_video2-15s';
                }
                // Sora 2 suporta image-to-video nativamente, não precisa de modelo diferente
                console.log(`[Sora 2 Laozhang] Modelo selecionado: ${laozhangModel} (${isLandscape ? 'Landscape' : 'Portrait'}, 15s)`);
            } else if (model === 'veo-3.1-fast' || model.includes('veo-3.1-fast')) {
                if (isLandscape) {
                    // Para paisagem 16:9, usar modelos landscape
                    laozhangModel = isImageToVideo ? 'veo-3.1-landscape-fast-fl' : 'veo-3.1-landscape-fast';
                } else {
                    // Para outros formatos, usar modelos padrão
                    laozhangModel = isImageToVideo ? 'veo-3.1-fast-fl' : 'veo-3.1-fast';
                }
            } else if (model === 'veo-3.1' || model.includes('veo-3.1')) {
                if (isLandscape) {
                    // Para paisagem 16:9, usar modelos landscape
                    laozhangModel = isImageToVideo ? 'veo-3.1-landscape-fl' : 'veo-3.1-landscape';
                } else {
                    // Para outros formatos, usar modelos padrão
                    laozhangModel = isImageToVideo ? 'veo-3.1-fl' : 'veo-3.1';
                }
            } else {
                // Se já for um modelo específico (Sora 2), usar diretamente
                laozhangModel = model;
            }
            
            const isSora2 = laozhangModel.includes('sora_video2');
            const modelType = isSora2 ? 'Sora 2' : 'Veo';
            console.log(`[${modelType} Laozhang] Modo detectado: ${mode}, Image-to-video: ${isImageToVideo}, Aspect Ratio: ${aspectRatio}, Landscape: ${isLandscape}, Modelo selecionado: ${laozhangModel}`);
            
            console.log(`[${modelType} Laozhang] Usando Laozhang.ai com modelo:`, laozhangModel);
            console.log('[Veo Laozhang] Prompt:', prompt ? `"${prompt.substring(0, 100)}..."` : 'VAZIO');
            
            // Construir payload no formato Chat Completions da Laozhang.ai
            // Documentação: https://docs1.laozhang.ai/api-capabilities/veo/veo-31-overview
            // Formato: messages com role "user" e content como array de objetos {type, text/image_url}
            
            const laozhangMessages = [];
            
            // Adicionar texto do prompt (modo text-to-video)
            if (prompt && prompt.trim()) {
                laozhangMessages.push({
                    type: 'text',
                    text: prompt.trim()
                });
            }
            
            // Modo text-to-video: não adiciona frames, referências ou vídeos de entrada
            // (código removido - apenas text-to-video suportado)
            
            // Construir payload final no formato Chat Completions
            const laozhangPayload = {
                model: laozhangModel,
                messages: [
                    {
                        role: 'user',
                        content: laozhangMessages
                    }
                ],
                stream: true, // Recomendado pela documentação para obter progresso
                n: 1 // Número de vídeos a gerar (1-4)
            };
            
            // Adicionar parâmetros adicionais se necessário
            // Nota: resolução e aspect ratio são controlados pelo modelo escolhido
            // veo-3.1-landscape* para 16:9, outros para formato padrão
            
            try {
                // Laozhang.ai usa endpoint Chat Completions padrão
                const endpoint = LAOZHANG_CHAT_ENDPOINT;
                
                console.log(`[Veo Laozhang] Usando endpoint: ${endpoint}`);
                console.log(`[Veo Laozhang] Modelo: ${laozhangModel}`);
                console.log(`[Veo Laozhang] Modo: ${mode}`);
                console.log(`[Veo Laozhang] Payload (resumido):`, JSON.stringify({
                    model: laozhangPayload.model,
                    messages: laozhangPayload.messages.map(m => ({
                        role: m.role,
                        content: m.content.map(c => c.type === 'text' ? { type: c.type, text: c.text.substring(0, 50) + '...' } : { type: c.type })
                    })),
                    stream: laozhangPayload.stream,
                    n: laozhangPayload.n
                }, null, 2));
                
                // Debitar créditos antes da chamada
                const laozhangProviderId = await getLaozhangApiProviderId();
                if (laozhangProviderId && userId) {
                    // Estimar créditos baseado na resolução e modelo
                    // Sora 2 = $0.15, veo-3.1-fast* = $0.15, veo-3.1 (padrão) = $0.25
                    const isSora2 = laozhangModel.includes('sora_video2');
                    const isFastModel = laozhangModel.includes('fast');
                    const estimatedCredits = (isSora2 || isFastModel) ? 15 : 25; // Aproximado em créditos
                    await checkAndDebitCredits(
                        userId,
                        laozhangProviderId,
                        estimatedCredits,
                        'api_video_generation',
                        JSON.stringify({ 
                            endpoint: '/api/video/generate', 
                            model: laozhangModel, 
                            mode, 
                            resolution, 
                            aspectRatio 
                        })
                    );
                }
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${laozhangKey}`
                    },
                    body: JSON.stringify(laozhangPayload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`[Veo Laozhang] ❌ Erro HTTP ${response.status}:`, errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                // Laozhang.ai retorna stream quando stream=true
                // Processar resposta stream ou JSON
                let laozhangResponse;
                const contentType = response.headers.get('content-type');
                
                // Verificar se o frontend quer SSE para progresso em tempo real
                const acceptHeader = req.headers.accept || '';
                const wantsSSE = acceptHeader.includes('text/event-stream');
                
                if (contentType && contentType.includes('text/event-stream')) {
                    // Resposta é stream - processar eventos SSE
                    console.log('[Veo Laozhang] Resposta é stream, processando eventos SSE...');
                    
                    // Se frontend quer SSE, configurar resposta como SSE
                    if (wantsSSE) {
                        res.setHeader('Content-Type', 'text/event-stream');
                        res.setHeader('Cache-Control', 'no-cache');
                        res.setHeader('Connection', 'keep-alive');
                    }
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    let operationId = null;
                    let fullContent = ''; // Acumular todo o conteúdo
                    let isFinished = false;
                    let lastProgress = 0; // Última porcentagem enviada
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';
                        
                        for (const line of lines) {
                            if (line.trim() === '' || line === '[DONE]') continue;
                            
                            if (line.startsWith('data: ')) {
                                try {
                                    const dataStr = line.substring(6);
                                    if (dataStr === '[DONE]') {
                                        isFinished = true;
                                        break;
                                    }
                                    
                                    const data = JSON.parse(dataStr);
                                    
                                    // Procurar por operationId
                                    if (data.id) {
                                        operationId = data.id;
                                    }
                                    
                                    // Acumular conteúdo dos chunks
                                    if (data.choices && data.choices.length > 0) {
                                        const choice = data.choices[0];
                                        if (choice.delta) {
                                            // Acumular conteúdo se existir
                                            if (choice.delta.content) {
                                                fullContent += choice.delta.content;
                                                console.log('[Veo Laozhang] Conteúdo acumulado:', fullContent.length, 'chars. Último chunk:', choice.delta.content.substring(0, 50));
                                                
                                                // Extrair porcentagem de progresso do conteúdo
                                                // Padrões: "进度：9.0%", "Progress: 36.0%", "🏃 进度：44.9%"
                                                const progressMatch = choice.delta.content.match(/(?:进度|Progress)[：:]\s*(\d+\.?\d*)%/i) || 
                                                                     choice.delta.content.match(/(\d+\.?\d*)%/);
                                                if (progressMatch && progressMatch[1]) {
                                                    const progressPercent = parseFloat(progressMatch[1]);
                                                    if (!isNaN(progressPercent) && progressPercent !== lastProgress) {
                                                        lastProgress = progressPercent;
                                                        console.log(`[Veo Laozhang] 📊 Progresso detectado: ${progressPercent}%`);
                                                        
                                                        // Atualizar progresso na operação se já existir
                                                        if (operationId && videoOperations.has(operationId)) {
                                                            const op = videoOperations.get(operationId);
                                                            op.progress = progressPercent;
                                                            op.progressMessage = `Gerando vídeo... ${progressPercent.toFixed(1)}%`;
                                                            videoOperations.set(operationId, op);
                                                        }
                                                    }
                                                }
                                            }
                                            
                                            // Verificar se há vídeo diretamente no delta
                                            if (choice.delta.video || choice.delta.uri || choice.delta.url) {
                                                const videoUri = choice.delta.video?.uri || choice.delta.uri || choice.delta.url;
                                                console.log('[Veo Laozhang] ✅ Vídeo URI encontrado no delta:', videoUri);
                                                return res.json({
                                                    video: { uri: videoUri },
                                                    status: 'completed',
                                                    message: 'Vídeo gerado com sucesso.'
                                                });
                                            }
                                            
                                            // Verificar outros campos que podem conter o vídeo
                                            if (choice.delta.role === 'assistant' && choice.delta.function_call) {
                                                console.log('[Veo Laozhang] Function call encontrado no delta');
                                            }
                                        }
                                        
                                        // Verificar se terminou
                                        if (choice.finish_reason === 'stop') {
                                            isFinished = true;
                                            console.log('[Veo Laozhang] ✅ Stream finalizado. Conteúdo total acumulado:', fullContent.length, 'caracteres');
                                            if (fullContent.length > 0) {
                                                console.log('[Veo Laozhang] Primeiros 500 chars do conteúdo:', fullContent.substring(0, 500));
                                            }
                                        }
                                    }
                                    
                                    // Se vídeo estiver pronto diretamente no evento
                                    if (data.video || data.uri || data.url) {
                                        const videoUri = data.video?.uri || data.uri || data.url;
                                        return res.json({
                                            video: { uri: videoUri },
                                            status: 'completed',
                                            message: 'Vídeo gerado com sucesso.'
                                        });
                                    }
                                } catch (e) {
                                    // Ignorar linhas que não são JSON
                                    console.warn('[Veo Laozhang] Erro ao parsear evento SSE:', e.message);
                                }
                            }
                        }
                        
                        if (isFinished) break;
                    }
                    
                    // Processar conteúdo completo quando stream terminar
                    if (fullContent && fullContent.trim()) {
                        console.log('[Veo Laozhang] Conteúdo completo recebido (', fullContent.length, 'caracteres):', fullContent.substring(0, 500));
                        
                        // Limpar o conteúdo (pode ter markdown code blocks)
                        let cleanContent = fullContent.trim();
                        cleanContent = cleanContent.replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/```\s*$/i, '');
                        
                        // Tentar parsear como JSON
                        let contentData = null;
                        try {
                            contentData = JSON.parse(cleanContent);
                            console.log('[Veo Laozhang] ✅ Conteúdo parseado como JSON');
                        } catch (parseError) {
                            // Se não for JSON válido, tentar extrair JSON do texto
                            console.log('[Veo Laozhang] Conteúdo não é JSON puro, tentando extrair JSON...');
                            const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
                            if (jsonMatch) {
                                try {
                                    contentData = JSON.parse(jsonMatch[0]);
                                    console.log('[Veo Laozhang] ✅ JSON extraído do texto');
                                } catch (e) {
                                    console.warn('[Veo Laozhang] Não foi possível parsear JSON extraído');
                                }
                            }
                        }
                        
                        // Se conseguiu parsear como JSON
                        if (contentData) {
                            // Procurar vídeo URI em diferentes formatos
                            const videoUri = contentData.video?.uri || 
                                          contentData.video?.url ||
                                          contentData.uri || 
                                          contentData.url ||
                                          contentData.videoUri ||
                                          contentData.video_url;
                            
                            if (videoUri) {
                                console.log('[Veo Laozhang] ✅ Vídeo URI encontrado no JSON:', videoUri);
                                return res.json({
                                    video: { uri: videoUri },
                                    status: 'completed',
                                    message: 'Vídeo gerado com sucesso.'
                                });
                            }
                            
                            // Se contém operationId para polling
                            if (contentData.operationId || contentData.id || contentData.operation) {
                                operationId = contentData.operationId || contentData.id || contentData.operation;
                            }
                        }
                        
                        // Se não encontrou no JSON, tentar extrair URI do texto (regex)
                        console.log('[Veo Laozhang] Tentando extrair URI do texto com regex...');
                        // Padrões mais específicos primeiro, depois genéricos
                        // Sora 2 retorna links em formato markdown: [click here](https://sora.gptkey.asia/assets/sora/xxx.mp4)
                        const uriPatterns = [
                            /\[[^\]]+\]\(([^\)]+\.mp4[^\)]*)\)/g,  // Markdown links [text](url.mp4) - Sora 2
                            /https?:\/\/[^\s"',<>\)]+\.mp4[^\)]*/g,  // URLs .mp4 (prioridade)
                            /https?:\/\/[^\s"',<>\)]+/g,  // URLs completas (sem parênteses no final)
                            /https?:\/\/[^\s"',<>]+/g,  // URLs completas (fallback)
                            /uri["\s:]+["']?([^"'\s]+)["']?/i,  // uri: "url"
                            /url["\s:]+["']?([^"'\s]+)["']?/i   // url: "url"
                        ];
                        
                        for (const pattern of uriPatterns) {
                            const matches = cleanContent.match(pattern);
                            if (matches && matches.length > 0) {
                                console.log('[Veo Laozhang] Matches encontrados:', matches.length, matches.slice(0, 3));
                                
                                // Pegar a primeira URL que parece ser de vídeo
                                let videoUri = matches.find(url => 
                                    url.includes('googleapis.com') || 
                                    url.includes('storage.googleapis.com') ||
                                    url.includes('aliyuncs.com') ||  // Laozhang.ai usa Aliyun CDN
                                    url.includes('sora.gptkey.asia') ||  // Sora 2 CDN
                                    url.includes('mycdn') ||
                                    url.includes('video') ||
                                    url.match(/https?:\/\/[^\s"']+\.mp4/i)
                                ) || matches[0];
                                
                                // Se o match foi de markdown, extrair apenas a URL
                                if (videoUri && videoUri.includes('](')) {
                                    const markdownMatch = videoUri.match(/\]\(([^\)]+)\)/);
                                    if (markdownMatch && markdownMatch[1]) {
                                        videoUri = markdownMatch[1];
                                    }
                                }
                                
                                if (videoUri) {
                                    // Limpar a URL: remover parênteses, colchetes, aspas e outros caracteres inválidos no final
                                    videoUri = videoUri.replace(/[\)\]\}"']+$/, '').trim();
                                    
                                    // Verificar se é uma URL válida
                                    try {
                                        new URL(videoUri);
                                        console.log('[Veo Laozhang] ✅ Vídeo URI extraído e limpo:', videoUri);
                                        console.log('[Veo Laozhang] Retornando resposta com vídeo URI...');
                                        
                                        // IMPORTANTE: Retornar resposta no formato que o frontend espera
                                        // Frontend espera: { status: 'completed', videoUri: '...' }
                                        const responseData = {
                                            status: 'completed',
                                            videoUri: videoUri,
                                            message: 'Vídeo gerado com sucesso.'
                                        };
                                        console.log('[Veo Laozhang] Resposta sendo enviada:', JSON.stringify(responseData));
                                        
                                        // Armazenar também na operação para polling
                                        if (operationId) {
                                            videoOperations.set(operationId, {
                                                userId,
                                                operation: { id: operationId },
                                                useAdminApi: false,
                                                adminApi: null,
                                                createdAt: new Date(),
                                                status: 'completed',
                                                videoUri: videoUri,
                                                useLaozhang: true,
                                                laozhangKey: laozhangKey
                                            });
                                        }
                                        
                                        return res.json(responseData);
                                    } catch (urlError) {
                                        console.warn('[Veo Laozhang] ⚠️ URL extraída não é válida:', videoUri, urlError.message);
                                    }
                                }
                            }
                        }
                        
                        console.warn('[Veo Laozhang] ⚠️ Não foi possível extrair vídeo URI do conteúdo');
                        console.log('[Veo Laozhang] Conteúdo completo para debug:', cleanContent.substring(0, 1000));
                    }
                    
                    // Se chegou aqui e tem operationId, retornar para polling
                    if (operationId) {
                        // Tentar fazer uma chamada adicional para obter o vídeo se o conteúdo não tiver URI
                        // A Laozhang.ai pode retornar o vídeo em uma chamada separada
                        if (fullContent && !fullContent.match(/https?:\/\/[^\s"']+/)) {
                            console.log('[Veo Laozhang] Conteúdo não contém URI, tentando obter vídeo via polling...');
                            
                            // Tentar fazer polling imediatamente (algumas APIs retornam o vídeo logo após)
                            try {
                                // Aguardar um pouco antes de fazer polling
                                await new Promise(resolve => setTimeout(resolve, 2000));
                                
                                // Fazer uma chamada para verificar se o vídeo está pronto
                                // Nota: A Laozhang.ai pode ter um endpoint específico para isso
                                // Por enquanto, armazenar e deixar o polling do frontend verificar
                            } catch (pollError) {
                                console.warn('[Veo Laozhang] Erro ao tentar polling imediato:', pollError.message);
                            }
                        }
                        
                        // Extrair última porcentagem do conteúdo completo
                        let finalProgress = 0;
                        const finalProgressMatch = fullContent.match(/(?:进度|Progress)[：:]\s*(\d+\.?\d*)%/gi);
                        if (finalProgressMatch && finalProgressMatch.length > 0) {
                            const lastMatch = finalProgressMatch[finalProgressMatch.length - 1];
                            const percentMatch = lastMatch.match(/(\d+\.?\d*)%/);
                            if (percentMatch && percentMatch[1]) {
                                finalProgress = parseFloat(percentMatch[1]);
                            }
                        }
                        
                        // Armazenar operação com o conteúdo completo para processamento posterior
                        videoOperations.set(operationId, {
                            userId,
                            operation: { 
                                id: operationId,
                                content: fullContent,
                                model: laozhangModel
                            },
                            useAdminApi: false,
                            adminApi: null,
                            createdAt: new Date(),
                            status: fullContent && fullContent.length > 0 ? 'processing' : 'processing',
                            useLaozhang: true,
                            laozhangKey: laozhangKey,
                            // Armazenar conteúdo para processamento na rota de status
                            rawContent: fullContent,
                            // Armazenar progresso extraído
                            progress: finalProgress,
                            progressMessage: finalProgress > 0 ? `Gerando vídeo... ${finalProgress.toFixed(1)}%` : 'Processando...'
                        });
                        
                        console.log(`[Veo Laozhang] Operação ${operationId} armazenada para polling. Conteúdo (${fullContent.length} chars): ${fullContent.substring(0, 200)}...`);
                        
                        return res.json({
                            operationId: operationId,
                            status: 'processing',
                            message: 'Geração de vídeo iniciada. Use o operationId para verificar o status.'
                        });
                    }
                    
                    // Se não tem operationId nem conteúdo, retornar erro
                    throw new Error('Não foi possível obter operationId ou vídeo da resposta. Conteúdo recebido: ' + (fullContent ? fullContent.substring(0, 200) : 'vazio'));
                } else {
                    // Resposta é JSON normal
                    laozhangResponse = await response.json();
                    console.log(`[Veo Laozhang] ✅ Resposta JSON recebida:`, JSON.stringify(laozhangResponse, null, 2).substring(0, 500));
                }
                
                // Processar resposta JSON
                let responseData = laozhangResponse;
                
                // Se a resposta contém choices (formato Chat Completions)
                if (responseData.choices && responseData.choices.length > 0) {
                    const choice = responseData.choices[0];
                    if (choice.message && choice.message.content) {
                        // Tentar parsear o content como JSON
                        try {
                            const contentData = JSON.parse(choice.message.content);
                            responseData = contentData;
                        } catch (e) {
                            // Se não for JSON, usar o content como está
                            responseData = { content: choice.message.content };
                        }
                    }
                }
                
                // Se a resposta contém operationId ou similar, retornar
                if (responseData.operationId || responseData.operation || responseData.id || responseData.name) {
                    const operationId = responseData.operationId || responseData.operation || responseData.id || responseData.name;
                    
                    // Armazenar operação
                    const laozhangOperation = {
                        userId,
                        operation: responseData,
                        useAdminApi: false,
                        adminApi: null,
                        createdAt: new Date(),
                        status: 'processing',
                        useLaozhang: true,
                        laozhangKey: laozhangKey
                    };
                    videoOperations.set(operationId, laozhangOperation);
                    await cacheVideoOperationMetadata(operationId, userId, {
                        apiKeySource: 'laozhang',
                        useLaozhang: true
                    });
                    
                    return res.json({
                        operationId: operationId,
                        status: 'processing',
                        message: 'Geração de vídeo iniciada. Use o operationId para verificar o status.'
                    });
                }
                
                // Se a resposta contém vídeo diretamente
                if (responseData.video || responseData.uri || responseData.url) {
                    const videoUri = responseData.video?.uri || responseData.uri || responseData.url;
                    // Frontend espera: { status: 'completed', videoUri: '...' }
                    return res.json({
                        status: 'completed',
                        videoUri: videoUri,
                        message: 'Vídeo gerado com sucesso.'
                    });
                }
                
                // Retornar resposta como está
                return res.json({
                    status: 'processing',
                    data: responseData,
                    message: 'Geração de vídeo iniciada.'
                });
                
            } catch (laozhangError) {
                console.error('[Veo Laozhang] Erro ao chamar Laozhang.ai:', laozhangError);
                return res.status(500).json({ 
                    message: 'Erro ao gerar vídeo: ' + (laozhangError.message || 'Erro desconhecido'),
                    details: laozhangError.details || laozhangError.error || 'Erro ao processar requisição'
                });
            }
        }

        // Validar formato da API key (deve começar com AIza ou similar)
        if (!apiKey.startsWith('AIza') && apiKey.length < 20) {
            console.warn('[Veo] ⚠️ API Key pode estar em formato inválido. Esperado formato Google API key.');
        }

        console.log('[Veo] ✅ API Key configurada:', apiKey.substring(0, 10) + '...' + apiKey.substring(apiKey.length - 4));
        console.log('[Veo] - Tamanho da chave:', apiKey.length, 'caracteres');
        console.log('[Veo] - Usando API do admin:', useAdminApi);

        // Construir payload para a API Veo
        const config = {
            numberOfVideos: 1,
            resolution: resolution
        };

        if (mode !== 'extend-video') {
            config.aspectRatio = aspectRatio;
        }

        // Construir payload base
        const generateVideoPayload = {
            model: model,
            config: config
        };

        // Adicionar prompt se fornecido (obrigatório para text-to-video)
        // Para extend-video, o prompt deve enfatizar continuar o vídeo existente
        if (mode === 'extend-video') {
            // Instruções muito específicas para garantir que o vídeo seja estendido, não recriado
            let extendPrompt = `VIDEO EXTENSION REQUEST:

You have been provided with a video. Your task is to EXTEND this video, creating a seamless continuation.

CRITICAL REQUIREMENTS:
1. This is NOT a new video - it is an EXTENSION of the existing video
2. The extended video must start EXACTLY where the provided video ends
3. Maintain IDENTICAL scene, characters, camera angle, lighting, colors, and visual style
4. Create a smooth, natural continuation - it should feel like ONE continuous video
5. The transition between the original and extension must be seamless
6. Do NOT change the scene, location, or context
7. Do NOT introduce new characters or elements that weren't in the original
8. The final output should be a SINGLE continuous video that combines the original 8 seconds with approximately 7 more seconds of extension, totaling around 15 seconds

${prompt && prompt.trim() ? `Additional continuation direction: ${prompt.trim()}` : 'Continue the video naturally, maintaining the exact same visual style and narrative flow.'}

Remember: The goal is to create ONE unified video, not two separate videos. The extension must connect seamlessly.`;
            
            generateVideoPayload.prompt = extendPrompt;
            console.log('[Veo] Prompt para extend-video:', extendPrompt.substring(0, 300));
        } else if (prompt && prompt.trim()) {
            generateVideoPayload.prompt = prompt.trim();
        }

        // Modo: Frames to Video
        if (mode === 'frames-to-video') {
            if (startFrame && startFrame.base64) {
                generateVideoPayload.image = {
                    imageBytes: startFrame.base64,
                    mimeType: startFrame.mimeType || 'image/jpeg'
                };
            }

            const finalEndFrame = isLooping ? startFrame : endFrame;
            if (finalEndFrame && finalEndFrame.base64) {
                generateVideoPayload.config.lastFrame = {
                    imageBytes: finalEndFrame.base64,
                    mimeType: finalEndFrame.mimeType || 'image/jpeg'
                };
            }
        }
        // Modo: References to Video
        else if (mode === 'references-to-video') {
            const referenceImagesPayload = [];

            for (const img of referenceImages) {
                if (img.base64) {
                    referenceImagesPayload.push({
                        image: {
                            imageBytes: img.base64,
                            mimeType: img.mimeType || 'image/jpeg'
                        },
                        referenceType: 'ASSET'
                    });
                }
            }

            if (styleImage && styleImage.base64) {
                referenceImagesPayload.push({
                    image: {
                        imageBytes: styleImage.base64,
                        mimeType: styleImage.mimeType || 'image/jpeg'
                    },
                    referenceType: 'STYLE'
                });
            }

            if (referenceImagesPayload.length > 0) {
                generateVideoPayload.config.referenceImages = referenceImagesPayload;
            }
        }
        // Modo: Extend Video
        else if (mode === 'extend-video') {
            // Para estender, precisamos do URI do vídeo gerado anteriormente
            // ESTRATÉGIA: Extrair o último frame e usar como imagem inicial
            if (!inputVideo) {
                return res.status(400).json({ message: 'Vídeo de entrada é obrigatório para estender.' });
            }
            
            try {
                let videoUri = null;
                if (inputVideo.uri) {
                    videoUri = inputVideo.uri;
                } else if (inputVideo.base64) {
                    const mimeType = inputVideo.mimeType || 'video/mp4';
                    videoUri = `data:${mimeType};base64,${inputVideo.base64}`;
                }
                
                if (videoUri && videoUri.startsWith('http')) {
                    // Baixar vídeo e extrair último frame usando FFmpeg
                    const tempVideoPath = path.join(__dirname, 'temp', `extend_${Date.now()}.mp4`);
                    const tempFramePath = path.join(__dirname, 'temp', `last_frame_${Date.now()}.jpg`);
                    
                    // Criar diretório temp se não existir
                    await fse.ensureDir(path.dirname(tempVideoPath));
                    
                    // Baixar vídeo
                    console.log('[Veo] Baixando vídeo para extrair último frame...');
                    const videoResponse = await axios({
                        url: videoUri,
                        method: 'GET',
                        responseType: 'stream',
                        timeout: 30000,
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (compatible; VideoGeneratorBot/1.0; +https://lacasa.ai)',
                            'Referer': videoUri
                        }
                    });
                    
                    const videoStream = fs.createWriteStream(tempVideoPath);
                    await new Promise((resolve, reject) => {
                        videoResponse.data.pipe(videoStream);
                        videoStream.on('finish', resolve);
                        videoStream.on('error', reject);
                    });
                    
                    // Extrair último frame usando FFmpeg
                    console.log('[Veo] Extraindo último frame com FFmpeg...');
                    await new Promise((resolve, reject) => {
                        ffmpeg(tempVideoPath)
                            .screenshots({
                                timestamps: ['99%'], // Pegar frame em 99% do vídeo
                                filename: path.basename(tempFramePath),
                                folder: path.dirname(tempFramePath),
                                size: '1280x720' // Manter resolução alta
                            })
                            .on('end', () => {
                                console.log('[Veo] ✅ Último frame extraído com sucesso');
                                resolve();
                            })
                            .on('error', (err) => {
                                console.error('[Veo] ❌ Erro ao extrair frame:', err.message);
                                reject(err);
                            });
                    });
                    
                    // Ler frame como base64
                    const frameBuffer = await fs.readFile(tempFramePath);
                    const frameBase64 = frameBuffer.toString('base64');
                    
                    // Limpar arquivos temporários
                    try {
                        await fs.unlink(tempVideoPath);
                        await fs.unlink(tempFramePath);
                    } catch (cleanupErr) {
                        console.warn('[Veo] Aviso ao limpar arquivos temporários:', cleanupErr.message);
                    }
                    
                    // Usar frame como imagem inicial (modo frames-to-video)
                    generateVideoPayload.image = {
                        imageBytes: frameBase64,
                        mimeType: 'image/jpeg'
                    };
                    
                    // Atualizar prompt para enfatizar continuação
                    if (generateVideoPayload.prompt) {
                        generateVideoPayload.prompt = `VIDEO EXTENSION: The image above is the LAST FRAME of an 8-second video. Generate a continuation that starts EXACTLY from this frame, maintains the SAME scene, characters, camera angle, lighting, and visual style, and creates approximately 7 more seconds of video, resulting in a TOTAL of 15 seconds (8s original + 7s extension). The continuation must be SEAMLESS and feel like ONE continuous video. ${generateVideoPayload.prompt}`;
                    }
                    
                    console.log('[Veo] Último frame extraído e configurado como imagem inicial para continuação');
                } else if (inputVideo.uri) {
                    // Fallback: usar URI diretamente se não for HTTP
                    generateVideoPayload.video = {
                        uri: inputVideo.uri
                    };
                } else {
                    return res.status(400).json({ message: 'Para estender um vídeo, você precisa usar um vídeo gerado anteriormente pelo Veo (que possui URI).' });
                }
            } catch (extractError) {
                console.error('[Veo] Erro ao extrair último frame:', extractError.message);
                // Fallback: tentar usar URI diretamente
                if (inputVideo.uri) {
                    generateVideoPayload.video = {
                        uri: inputVideo.uri
                    };
                } else {
                    return res.status(400).json({ message: `Erro ao processar vídeo para extensão: ${extractError.message}` });
                }
            }
        }

        console.log('[Veo] Prompt recebido:', prompt ? `"${prompt.substring(0, 100)}..."` : 'VAZIO');
        console.log('[Veo] Payload completo:', JSON.stringify(generateVideoPayload, null, 2));

        // Usar SDK do Google GenAI para Veo
        // Garantir que a API key está limpa (sem espaços)
        const cleanApiKey = apiKey.trim();
        
        if (!cleanApiKey || cleanApiKey.length === 0) {
            console.error('[Veo] ❌ API Key está vazia após limpeza!');
            return res.status(400).json({ 
                message: 'Chave de API inválida. Verifique se a chave do Gemini está correta e tem billing habilitado para usar o Veo.' 
            });
        }
        
        console.log('[Veo] Inicializando SDK do Google GenAI...');
        console.log('[Veo] - Modelo:', model);
        console.log('[Veo] - API Key (primeiros 10 chars):', cleanApiKey.substring(0, 10));
        
        const ai = new GoogleGenAI({ apiKey: cleanApiKey });
        
        // Garantir que o prompt está presente se necessário
        if (mode === 'text-to-video' && (!prompt || !prompt.trim())) {
            return res.status(400).json({ message: 'Prompt é obrigatório para geração de vídeo a partir de texto.' });
        }

        // O SDK espera o formato exato: model, config, e opcionalmente prompt, image, video, etc.
        // Construir payload exatamente como no exemplo do VETA
        const sdkPayload = {
            model: model,
            config: generateVideoPayload.config
        };

        // Adicionar prompt se existir (obrigatório para text-to-video)
        if (generateVideoPayload.prompt) {
            sdkPayload.prompt = generateVideoPayload.prompt;
            console.log('[Veo] Prompt adicionado ao SDK payload:', sdkPayload.prompt.substring(0, 100));
        } else {
            console.warn('[Veo] ATENÇÃO: Prompt não encontrado no generateVideoPayload!');
            // Se for text-to-video e não tiver prompt, adicionar do parâmetro original
            if (mode === 'text-to-video' && prompt && prompt.trim()) {
                sdkPayload.prompt = prompt.trim();
                console.log('[Veo] Prompt adicionado do parâmetro original:', sdkPayload.prompt.substring(0, 100));
            }
        }

        // Adicionar image se existir (frames-to-video)
        if (generateVideoPayload.image) {
            sdkPayload.image = generateVideoPayload.image;
        }

        // Adicionar video se existir (extend-video)
        if (generateVideoPayload.video) {
            sdkPayload.video = generateVideoPayload.video;
        }

        // referenceImages já está em config.referenceImages, não precisa adicionar separadamente

        console.log('[Veo] Payload completo para SDK:', JSON.stringify(sdkPayload, null, 2).substring(0, 1000));
        console.log('[Veo] Chamando SDK generateVideos com modelo:', model);
        
        // Validar que o modelo está correto
        const validModels = ['veo-3.1-fast-generate-preview', 'veo-3.1-generate-preview'];
        if (!validModels.includes(model)) {
            console.warn(`[Veo] Modelo "${model}" não está na lista de modelos válidos. Usando modelo padrão.`);
            sdkPayload.model = 'veo-3.1-fast-generate-preview';
        }
        
        // Chamar SDK - passar o payload diretamente como no exemplo do VETA
        let operation;
        try {
            operation = await ai.models.generateVideos(sdkPayload);
        } catch (sdkError) {
            console.error('[Veo] Erro ao chamar SDK generateVideos:', sdkError);
            
            // Tratar erros específicos da API
            if (sdkError.status === 400 && sdkError.message?.includes('API key')) {
                return res.status(400).json({ 
                    message: 'Chave de API inválida. Verifique se a chave do Gemini está correta e tem billing habilitado para usar o Veo.',
                    details: 'A chave de API precisa ter acesso ao Veo e billing habilitado no Google Cloud.'
                });
            }
            
            // Re-enviar erro genérico
            return res.status(sdkError.status || 500).json({ 
                message: sdkError.message || 'Erro ao gerar vídeo com Veo.',
                details: sdkError.details || sdkError.error || 'Erro desconhecido'
            });
        }
        
        console.log('[Veo] Operação criada:', operation.name || 'Sem nome');

        // Usar o nome completo da operação como ID (pode conter barras)
        const operationId = operation.name || `operation-${Date.now()}-${crypto.randomBytes(4).toString('hex')}`;
        
        console.log('[Veo] OperationId salvo:', operationId);

        // Armazenar operação usando o operationId completo
        const operationData = {
            userId,
            operation,
            prompt: prompt,
            model: model,
            aspectRatio: aspectRatio,
            resolution: resolution,
            useAdminApi,
            adminApi,
            createdAt: new Date(),
            status: 'processing'
        };
        videoOperations.set(operationId, operationData);
        await cacheVideoOperationMetadata(operationId, userId, {
            apiKeySource: apiKeySource || (useLaozhang ? 'laozhang' : 'unknown'),
            userKeyId: userGeminiKeyRow?.id || null,
            adminApiId: adminApi?.id || null,
            useLaozhang
        });
        
        console.log('[Veo] Operação armazenada. Total de operações:', videoOperations.size);

        // Se usou API do admin, debitar créditos (estimado)
        if (useAdminApi && adminApi) {
            try {
                // Estimar créditos baseado na resolução e modo
                const estimatedCredits = resolution === '1080p' ? 50 : 25;
                const creditResult = await checkAndDebitCredits(
                    userId,
                    adminApi.id,
                    estimatedCredits,
                    'api_video_generation',
                    JSON.stringify({ model, mode, resolution, aspectRatio })
                );
                console.log(`💳 [CRÉDITOS] ${creditResult.creditsUsed.toFixed(2)} créditos debitados. Saldo restante: ${creditResult.newBalance.toFixed(2)}`);
            } catch (creditError) {
                console.error('❌ [CRÉDITOS] Erro ao debitar créditos:', creditError);
            }
        }

        // Iniciar polling em background (usar cleanApiKey)
        pollVideoOperation(operationId, cleanApiKey);

        res.json({
            operationId: operationId,
            status: 'processing',
            message: 'Geração de vídeo iniciada. Use o operationId para verificar o status.'
        });

    } catch (error) {
        console.error('[Veo] Erro ao gerar vídeo:', error);
        if (error.response) {
            console.error('[Veo] Status:', error.response.status);
            console.error('[Veo] Data:', error.response.data);
        }
        
        // Tratar erros específicos
        let errorMessage = 'Erro ao gerar vídeo';
        let statusCode = 500;
        
        if (error.message?.includes('API key') || error.message?.includes('INVALID_ARGUMENT') || 
            error.response?.data?.error?.message?.includes('API key') ||
            error.response?.data?.error?.status === 'INVALID_ARGUMENT') {
            errorMessage = 'Chave de API inválida ou não configurada. Verifique se a chave do Gemini está correta e tem billing habilitado para usar o Veo.';
            statusCode = 400;
        } else if (error.message?.includes('PERMISSION_DENIED') || error.response?.data?.error?.status === 'PERMISSION_DENIED') {
            errorMessage = 'Permissão negada. Verifique se a chave de API tem acesso ao Veo e se o billing está habilitado.';
            statusCode = 403;
        } else if (error.response?.data?.error?.message) {
            errorMessage = error.response.data.error.message;
            statusCode = error.response.status || 500;
        } else if (error.message) {
            errorMessage = error.message;
        }

        res.status(statusCode).json({ 
            message: errorMessage,
            error: error.message || 'Erro desconhecido',
            details: error.response?.data?.error || error.details || null
        });
    }
});

// Função para fazer polling da operação
async function pollVideoOperation(operationId, apiKey) {
    const maxAttempts = 60; // 10 minutos máximo (10s * 60)
    let attempts = 0;

    while (attempts < maxAttempts) {
        try {
            const operationData = videoOperations.get(operationId);
            if (!operationData) {
                console.log(`[Veo] Operação ${operationId} não encontrada`);
                break;
            }

            const operation = operationData.operation;
            if (!operation.name) {
                console.log(`[Veo] Operação ${operationId} sem nome`);
                break;
            }

            // Usar SDK para verificar status
            const ai = new GoogleGenAI({ apiKey: apiKey });
            
            // Obter operação atualizada do SDK (precisa do nome da operação)
            const updatedOperation = await ai.operations.getVideosOperation({ name: operationId });
            
            console.log(`[Veo] Status da operação ${operationId}:`, updatedOperation.done ? 'Concluída' : 'Processando');

            if (updatedOperation.done) {
                // Operação concluída
                if (updatedOperation.response && updatedOperation.response.generatedVideos) {
                    const videos = updatedOperation.response.generatedVideos;
                    if (videos.length > 0 && videos[0].video && videos[0].video.uri) {
                        const videoUri = videos[0].video.uri;
                        
                        console.log(`[Veo] Vídeo gerado. URI: ${videoUri}`);
                        
                        try {
                            // Baixar vídeo - o URI já contém a URL completa
                            let videoUrl = videoUri;
                            if (!videoUrl.includes('key=')) {
                                videoUrl = `${videoUri}${videoUri.includes('?') ? '&' : '?'}key=${apiKey}`;
                            }
                            
                            console.log(`[Veo] Baixando vídeo de: ${videoUrl.substring(0, 100)}...`);
                            
                            const videoResponse = await axios.get(videoUrl, {
                                responseType: 'arraybuffer',
                                timeout: 120000
                            });

                            const videoBuffer = Buffer.from(videoResponse.data);
                            const videoBase64 = videoBuffer.toString('base64');

                            // Atualizar operação
                            videoOperations.set(operationId, {
                                ...operationData,
                                status: 'completed',
                                videoUri: videoUri,
                                videoBase64: videoBase64,
                                videoMimeType: 'video/mp4'
                            });

                            console.log(`[Veo] Vídeo gerado com sucesso: ${operationId} (${videoBuffer.length} bytes)`);
                            await removeVideoOperationCache(operationId);
                            return;
                        } catch (downloadError) {
                            console.error(`[Veo] Erro ao baixar vídeo:`, downloadError.message);
                            // Mesmo com erro no download, retornar o URI para o frontend tentar baixar
                            videoOperations.set(operationId, {
                                ...operationData,
                                status: 'completed',
                                videoUri: videoUri,
                                videoBase64: null,
                                videoMimeType: 'video/mp4',
                                downloadError: downloadError.message
                            });
                            await removeVideoOperationCache(operationId);
                            return;
                        }
                    }
                }

                // Verificar se há erro na operação
                if (updatedOperation.error) {
                    videoOperations.set(operationId, {
                        ...operationData,
                        status: 'error',
                        error: updatedOperation.error.message || 'Erro na geração do vídeo'
                    });
                    await removeVideoOperationCache(operationId);
                } else {
                    videoOperations.set(operationId, {
                        ...operationData,
                        status: 'error',
                        error: 'Nenhum vídeo foi gerado na resposta'
                    });
                    await removeVideoOperationCache(operationId);
                }
                break;
            }

            // Atualizar operação no storage
            videoOperations.set(operationId, {
                ...operationData,
                operation: updatedOperation
            });

            // Ainda processando
            attempts++;
            await new Promise(resolve => setTimeout(resolve, 10000)); // Aguardar 10 segundos

        } catch (error) {
            console.error(`[Veo] Erro ao verificar status da operação ${operationId}:`, error.message);
            videoOperations.set(operationId, {
                ...videoOperations.get(operationId),
                status: 'error',
                error: error.message
            });
            await removeVideoOperationCache(operationId);
            break;
        }
    }

    if (attempts >= maxAttempts) {
        videoOperations.set(operationId, {
            ...videoOperations.get(operationId),
            status: 'timeout',
            error: 'Timeout aguardando conclusão da geração'
        });
        await removeVideoOperationCache(operationId);
    }
}

// GET /api/video/status/:operationId - Verificar status da geração
app.get('/api/video/status/:operationId', authenticateToken, async (req, res) => {
    // Decodificar o operationId (pode conter barras e caracteres especiais)
    let operationId = decodeURIComponent(req.params.operationId);
    const userId = req.user.id;

    console.log('[Veo] Verificando status para operationId:', operationId);
    console.log('[Veo] Operações disponíveis:', Array.from(videoOperations.keys()));

    try {
        const operationData = videoOperations.get(operationId);
        
        if (!operationData) {
            console.warn('[Veo] Operação não encontrada no Map. Tentando reidratar a partir do banco...');
            const cached = await db.get('SELECT * FROM video_operations_cache WHERE operation_id = ?', [operationId]);
            if (cached) {
                const apiKey = await resolveCachedVideoApiKey(cached);
                if (apiKey) {
                    const restoredOperation = {
                        userId: cached.user_id,
                        operation: { name: operationId },
                        status: 'processing',
                        useAdminApi: cached.api_key_source === 'admin_provider',
                        adminApi: cached.admin_api_id ? await db.get('SELECT * FROM api_providers WHERE id = ?', [cached.admin_api_id]) : null,
                        useLaozhang: cached.use_laozhang === 1
                    };
                    videoOperations.set(operationId, restoredOperation);
                    pollVideoOperation(operationId, apiKey);
                    return res.json({ status: 'processing', restored: true, progress: 0, progressMessage: 'Processando...' });
                }
            }
            
            console.error('[Veo] Operação não encontrada nem no cache. OperationId procurado:', operationId);
            console.error('[Veo] Chaves disponíveis:', Array.from(videoOperations.keys()));
            return res.status(404).json({ message: 'Operação não encontrada' });
        }

        if (operationData.userId !== userId) {
            return res.status(403).json({ message: 'Acesso negado' });
        }

        // Extrair progresso atual se disponível
        let currentProgress = operationData.progress || 0;
        let progressMessage = operationData.progressMessage || 'Processando...';
        
        // Se não tem progresso armazenado mas tem conteúdo, tentar extrair
        if (currentProgress === 0 && (operationData.operation?.content || operationData.rawContent)) {
            const content = operationData.operation?.content || operationData.rawContent || '';
            const progressMatch = content.match(/(?:进度|Progress)[：:]\s*(\d+\.?\d*)%/gi);
            if (progressMatch && progressMatch.length > 0) {
                const lastMatch = progressMatch[progressMatch.length - 1];
                const percentMatch = lastMatch.match(/(\d+\.?\d*)%/);
                if (percentMatch && percentMatch[1]) {
                    currentProgress = parseFloat(percentMatch[1]);
                    progressMessage = `Gerando vídeo... ${currentProgress.toFixed(1)}%`;
                    // Atualizar operação com progresso extraído
                    operationData.progress = currentProgress;
                    operationData.progressMessage = progressMessage;
                    videoOperations.set(operationId, operationData);
                }
            }
        }
        
        // Se for Laozhang.ai e tiver conteúdo, processar para extrair vídeo URI
        if (operationData.useLaozhang && (operationData.operation?.content || operationData.rawContent) && !operationData.videoUri) {
            try {
                let content = operationData.operation?.content || operationData.rawContent || '';
                console.log('[Veo Laozhang] Processando conteúdo para extrair vídeo URI (', content.length, 'chars)');
                
                if (!content || content.trim().length === 0) {
                    console.warn('[Veo Laozhang] ⚠️ Conteúdo vazio, não é possível extrair vídeo URI');
                } else {
                    console.log('[Veo Laozhang] Primeiros 500 chars do conteúdo:', content.substring(0, 500));
                    
                    // Limpar o conteúdo (pode ter markdown code blocks)
                    let cleanContent = content.trim();
                    cleanContent = cleanContent.replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/```\s*$/i, '');
                    
                    // Tentar parsear como JSON
                    let contentData = null;
                    try {
                        contentData = JSON.parse(cleanContent);
                        console.log('[Veo Laozhang] ✅ Conteúdo parseado como JSON');
                    } catch (parseError) {
                        // Se não for JSON válido, tentar extrair JSON do texto
                        console.log('[Veo Laozhang] Conteúdo não é JSON puro, tentando extrair JSON...');
                        const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            try {
                                contentData = JSON.parse(jsonMatch[0]);
                                console.log('[Veo Laozhang] ✅ JSON extraído do texto');
                            } catch (e) {
                                console.warn('[Veo Laozhang] Não foi possível parsear JSON extraído');
                            }
                        }
                    }
                    
                    // Se conseguiu parsear como JSON
                    if (contentData) {
                        // Procurar vídeo URI em diferentes formatos
                        const videoUri = contentData.video?.uri || 
                                      contentData.video?.url ||
                                      contentData.uri || 
                                      contentData.url ||
                                      contentData.videoUri ||
                                      contentData.video_url ||
                                      contentData.result?.video?.uri ||
                                      contentData.result?.uri;
                        
                        if (videoUri) {
                            console.log('[Veo Laozhang] ✅ Vídeo URI encontrado no JSON:', videoUri);
                            // Atualizar operação com vídeo URI
                            videoOperations.set(operationId, {
                                ...operationData,
                                videoUri: videoUri,
                                status: 'completed'
                            });
                            
                            return res.json({
                                status: 'completed',
                                videoUri: videoUri,
                                videoBase64: null,
                                videoMimeType: 'video/mp4',
                                error: null,
                                downloadError: null
                            });
                        }
                    }
                    
                    // Se não encontrou no JSON, tentar extrair URI do texto (regex)
                    console.log('[Veo Laozhang] Tentando extrair URI do texto com regex...');
                    const uriPatterns = [
                        /https?:\/\/[^\s"',<>]+/g,  // URLs completas
                        /uri["\s:]+["']?([^"'\s]+)["']?/i,  // uri: "url"
                        /url["\s:]+["']?([^"'\s]+)["']?/i   // url: "url"
                    ];
                    
                    for (const pattern of uriPatterns) {
                        const matches = cleanContent.match(pattern);
                        if (matches && matches.length > 0) {
                            // Pegar a primeira URL que parece ser de vídeo
                            let videoUri = matches.find(url => 
                                url.includes('googleapis.com') || 
                                url.includes('storage.googleapis.com') ||
                                url.includes('aliyuncs.com') ||  // Laozhang.ai usa Aliyun CDN
                                url.includes('mycdn') ||
                                url.includes('video') ||
                                url.match(/https?:\/\/[^\s"']+\.mp4/i)
                            ) || matches[0];
                            
                            if (videoUri) {
                                // Limpar a URL: remover parênteses, colchetes, aspas e outros caracteres inválidos no final
                                videoUri = videoUri.replace(/[\)\]\}"']+$/, '').trim();
                                
                                // Verificar se é uma URL válida
                                try {
                                    new URL(videoUri);
                                    console.log('[Veo Laozhang] ✅ Vídeo URI extraído e limpo:', videoUri);
                                    // Atualizar operação com vídeo URI
                                    videoOperations.set(operationId, {
                                        ...operationData,
                                        videoUri: videoUri,
                                        status: 'completed'
                                    });
                                    
                                    return res.json({
                                        status: 'completed',
                                        videoUri: videoUri,
                                        videoBase64: null,
                                        videoMimeType: 'video/mp4',
                                        error: null,
                                        downloadError: null
                                    });
                                } catch (urlError) {
                                    console.warn('[Veo Laozhang] ⚠️ URL extraída não é válida:', videoUri);
                                }
                            }
                        }
                    }
                    
                    console.warn('[Veo Laozhang] ⚠️ Não foi possível extrair vídeo URI do conteúdo');
                }
            } catch (error) {
                console.error('[Veo Laozhang] Erro ao processar conteúdo:', error);
            }
        }
        
        // Se o vídeo foi concluído, salvar no banco de dados
        if (operationData.status === 'completed' && operationData.videoUri) {
            try {
                // A tabela já deve existir (criada na inicialização), mas garantimos que existe
                await db.exec(`
                    CREATE TABLE IF NOT EXISTS generated_videos (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        operation_id TEXT UNIQUE NOT NULL,
                        video_uri TEXT NOT NULL,
                        prompt TEXT,
                        model TEXT,
                        aspect_ratio TEXT,
                        resolution TEXT,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                    )
                `);
                
                // Verificar se já existe
                const existing = await db.get(
                    'SELECT id FROM generated_videos WHERE operation_id = ?',
                    [operationId]
                );
                
                if (!existing) {
                    // Salvar vídeo gerado
                    await db.run(`
                        INSERT INTO generated_videos (
                            user_id, operation_id, video_uri, prompt, model, aspect_ratio, resolution
                        ) VALUES (?, ?, ?, ?, ?, ?, ?)
                    `, [
                        userId,
                        operationId,
                        operationData.videoUri,
                        operationData.prompt || null,
                        operationData.model || null,
                        operationData.aspectRatio || null,
                        operationData.resolution || null
                    ]);
                    console.log('[Video History] ✅ Vídeo salvo no histórico:', operationId);
                }
            } catch (error) {
                console.error('[Video History] Erro ao salvar vídeo no histórico:', error);
            }
        }
        
        res.json({
            status: operationData.status,
            videoUri: operationData.videoUri || null,
            videoBase64: operationData.videoBase64 || null,
            videoMimeType: operationData.videoMimeType || null,
            error: operationData.error || null,
            downloadError: operationData.downloadError || null,
            progress: currentProgress,
            progressMessage: progressMessage
        });

    } catch (error) {
        console.error('[Veo] Erro ao verificar status:', error);
        res.status(500).json({ message: 'Erro ao verificar status' });
    }
});

// GET /api/video/download/:operationId - Baixar vídeo gerado
app.get('/api/video/download/:operationId', authenticateToken, async (req, res) => {
    // Decodificar o operationId
    let operationId = decodeURIComponent(req.params.operationId);
    const userId = req.user.id;

    try {
        const operationData = videoOperations.get(operationId);
        
        if (!operationData) {
            return res.status(404).json({ message: 'Operação não encontrada' });
        }

        if (operationData.userId !== userId) {
            return res.status(403).json({ message: 'Acesso negado' });
        }

        if (operationData.status !== 'completed') {
            return res.status(400).json({ message: 'Vídeo ainda não está pronto' });
        }

        // Se tiver base64, retornar diretamente
        if (operationData.videoBase64) {
            const videoBuffer = Buffer.from(operationData.videoBase64, 'base64');
            res.setHeader('Content-Type', operationData.videoMimeType || 'video/mp4');
            res.setHeader('Content-Disposition', `attachment; filename="video-${Date.now()}.mp4"`);
            res.setHeader('Content-Length', videoBuffer.length);
            return res.send(videoBuffer);
        }

        // Se não tiver base64 mas tiver URI, baixar do Google e servir
        if (operationData.videoUri) {
            // Buscar API key
            const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            let apiKey = null;
            
            if (geminiKeyData) {
                apiKey = decrypt(geminiKeyData.api_key);
            } else if (operationData.useAdminApi && operationData.adminApi) {
                apiKey = operationData.adminApi.api_key;
            }

            if (!apiKey) {
                return res.status(500).json({ message: 'Chave de API não encontrada' });
            }

            // Adicionar key ao URI se não tiver
            let videoUrl = operationData.videoUri;
            if (!videoUrl.includes('key=')) {
                videoUrl = `${operationData.videoUri}${operationData.videoUri.includes('?') ? '&' : '?'}key=${apiKey}`;
            }

            // Baixar vídeo do Google
            const videoResponse = await axios.get(videoUrl, {
                responseType: 'arraybuffer',
                timeout: 120000
            });

            const videoBuffer = Buffer.from(videoResponse.data);
            res.setHeader('Content-Type', operationData.videoMimeType || 'video/mp4');
            res.setHeader('Content-Disposition', `attachment; filename="video-${Date.now()}.mp4"`);
            res.setHeader('Content-Length', videoBuffer.length);
            return res.send(videoBuffer);
        }

        return res.status(404).json({ message: 'Vídeo não disponível' });

    } catch (error) {
        console.error('[Veo] Erro ao baixar vídeo:', error);
        res.status(500).json({ message: 'Erro ao baixar vídeo' });
    }
});

// Endpoint para fazer upload temporário de arquivo para agendamento
app.post('/api/youtube/schedule/upload', authenticateToken, async (req, res) => {
    try {
        const uploadsDir = path.join(__dirname, 'uploads', 'scheduled');
        await fse.ensureDir(uploadsDir);
        
        const form = formidable.formidable({
            uploadDir: uploadsDir,
            keepExtensions: true,
            maxFileSize: 10 * 1024 * 1024 * 1024 // 10GB
        });
        
        form.parse(req, async (err, fields, files) => {
            if (err) {
                console.error('[Schedule Upload] Erro ao processar:', err);
                return res.status(500).json({ msg: 'Erro ao processar arquivo.', error: err.message });
            }
            
            const videoFile = Array.isArray(files.video) ? files.video[0] : files.video;
            const thumbnailFile = files.thumbnail ? (Array.isArray(files.thumbnail) ? files.thumbnail[0] : files.thumbnail) : null;
            
            if (!videoFile) {
                return res.status(400).json({ msg: 'Arquivo de vídeo não fornecido.' });
            }
            
            const videoPath = videoFile.filepath;
            const thumbnailPath = thumbnailFile ? thumbnailFile.filepath : null;
            
            res.status(200).json({
                videoPath: path.relative(__dirname, videoPath),
                thumbnailPath: thumbnailPath ? path.relative(__dirname, thumbnailPath) : null
            });
        });
    } catch (err) {
        console.error('[Schedule Upload] Erro:', err);
        return res.status(500).json({ msg: 'Erro ao fazer upload do arquivo.', error: err.message });
    }
});

// Agendar publicação de vídeo (mantido para compatibilidade, mas agora com suporte a auto-metadata)
app.post('/api/youtube/schedule', authenticateToken, async (req, res) => {
    const { youtubeIntegrationId, channelId, videoFilePath, title, description, tags, thumbnailPath, scheduledTime, privacy = 'private', autoGenerateMetadata } = req.body;
    const userId = req.user.id;

    if (!title || !scheduledTime) {
        return res.status(400).json({ msg: 'Título e horário agendado são obrigatórios.' });
    }
    
    // Se channelId foi fornecido mas não youtubeIntegrationId, buscar integrationId
    let integrationId = youtubeIntegrationId;
    if (!integrationId && channelId) {
        const integration = await db.get(
            'SELECT id FROM youtube_integrations WHERE channel_id = ? AND user_id = ? AND is_active = 1',
            [channelId, userId]
        );
        if (integration) {
            integrationId = integration.id;
        }
    }

    try {
        let finalDescription = description;
        let finalTags = tags;

        // Se autoGenerateMetadata estiver ativado, gerar automaticamente
        if (autoGenerateMetadata) {
            try {
                // Buscar niche/subniche do usuário ou do vídeo
                const userChannel = await db.get('SELECT niche, subniche FROM user_channels WHERE user_id = ? LIMIT 1', [userId]);
                const metadata = await fetch(`${req.protocol}://${req.get('host')}/api/youtube/generate-metadata`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': req.headers['authorization']
                    },
                    body: JSON.stringify({
                        title: title,
                        niche: userChannel?.niche || null,
                        subniche: userChannel?.subniche || null
                    })
                });

                if (metadata.ok) {
                    const metadataData = await metadata.json();
                    finalDescription = metadataData.description || description;
                    finalTags = metadataData.tags || tags;
                    console.log('[Agendamento] Metadata gerada automaticamente');
                }
            } catch (metaErr) {
                console.warn('[Agendamento] Falha ao gerar metadata automática, usando valores fornecidos:', metaErr.message);
            }
        }

        const result = await db.run(
            `INSERT INTO scheduled_posts (user_id, youtube_integration_id, video_file_path, title, description, tags, thumbnail_url, scheduled_time)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, integrationId || null, videoFilePath || null, title, finalDescription || null, finalTags ? JSON.stringify(finalTags) : null, thumbnailPath || null, scheduledTime]
        );
        res.status(201).json({ id: result.lastID, msg: 'Publicação agendada com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/schedule]:', err);
        res.status(500).json({ msg: 'Erro ao agendar publicação.' });
    }
});

// Listar todos os canais conectados do YouTube
app.get('/api/youtube/channels', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        // Buscar canais incluindo niche, subniche e access_token para re-análise
        const integrations = await db.all(
            'SELECT id, channel_id, channel_name, token_expires_at, created_at, is_active, niche, subniche, language, country, access_token FROM youtube_integrations WHERE user_id = ? AND is_active = 1 ORDER BY created_at DESC',
            [userId]
        );

        // Verificar se há canais sem nicho/idioma e re-analisar em background
        const channelsWithoutNiche = integrations.filter(c => !c.niche || c.niche === null);
        const channelsWithoutLocale = integrations.filter(c => (!c.language || c.language === null) || (!c.country || c.country === null));
        if (channelsWithoutNiche.length > 0) {
            console.log(`[YouTube Channels] 🔍 Encontrados ${channelsWithoutNiche.length} canais sem nicho, iniciando re-análise em background...`);
            channelsWithoutNiche.forEach(channel => {
                const bgKey = `${userId}:${channel.channel_id}`;
                if (!shouldRunYtBg(ytBgLastRun.niche, bgKey, 6 * 60 * 60 * 1000)) return; // 6h
                // Re-analisar em background (não bloquear a resposta)
                if (channel.access_token) {
                    try {
                        const accessToken = decryptToken(channel.access_token, 'YouTube Channels Re-analysis');
                        if (!accessToken) {
                            console.warn(`[YouTube Channels] Token inválido para canal ${channel.channel_id}, pulando re-análise`);
                            return; // Usar return ao invés de continue em forEach
                        }
                        // Usar timeout para evitar travamento
                        Promise.race([
                            analyzeChannelNiche(channel.channel_id, channel.channel_name, accessToken, userId),
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Timeout: Análise demorou mais de 60 segundos')), 60000)
                            )
                        ])
                        .then(nicheAnalysis => {
                            if (nicheAnalysis && (nicheAnalysis.niche || nicheAnalysis.subniche)) {
                                console.log(`[YouTube Channels] ✅ Nicho detectado para ${channel.channel_name}: ${nicheAnalysis.niche} / ${nicheAnalysis.subniche}`);
                                db.run(
                                    `UPDATE youtube_integrations 
                                     SET niche = ?, subniche = ?, updated_at = CURRENT_TIMESTAMP 
                                     WHERE id = ?`,
                                    [nicheAnalysis.niche, nicheAnalysis.subniche, channel.id]
                                ).catch(err => {
                                    console.error(`[YouTube Channels] ❌ Erro ao salvar nicho:`, err.message);
                                });
                            } else {
                                // Definir nicho padrão se não conseguir detectar
                                console.log(`[YouTube Channels] ⚠️ Definindo nicho padrão para ${channel.channel_name}`);
                                db.run(
                                    `UPDATE youtube_integrations 
                                     SET niche = 'Entretenimento', subniche = NULL, updated_at = CURRENT_TIMESTAMP 
                                     WHERE id = ?`,
                                    [channel.id]
                                ).catch(err => {
                                    console.error(`[YouTube Channels] Erro ao definir nicho padrão:`, err.message);
                                });
                            }
                        })
                        .catch(err => {
                            console.warn(`[YouTube Channels] ⚠️ Erro ao re-analisar canal ${channel.channel_id}:`, err.message);
                            // Definir nicho padrão em caso de erro
                            db.run(
                                `UPDATE youtube_integrations 
                                 SET niche = 'Entretenimento', subniche = NULL, updated_at = CURRENT_TIMESTAMP 
                                 WHERE id = ?`,
                                [channel.id]
                            ).catch(updateErr => {
                                console.error(`[YouTube Channels] Erro ao definir nicho padrão após erro:`, updateErr.message);
                            });
                        });
                    } catch (decryptErr) {
                        console.error(`[YouTube Channels] Erro ao descriptografar token do canal ${channel.channel_id}:`, decryptErr.message);
                    }
                }
            });
        }

        if (channelsWithoutLocale.length > 0) {
            console.log(`[YouTube Channels] 🌍 Encontrados ${channelsWithoutLocale.length} canais sem idioma/país, buscando em background...`);
            channelsWithoutLocale.forEach(channel => {
                if (!channel.access_token) return;
                const bgKey = `${userId}:${channel.channel_id}`;
                if (!shouldRunYtBg(ytBgLastRun.locale, bgKey, 6 * 60 * 60 * 1000)) return; // 6h
                try {
                    const accessToken = decryptToken(channel.access_token, 'YouTube Channels Locale');
                    if (!accessToken) return;

                    // Buscar snippet do canal para idioma/país
                    fetch(`https://www.googleapis.com/youtube/v3/channels?part=snippet&id=${channel.channel_id}`, {
                        headers: { 'Authorization': `Bearer ${accessToken}` }
                    })
                    .then(r => r.ok ? r.json() : null)
                    .then(json => {
                        const snippet = json?.items?.[0]?.snippet;
                        if (!snippet) return;
                        const lang = snippet.defaultLanguage || snippet.defaultAudioLanguage || null;
                        const country = snippet.country || null;
                        if (!lang && !country) return;

                        return db.run(
                            `UPDATE youtube_integrations 
                             SET language = COALESCE(language, ?), country = COALESCE(country, ?), updated_at = CURRENT_TIMESTAMP
                             WHERE id = ?`,
                            [lang, country, channel.id]
                        );
                    })
                    .catch(() => {});
                } catch (_) {}
            });
        }

        const channels = integrations.map(integration => {
            const isExpired = integration.token_expires_at 
                ? new Date(integration.token_expires_at) < new Date()
                : false;
            
            return {
                id: integration.id,
                channelId: integration.channel_id,
                channelName: integration.channel_name,
                niche: integration.niche || null,
                subniche: integration.subniche || null,
                language: integration.language || null,
                country: integration.country || null,
                isExpired: isExpired,
                createdAt: integration.created_at
            };
        });

        return res.status(200).json({
            channels: channels,
            count: channels.length,
            maxChannels: 10
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/channels]:', err);
        return res.status(500).json({ msg: 'Erro ao listar canais.' });
    }
});

// Verificar status da integração do YouTube (mantido para compatibilidade)
app.get('/api/youtube/status', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const integrations = await db.all(
            'SELECT * FROM youtube_integrations WHERE user_id = ? AND is_active = 1 ORDER BY created_at DESC',
            [userId]
        );

        if (!integrations || integrations.length === 0) {
            return res.status(200).json({ 
                connected: false, 
                message: 'Nenhuma integração configurada.',
                channels: []
            });
        }

        // Retornar o canal mais recente para compatibilidade
        const latestIntegration = integrations[0];
        const isExpired = latestIntegration.token_expires_at 
            ? new Date(latestIntegration.token_expires_at) < new Date()
            : false;

        return res.status(200).json({
            connected: true,
            channelId: latestIntegration.channel_id,
            channelName: latestIntegration.channel_name,
            isExpired: isExpired,
            createdAt: latestIntegration.created_at,
            totalChannels: integrations.length,
            channels: integrations.map(i => ({
                id: i.id,
                channelId: i.channel_id,
                channelName: i.channel_name,
                isExpired: i.token_expires_at ? new Date(i.token_expires_at) < new Date() : false
            }))
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/status]:', err);
        return res.status(500).json({ msg: 'Erro ao verificar status da integração.' });
    }
});

// Processar seleção de canais após OAuth (rota interna, chamada pela página de seleção)
// NOTA: Esta rota é chamada pela página de seleção após OAuth válido
app.post('/api/youtube/oauth/connect-channels', async (req, res) => {
    const { userId, channelIds, accessToken, refreshToken, expiresAt } = req.body;

    if (!userId || !channelIds || !Array.isArray(channelIds) || channelIds.length === 0) {
        return res.status(400).json({ msg: 'Dados inválidos.' });
    }

    if (!accessToken) {
        return res.status(400).json({ msg: 'Token de acesso não fornecido.' });
    }

    // Validar que userId é um número válido
    const userIdNum = parseInt(userId);
    if (isNaN(userIdNum) || userIdNum <= 0) {
        return res.status(400).json({ msg: 'ID de usuário inválido.' });
    }

    try {
        // Buscar informações dos canais selecionados
        const channelIdsParam = channelIds.join(',');
        const channelsInfoResponse = await fetch(
            `https://www.googleapis.com/youtube/v3/channels?part=snippet&id=${channelIdsParam}`,
            {
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                },
            }
        );

        if (!channelsInfoResponse.ok) {
            throw new Error('Falha ao buscar informações dos canais');
        }

        const channelsInfo = await channelsInfoResponse.json();
        if (!channelsInfo.items || channelsInfo.items.length === 0) {
            throw new Error('Nenhum canal encontrado');
        }

        // Verificar limite antes de conectar
        const existingChannelsCount = await db.get(
            'SELECT COUNT(*) as count FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
            [userIdNum]
        );
        const currentCount = existingChannelsCount?.count || 0;
        const maxChannels = 10;
        const remainingSlots = maxChannels - currentCount;

        if (channelIds.length > remainingSlots) {
            return res.status(400).json({ 
                msg: `Você só pode adicionar mais ${remainingSlots} canal(is). Você selecionou ${channelIds.length}.` 
            });
        }

        // Verificar quais canais já estão conectados
        const existingChannels = await db.all(
            'SELECT channel_id FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
            [userId]
        );
        const existingChannelIds = new Set(existingChannels.map(c => c.channel_id));

        let connectedCount = 0;
        let updatedCount = 0;

        // Conectar cada canal selecionado
        for (const channelItem of channelsInfo.items) {
            const channelId = channelItem.id;
            const channelName = channelItem.snippet?.title || 'Canal do YouTube';
            const channelCountry = channelItem.snippet?.country || null;
            const channelLanguage = channelItem.snippet?.defaultLanguage || channelItem.snippet?.defaultAudioLanguage || null;

            // Pular se já está conectado
            if (existingChannelIds.has(channelId)) {
                continue;
            }

            // Verificar se já existe (mas inativo)
            const existingIntegration = await db.get(
                'SELECT id FROM youtube_integrations WHERE user_id = ? AND channel_id = ?',
                [userIdNum, channelId]
            );

            // Conectar o canal primeiro (sem bloquear na análise)
            let integrationId;
            if (existingIntegration) {
                // Atualizar integração existente
                await db.run(
                    `UPDATE youtube_integrations 
                     SET access_token = ?, refresh_token = ?, token_expires_at = ?, 
                         channel_name = ?, language = ?, country = ?, is_active = 1, updated_at = CURRENT_TIMESTAMP 
                     WHERE id = ?`,
                    [accessToken, refreshToken || null, expiresAt, channelName, channelLanguage, channelCountry, existingIntegration.id]
                );
                integrationId = existingIntegration.id;
                updatedCount++;
            } else {
                // Criar nova integração
                const result = await db.run(
                    `INSERT INTO youtube_integrations (user_id, channel_id, channel_name, language, country, access_token, refresh_token, token_expires_at, is_active)
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1)`,
                    [userIdNum, channelId, channelName, channelLanguage, channelCountry, accessToken, refreshToken || null, expiresAt]
                );
                integrationId = result.lastID;
                connectedCount++;
            }

            // === Sincronizar para Analytics e Performance (user_channels) ===
            // Isso permite que o canal conectado já apareça no seletor de "Analytics e Performance".
            try {
                const existingUserChannel = await db.get(
                    'SELECT id FROM user_channels WHERE user_id = ? AND (channel_id = ? OR channel_name = ?) LIMIT 1',
                    [userIdNum, channelId, channelName]
                );
                const channelUrl = `https://www.youtube.com/channel/${channelId}`;
                if (existingUserChannel) {
                    await db.run(
                        `UPDATE user_channels
                         SET channel_url = ?, channel_id = ?, language = ?, country = ?, is_active = 1, updated_at = CURRENT_TIMESTAMP
                         WHERE id = ? AND user_id = ?`,
                        [channelUrl, channelId, channelLanguage || 'pt-BR', channelCountry || 'BR', existingUserChannel.id, userIdNum]
                    );
                } else {
                    await db.run(
                        `INSERT INTO user_channels (user_id, channel_name, channel_url, channel_id, niche, language, country, is_active)
                         VALUES (?, ?, ?, ?, NULL, ?, ?, 1)`,
                        [userIdNum, channelName, channelUrl, channelId, channelLanguage || 'pt-BR', channelCountry || 'BR']
                    );
                }
            } catch (syncErr) {
                console.warn('[YouTube OAuth] Falha ao sincronizar user_channels:', syncErr.message);
            }

            // Analisar canal em background (não bloqueia a resposta)
            // Executar análise de nicho de forma assíncrona (não bloquear a resposta)
            // Adicionar timeout de 60 segundos para evitar travamento infinito
            const nicheAnalysisPromise = Promise.race([
                analyzeChannelNiche(channelId, channelName, accessToken, userIdNum),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Timeout: Análise de nicho demorou mais de 60 segundos')), 60000)
                )
            ]);
            
            nicheAnalysisPromise
                .then(nicheAnalysis => {
                    if (nicheAnalysis && (nicheAnalysis.niche || nicheAnalysis.subniche)) {
                        console.log(`[YouTube OAuth] ✅ Nicho detectado para ${channelName}: ${nicheAnalysis.niche} / ${nicheAnalysis.subniche}`);
                        // Atualizar o canal com o nicho detectado
                        db.run(
                            `UPDATE youtube_integrations 
                             SET niche = ?, subniche = ?, updated_at = CURRENT_TIMESTAMP 
                             WHERE id = ?`,
                            [nicheAnalysis.niche, nicheAnalysis.subniche, integrationId]
                        ).catch(err => {
                            console.error(`[YouTube OAuth] ❌ Erro ao salvar nicho detectado:`, err.message);
                        });
                        // Atualizar também no user_channels (Analytics e Performance)
                        db.run(
                            `UPDATE user_channels
                             SET niche = COALESCE(niche, ?), updated_at = CURRENT_TIMESTAMP
                             WHERE user_id = ? AND channel_id = ?`,
                            [nicheAnalysis.niche, userIdNum, channelId]
                        ).catch(() => {});
                    } else {
                        console.log(`[YouTube OAuth] ⚠️ Nenhum nicho detectado para ${channelName}`);
                        // Marcar como analisado mesmo sem nicho para não ficar travado
                        db.run(
                            `UPDATE youtube_integrations 
                             SET niche = 'Entretenimento', subniche = NULL, updated_at = CURRENT_TIMESTAMP 
                             WHERE id = ? AND niche IS NULL`,
                            [integrationId]
                        ).catch(err => {
                            console.error(`[YouTube OAuth] Erro ao atualizar nicho padrão:`, err.message);
                        });
                    }
                })
                .catch(nicheErr => {
                    console.warn(`[YouTube OAuth] ⚠️ Erro ao analisar nicho do canal ${channelId}:`, nicheErr.message);
                    // Definir nicho padrão para não ficar travado
                    db.run(
                        `UPDATE youtube_integrations 
                         SET niche = 'Entretenimento', subniche = NULL, updated_at = CURRENT_TIMESTAMP 
                         WHERE id = ? AND niche IS NULL`,
                        [integrationId]
                    ).catch(err => {
                        console.error(`[YouTube OAuth] Erro ao definir nicho padrão após erro:`, err.message);
                    });
                });
        }

        console.log(`[YouTube OAuth] Canais conectados: ${connectedCount} novos, ${updatedCount} atualizados para userId: ${userIdNum}`);

        return res.status(200).json({
            msg: 'Canais conectados com sucesso!',
            connected: connectedCount + updatedCount,
            new: connectedCount,
            updated: updatedCount
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/oauth/connect-channels]:', err);
        return res.status(500).json({ msg: `Erro ao conectar canais: ${err.message}` });
    }
});

// Desconectar/remover um canal
// Endpoint para buscar métricas do canal usando YouTube Analytics API
app.get('/api/youtube/channels/:id/analytics', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;
    const { startDate, endDate, metrics = 'views,estimatedMinutesWatched,subscribersGained,likes,comments,shares,averageViewDuration,averageViewPercentage,impressions,impressionsCtr' } = req.query;

    try {
        // Buscar integração do canal (id pode ser integration.id ou channel_id)
        let integration = await db.get(
            'SELECT channel_id, access_token, refresh_token, token_expires_at, id FROM youtube_integrations WHERE id = ? AND user_id = ? AND is_active = 1',
            [id, userId]
        );
        
        // Se não encontrou por id, tentar por channel_id
        if (!integration) {
            integration = await db.get(
                'SELECT channel_id, access_token, refresh_token, token_expires_at, id FROM youtube_integrations WHERE channel_id = ? AND user_id = ? AND is_active = 1',
                [id, userId]
            );
        }

        if (!integration) {
            return res.status(404).json({ msg: 'Canal não encontrado ou não conectado.' });
        }

        // Verificar e renovar token se necessário
        let accessToken = null;
        if (integration.access_token) {
            accessToken = decrypt(integration.access_token);
            if (!accessToken) {
                console.error(`[YouTube Analytics] Erro ao descriptografar token para canal ${id}`);
                // Tentar renovar token se refresh_token disponível
                if (integration.refresh_token) {
                    try {
                        accessToken = await refreshYouTubeToken(integration.refresh_token, userId, integration.id);
                        console.log(`[YouTube Analytics] Token renovado com sucesso para canal ${id}`);
                    } catch (refreshErr) {
                        console.error(`[YouTube Analytics] Erro ao renovar token:`, refreshErr.message);
                        return res.status(500).json({ msg: 'Erro ao acessar credenciais do canal. Tente reconectar o canal.' });
                    }
                } else {
                    return res.status(500).json({ msg: 'Erro ao acessar credenciais do canal. Tente reconectar o canal.' });
                }
            }
        } else {
            return res.status(500).json({ msg: 'Token de acesso não encontrado. Reconecte o canal.' });
        }
        if (integration.token_expires_at && new Date(integration.token_expires_at) < new Date()) {
            if (!integration.refresh_token) {
                return res.status(401).json({ msg: 'Token expirado. Reconecte o canal.' });
            }
            accessToken = await refreshYouTubeToken(integration.refresh_token, userId, id);
        }

        const channelId = integration.channel_id;
        
        // Datas padrão: últimos 30 dias
        const end = endDate ? new Date(endDate) : new Date();
        const start = startDate ? new Date(startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
        
        // Formatar datas para API (YYYY-MM-DD)
        const startDateStr = start.toISOString().split('T')[0];
        const endDateStr = end.toISOString().split('T')[0];

        // Cache leve (evita recarregar a cada clique e estourar quota)
        const cacheKey = `${userId}:${integration.id}:${startDateStr}:${endDateStr}`;
        const cached = getYtAnalyticsCache(cacheKey);
        if (cached) {
            return res.status(200).json({ ...cached, cache: { hit: true } });
        }

        const fetchYouTubeAnalyticsReport = async ({ metricsList, dimensions, sort, maxResults, currency }) => {
            const params = new URLSearchParams({
                ids: `channel==${channelId}`,
                startDate: startDateStr,
                endDate: endDateStr,
                metrics: metricsList.join(',')
            });
            if (dimensions) params.set('dimensions', dimensions);
            if (sort) params.set('sort', sort);
            if (maxResults) params.set('maxResults', String(maxResults));
            if (currency) params.set('currency', currency);

            const url = `https://youtubeanalytics.googleapis.com/v2/reports?${params.toString()}`;
            const r = await fetch(url, {
                headers: { 'Authorization': `Bearer ${accessToken}`, 'Accept': 'application/json' }
            });
            const bodyText = await r.text();
            let json = null;
            try { json = bodyText ? JSON.parse(bodyText) : null; } catch (_) { json = null; }
            return { ok: r.ok, status: r.status, json, text: bodyText };
        };

        const normalizeMetrics = (metricsStr) => {
            return String(metricsStr || '')
                .split(',')
                .map(m => m.trim())
                .filter(Boolean);
        };

        // Buscar métricas do YouTube Analytics API (com fallback caso algumas métricas não estejam disponíveis)
        // Tentar puxar o máximo possível (inclui monetização) — a API pode negar se o canal não for monetizado/scope insuficiente.
        const requestedMetrics = Array.from(new Set([
            ...normalizeMetrics(metrics),
            'views',
            'estimatedMinutesWatched',
            'subscribersGained',
            'likes',
            'comments',
            'shares',
            'averageViewDuration',
            'averageViewPercentage',
            'impressions',
            'impressionsCtr',
            // Monetização (quando disponível)
            'estimatedRevenue',
            'estimatedAdRevenue',
            'grossRevenue',
            'adImpressions',
            'monetizedPlaybacks',
            'playbackBasedCpm'
        ]));
        const fallbackCandidates = [
            requestedMetrics,
            requestedMetrics.filter(m => !['estimatedRevenue','estimatedAdRevenue','grossRevenue','adImpressions','monetizedPlaybacks','playbackBasedCpm'].includes(m)),
            requestedMetrics.filter(m => !['impressions', 'impressionsCtr', 'averageViewDuration', 'averageViewPercentage'].includes(m)),
            ['views', 'estimatedMinutesWatched', 'subscribersGained', 'likes', 'comments', 'shares']
        ];

        console.log(`[YouTube Analytics] Buscando métricas para canal ${channelId} de ${startDateStr} até ${endDateStr}`);

        let analyticsData = null;
        let analyticsMeta = { usedMetrics: null, degraded: false };
        let lastAnalyticsError = null;

        for (const candidate of fallbackCandidates) {
            const unique = Array.from(new Set(candidate));
            const result = await fetchYouTubeAnalyticsReport({ metricsList: unique, currency: 'USD' });
            if (result.ok && result.json) {
                analyticsData = result.json;
                analyticsMeta.usedMetrics = unique;
                analyticsMeta.degraded = unique.join(',') !== requestedMetrics.join(',');
                break;
            }
            lastAnalyticsError = result.text || JSON.stringify(result.json || {});
        }

        if (!analyticsData) {
            console.error('[YouTube Analytics] Falha ao buscar métricas (mesmo com fallback):', lastAnalyticsError);
            return res.status(502).json({
                msg: 'Erro ao buscar métricas do YouTube Analytics.',
                error: lastAnalyticsError
            });
        }

        // Série temporal diária (para gráficos + fallback de receita/avançadas)
        let daily = null;
        try {
            const dailyMetricsCandidates = [
                ['views', 'estimatedMinutesWatched', 'subscribersGained', 'impressions', 'impressionsCtr', 'averageViewDuration', 'averageViewPercentage', 'estimatedRevenue', 'estimatedAdRevenue', 'adImpressions', 'monetizedPlaybacks', 'playbackBasedCpm'],
                ['views', 'estimatedMinutesWatched', 'subscribersGained', 'impressions', 'impressionsCtr', 'averageViewDuration', 'averageViewPercentage'],
                ['views', 'estimatedMinutesWatched', 'subscribersGained']
            ];
            for (const cand of dailyMetricsCandidates) {
                const dailyResult = await fetchYouTubeAnalyticsReport({
                    metricsList: cand,
                    dimensions: 'day',
                    sort: 'day'
                });
                if (dailyResult.ok && dailyResult.json) {
                    daily = dailyResult.json;
                    break;
                }
            }
        } catch (e) {
            daily = null;
        }

        // Fontes de tráfego (Top)
        let trafficSources = null;
        try {
            const trafficResult = await fetchYouTubeAnalyticsReport({
                metricsList: ['views', 'estimatedMinutesWatched'],
                // Dimensão correta no YouTube Analytics é insightTrafficSourceType
                dimensions: 'insightTrafficSourceType',
                sort: '-views',
                maxResults: 8
            });
            if (trafficResult.ok && trafficResult.json) trafficSources = trafficResult.json;
        } catch (e) {
            trafficSources = null;
        }

        // Países (Top)
        let topCountries = null;
        try {
            const countriesResult = await fetchYouTubeAnalyticsReport({
                metricsList: ['views'],
                dimensions: 'country',
                sort: '-views',
                maxResults: 8
            });
            if (countriesResult.ok && countriesResult.json) topCountries = countriesResult.json;
        } catch (e) {
            topCountries = null;
        }
        
        // Buscar estatísticas do canal (subscribers, views totais, etc.)
        const channelStatsUrl = `https://www.googleapis.com/youtube/v3/channels?part=statistics,snippet&id=${channelId}`;
        const channelStatsResponse = await fetch(channelStatsUrl, {
            headers: {
                'Authorization': `Bearer ${accessToken}`
            }
        });

        let channelStats = null;
        let channelSnippet = null;
        if (channelStatsResponse.ok) {
            const channelData = await channelStatsResponse.json();
            if (channelData.items && channelData.items.length > 0) {
                channelStats = channelData.items[0].statistics;
                channelSnippet = channelData.items[0].snippet || null;
            }
        }

        // Buscar vídeos recentes (SEM search.list: usar uploads playlist)
        let videosData = [];
        let recentVideosError = null;
        try {
            const ids = await getRecentVideoIdsFromUploads(channelId, accessToken, 10);
            if (ids.length) {
                const videoDetailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=statistics,snippet,contentDetails&id=${ids.join(',')}`;
                const videoDetailsResponse = await fetch(videoDetailsUrl, { headers: { 'Authorization': `Bearer ${accessToken}` } });
                if (!videoDetailsResponse.ok) {
                    recentVideosError = { status: videoDetailsResponse.status, text: await videoDetailsResponse.text().catch(() => '') };
                } else {
                    const videoDetails = await videoDetailsResponse.json();
                    videosData = videoDetails.items || [];
                }
            }
        } catch (e) {
            recentVideosError = { status: 0, text: e.message };
        }

        // Extrair receita estimada dos dados de analytics
        let estimatedRevenue = 0;
        let adImpressions = 0;
        let estimatedAdRevenue = 0;
        let grossRevenue = 0;
        let monetizedPlaybacks = 0;
        let playbackBasedCpm = 0;
        
        if (analyticsData.rows && analyticsData.rows.length > 0 && analyticsData.columnHeaders) {
            const row = analyticsData.rows[0];
            const headers = analyticsData.columnHeaders.map(h => h.name);
            
            const revenueIndex = headers.findIndex(h => h === 'estimatedRevenue' || h === 'estimatedAdRevenue');
            const impressionsIndex = headers.findIndex(h => h === 'adImpressions');
            const adRevenueIndex = headers.findIndex(h => h === 'estimatedAdRevenue');
            const grossRevenueIndex = headers.findIndex(h => h === 'grossRevenue');
            const monetizedPlaybacksIndex = headers.findIndex(h => h === 'monetizedPlaybacks');
            const playbackBasedCpmIndex = headers.findIndex(h => h === 'playbackBasedCpm');
            
            if (revenueIndex >= 0 && row[revenueIndex] !== undefined) {
                estimatedRevenue = parseFloat(row[revenueIndex] || 0);
            }
            if (adRevenueIndex >= 0 && row[adRevenueIndex] !== undefined) {
                estimatedAdRevenue = parseFloat(row[adRevenueIndex] || 0);
                if (estimatedRevenue === 0) estimatedRevenue = estimatedAdRevenue;
            }
            if (impressionsIndex >= 0 && row[impressionsIndex] !== undefined) {
                adImpressions = parseInt(row[impressionsIndex] || 0);
            }
            if (grossRevenueIndex >= 0 && row[grossRevenueIndex] !== undefined) {
                grossRevenue = parseFloat(row[grossRevenueIndex] || 0);
            }
            if (monetizedPlaybacksIndex >= 0 && row[monetizedPlaybacksIndex] !== undefined) {
                monetizedPlaybacks = parseInt(row[monetizedPlaybacksIndex] || 0);
            }
            if (playbackBasedCpmIndex >= 0 && row[playbackBasedCpmIndex] !== undefined) {
                playbackBasedCpm = parseFloat(row[playbackBasedCpmIndex] || 0);
            }
        }

        // Fallback: se o total não trouxe receita, tentar somar a série diária
        if ((!estimatedRevenue || estimatedRevenue === 0) && daily?.rows?.length && daily?.columnHeaders?.length) {
            try {
                const headersD = daily.columnHeaders.map(h => h.name);
                const idxEst = headersD.findIndex(h => h === 'estimatedRevenue');
                const idxAd = headersD.findIndex(h => h === 'estimatedAdRevenue');
                const idxImp = headersD.findIndex(h => h === 'adImpressions');
                let sumEst = 0;
                let sumAd = 0;
                let sumImp = 0;
                for (const r of daily.rows) {
                    if (idxEst >= 0) sumEst += parseFloat(r[idxEst] || 0);
                    if (idxAd >= 0) sumAd += parseFloat(r[idxAd] || 0);
                    if (idxImp >= 0) sumImp += parseInt(r[idxImp] || 0);
                }
                if (sumEst > 0) estimatedRevenue = sumEst;
                if (sumAd > 0) estimatedAdRevenue = sumAd;
                if (sumImp > 0) adImpressions = sumImp;
            } catch (_) {}
        }

        // Extra: métricas avançadas (quando disponíveis)
        const computeAdvanced = () => {
            const out = {
                averageViewDurationSeconds: null,
                averageViewDurationFormatted: null,
                averageViewPercentage: null,
                impressions: null,
                impressionsCtr: null
            };
            if (!analyticsData?.rows?.length || !analyticsData?.columnHeaders?.length) return out;

            const row = analyticsData.rows[0];
            const headers = analyticsData.columnHeaders.map(h => h.name);
            const get = (name) => {
                const idx = headers.findIndex(h => h === name);
                return idx >= 0 ? row[idx] : null;
            };

            const avgDur = get('averageViewDuration');
            if (avgDur !== null && avgDur !== undefined && avgDur !== '') {
                const secs = Math.round(parseFloat(avgDur) || 0);
                out.averageViewDurationSeconds = secs;
                const mm = Math.floor(secs / 60);
                const ss = secs % 60;
                out.averageViewDurationFormatted = `${mm}:${String(ss).padStart(2, '0')}`;
            }

            const avp = get('averageViewPercentage');
            if (avp !== null && avp !== undefined && avp !== '') {
                out.averageViewPercentage = parseFloat(avp);
            }

            const imp = get('impressions');
            if (imp !== null && imp !== undefined && imp !== '') out.impressions = parseInt(imp || 0);

            const ctr = get('impressionsCtr');
            if (ctr !== null && ctr !== undefined && ctr !== '') out.impressionsCtr = parseFloat(ctr);

            return out;
        };

        const advanced = computeAdvanced();

        // Fallback: se CTR/Retenção/Duração não vierem no total, tentar calcular pelo relatório diário
        if ((advanced.impressionsCtr === null || advanced.averageViewPercentage === null || advanced.averageViewDurationSeconds === null) &&
            daily?.rows?.length && daily?.columnHeaders?.length) {
            try {
                const headersD = daily.columnHeaders.map(h => h.name);
                const idxCtr = headersD.findIndex(h => h === 'impressionsCtr');
                const idxAvp = headersD.findIndex(h => h === 'averageViewPercentage');
                const idxDur = headersD.findIndex(h => h === 'averageViewDuration');

                const mean = (idx) => {
                    if (idx < 0) return null;
                    let sum = 0;
                    let n = 0;
                    for (const r of daily.rows) {
                        const v = parseFloat(r[idx]);
                        if (!isNaN(v)) { sum += v; n++; }
                    }
                    return n ? (sum / n) : null;
                };

                const ctrMean = mean(idxCtr);
                const avpMean = mean(idxAvp);
                const durMean = mean(idxDur);

                if (advanced.impressionsCtr === null && ctrMean !== null) advanced.impressionsCtr = ctrMean;
                if (advanced.averageViewPercentage === null && avpMean !== null) advanced.averageViewPercentage = avpMean;
                if (advanced.averageViewDurationSeconds === null && durMean !== null) {
                    const secs = Math.round(durMean);
                    advanced.averageViewDurationSeconds = secs;
                    const mm = Math.floor(secs / 60);
                    const ss = secs % 60;
                    advanced.averageViewDurationFormatted = `${mm}:${String(ss).padStart(2, '0')}`;
                }
            } catch (_) {}
        }

        // Top vídeos (mais vistos) + análise heurística
        const parseIsoDurationToSeconds = (iso) => {
            if (!iso) return 0;
            const m = String(iso).match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
            if (!m) return 0;
            const h = parseInt(m[1] || 0, 10);
            const mm = parseInt(m[2] || 0, 10);
            const s = parseInt(m[3] || 0, 10);
            return h * 3600 + mm * 60 + s;
        };

        const scoreTitlePatterns = (title) => {
            const t = String(title || '').toLowerCase();
            const hasNumber = /\d/.test(t);
            const hasQuestion = t.includes('?');
            const hasStrongWords = /(segredo|revelad|chocante|ningu[eé]m|o que n[aã]o|nunca|verdade|erro|descubra|proibido|inesperad)/.test(t);
            const len = t.length;
            return {
                hasNumber,
                hasQuestion,
                hasStrongWords,
                length: len,
                score: (hasNumber ? 1 : 0) + (hasQuestion ? 1 : 0) + (hasStrongWords ? 1 : 0) + (len >= 35 && len <= 70 ? 1 : 0)
            };
        };

        const analyzeTopVideo = (v) => {
            const views = v.viewCount || 0;
            const likes = v.likeCount || 0;
            const comments = v.commentCount || 0;
            const publishedMs = v.publishedAt ? new Date(v.publishedAt).getTime() : NaN;
            const daysAgo = Number.isFinite(publishedMs)
                ? Math.max(1, Math.round((Date.now() - publishedMs) / (1000 * 60 * 60 * 24)))
                : 30;
            const viewsPerDay = Math.round(views / daysAgo);
            const engagementRate = views > 0 ? ((likes + comments) / views) * 100 : 0;
            const durSecs = parseIsoDurationToSeconds(v.duration);
            const durMin = durSecs ? (durSecs / 60) : null;
            const patterns = scoreTitlePatterns(v.title);

            const tips = [];
            tips.push(`Replicar o ÂNGULO do título (curiosidade + promessa clara). Pontuação de padrão de título: ${patterns.score}/4.`);
            tips.push(`Meta rápida: elevar engajamento para ≥ 2.5% (likes+comentários). Atual: ${engagementRate.toFixed(2)}%.`);
            if (patterns.hasNumber) tips.push('Manter/expandir uso de números (listas, datas, quantidades) — costuma elevar CTR.');
            if (!patterns.hasQuestion) tips.push('Teste uma variação em formato de pergunta (abre loop de curiosidade e aumenta clique).');
            if (durMin && durMin < 6) tips.push('Se o conteúdo permitir, teste versão 8–12 min com narrativa em 3 atos para aumentar watch-time.');
            if (viewsPerDay > 5000) tips.push('Este vídeo tem potencial “evergreen/viral”: crie 2–3 sequências (Parte 2, “o que não te contaram”, comparação).');

            const nextVideoIdeas = [];
            nextVideoIdeas.push(`Parte 2 / continuação direta: “${String(v.title).slice(0, 45)}… (continuação)”`);
            nextVideoIdeas.push('Vídeo “mitos vs verdade” no mesmo tema (alta retenção e comentários).');
            nextVideoIdeas.push('Vídeo “ranking/top 7” com recorte mais específico (melhora CTR por clareza).');

            return {
                videoId: v.videoId,
                title: v.title,
                publishedAt: v.publishedAt,
                thumbnail: v.thumbnail,
                viewCount: views,
                likeCount: likes,
                commentCount: comments,
                duration: v.duration,
                derived: {
                    viewsPerDay,
                    engagementRatePct: parseFloat(engagementRate.toFixed(2)),
                    titlePatternScore: patterns.score
                },
                tips,
                nextVideoIdeas
            };
        };

        let topVideos = [];
        let topVideosError = null;
        try {
            // Preferir Analytics API para Top 5 (menos custo / menos chance de quotaExceeded)
            const topByAnalytics = await fetchYouTubeAnalyticsReport({
                metricsList: ['views'],
                dimensions: 'video',
                sort: '-views',
                maxResults: 5
            });

            let ids = [];
            if (topByAnalytics.ok && topByAnalytics.json?.rows?.length && topByAnalytics.json?.columnHeaders?.length) {
                const headers = topByAnalytics.json.columnHeaders.map(h => h.name);
                const idxVideo = headers.findIndex(h => h === 'video');
                const idxViews = headers.findIndex(h => h === 'views');
                topVideos = topByAnalytics.json.rows.map(r => ({
                    videoId: idxVideo >= 0 ? r[idxVideo] : null,
                    title: '',
                    publishedAt: null,
                    thumbnail: '',
                    duration: null,
                    viewCount: idxViews >= 0 ? parseInt(r[idxViews] || 0) : 0,
                    likeCount: 0,
                    commentCount: 0
                })).filter(v => v.videoId);
                ids = topVideos.map(v => v.videoId);
            }

            // Enriquecer com Data API (pode falhar por quotaExceeded)
            if (ids.length > 0) {
                const topDetailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics,contentDetails&id=${ids.join(',')}`;
                const topDetailsResponse = await fetch(topDetailsUrl, { headers: { 'Authorization': `Bearer ${accessToken}` } });
                if (topDetailsResponse.ok) {
                    const topDetailsData = await topDetailsResponse.json();
                    const byId = new Map((topDetailsData.items || []).map(item => [item.id, item]));
                    topVideos = topVideos.map(v => {
                        const item = byId.get(v.videoId);
                        if (!item) return v;
                        return {
                            ...v,
                            title: item.snippet?.title || v.title,
                            publishedAt: item.snippet?.publishedAt || v.publishedAt,
                            thumbnail: item.snippet?.thumbnails?.high?.url || item.snippet?.thumbnails?.default?.url || v.thumbnail,
                            duration: item.contentDetails?.duration || v.duration,
                            viewCount: parseInt(item.statistics?.viewCount || v.viewCount || 0),
                            likeCount: parseInt(item.statistics?.likeCount || 0),
                            commentCount: parseInt(item.statistics?.commentCount || 0)
                        };
                    }).sort((a, b) => (b.viewCount || 0) - (a.viewCount || 0));
                } else {
                    topVideosError = { status: topDetailsResponse.status, text: await topDetailsResponse.text().catch(() => '') };
                }
            }

            // Fallback SEM search.list: pegar até 50 vídeos recentes do uploads playlist e ordenar por views
            if (!topVideos.length) {
                const ids = await getRecentVideoIdsFromUploads(channelId, accessToken, 50);
                if (ids.length > 0) {
                    const topDetailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics,contentDetails&id=${ids.join(',')}`;
                    const topDetailsResponse = await fetch(topDetailsUrl, { headers: { 'Authorization': `Bearer ${accessToken}` } });
                    if (topDetailsResponse.ok) {
                        const topDetailsData = await topDetailsResponse.json();
                        topVideos = (topDetailsData.items || [])
                            .map(item => ({
                                videoId: item.id,
                                title: item.snippet?.title || '',
                                publishedAt: item.snippet?.publishedAt || null,
                                thumbnail: item.snippet?.thumbnails?.high?.url || item.snippet?.thumbnails?.default?.url || '',
                                duration: item.contentDetails?.duration || null,
                                viewCount: parseInt(item.statistics?.viewCount || 0),
                                likeCount: parseInt(item.statistics?.likeCount || 0),
                                commentCount: parseInt(item.statistics?.commentCount || 0)
                            }))
                            .sort((a, b) => b.viewCount - a.viewCount)
                            .slice(0, 5);
                    } else if (!topVideosError) {
                        topVideosError = { status: topDetailsResponse.status, text: await topDetailsResponse.text().catch(() => '') };
                    }
                }
            }
        } catch (e) {
            topVideosError = { status: 0, text: e.message };
            topVideos = [];
        }

        const topVideosAnalysis = topVideos.map(analyzeTopVideo);
        
        const payload = {
            analytics: analyticsData,
            analyticsMeta,
            daily,
            trafficSources,
            topCountries,
            channelStats: channelStats,
            channelSnippet,
            advanced,
            estimatedRevenue: estimatedRevenue,
            estimatedAdRevenue: estimatedAdRevenue,
            grossRevenue,
            adImpressions: adImpressions,
            monetizedPlaybacks,
            playbackBasedCpm,
            recentVideosError,
            recentVideos: videosData.map(v => ({
                id: v.id,
                title: v.snippet?.title,
                publishedAt: v.snippet?.publishedAt,
                views: parseInt(v.statistics?.viewCount || 0),
                likes: parseInt(v.statistics?.likeCount || 0),
                comments: parseInt(v.statistics?.commentCount || 0)
            })),
            topVideos: topVideos,
            topVideosAnalysis,
            topVideosError,
            period: {
                start: startDateStr,
                end: endDateStr
            }
        };

        setYtAnalyticsCache(cacheKey, payload);
        return res.status(200).json(payload);

    } catch (err) {
        console.error('[YouTube Analytics] Erro:', err);
        return res.status(500).json({ msg: 'Erro ao buscar métricas do canal.', error: err.message });
    }
});

// Endpoint para re-analisar nicho do canal usando últimos 10 vídeos
app.post('/api/youtube/channels/:id/reanalyze-niche', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    try {
        // Buscar integração do canal
        const integration = await db.get(
            'SELECT channel_id, channel_name, access_token, refresh_token, token_expires_at, id FROM youtube_integrations WHERE id = ? AND user_id = ? AND is_active = 1',
            [id, userId]
        );

        if (!integration) {
            return res.status(404).json({ msg: 'Canal não encontrado ou não conectado.' });
        }

        // Verificar e renovar token se necessário
        let accessToken = decryptToken(integration.access_token, 'YouTube Re-analyze Niche');
        if (!accessToken) {
            if (integration.refresh_token) {
                try {
                    accessToken = await refreshYouTubeToken(integration.refresh_token, userId, integration.id);
                } catch (refreshErr) {
                    return res.status(401).json({ msg: 'Erro ao renovar token. Reconecte o canal.' });
                }
            } else {
                return res.status(401).json({ msg: 'Token inválido. Reconecte o canal.' });
            }
        } else if (integration.token_expires_at && new Date(integration.token_expires_at) < new Date()) {
            if (!integration.refresh_token) {
                return res.status(401).json({ msg: 'Token expirado. Reconecte o canal.' });
            }
            accessToken = await refreshYouTubeToken(integration.refresh_token, userId, integration.id);
        }

        // Re-analisar nicho usando últimos 10 vídeos
        const nicheAnalysis = await analyzeChannelNicheWithVideos(integration.channel_id, integration.channel_name, accessToken, userId, 10);

        // Atualizar nicho no banco
        await db.run(
            `UPDATE youtube_integrations 
             SET niche = ?, subniche = ?, updated_at = CURRENT_TIMESTAMP 
             WHERE id = ?`,
            [nicheAnalysis.niche, nicheAnalysis.subniche || null, id]
        );

        return res.status(200).json({
            msg: 'Nicho re-analisado com sucesso!',
            niche: nicheAnalysis.niche,
            subniche: nicheAnalysis.subniche
        });

    } catch (err) {
        console.error('[YouTube Re-analyze Niche] Erro:', err);
        return res.status(500).json({ msg: 'Erro ao re-analisar nicho.', error: err.message });
    }
});

// Endpoint para análise completa de insights do canal
app.post('/api/youtube/channels/:id/insights', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    try {
        // Buscar integração do canal
        const integration = await db.get(
            'SELECT channel_id, channel_name, access_token, refresh_token, token_expires_at, id, niche, subniche FROM youtube_integrations WHERE id = ? AND user_id = ? AND is_active = 1',
            [id, userId]
        );

        if (!integration) {
            return res.status(404).json({ msg: 'Canal não encontrado ou não conectado.' });
        }

        // Verificar e renovar token se necessário
        let accessToken = decryptToken(integration.access_token, 'YouTube Insights');
        if (!accessToken) {
            if (integration.refresh_token) {
                try {
                    accessToken = await refreshYouTubeToken(integration.refresh_token, userId, integration.id);
                } catch (refreshErr) {
                    return res.status(401).json({ msg: 'Erro ao renovar token. Reconecte o canal.' });
                }
            } else {
                return res.status(401).json({ msg: 'Token inválido. Reconecte o canal.' });
            }
        } else if (integration.token_expires_at && new Date(integration.token_expires_at) < new Date()) {
            if (!integration.refresh_token) {
                return res.status(401).json({ msg: 'Token expirado. Reconecte o canal.' });
            }
            accessToken = await refreshYouTubeToken(integration.refresh_token, userId, integration.id);
        }

        // Buscar dados do canal para análise
        const channelData = await fetchChannelDataForInsights(integration.channel_id, accessToken);
        
        // Gerar insights com IA
        const insights = await generateChannelInsights(channelData, integration.channel_name, integration.niche, integration.subniche, userId);

        return res.status(200).json(insights);

    } catch (err) {
        console.error('[YouTube Insights] Erro:', err);
        return res.status(500).json({ msg: 'Erro ao gerar insights.', error: err.message });
    }
});

// Função auxiliar para analisar nicho com número específico de vídeos
async function analyzeChannelNicheWithVideos(channelId, channelName, accessToken, userId, maxVideos = 10) {
    try {
        console.log(`[Análise Canal] 🔍 Iniciando análise do canal ${channelId} (${channelName}) com ${maxVideos} vídeos...`);
        
        // Buscar os vídeos mais recentes do canal
        console.log(`[Análise Canal] 📡 Buscando vídeos do canal (uploads playlist, sem search.list)...`);
        const videoTitles = await getRecentVideoTitlesFromUploads(channelId, accessToken, Math.min(50, maxVideos));
        
        if (videoTitles.length === 0) {
            console.warn(`[Análise Canal] ⚠️ Nenhum título válido encontrado nos vídeos`);
            return { niche: 'Entretenimento', subniche: null };
        }
        
        console.log(`[Análise Canal] 📝 Títulos encontrados: ${videoTitles.length} vídeos`);
        
        // Buscar chaves de API do usuário para análise
        const keysData = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
        const keys = {};
        keysData.forEach(k => { keys[k.service_name] = decrypt(k.api_key); });
        
        // Tentar usar Gemini, Claude ou OpenAI (nesta ordem)
        let detectedNiche = null;
        let detectedSubniche = null;
        
        const analysisPrompt = `Você é um especialista em análise de conteúdo do YouTube. Analise os seguintes títulos de vídeos de um canal do YouTube e identifique o NICHO e SUBNICHE do canal.

Títulos dos vídeos:
${videoTitles.map((title, i) => `${i + 1}. ${title}`).join('\n')}

Nome do canal: ${channelName}

Analise os padrões, temas e assuntos recorrentes nos títulos para identificar:
- O NICHO principal (categoria ampla: Entretenimento, Educação, Tecnologia, Finanças, Gaming, etc.)
- O SUBNICHE específico (área mais específica dentro do nicho: Gaming FPS, Finanças Pessoais, Programação Web, etc.)

IMPORTANTE: Responda APENAS com um objeto JSON válido, sem nenhum texto adicional antes ou depois:
{
  "niche": "Nome do nicho principal",
  "subniche": "Nome do subnicho específico ou null se não houver subnicho claro"
}

Seja específico e preciso. Se não conseguir identificar claramente, use "Entretenimento" como nicho padrão e deixe subniche como null.`;

        // Tentar Gemini primeiro
        if (keys.gemini) {
            try {
                const response = await callGeminiAPI(analysisPrompt, keys.gemini, 'gemini-2.0-flash');
                const parsed = parseAIResponse(response.titles, 'gemini');
                if (parsed.niche) {
                    detectedNiche = parsed.niche;
                    detectedSubniche = parsed.subniche || null;
                    console.log(`[Análise Canal] Nicho detectado via Gemini: ${detectedNiche} / ${detectedSubniche}`);
                    return { niche: detectedNiche, subniche: detectedSubniche };
                }
            } catch (err) {
                console.warn(`[Análise Canal] Erro ao usar Gemini: ${err.message}`);
            }
        }
        
        // Tentar Claude
        if (keys.claude) {
            try {
                const response = await callClaudeAPI(analysisPrompt, keys.claude, 'claude-3-5-haiku-20241022');
                const parsed = parseAIResponse(response.titles, 'claude');
                if (parsed.niche) {
                    detectedNiche = parsed.niche;
                    detectedSubniche = parsed.subniche || null;
                    console.log(`[Análise Canal] Nicho detectado via Claude: ${detectedNiche} / ${detectedSubniche}`);
                    return { niche: detectedNiche, subniche: detectedSubniche };
                }
            } catch (err) {
                console.warn(`[Análise Canal] Erro ao usar Claude: ${err.message}`);
            }
        }
        
        // Tentar OpenAI
        if (keys.openai) {
            try {
                const response = await callOpenAIAPI(analysisPrompt, keys.openai, 'gpt-4o-mini');
                const parsed = parseAIResponse(response.titles, 'openai');
                if (parsed.niche) {
                    detectedNiche = parsed.niche;
                    detectedSubniche = parsed.subniche || null;
                    console.log(`[Análise Canal] Nicho detectado via OpenAI: ${detectedNiche} / ${detectedSubniche}`);
                    return { niche: detectedNiche, subniche: detectedSubniche };
                }
            } catch (err) {
                console.warn(`[Análise Canal] Erro ao usar OpenAI: ${err.message}`);
            }
        }
        
        // Se nenhuma IA funcionou, retornar nicho padrão
        console.warn(`[Análise Canal] ⚠️ Não foi possível detectar nicho para o canal ${channelId}, usando padrão`);
        return { niche: 'Entretenimento', subniche: null };
        
    } catch (err) {
        console.error(`[Análise Canal] ❌ Erro ao analisar canal ${channelId}:`, err.message);
        return { niche: 'Entretenimento', subniche: null };
    }
}

// Função auxiliar para buscar dados do canal para análise
async function fetchChannelDataForInsights(channelId, accessToken) {
    try {
        // Buscar últimos 20 vídeos via uploads playlist (sem search.list)
        const videoIds = await getRecentVideoIdsFromUploads(channelId, accessToken, 20);
        const searchData = { items: [] };

        // Buscar estatísticas dos vídeos
        let videoStats = [];
        if (videoIds.length > 0) {
            const statsUrl = `https://www.googleapis.com/youtube/v3/videos?part=statistics,contentDetails,snippet&id=${videoIds.join(',')}`;
            const statsResponse = await fetch(statsUrl, {
                headers: { 'Authorization': `Bearer ${accessToken}` }
            });

            if (statsResponse.ok) {
                const statsData = await statsResponse.json();
                videoStats = statsData.items || [];
                // Reconstituir um "items" compatível (para usar títulos em outros pontos)
                searchData.items = (statsData.items || []).map(v => ({
                    id: { videoId: v.id },
                    snippet: v.snippet || {}
                }));
            }
        }

        // Buscar estatísticas do canal
        const channelUrl = `https://www.googleapis.com/youtube/v3/channels?part=statistics,snippet&id=${channelId}`;
        const channelResponse = await fetch(channelUrl, {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });

        let channelStats = null;
        if (channelResponse.ok) {
            const channelData = await channelResponse.json();
            channelStats = channelData.items?.[0] || null;
        }

        return {
            videos: searchData.items || [],
            videoStats: videoStats,
            channelStats: channelStats
        };

    } catch (err) {
        console.error('[Fetch Channel Data] Erro:', err);
        throw err;
    }
}

// Função para gerar insights com IA
async function generateChannelInsights(channelData, channelName, niche, subniche, userId) {
    try {
        // Preparar dados para análise
        const videoTitles = channelData.videos.map(v => v.snippet?.title || '').filter(Boolean);
        const videoDurations = channelData.videoStats
            .map(v => {
                const duration = v.contentDetails?.duration || '';
                // Converter ISO 8601 duration para minutos
                const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
                if (match) {
                    const hours = parseInt(match[1] || 0);
                    const minutes = parseInt(match[2] || 0);
                    const seconds = parseInt(match[3] || 0);
                    return hours * 60 + minutes + seconds / 60;
                }
                return null;
            })
            .filter(Boolean);
        
        const avgDuration = videoDurations.length > 0 
            ? videoDurations.reduce((a, b) => a + b, 0) / videoDurations.length 
            : null;

        const videoViews = channelData.videoStats.map(v => parseInt(v.statistics?.viewCount || 0));
        const avgViews = videoViews.length > 0 
            ? videoViews.reduce((a, b) => a + b, 0) / videoViews.length 
            : 0;

        // Buscar chaves de API
        const keysData = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
        const keys = {};
        keysData.forEach(k => { keys[k.service_name] = decrypt(k.api_key); });

        const insightsPrompt = `Você é um especialista em análise de canais do YouTube e estratégias de crescimento. Analise os seguintes dados de um canal e forneça insights detalhados e acionáveis.

DADOS DO CANAL:
- Nome: ${channelName}
- Nicho: ${niche || 'Não identificado'}
- Subniche: ${subniche || 'Não identificado'}
- Total de vídeos analisados: ${videoTitles.length}
- Duração média dos vídeos: ${avgDuration ? Math.round(avgDuration) + ' minutos' : 'Não disponível'}
- Visualizações médias por vídeo: ${Math.round(avgViews).toLocaleString()}

TÍTULOS DOS ÚLTIMOS VÍDEOS:
${videoTitles.map((title, i) => `${i + 1}. ${title}`).join('\n')}

FORNEÇA UMA ANÁLISE COMPLETA COM OS SEGUINTES ITENS (responda em formato JSON válido):

{
  "summary": "Resumo executivo de 2-3 parágrafos sobre o estado atual do canal e principais oportunidades",
  "frequency": "Recomendação de quantos vídeos postar por semana/mês baseado no nicho e performance atual",
  "duration": "Duração ideal de vídeo em minutos baseado na análise dos vídeos mais bem-sucedidos",
  "publishTime": "Melhor horário e dia da semana para publicar baseado no nicho e público-alvo",
  "contentType": "Tipos de conteúdo recomendados para aumentar views e engajamento",
  "strategies": [
    "Estratégia 1 específica e acionável",
    "Estratégia 2 específica e acionável",
    "Estratégia 3 específica e acionável",
    "Estratégia 4 específica e acionável",
    "Estratégia 5 específica e acionável"
  ],
  "titlePatterns": [
    "Padrão de título 1 que funciona bem no nicho",
    "Padrão de título 2 que funciona bem no nicho",
    "Padrão de título 3 que funciona bem no nicho"
  ],
  "thumbnailRecommendations": "Recomendações específicas sobre thumbnails: cores, elementos, composição, etc."
}

IMPORTANTE: Responda APENAS com o JSON válido, sem texto adicional antes ou depois.`;

        // Tentar usar Gemini, Claude ou OpenAI
        let insights = null;

        if (keys.gemini) {
            try {
                const response = await callGeminiAPI(insightsPrompt, keys.gemini, 'gemini-2.0-flash');
                const parsed = parseAIResponse(response.titles, 'gemini');
                if (parsed.summary) {
                    insights = parsed;
                }
            } catch (err) {
                console.warn(`[Insights] Erro ao usar Gemini: ${err.message}`);
            }
        }

        if (!insights && keys.claude) {
            try {
                const response = await callClaudeAPI(insightsPrompt, keys.claude, 'claude-3-5-haiku-20241022');
                const parsed = parseAIResponse(response.titles, 'claude');
                if (parsed.summary) {
                    insights = parsed;
                }
            } catch (err) {
                console.warn(`[Insights] Erro ao usar Claude: ${err.message}`);
            }
        }

        if (!insights && keys.openai) {
            try {
                const response = await callOpenAIAPI(insightsPrompt, keys.openai, 'gpt-4o-mini');
                const parsed = parseAIResponse(response.titles, 'openai');
                if (parsed.summary) {
                    insights = parsed;
                }
            } catch (err) {
                console.warn(`[Insights] Erro ao usar OpenAI: ${err.message}`);
            }
        }

        // Se não conseguiu gerar insights, retornar valores padrão
        if (!insights) {
            return {
                summary: `Análise do canal ${channelName}. Com base nos dados disponíveis, há oportunidades de crescimento através de otimização de títulos, thumbnails e frequência de publicação.`,
                frequency: '2-3 vídeos por semana',
                duration: avgDuration ? `${Math.round(avgDuration)} minutos` : '10-15 minutos',
                publishTime: 'Terças e Quintas às 18h',
                contentType: 'Foque em conteúdo que ressoe com seu nicho e público-alvo',
                strategies: [
                    'Otimize títulos com palavras-chave relevantes',
                    'Crie thumbnails chamativos e consistentes',
                    'Mantenha frequência regular de publicação',
                    'Interaja com comentários para aumentar engajamento',
                    'Analise vídeos de maior sucesso e replique padrões'
                ],
                titlePatterns: [
                    'Use números e listas quando apropriado',
                    'Inclua palavras de ação e curiosidade',
                    'Seja específico e prometa valor claro'
                ],
                thumbnailRecommendations: 'Use cores contrastantes, rostos ou elementos visuais chamativos, e mantenha consistência visual entre vídeos.'
            };
        }

        return insights;

    } catch (err) {
        console.error('[Generate Insights] Erro:', err);
        throw err;
    }
}

// Função auxiliar para renovar token do YouTube
async function refreshYouTubeToken(refreshToken, userId, integrationId) {
    const CLIENT_ID = process.env.YOUTUBE_CLIENT_ID;
    const CLIENT_SECRET = process.env.YOUTUBE_CLIENT_SECRET;
    
    const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams({
            client_id: CLIENT_ID,
            client_secret: CLIENT_SECRET,
            refresh_token: refreshToken,
            grant_type: 'refresh_token',
        }),
    });

    if (!tokenResponse.ok) {
        throw new Error('Falha ao renovar token');
    }

    const tokenData = await tokenResponse.json();
    const newAccessToken = tokenData.access_token;
    const expiresAt = tokenData.expires_in 
        ? new Date(Date.now() + tokenData.expires_in * 1000).toISOString()
        : null;

    // Atualizar token no banco
    await db.run(
        'UPDATE youtube_integrations SET access_token = ?, token_expires_at = ? WHERE id = ?',
        [encrypt(newAccessToken), expiresAt, integrationId]
    );

    return newAccessToken;
}

// Endpoint para obter URL de upload resumable do YouTube (para upload direto do frontend)
app.post('/api/youtube/upload/init', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { channelId, title, description, tags, privacy = 'private', categoryId = '22', videoSize } = req.body;

    if (!channelId || !title || !videoSize) {
        return res.status(400).json({ msg: 'channelId, title e videoSize são obrigatórios.' });
    }

    try {
        // Buscar integração do canal
        const integration = await db.get(
            'SELECT channel_id, access_token, refresh_token, token_expires_at, id FROM youtube_integrations WHERE channel_id = ? AND user_id = ? AND is_active = 1',
            [channelId, userId]
        );

        if (!integration) {
            return res.status(404).json({ msg: 'Canal não encontrado ou não conectado.' });
        }

        // Verificar e renovar token se necessário
        let accessToken = decryptToken(integration.access_token, 'YouTube Upload Init');
        if (!accessToken) {
            if (integration.refresh_token) {
                try {
                    accessToken = await refreshYouTubeToken(integration.refresh_token, userId, integration.id);
                } catch (refreshErr) {
                    return res.status(401).json({ msg: 'Erro ao renovar token. Reconecte o canal.' });
                }
            } else {
                return res.status(401).json({ msg: 'Token inválido. Reconecte o canal.' });
            }
        } else if (integration.token_expires_at && new Date(integration.token_expires_at) < new Date()) {
            if (!integration.refresh_token) {
                return res.status(401).json({ msg: 'Token expirado. Reconecte o canal.' });
            }
            accessToken = await refreshYouTubeToken(integration.refresh_token, userId, integration.id);
        }

        // Criar metadata do vídeo
        const videoMetadata = {
            snippet: {
                title: title,
                description: description || '',
                tags: Array.isArray(tags) ? tags : (tags ? tags.split(',').map(t => t.trim()) : []),
                categoryId: categoryId
            },
            status: {
                privacyStatus: privacy
            }
        };

        // Iniciar upload resumable
        const initUploadUrl = 'https://www.googleapis.com/upload/youtube/v3/videos?uploadType=resumable&part=snippet,status';
        
        const initResponse = await fetch(initUploadUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json',
                'X-Upload-Content-Type': 'video/*',
                'X-Upload-Content-Length': videoSize.toString()
            },
            body: JSON.stringify(videoMetadata)
        });

        if (!initResponse.ok) {
            const errorText = await initResponse.text();
            console.error('[YouTube Upload Init] Erro:', errorText);
            return res.status(initResponse.status).json({ 
                msg: 'Erro ao iniciar upload do vídeo.',
                error: errorText 
            });
        }

        const uploadUrl = initResponse.headers.get('Location');
        if (!uploadUrl) {
            return res.status(500).json({ msg: 'URL de upload não recebida.' });
        }

        return res.status(200).json({
            uploadUrl: uploadUrl,
            accessToken: accessToken // Retornar token para uso no frontend (será usado apenas para este upload)
        });

    } catch (err) {
        console.error('[YouTube Upload Init] Erro:', err);
        return res.status(500).json({ msg: 'Erro ao iniciar upload.', error: err.message });
    }
});

// Função auxiliar para renovar token do YouTube
async function refreshYouTubeToken(refreshToken, userId, integrationId) {
    const CLIENT_ID = process.env.YOUTUBE_CLIENT_ID;
    const CLIENT_SECRET = process.env.YOUTUBE_CLIENT_SECRET;
    
    const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams({
            client_id: CLIENT_ID,
            client_secret: CLIENT_SECRET,
            refresh_token: refreshToken,
            grant_type: 'refresh_token',
        }),
    });

    if (!tokenResponse.ok) {
        throw new Error('Falha ao renovar token');
    }

    const tokenData = await tokenResponse.json();
    const newAccessToken = tokenData.access_token;
    const expiresAt = tokenData.expires_in 
        ? new Date(Date.now() + tokenData.expires_in * 1000).toISOString()
        : null;

    // Atualizar token no banco
    await db.run(
        'UPDATE youtube_integrations SET access_token = ?, token_expires_at = ? WHERE id = ?',
        [encrypt(newAccessToken), expiresAt, integrationId]
    );

    return newAccessToken;
}

// Endpoint completo para upload de vídeo para YouTube (recebe arquivo via FormData)
app.post('/api/youtube/upload/complete', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    
    try {
        const uploadsDir = path.join(__dirname, 'uploads', 'videos');
        await fse.ensureDir(uploadsDir);
        
        const form = formidable.formidable({
            uploadDir: uploadsDir,
            keepExtensions: true,
            maxFileSize: 10 * 1024 * 1024 * 1024 // 10GB
        });
        
        form.parse(req, async (err, fields, files) => {
            if (err) {
                console.error('[YouTube Upload Complete] Erro ao processar:', err);
                return res.status(500).json({ msg: 'Erro ao processar arquivo.', error: err.message });
            }
            
            const videoFile = Array.isArray(files.video) ? files.video[0] : files.video;
            const thumbnailFile = files.thumbnail ? (Array.isArray(files.thumbnail) ? files.thumbnail[0] : files.thumbnail) : null;
            
            if (!videoFile) {
                return res.status(400).json({ msg: 'Arquivo de vídeo não fornecido.' });
            }
            
            const channelId = fields.channelId?.[0] || fields.channelId;
            const title = fields.title?.[0] || fields.title;
            const description = fields.description?.[0] || fields.description || '';
            const tags = fields.tags?.[0] || fields.tags || '[]';
            const privacy = fields.privacy?.[0] || fields.privacy || 'private';
            const categoryId = fields.categoryId?.[0] || fields.categoryId || '22';
            
            if (!channelId || !title) {
                return res.status(400).json({ msg: 'channelId e title são obrigatórios.' });
            }
            
            try {
                // Buscar integração do canal
                const integration = await db.get(
                    'SELECT channel_id, access_token, refresh_token, token_expires_at, id FROM youtube_integrations WHERE channel_id = ? AND user_id = ? AND is_active = 1',
                    [channelId, userId]
                );

                if (!integration) {
                    return res.status(404).json({ msg: 'Canal não encontrado ou não conectado.' });
                }

                // Verificar e renovar token se necessário
                let accessToken = decryptToken(integration.access_token, 'YouTube Upload Complete');
                if (!accessToken) {
                    if (integration.refresh_token) {
                        try {
                            accessToken = await refreshYouTubeToken(integration.refresh_token, userId, integration.id);
                        } catch (refreshErr) {
                            return res.status(401).json({ msg: 'Erro ao renovar token. Reconecte o canal.' });
                        }
                    } else {
                        return res.status(401).json({ msg: 'Token inválido. Reconecte o canal.' });
                    }
                } else if (integration.token_expires_at && new Date(integration.token_expires_at) < new Date()) {
                    if (!integration.refresh_token) {
                        return res.status(401).json({ msg: 'Token expirado. Reconecte o canal.' });
                    }
                    accessToken = await refreshYouTubeToken(integration.refresh_token, userId, integration.id);
                }

                // Ler arquivo de vídeo
                const videoPath = videoFile.filepath;
                const videoBuffer = fs.readFileSync(videoPath);
                const videoSize = videoBuffer.length;

                // Criar metadata do vídeo
                let tagsArray = [];
                try {
                    tagsArray = typeof tags === 'string' ? JSON.parse(tags) : tags;
                    if (!Array.isArray(tagsArray)) {
                        tagsArray = tags.split(',').map(t => t.trim()).filter(t => t);
                    }
                } catch (e) {
                    tagsArray = typeof tags === 'string' ? tags.split(',').map(t => t.trim()).filter(t => t) : [];
                }

                const videoMetadata = {
                    snippet: {
                        title: title,
                        description: description,
                        tags: tagsArray,
                        categoryId: categoryId
                    },
                    status: {
                        privacyStatus: privacy
                    }
                };

                // Iniciar upload resumable
                const initUploadUrl = 'https://www.googleapis.com/upload/youtube/v3/videos?uploadType=resumable&part=snippet,status';
                
                const initResponse = await fetch(initUploadUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Content-Type': 'application/json',
                        'X-Upload-Content-Type': 'video/*',
                        'X-Upload-Content-Length': videoSize.toString()
                    },
                    body: JSON.stringify(videoMetadata)
                });

                if (!initResponse.ok) {
                    const errorText = await initResponse.text();
                    console.error('[YouTube Upload Complete] Erro ao iniciar upload:', errorText);
                    return res.status(initResponse.status).json({ 
                        msg: 'Erro ao iniciar upload do vídeo.',
                        error: errorText 
                    });
                }

                const uploadUrl = initResponse.headers.get('Location');
                if (!uploadUrl) {
                    return res.status(500).json({ msg: 'URL de upload não recebida.' });
                }

                // Fazer upload do vídeo em chunks
                const chunkSize = 256 * 1024; // 256KB por chunk
                let uploadedBytes = 0;

                while (uploadedBytes < videoSize) {
                    const chunk = videoBuffer.slice(uploadedBytes, Math.min(uploadedBytes + chunkSize, videoSize));
                    const chunkEnd = Math.min(uploadedBytes + chunk.length - 1, videoSize - 1);

                    const chunkResponse = await fetch(uploadUrl, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'video/*',
                            'Content-Length': chunk.length.toString(),
                            'Content-Range': `bytes ${uploadedBytes}-${chunkEnd}/${videoSize}`
                        },
                        body: chunk
                    });

                    if (chunkResponse.status === 308) {
                        // Continuar upload
                        const rangeHeader = chunkResponse.headers.get('Range');
                        if (rangeHeader) {
                            const match = rangeHeader.match(/bytes=0-(\d+)/);
                            if (match) {
                                uploadedBytes = parseInt(match[1]) + 1;
                            } else {
                                uploadedBytes += chunk.length;
                            }
                        } else {
                            uploadedBytes += chunk.length;
                        }
                    } else if (chunkResponse.ok) {
                        // Upload completo
                        const uploadResult = await chunkResponse.json();
                        
                        // Se tiver thumbnail, fazer upload
                        if (thumbnailFile && fs.existsSync(thumbnailFile.filepath)) {
                            try {
                                const thumbnailBuffer = fs.readFileSync(thumbnailFile.filepath);
                                const thumbnailUploadUrl = `https://www.googleapis.com/upload/youtube/v3/thumbnails/set?videoId=${uploadResult.id}`;
                                
                                await fetch(thumbnailUploadUrl, {
                                    method: 'POST',
                                    headers: {
                                        'Authorization': `Bearer ${accessToken}`,
                                        'Content-Type': 'image/jpeg'
                                    },
                                    body: thumbnailBuffer
                                });
                            } catch (thumbErr) {
                                console.warn('[YouTube Upload Complete] Erro ao fazer upload da thumbnail:', thumbErr.message);
                            }
                        }

                        // Limpar arquivo temporário
                        try {
                            fs.unlinkSync(videoPath);
                            if (thumbnailFile && fs.existsSync(thumbnailFile.filepath)) {
                                fs.unlinkSync(thumbnailFile.filepath);
                            }
                        } catch (cleanupErr) {
                            console.warn('[YouTube Upload Complete] Erro ao limpar arquivos temporários:', cleanupErr.message);
                        }

                        return res.status(200).json({
                            msg: 'Vídeo enviado com sucesso!',
                            videoId: uploadResult.id,
                            videoUrl: `https://www.youtube.com/watch?v=${uploadResult.id}`
                        });
                    } else {
                        const errorText = await chunkResponse.text();
                        throw new Error(`Erro no upload: ${errorText}`);
                    }
                }

                return res.status(500).json({ msg: 'Upload não completado.' });

            } catch (uploadErr) {
                console.error('[YouTube Upload Complete] Erro:', uploadErr);
                return res.status(500).json({ msg: 'Erro ao fazer upload do vídeo.', error: uploadErr.message });
            }
        });
    } catch (err) {
        console.error('[YouTube Upload Complete] Erro:', err);
        return res.status(500).json({ msg: 'Erro ao processar upload.', error: err.message });
    }
});

// Endpoint para upload de vídeo para YouTube (mantido para compatibilidade com agendamento)
app.post('/api/youtube/upload', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { channelId, videoFilePath, title, description, tags, thumbnailPath, privacy = 'private', categoryId = '22' } = req.body;

    if (!channelId || !videoFilePath || !title) {
        return res.status(400).json({ msg: 'channelId, videoFilePath e title são obrigatórios.' });
    }

    try {
        // Buscar integração do canal
        const integration = await db.get(
            'SELECT channel_id, access_token, refresh_token, token_expires_at, id FROM youtube_integrations WHERE channel_id = ? AND user_id = ? AND is_active = 1',
            [channelId, userId]
        );

        if (!integration) {
            return res.status(404).json({ msg: 'Canal não encontrado ou não conectado.' });
        }

        // Verificar e renovar token se necessário
        let accessToken = decryptToken(integration.access_token, 'YouTube Upload');
        if (!accessToken) {
            if (integration.refresh_token) {
                try {
                    accessToken = await refreshYouTubeToken(integration.refresh_token, userId, integration.id);
                } catch (refreshErr) {
                    return res.status(401).json({ msg: 'Erro ao renovar token. Reconecte o canal.' });
                }
            } else {
                return res.status(401).json({ msg: 'Token inválido. Reconecte o canal.' });
            }
        } else if (integration.token_expires_at && new Date(integration.token_expires_at) < new Date()) {
            if (!integration.refresh_token) {
                return res.status(401).json({ msg: 'Token expirado. Reconecte o canal.' });
            }
            accessToken = await refreshYouTubeToken(integration.refresh_token, userId, integration.id);
        }

        // Ler arquivo de vídeo
        const videoPath = path.join(__dirname, videoFilePath);
        if (!fs.existsSync(videoPath)) {
            return res.status(404).json({ msg: 'Arquivo de vídeo não encontrado.' });
        }

        const videoBuffer = fs.readFileSync(videoPath);
        const videoSize = videoBuffer.length;

        // Criar metadata do vídeo
        const videoMetadata = {
            snippet: {
                title: title,
                description: description || '',
                tags: Array.isArray(tags) ? tags : (tags ? tags.split(',').map(t => t.trim()) : []),
                categoryId: categoryId
            },
            status: {
                privacyStatus: privacy // 'private', 'unlisted', 'public'
            }
        };

        // Upload usando resumable upload do YouTube
        // Primeiro, iniciar upload resumable
        const initUploadUrl = 'https://www.googleapis.com/upload/youtube/v3/videos?uploadType=resumable&part=snippet,status';
        
        const initResponse = await fetch(initUploadUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json',
                'X-Upload-Content-Type': 'video/*',
                'X-Upload-Content-Length': videoSize.toString()
            },
            body: JSON.stringify(videoMetadata)
        });

        if (!initResponse.ok) {
            const errorText = await initResponse.text();
            console.error('[YouTube Upload] Erro ao iniciar upload:', errorText);
            return res.status(initResponse.status).json({ 
                msg: 'Erro ao iniciar upload do vídeo.',
                error: errorText 
            });
        }

        const uploadUrl = initResponse.headers.get('Location');
        if (!uploadUrl) {
            return res.status(500).json({ msg: 'URL de upload não recebida.' });
        }

        // Fazer upload do vídeo em chunks (para vídeos grandes)
        const chunkSize = 256 * 1024; // 256KB por chunk
        let uploadedBytes = 0;

        while (uploadedBytes < videoSize) {
            const chunk = videoBuffer.slice(uploadedBytes, Math.min(uploadedBytes + chunkSize, videoSize));
            const chunkEnd = Math.min(uploadedBytes + chunk.length - 1, videoSize - 1);

            const chunkResponse = await fetch(uploadUrl, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'video/*',
                    'Content-Length': chunk.length.toString(),
                    'Content-Range': `bytes ${uploadedBytes}-${chunkEnd}/${videoSize}`
                },
                body: chunk
            });

            if (chunkResponse.status === 308) {
                // Continuar upload
                const rangeHeader = chunkResponse.headers.get('Range');
                if (rangeHeader) {
                    const match = rangeHeader.match(/bytes=0-(\d+)/);
                    if (match) {
                        uploadedBytes = parseInt(match[1]) + 1;
                    } else {
                        uploadedBytes += chunk.length;
                    }
                } else {
                    uploadedBytes += chunk.length;
                }
            } else if (chunkResponse.ok) {
                // Upload completo
                const uploadResult = await chunkResponse.json();
                
                // Se tiver thumbnail, fazer upload
                if (thumbnailPath && fs.existsSync(path.join(__dirname, thumbnailPath))) {
                    try {
                        const thumbnailBuffer = fs.readFileSync(path.join(__dirname, thumbnailPath));
                        const thumbnailUploadUrl = `https://www.googleapis.com/upload/youtube/v3/thumbnails/set?videoId=${uploadResult.id}`;
                        
                        await fetch(thumbnailUploadUrl, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${accessToken}`,
                                'Content-Type': 'image/jpeg'
                            },
                            body: thumbnailBuffer
                        });
                    } catch (thumbErr) {
                        console.warn('[YouTube Upload] Erro ao fazer upload da thumbnail:', thumbErr.message);
                    }
                }

                return res.status(200).json({
                    msg: 'Vídeo enviado com sucesso!',
                    videoId: uploadResult.id,
                    videoUrl: `https://www.youtube.com/watch?v=${uploadResult.id}`
                });
            } else {
                const errorText = await chunkResponse.text();
                throw new Error(`Erro no upload: ${errorText}`);
            }
        }

        return res.status(500).json({ msg: 'Upload não completado.' });

    } catch (err) {
        console.error('[YouTube Upload] Erro:', err);
        return res.status(500).json({ msg: 'Erro ao fazer upload do vídeo.', error: err.message });
    }
});

app.delete('/api/youtube/channels/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const integrationId = parseInt(req.params.id);

    try {
        // Verificar se a integração pertence ao usuário
        const integration = await db.get(
            'SELECT id FROM youtube_integrations WHERE id = ? AND user_id = ?',
            [integrationId, userId]
        );

        if (!integration) {
            return res.status(404).json({ msg: 'Canal não encontrado.' });
        }

        // Desativar a integração (soft delete)
        await db.run(
            'UPDATE youtube_integrations SET is_active = 0, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
            [integrationId]
        );

        console.log(`[YouTube] Canal desconectado: userId=${userId}, integrationId=${integrationId}`);
        return res.status(200).json({ msg: 'Canal desconectado com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/channels/:id DELETE]:', err);
        return res.status(500).json({ msg: 'Erro ao desconectar canal.' });
    }
});

// Listar publicações agendadas
app.get('/api/youtube/scheduled', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    console.log(`[YouTube Scheduled] Requisição recebida para userId: ${userId}`);

    try {
        if (!db) {
            console.error('[YouTube Scheduled] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        let scheduled = [];
        try {
            scheduled = await db.all(
                'SELECT * FROM scheduled_posts WHERE user_id = ? ORDER BY scheduled_time ASC',
                [userId]
            );
            console.log(`[YouTube Scheduled] Publicações encontradas:`, scheduled.length);
        } catch (dbErr) {
            console.error('[YouTube Scheduled] Erro ao buscar publicações:', dbErr);
            scheduled = [];
        }

        res.status(200).json(scheduled || []);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/scheduled]:', err);
        // Retornar array vazio se a tabela não existir
        res.status(200).json([]);
    }
});

// Excluir publicação agendada
app.delete('/api/youtube/scheduled/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scheduledId = parseInt(req.params.id);

    if (!scheduledId || isNaN(scheduledId)) {
        return res.status(400).json({ msg: 'ID inválido.' });
    }

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const post = await db.get('SELECT * FROM scheduled_posts WHERE id = ? AND user_id = ?', [scheduledId, userId]);
        if (!post) {
            return res.status(404).json({ msg: 'Agendamento não encontrado.' });
        }

        await db.run('DELETE FROM scheduled_posts WHERE id = ? AND user_id = ?', [scheduledId, userId]);

        // Tentar limpar arquivos temporários (se existirem)
        const safeUnlink = (p) => {
            if (!p) return;
            try {
                const abs = path.isAbsolute(p) ? p : path.join(__dirname, p);
                if (fs.existsSync(abs)) fs.unlinkSync(abs);
            } catch (_) {}
        };
        safeUnlink(post.video_file_path);
        safeUnlink(post.thumbnail_url);

        return res.status(200).json({ msg: 'Agendamento excluído com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/scheduled/:id DELETE]:', err);
        return res.status(500).json({ msg: 'Erro ao excluir agendamento.' });
    }
});

// === PARTE 2.B: MONITORAMENTO AUTOMÁTICO ===

// B.1 - Alertas de Vídeos Virais: Verificar e notificar sobre vídeos virais de competidores
app.get('/api/youtube/viral-alerts', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        console.log(`[Viral Alerts] Buscando alertas para userId: ${userId}`);
        const alerts = await db.all(
            `SELECT * FROM viral_alerts 
             WHERE user_id = ? AND (notified = 0 OR notified IS NULL)
             ORDER BY detected_at DESC 
             LIMIT 50`,
            [userId]
        );

        console.log(`[Viral Alerts] ${alerts?.length || 0} alertas encontrados para userId: ${userId}`);
        res.status(200).json({ alerts: alerts || [] });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/viral-alerts]:', err);
        res.status(500).json({ msg: `Erro ao buscar alertas virais: ${err.message}` });
    }
});

// B.2 - Análise Automática de Tendências: Escanear YouTube por novos vídeos virais
app.post('/api/youtube/scan-trends', authenticateToken, async (req, res) => {
    const { 
        niche, 
        subniche, 
        maxResults = 10,
        minViews = 0,
        minViewsPerDay = 0,
        language = 'pt',
        publishedAfter = 7, // dias
        orderBy = 'viewCount', // viewCount, date, rating, relevance
        videoDuration = 'any', // any, short, medium, long
        videoDefinition = 'any' // any, high, standard
    } = req.body;
    const userId = req.user.id;

    if (!niche) {
        return res.status(400).json({ msg: 'Nicho é obrigatório para escanear tendências.' });
    }

    try {
        // Buscar chave do YouTube ou Gemini (necessária para YouTube API)
        // IMPORTANTE: A chave do Gemini pode ser usada para YouTube API, mas é melhor usar uma chave específica do YouTube
        // Tentar primeiro buscar chave do YouTube, depois Gemini como fallback
        let youtubeApiKey = null;
        
        // Tentar buscar chave do YouTube especificamente
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
        }
        
        // Se não tiver chave do YouTube, tentar Gemini
        if (!youtubeApiKey) {
            const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ 
                msg: 'Chave de API do YouTube ou Gemini é necessária para escanear tendências. Configure uma chave de API do YouTube Data API v3 nas Configurações.' 
            });
        }

        // Mapear idioma para código do YouTube
        const languageMap = {
            'pt': 'pt',
            'pt-BR': 'pt',
            'en': 'en',
            'es': 'es',
            'fr': 'fr',
            'de': 'de',
            'it': 'it',
            'ja': 'ja',
            'ko': 'ko',
            'zh': 'zh',
            'ru': 'ru'
        };
        const videoLanguage = languageMap[language] || 'pt';
        
        // Mapear duração do vídeo
        const durationMap = {
            'short': 'short', // menos de 4 minutos
            'medium': 'medium', // 4-20 minutos
            'long': 'long' // mais de 20 minutos
        };
        const videoDurationParam = durationMap[videoDuration] || 'any';
        
        // Mapear ordenação
        const orderMap = {
            'viewCount': 'viewCount',
            'date': 'date',
            'rating': 'rating',
            'relevance': 'relevance'
        };
        const orderParam = orderMap[orderBy] || 'viewCount';
        
        // Calcular data de publicação
        const publishedAfterDate = new Date(Date.now() - publishedAfter * 24 * 60 * 60 * 1000).toISOString();
        
        // Buscar vídeos virais recentes usando YouTube Data API
        const searchQuery = `${niche} ${subniche || ''}`.trim();
        
        // Construir URL com parâmetros
        let searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(searchQuery)}&type=video&order=${orderParam}&maxResults=${Math.min(maxResults, 50)}&publishedAfter=${publishedAfterDate}&relevanceLanguage=${videoLanguage}&key=${youtubeApiKey}`;
        
        // Adicionar filtro de duração se especificado
        if (videoDurationParam !== 'any') {
            searchUrl += `&videoDuration=${videoDurationParam}`;
        }
        
        // Adicionar filtro de definição se especificado
        if (videoDefinition !== 'any') {
            searchUrl += `&videoDefinition=${videoDefinition}`;
        }
        
        console.log(`[Scan Trends] Buscando tendências para: "${searchQuery}"`);
        console.log(`[Scan Trends] Filtros: minViews=${minViews}, minViewsPerDay=${minViewsPerDay}, language=${videoLanguage}, publishedAfter=${publishedAfter} dias, orderBy=${orderParam}, duration=${videoDurationParam}`);
        const searchResponse = await fetch(searchUrl);
        const searchData = await searchResponse.json();
        
        if (!searchResponse.ok) {
            console.error('[Scan Trends] Erro da API do YouTube:', JSON.stringify(searchData, null, 2));
            let errorMsg = 'Falha ao buscar vídeos do YouTube.';
            
            if (searchData.error) {
                if (searchData.error.message && searchData.error.message.includes('API key not valid')) {
                    errorMsg = 'A chave de API do YouTube não é válida. Verifique se a chave está correta e se a API do YouTube Data API v3 está habilitada no Google Cloud Console.';
                } else {
                    errorMsg = searchData.error.message || errorMsg;
                }
            }
            
            return res.status(400).json({ msg: errorMsg, trends: [] });
        }
        
        if (!searchData.items || searchData.items.length === 0) {
            return res.status(200).json({ trends: [], count: 0, msg: 'Nenhum vídeo encontrado para este nicho.' });
        }

        const videoIds = searchData.items.map(item => item.id.videoId).filter(Boolean).join(',');
        
        if (!videoIds) {
            return res.status(200).json({ trends: [], count: 0, msg: 'Nenhum vídeo válido encontrado.' });
        }

        // Buscar detalhes dos vídeos
        const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoIds}&key=${youtubeApiKey}`;
        const detailsResponse = await fetch(detailsUrl);
        const detailsData = await detailsResponse.json();
        
        if (!detailsResponse.ok) {
            console.error('[Scan Trends] Erro ao buscar detalhes:', detailsData);
            const errorMsg = detailsData.error?.message || 'Falha ao buscar detalhes dos vídeos.';
            return res.status(400).json({ msg: errorMsg, trends: [] });
        }

        const trends = [];
        const allVideos = [];
        
        for (const video of detailsData.items || []) {
            const views = parseInt(video.statistics.viewCount || 0);
            const publishedAt = new Date(video.snippet.publishedAt);
            const daysSince = Math.round((new Date() - publishedAt) / (1000 * 60 * 60 * 24));
            const viewsPerDay = daysSince > 0 ? views / daysSince : views;

            const videoData = {
                videoId: video.id,
                title: video.snippet.title,
                url: `https://www.youtube.com/watch?v=${video.id}`,
                channelId: video.snippet.channelId,
                channelName: video.snippet.channelTitle,
                views: views,
                viewsPerDay: Math.round(viewsPerDay),
                daysSince: daysSince,
                thumbnailUrl: video.snippet.thumbnails.high?.url || video.snippet.thumbnails.default?.url,
                isViral: isViralVideo(views, daysSince, viewsPerDay)
            };

            allVideos.push(videoData);

            // Verificar se é viral
            if (videoData.isViral) {
                // Salvar na tabela de tendências (ou atualizar se já existir)
                try {
                    await db.run(
                        `INSERT OR REPLACE INTO trend_analysis (user_id, niche, subniche, video_id, video_title, video_url, channel_id, channel_name, views, views_per_day, analyzed, detected_at)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)`,
                        [userId, niche, subniche || null, video.id, video.snippet.title, videoData.url, video.snippet.channelId, video.snippet.channelTitle, views, viewsPerDay]
                    );
                } catch (dbErr) {
                    console.error('[Scan Trends] Erro ao salvar tendência:', dbErr.message);
                }

                trends.push(videoData);
            }
        }

        console.log(`[Scan Trends] Total de vídeos encontrados: ${allVideos.length}, Vídeos virais: ${trends.length}`);
        
        // Se não encontrou vídeos virais, retornar os top vídeos encontrados mesmo assim
        const finalTrends = trends.length > 0 ? trends : allVideos.slice(0, Math.min(5, allVideos.length));
        
        res.status(200).json({ 
            trends: finalTrends,
            count: finalTrends.length,
            msg: finalTrends.length > 0 
                ? `${finalTrends.length} vídeo(s) ${trends.length > 0 ? 'viral(is)' : 'relevante(s)'} encontrado(s) no nicho ${niche}.`
                : `Nenhum vídeo encontrado para o nicho ${niche}.`
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/scan-trends]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao escanear tendências.' });
    }
});
// B.3 - Auto-análise de Canais Competidores: Adicionar canal para monitoramento automático
app.post('/api/youtube/monitor-competitor', authenticateToken, async (req, res) => {
    const { competitorChannelId, competitorChannelName, niche, subniche, autoAnalyze = true, checkFrequency = 'daily' } = req.body;
    const userId = req.user.id;

    if (!competitorChannelId) {
        return res.status(400).json({ msg: 'ID do canal competidor é obrigatório.' });
    }

    try {
        // Verificar se já está sendo monitorado
        const existing = await db.get(
            'SELECT * FROM competitor_monitoring WHERE user_id = ? AND competitor_channel_id = ?',
            [userId, competitorChannelId]
        );

        if (existing) {
            // Atualizar configurações
            await db.run(
                `UPDATE competitor_monitoring 
                 SET competitor_channel_name = ?, niche = ?, subniche = ?, auto_analyze = ?, check_frequency = ?
                 WHERE id = ?`,
                [competitorChannelName || existing.competitor_channel_name, niche || null, subniche || null, autoAnalyze ? 1 : 0, checkFrequency, existing.id]
            );
            return res.status(200).json({ id: existing.id, msg: 'Configurações de monitoramento atualizadas.' });
        } else {
            // Criar novo monitoramento
            const result = await db.run(
                `INSERT INTO competitor_monitoring (user_id, competitor_channel_id, competitor_channel_name, niche, subniche, auto_analyze, check_frequency)
                 VALUES (?, ?, ?, ?, ?, ?, ?)`,
                [userId, competitorChannelId, competitorChannelName || null, niche || null, subniche || null, autoAnalyze ? 1 : 0, checkFrequency]
            );
            return res.status(201).json({ id: result.lastID, msg: 'Canal adicionado para monitoramento automático.' });
        }
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/monitor-competitor]:', err);
        res.status(500).json({ msg: 'Erro ao configurar monitoramento.' });
    }
});

// Listar canais monitorados
app.get('/api/youtube/monitored-competitors', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const competitors = await db.all(
            'SELECT * FROM competitor_monitoring WHERE user_id = ? ORDER BY created_at DESC',
            [userId]
        );

        res.status(200).json({ competitors: competitors || [] });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/monitored-competitors]:', err);
        res.status(500).json({ msg: 'Erro ao listar canais monitorados.' });
    }
});

// Remover canal do monitoramento
app.delete('/api/youtube/monitor-competitor/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;

    try {
        const result = await db.run(
            'DELETE FROM competitor_monitoring WHERE id = ? AND user_id = ?',
            [id, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Monitoramento não encontrado.' });
        }

        res.status(200).json({ msg: 'Monitoramento removido com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/monitor-competitor DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao remover monitoramento.' });
    }
});

// B.4 - Sugestões Automáticas: IA sugere novos vídeos baseado em tendências
app.get('/api/youtube/ai-suggestions', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { limit = 10 } = req.query;

    try {
        const suggestions = await db.all(
            `SELECT * FROM ai_suggestions 
             WHERE user_id = ? AND viewed = 0 
             ORDER BY priority DESC, created_at DESC 
             LIMIT ?`,
            [userId, parseInt(limit)]
        );

        res.status(200).json({ suggestions: suggestions || [] });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/ai-suggestions]:', err);
        res.status(500).json({ msg: 'Erro ao buscar sugestões.' });
    }
});

// Gerar sugestões automáticas baseadas em tendências
app.post('/api/youtube/generate-suggestions', authenticateToken, async (req, res) => {
    const { niche, subniche } = req.body;
    const userId = req.user.id;

    if (!niche) {
        return res.status(400).json({ msg: 'Nicho é obrigatório para gerar sugestões.' });
    }

    try {
        console.log(`[Generate Suggestions] Iniciando para nicho: ${niche}, subniche: ${subniche}`);
        
        // Buscar tendências recentes do usuário (não analisadas ainda)
        const recentTrends = await db.all(
            `SELECT * FROM trend_analysis 
             WHERE user_id = ? AND niche = ? AND (analyzed = 0 OR analyzed IS NULL)
             ORDER BY detected_at DESC LIMIT 5`,
            [userId, niche]
        );
        
        console.log(`[Generate Suggestions] Tendências encontradas para nicho "${niche}": ${recentTrends.length}`);

        // Se não houver tendências salvas, buscar tendências em tempo real
        let trendsToUse = recentTrends;
        if (recentTrends.length === 0) {
            console.log(`[Generate Suggestions] Nenhuma tendência salva encontrada. Buscando tendências em tempo real...`);
            
            try {
                // Buscar chave do YouTube ou Gemini
                let youtubeApiKey = null;
                const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
                if (youtubeKeyData) {
                    youtubeApiKey = decrypt(youtubeKeyData.api_key);
                }
                if (!youtubeApiKey) {
                    const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
                    if (geminiKeyData) {
                        youtubeApiKey = decrypt(geminiKeyData.api_key);
                    }
                }
                
                if (youtubeApiKey) {
                    // Buscar vídeos recentes do nicho
                    const searchQuery = `${niche} ${subniche || ''}`.trim();
                    const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(searchQuery)}&type=video&order=viewCount&maxResults=5&publishedAfter=${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()}&relevanceLanguage=pt&key=${youtubeApiKey}`;
                    
                    const searchResponse = await fetch(searchUrl);
                    if (searchResponse.ok) {
                        const searchData = await searchResponse.json();
                        if (searchData.items && searchData.items.length > 0) {
                            const videoIds = searchData.items.map(item => item.id.videoId).filter(Boolean).join(',');
                            if (videoIds) {
                                const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoIds}&key=${youtubeApiKey}`;
                                const detailsResponse = await fetch(detailsUrl);
                                if (detailsResponse.ok) {
                                    const detailsData = await detailsResponse.json();
                                    // Criar objetos de tendência temporários
                                    trendsToUse = (detailsData.items || []).map(video => ({
                                        video_title: video.snippet.title,
                                        views: parseInt(video.statistics.viewCount || 0),
                                        views_per_day: Math.round((parseInt(video.statistics.viewCount || 0)) / Math.max(1, Math.round((new Date() - new Date(video.snippet.publishedAt)) / (1000 * 60 * 60 * 24)))),
                                        video_url: `https://www.youtube.com/watch?v=${video.id}`,
                                        channel_name: video.snippet.channelTitle
                                    }));
                                    console.log(`[Generate Suggestions] ${trendsToUse.length} tendências encontradas em tempo real`);
                                }
                            }
                        }
                    }
                }
            } catch (trendsErr) {
                console.warn(`[Generate Suggestions] Erro ao buscar tendências em tempo real:`, trendsErr.message);
            }
        }

        // Se ainda não houver tendências, usar o nicho diretamente
        if (trendsToUse.length === 0) {
            console.log(`[Generate Suggestions] Nenhuma tendência disponível. Gerando sugestões baseadas apenas no nicho "${niche}"`);
        }

        // Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem plano que permite API própria OU não tem API própria configurada
        // REGRA CRÍTICA: Se preferência NÃO está marcada E usuário tem plano que permite E tem API própria → usar API própria
        const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
        
        console.log(`[Generate Suggestions] shouldUseCredits: ${creditsCheck.shouldUse}, reason: ${creditsCheck.reason}`);
        
        let suggestions = [];
        
        // Se deve usar créditos, usar laozhang.ai primeiro
        if (creditsCheck.shouldUse) {
            console.log('[Generate Suggestions] Verificando chave laozhang.ai...');
            const laozhangKey = await getLaozhangApiKey();
            console.log('[Generate Suggestions] Chave laozhang.ai encontrada:', laozhangKey ? 'Sim' : 'Não');
            if (laozhangKey) {
                try {
                    let trendsSummary = '';
                    if (trendsToUse.length > 0) {
                        trendsSummary = trendsToUse.map(t => `- "${t.video_title}" (${t.views} views${t.views_per_day ? ` em ${t.views_per_day} views/dia` : ''})`).join('\n');
                    }

                    const prompt = `Você é um ESPECIALISTA EM CRIAÇÃO DE CONTEÚDO VIRAL PARA YOUTUBE com conhecimento profundo sobre tendências, algoritmos e o que faz um vídeo viralizar.

${trendsToUse.length > 0 ? `Analise as seguintes tendências virais no nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''}:

${trendsSummary}

Com base nessas tendências virais, sugira 5 NOVOS vídeos que o criador poderia fazer para aproveitar essas tendências e potencialmente viralizar também.` : `O criador está interessado no nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''}.

Com base nas tendências atuais deste nicho no YouTube, sugira 5 NOVOS vídeos com alto potencial viral que o criador poderia fazer.`}

Para cada sugestão, forneça:
1. Um título viral e chamativo
2. Uma breve descrição do conceito do vídeo
3. O motivo pelo qual esta ideia tem potencial de viralizar

Responda APENAS com um JSON válido no formato:
{
  "suggestions": [
    {
      "title": "Título viral sugerido",
      "description": "Descrição do conceito do vídeo",
      "reason": "Por que esta ideia tem potencial de viralizar",
      "priority": 8 (1-10, sendo 10 o maior potencial)
    },
    ...
  ]
}

IMPORTANTE: 
- Os títulos devem ser em português (Brasil)
- Foque em ideias que aproveitem os padrões das tendências analisadas
- Seja específico e criativo
- Priorize ideias com alto potencial de engajamento

Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await callLaozhangAPI(prompt, laozhangKey, 'gpt-4o', null, userId, '/api/youtube/generate-suggestions', JSON.stringify({ endpoint: '/api/youtube/generate-suggestions', model: 'gpt-4o' }));
                    // callLaozhangAPI retorna uma string diretamente, não um objeto
                    const responseText = typeof response === 'string' ? response : (response?.titles || response?.text || response?.content || JSON.stringify(response) || '');
                    
                    console.log(`[Sugestões IA] Resposta recebida (${responseText.length} caracteres)`);
                    console.log(`[Sugestões IA] Primeiros 500 caracteres:`, responseText.substring(0, 500));
                    
                    // Verificar se a API recusou a requisição (apenas se for uma mensagem de erro clara, não JSON válido)
                    const hasValidJson = responseText.match(/\{[\s\S]*"suggestions"[\s\S]*\}/) || responseText.match(/\{[\s\S]*"title"[\s\S]*\}/);
                    
                    if (!hasValidJson) {
                        const errorPatterns = [
                            /^I'm sorry,?\s+I can't assist/i,
                            /^I'm sorry,?\s+I cannot/i,
                            /^I'm unable to assist/i,
                            /^I cannot fulfill/i,
                            /^I must decline/i,
                            /^I can't help with that/i,
                            /^I'm not able to/i,
                            /^This request violates/i,
                            /^I cannot comply/i
                        ];
                        
                        const trimmedResponse = responseText.trim();
                        const isError = errorPatterns.some(pattern => pattern.test(trimmedResponse));
                        
                        if (isError || (trimmedResponse.length < 100 && trimmedResponse.toLowerCase().startsWith("i'm sorry"))) {
                            console.error('[Sugestões IA] API recusou a requisição:', responseText.substring(0, 500));
                            throw new Error(`A API de IA recusou processar o prompt. Isso pode acontecer se o conteúdo violar as políticas de uso da API. Tente simplificar o conteúdo ou remover conteúdo sensível.`);
                        }
                    }
                    
                    // Tentar extrair JSON da resposta - usar regex mais robusto para pegar JSON completo
                    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    // Se não encontrar, tentar remover markdown code blocks
                    if (!jsonMatch) {
                        const cleaned = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                        jsonMatch = cleaned.match(/\{[\s\S]*\}/);
                    }
                    
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.suggestions && Array.isArray(parsed.suggestions)) {
                                // Salvar sugestões no banco
                                for (const suggestion of parsed.suggestions) {
                                    try {
                                        await db.run(
                                            `INSERT INTO ai_suggestions (user_id, suggestion_type, title, description, niche, subniche, reason, priority, viewed, created_at)
                                             VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)`,
                                            [userId, 'trend_based', suggestion.title || 'Sugestão sem título', suggestion.description || 'Sem descrição', niche, subniche || null, suggestion.reason || 'Baseado em tendências virais', suggestion.priority || 5]
                                        );
                                        console.log(`[Sugestões IA] Sugestão salva: "${suggestion.title || 'Sem título'}"`);
                                    } catch (dbErr) {
                                        console.error(`[Sugestões IA] Erro ao salvar sugestão:`, dbErr.message);
                                    }
                                }
                                suggestions = parsed.suggestions;
                                console.log(`[Sugestões IA] ✅ ${suggestions.length} sugestões geradas usando API configurada como padrão`);
                            } else {
                                console.warn(`[Sugestões IA] Resposta não tem formato esperado (sem array 'suggestions')`);
                                console.warn(`[Sugestões IA] Estrutura recebida:`, Object.keys(parsed));
                            }
                        } catch (e) {
                            console.warn(`[Sugestões IA] Falha ao parsear JSON:`, e.message);
                            console.warn(`[Sugestões IA] JSON encontrado:`, jsonMatch[0].substring(0, 500));
                        }
                    } else {
                        console.warn(`[Sugestões IA] Nenhum JSON encontrado na resposta`);
                        console.warn(`[Sugestões IA] Resposta completa:`, responseText.substring(0, 1000));
                    }
                } catch (serviceErr) {
                    console.error(`[Sugestões IA] Erro ao usar API configurada como padrão:`, serviceErr.message);
                    // Se deve usar créditos e laozhang falhou, não tentar APIs próprias
                    if (creditsCheck.shouldUse) {
                        return res.status(500).json({ 
                            suggestions: [],
                            count: 0,
                            msg: 'Erro ao gerar sugestões usando sistema de créditos. Verifique se a chave está configurada corretamente no painel admin.' 
                        });
                    }
                }
            } else if (creditsCheck.shouldUse) {
                // Se deve usar créditos mas não tem chave
                return res.status(400).json({ 
                    suggestions: [],
                    count: 0,
                    msg: 'API configurada como padrão não está configurada. Configure a chave no painel admin ou desmarque a opção de usar créditos.' 
                });
            }
        }
        
        // Se não usar créditos ou se laozhang falhou (e não é obrigatório), usar APIs próprias
        if (suggestions.length === 0 && !creditsCheck.shouldUse) {
            // Tentar usar IA para gerar sugestões baseadas nas tendências
            const services = ['gemini', 'claude', 'openai'];

            for (const service of services) {
                try {
                    const serviceKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                    if (!serviceKeyData) continue;

                    const decryptedKey = decrypt(serviceKeyData.api_key);
                    if (!decryptedKey) continue;

                    let apiCallFunction;
                    let model;
                    if (service === 'gemini') {
                        apiCallFunction = callGeminiAPI;
                        model = 'gemini-2.0-flash';
                    } else if (service === 'claude') {
                        apiCallFunction = callClaudeAPI;
                        model = 'claude-3-5-haiku-20241022';
                    } else {
                        apiCallFunction = callOpenAIAPI;
                        model = 'gpt-4o'; // Usar GPT-4o como padrão
                    }

                    const trendsSummary = trendsToUse.length > 0 
                        ? trendsToUse.map(t => `- "${t.video_title}" (${t.views} views${t.views_per_day ? ` em ${t.views_per_day} views/dia` : ''})`).join('\n')
                        : '';

                    const prompt = trendsToUse.length > 0 
                        ? `Você é um ESPECIALISTA EM CRIAÇÃO DE CONTEÚDO VIRAL PARA YOUTUBE com conhecimento profundo sobre tendências, algoritmos e o que faz um vídeo viralizar.

Analise as seguintes tendências virais no nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''}:

${trendsSummary}

Com base nessas tendências virais, sugira 5 NOVOS vídeos que o criador poderia fazer para aproveitar essas tendências e potencialmente viralizar também.`
                        : `Você é um ESPECIALISTA EM CRIAÇÃO DE CONTEÚDO VIRAL PARA YOUTUBE com conhecimento profundo sobre tendências, algoritmos e o que faz um vídeo viralizar.

O criador está interessado no nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''}.

Com base nas tendências atuais deste nicho no YouTube, sugira 5 NOVOS vídeos com alto potencial viral que o criador poderia fazer.

Para cada sugestão, forneça:
1. Um título viral e chamativo
2. Uma breve descrição do conceito do vídeo
3. O motivo pelo qual esta ideia tem potencial de viralizar

Responda APENAS com um JSON válido no formato:
{
  "suggestions": [
    {
      "title": "Título viral sugerido",
      "description": "Descrição do conceito do vídeo",
      "reason": "Por que esta ideia tem potencial de viralizar",
      "priority": 8 (1-10, sendo 10 o maior potencial)
    },
    ...
  ]
}

IMPORTANTE: 
- Os títulos devem ser em português (Brasil)
- Foque em ideias que aproveitem os padrões das tendências analisadas
- Seja específico e criativo
- Priorize ideias com alto potencial de engajamento

Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await apiCallFunction(prompt, decryptedKey, model);
                    // A resposta pode ser string direta ou objeto
                    const responseText = typeof response === 'string' ? response : (response?.titles || response?.text || response?.content || JSON.stringify(response) || '');
                    
                    console.log(`[Sugestões IA] Resposta de ${service} (${responseText.length} caracteres)`);
                    
                    // Tentar extrair JSON da resposta - usar regex mais robusto para pegar JSON completo
                    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    // Se não encontrar, tentar remover markdown code blocks
                    if (!jsonMatch) {
                        const cleaned = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                        jsonMatch = cleaned.match(/\{[\s\S]*\}/);
                    }
                    
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.suggestions && Array.isArray(parsed.suggestions)) {
                                // Salvar sugestões no banco
                                for (const suggestion of parsed.suggestions) {
                                    try {
                                        await db.run(
                                            `INSERT INTO ai_suggestions (user_id, suggestion_type, title, description, niche, subniche, reason, priority, viewed, created_at)
                                             VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)`,
                                            [userId, 'trend_based', suggestion.title || 'Sugestão sem título', suggestion.description || 'Sem descrição', niche, subniche || null, suggestion.reason || 'Baseado em tendências virais', suggestion.priority || 5]
                                        );
                                        console.log(`[Sugestões IA] Sugestão salva: "${suggestion.title || 'Sem título'}"`);
                                    } catch (dbErr) {
                                        console.error(`[Sugestões IA] Erro ao salvar sugestão:`, dbErr.message);
                                    }
                                }
                                suggestions = parsed.suggestions;
                                console.log(`[Sugestões IA] ✅ ${suggestions.length} sugestões geradas e salvas usando ${service}`);
                                break;
                            } else {
                                console.warn(`[Sugestões IA] Resposta de ${service} não tem formato esperado (sem array 'suggestions')`);
                            }
                        } catch (e) {
                            console.warn(`[Sugestões IA] Falha ao parsear JSON de ${service}:`, e.message);
                            console.warn(`[Sugestões IA] JSON encontrado:`, jsonMatch[0].substring(0, 500));
                        }
                    } else {
                        console.warn(`[Sugestões IA] Nenhum JSON encontrado na resposta de ${service}`);
                    }
                } catch (serviceErr) {
                    console.warn(`[Sugestões IA] Falha com ${service}:`, serviceErr.message);
                    continue;
                }
            }
        }

        // Fallback: gerar sugestões básicas baseadas nos títulos das tendências
        if (suggestions.length === 0 && recentTrends.length > 0) {
            console.log(`[Sugestões IA] Gerando sugestões básicas baseadas em ${recentTrends.length} tendências`);
            for (const trend of recentTrends.slice(0, 3)) {
                try {
                    await db.run(
                        `INSERT INTO ai_suggestions (user_id, suggestion_type, title, description, niche, subniche, reason, priority, viewed, created_at)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)`,
                        [userId, 'trend_based', `Versão adaptada: ${trend.video_title}`, `Crie uma versão adaptada deste vídeo viral para seu canal`, niche, subniche || null, `Baseado no vídeo viral "${trend.video_title}" com ${trend.views} views`, 7]
                    );
                } catch (dbErr) {
                    console.error(`[Sugestões IA] Erro ao salvar sugestão básica:`, dbErr.message);
                }
            }
            suggestions = recentTrends.slice(0, 3).map(t => ({
                title: `Versão adaptada: ${t.video_title}`,
                description: `Crie uma versão adaptada deste vídeo viral para seu canal`,
                reason: `Baseado no vídeo viral com ${t.views} views`,
                priority: 7
            }));
            console.log(`[Sugestões IA] ✅ ${suggestions.length} sugestões básicas geradas`);
        }

        res.status(200).json({ 
            suggestions: suggestions,
            count: suggestions.length,
            msg: `${suggestions.length} sugestão(ões) gerada(s) com sucesso.`
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/generate-suggestions]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar sugestões.' });
    }
});

// Marcar sugestão como visualizada
app.put('/api/youtube/ai-suggestions/:id/viewed', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;

    try {
        await db.run(
            'UPDATE ai_suggestions SET viewed = 1 WHERE id = ? AND user_id = ?',
            [id, userId]
        );

        res.status(200).json({ msg: 'Sugestão marcada como visualizada.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/ai-suggestions PUT]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar sugestão.' });
    }
});

// === ROTAS DE GERENCIAMENTO DE CANAIS DO USUÁRIO ===

// Criar/Atualizar canal do usuário
app.post('/api/channels', authenticateToken, async (req, res) => {
    const { channelName, channelUrl, channelId, niche, language, country } = req.body;
    const userId = req.user.id;

    if (!channelName) {
        return res.status(400).json({ msg: 'Nome do canal é obrigatório.' });
    }

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        // Verificar se já existe um canal com o mesmo nome para este usuário
        const existing = await db.get('SELECT id FROM user_channels WHERE user_id = ? AND channel_name = ?', [userId, channelName]);
        
        if (existing) {
            // Atualizar canal existente
            await db.run(
                `UPDATE user_channels 
                 SET channel_url = ?, channel_id = ?, niche = ?, language = ?, country = ?, updated_at = CURRENT_TIMESTAMP 
                 WHERE id = ? AND user_id = ?`,
                [channelUrl || null, channelId || null, niche || null, language || 'pt-BR', country || 'BR', existing.id, userId]
            );
            console.log(`[Canais] Canal ${existing.id} atualizado pelo usuário ${userId}`);
            res.status(200).json({ id: existing.id, msg: 'Canal atualizado com sucesso.' });
        } else {
            // Verificar limite de 10 canais ATIVOS por usuário (evita travar quando existem canais inativos)
            const channelCount = await db.get('SELECT COUNT(*) as count FROM user_channels WHERE user_id = ? AND is_active = 1', [userId]);
            if (channelCount && channelCount.count >= 10) {
                return res.status(400).json({ msg: 'Limite de 10 canais ativos atingido. Desative ou exclua um canal antes de adicionar outro.' });
            }
            // Criar novo canal
            const result = await db.run(
                `INSERT INTO user_channels (user_id, channel_name, channel_url, channel_id, niche, language, country) 
                 VALUES (?, ?, ?, ?, ?, ?, ?)`,
                [userId, channelName, channelUrl || null, channelId || null, niche || null, language || 'pt-BR', country || 'BR']
            );
            console.log(`[Canais] Canal ${result.lastID} criado pelo usuário ${userId}`);
            res.status(201).json({ id: result.lastID, msg: 'Canal criado com sucesso.' });
        }
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels POST]:', err);
        if (err.message.includes('UNIQUE constraint failed')) {
            return res.status(400).json({ msg: 'Já existe um canal com este nome.' });
        }
        res.status(500).json({ msg: 'Erro ao criar/atualizar canal.' });
    }
});

// Listar canais do usuário
app.get('/api/channels', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        // 🔄 Sincronizar canais conectados do YouTube (youtube_integrations) para aparecerem automaticamente no "Analytics e Performance"
        // Isso evita o usuário ter que cadastrar canal manualmente após conectar via OAuth.
        try {
            const ytIntegrations = await db.all(
                'SELECT channel_id, channel_name, niche, language, country FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
                [userId]
            );
            if (ytIntegrations && ytIntegrations.length > 0) {
                for (const yt of ytIntegrations) {
                    if (!yt?.channel_id) continue;
                    const channelUrl = `https://www.youtube.com/channel/${yt.channel_id}`;
                    const existing = await db.get(
                        'SELECT id FROM user_channels WHERE user_id = ? AND channel_id = ? LIMIT 1',
                        [userId, yt.channel_id]
                    );
                    if (existing?.id) {
                        await db.run(
                            `UPDATE user_channels
                             SET channel_name = COALESCE(?, channel_name),
                                 channel_url = COALESCE(?, channel_url),
                                 niche = COALESCE(niche, ?),
                                 language = COALESCE(language, ?),
                                 country = COALESCE(country, ?),
                                 is_active = 1,
                                 updated_at = CURRENT_TIMESTAMP
                             WHERE id = ? AND user_id = ?`,
                            [yt.channel_name || null, channelUrl, yt.niche || null, yt.language || 'pt-BR', yt.country || 'BR', existing.id, userId]
                        );
                    } else {
                        // Respeitar o limite do app (10 ativos) — mas o YouTube também limita a 10 integrações ativas, então normalmente não estoura.
                        const activeCount = await db.get('SELECT COUNT(*) as count FROM user_channels WHERE user_id = ? AND is_active = 1', [userId]);
                        if ((activeCount?.count || 0) >= 10) break;
                        await db.run(
                            `INSERT INTO user_channels (user_id, channel_name, channel_url, channel_id, niche, language, country, is_active)
                             VALUES (?, ?, ?, ?, ?, ?, ?, 1)`,
                            [userId, yt.channel_name || 'Canal do YouTube', channelUrl, yt.channel_id, yt.niche || null, yt.language || 'pt-BR', yt.country || 'BR']
                        );
                    }
                }
            }
        } catch (syncErr) {
            console.warn('[Canais] Falha ao sincronizar canais do YouTube para user_channels:', syncErr.message);
        }

        const channels = await db.all(
            'SELECT * FROM user_channels WHERE user_id = ? ORDER BY created_at DESC',
            [userId]
        );
        res.status(200).json(channels || []);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels GET]:', err);
        res.status(500).json({ msg: 'Erro ao listar canais.' });
    }
});

// Excluir canal do usuário
app.delete('/api/channels/:id', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const result = await db.run('DELETE FROM user_channels WHERE id = ? AND user_id = ?', [id, userId]);
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Canal não encontrado ou não pertence a este usuário.' });
        }

        console.log(`[Canais] Canal ${id} excluído pelo usuário ${userId}`);
        res.status(200).json({ msg: 'Canal excluído com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir canal.' });
    }
});

// Atualizar status do canal (ativar/desativar)
app.put('/api/channels/:id/status', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const { isActive } = req.body;
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const result = await db.run(
            'UPDATE user_channels SET is_active = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ? AND user_id = ?',
            [isActive ? 1 : 0, id, userId]
        );
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Canal não encontrado ou não pertence a este usuário.' });
        }

        console.log(`[Canais] Status do canal ${id} atualizado para ${isActive ? 'ativo' : 'inativo'} pelo usuário ${userId}`);
        res.status(200).json({ msg: 'Status do canal atualizado com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/:id/status PUT]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar status do canal.' });
    }
});

// Buscar informações do canal a partir da URL
app.post('/api/channels/fetch-info', authenticateToken, async (req, res) => {
    const { channelUrl } = req.body;
    const userId = req.user.id;

    if (!channelUrl) {
        return res.status(400).json({ msg: 'URL do canal é obrigatória.' });
    }

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        if (!geminiKeyData) {
            return res.status(400).json({ msg: 'Chave de API do Gemini é necessária.' });
        }
        const geminiApiKey = decrypt(geminiKeyData.api_key);
        if (!geminiApiKey) {
            return res.status(500).json({ msg: 'Falha ao desencriptar a chave do Gemini.' });
        }

        // Extrair ID do canal da URL
        const match = channelUrl.match(/youtube\.com\/(?:@([\w.-]+)|channel\/([\w-]+)|c\/([\w-]+)|user\/([\w-]+))/);
        if (!match) {
            return res.status(400).json({ msg: 'Formato de URL do canal não suportado.' });
        }

        let ytChannelId;
        const handle = match[1];
        const legacyId = match[2] || match[3] || match[4];

        if (handle) {
            const searchApiUrl = `https://www.googleapis.com/youtube/v3/search?part=id&q=${encodeURIComponent(handle)}&type=channel&maxResults=1&key=${geminiApiKey}`;
            const searchResponse = await fetch(searchApiUrl);
            const searchData = await searchResponse.json();
            if (searchResponse.ok && searchData.items && searchData.items.length > 0) {
                ytChannelId = searchData.items[0].id.channelId;
            }
        } else if (legacyId) {
            ytChannelId = legacyId;
        }

        if (!ytChannelId) {
            return res.status(400).json({ msg: 'Não foi possível determinar o ID do canal.' });
        }

        // Buscar informações do canal
        const channelUrl_api = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${ytChannelId}&key=${geminiApiKey}`;
        const channelResponse = await fetch(channelUrl_api);
        const channelData = await channelResponse.json();

        if (!channelResponse.ok || !channelData.items || channelData.items.length === 0) {
            return res.status(400).json({ msg: 'Canal não encontrado.' });
        }

        const channel = channelData.items[0];
        const channelName = channel.snippet.title;
        const channelDescription = channel.snippet.description || '';
        const country = channel.snippet.country || 'BR';
        
        // Detectar idioma baseado no país ou descrição
        let language = 'pt-BR';
        if (country === 'US' || country === 'GB' || country === 'CA' || country === 'AU') {
            language = 'en-US';
        } else if (country === 'ES' || country === 'MX' || country === 'AR' || country === 'CO') {
            language = 'es-ES';
        } else if (country === 'FR') {
            language = 'fr-FR';
        } else if (country === 'DE') {
            language = 'de-DE';
        } else if (country === 'IT') {
            language = 'it-IT';
        } else if (country === 'JP') {
            language = 'ja-JP';
        } else if (country === 'KR') {
            language = 'ko-KR';
        } else if (country === 'CN') {
            language = 'zh-CN';
        }

        // Usar IA para detectar nicho (obrigatório)
        let niche = '';
        try {
            const nichePrompt = `Analise este canal do YouTube e identifique o nicho principal em uma palavra ou frase curta (máximo 3 palavras). Seja específico e preciso.
Nome do Canal: ${channelName}
Descrição: ${channelDescription.substring(0, 500)}

IMPORTANTE: Responda APENAS com o nicho, sem explicações adicionais, sem pontos, sem aspas, sem nada além do nicho.
Exemplos válidos: Tecnologia, Educação Financeira, Gaming, Culinária, Fitness, Entretenimento, História, Ciência, Viagens.

Nicho identificado:`;
            
            console.log('[Canais] Detectando nicho do canal:', channelName);
            const nicheResponse = await callGeminiAPI(nichePrompt, geminiApiKey, 'gemini-2.0-flash-exp');
            if (nicheResponse && nicheResponse.titles) {
                niche = nicheResponse.titles.trim()
                    .split('\n')[0]
                    .replace(/^["']|["']$/g, '') // Remove aspas
                    .replace(/^\.+/, '') // Remove pontos no início
                    .substring(0, 50)
                    .trim();
                console.log('[Canais] Nicho detectado:', niche);
            }
            if (!niche || niche.length < 2) {
                console.warn('[Canais] Nicho não detectado ou muito curto, usando fallback');
                // Fallback: usar primeira palavra da descrição ou nome do canal
                niche = channelDescription.split(' ').slice(0, 2).join(' ').substring(0, 30) || channelName.split(' ').slice(0, 2).join(' ').substring(0, 30) || 'Entretenimento';
            }
        } catch (nicheErr) {
            console.warn('[Canais] Erro ao detectar nicho:', nicheErr.message);
            // Fallback: usar primeira palavra do nome do canal
            niche = channelName.split(' ').slice(0, 2).join(' ').substring(0, 30) || 'Entretenimento';
        }

        // Garantir que sempre há um nicho
        if (!niche || niche.length < 2) {
            niche = 'Entretenimento';
        }

        const responseData = {
            channelName,
            channelId: ytChannelId,
            niche: niche,
            language,
            country
        };
        
        console.log('[Canais] Retornando dados do canal:', responseData);
        res.status(200).json(responseData);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/fetch-info]:', err);
        res.status(500).json({ msg: 'Erro ao buscar informações do canal.' });
    }
});

// === ANIMAÇÃO PARALLAX ===
app.post('/api/animate/parallax', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { base64, imageUrl, sceneNumber, duration = 5 } = req.body || {};
    try {
        let imgBuffer;
        if (base64 && typeof base64 === 'string') {
            const commaIdx = base64.indexOf(',');
            const raw = commaIdx >= 0 ? base64.slice(commaIdx + 1) : base64;
            imgBuffer = Buffer.from(raw, 'base64');
        } else if (imageUrl) {
            const resp = await fetch(imageUrl);
            if (!resp.ok) throw new Error('Falha ao baixar imagem');
            imgBuffer = Buffer.from(await resp.arrayBuffer());
        } else {
            return res.status(400).json({ msg: 'Envie base64 ou imageUrl para animar.' });
        }
        const tmpDir = TEMP_DIR || path.join(process.cwd(), 'temp_audio');
        const imgPath = path.join(tmpDir, `parallax_${Date.now()}.png`);
        const outPath = path.join(tmpDir, `parallax_${Date.now()}.mp4`);
        fs.writeFileSync(imgPath, imgBuffer);
        const py = (() => {
            try { execSync('python3 --version', { stdio: 'ignore' }); return 'python3'; } catch {}
            try { execSync('python --version', { stdio: 'ignore' }); return 'python'; } catch {}
            return 'python3';
        })();
        
        // Escapar caminhos corretamente para Windows (caminhos com espaços)
        const scriptPath = path.join(__dirname, 'animator_depth.py');
        // No Windows, usar aspas duplas e escapar corretamente
        const escapePath = (p) => {
            // Normalizar caminho e adicionar aspas se necessário
            const normalized = path.normalize(p);
            // Se contém espaços, adicionar aspas e escapar aspas internas
            if (normalized.includes(' ')) {
                return `"${normalized.replace(/"/g, '\\"')}"`;
            }
            return normalized;
        };
        
        const cmd = `${py} ${escapePath(scriptPath)} --input ${escapePath(imgPath)} --output ${escapePath(outPath)} --duration ${duration}`;
        const { stdout, stderr } = await execAsync(cmd, { maxBuffer: 1024 * 1024 * 50 });
        const videoB64 = fs.readFileSync(outPath).toString('base64');
        try { fs.unlinkSync(imgPath); fs.unlinkSync(outPath); } catch {}
        return res.json({ success: true, sceneNumber: sceneNumber || null, videoBase64: `data:video/mp4;base64,${videoB64}` });
    } catch (err) {
        console.error('[Parallax] Erro:', err.message);
        return res.status(500).json({ msg: `Falha parallax: ${err.message}` });
    }
});

// Rotas do Meta.ai e HuMo removidas - usando apenas Parallax

// ============================================
// INICIAR SERVIDOR (DEPOIS DE TODAS AS ROTAS)
// ============================================
// Variável para garantir que o servidor só inicie UMA vez (proteção contra race condition)
let serverStarted = false;

// Função única para iniciar o servidor (garante que só inicie uma vez)
function startServer() {
    // Verificação dupla: flag + app.listening para garantir que não inicie duas vezes
    if (serverStarted) {
        return;
    }
    
    // Marcar como iniciado ANTES de tentar iniciar (previne race condition)
    serverStarted = true;
    
    // Iniciar servidor
    try {
        const server = app.listen(PORT, () => {
            console.log(`🚀 Servidor "La Casa Dark Core" a rodar na porta ${PORT}`);
            if (!db) {
                console.log(`⚠️  Banco de dados ainda não está pronto. Algumas funcionalidades podem não estar disponíveis.`);
            } else {
                console.log(`✅ Todas as rotas registradas e funcionando!`);
            }
            
            // Restaurar loops ativos em background (não bloqueia o servidor)
            // Verifica se o banco está pronto antes de executar
            const checkAndRestore = () => {
                if (global.dbReady && db) {
                    restoreActiveLoops().catch(err => {
                        console.error('[NOTIFICATIONS] Erro ao restaurar loops (não crítico):', err.message);
                    });
                } else {
                    // Tentar novamente após 1 segundo se o banco ainda não estiver pronto
                    setTimeout(checkAndRestore, 1000);
                }
            };
            setTimeout(checkAndRestore, 500); // Iniciar verificação após 500ms
        });
        
        // Tratamento de erro para porta em uso
        server.on('error', (err) => {
            if (err.code === 'EADDRINUSE') {
                console.error(`❌ Erro: A porta ${PORT} já está em uso.`);
                console.error(`   Por favor, encerre o processo que está usando a porta ${PORT} e tente novamente.`);
                console.error(`   Comando: netstat -ano | findstr :${PORT}`);
            } else {
                console.error('❌ Erro ao iniciar servidor:', err.message);
            }
            // Resetar flag em caso de erro para permitir nova tentativa
            serverStarted = false;
        });
    } catch (err) {
        console.error('❌ Erro ao iniciar servidor:', err.message);
        serverStarted = false;
    }
}

// === SERVIÇO DE TRADUÇÃO ONLINE (Gratuito) ===

/**
 * Traduz texto usando múltiplas APIs gratuitas com fallback
 * Ordem de prioridade:
 * 1. MyMemory Translation API (gratuito, 500 requisições/dia)
 * 2. LibreTranslate (open-source, sem limite se self-hosted)
 * 3. Google Translate via scraping (fallback)
 */
async function translateText(text, fromLang = 'auto', toLang = 'pt') {
    if (!text || text.trim().length === 0) {
        return text;
    }

    // MÉTODO 1: MyMemory Translation API (GRATUITO - 500 req/dia)
    try {
        console.log(`[Tradução] Tentando MyMemory API: ${fromLang} → ${toLang}`);
        const mymemoryUrl = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${fromLang}|${toLang}`;
        const response = await fetch(mymemoryUrl);
        const data = await response.json();
        
        if (response.ok && data.responseData && data.responseData.translatedText) {
            console.log(`[Tradução] ✅ Sucesso com MyMemory API`);
            return data.responseData.translatedText;
        }
    } catch (err) {
        console.warn(`[Tradução] MyMemory falhou:`, err.message);
    }

    // MÉTODO 2: LibreTranslate API (GRATUITO - public instance)
    try {
        console.log(`[Tradução] Tentando LibreTranslate API`);
        const libreTranslateUrl = 'https://libretranslate.de/translate';
        const response = await fetch(libreTranslateUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                q: text,
                source: fromLang === 'auto' ? 'en' : fromLang,
                target: toLang,
                format: 'text'
            })
        });
        const data = await response.json();
        
        if (response.ok && data.translatedText) {
            console.log(`[Tradução] ✅ Sucesso com LibreTranslate API`);
            return data.translatedText;
        }
    } catch (err) {
        console.warn(`[Tradução] LibreTranslate falhou:`, err.message);
    }

    // MÉTODO 3: Usar Gemini AI como fallback (se disponível)
    try {
        console.log(`[Tradução] Tentando fallback com IA interna`);
        // Se o usuário tiver Gemini configurado, podemos usar para tradução
        return text; // Por enquanto retorna o original se todos falharem
    } catch (err) {
        console.warn(`[Tradução] Todos os métodos falharam`);
    }

    return text; // Retorna texto original se todas as traduções falharem
}

// Variável para armazenar os intervalos de notificações
const notificationLoops = {
    purchase: null,
    user: null
};

// Função para iniciar um loop de notificações
async function startNotificationLoop(loopType, intervalSeconds) {
    // Parar loop existente se houver
    if (notificationLoops[loopType]) {
        clearInterval(notificationLoops[loopType]);
        notificationLoops[loopType] = null;
    }
    
    console.log(`[NOTIFICATIONS] Iniciando loop ${loopType} com intervalo de ${intervalSeconds} segundos`);
    
    // Executar imediatamente na primeira vez
    await processNotificationLoop(loopType);
    
    // Configurar intervalo
    notificationLoops[loopType] = setInterval(async () => {
        await processNotificationLoop(loopType);
    }, intervalSeconds * 1000);
}

// Função para processar um loop de notificações
async function processNotificationLoop(loopType) {
    try {
        // Verificar se o loop ainda está ativo
        const loopStatus = await db.get('SELECT is_active FROM active_loops WHERE loop_type = ?', [loopType]);
        if (!loopStatus || loopStatus.is_active !== 1) {
            console.log(`[NOTIFICATIONS] Loop ${loopType} não está mais ativo, parando...`);
            if (notificationLoops[loopType]) {
                clearInterval(notificationLoops[loopType]);
                notificationLoops[loopType] = null;
            }
            return;
        }
        
        // Obter configurações
        const configs = await db.all('SELECT key, value FROM notification_config');
        const config = {};
        configs.forEach(c => { config[c.key] = c.value; });
        
        const enabled = config[`${loopType}_enabled`] === 'true';
        if (!enabled) {
            return; // Loop desabilitado
        }
        
        const interval = parseInt(config[`${loopType}_interval`]) || 5;
        const message = config[`${loopType}_message`] || '';
        
        // Buscar usuários fictícios ativos do tipo correto
        const fakeUsers = await db.all(
            'SELECT * FROM fake_users WHERE type = ? AND is_active = 1 ORDER BY RANDOM() LIMIT 1',
            [loopType]
        );
        
        if (fakeUsers.length === 0) {
            console.log(`[NOTIFICATIONS] Nenhum usuário fictício ${loopType} disponível`);
            return;
        }
        
        const fakeUser = fakeUsers[0];
        
        // Criar mensagem personalizada
        let notificationMessage = message;
        notificationMessage = notificationMessage.replace(/{name}/g, fakeUser.name);
        if (loopType === 'purchase' && fakeUser.plan_name) {
            notificationMessage = notificationMessage.replace(/{plan}/g, fakeUser.plan_name);
        }
        
        // Criar notificação global (user_id = null para todos verem)
        await db.run(
            'INSERT INTO notifications (user_id, title, message, type, is_read, created_at) VALUES (?, ?, ?, ?, 0, CURRENT_TIMESTAMP)',
            [null, loopType === 'purchase' ? 'Nova Compra' : 'Novo Usuário', notificationMessage, loopType]
        );
        
        console.log(`[NOTIFICATIONS] Notificação ${loopType} criada: ${notificationMessage}`);
    } catch (error) {
        console.error(`[NOTIFICATIONS] Erro ao processar loop ${loopType}:`, error);
    }
}

// --- FUNÇÕES AUXILIARES PARA ANÁLISE DE CANAIS VIRAIS ---

// Buscar informações do canal
async function getChannelInfo(channelIdOrHandle, apiKey) {
    try {
        // Limpar handle (remover @ se presente)
        let identifier = channelIdOrHandle.trim();
        if (identifier.startsWith('@')) {
            identifier = identifier.substring(1);
        }
        
        // Tentar buscar por channelId primeiro (se parece com ID)
        if (identifier.length === 24 && identifier.startsWith('UC')) {
            let url = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics,contentDetails&id=${identifier}&key=${apiKey}`;
            let response = await fetch(url);
            let data = await response.json();
            
            if (response.ok && data.items && data.items.length > 0) {
                const channel = data.items[0];
                const publishedAt = new Date(channel.snippet.publishedAt);
                const daysSinceCreation = Math.round((new Date() - publishedAt) / (1000 * 60 * 60 * 24));
                const monthsSinceCreation = Math.round(daysSinceCreation / 30);
                const yearsSinceCreation = (daysSinceCreation / 365).toFixed(1);
                
                return {
                    channelId: channel.id,
                    channelName: channel.snippet.title,
                    channelHandle: channel.snippet.customUrl || identifier,
                    subscriberCount: parseInt(channel.statistics.subscriberCount || 0),
                    videoCount: parseInt(channel.statistics.videoCount || 0),
                    viewCount: parseInt(channel.statistics.viewCount || 0),
                    description: channel.snippet.description || '',
                    thumbnail: channel.snippet.thumbnails.high?.url || channel.snippet.thumbnails.default?.url || '',
                    publishedAt: channel.snippet.publishedAt,
                    daysSinceCreation: daysSinceCreation,
                    monthsSinceCreation: monthsSinceCreation,
                    yearsSinceCreation: parseFloat(yearsSinceCreation)
                };
            }
        }
        
        // Tentar buscar por handle usando search
        const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(identifier)}&type=channel&maxResults=1&key=${apiKey}`;
        const searchResponse = await fetch(searchUrl);
        const searchData = await searchResponse.json();
        
        if (searchResponse.ok && searchData.items && searchData.items.length > 0) {
            const channelId = searchData.items[0].id.channelId;
            
            // Buscar detalhes completos
            const detailsUrl = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics,contentDetails&id=${channelId}&key=${apiKey}`;
            const detailsResponse = await fetch(detailsUrl);
            const detailsData = await detailsResponse.json();
            
            if (detailsResponse.ok && detailsData.items && detailsData.items.length > 0) {
                const channel = detailsData.items[0];
                const publishedAt = new Date(channel.snippet.publishedAt);
                const daysSinceCreation = Math.round((new Date() - publishedAt) / (1000 * 60 * 60 * 24));
                const monthsSinceCreation = Math.round(daysSinceCreation / 30);
                const yearsSinceCreation = (daysSinceCreation / 365).toFixed(1);
                
                return {
                    channelId: channel.id,
                    channelName: channel.snippet.title,
                    channelHandle: channel.snippet.customUrl || identifier,
                    subscriberCount: parseInt(channel.statistics.subscriberCount || 0),
                    videoCount: parseInt(channel.statistics.videoCount || 0),
                    viewCount: parseInt(channel.statistics.viewCount || 0),
                    description: channel.snippet.description || '',
                    thumbnail: channel.snippet.thumbnails.high?.url || channel.snippet.thumbnails.default?.url || '',
                    publishedAt: channel.snippet.publishedAt,
                    daysSinceCreation: daysSinceCreation,
                    monthsSinceCreation: monthsSinceCreation,
                    yearsSinceCreation: parseFloat(yearsSinceCreation)
                };
            }
        }
        
        throw new Error('Canal não encontrado. Verifique a URL ou handle do canal.');
    } catch (err) {
        console.error('[getChannelInfo] Erro:', err);
        throw new Error(`Erro ao buscar informações do canal: ${err.message}`);
    }
}

// Buscar vídeos mais vistos do canal
async function getChannelTopVideos(channelId, apiKey, maxResults = 20) {
    try {
        // Buscar vídeos ordenados por viewCount
        const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${channelId}&order=viewCount&type=video&maxResults=${maxResults}&key=${apiKey}`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (!response.ok) {
            throw new Error(data.error?.message || 'Erro ao buscar vídeos');
        }
        
        if (!data.items || data.items.length === 0) {
            return [];
        }
        
        const videoIds = data.items.map(item => item.id.videoId).join(',');
        
        // Buscar estatísticas detalhadas
        const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics,contentDetails&id=${videoIds}&key=${apiKey}`;
        const detailsResponse = await fetch(detailsUrl);
        const detailsData = await detailsResponse.json();
        
        if (!detailsResponse.ok || !detailsData.items) {
            throw new Error('Erro ao buscar detalhes dos vídeos');
        }
        
        return detailsData.items.map(item => {
            const publishedAt = new Date(item.snippet.publishedAt);
            const daysAgo = Math.round((new Date() - publishedAt) / (1000 * 60 * 60 * 24));
            
            return {
                videoId: item.id,
                title: item.snippet.title,
                description: item.snippet.description || '',
                thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default?.url || '',
                publishedAt: item.snippet.publishedAt,
                viewCount: parseInt(item.statistics.viewCount || 0),
                likeCount: parseInt(item.statistics.likeCount || 0),
                commentCount: parseInt(item.statistics.commentCount || 0),
                duration: item.contentDetails.duration,
                tags: item.snippet.tags || [],
                categoryId: item.snippet.categoryId,
                daysAgo: daysAgo,
                viralScore: calculateViralScore(
                    parseInt(item.statistics.viewCount || 0),
                    parseInt(item.statistics.likeCount || 0),
                    parseInt(item.statistics.commentCount || 0),
                    daysAgo
                )
            };
        }).sort((a, b) => b.viralScore - a.viralScore);
    } catch (err) {
        console.error('[getChannelTopVideos] Erro:', err);
        throw new Error(`Erro ao buscar vídeos mais vistos: ${err.message}`);
    }
}

// Calcular score viral
function calculateViralScore(views, likes, comments, daysAgo) {
    if (daysAgo === 0) daysAgo = 1;
    const viewsPerDay = views / daysAgo;
    const engagementRate = ((likes + comments) / views) * 100;
    return (viewsPerDay * 0.6) + (engagementRate * 1000 * 0.4);
}

// Buscar comentários de um vídeo
async function getVideoComments(videoId, apiKey, maxResults = 100) {
    try {
        const url = `https://www.googleapis.com/youtube/v3/commentThreads?part=snippet&videoId=${videoId}&maxResults=${maxResults}&order=relevance&key=${apiKey}`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (!response.ok) {
            throw new Error(data.error?.message || 'Erro ao buscar comentários');
        }
        
        if (!data.items || data.items.length === 0) {
            return [];
        }
        
        return data.items.map(item => {
            const comment = item.snippet.topLevelComment.snippet;
            return {
                commentId: item.snippet.topLevelComment.id,
                authorName: comment.authorDisplayName,
                authorChannelId: comment.authorChannelId?.value || null,
                text: comment.textDisplay,
                likeCount: parseInt(comment.likeCount || 0),
                publishedAt: comment.publishedAt,
                updatedAt: comment.updatedAt
            };
        });
    } catch (err) {
        console.error('[getVideoComments] Erro:', err);
        // Se não houver comentários ou erro, retornar array vazio
        return [];
    }
}

// Analisar insights virais com IA
async function analyzeViralInsights(channelData, videos, comments, apiKey, service, modelToUse) {
    try {
        const topVideos = videos.slice(0, 10);
        const topComments = comments.slice(0, 50);
        
        // Identificar o vídeo mais viral para análise detalhada
        const mostViralVideo = topVideos.reduce((max, v) => {
            const maxViews = max.viewCount || 0;
            const vViews = v.viewCount || 0;
            return vViews > maxViews ? v : max;
        }, topVideos[0]);
        
        const mostViralDaysAgo = mostViralVideo.daysAgo || (mostViralVideo.publishedAt ? Math.round((new Date() - new Date(mostViralVideo.publishedAt)) / (1000 * 60 * 60 * 24)) : 0);
        
        const analysisPrompt = `Você é um ESPECIALISTA EM ANÁLISE DE CANAIS VIRAIS DO YOUTUBE.

GPT, preciso da sua ajuda para analisar um canal de sucesso no YouTube e usar essa análise como base para a criação do meu próprio canal dentro do mesmo nicho.

DADOS DO CANAL:
- Nome: ${channelData.channelName}
- Inscritos: ${channelData.subscriberCount.toLocaleString()}
- Total de vídeos: ${channelData.videoCount}
- Total de visualizações: ${channelData.viewCount.toLocaleString()}

LISTA COMPLETA DOS VÍDEOS PUBLICADOS (TOP 10 MAIS VISTOS):
${topVideos.map((v, i) => {
    const daysAgo = v.daysAgo || (v.publishedAt ? Math.round((new Date() - new Date(v.publishedAt)) / (1000 * 60 * 60 * 24)) : 0);
    const viralScore = v.viralScore || 0;
    return `
${i + 1}. "${v.title}"
   - Visualizações: ${(v.viewCount || 0).toLocaleString()}
   - Likes: ${(v.likeCount || 0).toLocaleString()}
   - Comentários: ${(v.commentCount || 0).toLocaleString()}
   - Publicado há: ${daysAgo} dias
   - Score Viral: ${viralScore.toFixed(2)}
   - Thumbnail URL: ${v.thumbnail || 'N/A'}
`;
}).join('\n')}

VÍDEO MAIS VIRAL DO CANAL:
"${mostViralVideo.title}"
- Visualizações: ${(mostViralVideo.viewCount || 0).toLocaleString()}
- Pegou ${(mostViralVideo.viewCount || 0).toLocaleString()} views em ${mostViralDaysAgo} dias
- Likes: ${(mostViralVideo.likeCount || 0).toLocaleString()}
- Comentários: ${(mostViralVideo.commentCount || 0).toLocaleString()}
- Thumbnail: ${mostViralVideo.thumbnail || 'N/A'}

COMENTÁRIOS MAIS RELEVANTES (especialmente dos vídeos que performaram melhor):
${topComments.map((c, i) => `
${i + 1}. "${c.text.substring(0, 200)}" - ${c.authorName} (${c.likeCount} likes)
`).join('\n')}

ANÁLISE PROFUNDA REQUERIDA:

1. IDENTIFICAÇÃO DO NICHO E SUBNICHO:
   - Qual é o nicho exato desse canal?
   - Qual é o subnicho (se houver)?
   - Há subnichos pouco explorados dentro deste nicho que tenham alto volume de buscas e baixa competição?

2. DIFERENCIAIS DE SUCESSO:
   - Quais são os principais diferenciais que tornam esse canal bem-sucedido?
   - O que faz este canal se destacar da concorrência?

3. PÚBLICO-ALVO:
   - Perfil demográfico (idade, gênero, localização)
   - Interesses específicos
   - Comportamento e padrões de consumo de conteúdo

4. PADRÕES NOS TÍTULOS (ANÁLISE DETALHADA):
   - Estrutura comum dos títulos virais
   - Palavras-chave recorrentes que geram mais views
   - Técnicas de hook mais eficazes
   - Comprimento médio ideal
   - Para o vídeo mais viral com título "${mostViralVideo.title}", identifique:
     * Por que este título específico viralizou?
     * Quais elementos do título são responsáveis pelo sucesso?
     * Variações deste título que poderiam funcionar igualmente bem

5. ANÁLISE DE THUMBNAILS:
   - Para o vídeo mais viral com thumbnail "${mostViralVideo.thumbnail || 'N/A'}" e título "${mostViralVideo.title}":
     * Quais elementos visuais da thumbnail contribuíram para o viral?
     * Como a thumbnail complementa o título?
     * Padrões visuais que se repetem nas thumbnails dos vídeos virais

6. ESTRATÉGIAS DE ENGAGEMENT:
   - O que gera mais comentários? (identifique nos comentários fornecidos)
   - O que gera mais likes?
   - Timing de publicação mais eficaz
   - Há algo nos comentários que revele desejos ou insatisfações da audiência que possam ser usados como oportunidade?

7. INSIGHTS VIRAIS:
   - Por que esses vídeos viralizaram? (análise profunda)
   - Elementos comuns nos vídeos virais
   - Diferenças entre vídeos virais e não virais
   - Padrões ou formatos que se repetem nos vídeos de maior sucesso

8. OPORTUNIDADES ESTRATÉGICAS:
   - Oportunidades para criar um canal similar com diferenciais competitivos
   - Subnichos dentro deste nicho que estão pouco explorados mas com alta demanda
   - Gaps de conteúdo identificados nos comentários

9. RECOMENDAÇÕES PRÁTICAS:
   - Como estruturar o conteúdo de um novo canal
   - Linha editorial recomendada
   - Sugestões de temas iniciais
   - Estratégias de conteúdo mais eficazes (tipo de vídeo, frequência, estilo de narrativa)

RESPONDA EM FORMATO JSON:
{
  "niche_analysis": {
    "exact_niche": "descrição do nicho exato",
    "subniche": "subnicho identificado",
    "unexplored_subniches": ["subnicho 1 com alta demanda", "subnicho 2 com alta demanda"],
    "competition_level": "baixa/média/alta"
  },
  "differentiators": {
    "main_differentiators": ["diferencial 1", "diferencial 2", ...],
    "success_factors": ["fator 1", "fator 2", ...]
  },
  "target_audience": {
    "demographic": "perfil demográfico",
    "interests": ["interesse 1", "interesse 2", ...],
    "behavior": "comportamento identificado"
  },
  "title_patterns": {
    "structure": "descrição detalhada da estrutura comum",
    "keywords": ["palavra-chave 1", "palavra-chave 2", ...],
    "hook_techniques": ["técnica 1", "técnica 2", ...],
    "avg_length": número,
    "viral_title_analysis": {
      "title": "${mostViralVideo.title}",
      "why_viral": "análise detalhada de por que este título viralizou",
      "key_elements": ["elemento 1", "elemento 2", ...],
      "variations": ["variação 1", "variação 2", "variação 3", ...]
    }
  },
  "thumbnail_analysis": {
    "viral_thumbnail_url": "${mostViralVideo.thumbnail || 'N/A'}",
    "viral_title": "${mostViralVideo.title}",
    "visual_elements": ["elemento visual 1", "elemento visual 2", ...],
    "thumbnail_title_synergy": "como thumbnail e título trabalham juntos",
    "recurring_patterns": ["padrão 1", "padrão 2", ...]
  },
  "engagement_strategies": {
    "comment_triggers": ["elemento 1", "elemento 2", ...],
    "like_triggers": ["elemento 1", "elemento 2", ...],
    "best_posting_times": "análise de timing",
    "audience_desires": ["desejo 1 identificado nos comentários", "desejo 2", ...],
    "audience_pain_points": ["ponto de dor 1", "ponto de dor 2", ...]
  },
  "viral_insights": {
    "why_viral": "análise detalhada e profunda",
    "common_elements": ["elemento 1", "elemento 2", ...],
    "differences": "diferenças entre vídeos virais e não virais",
    "recurring_formats": ["formato 1", "formato 2", ...]
  },
  "opportunities": {
    "competitive_differentiators": ["oportunidade 1", "oportunidade 2", ...],
    "unexplored_subniches": ["subnicho 1", "subnicho 2", ...],
    "content_gaps": ["gap 1", "gap 2", ...]
  },
  "recommendations": {
    "content_structure": "como estruturar conteúdo",
    "editorial_line": "linha editorial recomendada",
    "initial_themes": ["tema 1", "tema 2", ...],
    "replication_strategy": "estratégia detalhada de replicação",
    "suggested_titles": ["título 1 baseado nos padrões", "título 2", ...],
    "content_strategies": ["estratégia 1", "estratégia 2", ...],
    "video_types": "tipos de vídeo mais eficazes",
    "publishing_frequency": "frequência recomendada",
    "narrative_style": "estilo de narrativa"
  }
}`;

        let analysisResponse;
        if (service === 'claude') {
            analysisResponse = await callClaudeAPI(analysisPrompt, apiKey, modelToUse);
        } else if (service === 'openai') {
            analysisResponse = await callOpenAIAPI(analysisPrompt, apiKey, modelToUse);
        } else {
            analysisResponse = await callGeminiAPI(analysisPrompt, apiKey, modelToUse);
        }
        
        const analysisText = typeof analysisResponse === 'string' ? analysisResponse : JSON.stringify(analysisResponse);
        console.log('[analyzeViralInsights] Resposta da IA (primeiros 1000 chars):', analysisText.substring(0, 1000));
        
        let parsed;
        try {
            parsed = parseAIResponse(analysisText, service);
            console.log('[analyzeViralInsights] Parseado com sucesso. Tipo:', typeof parsed);
            console.log('[analyzeViralInsights] Estrutura parseada:', {
                hasTitlePatterns: !!parsed?.title_patterns,
                hasEngagement: !!parsed?.engagement_strategies,
                hasViralInsights: !!parsed?.viral_insights,
                hasRecommendations: !!parsed?.recommendations
            });
        } catch (parseErr) {
            console.error('[analyzeViralInsights] Erro ao parsear resposta da IA:', parseErr);
            console.error('[analyzeViralInsights] Texto que causou erro:', analysisText.substring(0, 500));
            parsed = {};
        }
        
        // Garantir que sempre retorna estrutura válida
        if (!parsed || typeof parsed !== 'object') {
            console.warn('[analyzeViralInsights] Parse retornou valor inválido, usando objeto vazio');
            parsed = {};
        }
        
        // Garantir que todas as seções existem
        if (!parsed.niche_analysis || typeof parsed.niche_analysis !== 'object') {
            parsed.niche_analysis = {
                exact_niche: 'Não identificado',
                subniche: 'Não identificado',
                unexplored_subniches: [],
                competition_level: 'Não identificado'
            };
        }
        
        if (!parsed.differentiators || typeof parsed.differentiators !== 'object') {
            parsed.differentiators = {
                main_differentiators: [],
                success_factors: []
            };
        }
        
        if (!parsed.target_audience || typeof parsed.target_audience !== 'object') {
            parsed.target_audience = {
                demographic: 'Não identificado',
                interests: [],
                behavior: 'Não identificado'
            };
        }
        
        if (!parsed.title_patterns || typeof parsed.title_patterns !== 'object') {
            parsed.title_patterns = {
                structure: 'Estrutura não identificada',
                keywords: [],
                hook_techniques: [],
                avg_length: 0,
                viral_title_analysis: {
                    title: '',
                    why_viral: 'Análise não disponível',
                    key_elements: [],
                    variations: []
                }
            };
        }
        
        if (!parsed.thumbnail_analysis || typeof parsed.thumbnail_analysis !== 'object') {
            parsed.thumbnail_analysis = {
                viral_thumbnail_url: '',
                viral_title: '',
                visual_elements: [],
                thumbnail_title_synergy: 'Análise não disponível',
                recurring_patterns: []
            };
        }
        
        if (!parsed.engagement_strategies || typeof parsed.engagement_strategies !== 'object') {
            parsed.engagement_strategies = {
                comment_triggers: [],
                like_triggers: [],
                best_posting_times: 'Não identificado',
                audience_desires: [],
                audience_pain_points: []
            };
        }
        
        if (!parsed.viral_insights || typeof parsed.viral_insights !== 'object') {
            parsed.viral_insights = {
                why_viral: 'Análise não disponível',
                common_elements: [],
                differences: 'Não identificado',
                recurring_formats: []
            };
        }
        
        if (!parsed.opportunities || typeof parsed.opportunities !== 'object') {
            parsed.opportunities = {
                competitive_differentiators: [],
                unexplored_subniches: [],
                content_gaps: []
            };
        }
        
        if (!parsed.recommendations || typeof parsed.recommendations !== 'object') {
            parsed.recommendations = {
                content_structure: 'Estrutura não identificada',
                editorial_line: 'Linha editorial não identificada',
                initial_themes: [],
                replication_strategy: 'Estratégia não identificada',
                suggested_titles: [],
                content_strategies: [],
                video_types: 'Não identificado',
                publishing_frequency: 'Não identificado',
                narrative_style: 'Não identificado'
            };
        }
        
        return parsed;
    } catch (err) {
        console.error('[analyzeViralInsights] Erro:', err);
        // Retornar estrutura padrão em vez de lançar erro
        return {
            niche_analysis: {
                exact_niche: 'Não identificado',
                subniche: 'Não identificado',
                unexplored_subniches: [],
                competition_level: 'Não identificado'
            },
            differentiators: {
                main_differentiators: [],
                success_factors: []
            },
            target_audience: {
                demographic: 'Não identificado',
                interests: [],
                behavior: 'Não identificado'
            },
            title_patterns: {
                structure: 'Estrutura não identificada',
                keywords: [],
                hook_techniques: [],
                avg_length: 0,
                viral_title_analysis: {
                    title: '',
                    why_viral: 'Análise não disponível',
                    key_elements: [],
                    variations: []
                }
            },
            thumbnail_analysis: {
                viral_thumbnail_url: '',
                viral_title: '',
                visual_elements: [],
                thumbnail_title_synergy: 'Análise não disponível',
                recurring_patterns: []
            },
            engagement_strategies: {
                comment_triggers: [],
                like_triggers: [],
                best_posting_times: 'Não identificado',
                audience_desires: [],
                audience_pain_points: []
            },
            viral_insights: {
                why_viral: 'Análise não disponível',
                common_elements: [],
                differences: 'Não identificado',
                recurring_formats: []
            },
            opportunities: {
                competitive_differentiators: [],
                unexplored_subniches: [],
                content_gaps: []
            },
            recommendations: {
                content_structure: 'Estrutura não identificada',
                editorial_line: 'Linha editorial não identificada',
                initial_themes: [],
                replication_strategy: 'Estratégia não identificada',
                suggested_titles: [],
                content_strategies: [],
                video_types: 'Não identificado',
                publishing_frequency: 'Não identificado',
                narrative_style: 'Não identificado'
            }
        };
    }
}

// Analisar insights para novo canal baseado em análises cruzadas
async function analyzeNewChannelInsights(currentInsights, otherChannelsInsights, channelInfo, apiKey, service, modelToUse) {
    try {
        const prompt = `Você é um ESPECIALISTA EM CRIAÇÃO DE CANAIS VIRAIS NO YOUTUBE.

Com base na análise de múltiplos canais virais do mesmo nicho, forneça insights específicos para CRIAR UM NOVO CANAL que replique o sucesso.

ANÁLISE ATUAL DO CANAL: ${channelInfo.channelName}
- Idade do canal: ${channelInfo.yearsSinceCreation || 0} anos
- Inscritos: ${channelInfo.subscriberCount.toLocaleString()}
- Total de vídeos: ${channelInfo.videoCount}
- Total de visualizações: ${channelInfo.viewCount.toLocaleString()}

INSIGHTS DO CANAL ATUAL:
${JSON.stringify(currentInsights, null, 2)}

INSIGHTS DE OUTROS CANAIS VIRAIS DO MESMO NICHO:
${otherChannelsInsights.map((oc, i) => `
Canal ${i + 1}: ${oc.channelName}
${JSON.stringify(oc.insights, null, 2)}
`).join('\n---\n')}

ANALISE E FORNEÇA INSIGHTS ESPECÍFICOS PARA CRIAR UM NOVO CANAL:

1. PADRÕES CRUZADOS:
   - Quais elementos são comuns em TODOS os canais virais analisados?
   - Quais diferenças estratégicas existem entre os canais?
   - O que funciona melhor para este nicho?

2. ESTRATÉGIA PARA NOVO CANAL:
   - Como posicionar o novo canal para competir?
   - Quais elementos replicar e quais evitar?
   - Timing ideal para lançamento

3. TÍTULOS OTIMIZADOS:
   - 10 títulos sugeridos baseados nos padrões virais identificados
   - Estrutura ideal para este nicho
   - Palavras-chave essenciais

4. ROADMAP DE CONTEÚDO:
   - Primeiros 10 vídeos sugeridos
   - Ordem de publicação recomendada
   - Estratégia de crescimento inicial

RESPONDA EM FORMATO JSON:
{
  "cross_patterns": {
    "common_elements": ["elemento1", "elemento2", ...],
    "key_differences": "análise das diferenças",
    "best_practices": ["prática1", "prática2", ...]
  },
  "new_channel_strategy": {
    "positioning": "como posicionar",
    "replicate_elements": ["elemento1", "elemento2", ...],
    "avoid_elements": ["elemento1", "elemento2", ...],
    "launch_timing": "quando lançar"
  },
  "optimized_titles": [
    "título 1",
    "título 2",
    ...
  ],
  "content_roadmap": {
    "first_10_videos": [
      {"order": 1, "title": "título", "reason": "por que este primeiro"},
      ...
    ],
    "growth_strategy": "estratégia de crescimento"
  }
}`;

        let response;
        if (service === 'claude') {
            response = await callClaudeAPI(prompt, apiKey, modelToUse);
        } else if (service === 'openai') {
            response = await callOpenAIAPI(prompt, apiKey, modelToUse);
        } else {
            response = await callGeminiAPI(prompt, apiKey, modelToUse);
        }
        
        const responseText = typeof response === 'string' ? response : JSON.stringify(response);
        const parsed = parseAIResponse(responseText, service);
        
        return parsed || {};
    } catch (err) {
        console.error('[analyzeNewChannelInsights] Erro:', err);
        return null;
    }
}

// Função para restaurar loops ativos ao iniciar o servidor
async function restoreActiveLoops() {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS active_loops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    loop_type TEXT NOT NULL UNIQUE,
                    is_active BOOLEAN DEFAULT 0,
                    interval_seconds INTEGER DEFAULT 5,
                    started_at DATETIME,
                    stopped_at DATETIME,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const activeLoops = await db.all('SELECT * FROM active_loops WHERE is_active = 1');
        
        if (activeLoops.length === 0) {
            console.log('[NOTIFICATIONS] Nenhum loop ativo para restaurar');
            return;
        }
        
        console.log(`[NOTIFICATIONS] Restaurando ${activeLoops.length} loop(s) ativo(s)...`);
        
        // Iniciar loops ativos
        for (const loop of activeLoops) {
            if (loop.is_active === 1) {
                console.log(`[NOTIFICATIONS] Iniciando loop ${loop.loop_type} (intervalo: ${loop.interval_seconds}s)`);
                startNotificationLoop(loop.loop_type, loop.interval_seconds);
            }
        }
        
        console.log('[NOTIFICATIONS] Loops ativos restaurados e em execução.');
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao restaurar loops:', error);
    }
}

// --- ENDPOINTS PARA ANÁLISE DE CANAIS VIRAIS ---

// Detectar nicho automaticamente pela URL do canal
app.post('/api/viral-analysis/detect-niche', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { channelUrl, channelId, channelHandle } = req.body;
        
        if (!channelUrl && !channelId && !channelHandle) {
            return res.status(400).json({ msg: 'URL, ID ou Handle do canal é obrigatório.' });
        }
        
        // Buscar API key do YouTube
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (!youtubeKeyData || !youtubeKeyData.api_key) {
            return res.status(400).json({ msg: 'Chave de API do YouTube não configurada.' });
        }
        const youtubeApiKey = decrypt(youtubeKeyData.api_key);
        
        // Extrair channelId da URL se necessário
        let finalChannelId = channelId;
        if (channelUrl && !channelId) {
            const urlMatch = channelUrl.match(/(?:youtube\.com\/(?:c\/|channel\/|user\/|@)|youtu\.be\/)([^\/\?]+)/);
            if (urlMatch) {
                finalChannelId = urlMatch[1];
            }
        }
        if (!finalChannelId && channelHandle) {
            finalChannelId = channelHandle;
        }
        
        // Buscar informações do canal
        const channelInfo = await getChannelInfo(finalChannelId, youtubeApiKey);
        
        // Buscar API key para IA
        let apiKey = null;
        let service = null;
        let modelToUse = null;
        
        const services = ['claude', 'openai', 'gemini'];
        for (const svc of services) {
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
            if (keyData && keyData.api_key) {
                try {
                    apiKey = decrypt(keyData.api_key);
                    service = svc;
                    if (svc === 'claude') modelToUse = 'claude-3-7-sonnet-20250219';
                    else if (svc === 'openai') modelToUse = 'gpt-4o';
                    else modelToUse = 'gemini-2.5-pro';
                    break;
                } catch (e) {
                    continue;
                }
            }
        }
        
        if (!apiKey) {
            return res.status(400).json({ msg: 'Nenhuma API key de IA configurada para detectar o nicho.' });
        }
        
        // Usar IA para detectar o nicho
        const nichePrompt = `Analise as seguintes informações de um canal do YouTube e identifique o NICHO PRINCIPAL do canal.

INFORMAÇÕES DO CANAL:
- Nome: ${channelInfo.channelName}
- Descrição: ${channelInfo.description.substring(0, 500)}
- Total de vídeos: ${channelInfo.videoCount}
- Total de visualizações: ${channelInfo.viewCount.toLocaleString()}
- Inscritos: ${channelInfo.subscriberCount.toLocaleString()}

Com base nessas informações, identifique o nicho principal do canal. O nicho deve ser uma palavra ou frase curta (máximo 2 palavras) que descreva o tema principal do conteúdo.

Exemplos de nichos válidos:
- História
- Tecnologia
- Educação
- Entretenimento
- Finanças
- Gaming
- Culinária
- Fitness
- Viagens
- Ciência
- Negócios
- Marketing

Responda APENAS com o nicho identificado, sem explicações adicionais. Use letras maiúsculas para a primeira letra de cada palavra.`;

        let nicheResponse;
        if (service === 'claude') {
            nicheResponse = await callClaudeAPI(nichePrompt, apiKey, modelToUse);
        } else if (service === 'openai') {
            nicheResponse = await callOpenAIAPI(nichePrompt, apiKey, modelToUse);
        } else {
            nicheResponse = await callGeminiAPI(nichePrompt, apiKey, modelToUse);
        }
        
        const nicheText = typeof nicheResponse === 'string' ? nicheResponse : JSON.stringify(nicheResponse);
        const parsedNiche = parseAIResponse(nicheText, service);
        
        // Extrair nicho da resposta
        let detectedNiche = null;
        if (typeof parsedNiche === 'string') {
            detectedNiche = parsedNiche.trim();
        } else if (parsedNiche && parsedNiche.niche) {
            detectedNiche = parsedNiche.niche.trim();
        } else if (parsedNiche && typeof parsedNiche === 'object') {
            // Tentar encontrar o nicho no objeto
            detectedNiche = parsedNiche.niche || parsedNiche.title || Object.values(parsedNiche)[0];
            if (typeof detectedNiche === 'string') {
                detectedNiche = detectedNiche.trim();
            }
        }
        
        // Limpar e formatar o nicho
        if (detectedNiche) {
            // Remover aspas, pontos, etc.
            detectedNiche = detectedNiche.replace(/^["']|["']$/g, '').replace(/\.$/, '').trim();
            // Capitalizar primeira letra de cada palavra
            detectedNiche = detectedNiche.split(' ').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            ).join(' ');
        }
        
        res.status(200).json({ 
            niche: detectedNiche || null,
            channel: {
                name: channelInfo.channelName,
                description: channelInfo.description
            }
        });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/detect-niche]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao detectar nicho do canal.' });
    }
});

// Adicionar canal para análise
app.post('/api/viral-analysis/channels', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { channelUrl, channelId, channelHandle } = req.body;
        
        if (!channelUrl && !channelId && !channelHandle) {
            return res.status(400).json({ msg: 'URL, ID ou Handle do canal é obrigatório.' });
        }
        
        // Buscar API key do YouTube
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (!youtubeKeyData || !youtubeKeyData.api_key) {
            return res.status(400).json({ msg: 'Chave de API do YouTube não configurada. Configure nas Configurações.' });
        }
        
        const apiKey = decrypt(youtubeKeyData.api_key);
        
        // Extrair channelId da URL se necessário
        let finalChannelId = channelId;
        if (channelUrl && !channelId) {
            const urlMatch = channelUrl.match(/(?:youtube\.com\/(?:c\/|channel\/|user\/|@)|youtu\.be\/)([^\/\?]+)/);
            if (urlMatch) {
                finalChannelId = urlMatch[1];
            }
        }
        if (!finalChannelId && channelHandle) {
            finalChannelId = channelHandle;
        }
        
        // Buscar informações do canal
        const channelInfo = await getChannelInfo(finalChannelId, apiKey);
        
        // Verificar se já existe análise
        const existing = await db.get('SELECT id FROM channel_viral_analysis WHERE user_id = ? AND channel_id = ?', [userId, channelInfo.channelId]);
        
        if (existing) {
            return res.status(200).json({ 
                msg: 'Canal já está sendo analisado.',
                analysisId: existing.id,
                channel: channelInfo
            });
        }
        
        // Obter folder_id se fornecido (niche e subniche serão detectados durante a análise)
        const { folder_id } = req.body;
        
        // Criar nova análise (niche e subniche serão detectados durante a análise)
        const result = await db.run(
            `INSERT INTO channel_viral_analysis 
            (user_id, channel_id, channel_name, channel_url, channel_handle, subscriber_count, total_videos, total_views, channel_age_days, channel_age_years, niche, subniche, folder_id, analyzed_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
            [userId, channelInfo.channelId, channelInfo.channelName, channelUrl || `https://youtube.com/channel/${channelInfo.channelId}`, channelInfo.channelHandle, channelInfo.subscriberCount, channelInfo.videoCount, channelInfo.viewCount, channelInfo.daysSinceCreation || 0, channelInfo.yearsSinceCreation || 0, null, null, folder_id || null]
        );
        
        res.status(201).json({
            msg: 'Canal adicionado para análise com sucesso.',
            analysisId: result.lastID,
            channel: channelInfo
        });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/channels]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao adicionar canal para análise.' });
    }
});

// Listar canais em análise
app.get('/api/viral-analysis/channels', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        
        // Verificar quais colunas existem na tabela
        let tableInfo;
        try {
            tableInfo = await db.all("PRAGMA table_info(channel_viral_analysis)");
        } catch (e) {
            // Se a tabela não existir, retornar array vazio
            return res.status(200).json({ channels: [] });
        }
        
        const existingColumns = tableInfo.map(col => col.name);
        
        // Construir SELECT apenas com colunas que existem
        const baseColumns = ['id', 'channel_id', 'channel_name', 'channel_url', 'channel_handle', 'subscriber_count', 'total_videos', 'total_views', 'analyzed_at', 'last_updated'];
        const optionalColumns = ['channel_age_days', 'channel_age_years', 'avg_rpm_usd', 'avg_rpm_brl', 'niche', 'subniche', 'folder_id'];
        
        const selectColumns = [...baseColumns];
        optionalColumns.forEach(col => {
            if (existingColumns.includes(col)) {
                selectColumns.push(col);
            }
        });
        
        const channels = await db.all(
            `SELECT ${selectColumns.join(', ')}
            FROM channel_viral_analysis 
            WHERE user_id = ? 
            ORDER BY analyzed_at DESC 
            LIMIT 5`,
            [userId]
        );
        
        res.status(200).json({ channels });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/channels GET]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao listar canais.' });
    }
});

// Analisar canal completo
app.post('/api/viral-analysis/channels/:analysisId/analyze', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const analysisId = parseInt(req.params.analysisId);
        const { ai_model = 'auto' } = req.body;
        
        // Verificar se a análise pertence ao usuário
        const analysis = await db.get('SELECT * FROM channel_viral_analysis WHERE id = ? AND user_id = ?', [analysisId, userId]);
        if (!analysis) {
            return res.status(404).json({ msg: 'Análise não encontrada.' });
        }
        
        // Buscar API keys
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (!youtubeKeyData || !youtubeKeyData.api_key) {
            return res.status(400).json({ msg: 'Chave de API do YouTube não configurada.' });
        }
        const youtubeApiKey = decrypt(youtubeKeyData.api_key);
        
        // Buscar API key para IA
        let apiKey = null;
        let service = null;
        let modelToUse = null;
        
        if (ai_model && ai_model !== 'auto') {
            if (ai_model.includes('claude')) {
                service = 'claude';
                modelToUse = 'claude-3-7-sonnet-20250219';
            } else if (ai_model.includes('gpt')) {
                service = 'openai';
                modelToUse = 'gpt-4o';
            } else if (ai_model.includes('gemini')) {
                service = 'gemini';
                modelToUse = 'gemini-2.5-pro';
            }
        }
        
        if (!service) {
            const services = ['claude', 'openai', 'gemini'];
            for (const svc of services) {
                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
                if (keyData && keyData.api_key) {
                    try {
                        apiKey = decrypt(keyData.api_key);
                        service = svc;
                        if (svc === 'claude') modelToUse = 'claude-3-7-sonnet-20250219';
                        else if (svc === 'openai') modelToUse = 'gpt-4o';
                        else modelToUse = 'gemini-2.5-pro';
                        break;
                    } catch (e) {
                        continue;
                    }
                }
            }
        } else {
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (keyData && keyData.api_key) {
                apiKey = decrypt(keyData.api_key);
            }
        }
        
        if (!apiKey) {
            return res.status(400).json({ msg: 'Nenhuma API key de IA configurada.' });
        }
        
        // Buscar informações atualizadas do canal
        const channelInfo = await getChannelInfo(analysis.channel_id, youtubeApiKey);
        
        // Buscar top 20 vídeos mais vistos
        const videos = await getChannelTopVideos(analysis.channel_id, youtubeApiKey, 20);
        
        // Buscar comentários dos top 5 vídeos
        const allComments = [];
        for (let i = 0; i < Math.min(5, videos.length); i++) {
            const comments = await getVideoComments(videos[i].videoId, youtubeApiKey, 20);
            // Adicionar videoId aos comentários para associação
            comments.forEach(comment => {
                comment.videoId = videos[i].videoId;
            });
            allComments.push(...comments);
        }
        
        // Salvar vídeos no banco
        for (const video of videos) {
            await db.run(
                `INSERT OR REPLACE INTO channel_viral_videos 
                (analysis_id, video_id, video_url, title, description, thumbnail_url, view_count, like_count, comment_count, published_at, duration, tags_json, category_id, viral_score)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [analysisId, video.videoId, `https://youtube.com/watch?v=${video.videoId}`, video.title, video.description, video.thumbnail, video.viewCount, video.likeCount, video.commentCount, video.publishedAt, video.duration, JSON.stringify(video.tags), video.categoryId, video.viralScore]
            );
        }
        
        // Salvar comentários (associar aos vídeos salvos)
        const savedVideos = await db.all('SELECT id, video_id FROM channel_viral_videos WHERE analysis_id = ?', [analysisId]);
        const videoIdMap = {};
        savedVideos.forEach(v => { videoIdMap[v.video_id] = v.id; });
        
        // Agrupar comentários por vídeo
        const commentsByVideo = {};
        for (const comment of allComments) {
            if (!commentsByVideo[comment.videoId]) {
                commentsByVideo[comment.videoId] = [];
            }
            commentsByVideo[comment.videoId].push(comment);
        }
        
        // Salvar comentários associados aos vídeos corretos
        for (const [youtubeVideoId, comments] of Object.entries(commentsByVideo)) {
            const videoDbId = videoIdMap[youtubeVideoId];
            if (videoDbId) {
                for (const comment of comments) {
                    await db.run(
                        `INSERT OR IGNORE INTO channel_viral_comments 
                        (video_id, comment_id, author_name, author_channel_id, text, like_count, published_at)
                        VALUES (?, ?, ?, ?, ?, ?, ?)`,
                        [videoDbId, comment.commentId, comment.authorName, comment.authorChannelId, comment.text, comment.likeCount, comment.publishedAt]
                    );
                }
            }
        }
        
        // Detectar nicho e subnicho durante a análise (mais preciso)
        let detectedNiche = analysis.niche;
        let detectedSubniche = analysis.subniche || null;
        
        if (!detectedNiche || !detectedSubniche) {
            try {
                // Usar IA para detectar nicho e subnicho baseado nos dados completos do canal
                const nicheDetectionPrompt = `Analise as seguintes informações de um canal do YouTube e identifique o NICHO PRINCIPAL e o SUBNICHO do canal.

INFORMAÇÕES DO CANAL:
- Nome: ${channelInfo.channelName}
- Descrição: ${channelInfo.description ? channelInfo.description.substring(0, 500) : 'N/A'}
- Total de vídeos: ${channelInfo.videoCount}
- Total de visualizações: ${channelInfo.viewCount.toLocaleString()}
- Inscritos: ${channelInfo.subscriberCount.toLocaleString()}

TOP 5 VÍDEOS MAIS VISTOS:
${videos.slice(0, 5).map((v, i) => `
${i + 1}. "${v.title}"
   - Visualizações: ${(v.viewCount || 0).toLocaleString()}
`).join('')}

Com base nessas informações, identifique:
1. NICHO PRINCIPAL: Uma palavra ou frase curta (máximo 2 palavras) que descreva o tema principal do conteúdo.
2. SUBNICHO: Uma palavra ou frase que especifique melhor o foco dentro do nicho principal.

Exemplos:
- Nicho: "História", Subnicho: "História Antiga"
- Nicho: "Tecnologia", Subnicho: "Inteligência Artificial"
- Nicho: "Educação", Subnicho: "Matemática"

Responda APENAS com um JSON válido no formato:
{
  "niche": "Nicho Principal",
  "subniche": "Subnicho Específico"
}`;

                let nicheResponse;
                if (service === 'claude') {
                    nicheResponse = await callClaudeAPI(nicheDetectionPrompt, apiKey, modelToUse);
                } else if (service === 'openai') {
                    nicheResponse = await callOpenAIAPI(nicheDetectionPrompt, apiKey, modelToUse);
                } else {
                    nicheResponse = await callGeminiAPI(nicheDetectionPrompt, apiKey, modelToUse);
                }
                
                const nicheText = typeof nicheResponse === 'string' ? nicheResponse : JSON.stringify(nicheResponse);
                const parsedNiche = parseAIResponse(nicheText, service);
                
                if (parsedNiche && typeof parsedNiche === 'object') {
                    if (parsedNiche.niche && !detectedNiche) {
                        detectedNiche = parsedNiche.niche.trim();
                    }
                    if (parsedNiche.subniche) {
                        detectedSubniche = parsedNiche.subniche.trim();
                    }
                } else if (typeof parsedNiche === 'string' && !detectedNiche) {
                    detectedNiche = parsedNiche.trim();
                }
                
                // Limpar e formatar
                if (detectedNiche) {
                    detectedNiche = detectedNiche.replace(/^["']|["']$/g, '').replace(/\.$/, '').trim();
                    detectedNiche = detectedNiche.split(' ').map(word => 
                        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                    ).join(' ');
                }
                if (detectedSubniche) {
                    detectedSubniche = detectedSubniche.replace(/^["']|["']$/g, '').replace(/\.$/, '').trim();
                    detectedSubniche = detectedSubniche.split(' ').map(word => 
                        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                    ).join(' ');
                }
                
                console.log('[Viral Analysis] Nicho detectado:', detectedNiche, 'Subnicho:', detectedSubniche);
            } catch (err) {
                console.error('[Viral Analysis] Erro ao detectar nicho/subnicho:', err);
                // Continuar mesmo se falhar
            }
        }
        
        // Atualizar nicho e subnicho no banco
        if (detectedNiche || detectedSubniche) {
            await db.run(
                'UPDATE channel_viral_analysis SET niche = COALESCE(?, niche), subniche = COALESCE(?, subniche) WHERE id = ?',
                [detectedNiche, detectedSubniche, analysisId]
            );
        }
        
        // Analisar insights virais com IA
        let insights;
        try {
            insights = await analyzeViralInsights(channelInfo, videos, allComments, apiKey, service, modelToUse);
            console.log('[Viral Analysis] Insights gerados:', JSON.stringify(insights).substring(0, 200));
        } catch (err) {
            console.error('[Viral Analysis] Erro ao gerar insights:', err);
            // Usar estrutura vazia se falhar
            insights = {
                title_patterns: {
                    structure: 'Estrutura não identificada',
                    keywords: [],
                    hook_techniques: [],
                    avg_length: 0
                },
                engagement_strategies: {
                    comment_triggers: [],
                    like_triggers: [],
                    best_posting_times: 'Não identificado'
                },
                viral_insights: {
                    why_viral: 'Análise não disponível',
                    common_elements: [],
                    differences: 'Não identificado'
                },
                recommendations: {
                    replication_strategy: 'Estratégia não identificada',
                    suggested_titles: [],
                    content_strategies: []
                }
            };
        }
        
        // Calcular RPM médio baseado no nicho (usar nicho atualizado)
        const updatedNiche = detectedNiche || analysis.niche;
        const rpmData = getRPMByNiche(updatedNiche || null);
        
        // Calcular RPM médio do canal (estimativa baseada em views totais)
        const avgRPM = {
            usd: rpmData.usd,
            brl: rpmData.brl
        };
        
        // Calcular valor total ganho estimado do canal
        const totalRevenueUSD = (channelInfo.viewCount / 1000) * avgRPM.usd;
        const totalRevenueBRL = (channelInfo.viewCount / 1000) * avgRPM.brl;
        
        // Analisar insights cruzados para novo canal (usar nicho atualizado)
        const allAnalyses = await db.all(
            `SELECT * FROM channel_viral_analysis WHERE user_id = ? AND niche = ? AND id != ? ORDER BY analyzed_at DESC`,
            [userId, updatedNiche || '', analysisId]
        );
        
        let newChannelInsights = null;
        if (allAnalyses.length > 0) {
            // Buscar insights de outros canais do mesmo nicho
            const otherInsights = [];
            for (const otherAnalysis of allAnalyses.slice(0, 4)) {
                if (otherAnalysis.viral_insights_json) {
                    try {
                        const parsed = typeof otherAnalysis.viral_insights_json === 'string' 
                            ? JSON.parse(otherAnalysis.viral_insights_json) 
                            : otherAnalysis.viral_insights_json;
                        otherInsights.push({
                            channelName: otherAnalysis.channel_name,
                            insights: parsed
                        });
                    } catch (e) {
                        console.error('[Viral Analysis] Erro ao parsear insights de outro canal:', e);
                    }
                }
            }
            
            if (otherInsights.length > 0) {
                newChannelInsights = await analyzeNewChannelInsights(insights, otherInsights, channelInfo, apiKey, service, modelToUse);
            }
        }
        
        // Salvar insights
        const insightsData = {
            title_patterns: insights.title_patterns || {},
            engagement_strategies: insights.engagement_strategies || {},
            viral_insights: insights.viral_insights || {},
            recommendations: insights.recommendations || {}
        };
        
        console.log('[Viral Analysis] Salvando insights no banco:', {
            analysisId,
            hasTitlePatterns: !!insightsData.title_patterns && Object.keys(insightsData.title_patterns).length > 0,
            hasEngagement: !!insightsData.engagement_strategies && Object.keys(insightsData.engagement_strategies).length > 0,
            hasViralInsights: !!insightsData.viral_insights && Object.keys(insightsData.viral_insights).length > 0,
            hasRecommendations: !!insightsData.recommendations && Object.keys(insightsData.recommendations).length > 0,
            insightsDataPreview: JSON.stringify(insightsData).substring(0, 500)
        });
        
        await db.run(
            'UPDATE channel_viral_analysis SET analysis_data_json = ?, viral_insights_json = ?, new_channel_insights_json = ?, avg_rpm_usd = ?, avg_rpm_brl = ?, total_revenue_usd = ?, total_revenue_brl = ?, channel_age_days = ?, channel_age_years = ?, last_updated = CURRENT_TIMESTAMP WHERE id = ?',
            [JSON.stringify({ channelInfo, videos: videos.slice(0, 10) }), JSON.stringify(insightsData), newChannelInsights ? JSON.stringify(newChannelInsights) : null, avgRPM.usd, avgRPM.brl, totalRevenueUSD, totalRevenueBRL, channelInfo.daysSinceCreation || 0, channelInfo.yearsSinceCreation || 0, analysisId]
        );
        
        // Verificar se foi salvo corretamente
        const saved = await db.get('SELECT viral_insights_json FROM channel_viral_analysis WHERE id = ?', [analysisId]);
        console.log('[Viral Analysis] Verificação pós-salvamento:', {
            saved: !!saved,
            hasViralInsightsJson: !!saved?.viral_insights_json,
            length: saved?.viral_insights_json?.length || 0,
            preview: saved?.viral_insights_json?.substring(0, 200) || 'null'
        });
        
        // Salvar insights individuais
        if (insights.title_patterns) {
            await db.run(
                'INSERT INTO channel_viral_insights (analysis_id, insight_type, insight_title, insight_content, priority) VALUES (?, ?, ?, ?, ?)',
                [analysisId, 'title_patterns', 'Padrões nos Títulos', JSON.stringify(insights.title_patterns), 1]
            );
        }
        if (insights.engagement_strategies) {
            await db.run(
                'INSERT INTO channel_viral_insights (analysis_id, insight_type, insight_title, insight_content, priority) VALUES (?, ?, ?, ?, ?)',
                [analysisId, 'engagement', 'Estratégias de Engagement', JSON.stringify(insights.engagement_strategies), 2]
            );
        }
        if (insights.viral_insights) {
            await db.run(
                'INSERT INTO channel_viral_insights (analysis_id, insight_type, insight_title, insight_content, priority) VALUES (?, ?, ?, ?, ?)',
                [analysisId, 'viral', 'Insights Virais', JSON.stringify(insights.viral_insights), 3]
            );
        }
        if (insights.recommendations) {
            await db.run(
                'INSERT INTO channel_viral_insights (analysis_id, insight_type, insight_title, insight_content, priority) VALUES (?, ?, ?, ?, ?)',
                [analysisId, 'recommendations', 'Recomendações', JSON.stringify(insights.recommendations), 4]
            );
        }
        
        res.status(200).json({
            msg: 'Análise concluída com sucesso.',
            analysis: {
                channel: channelInfo,
                videosCount: videos.length,
                commentsCount: allComments.length,
                insights: insightsData
            }
        });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/channels/:id/analyze]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao analisar canal.' });
    }
});

// Obter análise completa
app.get('/api/viral-analysis/channels/:analysisId', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const analysisId = parseInt(req.params.analysisId);
        
        const analysis = await db.get('SELECT * FROM channel_viral_analysis WHERE id = ? AND user_id = ?', [analysisId, userId]);
        if (!analysis) {
            return res.status(404).json({ msg: 'Análise não encontrada.' });
        }
        
        const videos = await db.all('SELECT * FROM channel_viral_videos WHERE analysis_id = ? ORDER BY view_count DESC, viral_score DESC', [analysisId]);
        const insights = await db.all('SELECT * FROM channel_viral_insights WHERE analysis_id = ? ORDER BY priority', [analysisId]);
        
        // Buscar comentários para cada vídeo
        for (const video of videos) {
            const comments = await db.all('SELECT * FROM channel_viral_comments WHERE video_id = ? ORDER BY like_count DESC LIMIT 10', [video.id]);
            video.comments = comments;
        }
        
        // Parsear JSONs se existirem
        let analysisData = null;
        let viralInsights = null;
        
        try {
            if (analysis.analysis_data_json) {
                analysisData = typeof analysis.analysis_data_json === 'string' 
                    ? JSON.parse(analysis.analysis_data_json) 
                    : analysis.analysis_data_json;
            }
        } catch (e) {
            console.error('[Viral Analysis] Erro ao parsear analysis_data_json:', e);
        }
        
        try {
            if (analysis.viral_insights_json) {
                viralInsights = typeof analysis.viral_insights_json === 'string' 
                    ? JSON.parse(analysis.viral_insights_json) 
                    : analysis.viral_insights_json;
                console.log('[Viral Analysis GET] Insights parseados:', {
                    hasTitlePatterns: !!viralInsights?.title_patterns,
                    hasEngagement: !!viralInsights?.engagement_strategies,
                    hasViralInsights: !!viralInsights?.viral_insights,
                    hasRecommendations: !!viralInsights?.recommendations,
                    titlePatternsKeys: viralInsights?.title_patterns ? Object.keys(viralInsights.title_patterns) : [],
                    recommendationsKeys: viralInsights?.recommendations ? Object.keys(viralInsights.recommendations) : []
                });
            } else {
                console.warn('[Viral Analysis GET] viral_insights_json está vazio ou null');
            }
        } catch (e) {
            console.error('[Viral Analysis] Erro ao parsear viral_insights_json:', e);
            console.error('[Viral Analysis] Conteúdo raw:', analysis.viral_insights_json?.substring(0, 500));
        }
        
        // Parsear new_channel_insights se existir
        let newChannelInsights = null;
        try {
            if (analysis.new_channel_insights_json) {
                newChannelInsights = typeof analysis.new_channel_insights_json === 'string' 
                    ? JSON.parse(analysis.new_channel_insights_json) 
                    : analysis.new_channel_insights_json;
            }
        } catch (e) {
            console.error('[Viral Analysis] Erro ao parsear new_channel_insights_json:', e);
        }
        
        console.log('[Viral Analysis GET] Retornando análise:', {
            hasViralInsights: !!viralInsights,
            videosCount: videos.length,
            insightsCount: insights.length
        });
        
        res.status(200).json({
            analysis: {
                ...analysis,
                analysis_data: analysisData,
                viral_insights: viralInsights,
                new_channel_insights: newChannelInsights,
                total_revenue_usd: analysis.total_revenue_usd || null,
                total_revenue_brl: analysis.total_revenue_brl || null
            },
            videos,
            insights
        });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/channels/:id]:', err);
        res.status(500).json({ msg: 'Erro ao buscar análise.' });
    }
});

// Remover canal da análise
app.delete('/api/viral-analysis/channels/:analysisId', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const analysisId = parseInt(req.params.analysisId);
        
        const analysis = await db.get('SELECT id FROM channel_viral_analysis WHERE id = ? AND user_id = ?', [analysisId, userId]);
        if (!analysis) {
            return res.status(404).json({ msg: 'Análise não encontrada.' });
        }
        
        await db.run('DELETE FROM channel_viral_analysis WHERE id = ?', [analysisId]);
        
        res.status(200).json({ msg: 'Canal removido da análise com sucesso.' });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/channels/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao remover canal.' });
    }
});

// Cruzar análises de múltiplos canais e gerar conteúdo viral
app.post('/api/viral-analysis/cross-analyze', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { analysisIds } = req.body;
        
        if (!analysisIds || !Array.isArray(analysisIds) || analysisIds.length < 2) {
            return res.status(400).json({ msg: 'Selecione pelo menos 2 análises para cruzar.' });
        }
        
        // Buscar todas as análises selecionadas
        const placeholders = analysisIds.map(() => '?').join(',');
        const analyses = await db.all(
            `SELECT * FROM channel_viral_analysis WHERE id IN (${placeholders}) AND user_id = ?`,
            [...analysisIds, userId]
        );
        
        if (analyses.length < 2) {
            return res.status(400).json({ msg: 'Não foi possível encontrar as análises selecionadas.' });
        }
        
        // Buscar vídeos e insights de cada análise
        const allVideos = [];
        const allInsights = [];
        
        for (const analysis of analyses) {
            const videos = await db.all(
                'SELECT * FROM channel_viral_videos WHERE analysis_id = ? ORDER BY view_count DESC LIMIT 10',
                [analysis.id]
            );
            allVideos.push(...videos.map(v => ({ ...v, channelName: analysis.channel_name, niche: analysis.niche })));
            
            const insights = await db.all(
                'SELECT * FROM channel_viral_insights WHERE analysis_id = ?',
                [analysis.id]
            );
            allInsights.push(...insights.map(i => ({ ...i, channelName: analysis.channel_name })));
        }
        
        // Buscar chave de API do usuário
        const user = await db.get('SELECT openai_api_key FROM users WHERE id = ?', [userId]);
        if (!user || !user.openai_api_key) {
            return res.status(400).json({ msg: 'Configure sua chave de API OpenAI nas configurações.' });
        }
        
        // Preparar dados para análise cruzada
        const topVideosByChannel = {};
        analyses.forEach(analysis => {
            const channelVideos = allVideos.filter(v => v.channelName === analysis.channel_name);
            topVideosByChannel[analysis.channel_name] = channelVideos.slice(0, 5);
        });
        
        // Identificar nicho comum entre os canais
        const commonNiche = analyses[0].niche || 'Não identificado';
        const allNiches = analyses.map(a => a.niche).filter(n => n);
        const uniqueNiches = [...new Set(allNiches)];
        
        // Identificar vídeos mais virais de cada canal para análise de títulos e thumbnails
        const mostViralVideos = analyses.map(analysis => {
            const channelVideos = allVideos.filter(v => v.channelName === analysis.channel_name);
            return channelVideos.reduce((max, v) => (v.view_count || 0) > (max.view_count || 0) ? v : max, channelVideos[0]);
        }).filter(v => v);
        
        // Criar prompt para análise cruzada com foco em conteúdo inexplorado
        const crossAnalysisPrompt = `Você é um ESPECIALISTA EM ANÁLISE DE CANAIS VIRAIS DO YOUTUBE e IDENTIFICAÇÃO DE OPORTUNIDADES DE CONTEÚDO INEXPLORADO.

CONTEXTO INICIAL:
Quero criar um canal no YouTube dentro do nicho de "${commonNiche}". Analisei ${analyses.length} canais de sucesso neste nicho, mas percebi que já há bastante concorrência em alguns subnichos. Estou em busca de ideias de subnichos dentro de "${commonNiche}" que ainda estejam pouco exploradas no YouTube, com pouca ou nenhuma concorrência, mas que tenham ALTO VOLUME DE BUSCAS, INTERESSE CRESCENTE e BOM POTENCIAL DE MONETIZAÇÃO.

O objetivo é encontrar uma OPORTUNIDADE ÚNICA para criar conteúdo relevante, com FORTE DEMANDA e BAIXA COMPETIÇÃO, gerando CONTEÚDO VIRAL INÉDITO que ainda não foi explorado no YouTube.

DADOS DOS CANAIS ANALISADOS:

${analyses.map((analysis, idx) => {
    const channelVideos = topVideosByChannel[analysis.channel_name] || [];
    const mostViral = mostViralVideos.find(v => v.channelName === analysis.channel_name);
    return `
CANAL ${idx + 1}: ${analysis.channel_name}
- Inscritos: ${(analysis.subscriber_count || 0).toLocaleString()}
- Vídeos: ${(analysis.total_videos || 0).toLocaleString()}
- Visualizações: ${(analysis.total_views || 0).toLocaleString()}
- Nicho: ${analysis.niche || 'Não identificado'}

TOP 5 VÍDEOS MAIS VISTOS:
${channelVideos.map((v, i) => `
${i + 1}. "${v.title}"
   - Visualizações: ${(v.view_count || 0).toLocaleString()}
   - Likes: ${(v.like_count || 0).toLocaleString()}
   - Comentários: ${(v.comment_count || 0).toLocaleString()}
   - Score Viral: ${(v.viral_score || 0).toFixed(2)}
   - Thumbnail: ${v.thumbnail_url || 'N/A'}
`).join('') || 'Nenhum vídeo'}

${mostViral ? `VÍDEO MAIS VIRAL DESTE CANAL:
"${mostViral.title}"
- Pegou ${(mostViral.view_count || 0).toLocaleString()} views
- Thumbnail: ${mostViral.thumbnail_url || 'N/A'}
- Este vídeo viralizou com este título e esta thumbnail. Analise profundamente por que funcionou.` : ''}
`;
}).join('\n')}

ANÁLISE PROFUNDA REQUERIDA:

1. IDENTIFICAÇÃO DE SUBNICHOS INEXPLORADOS:
   - Com base nos dados atuais e tendências, identifique subnichos dentro de "${commonNiche}" que:
     * Ainda estejam pouco explorados no YouTube
     * Tenham ALTO VOLUME DE BUSCAS (alta demanda)
     * Tenham INTERESSE CRESCENTE (tendência ascendente)
     * Tenham BOM POTENCIAL DE MONETIZAÇÃO
     * Tenham BAIXA OU NENHUMA CONCORRÊNCIA
   - Priorize oportunidades que sejam ÚNICAS e ainda não exploradas

2. PADRÕES COMUNS IDENTIFICADOS:
   - Padrões nos títulos que aparecem em múltiplos canais e funcionam
   - Padrões de engagement (o que gera mais comentários/likes)
   - Temas de conteúdo comuns que performam bem
   - Estruturas de títulos que funcionam consistentemente
   - Padrões visuais nas thumbnails dos vídeos virais

3. ANÁLISE DE TÍTULOS VIRAIS (PROMPT ESPECÍFICO):
${mostViralVideos.map((v, idx) => `
   - Este vídeo do canal "${v.channelName}" viralizou, pegou ${(v.view_count || 0).toLocaleString()} views com o título: "${v.title}"
   - Preciso que você me dê variações MUITO CHAMATIVAS focadas em viralização para um canal subnichado
   - Identifique os elementos-chave deste título que o tornaram viral
`).join('')}

4. ANÁLISE DE THUMBNAILS VIRAIS (PROMPT ESPECÍFICO):
${mostViralVideos.map((v, idx) => `
   - Este vídeo com esta thumbnail (${v.thumbnail_url || 'N/A'}) viralizou com o título: "${v.title}"
   - Analise como a thumbnail complementa o título e identifique elementos visuais que contribuíram para o viral
   - Quais adaptações desta thumbnail funcionariam para outros títulos virais?
`).join('')}

5. GERAÇÃO DE CONTEÚDO INÉDITO VIRAL:
   - Gere 15 títulos ORIGINAIS e INÉDITOS baseados nos padrões identificados
   - Os títulos devem ser para conteúdo que AINDA NÃO FOI EXPLORADO no YouTube
   - Foque em subnichos com ALTA DEMANDA e BAIXA COMPETIÇÃO
   - Combine os melhores elementos de cada canal analisado
   - Crie títulos que sejam VIRAIS mas para conteúdo NOVO e INEXPLORADO

6. ESTRATÉGIA DE CONTEÚDO:
   - Estratégia que combine os melhores elementos de cada canal
   - Foco em subnichos pouco explorados mas com alta demanda
   - Identifique hooks virais que podem ser aplicados em conteúdo inédito
   - Como estruturar conteúdo para maximizar viralização em nichos inexplorados

7. RECOMENDAÇÕES ESPECÍFICAS:
   - Como criar conteúdo relevante com forte demanda e baixa competição
   - Oportunidades únicas identificadas
   - Estratégias para monetização em subnichos inexplorados
   - Roadmap inicial de conteúdo

Retorne um JSON com a seguinte estrutura:
{
  "unexplored_opportunities": {
    "subniches": [
      {
        "name": "nome do subnicho",
        "demand_level": "alta/média/baixa",
        "competition_level": "baixa/média/alta",
        "monetization_potential": "alto/médio/baixo",
        "why_unexplored": "explicação",
        "trend_direction": "crescendo/estável/decrescendo"
      }
    ],
    "content_gaps": ["gap 1", "gap 2", ...],
    "unique_angles": ["ângulo único 1", "ângulo único 2", ...]
  },
  "common_patterns": {
    "title_patterns": "Descrição detalhada dos padrões de títulos comuns que funcionam",
    "engagement_patterns": "Descrição dos padrões de engagement comuns",
    "content_themes": ["tema1", "tema2", "tema3"],
    "thumbnail_patterns": "Padrões visuais das thumbnails virais",
    "viral_title_elements": ["elemento 1", "elemento 2", ...]
  },
  "viral_title_analysis": {
    "viral_titles": [
      {
        "original_title": "título original que viralizou",
        "why_viral": "análise de por que viralizou",
        "key_elements": ["elemento 1", "elemento 2", ...],
        "variations": ["variação 1", "variação 2", "variação 3"]
      }
    ]
  },
  "thumbnail_analysis": {
    "viral_thumbnails": [
      {
        "title": "título do vídeo",
        "thumbnail_url": "url da thumbnail",
        "visual_elements": ["elemento 1", "elemento 2", ...],
        "thumbnail_title_synergy": "como trabalham juntos",
        "adaptations": ["adaptação 1", "adaptação 2", ...]
      }
    ],
    "recurring_patterns": ["padrão 1", "padrão 2", ...]
  },
  "generated_content": {
    "titles": [
      "título 1 INÉDITO para conteúdo não explorado",
      "título 2 INÉDITO para conteúdo não explorado",
      ... "título 15"
    ],
    "content_strategy": "Estratégia detalhada de conteúdo focado em subnichos inexplorados com alta demanda",
    "hooks": ["hook viral 1", "hook viral 2", "hook viral 3"],
    "unexplored_topics": ["tópico 1 inexplorado", "tópico 2 inexplorado", ...]
  },
  "recommendations": {
    "strategic_recommendations": "Recomendações estratégicas para criar conteúdo viral em subnichos inexplorados",
    "monetization_strategy": "Estratégia de monetização para conteúdo inédito",
    "content_roadmap": ["vídeo 1", "vídeo 2", ...],
    "competitive_advantages": ["vantagem 1", "vantagem 2", ...]
  }
}`;

        // Chamar IA para análise cruzada
        const aiResponse = await callOpenAIAPI(
            crossAnalysisPrompt,
            user.openai_api_key,
            'gpt-4o',
            null,
            []
        );
        
        let crossAnalysisData;
        try {
            if (typeof aiResponse === 'string') {
                crossAnalysisData = JSON.parse(aiResponse);
            } else {
                crossAnalysisData = aiResponse;
            }
        } catch (e) {
            console.error('[Cross Analysis] Erro ao parsear resposta da IA:', e);
            crossAnalysisData = {
                common_patterns: {
                    title_patterns: 'Análise não disponível',
                    engagement_patterns: 'Análise não disponível',
                    content_themes: []
                },
                generated_content: {
                    titles: [],
                    content_strategy: 'Erro ao gerar estratégia',
                    hooks: []
                },
                recommendations: 'Erro ao gerar recomendações'
            };
        }
        
        res.status(200).json(crossAnalysisData);
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/cross-analyze]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao cruzar análises.' });
    }
});

// Analisar comentários de um vídeo e gerar títulos baseados nos comentários
app.post('/api/viral-analysis/videos/:videoId/analyze-comments', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const videoId = req.params.videoId;
        
        // Buscar vídeo no banco
        const video = await db.get(
            'SELECT * FROM channel_viral_videos WHERE video_id = ? AND analysis_id IN (SELECT id FROM channel_viral_analysis WHERE user_id = ?)',
            [videoId, userId]
        );
        
        if (!video) {
            return res.status(404).json({ msg: 'Vídeo não encontrado.' });
        }
        
        // Buscar comentários do vídeo
        const comments = await db.all(
            `SELECT c.* FROM channel_viral_comments c
             INNER JOIN channel_viral_videos v ON c.video_id = v.id
             WHERE v.video_id = ? AND v.analysis_id IN (SELECT id FROM channel_viral_analysis WHERE user_id = ?)
             ORDER BY c.like_count DESC
             LIMIT 100`,
            [videoId, userId]
        );
        
        if (comments.length === 0) {
            return res.status(400).json({ msg: 'Nenhum comentário encontrado para este vídeo.' });
        }
        
        // Buscar API key para IA
        let apiKey = null;
        let service = null;
        let modelToUse = null;
        
        const services = ['claude', 'openai', 'gemini'];
        for (const svc of services) {
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
            if (keyData && keyData.api_key) {
                try {
                    apiKey = decrypt(keyData.api_key);
                    service = svc;
                    if (svc === 'claude') modelToUse = 'claude-3-7-sonnet-20250219';
                    else if (svc === 'openai') modelToUse = 'gpt-4o';
                    else modelToUse = 'gemini-2.5-pro';
                    break;
                } catch (e) {
                    continue;
                }
            }
        }
        
        if (!apiKey) {
            return res.status(400).json({ msg: 'Nenhuma API key de IA configurada.' });
        }
        
        // Buscar nicho do canal
        const analysis = await db.get(
            'SELECT niche, subniche FROM channel_viral_analysis WHERE id = (SELECT analysis_id FROM channel_viral_videos WHERE video_id = ?)',
            [videoId]
        );
        
        const niche = analysis?.niche || 'Não identificado';
        const subniche = analysis?.subniche || '';
        
        // Criar prompt para análise de comentários
        const commentsAnalysisPrompt = `Você é um ESPECIALISTA EM ANÁLISE DE COMENTÁRIOS DO YOUTUBE.

Analise os comentários abaixo de um vídeo que viralizou e gere títulos baseados nos insights dos comentários.

VÍDEO ANALISADO:
- Título: "${video.title}"
- Visualizações: ${(video.view_count || 0).toLocaleString()}
- Likes: ${(video.like_count || 0).toLocaleString()}
- Comentários: ${(video.comment_count || 0).toLocaleString()}
- Nicho: ${niche}${subniche ? ` | Subnicho: ${subniche}` : ''}

COMENTÁRIOS MAIS RELEVANTES (${comments.length} comentários):
${comments.map((c, i) => `
${i + 1}. "${c.text.substring(0, 300)}" - ${c.author_name} (${c.like_count} likes)
`).join('')}

ANÁLISE E GERAÇÃO:

1. IDENTIFIQUE OS PADRÕES NOS COMENTÁRIOS:
   - O que os comentários mais mencionam?
   - Quais são as dúvidas mais frequentes?
   - Quais são os pontos que geraram mais discussão?
   - O que as pessoas querem saber mais sobre este tema?

2. GERE 15 TÍTULOS BASEADOS NOS COMENTÁRIOS:
   - Os títulos devem abordar os temas mais mencionados nos comentários
   - Devem ser chamativos e focados em viralização
   - Devem responder às dúvidas e curiosidades expressas nos comentários
   - Devem ser para o nicho: ${niche}${subniche ? ` (subnicho: ${subniche})` : ''}

3. FÓRMULA DE ESTRUTURA DO TÍTULO:
   - Identifique a estrutura que funcionou neste vídeo
   - Crie uma fórmula que pode ser replicada

Retorne um JSON válido no formato:
{
  "comment_insights": {
    "most_mentioned_topics": ["tema 1", "tema 2", "tema 3"],
    "common_questions": ["pergunta 1", "pergunta 2", "pergunta 3"],
    "discussion_points": ["ponto 1", "ponto 2", "ponto 3"],
    "audience_interests": ["interesse 1", "interesse 2", "interesse 3"]
  },
  "generated_titles": [
    "título 1 baseado nos comentários",
    "título 2 baseado nos comentários",
    ... "título 15"
  ],
  "title_structure_formula": "Fórmula de estrutura do título identificada (ex: Pergunta + Tema + Hook)"
}`;

        // Chamar IA
        let aiResponse;
        if (service === 'claude') {
            aiResponse = await callClaudeAPI(commentsAnalysisPrompt, apiKey, modelToUse);
        } else if (service === 'openai') {
            aiResponse = await callOpenAIAPI(commentsAnalysisPrompt, apiKey, modelToUse);
        } else {
            aiResponse = await callGeminiAPI(commentsAnalysisPrompt, apiKey, modelToUse);
        }
        
        const analysisText = typeof aiResponse === 'string' ? aiResponse : JSON.stringify(aiResponse);
        const parsed = parseAIResponse(analysisText, service);
        
        res.status(200).json({
            video: {
                id: video.id,
                title: video.title,
                view_count: video.view_count,
                comment_count: video.comment_count
            },
            comments_analyzed: comments.length,
            analysis: parsed || {
                comment_insights: {},
                generated_titles: [],
                title_structure_formula: 'Análise não disponível'
            }
        });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/videos/:videoId/analyze-comments]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao analisar comentários.' });
    }
});

// Rota de tradução
app.post('/api/translate', authenticateToken, async (req, res) => {
    const { text, from = 'auto', to = 'pt' } = req.body;

    if (!text || typeof text !== 'string') {
        return res.status(400).json({ msg: 'Texto para tradução é obrigatório.' });
    }

    try {
        const translatedText = await translateText(text, from, to);
        res.status(200).json({
            original: text,
            translated: translatedText,
            from,
            to
        });
    } catch (err) {
        console.error('[ERRO /api/translate]:', err);
        res.status(500).json({ msg: 'Erro ao traduzir texto.' });
    }
});

// Rota de tradução em lote (para múltiplos textos)
app.post('/api/translate/batch', authenticateToken, async (req, res) => {
    const { texts, from = 'auto', to = 'pt' } = req.body;

    if (!Array.isArray(texts) || texts.length === 0) {
        return res.status(400).json({ msg: 'Array de textos é obrigatório.' });
    }

    try {
        const translations = await Promise.all(
            texts.map(text => translateText(text, from, to))
        );

        res.status(200).json({
            translations,
            from,
            to,
            count: translations.length
        });
    } catch (err) {
        console.error('[ERRO /api/translate/batch]:', err);
        res.status(500).json({ msg: 'Erro ao traduzir textos.' });
    }
});

console.log('✅ Serviço de Tradução Online configurado (MyMemory + LibreTranslate)');

// ========== ROTAS DO EDITOR WHISK ==========

// Rota para detectar textos na imagem usando Whisk
app.post('/api/edit/whisk/detect-text', authenticateToken, async (req, res) => {
    try {
        const { imageUrl, imageBase64, whiskCookie } = req.body;

        if (!whiskCookie) {
            return res.status(400).json({ msg: 'Cookie do Whisk é obrigatório.' });
        }

        let imageData = imageBase64;
        if (!imageData && imageUrl) {
            // Se for URL, buscar a imagem e converter para base64
            const response = await fetch(imageUrl);
            const buffer = await response.arrayBuffer();
            imageData = Buffer.from(buffer).toString('base64');
        }

        if (!imageData) {
            return res.status(400).json({ msg: 'Imagem (base64 ou URL) é obrigatória.' });
        }

        // Remover prefixo data:image se existir
        if (imageData.includes(',')) {
            imageData = imageData.split(',')[1];
        }

        const whisk = new WhiskClient(whiskCookie);
        const detections = await whisk.detectText(imageData);

        res.status(200).json({
            success: true,
            detections: detections || []
        });
    } catch (err) {
        console.error('[ERRO /api/edit/whisk/detect-text]:', err);
        if (err instanceof WhiskError) {
            return res.status(err.code || 500).json({ msg: err.message });
        }
        res.status(500).json({ msg: err.message || 'Erro ao detectar textos na imagem.' });
    }
});

// Rota para fazer inpainting (remover/substituir texto) usando Whisk
app.post('/api/edit/whisk/inpaint', authenticateToken, async (req, res) => {
    try {
        const { imageUrl, imageBase64, maskBase64, prompt, whiskCookie } = req.body;

        if (!whiskCookie) {
            return res.status(400).json({ msg: 'Cookie do Whisk é obrigatório.' });
        }

        let imageData = imageBase64;
        if (!imageData && imageUrl) {
            const response = await fetch(imageUrl);
            const buffer = await response.arrayBuffer();
            imageData = Buffer.from(buffer).toString('base64');
        }

        if (!imageData) {
            return res.status(400).json({ msg: 'Imagem (base64 ou URL) é obrigatória.' });
        }

        if (!maskBase64) {
            return res.status(400).json({ msg: 'Máscara (base64) é obrigatória.' });
        }

        // Remover prefixos data:image se existirem
        if (imageData.includes(',')) {
            imageData = imageData.split(',')[1];
        }
        let maskData = maskBase64;
        if (maskData.includes(',')) {
            maskData = maskData.split(',')[1];
        }

        const whisk = new WhiskClient(whiskCookie);
        const resultImage = await whisk.inpaint(imageData, maskData, prompt || 'remove text, keep background seamless');

        res.status(200).json({
            success: true,
            image: `data:image/png;base64,${resultImage}`
        });
    } catch (err) {
        console.error('[ERRO /api/edit/whisk/inpaint]:', err);
        if (err instanceof WhiskError) {
            return res.status(err.code || 500).json({ msg: err.message });
        }
        res.status(500).json({ msg: err.message || 'Erro ao processar imagem com Whisk.' });
    }
});

console.log('✅ Rotas do Editor Whisk configuradas');

// Aguardar banco de dados estar pronto antes de iniciar servidor
// Mas com timeout para não travar indefinidamente
const DB_INIT_TIMEOUT = 10000; // 10 segundos máximo
const startTime = Date.now();

function waitForDatabase() {
    return new Promise((resolve) => {
        if (global.dbReady && db) {
            resolve(true);
            return;
        }
        
        const checkInterval = setInterval(() => {
            if (global.dbReady && db) {
                clearInterval(checkInterval);
                resolve(true);
            } else if (Date.now() - startTime > DB_INIT_TIMEOUT) {
                clearInterval(checkInterval);
                console.warn('⚠️  Timeout aguardando banco de dados. Iniciando servidor mesmo assim...');
                resolve(false);
            }
        }, 100);
    });
}

// Aguardar banco estar pronto (com timeout)
waitForDatabase().then((dbReady) => {
    if (dbReady) {
        console.log('✅ Banco de dados confirmado como pronto. Iniciando servidor...');
    } else {
        console.warn('⚠️  Iniciando servidor sem confirmação do banco de dados');
    }
    startServer();
});
