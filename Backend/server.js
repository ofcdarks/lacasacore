// --- IMPORTS ---
const express = require('express');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const sqlite = require('sqlite');
const sqlite3 = require('sqlite3');
const path = require('path');
const crypto = require('crypto');
const fs = require('fs'); // Importando o módulo File System
require('dotenv').config(); // Carrega as variáveis do ficheiro .env

// Usar @distube/ytdl-core diretamente do GitHub (master branch) - versão mais atualizada
const ytdl = require('@distube/ytdl-core');
console.log('[Sistema] Usando @distube/ytdl-core do GitHub (master branch) - versão mais recente');
const { YoutubeTranscript } = require('youtube-transcript');
const { fetch } = require('undici');
const { ImageFX, AspectRatio, Model, AccountError, ImageFXError } = require('./imagefx.js');
const ffmpeg = require('fluent-ffmpeg');
const ffmpegInstaller = require('@ffmpeg-installer/ffmpeg');
const ffprobeInstaller = require('@ffprobe-installer/ffprobe');
const { OpenAI } = require('openai');
const fse = require('fs-extra');
const axios = require('axios');
const { exec, execSync } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);
const ScriptOptimizer = require('./scriptOptimizer.js');
const AIScriptValidator = require('./aiScriptValidator.js');
const ViralFormulaReplicator = require('./viralFormulaReplicator.js');
const { GoogleGenAI } = require('@google/genai');
const Stripe = require('stripe');
const nodemailer = require('nodemailer');
const LAOZHANG_CHAT_ENDPOINT = process.env.LAOZHANG_CHAT_ENDPOINT || 'https://api.laozhang.ai/v1/chat/completions';

const PROVIDER_NAME_PATTERNS = [
    { pattern: /laozhang(\.ai)?/gi, replacement: 'provedor externo' },
    { pattern: /lao\s*zhang/gi, replacement: 'provedor externo' },
    { pattern: /voz\s*premium/gi, replacement: 'provedor externo' },
    { pattern: /voice\s*premium/gi, replacement: 'provedor externo' },
    { pattern: /genaipro/gi, replacement: 'provedor externo' }
];

const sanitizeUserFacingText = (text, fallback = 'Operação') => {
    if (!text || typeof text !== 'string') {
        return fallback;
    }
    let sanitized = text;
    for (const { pattern, replacement } of PROVIDER_NAME_PATTERNS) {
        sanitized = sanitized.replace(pattern, replacement);
    }
    sanitized = sanitized.replace(/\s{2,}/g, ' ').trim();''
    return sanitized || fallback;
};

// Configurar caminho do FFmpeg e FFprobe automaticamente
ffmpeg.setFfmpegPath(ffmpegInstaller.path);
ffmpeg.setFfprobePath(ffprobeInstaller.path);
console.log(`[Sistema] FFmpeg configurado: ${ffmpegInstaller.path}`);
console.log(`[Sistema] FFprobe configurado: ${ffprobeInstaller.path}`);

// --- CONFIGURAÇÃO ---
const app = express();
const PORT = process.env.PORT || 5001;
const JWT_SECRET = process.env.JWT_SECRET || 'seu-segredo-jwt-super-secreto-trocar-em-prod';

const ENCRYPTION_SECRET = process.env.ENCRYPTION_SECRET || 'abc123def456ghi789jkl012mno345pqr'; // 32 caracteres
const ALGORITHM = 'aes-256-cbc';

// --- GLOBALS ---
let db;

// SSE clients para progresso em tempo real
const sseClients = new Map();

// Diretório temporário para arquivos de áudio
const TEMP_DIR = path.join(__dirname, 'temp_audio');
if (!fs.existsSync(TEMP_DIR)) {
    fs.mkdirSync(TEMP_DIR, { recursive: true });
}

// --- MIDDLEWARES ---
app.use(cors({
  origin: '*', // Allow any origin
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'], // Explicitly allow methods
  allowedHeaders: ['Content-Type', 'Authorization'] // Explicitly allow headers
}));
app.use(express.json({ limit: '50mb' }));

// Middleware de log para requisições (depois do express.json para ter acesso ao body)
app.use((req, res, next) => {
    if (req.path.includes('/forgot-password') || req.path.includes('/auth')) {
        console.log(`[HTTP] ${req.method} ${req.path} - ${new Date().toISOString()}`);
        if (req.body && Object.keys(req.body).length > 0) {
            const bodyCopy = { ...req.body };
            // Ocultar senhas nos logs
            if (bodyCopy.password) bodyCopy.password = '***';
            console.log(`[HTTP] Body recebido:`, bodyCopy);
        }
    }
    next();
});

// Aumentar timeout para requisições longas (transcrição pode demorar)
app.use((req, res, next) => {
    // Timeout de 15 minutos para requisições de transcrição
    if (req.path.includes('/transcript')) {
        req.setTimeout(15 * 60 * 1000); // 15 minutos
        res.setTimeout(15 * 60 * 1000);
    }
    next();
}); // Aumentar limite para suportar URLs de imagens grandes
app.use(express.urlencoded({ limit: '50mb', extended: true }));

// Desabilitar cache para arquivos HTML durante desenvolvimento
app.use(express.static(__dirname, {
    setHeaders: (res, path) => {
        if (path.endsWith('.html')) {
            res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, private');
            res.setHeader('Pragma', 'no-cache');
            res.setHeader('Expires', '0');
        }
    }
}));

// Middleware para garantir que todas as respostas sejam JSON válido
app.use((req, res, next) => {
    // Interceptar res.json para garantir formato válido
    const originalJson = res.json;
    res.json = function(data) {
        // Garantir que sempre retorna JSON válido
        if (typeof data === 'string') {
            try {
                data = JSON.parse(data);
            } catch {
                data = { msg: data };
            }
        }
        res.setHeader('Content-Type', 'application/json');
        return originalJson.call(this, data);
    };
    next();
});

// Middleware de tratamento de erros para garantir que sempre retorne JSON
app.use((err, req, res, next) => {
    console.error('Erro no middleware:', err);
    if (!res.headersSent) {
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});

// Rota para redirecionar o acesso direto ao arquivo de autenticação
app.get('/la-casa-dark-core-auth.html', (req, res) => {
    res.redirect('/');
});

// Rota principal para servir a página de autenticação
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'la-casa-dark-core-auth.html'));
});


// --- FUNÇÕES AUXILIARES DE ENCRIPTAÇÃO ---
function encrypt(text) {
    if (!ENCRYPTION_SECRET || ENCRYPTION_SECRET.length !== 32) {
        console.error("ENCRYPTION_SECRET inválida. Deve ter 32 caracteres.");
        throw new Error("Configuração de encriptação inválida.");
    }
    const iv = crypto.randomBytes(16); // Gera um novo IV para cada encriptação
    const cipher = crypto.createCipheriv(ALGORITHM, Buffer.from(ENCRYPTION_SECRET), iv);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return `${iv.toString('hex')}:${encrypted}`;
}

function decrypt(hash) {
    if (!ENCRYPTION_SECRET || ENCRYPTION_SECRET.length !== 32) {
        console.error("ENCRYPTION_SECRET inválida. Deve ter 32 caracteres.");
        throw new Error("Configuração de encriptação inválida.");
    }
    try {
        const parts = hash.split(':');
        const decipher_iv = Buffer.from(parts.shift(), 'hex');
        const encryptedText = Buffer.from(parts.join(':'), 'hex');
        const decipher = crypto.createDecipheriv(ALGORITHM, Buffer.from(ENCRYPTION_SECRET), decipher_iv);
        let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    } catch (err) {
        console.error("Falha ao desencriptar:", err);
        return null;
    }
}


// --- FUNÇÕES AUXILIARES DE MINERAÇÃO (YOUTUBE API V3) ---
async function callYouTubeDataAPI(videoId, apiKey) {
    if (!apiKey || !apiKey.trim()) {
        throw new Error('Chave de API do YouTube não fornecida.');
    }
    
    // Limpar a chave de espaços e caracteres inválidos
    apiKey = apiKey.trim();
    
    const url = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoId}&key=${apiKey}`;
    try {
        const response = await fetch(url);
        const data = await response.json();
        
        if (!response.ok) {
            // Verificar erros específicos da API do YouTube
            if (data.error) {
                const errorMessage = data.error.message || '';
                const errorReason = data.error.errors?.[0]?.reason || '';
                
                console.log('[YouTube API] Erro recebido:', {
                    status: response.status,
                    errorMessage: errorMessage,
                    errorReason: errorReason,
                    fullError: JSON.stringify(data.error, null, 2)
                });
                
                // Erro de API key inválida
                if (errorMessage.includes('API key not valid') || 
                    errorMessage.includes('invalid API key') ||
                    errorMessage.includes('badRequest') ||
                    errorReason === 'keyInvalid' ||
                    errorReason === 'badRequest') {
                    throw new Error('A chave de API do YouTube está inválida. Configure uma chave válida nas Configurações.');
                }
                
                // Erro de API key não fornecida
                if (errorMessage.includes('API key not found') || 
                    errorReason === 'keyNotFound') {
                    throw new Error('Chave de API do YouTube não configurada. Configure uma chave nas Configurações.');
                }
                
                // Erro de quota excedida
                if (errorMessage.includes('quota') || errorReason === 'quotaExceeded') {
                    throw new Error('Cota da API do YouTube excedida. Tente novamente mais tarde.');
                }
                
                // Outros erros
                throw new Error(errorMessage || 'Erro ao buscar dados do YouTube.');
            }
            
            throw new Error('Erro desconhecido ao buscar dados do YouTube.');
        }
        
        if (!data.items || data.items.length === 0) {
            throw new Error('Vídeo não encontrado. Verifique se a URL está correta.');
        }
        
        const item = data.items[0];
        const snippet = item.snippet;
        const stats = item.statistics;

        return {
            title: snippet.title,
            description: snippet.description || '',
            thumbnailUrl: snippet.thumbnails.maxres?.url || snippet.thumbnails.high?.url || snippet.thumbnails.default?.url,
            views: stats.viewCount || 0,
            likes: stats.likeCount || 0,
            comments: stats.commentCount || 0,
            days: Math.round((new Date() - new Date(snippet.publishedAt)) / (1000 * 60 * 60 * 24))
        };
    } catch (err) {
        console.error("Erro ao chamar YouTube Data API v3:", err);
        // Se o erro já tem uma mensagem amigável, manter
        if (err.message && (
            err.message.includes('chave de API') || 
            err.message.includes('API key') ||
            err.message.includes('Cota') ||
            err.message.includes('não encontrado')
        )) {
            throw err;
        }
        // Caso contrário, lançar erro genérico
        throw new Error(`Falha ao buscar dados do YouTube: ${err.message}`);
    }
}

async function getChannelVideosWithDetails(channelId, apiKey, order = 'date', maxResults = 5) {
    try {
        // Etapa 1: Buscar IDs dos vídeos
        const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=id&channelId=${channelId}&order=${order}&maxResults=${maxResults}&type=video&key=${apiKey}`;
        const searchResponse = await fetch(searchUrl);
        
        if (!searchResponse.ok) {
            const errorText = await searchResponse.text();
            console.error('[getChannelVideosWithDetails] Erro na busca de vídeos:', searchResponse.status, errorText.substring(0, 200));
            // Tentar parsear como JSON, se falhar retornar array vazio
            try {
                const errorData = JSON.parse(errorText);
                throw new Error(errorData.error?.message || `Erro ao buscar vídeos: ${searchResponse.status}`);
            } catch {
                throw new Error(`Erro ao buscar vídeos do canal: ${searchResponse.status}`);
            }
        }
        
        const searchData = await searchResponse.json();
        if (!searchData.items || !Array.isArray(searchData.items)) {
            console.warn('[getChannelVideosWithDetails] Nenhum vídeo encontrado ou resposta inválida');
            return [];
        }
        
        const videoIds = searchData.items.map(item => item.id?.videoId).filter(id => id).join(',');
        if (!videoIds) {
            console.warn('[getChannelVideosWithDetails] Nenhum ID de vídeo válido encontrado');
            return [];
        }

        // Etapa 2: Buscar detalhes e estatísticas de todos os vídeos de uma vez
        const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoIds}&key=${apiKey}`;
        const detailsResponse = await fetch(detailsUrl);
        
        if (!detailsResponse.ok) {
            const errorText = await detailsResponse.text();
            console.error('[getChannelVideosWithDetails] Erro ao buscar detalhes:', detailsResponse.status, errorText.substring(0, 200));
            // Tentar parsear como JSON, se falhar retornar array vazio
            try {
                const errorData = JSON.parse(errorText);
                throw new Error(errorData.error?.message || `Erro ao buscar detalhes: ${detailsResponse.status}`);
            } catch {
                throw new Error(`Erro ao buscar detalhes dos vídeos: ${detailsResponse.status}`);
            }
        }
        
        const detailsData = await detailsResponse.json();
        if (!detailsData.items || !Array.isArray(detailsData.items)) {
            console.warn('[getChannelVideosWithDetails] Nenhum detalhe de vídeo encontrado');
            return [];
        }

        // Etapa 3: Mapear e formatar os dados (com receita e RPM estimados)
        return detailsData.items.map(item => {
            const uploadDate = new Date(item.snippet.publishedAt);
            const daysPosted = Math.round((new Date() - uploadDate) / (1000 * 60 * 60 * 24));
            const views = parseInt(item.statistics.viewCount || 0);
            // Calcular receita e RPM (usar padrão, pode ser melhorado buscando nicho do canal)
            const rpm = getRPMByNiche(null);
            const estimatedRevenueUSD = (views / 1000) * rpm.usd;
            const estimatedRevenueBRL = (views / 1000) * rpm.brl;
            
            return {
                videoId: item.id,
                title: item.snippet.title,
                thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default?.url || '',
                publishedAt: item.snippet.publishedAt,
                views: views,
                likes: parseInt(item.statistics.likeCount || 0),
                comments: parseInt(item.statistics.commentCount || 0),
                days: daysPosted,
                estimatedRevenueUSD: estimatedRevenueUSD,
                estimatedRevenueBRL: estimatedRevenueBRL,
                rpmUSD: rpm.usd,
                rpmBRL: rpm.brl
            };
        });
    } catch (err) {
        console.error('[getChannelVideosWithDetails] Erro geral:', err.message);
        // Sempre retornar array vazio em caso de erro, não lançar exceção
        return [];
    }
}

// --- Helper para buscar imagem como Base64 ---
async function fetchImageAsBase64(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Falha ao baixar imagem: ${response.statusText}`);
        const buffer = await response.arrayBuffer();
        const base64 = Buffer.from(buffer).toString('base64');
        const mimeType = response.headers.get('content-type') || 'image/jpeg';
        return { base64, mimeType };
    } catch (err) {
        console.error(`Erro ao converter imagem para base64: ${err.message}`);
        throw err;
    }
}

// --- Helper para corrigir JSON com quebras de linha não escapadas ---
function fixJsonWithUnescapedNewlines(jsonString) {
    let result = '';
    let inString = false;
    let escapeNext = false;
    
    for (let i = 0; i < jsonString.length; i++) {
        const char = jsonString[i];
        const nextChar = jsonString[i + 1];
        
        if (escapeNext) {
            result += char;
            escapeNext = false;
            continue;
        }
        
        if (char === '\\') {
            result += char;
            escapeNext = true;
            continue;
        }
        
        if (char === '"') {
            inString = !inString;
            result += char;
            continue;
        }
        
        if (inString && (char === '\n' || char === '\r')) {
            // Substituir quebras de linha dentro de strings por \n escapado
            if (char === '\r' && nextChar === '\n') {
                result += '\\n';
                i++; // Pular o \n também
            } else {
                result += '\\n';
            }
            continue;
        }
        
        result += char;
    }
    
    return result;
}

// --- Helper para analisar resposta JSON da IA ---
function parseAIResponse(responseText, serviceName) {
    try {
        // Limpar o texto removendo possíveis markdown code blocks
        let cleanedText = responseText.trim();
        
        // Remover markdown code blocks se existirem
        cleanedText = cleanedText.replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/\s*```$/i, '');
        
        // Tenta encontrar um objeto JSON dentro de uma string maior (comum com Claude)
        const jsonMatch = cleanedText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
            let jsonString = jsonMatch[0];
            
            // Tentar parsear diretamente
            try {
                return JSON.parse(jsonString);
            } catch (parseError) {
                // Se falhar, tentar corrigir quebras de linha não escapadas
                try {
                    const fixedJson = fixJsonWithUnescapedNewlines(jsonString);
                    return JSON.parse(fixedJson);
                } catch (secondError) {
                    // Última tentativa: usar uma abordagem mais robusta
                    // Extrair apenas o conteúdo entre as primeiras chaves
                    const firstBrace = jsonString.indexOf('{');
                    const lastBrace = jsonString.lastIndexOf('}');
                    
                    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
                        let extractedJson = jsonString.substring(firstBrace, lastBrace + 1);
                        extractedJson = fixJsonWithUnescapedNewlines(extractedJson);
                        return JSON.parse(extractedJson);
                    }
                    
                    throw parseError;
                }
            }
        }
        
        // Se não encontrar, tenta parsear a string inteira
        return JSON.parse(cleanedText);
    } catch (e) {
        console.error(`[Análise-${serviceName}] Falha ao parsear JSON da IA:`, e);
        console.error(`[Análise-${serviceName}] Texto recebido (primeiros 2000 caracteres):`, responseText.substring(0, 2000));
        
        // Tentar uma última abordagem: usar regex para extrair campos específicos
        try {
            // Regex mais robusta que lida com quebras de linha dentro de strings
            const nicheMatch = responseText.match(/"niche"\s*:\s*"((?:[^"\\]|\\.)*)"/);
            const subnicheMatch = responseText.match(/"subniche"\s*:\s*"((?:[^"\\]|\\.)*)"/);
            // Usar [\s\S] em vez de . com flag s para compatibilidade
            const motivoMatch = responseText.match(/"motivoSucesso"\s*:\s*"((?:[^"\\]|\\.|[\s\S])*?)"/);
            const formulaMatch = responseText.match(/"formulaTitulo"\s*:\s*"((?:[^"\\]|\\.|[\s\S])*?)"/);
            
            if (nicheMatch && motivoMatch) {
                console.warn(`[Análise-${serviceName}] Usando fallback de parsing regex devido a JSON malformado`);
                
                // Extrair títulos sugeridos usando regex (mais robusta)
                const titulosMatches = [...responseText.matchAll(/"titulo"\s*:\s*"((?:[^"\\]|\\.)*)"/g)];
                const titulos = titulosMatches.map(m => m[1]).filter(t => t.length > 0);
                
                // Limpar quebras de linha dos valores extraídos
                const cleanValue = (val) => val.replace(/\r?\n/g, ' ').trim();
                
                return {
                    niche: cleanValue(nicheMatch[1]),
                    subniche: subnicheMatch ? cleanValue(subnicheMatch[1]) : 'N/A',
                    analiseOriginal: {
                        motivoSucesso: cleanValue(motivoMatch[1]),
                        formulaTitulo: formulaMatch ? cleanValue(formulaMatch[1]) : 'N/A'
                    },
                    titulosSugeridos: titulos.map((titulo, index) => ({
                        titulo: cleanValue(titulo),
                        pontuacao: 8,
                        explicacao: `Título gerado pela IA (parsing fallback)`
                    }))
                };
            }
        } catch (fallbackError) {
            console.error(`[Análise-${serviceName}] Fallback também falhou:`, fallbackError);
        }
        
        throw new Error(`A IA (${serviceName}) retornou um formato JSON inválido.`);
    }
}


// --- FUNÇÕES AUXILIARES DE API (O DISTRIBUIDOR) ---

async function callGeminiAPI(prompt, apiKey, model, imageUrl = null) {
    if (!apiKey) throw new Error("Chave de API do Utilizador (Gemini) não configurada.");
    
    const modelName = model; // Usar o nome do modelo diretamente do frontend

    const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
    
    const parts = [{ text: prompt }];
    if (imageUrl) {
        const { base64, mimeType } = await fetchImageAsBase64(imageUrl);
        parts.unshift({
            inlineData: {
                mimeType: mimeType,
                data: base64
            }
        });
    }

    // Detectar se é pedido de roteiro (texto puro) ou JSON
    const isScriptRequest = typeof prompt === 'string' && (
        prompt.includes('RESPOSTA FINAL - CRÍTICO') ||
        prompt.includes('roteiro em TEXTO SIMPLES') ||
        prompt.includes('NÃO use JSON') ||
        prompt.includes('Escreva APENAS o texto') ||
        prompt.includes('SEM JSON')
    );

    const generationConfig = {
            temperature: 0.7, 
            topK: 1, 
            topP: 1, 
            maxOutputTokens: 32000  // Aumentar para permitir gerar muitas cenas (31 cenas x ~1000 chars = ~31000 tokens)
    };
    
    // CRÍTICO: Só adicionar responseMimeType se NÃO for pedido de roteiro
    if (!isScriptRequest) {
        generationConfig.responseMimeType = "application/json";
    }

    const payload = {
        contents: [{ parts: parts }],
        generationConfig: generationConfig,
    };

    // Retry logic com backoff exponencial para erro 429 (Resource exhausted)
    const maxRetries = 3;
    const baseDelay = 2000; // 2 segundos base
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
            const response = await fetch(GEMINI_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();

            if (!response.ok) {
                console.error('[La Casa Dark Core] Erro da API:', result);
                
                // Tratar erro de autenticação
                if (response.status === 400 && result.error?.message.includes('API key not valid')) {
                    throw new Error(`A sua Chave de API do Gemini é inválida.`);
                }
                
                // Tratar erro 429 (Resource exhausted) com retry
                if (response.status === 429 || (result.error?.message && result.error.message.includes('Resource exhausted'))) {
                    if (attempt < maxRetries) {
                        const delay = baseDelay * Math.pow(2, attempt); // Backoff exponencial: 2s, 4s, 8s
                        console.warn(`[La Casa Dark Core] Limite de requisições atingido (429). Tentativa ${attempt + 1}/${maxRetries + 1}. Aguardando ${delay}ms antes de tentar novamente...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue; // Tentar novamente
                    } else {
                        // Todas as tentativas falharam
                        throw new Error(`Limite de requisições atingido para a API Gemini. Aguarde alguns minutos ou use outro modelo de IA (Claude ou OpenAI). Detalhes: ${result.error?.message || response.statusText}`);
                    }
                }
                
                // Outros erros não relacionados a rate limit
                throw new Error(`Erro da API Gemini: ${result.error?.message || response.statusText}`);
            }
            
            // Sucesso - processar resposta
            if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0].text) {
                const content = result.candidates[0].content.parts[0].text;
                
                // Se for pedido de roteiro, retornar texto direto
                if (isScriptRequest) {
                    console.log('[La Casa Dark Core] Retornando texto puro de script');
                    return content; // Retorna string diretamente
                } else {
                    // Para JSON, manter comportamento antigo
                    return { titles: content, model: model };
                }
            } else {
                console.error('[La Casa Dark Core] Resposta inesperada da API:', result);
                throw new Error('A resposta da IA foi bloqueada ou retornou vazia.');
            }
        } catch (error) {
            // Se for erro de rate limit e ainda temos tentativas, continuar o loop
            if (error.message.includes('Resource exhausted') || error.message.includes('Limite de requisições')) {
                if (attempt < maxRetries) {
                    const delay = baseDelay * Math.pow(2, attempt);
                    console.warn(`[La Casa Dark Core] Erro detectado. Tentativa ${attempt + 1}/${maxRetries + 1}. Aguardando ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    continue;
                }
            }
            
            // Se não for erro de rate limit ou se esgotaram as tentativas, lançar erro
            console.error('[La Casa Dark Core] Falha ao chamar a API:', error);
            throw error;
        }
    }
}
async function callOpenAIAPI(prompt, apiKey, model, imageUrl = null) {
    if (!apiKey) throw new Error("Chave de API do Utilizador (OpenAI) não configurada.");
    
    const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
    
    const modelName = model; // Usar o nome do modelo diretamente do frontend

    const content = [{ type: "text", text: prompt }];
    if (imageUrl) {
        content.unshift({
            type: "image_url",
            image_url: { "url": imageUrl, "detail": "high" }
        });
    }

    // Detectar se é pedido de roteiro (texto puro) ou JSON
    const isScriptRequest = typeof prompt === 'string' && (
        prompt.includes('RESPOSTA FINAL - CRÍTICO') ||
        prompt.includes('roteiro em TEXTO SIMPLES') ||
        prompt.includes('NÃO use JSON') ||
        prompt.includes('Escreva APENAS o texto') ||
        prompt.includes('SEM JSON')
    );

    const payload = {
        model: modelName,
        messages: [
            { 
                role: "system", 
                content: isScriptRequest 
                    ? "You are a professional scriptwriter. Respond ONLY with the script text in plain text format. Do NOT use JSON, objects, or special formatting. Write natural, flowing text."
                    : "You are a helpful assistant designed to output JSON."
            },
            { role: "user", content: content }
        ],
        temperature: 0.7,
        max_tokens: 32000,  // Aumentar para permitir gerar muitas cenas (31 cenas x ~1000 chars = ~31000 tokens)
    };
    
    // CRÍTICO: Só adicionar response_format se NÃO for pedido de roteiro
    if (!isScriptRequest) {
        payload.response_format = { type: "json_object" };
    }

    try {
        const response = await fetch(OPENAI_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify(payload)
        });
        const result = await response.json();

        if (!response.ok) {
            console.error('[La Casa Dark Core] Erro da API:', result);
            if (result.error?.code === 'invalid_api_key') {
                 throw new Error(`A sua Chave de API do OpenAI é inválida.`);
            }
            throw new Error(`Erro da API OpenAI: ${result.error?.message || response.statusText}`);
        }
        if (result.choices && result.choices[0].message && result.choices[0].message.content) {
            const content = result.choices[0].message.content;
            
            // Se for pedido de roteiro, retornar texto direto sem envolver em "titles"
            if (isScriptRequest) {
                console.log('[La Casa Dark Core] Retornando texto puro de script');
                return content; // Retorna string diretamente
            } else {
                // Para JSON, manter comportamento antigo
                return { titles: content, model: model };
            }
        } else {
            throw new Error('A resposta da IA (OpenAI) retornou vazia.');
        }
    } catch (error) {
        console.error('[La Casa Dark Core] Falha ao chamar a API:', error);
        throw error;
    }
}

async function callClaudeAPI(prompt, apiKey, model, imageUrl = null) {
    if (!apiKey) throw new Error("Chave de API do Utilizador (Claude) não configurada.");
    
    const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';
    
    // Mapeamento de nomes amigáveis para nomes corretos da API da Anthropic
    // MODELOS VÁLIDOS CONFIRMADOS (Novembro 2025 - Anthropic API):
    // - claude-3-7-sonnet-20250219 (Sonnet mais recente)
    // - claude-sonnet-4-20250514 (Sonnet 4)
    // - claude-opus-4-20250514 (Opus 4)
    const modelAliases = {
        'claude-3-5-sonnet-20241022': 'claude-3-7-sonnet-20250219',
        'claude-3-5-sonnet-20240620': 'claude-3-7-sonnet-20250219',
        'claude-3-5-sonnet-latest': 'claude-3-7-sonnet-20250219',
        'claude-3-sonnet-20240229': 'claude-3-7-sonnet-20250219',
        'claude-3.5-sonnet-20241022': 'claude-3-7-sonnet-20250219',
        'claude-3.5-sonnet-20240620': 'claude-3-7-sonnet-20250219',
        'claude-3-haiku-20240307': 'claude-3-7-sonnet-20250219',
        'claude-3.5-haiku-20241022': 'claude-3-7-sonnet-20250219',
        'claude-3-5-haiku-20241022': 'claude-3-7-sonnet-20250219',
        'claude-3-5-haiku-latest': 'claude-3-7-sonnet-20250219',
        'claude-3-opus-20240229': 'claude-opus-4-20250514'
    };
    
    const supportedModels = new Set([
        'claude-3-7-sonnet-20250219',  // Modelo mais recente
        'claude-sonnet-4-20250514',    // Sonnet 4
        'claude-opus-4-20250514'       // Opus 4
    ]);
    
    let modelName = modelAliases[model] || model;
    
    if (!supportedModels.has(modelName)) {
        if (model && model.toLowerCase().includes('opus')) {
            modelName = 'claude-opus-4-20250514';
        } else if (model && (model.toLowerCase().includes('sonnet') || model.toLowerCase().includes('4'))) {
            modelName = 'claude-sonnet-4-20250514';
        } else {
            modelName = 'claude-3-7-sonnet-20250219';
        }
        console.warn(`[Claude API] Modelo ${model} não reconhecido. Usando ${modelName} como padrão.`);
    }
    
    const validModels = ['claude-3-7-sonnet-20250219', 'claude-sonnet-4-20250514', 'claude-opus-4-20250514'];
    
    console.log(`[Claude API] Modelo original: ${model}, Modelo mapeado: ${modelName}`);

    const content = [{ type: "text", text: prompt }];
    if (imageUrl) {
        const { base64, mimeType } = await fetchImageAsBase64(imageUrl);
        content.unshift({
            type: "image",
            source: {
                type: "base64",
                media_type: mimeType,
                data: base64
            }
        });
    }

    // Detectar se é pedido de roteiro (texto puro) ou JSON
    const isScriptRequest = typeof prompt === 'string' && (
        prompt.includes('RESPOSTA FINAL - CRÍTICO') ||
        prompt.includes('roteiro em TEXTO SIMPLES') ||
        prompt.includes('NÃO use JSON')
    );

    const payload = {
        model: modelName,
        system: isScriptRequest 
            ? "Você é um roteirista profissional. Responda APENAS com o texto do roteiro, sem usar JSON, objetos ou formatações especiais. Escreva texto corrido e natural."
            : "Responda APENAS com o objeto JSON solicitado, começando com { e terminando com }.",
        messages: [{ role: "user", content: content }],
        temperature: 0.7,
        max_tokens: 32000,  // Aumentar para permitir gerar muitas cenas (31 cenas x ~1000 chars = ~31000 tokens)
    };

    try {
        // Timeout de 120 segundos para evitar travamentos
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 120000);

        const response = await fetch(CLAUDE_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify(payload),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        const result = await response.json();
        
        // Log para debug (só primeiros 500 caracteres)
        if (isScriptRequest && result.content) {
            console.log('[Claude API] Resposta para roteiro (preview):', JSON.stringify(result).substring(0, 500));
        }

        if (!response.ok) {
            console.error('Erro da API Claude:', result);
            console.error(`[Claude API] Modelo tentado: ${modelName} (original: ${model})`);
            if (result.error?.type === 'authentication_error') {
                 throw new Error(`A sua Chave de API do Claude é inválvida.`);
            }
            // Mensagem de erro mais detalhada
            const errorMsg = result.error?.message || response.statusText;
            if (errorMsg.includes('model') || errorMsg.includes('invalid') || errorMsg.includes('not found') || errorMsg.includes('does not exist')) {
                // Tentar fallback automático com os modelos válidos mais recentes
    const validModels = ['claude-3-7-sonnet-20250219', 'claude-sonnet-4-20250514', 'claude-opus-4-20250514'];
                
                // Tentar outros modelos válidos se o atual falhou
                for (const altModel of validModels) {
                    if (altModel === modelName) continue; // Pular o modelo que já falhou
                    
                    try {
                        console.log(`[Claude API] Tentando modelo alternativo: ${altModel}`);
                        const fallbackPayload = { ...payload, model: altModel };
                        const fallbackResponse = await fetch(CLAUDE_API_URL, {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json',
                                'x-api-key': apiKey,
                                'anthropic-version': '2023-06-01'
                            },
                            body: JSON.stringify(fallbackPayload)
                        });
                        const fallbackResult = await fallbackResponse.json();
                        
                        if (fallbackResponse.ok && fallbackResult.content && fallbackResult.content[0] && fallbackResult.content[0].text) {
                            console.log(`[Claude API] Sucesso com modelo alternativo: ${altModel}`);
                            return { titles: fallbackResult.content[0].text, model: model };
                        }
                    } catch (fallbackErr) {
                        console.warn(`[Claude API] Fallback ${altModel} falhou:`, fallbackErr.message);
                        continue;
                    }
                }
                
                // Se todos os modelos válidos falharem, mostrar erro
                throw new Error(`Modelo Claude inválido ou não disponível: ${modelName}. Use um destes modelos válidos: ${validModels.join(', ')}. Erro da API: ${errorMsg}`);
            }
            throw new Error(`Erro da API Claude: ${errorMsg}`);
        }
        if (result.content && result.content[0] && result.content[0].text) {
            return { titles: result.content[0].text, model: model };
        } else {
            throw new Error('A resposta da IA (Claude) retornou vazia.');
        }
    } catch (error) {
        // Tratamento específico para timeout
        if (error.name === 'AbortError') {
            console.error('[Claude API] ⏰ Timeout após 120 segundos');
            throw new Error('A API do Claude demorou muito para responder (timeout). Tente novamente com um roteiro mais curto ou use outro modelo.');
        }
        console.error('Falha ao chamar a API do Claude:', error);
        throw error;
    }
}

// Função para remover repetições de frases/parágrafos
function removeRepetitions(text) {
    if (!text) return text;
    
    const sentences = text.split(/[.!?]\s+/);
    const uniqueSentences = [];
    const seenSentences = new Set();
    
    for (const sentence of sentences) {
        const normalized = sentence.trim().toLowerCase().replace(/\s+/g, ' ');
        if (normalized.length > 20 && !seenSentences.has(normalized)) {
            uniqueSentences.push(sentence.trim());
            seenSentences.add(normalized);
        } else if (normalized.length <= 20) {
            uniqueSentences.push(sentence.trim());
        }
    }
    
    return uniqueSentences.join('. ') + '.';
}

/**
 * Remove marcações de roteiro (música, visual, narrador, etc.) deixando apenas texto para voice over
 * @param {string} script - Texto do roteiro com marcações
 * @returns {string} - Roteiro limpo apenas com texto para narração
 */
function cleanScriptForVoiceOver(script) {
    if (!script || typeof script !== 'string') return script;
    
    let cleaned = script;
    
    // Remover marcações de PARTE X com intervalos de tempo (mais agressivo)
    cleaned = cleaned.replace(/PARTE\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gi, ''); // Remove linha inteira com "PARTE 1 0:00 - 3:00"
    cleaned = cleaned.replace(/Parte\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gi, ''); // Remove linha inteira com "Parte 1 0:00 - 3:00"
    cleaned = cleaned.replace(/PARTE\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}/gi, ''); // Remove "PARTE 1 0:00 - 3:00" (sem quebra de linha)
    cleaned = cleaned.replace(/Parte\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}/gi, ''); // Remove "Parte 1 0:00 - 3:00" (sem quebra de linha)
    cleaned = cleaned.replace(/PARTE\s+\d+.*?(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})/gi, ''); // Remove "PARTE 1 0:00 - 3:00" (qualquer variação)
    cleaned = cleaned.replace(/Parte\s+\d+.*?(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})/gi, ''); // Remove "Parte 1 0:00 - 3:00" (qualquer variação)
    cleaned = cleaned.replace(/^\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gmi, ''); // Remove linha que começa com "0:00 - 3:00"
    cleaned = cleaned.replace(/^\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}\s*/gmi, ''); // Remove "0:00 - 3:00" no início da linha (sem quebra)
    cleaned = cleaned.replace(/PARTE\s+\d+\s*$/gmi, ''); // Remove "PARTE 1" sozinho no final da linha
    cleaned = cleaned.replace(/Parte\s+\d+\s*$/gmi, ''); // Remove "Parte 1" sozinho no final da linha
    
    // Remover marcações de música e sons entre parênteses
    cleaned = cleaned.replace(/\([^)]*[Mm]úsica[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([^)]*[Ss]om[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([^)]*[Aa]udio[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([^)]*[Tt]ela[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([^)]*[Cc]âmera[^)]*\)/gi, '');
    
    // Remover marcações de visual entre parênteses
    cleaned = cleaned.replace(/\([Vv]isual[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Vv]isualização[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Ii]magem[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Aa]nimação[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Cc]ena[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Mm]apa[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Rr]eencenação[^)]*\)/gi, '');
    
    // Remover marcações genéricas entre parênteses que começam com maiúscula (geralmente são direções)
    cleaned = cleaned.replace(/\([A-Z][^)]*\)/g, '');
    
    // Remover prefixos de narrador/personagem
    cleaned = cleaned.replace(/^NARRADOR:\s*/gmi, '');
    cleaned = cleaned.replace(/^NARRATOR:\s*/gmi, '');
    cleaned = cleaned.replace(/^VOZ:\s*/gmi, '');
    cleaned = cleaned.replace(/^VOICE:\s*/gmi, '');
    cleaned = cleaned.replace(/^[A-ZÁÉÍÓÚÀÈÌÒÙÂÊÎÔÛÃÕÇ]+:\s*/gm, ''); // Remove qualquer palavra em maiúsculas seguida de dois pontos no início da linha
    
    // Remover linhas que são apenas direções ou marcações
    cleaned = cleaned.split('\n')
        .map(line => {
            const trimmed = line.trim();
            // Remover linhas que são apenas parênteses vazios ou com conteúdo de direção
            if (trimmed.match(/^\([^)]*\)\s*$/)) return '';
            // Remover linhas muito curtas que são provavelmente marcações
            if (trimmed.length < 3 && trimmed.match(/^[A-Z\s]+$/)) return '';
            return line;
        })
        .filter(line => line.trim().length > 0)
        .join('\n');
    
    // Limpar múltiplas quebras de linha
    cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
    
    // Limpar espaços extras
    cleaned = cleaned.replace(/[ \t]+/g, ' ');
    cleaned = cleaned.replace(/\s+\n/g, '\n');
    cleaned = cleaned.replace(/\n\s+/g, '\n');
    
    // Remover espaços no início e fim
    cleaned = cleaned.trim();
    
    return cleaned;
}

function extractTextFromAIResponse(response) {
    if (response === null || response === undefined) {
        console.warn('[extractTextFromAIResponse] Response is null or undefined');
        return '';
    }
    
    // Se for string, retornar diretamente
    if (typeof response === 'string') {
        return response;
    }
    
    // Se for array, processar recursivamente
    if (Array.isArray(response)) {
        return response
            .map(item => extractTextFromAIResponse(item))
            .filter(Boolean)
            .join('\n');
    }
    
    // Se for objeto, tentar extrair de várias formas
    if (typeof response === 'object') {
        // PRIORIDADE 1: Claude retorna content como array de objetos com text
        if (response.content && Array.isArray(response.content)) {
            const extracted = response.content
                .map(item => {
                    if (typeof item === 'string') return item;
                    if (typeof item.text === 'string') return item.text;
                    if (typeof item.content === 'string') return item.content;
                    return '';
                })
                .filter(Boolean)
                .join('\n');
            
            if (extracted.trim().length > 0) {
                console.log('[extractTextFromAIResponse] ✅ Extracted from content array (Claude format)');
                return extracted;
            }
        }
        
        // PRIORIDADE 2: Campos específicos de roteiro (evitar "titles")
        const scriptFields = [
            'script',      // Roteiros
            'roteiro',     // Roteiro em PT
            'text',        // Campo genérico de texto
            'output_text', // Saída de texto
            'message',     // Mensagem
            'response',    // Resposta genérica
            'result'       // Resultado
        ];
        
        for (const field of scriptFields) {
            if (typeof response[field] === 'string' && response[field].trim().length > 0) {
                console.log(`[extractTextFromAIResponse] ✅ Extracted from field: ${field}`);
                return response[field];
            }
        }
        
        // PRIORIDADE 3: Campo "content" como string (Gemini)
        if (typeof response.content === 'string' && response.content.trim().length > 0) {
            console.log('[extractTextFromAIResponse] ✅ Extracted from content string');
            return response.content;
        }
        
        // ÚLTIMO RECURSO: "titles" (só se nada mais funcionar e tiver conteúdo real)
        if (typeof response.titles === 'string') {
            const trimmedTitles = response.titles.trim();
            // Verificar se tem conteúdo real (não apenas espaços/tabs/newlines)
            const hasRealContent = trimmedTitles.length > 50 && /[a-zA-Z0-9]{10,}/.test(trimmedTitles);
            if (hasRealContent) {
                console.warn('[extractTextFromAIResponse] ⚠️ Using "titles" field as fallback - this might be wrong for scripts!');
                return trimmedTitles;
            } else if (trimmedTitles.length > 0) {
                console.error(`[extractTextFromAIResponse] ❌ "titles" field has only whitespace (${trimmedTitles.length} chars): "${trimmedTitles.substring(0, 100)}"`);
            }
        }
        
        // Log completo do objeto para debug
        console.error('[extractTextFromAIResponse] ❌ Não encontrou texto em nenhum campo conhecido!');
        console.error('[extractTextFromAIResponse] Campos disponíveis:', Object.keys(response));
        console.error('[extractTextFromAIResponse] Objeto completo (primeiros 500 chars):', JSON.stringify(response).substring(0, 500));
        
        // Tentar JSON.stringify como último recurso (provavelmente vai falhar)
        try {
            const stringified = JSON.stringify(response);
            console.warn('[extractTextFromAIResponse] ⚠️ Had to stringify entire object:', stringified.substring(0, 200) + '...');
            return stringified;
        } catch {
            console.error('[extractTextFromAIResponse] ❌ Failed to stringify object');
            return String(response);
        }
    }
    
    console.warn('[extractTextFromAIResponse] ⚠️ Falling back to String conversion');
    return String(response);
}

function parseScenePromptsResponse(response) {
    let rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);

    if (!rawResponse || rawResponse.length === 0) {
        throw new Error('A resposta da IA veio vazia.');
    }

    console.log('[Scene Prompts Parser] Pré-processando resposta...');
    rawResponse = rawResponse
        .replace(/^```json\s*/i, '')
        .replace(/^```\s*/i, '')
        .replace(/\s*```\s*$/i, '')
        .trim();

    const sanitizeSceneArray = (scenes) => {
        if (!Array.isArray(scenes)) return [];
        return scenes
            .filter(scene => scene && (scene.prompt_text || scene.prompt || scene.text))
            .map((scene, index) => ({
                scene_number: scene.scene_number || scene.number || index + 1,
                scene_description: scene.scene_description || scene.description || `Cena ${scene.scene_number || scene.number || index + 1}`,
                prompt_text: scene.prompt_text || scene.prompt || scene.text || ''
            }));
    };

    const tryParseJson = (text) => {
        try {
            return JSON.parse(text);
        } catch {
            return null;
        }
    };

    let parsed = tryParseJson(rawResponse);
    if (parsed && parsed.scenes) {
        const scenes = sanitizeSceneArray(parsed.scenes);
        if (scenes.length > 0) return scenes;
    } else if (parsed && Array.isArray(parsed)) {
        const scenes = sanitizeSceneArray(parsed);
        if (scenes.length > 0) return scenes;
    }

    const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
        const cleaned = jsonMatch[0]
            .replace(/```json\s*/gi, '')
            .replace(/```\s*/g, '')
            .replace(/^[^{]*/, '')
            .replace(/[^}]*$/, '');

        parsed = tryParseJson(cleaned);
        if (parsed && parsed.scenes) {
            const scenes = sanitizeSceneArray(parsed.scenes);
            if (scenes.length > 0) return scenes;
        }
    }

    const scenesArrayMatch = rawResponse.match(/"scenes"\s*:\s*\[([\s\S]*?)\]/);
    if (scenesArrayMatch) {
        let scenesArrayStr = scenesArrayMatch[1];
        if (!scenesArrayStr.trim().endsWith('}')) {
            const sceneObjects = scenesArrayStr.match(/\{[^{}]*\}/g);
            if (sceneObjects && sceneObjects.length > 0) {
                scenesArrayStr = sceneObjects.join(',\n');
            }
        }

        const fallbackJson = tryParseJson(`{"scenes":[${scenesArrayStr}]}`);
        if (fallbackJson && fallbackJson.scenes) {
            const scenes = sanitizeSceneArray(fallbackJson.scenes);
            if (scenes.length > 0) return scenes;
        }
    }

    const scenePattern = /\{\s*"scene_number"\s*:\s*(\d+)[\s\S]*?"scene_description"\s*:\s*"([^"]*)"[\s\S]*?"prompt_text"\s*:\s*"([^"]*)"[\s\S]*?\}/g;
    const regexScenes = [];
    let match;
    while ((match = scenePattern.exec(rawResponse)) !== null) {
        regexScenes.push({
            scene_number: parseInt(match[1]),
            scene_description: match[2],
            prompt_text: match[3]
        });
    }
    if (regexScenes.length > 0) {
        console.log(`[Scene Prompts Parser] ✅ Extraídas ${regexScenes.length} cenas via regex padrão!`);
        return regexScenes;
    }

    const simpleScenePattern = /\{\s*"scene_number"\s*:\s*\d+[\s\S]*?\}/g;
    const simpleMatches = rawResponse.match(simpleScenePattern);
    if (simpleMatches && simpleMatches.length > 0) {
        const parsedScenes = [];
        simpleMatches.forEach((sceneStr, index) => {
            const sceneObject = tryParseJson(sceneStr);
            if (sceneObject && (sceneObject.prompt_text || sceneObject.prompt || sceneObject.text)) {
                parsedScenes.push({
                    scene_number: sceneObject.scene_number || sceneObject.number || index + 1,
                    scene_description: sceneObject.scene_description || sceneObject.description || `Cena ${sceneObject.scene_number || sceneObject.number || index + 1}`,
                    prompt_text: sceneObject.prompt_text || sceneObject.prompt || sceneObject.text || ''
                });
            }
        });
        if (parsedScenes.length > 0) {
            console.log(`[Scene Prompts Parser] ✅ Extraídas ${parsedScenes.length} cenas via fallback simples!`);
            return parsedScenes;
        }
    }

    throw new Error(`Não foi possível interpretar a resposta da IA como JSON válido. Conteúdo analisado (primeiros 500 chars): ${rawResponse.substring(0, 500)}`);
}

function buildScenePromptText({
    script,
    targetScenes,
    minScenes,
    maxScenes,
    wordCount,
    styleInstruction = '',
    imageModelInstruction = '',
    charactersInstruction = '',
    startSceneNumber = 1,
    isContinuation = false,
    previousScenes = []
}) {
    const previousSummary = previousScenes && previousScenes.length > 0
        ? `CENAS JÁ GERADAS (não repita):\n${previousScenes.slice(-5).map(scene => `- Cena ${scene.scene_number}: ${scene.scene_description}`).join('\n')}\n\n`
        : '';

    const continuationInstruction = isContinuation
        ? `Você já gerou ${startSceneNumber - 1} cenas. Continue a numeração a partir da cena ${startSceneNumber} e gere EXATAMENTE ${targetScenes} novas cenas sem repetir ou alterar as anteriores.\n`
        : `Divida o roteiro em aproximadamente ${targetScenes} cenas (entre ${minScenes} e ${maxScenes} cenas, se necessário).\n`;

    return `Você é um especialista em criação de prompts para geração de imagens usando IA.

${previousSummary}${continuationInstruction}
REGRAS IMPORTANTES:
1. Cada prompt deve ter entre 600-1200 caracteres.
2. Cada prompt deve ser em INGLÊS e otimizado para geração de imagens.
3. Seja específico e detalhado: descreva composição, iluminação, cores, atmosfera, personagens, cenário.
4. Use termos técnicos de fotografia/cinematografia quando apropriado.${styleInstruction}${imageModelInstruction}${charactersInstruction ? `\n${charactersInstruction}` : ''}
5. Os prompts devem ser fotorealísticos e cinematográficos, a menos que especificado outro estilo.
6. Se já existem cenas anteriores, continue a história sem repetir.

ROTEIRO:
"""
${script}
"""

FORMATO DE RESPOSTA (JSON):
{
  "scenes": [
    {
      "scene_number": ${startSceneNumber},
      "scene_description": "Breve descrição da cena em português",
      "prompt_text": "Prompt detalhado em inglês para geração de imagem"
    },
    ...
  ]
}

IMPORTANTE:
- Retorne APENAS o JSON, sem texto adicional.
- Gere EXATAMENTE ${targetScenes} novas cenas começando em ${startSceneNumber}.
- Continue a história exatamente do ponto onde parou, sem reiniciar a narrativa.
- Não repita cenas anteriores.`;
}

async function generateScenesWithRetries({
    apiFunc,
    apiKey,
    model,
    script,
    styleInstruction,
    imageModelInstruction,
    charactersInstruction,
    estimatedScenes,
    minScenes,
    maxScenes,
    wordCount,
    serviceLabel = 'AI',
    maxAttempts = 4
}) {
    let allScenes = [];
    let attempt = 0;
    let startSceneNumber = 1;
    let remainingScenes = estimatedScenes;

    while (remainingScenes > 0 && attempt < maxAttempts) {
        const targetScenes = remainingScenes;
        const prompt = buildScenePromptText({
            script,
            targetScenes,
            minScenes: Math.max(1, Math.min(minScenes, targetScenes)),
            maxScenes: Math.max(targetScenes, Math.min(maxScenes, targetScenes + 2)),
            wordCount,
            styleInstruction,
            imageModelInstruction,
            charactersInstruction,
            startSceneNumber,
            isContinuation: attempt > 0,
            previousScenes: allScenes
        });

        console.log(`[Scene Prompts][${serviceLabel}] Tentativa ${attempt + 1}: solicitando ${targetScenes} cenas (iniciando na cena ${startSceneNumber})`);

        const response = await apiFunc(prompt, apiKey, model);
        const parsedScenes = parseScenePromptsResponse(response);

        if (!parsedScenes || parsedScenes.length === 0) {
            console.warn(`[Scene Prompts][${serviceLabel}] Nenhuma cena retornada nesta tentativa.`);
            attempt++;
            continue;
        }

        const normalizedScenes = parsedScenes
            .map((scene, idx) => {
                const promptText = scene.prompt_text || scene.prompt || scene.text || '';
                if (!promptText.trim()) return null;
                return {
                    scene_number: startSceneNumber + idx,
                    scene_description: scene.scene_description || scene.description || `Cena ${startSceneNumber + idx}`,
                    prompt_text: promptText
                };
            })
            .filter(Boolean);

        if (normalizedScenes.length === 0) {
            console.warn(`[Scene Prompts][${serviceLabel}] As cenas retornadas estavam vazias.`);
            attempt++;
            continue;
        }

        allScenes = allScenes.concat(normalizedScenes);
        if (allScenes.length > estimatedScenes) {
            allScenes = allScenes.slice(0, estimatedScenes);
        }

        remainingScenes = estimatedScenes - allScenes.length;
        startSceneNumber = allScenes.length + 1;
        attempt++;
    }

    return allScenes;
}

function parseJSONFromString(text) {
    if (!text) return null;
    let cleaned = text.trim();
    cleaned = cleaned.replace(/^```json/i, '').replace(/^```/, '').replace(/```$/g, '').trim();
    
    try {
        return JSON.parse(cleaned);
    } catch (err) {
        const match = cleaned.match(/\{[\s\S]*\}/);
        if (match) {
            try {
                return JSON.parse(match[0]);
            } catch (innerErr) {
                return null;
            }
        }
        return null;
    }
}

/**
 * Chama a API do provedor externo
 */
async function callLaozhangAPI(prompt, apiKey, model = null, imageUrl = null, userId = null, operationType = 'api_call', details = null) {
    if (!apiKey) throw new Error("Chave de API do provedor externo não configurada.");
    
    // Endpoint oficial documentado (compatível com OpenAI)
    const possibleEndpoints = [LAOZHANG_CHAT_ENDPOINT];
    
    // Detectar se é pedido de roteiro (texto puro) ou JSON
    const isScriptRequest = typeof prompt === 'string' && (
        prompt.includes('RESPOSTA FINAL - CRÍTICO') ||
        prompt.includes('roteiro em TEXTO SIMPLES') ||
        prompt.includes('NÃO use JSON')
    );
    
    // Calcular tokens aproximados (input + output estimado)
    const promptTokens = Math.ceil((typeof prompt === 'string' ? prompt.length : JSON.stringify(prompt).length) / 4);
    // Para roteiros longos, estimar mais tokens de saída baseado no número de partes
    let estimatedOutputTokens = 2000; // Estimativa conservadora padrão
    if (isScriptRequest) {
        if (prompt.includes('partes')) {
            const partsMatch = prompt.match(/dividido em.*?(\d+).*?partes/i) || prompt.match(/EXATAMENTE (\d+) PARTES/i);
            const numParts = partsMatch ? parseInt(partsMatch[1]) : 1;
            // Estimativa: ~450 palavras por parte × 1.3 tokens por palavra × número de partes
            estimatedOutputTokens = Math.min(12000, Math.ceil(450 * 1.3 * numParts)); // Máximo 12000 tokens
            console.log(`[API] Estimativa de tokens de saída para ${numParts} partes: ${estimatedOutputTokens}`);
        } else if (operationType && operationType.includes('viral_agent')) {
            // Para agentes virais, estimar tokens baseado no max_tokens (geralmente 8192)
            // Usar 80% do max_tokens como estimativa conservadora
            estimatedOutputTokens = 6554; // ~80% de 8192
            console.log(`[API] Estimativa de tokens para agente viral: ${estimatedOutputTokens}`);
        }
    }
    const totalTokens = promptTokens + estimatedOutputTokens;
    
    // Debitar créditos ANTES da chamada se userId fornecido
    let creditDebitResult = null;
    if (userId) {
        try {
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (laozhangProviderId) {
                creditDebitResult = await checkAndDebitCredits(
                    userId,
                    laozhangProviderId,
                    totalTokens,
                    operationType,
                    details || JSON.stringify({ model: model || 'gpt-4o', service: 'laozhang' })
                );
                console.log(`[API] 💰 Créditos debitados: ${creditDebitResult.creditsUsed.toFixed(4)}, Novo saldo: ${creditDebitResult.newBalance.toFixed(4)}`);
            }
        } catch (creditError) {
            console.error('[API] ❌ Erro ao debitar créditos:', creditError.message);
            // Se não tiver créditos suficientes, lançar erro
            if (creditError.message.includes('Créditos insuficientes')) {
                throw creditError;
            }
            // Se for outro erro, continuar mas logar
        }
    }
    
    const payload = {
        model: model || 'gpt-4o',
        messages: [
            {
                role: 'system',
                content: isScriptRequest 
                    ? "Você é um roteirista profissional. Responda APENAS com o texto do roteiro, sem usar JSON, objetos ou formatações especiais. Escreva texto corrido e natural."
                    : "Responda APENAS com o objeto JSON solicitado, começando com { e terminando com }."
            },
            {
                role: 'user',
                content: prompt
            }
        ],
        temperature: 0.7,
        max_tokens: isScriptRequest ? 16384 : 16384  // Usar 16384 tokens (limite seguro da API Laozhang)
    };
    
    // Tentar diferentes endpoints até encontrar um que funcione
    let lastError = null;
    for (const endpoint of possibleEndpoints) {
        try {
            console.log(`[API] Tentando endpoint: ${endpoint}`);
            const controller = new AbortController();
            // Timeout dinâmico baseado no tipo de requisição: roteiros longos precisam de mais tempo
            // Para roteiros: 10 minutos base + 1 minuto por parte (mínimo 5 minutos, máximo 20 minutos)
            const isLongScript = isScriptRequest && prompt.includes('partes');
            // Aumentar timeout padrão para 5 minutos (300000ms) para dar mais tempo à API
            let timeoutDuration = 300000; // 5 minutos padrão (aumentado de 3 minutos)
            
            // Detectar se é requisição de scene prompts ou outras operações que podem demorar
            const isScenePrompts = operationType && operationType.includes('scene-prompts');
            const isViralAgent = operationType && operationType.includes('viral_agent');
            
            if (isLongScript) {
                // Tentar extrair número de partes do prompt
                const partsMatch = prompt.match(/dividido em.*?(\d+).*?partes/i) || prompt.match(/EXATAMENTE (\d+) PARTES/i);
                const numParts = partsMatch ? parseInt(partsMatch[1]) : 1;
                timeoutDuration = Math.min(1200000, Math.max(300000, 600000 + (numParts * 60000))); // 5-20 minutos
                console.log(`[API] Timeout ajustado para ${timeoutDuration / 1000 / 60} minutos (${numParts} partes)`);
            } else if (isScenePrompts || isViralAgent || isScriptRequest) {
                // Para scene prompts, agentes virais e roteiros, usar 8 minutos
                timeoutDuration = 480000; // 8 minutos
                console.log(`[API] Timeout ajustado para ${timeoutDuration / 1000 / 60} minutos (${isScenePrompts ? 'scene prompts' : isViralAgent ? 'agente viral' : 'roteiro'})`);
            }
            const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);
            
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'Accept': 'application/json'
                },
                body: JSON.stringify(payload),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                const errorText = await response.text().catch(() => response.statusText);
                console.warn(`[API] Endpoint ${endpoint} retornou erro ${response.status}:`, errorText.substring(0, 500));
                
                // Tentar parsear o erro JSON para mais detalhes
                let errorDetails = errorText;
                try {
                    const errorJson = JSON.parse(errorText);
                    if (errorJson.error) {
                        errorDetails = JSON.stringify(errorJson.error);
                        console.error(`[API] Detalhes do erro:`, errorJson.error);
                    }
                } catch (e) {
                    // Não é JSON, usar texto direto
                }
                
                lastError = new Error(`Erro ${response.status}: ${errorDetails.substring(0, 200)}`);
                continue; // Tentar próximo endpoint
            }
            
            const result = await response.json();
            console.log(`[API] ✅ Sucesso com endpoint: ${endpoint}`);
            console.log('[API] Estrutura da resposta:', JSON.stringify(result).substring(0, 300));
            
            // Se tiver informações de uso de tokens na resposta, ajustar créditos
            if (userId && creditDebitResult && result.usage) {
                const actualTokens = (result.usage.prompt_tokens || promptTokens) + (result.usage.completion_tokens || estimatedOutputTokens);
                const actualCredits = (actualTokens / 1000) * (creditDebitResult.creditsUsed / (totalTokens / 1000));
                const difference = actualCredits - creditDebitResult.creditsUsed;
                
                if (Math.abs(difference) > 0.01) { // Ajustar apenas se diferença > 0.01 créditos
                    try {
                        const laozhangProviderId = await getLaozhangApiProviderId();
                        if (laozhangProviderId) {
                            // Ajustar saldo do usuário
                            await db.run(`
                                UPDATE user_credits 
                                SET balance = balance + ?, updated_at = CURRENT_TIMESTAMP 
                                WHERE user_id = ?
                            `, [creditDebitResult.creditsUsed - actualCredits, userId]);
                            
                            // Atualizar registro de uso
                            await db.run(`
                                UPDATE credit_usage 
                                SET credits_used = ?, units_consumed = ?
                                WHERE id = (SELECT id FROM credit_usage WHERE user_id = ? AND api_provider_id = ? ORDER BY id DESC LIMIT 1)
                            `, [actualCredits, actualTokens, userId, laozhangProviderId]);
                            
                            console.log(`[API] 💰 Créditos ajustados: ${difference > 0 ? '+' : ''}${difference.toFixed(4)}`);
                        }
                    } catch (adjustError) {
                        console.error('[API] ⚠️ Erro ao ajustar créditos:', adjustError.message);
                    }
                }
            }
            
            if (result.choices && result.choices[0] && result.choices[0].message) {
                const content = result.choices[0].message.content;
                
                console.log('[API] Resposta recebida (primeiros 200 chars):', content.substring(0, 200));
                
                if (isScriptRequest) {
                    console.log('[API] Retornando texto puro de script');
                    return content; // Retorna string diretamente
                } else {
                    // Para requisições JSON, retornar o conteúdo diretamente
                    return content;
                }
            } else if (result.content) {
                // Algumas APIs retornam content diretamente
                const content = typeof result.content === 'string' ? result.content : JSON.stringify(result.content);
                console.log('[API] Resposta recebida (formato alternativo)');
                return content;
            } else {
                console.warn(`[API] Estrutura de resposta inesperada em ${endpoint}:`, JSON.stringify(result).substring(0, 500));
                lastError = new Error('Estrutura de resposta inesperada');
                continue; // Tentar próximo endpoint
            }
        } catch (error) {
            // Se a chamada falhou e já debitamos créditos, reembolsar
            if (userId && creditDebitResult) {
                try {
                    await refundCredits(userId, creditDebitResult.creditsUsed, 'Erro ao processar solicitação');
                    console.log(`[API] 💰 Créditos reembolsados: ${creditDebitResult.creditsUsed.toFixed(4)}`);
                } catch (refundError) {
                    console.error('[API] ⚠️ Erro ao reembolsar créditos:', refundError.message);
                }
            }
            
            // Tratar erros de abort (timeout)
            if (error.name === 'AbortError') {
                console.error(`[API] ⏱️ Timeout após ${timeoutDuration / 1000 / 60} minutos ao tentar endpoint ${endpoint}`);
                lastError = new Error(`Timeout: A requisição demorou mais de ${timeoutDuration / 1000 / 60} minutos. Tente novamente ou use uma requisição menor.`);
                // Se não for o último endpoint, tentar próximo
                if (endpoint !== possibleEndpoints[possibleEndpoints.length - 1]) {
                    console.warn(`[API] Tentando próximo endpoint...`);
                    continue;
                }
                break; // Se for o último endpoint, sair do loop
            }
            
            // Tratar outros erros
            console.warn(`[API] Erro ao tentar endpoint ${endpoint}:`, error.message);
            lastError = error;
            // Se não for o último endpoint, tentar próximo
            if (endpoint !== possibleEndpoints[possibleEndpoints.length - 1]) {
                continue; // Tentar próximo endpoint
            }
        }
    }
    
    // Se chegou aqui, nenhum endpoint funcionou
    console.error('[API] ❌ Todos os endpoints falharam');
    throw lastError || new Error('Falha ao chamar a API: nenhum endpoint funcionou');
}

async function getPreferredAIProvider(userId, preferenceOrder = ['claude', 'openai', 'gemini']) {
    const defaultModels = {
        claude: 'claude-3-7-sonnet-20250219',  // Claude 3.7 Sonnet (Fev/2025)
        openai: 'gpt-4o',                       // GPT-4o (2025)
        gemini: 'gemini-2.5-pro',               // Gemini 2.5 Pro (2025)
        laozhang: 'gpt-4o'                      // Laozhang.ai (usa GPT-4o como padrão)
    };

    // PRIMEIRO: Verificar se laozhang.ai está configurada como padrão no admin
    try {
        const laozhangDefaultSetting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
        console.log('[AI Provider] Verificando configuração padrão:', laozhangDefaultSetting);
        
        let laozhangUseAsDefault = false;
        if (laozhangDefaultSetting) {
            try {
                const parsedValue = JSON.parse(laozhangDefaultSetting.value);
                laozhangUseAsDefault = parsedValue === true || parsedValue === 'true' || parsedValue === 1;
            } catch (e) {
                // Se não for JSON, verificar como string
                laozhangUseAsDefault = laozhangDefaultSetting.value === 'true' || laozhangDefaultSetting.value === '1';
            }
        }
        
        console.log('[AI Provider] laozhangUseAsDefault:', laozhangUseAsDefault);
        
        if (laozhangUseAsDefault) {
            const laozhangKey = await getLaozhangApiKey();
            console.log('[AI Provider] Chave de API encontrada:', laozhangKey ? 'Sim' : 'Não');
            if (laozhangKey) {
                console.log('[AI Provider] ✅ Usando API configurada como padrão (configuração do admin)');
                return {
                    service: 'laozhang',
                    apiKey: laozhangKey,
                    model: defaultModels.laozhang
                };
            } else {
                console.warn('[AI Provider] ⚠️ API configurada como padrão mas chave não encontrada');
            }
        } else {
            console.log('[AI Provider] Laozhang.ai não está configurada como padrão');
        }
    } catch (err) {
        console.error('[AI Provider] ❌ Erro ao verificar configuração padrão Laozhang.ai:', err.message);
    }

    // SEGUNDO: Verificar se deve usar créditos (laozhang.ai)
    // REGRA: Usa créditos se usuário marcou preferência OU não tem API própria configurada
    try {
        const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
        
        if (creditsCheck.shouldUse) {
            // Se deve usar créditos, usar laozhang.ai
            const laozhangKey = await getLaozhangApiKey();
            if (laozhangKey) {
                console.log(`[AI Provider] ✅ Usando Laozhang.ai (${creditsCheck.reason})`);
                return {
                    service: 'laozhang',
                    apiKey: laozhangKey,
                    model: defaultModels.laozhang
                };
            } else {
                console.warn('[AI Provider] ⚠️ Laozhang.ai não configurada, tentando usar APIs próprias do usuário');
            }
        } else {
            console.log(`[AI Provider] ✅ Usando API própria (${creditsCheck.reason})`);
        }
    } catch (err) {
        console.warn('[AI Provider] Erro ao verificar uso de créditos:', err.message);
    }

    // TERCEIRO: Se não usar laozhang.ai, usar APIs próprias do usuário
    for (const service of preferenceOrder) {
        try {
            const keyData = await db.get(
                'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                [userId, service]
            );
            if (keyData) {
                const decryptedKey = decrypt(keyData.api_key);
                if (decryptedKey) {
                    return {
                        service,
                        apiKey: decryptedKey,
                        model: defaultModels[service] || 'gemini-2.0-flash'
                    };
                }
            }
        } catch (err) {
            console.warn(`[AI Provider] Erro ao buscar chave ${service}:`, err.message);
        }
    }
    return null;
}

async function analyzeTranscriptForVirality({ userId, transcript, videoTitle, niche, subniche }) {
    const provider = await getPreferredAIProvider(userId, ['claude', 'openai', 'gemini']);
    if (!provider) {
        throw new Error('Configure uma chave do Claude, OpenAI ou Gemini para gerar a análise do roteiro.');
    }

    const sanitizedTranscript = transcript.trim();
    const truncatedTranscript = sanitizedTranscript.length > 20000
        ? `${sanitizedTranscript.substring(0, 20000)}\n[... conteúdo truncado para análise ...]`
        : sanitizedTranscript;

    const analysisPrompt = `
Você é um ESTRATEGISTA DE CONTEÚDO para YouTube. Analise profundamente o roteiro abaixo e explique POR QUE ele viralizou.

Retorne APENAS um JSON válido no formato:
{
  "resumo": "síntese em 2-3 frases",
  "motivosVirais": ["motivo 1", "motivo 2", "..."],
  "gatilhosEmocionais": ["gatilho 1", "..."],
  "estruturaNarrativa": [
    { "etapa": "Nome curto", "descricao": "O que acontece nessa parte", "tempoAproximado": "0:00-0:45" }
  ],
  "formulaChecklist": [
    {
      "item": "Elemento da fórmula",
      "status": "aplicado" ou "melhorar",
      "porqueFunciona": "Explicação curta",
      "comoAplicarNoMeuConteudo": "Diretriz prática",
      "upgradeSugerido": "Ajuste para ficar 10/10"
    }
  ],
  "diferencialProposto": "Diferencial para deixar ainda melhor",
  "sugestoesAplicacao": ["ação 1", "ação 2"],
  "alertas": ["possíveis riscos ou pontos de atenção"]
}

Regras:
- Idioma: português do Brasil.
- Não copie trechos do roteiro; descreva a fórmula e o raciocínio.
- Mostre como replicar a estrutura sem plagiar.
- Foque em transformar os aprendizados em um checklist acionável.

Contexto do vídeo:
- Título: ${videoTitle || 'N/A'}
- Nicho: ${niche || 'N/A'}
- Subnicho: ${subniche || 'N/A'}

ROTEIRO COMPLETO:
"""${truncatedTranscript}"""`;

    let aiResponse;
        if (provider.service === 'laozhang') {
            aiResponse = await callLaozhangAPI(
                analysisPrompt, 
                provider.apiKey, 
                provider.model, 
                null, 
                userId, 
                'api_call', 
                JSON.stringify({ endpoint: '/api/scripts/generate', model: provider.model })
            );
        // callLaozhangAPI retorna string diretamente
        const responseText = typeof aiResponse === 'string' ? aiResponse : JSON.stringify(aiResponse);
        const parsed = parseJSONFromString(responseText);
        if (!parsed) {
            throw new Error('A IA retornou um formato inválido na análise do roteiro.');
        }
        return { analysis: parsed, provider: provider.service };
    } else if (provider.service === 'claude') {
        aiResponse = await callClaudeAPI(analysisPrompt, provider.apiKey, provider.model);
    } else if (provider.service === 'openai') {
        aiResponse = await callOpenAIAPI(analysisPrompt, provider.apiKey, provider.model);
    } else {
        aiResponse = await callGeminiAPI(analysisPrompt, provider.apiKey, provider.model);
    }

    const parsed = parseJSONFromString(extractTextFromAIResponse(aiResponse));
    if (!parsed) {
        throw new Error('A IA retornou um formato inválido na análise do roteiro.');
    }

    return { analysis: parsed, provider: provider.service };
}


// --- FUNÇÕES AUXILIARES DE VALIDAÇÃO DE CHAVE ---

async function validateGeminiKey(apiKey) {
    try {
        // Tentar primeiro com API do Gemini (generativelanguage.googleapis.com)
        // Para chaves de API do Gemini diretas
        try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${encodeURIComponent(apiKey)}`);
            if (response.status === 200) {
                const data = await response.json();
                if (data.models && data.models.length > 0) {
                    return { success: true, type: 'gemini-api' };
                }
            }
            const error = await response.json().catch(() => ({}));
            // Se der erro específico sobre API keys não suportadas, tentar Vertex AI
            if (error.error?.message && error.error.message.includes('API keys are not supported')) {
                console.log('[Validação Gemini] Chave é do Google Cloud (Vertex AI), não API key direta');
                // Continuar para validar como Google Cloud
            } else {
                return { success: false, error: error.error?.message || 'Chave inválida ou sem modelos acessíveis.' };
            }
        } catch (geminiErr) {
            console.log('[Validação Gemini] Erro ao validar como API direta, tentando Google Cloud...');
        }
        
        // Tentar validar como chave do Google Cloud
        // Chaves do Google Cloud podem ser usadas para:
        // 1. Google Cloud Text-to-Speech (já implementado)
        // 2. Outros serviços do Google Cloud
        // Nota: Vertex AI geralmente requer OAuth2, mas a chave pode ser válida para outros serviços
        try {
            // Validar usando Google Cloud Text-to-Speech API (que já estamos usando)
            // Se a chave funcionar para TTS, ela é válida para serviços do Google Cloud
            const ttsResponse = await fetch(`https://texttospeech.googleapis.com/v1/voices?key=${encodeURIComponent(apiKey)}&languageCode=pt-BR`);
            
            if (ttsResponse.status === 200) {
                const ttsData = await ttsResponse.json();
                if (ttsData.voices && ttsData.voices.length > 0) {
                    return { 
                        success: true, 
                        type: 'google-cloud', 
                        message: 'Chave do Google Cloud válida. Pode ser usada para Text-to-Speech e outros serviços do Google Cloud.'
                    };
                }
            } else if (ttsResponse.status === 401 || ttsResponse.status === 403) {
                const ttsError = await ttsResponse.json().catch(() => ({}));
                // Se a mensagem menciona que a API não está habilitada, a chave é válida mas precisa habilitar a API
                if (ttsError.error?.message && ttsError.error.message.includes('API has not been used')) {
                    return { 
                        success: true, 
                        type: 'google-cloud', 
                        message: 'Chave do Google Cloud válida. Habilite a API Text-to-Speech no Google Cloud Console para usar TTS.',
                        warning: 'A API Text-to-Speech precisa ser habilitada no Google Cloud Console.'
                    };
                }
                return { success: false, error: ttsError.error?.message || 'Chave inválida ou sem permissão para Text-to-Speech.' };
            } else {
                const ttsError = await ttsResponse.json().catch(() => ({}));
                return { success: false, error: ttsError.error?.message || 'Erro ao validar chave do Google Cloud.' };
            }
        } catch (cloudErr) {
            // Se ambos falharem, mas a chave parece ser do Google Cloud (baseado no erro original)
            // Retornar como válida mas com aviso
            console.log('[Validação Gemini] Erro ao validar Google Cloud:', cloudErr.message);
            return { 
                success: true, 
                type: 'google-cloud', 
                message: 'Chave do Google Cloud detectada. Pode ser usada para serviços do Google Cloud.',
                warning: 'Validação completa não foi possível. Certifique-se de que as APIs necessárias estão habilitadas no Google Cloud Console.'
            };
        }
    } catch (err) {
        return { success: false, error: err.message };
    }
}

async function validateOpenAIKey(apiKey) {
    try {
        const response = await fetch('https://api.openai.com/v1/models', {
            headers: { 'Authorization': `Bearer ${apiKey}` }
        });
        if (response.status === 200) return { success: true };
        const error = await response.json();
        return { success: false, error: error.error?.message || 'Chave inválida' };
    } catch (err) {
        return { success: false, error: err.message };
    }
}

async function validateClaudeKey(apiKey) {
    try {
        const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: { 
                'x-api-key': apiKey, 
                'anthropic-version': '2023-06-01',
                'content-type': 'application/json'
            },
            body: JSON.stringify({
                model: "claude-3-5-haiku-20241022", // Usar um modelo válido mais recente para validação
                max_tokens: 10,
                messages: [{ role: "user", content: "Test" }]
            })
        });
        
        const data = await response.json();

        if (response.status === 200) {
            return { success: true };
        } 
        else if (response.status === 401 || response.status === 403) {
            return { success: false, error: data.error?.type || 'Chave inválida (auth)' };
        } 
        else if (response.status === 400 && data.error?.type === 'invalid_request_error') {
            // Claude pode retornar 400 para 'invalid_request_error' mesmo com chave válida se o prompt for muito curto,
            // mas a chave em si é válida. Consideramos sucesso para validação da chave.
            return { success: true }; 
        }
        else {
            return { success: false, error: data.error?.type || `Erro ${response.status}` };
        }
    } catch (err) {
        return { success: false, error: err.message };
    }
}

async function validateYouTubeKey(apiKey) {
    try {
        // Testar a chave fazendo uma requisição simples de busca
        const response = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=1&q=test&type=video&key=${apiKey}`);
        
        if (response.status === 200) {
            return { success: true };
        }
        
        // Verificar erros específicos
        const data = await response.json();
        
        if (response.status === 400 && data.error?.errors?.[0]?.reason === 'keyInvalid') {
            return { success: false, error: 'Chave de API inválida' };
        }
        
        if (response.status === 403 && data.error?.errors?.[0]?.reason === 'quotaExceeded') {
            // Se a cota foi excedida, a chave é válida mas sem créditos
            return { success: true };
        }
        
        return { success: false, error: data.error?.message || 'Chave inválida' };
    } catch (err) {
        return { success: false, error: err.message };
    }
}


// --- MIDDLEWARE DE AUTENTICAÇÃO ---
const authenticateToken = (req, res, next) => {
    // Verificar se o banco de dados está inicializado
    if (!db) {
        return res.status(503).json({ msg: 'Servidor ainda não está pronto. Aguarde alguns instantes e tente novamente.' });
    }
    
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token == null) {
        return res.status(401).json({ msg: 'Token não fornecido.' });
    }

    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).json({ msg: 'Token inválido ou expirado.' });
        }
        req.user = user;
        next();
    });
};

const isAdmin = (req, res, next) => {
    if (!req.user || !req.user.isAdmin) {
        return res.status(403).json({ msg: 'Acesso negado. Requer privilégios de administrador.' });
    }
    next();
};

// ================================================
// SISTEMA DE CRÉDITOS - FUNÇÕES PRINCIPAIS
// ================================================

/**
 * Obtém a API padrão do admin (para uso com créditos)
 */
const getDefaultAdminApi = async () => {
    try {
        // Buscar API padrão ativa
        let api = await db.get(`
            SELECT * FROM api_providers 
            WHERE is_active = 1 AND is_default = 1
            LIMIT 1
        `);
        
        if (api) {
            return api;
        }
        
        // Se não tem padrão, buscar primeira API ativa
        api = await db.get(`
            SELECT * FROM api_providers 
            WHERE is_active = 1
            ORDER BY id ASC
            LIMIT 1
        `);
        
        return api || null;
    } catch (error) {
        console.error('❌ Erro ao buscar API padrão do admin:', error);
        return null;
    }
};

// Função para buscar chave de voz configurada no admin
const getAdminVoiceApiKey = async () => {
    try {
        const setting = await db.get(`
            SELECT value FROM app_settings 
            WHERE key = 'voice_api_key'
        `);
        
        if (setting && setting.value) {
            let apiKey = setting.value;
            
            // Tentar parsear como JSON (caso tenha sido salvo como JSON)
            try {
                const parsed = JSON.parse(setting.value);
                // Se o resultado do parse for uma string, usar ela
                if (typeof parsed === 'string') {
                    apiKey = parsed;
                }
            } catch (parseError) {
                // Se não for JSON, usar diretamente (já é string)
                apiKey = setting.value;
            }
            
            // Remover aspas extras se houver (caso tenha sido salvo como JSON string)
            if (apiKey.startsWith('"') && apiKey.endsWith('"')) {
                apiKey = apiKey.slice(1, -1);
            }
            
            // Validar se não está vazia
            if (apiKey && apiKey.trim().length > 0) {
                console.log('[getAdminVoiceApiKey] ✅ Chave encontrada (tamanho:', apiKey.length, 'caracteres)');
                return apiKey.trim();
            } else {
                console.log('[getAdminVoiceApiKey] ⚠️ Chave encontrada mas está vazia');
                return null;
            }
        }
        
        console.log('[getAdminVoiceApiKey] ❌ Nenhuma chave de voz encontrada no admin');
        return null;
    } catch (error) {
        console.error('Erro ao buscar chave de voz do admin:', error);
        return null;
    }
};

const normalizeAppSettingKey = (value) => {
    if (value === null || value === undefined) return null;
    let key = String(value);
    if (key.startsWith('"') && key.endsWith('"')) {
        key = key.slice(1, -1);
    }
    key = key.trim();
    return key.length >= 10 ? key : null;
};

const getAdminOpenAiVoiceApiKey = async () => {
    try {
        const setting = await db.get("SELECT value FROM app_settings WHERE key = 'openai_voice_api_key'");
        if (setting && setting.value) {
            let apiKey = setting.value;
            try {
                const parsed = JSON.parse(setting.value);
                if (typeof parsed === 'string') apiKey = parsed;
            } catch {
                apiKey = setting.value;
            }
            apiKey = normalizeAppSettingKey(apiKey);
            if (apiKey) {
                console.log('[getAdminOpenAiVoiceApiKey] ✅ Chave encontrada no admin');
                return apiKey;
            }
        }
        return null;
    } catch (error) {
        console.error('[getAdminOpenAiVoiceApiKey] ❌ Erro ao buscar chave OpenAI:', error);
        return null;
    }
};

const getAdminVideoApiKey = async () => {
    try {
        const setting = await db.get("SELECT value FROM app_settings WHERE key = 'video_api_key'");
        if (setting && setting.value) {
            let apiKey = setting.value;
            try {
                const parsed = JSON.parse(setting.value);
                if (typeof parsed === 'string') apiKey = parsed;
            } catch {
                apiKey = setting.value;
            }
            apiKey = normalizeAppSettingKey(apiKey);
            if (apiKey) {
                console.log('[getAdminVideoApiKey] ✅ Chave de vídeo encontrada no admin');
                return apiKey;
            }
        }
        return null;
    } catch (error) {
        console.error('[getAdminVideoApiKey] ❌ Erro ao buscar chave de vídeo:', error);
        return null;
    }
};

const cacheVideoOperationMetadata = async (operationId, userId, meta = {}) => {
    try {
        await db.run(`
            INSERT OR REPLACE INTO video_operations_cache (
                operation_id,
                user_id,
                api_key_source,
                user_key_id,
                admin_api_id,
                use_laozhang
            ) VALUES (?, ?, ?, ?, ?, ?)
        `, [
            operationId,
            userId,
            meta.apiKeySource || 'unknown',
            meta.userKeyId || null,
            meta.adminApiId || null,
            meta.useLaozhang ? 1 : 0
        ]);
        console.log('[VideoCache] Operação registrada:', operationId, meta.apiKeySource);
    } catch (error) {
        console.error('[VideoCache] Erro ao salvar operação:', error.message);
    }
};

const removeVideoOperationCache = async (operationId) => {
    try {
        await db.run('DELETE FROM video_operations_cache WHERE operation_id = ?', [operationId]);
    } catch (error) {
        console.error('[VideoCache] Erro ao remover operação:', error.message);
    }
};

const resolveCachedVideoApiKey = async (cacheRow) => {
    try {
        switch (cacheRow.api_key_source) {
            case 'panel_video':
                return await getAdminVideoApiKey();
            case 'user_gemini':
                if (!cacheRow.user_key_id) return null;
                const userKey = await db.get('SELECT api_key FROM user_api_keys WHERE id = ?', [cacheRow.user_key_id]);
                if (!userKey || !userKey.api_key) return null;
                if (userKey.api_key.includes(':')) {
                    try {
                        return decrypt(userKey.api_key);
                    } catch (err) {
                        console.warn('[VideoCache] Erro ao descriptografar chave do usuário:', err.message);
                        return userKey.api_key;
                    }
                }
                return userKey.api_key;
            case 'admin_provider':
                if (!cacheRow.admin_api_id) return null;
                const adminProvider = await db.get('SELECT * FROM api_providers WHERE id = ?', [cacheRow.admin_api_id]);
                if (!adminProvider || !adminProvider.api_key) return null;
                if (adminProvider.api_key.includes(':')) {
                    try {
                        return decrypt(adminProvider.api_key);
                    } catch (err) {
                        console.warn('[VideoCache] Erro ao descriptografar chave do admin provider:', err.message);
                        return adminProvider.api_key;
                    }
                }
                return adminProvider.api_key;
            case 'laozhang':
                return await getLaozhangApiKey();
            default:
                return null;
        }
    } catch (error) {
        console.error('[VideoCache] Erro ao resolver chave para operação:', cacheRow.operation_id, error.message);
        return null;
    }
};

const rehydratePendingVideoOperations = async () => {
    try {
        const pending = await db.all('SELECT * FROM video_operations_cache');
        if (!pending || pending.length === 0) {
            console.log('[VideoCache] Nenhuma operação pendente para reidratar.');
            return;
        }
        
        console.log(`[VideoCache] Reidratando ${pending.length} operação(ões) de vídeo pendentes...`);
        for (const row of pending) {
            const apiKey = await resolveCachedVideoApiKey(row);
            if (!apiKey) {
                console.warn('[VideoCache] Não foi possível recuperar chave para operação:', row.operation_id);
                continue;
            }
            
            const operationData = {
                userId: row.user_id,
                operation: { name: row.operation_id },
                status: 'processing',
                useAdminApi: row.api_key_source === 'admin_provider',
                adminApi: null,
                useLaozhang: row.use_laozhang === 1
            };
            
            if (row.admin_api_id) {
                operationData.adminApi = await db.get('SELECT * FROM api_providers WHERE id = ?', [row.admin_api_id]);
            }
            
            videoOperations.set(row.operation_id, operationData);
            pollVideoOperation(row.operation_id, apiKey);
        }
    } catch (error) {
        console.error('[VideoCache] Erro ao reidratar operações pendentes:', error.message);
    }
};

/**
 * Obtém a chave da API Laozhang.ai das configurações da aplicação
 */
const getLaozhangApiKey = async () => {
    try {
        const setting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_api_key'");
        if (setting && setting.value) {
            try {
                const parsed = JSON.parse(setting.value);
                // Se for objeto, extrair api_key se existir, senão retornar o objeto
                if (typeof parsed === 'object' && parsed !== null) {
                    if (parsed.api_key) {
                        return parsed.api_key;
                    } else if (parsed.key) {
                        return parsed.key;
                    } else {
                        // Se for objeto sem api_key, tentar converter para string
                        return JSON.stringify(parsed);
                    }
                }
                return parsed;
            } catch (e) {
                // Se não for JSON, retornar como string
                const value = String(setting.value).trim();
                if (value && value.length > 10) {
                    return value;
                }
                return null;
            }
        }
        return null;
    } catch (error) {
        console.error('❌ Erro ao buscar chave Laozhang.ai:', error);
        return null;
    }
};

/**
 * Obtém o ID do provider Laozhang.ai da tabela api_providers
 */
const getLaozhangApiProviderId = async () => {
    try {
        const provider = await db.get("SELECT id FROM api_providers WHERE provider = 'laozhang' AND is_active = 1 LIMIT 1");
        if (provider) {
            return provider.id;
        }
        // Se não existir, criar um provider padrão para Laozhang
        const result = await db.run(`
            INSERT INTO api_providers (
                name, provider, model, api_key, unit_type, unit_size,
                real_cost_per_unit, credits_per_unit, markup, is_premium,
                is_active, is_default
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
            'Laozhang.ai', 'laozhang', 'gpt-4o', '', 'tokens', 1000,
            0.0, 1.0, 1.0, 0, 1, 0
        ]);
        return result.lastID;
    } catch (error) {
        console.error('❌ Erro ao buscar/criar provider Laozhang.ai:', error);
        return null;
    }
};

/**
 * Determina se deve usar créditos (laozhang.ai) ou API própria
 * REGRA: Usa créditos se:
 * 1. Usuário marcou preferência para usar créditos, OU
 * 2. Usuário NÃO tem API própria configurada
 * 
 * @param {number} userId - ID do usuário
 * @param {string[]} services - Lista de serviços para verificar (ex: ['claude', 'openai', 'gemini'])
 * @returns {Promise<{shouldUse: boolean, reason: string, hasOwnApi: boolean, hasPreference: boolean}>}
 */
async function shouldUseCredits(userId, services = ['claude', 'openai', 'gemini']) {
    try {
        // Verificar preferência do usuário
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
        const hasPreference = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // Verificar se usuário tem API própria configurada
        let hasOwnApi = false;
        for (const service of services) {
            try {
                const keyData = await db.get(
                    'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                    [userId, service]
                );
                if (keyData && keyData.api_key) {
                    const decryptedKey = decrypt(keyData.api_key);
                    if (decryptedKey && decryptedKey.trim().length > 0) {
                        hasOwnApi = true;
                        break;
                    }
                }
            } catch (err) {
                // Ignorar erros individuais
            }
        }
        
        // REGRA: Usa créditos se tem preferência OU não tem API própria
        const shouldUse = hasPreference || !hasOwnApi;
        
        const reason = hasPreference 
            ? 'Preferência do usuário marcada para usar créditos'
            : !hasOwnApi 
                ? 'Usuário não tem API própria configurada'
                : 'Usuário tem API própria e não marcou preferência';
        
        console.log(`[shouldUseCredits] userId: ${userId}, shouldUse: ${shouldUse}, reason: ${reason}, hasOwnApi: ${hasOwnApi}, hasPreference: ${hasPreference}`);
        
        return {
            shouldUse,
            reason,
            hasOwnApi,
            hasPreference
        };
    } catch (error) {
        console.error('[shouldUseCredits] Erro:', error);
        // Em caso de erro, por padrão usar créditos (mais seguro)
        return {
            shouldUse: true,
            reason: 'Erro ao verificar configurações, usando créditos por padrão',
            hasOwnApi: false,
            hasPreference: false
        };
    }
}

/**
 * Verifica e debita créditos do usuário
 */
const checkAndDebitCredits = async (userId, apiProviderId, unitsConsumed, operationType = 'api_call', details = null) => {
    try {
        // Obter informações da API
        const apiProvider = await db.get(`
            SELECT credits_per_unit, unit_type, unit_size, name 
            FROM api_providers 
            WHERE id = ? AND is_active = 1
        `, [apiProviderId]);

        if (!apiProvider) {
            throw new Error('API provider não encontrada ou inativa');
        }

        // Aplicar multiplicador TTS se for operação de TTS
        let creditsPerUnit = apiProvider.credits_per_unit;
        if (operationType && (operationType.includes('tts') || operationType.includes('TTS') || operationType === 'api_tts_generation' || operationType === 'api_tts_preview')) {
            const ttsMultiplierSetting = await db.get("SELECT value FROM app_settings WHERE key = 'tts_credits_multiplier'");
            const ttsMultiplier = ttsMultiplierSetting ? parseFloat(ttsMultiplierSetting.value) : 1.0;
            
            if (ttsMultiplier > 0 && ttsMultiplier !== 1.0) {
                creditsPerUnit = apiProvider.credits_per_unit * ttsMultiplier;
                console.log(`🔊 [TTS] Aplicando multiplicador de ${ttsMultiplier}x ao custo de créditos para TTS. Custo base: ${apiProvider.credits_per_unit}, Custo final: ${creditsPerUnit.toFixed(4)}`);
            }
        }

        // Calcular créditos necessários
        const creditsNeeded = (unitsConsumed / apiProvider.unit_size) * creditsPerUnit;

        // Verificar saldo
        let userCredits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [userId]);
        
        if (!userCredits) {
            // Criar registro se não existir
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [userId]);
            userCredits = { balance: 0 };
        }

        if (userCredits.balance < creditsNeeded) {
            throw new Error(`Créditos insuficientes. Necessário: ${creditsNeeded.toFixed(2)}, Disponível: ${userCredits.balance.toFixed(2)}`);
        }

        // Debitar créditos
        const newBalance = userCredits.balance - creditsNeeded;
        await db.run(`
            UPDATE user_credits 
            SET balance = ?, updated_at = CURRENT_TIMESTAMP 
            WHERE user_id = ?
        `, [newBalance, userId]);

        // Registrar uso
        await db.run(`
            INSERT INTO credit_usage (
                user_id, api_provider_id, credits_used, 
                units_consumed, operation_type, details
            ) VALUES (?, ?, ?, ?, ?, ?)
        `, [userId, apiProviderId, creditsNeeded, unitsConsumed, operationType, details || JSON.stringify({ model: operationType })]);
        
        // Mapear operationType e endpoints para nomes amigáveis de ferramentas
        // IMPORTANTE: NUNCA incluir nome do fornecedor de API (Laozhang.ai, etc)
        const toolNames = {
            // ===== GERADOR DE ROTEIRO =====
            'api_script_agents_generate': 'Gerador de Roteiro',
            '/api/generate': 'Gerador de Roteiro',
            '/api/scripts': 'Gerador de Roteiro',
            '/api/scripts/generate': 'Gerador de Roteiro',
            '/api/script-agents/:agentId/generate': 'Gerador de Roteiro',
            '/api/script-agents/:agentId/generate/laozhang': 'Gerador de Roteiro',
            'viral_agent_chat': 'Agente Viral',
            'viral_agent': 'Agente Viral',
            
            // ===== GERADOR DE VÍDEO =====
            'api_video_generation': 'Gerador de Vídeo',
            
            // ===== GERAÇÃO DE VOZ (TTS) =====
            'api_tts_generation': 'Geração de Voz',
            'api_tts_preview': 'Preview de Voz',
            
            // ===== GERAÇÃO DE IMAGEM =====
            'api_image_generation': 'Geração de Imagem',
            
            // ===== GERADOR DE THUMBNAIL =====
            'api_analyze_thumbnail': 'Gerador de Thumbnail',
            '/api/analyze/thumbnail': 'Gerador de Thumbnail',
            '/api/analyze/thumbnail/laozhang': 'Gerador de Thumbnail',
            
            // ===== GERADOR DE CENAS =====
            '/api/generate/scene-prompts': 'Gerador de Cenas',
            '/api/generate/scene-prompts/laozhang': 'Gerador de Cenas',
            
            // ===== ANÁLISE DE TÍTULOS =====
            '/api/analyze/titles': 'Análise de Títulos',
            '/api/analyze/titles/laozhang': 'Análise de Títulos',
            
            // ===== DETECÇÃO DE PERSONAGENS =====
            'api_detect_characters': 'Detecção de Personagens',
            '/api/detect/characters': 'Detecção de Personagens',
            '/api/detect/characters/laozhang': 'Detecção de Personagens',
            
            // ===== BUSCA DE SUBNICHO =====
            'api_niche_find_subniche': 'Busca de Subnicho',
            '/api/niche/find-subniche': 'Busca de Subnicho',
            '/api/niche/find-subniche/laozhang': 'Busca de Subnicho',
            
            // ===== ANÁLISE DE COMPETIDOR =====
            'api_niche_analyze_competitor': 'Análise de Competidor',
            '/api/niche/analyze-competitor': 'Análise de Competidor',
            '/api/niche/analyze-competitor/laozhang': 'Análise de Competidor',
            
            // ===== CRIAÇÃO DE AGENTE =====
            '/api/script-agents/create': 'Criação de Agente',
            '/api/script-agents/create/laozhang': 'Criação de Agente',
            
            // ===== REESCREVER PROMPT =====
            'api_rewrite_prompt': 'Reescrever Prompt',
            '/api/rewrite/blocked-prompt': 'Reescrever Prompt',
            '/api/rewrite/blocked-prompt/laozhang': 'Reescrever Prompt',
            
            // ===== ANÁLISE DE TRANSCRIÇÃO =====
            'api_transcript_analyze': 'Análise de Transcrição',
            '/api/video/transcript/analyze': 'Análise de Transcrição',
            '/api/video/transcript/analyze/laozhang': 'Análise de Transcrição',
            
            // ===== GERADOR DE METADADOS YOUTUBE =====
            '/api/youtube/generate-metadata': 'Gerador de Metadados YouTube',
            
            // ===== GENÉRICOS (fallback) =====
            'api_generation': 'Geração de Conteúdo',
            'api_call': 'Ferramenta'
        };
        
        const detailsObj = typeof details === 'string' ? JSON.parse(details) : (details || {});
        
        // Determinar nome da ferramenta - tentar múltiplas fontes
        let toolName = toolNames[operationType];
        
        // Se não encontrou pelo operationType, tentar pelo endpoint nos details
        if (!toolName && detailsObj?.endpoint) {
            // Tentar match parcial do endpoint
            for (const [key, value] of Object.entries(toolNames)) {
                if (detailsObj.endpoint.includes(key) || key.includes(detailsObj.endpoint)) {
                    toolName = value;
                    break;
                }
            }
        }
        
        // Se ainda não encontrou, tentar inferir pelo operationType ou endpoint
        if (!toolName) {
            const searchKey = operationType || detailsObj?.endpoint || '';
            
            // Buscar por palavras-chave no operationType ou endpoint
            if (searchKey.includes('script') || searchKey.includes('roteiro') || searchKey.includes('agent')) {
                toolName = 'Gerador de Roteiro';
            } else if (searchKey.includes('video') || searchKey.includes('vídeo')) {
                toolName = 'Gerador de Vídeo';
            } else if (searchKey.includes('tts') || searchKey.includes('voz') || searchKey.includes('voice')) {
                toolName = 'Geração de Voz';
            } else if (searchKey.includes('image') || searchKey.includes('imagem')) {
                toolName = 'Geração de Imagem';
            } else if (searchKey.includes('thumbnail') || searchKey.includes('thumb')) {
                toolName = 'Gerador de Thumbnail';
            } else if (searchKey.includes('scene') || searchKey.includes('cena')) {
                toolName = 'Gerador de Cenas';
            } else if (searchKey.includes('title') || searchKey.includes('título')) {
                toolName = 'Análise de Títulos';
            } else if (searchKey.includes('character') || searchKey.includes('personagem')) {
                toolName = 'Detecção de Personagens';
            } else if (searchKey.includes('subniche') || searchKey.includes('sub-nicho')) {
                toolName = 'Busca de Subnicho';
            } else if (searchKey.includes('competitor') || searchKey.includes('competidor')) {
                toolName = 'Análise de Competidor';
            } else if (searchKey.includes('transcript') || searchKey.includes('transcrição')) {
                toolName = 'Análise de Transcrição';
            } else if (searchKey.includes('rewrite') || searchKey.includes('reescrever')) {
                toolName = 'Reescrever Prompt';
            } else {
                // Último fallback: usar o operationType formatado (sem "api_" ou "laozhang")
                toolName = (operationType || 'Ferramenta')
                    .replace(/^api_/, '')
                    .replace(/laozhang/gi, '')
                    .replace(/_/g, ' ')
                    .replace(/\s+/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase())
                    .trim() || 'Ferramenta';
            }
        }
        
        // Extrair modelo dos details
        let modelName = detailsObj?.model || null;
        
        // Formatar nome do modelo para exibição amigável
        if (modelName) {
            // Vídeo - Veo
            // Veo models - verificar modelos landscape primeiro
            if (modelName.includes('veo-3.1-landscape-fast-fl') || modelName === 'veo-3.1-landscape-fast-fl') {
                modelName = 'Veo 3.1 Landscape Fast';
            } else if (modelName.includes('veo-3.1-landscape-fast') || modelName === 'veo-3.1-landscape-fast') {
                modelName = 'Veo 3.1 Landscape Fast';
            } else if (modelName.includes('veo-3.1-landscape-fl') || modelName === 'veo-3.1-landscape-fl') {
                modelName = 'Veo 3.1 Landscape';
            } else if (modelName.includes('veo-3.1-landscape') || modelName === 'veo-3.1-landscape') {
                modelName = 'Veo 3.1 Landscape';
            } else if (modelName.includes('veo-3.1-fast-fl') || modelName === 'veo-3.1-fast-fl') {
                modelName = 'Veo 3.1 Fast';
            } else if (modelName.includes('veo-3.1-fast') || modelName === 'veo-3.1-fast-generate-preview' || modelName === 'veo-3.1-fast') {
                modelName = 'Veo 3.1 Fast';
            } else if (modelName.includes('veo-3.1-fl') || modelName === 'veo-3.1-fl') {
                modelName = 'Veo 3.1';
            } else if (modelName.includes('veo-3.1-generate') || modelName === 'veo-3.1-generate-preview' || modelName === 'veo-3.1') {
                modelName = 'Veo 3.1';
            } else if (modelName.includes('veo-3.1')) {
                modelName = 'Veo 3.1';
            } else if (modelName.includes('veo')) {
                modelName = modelName.replace('veo-', 'Veo ').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            // Claude
            else if (modelName.includes('claude-3-7-sonnet') || modelName === 'claude-3-7-sonnet-20250219') {
                modelName = 'Claude 3.7 Sonnet';
            } else if (modelName.includes('claude-3-5')) {
                modelName = 'Claude 3.5';
            } else if (modelName.includes('claude')) {
                modelName = modelName.replace('claude-', 'Claude ').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            // GPT
            else if (modelName === 'gpt-4o' || modelName.includes('gpt-4o')) {
                modelName = 'GPT-4o';
            } else if (modelName.includes('gpt-4')) {
                modelName = 'GPT-4';
            } else if (modelName.includes('gpt')) {
                modelName = modelName.replace('gpt-', 'GPT-').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            // Gemini
            else if (modelName.includes('gemini-2.5-pro') || modelName === 'gemini-2.5-pro') {
                modelName = 'Gemini 2.5 Pro';
            } else if (modelName.includes('gemini-2.0')) {
                modelName = 'Gemini 2.0';
            } else if (modelName.includes('gemini')) {
                modelName = modelName.replace('gemini-', 'Gemini ').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            // Outros - limpar formato técnico
            else {
                // Remover sufixos de data e versão
                modelName = modelName
                    .replace(/-\d{8}$/, '') // Remove datas como -20250219
                    .replace(/-\d{4}$/, '') // Remove anos como -2025
                    .replace(/-preview$/, '')
                    .replace(/-generate$/, '')
                    .replace(/-latest$/, '')
                    .replace(/-exp$/, '')
                    .replace(/-experimental$/, '')
                    .replace(/-/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
            }
        }
        
        // Criar descrição apenas com nome da ferramenta e modelo (sem fornecedor de API)
        let description = toolName;
        if (modelName) {
            description += ` - ${modelName}`;
        }
        
        // Registrar transação para histórico do usuário
        const sanitizedDescription = sanitizeUserFacingText(description, toolName || 'Operação');
        await db.run(`
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description, admin_id)
            VALUES (?, ?, 'debit', ?, NULL)
        `, [userId, -creditsNeeded, sanitizedDescription]);

        return {
            success: true,
            creditsUsed: creditsNeeded,
            newBalance: newBalance
        };
    } catch (error) {
        console.error('❌ Erro ao verificar/debitar créditos:', error);
        throw error;
    }
};

/**
 * Reembolsa créditos ao usuário em caso de erro
 */
const refundCredits = async (userId, creditsAmount, reason = 'Erro na operação') => {
    try {
        if (!creditsAmount || creditsAmount <= 0) {
            return { success: false, message: 'Valor inválido' };
        }

        let userCredits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [userId]);
        
        if (!userCredits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [userId]);
            userCredits = { balance: 0 };
        }

        const newBalance = userCredits.balance + creditsAmount;
        await db.run(`
            UPDATE user_credits 
            SET balance = ?, updated_at = CURRENT_TIMESTAMP 
            WHERE user_id = ?
        `, [newBalance, userId]);

        // Registrar transação de reembolso
        const sanitizedReason = sanitizeUserFacingText(reason || 'Créditos reembolsados', 'Créditos reembolsados');
        await db.run(`
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description)
            VALUES (?, ?, 'refund', ?)
        `, [userId, creditsAmount, sanitizedReason]);

        return {
            success: true,
            creditsRefunded: creditsAmount,
            newBalance: newBalance
        };
    } catch (error) {
        console.error('❌ Erro ao reembolsar créditos:', error);
        throw error;
    }
};

// ================================================
// SISTEMA DE TTS (TEXT-TO-SPEECH) - FUNÇÕES
// ================================================

// Armazenamento de jobs TTS em memória
const ttsJobs = {};

// Limpar jobs antigos (mais de 1 hora)
setInterval(() => {
    const oneHourAgo = Date.now() - 3600000;
    for (const [jobId, job] of Object.entries(ttsJobs)) {
        if (job.createdAt && new Date(job.createdAt).getTime() < oneHourAgo) {
            delete ttsJobs[jobId];
        }
    }
}, 600000); // A cada 10 minutos

// Diretório temporário para áudio
const TEMP_AUDIO_DIR = path.join(__dirname, 'temp_audio');
if (!fs.existsSync(TEMP_AUDIO_DIR)) {
    fs.mkdirSync(TEMP_AUDIO_DIR, { recursive: true });
}

// Modelos TTS válidos
const VALID_TTS_MODELS = [
    'gemini-2.5-pro-preview-tts',
    'gemini-2.5-flash-preview-tts',
    'tts-1',
    'tts-1-hd',
    'genaipro-default'
];
const DEFAULT_TTS_MODEL = 'gemini-2.5-pro-preview-tts';
const FALLBACK_TTS_VOICE = 'zephyr';
const DEFAULT_TTS_SAMPLE_TEXT = 'LaCasa Dark A ferramenta de elite para canais dark.';

const validateTtsModel = (model) => {
    if (!model || !VALID_TTS_MODELS.includes(model)) {
        return DEFAULT_TTS_MODEL;
    }
    return model;
};

// Função auxiliar para dividir texto tipo CapCut (máx 500 chars por bloco, respeitando frases)
function splitLikeCapcut(text, maxLen = 500) {
    const sentences = text.split(/(?<=[.!?])\s+/);
    const blocks = [];
    let current = "";

    for (const sentence of sentences) {
        if (sentence.length > maxLen) {
            // Se uma frase sozinha ultrapassa o limite, divide por palavras
            const words = sentence.split(" ");
            let tempCurrent = "";
            for (const word of words) {
                if ((tempCurrent + " " + word).trim().length <= maxLen) {
                    tempCurrent += " " + word;
                } else {
                    if (tempCurrent.trim().length > 0) {
                        blocks.push(tempCurrent.trim());
                    }
                    tempCurrent = word;
                }
            }
            if (tempCurrent.trim().length > 0) {
                current = tempCurrent.trim();
            }
        } else {
            if ((current + " " + sentence).trim().length <= maxLen) {
                current += " " + sentence;
            } else {
                if (current.trim().length > 0) {
                    blocks.push(current.trim());
                }
                current = sentence;
            }
        }
    }
    if (current.trim().length > 0) {
        blocks.push(current.trim());
    }
    return blocks;
}

// Função completa de divisão de texto do DARKSCRIPT (com prioridades de quebra)
function splitTextIntoChunks(text, charLimit) {
    const chunks = [];
    let remainingText = text.trim();

    while (remainingText.length > 0) {
        if (remainingText.length <= charLimit) {
            chunks.push(remainingText);
            break;
        }

        // Tenta usar 95% do limite para deixar margem e evitar cortes no meio de palavras
        const safeLimit = Math.floor(charLimit * 0.95);
        let chunk = remainingText.substring(0, safeLimit);
        let lastSentenceEnd = -1;
        let bestBreakPoint = -1;

        // PRIORIDADE 1: Procura por finais de parágrafo (quebra de linha dupla)
        const doubleLineBreak = chunk.lastIndexOf('\n\n');
        if (doubleLineBreak > charLimit * 0.7) { // Se está nos últimos 30% do chunk
            bestBreakPoint = doubleLineBreak + 2;
        }

        // PRIORIDADE 2: Procura por finais de frase (ponto, exclamação, interrogação seguidos de espaço)
        if (bestBreakPoint === -1) {
            const sentenceEnders = ['.', '!', '?'];
            for (const ender of sentenceEnders) {
                // Procura pelo padrão: "encerrador + espaço" ou "encerrador + quebra de linha"
                const pattern1 = `${ender} `;
                const pattern2 = `${ender}\n`;
                const index1 = chunk.lastIndexOf(pattern1);
                const index2 = chunk.lastIndexOf(pattern2);
                const index = Math.max(index1, index2);
                
                if (index > lastSentenceEnd && index > charLimit * 0.7) {
                    lastSentenceEnd = index + (index === index1 ? pattern1.length : pattern2.length);
                    bestBreakPoint = lastSentenceEnd;
                }
            }
        }

        // PRIORIDADE 3: Procura por vírgulas ou ponto-e-vírgula (em posições adequadas)
        if (bestBreakPoint === -1) {
            const commaBreak = chunk.lastIndexOf(', ');
            const semicolonBreak = chunk.lastIndexOf('; ');
            const breakPoint = Math.max(commaBreak, semicolonBreak);
            
            if (breakPoint > charLimit * 0.8) { // Se está nos últimos 20% do chunk
                bestBreakPoint = breakPoint + 2;
            }
        }

        // PRIORIDADE 4: Se não encontrou ponto de quebra natural, quebra na última palavra
        if (bestBreakPoint === -1) {
            const lastSpace = chunk.lastIndexOf(' ');
            if (lastSpace !== -1 && lastSpace > charLimit * 0.5) {
                bestBreakPoint = lastSpace + 1;
            } else {
                // Último recurso: quebra no limite exato (pode cortar palavra, mas é raro)
                bestBreakPoint = safeLimit;
            }
        }

        // Se encontrou um ponto de quebra adequado, usa ele
        if (bestBreakPoint > 0 && bestBreakPoint <= safeLimit) {
            chunk = remainingText.substring(0, bestBreakPoint).trim();
        } else {
            // Fallback: usa o chunk até o limite seguro
            chunk = chunk.trim();
        }
        
        chunks.push(chunk);
        remainingText = remainingText.substring(chunk.length).trim();
    }

    return chunks.filter(Boolean); // Remove chunks vazios
}

// Função para gerar áudio usando OpenAI TTS
const generateOpenAiTtsAudio = async ({ apiKey, textInput, voiceName }) => {
    const MAX_RETRIES = 3;
    const RETRY_DELAY = 3000;
    
    const validOpenAiVoices = ['alloy', 'echo', 'fable', 'onyx', 'nova', 'shimmer'];
    
    // Mapeamento de vozes Gemini para OpenAI
    const voiceMapping = {
        'Zephyr': 'nova',
        'Puck': 'shimmer',
        'Charon': 'onyx',
        'Kore': 'nova',
        'Fenrir': 'echo',
        'Leda': 'alloy',
        'Orus': 'onyx',
        'Aoede': 'shimmer',
        'Callirrhoe': 'alloy',
        'Autonoe': 'nova',
        'Enceladus': 'shimmer',
        'Iapetus': 'echo',
        'Umbriel': 'alloy',
        'Algieba': 'onyx',
        'Despina': 'nova',
        'Erinome': 'shimmer',
        'Algenib': 'onyx',
        'Rasalgethi': 'echo',
        'Laomedeia': 'shimmer',
        'Achernar': 'nova',
        'Alnilam': 'onyx',
        'Schedar': 'echo',
        'Gacrux': 'onyx',
        'Pulcherrima': 'nova',
        'Achird': 'alloy',
        'Zubenelgenubi': 'alloy',
        'Vindemiatrix': 'shimmer',
        'Sadachbia': 'shimmer',
        'Sadaltager': 'onyx',
        'Sulafat': 'nova'
    };
    
    let openAiVoice = voiceMapping[voiceName] || 'alloy';
    if (validOpenAiVoices.includes(voiceName?.toLowerCase())) {
        openAiVoice = voiceName.toLowerCase();
    }
    
    const cleanText = textInput.trim().replace(/[\x00-\x1F\x7F]/g, '');
    if (cleanText.length === 0) {
        throw new Error('Texto de entrada está vazio após limpeza');
    }
    
    if (cleanText.length > 4096) {
        throw new Error(`Texto muito longo (${cleanText.length} chars). Limite da API OpenAI é 4096 caracteres.`);
    }
    
    const responseFormat = 'mp3';
    
    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
        try {
            const response = await axios.post(
                'https://api.openai.com/v1/audio/speech',
                {
                    model: 'tts-1-hd',
                    input: cleanText,
                    voice: openAiVoice,
                    response_format: responseFormat,
                    speed: 1.0
                },
                {
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    responseType: 'arraybuffer',
                    timeout: 300000
                }
            );
            
            if (!response.data || response.data.length === 0) {
                throw new Error('A API retornou uma resposta vazia');
            }
            
            const audioBuffer = Buffer.from(response.data);
            const audioBase64 = audioBuffer.toString('base64');
            
            return {
                audioBase64: audioBase64,
                usage: null,
                format: 'mp3'
            };
        } catch (error) {
            if (attempt < MAX_RETRIES - 1) {
                const delay = RETRY_DELAY * (attempt + 1);
                await new Promise(resolve => setTimeout(resolve, delay));
            } else {
                throw error;
            }
        }
    }
};

// Função para gerar áudio usando Voz Premium API (GenAIPro)
// Sistema assíncrono: cria task e consulta status
// Documentação: https://genaipro.vn/docs-api
const generateVoicePremiumTtsAudio = async ({ apiKey, textInput, voiceName }) => {
    const MAX_WAIT_TIME = 300000; // 5 minutos máximo (algumas tasks podem demorar)
    const POLL_INTERVAL = 1500; // Verificar a cada 1.5 segundos (mais rápido para preview)
    
    // API Voz Premium (GenAIPro) conforme documentação
    // Base URL: https://genaipro.vn/api/v1
    const API_BASE = 'https://genaipro.vn/api/v1';
    
    const cleanText = textInput.trim();
    if (cleanText.length === 0) {
        throw new Error('Texto de entrada está vazio');
    }
    
    // Validar voice_id - se não foi fornecido, usar um padrão
    if (!voiceName || voiceName.trim() === '' || voiceName === 'default') {
        console.warn('[La Casa Dark Core] Voice ID não fornecido ou inválido, tentando buscar vozes disponíveis...');
        // Tentar buscar uma voz padrão
        try {
            const voicesResponse = await axios.get(`${API_BASE}/max/voices`, {
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                params: {
                    page: 1,
                    page_size: 1,
                    language: 'Portuguese'
                },
                timeout: 10000
            });
            
            if (voicesResponse?.data?.voice_list && voicesResponse.data.voice_list.length > 0) {
                voiceName = voicesResponse.data.voice_list[0].voice_id;
                console.log(`[La Casa Dark Core] Usando voz padrão: ${voiceName}`);
            } else {
                throw new Error('Nenhuma voz disponível encontrada');
            }
        } catch (voiceError) {
            console.error('[La Casa Dark Core] Erro ao buscar voz padrão:', voiceError.message);
            throw new Error('Voice ID é obrigatório. Configure uma voz premium no painel.');
        }
    }
    
    try {
        // Detectar tipo de voz: Labs (alfanumérica) ou Max (numérica)
        const isLabsVoice = voiceName && !/^\d+$/.test(voiceName);
        const voiceType = isLabsVoice ? 'Labs' : 'Max';
        
        console.log(`[La Casa Dark Core] Criando task TTS com voz: ${voiceName} (tipo: ${voiceType})`);
        console.log(`[La Casa Dark Core] Texto (primeiros 100 chars): ${cleanText.substring(0, 100)}...`);
        
        let taskResponse;
        let audioResult = null;
        
        // Headers de autenticação conforme documentação GenAIPro
        const authHeaders = {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
        };
        
        // =========================================================
        // Se for voz LABS, usar endpoint Labs PRIMEIRO
        // =========================================================
        if (isLabsVoice) {
            console.log('[La Casa Dark Core] Voz Labs detectada, tentando POST /labs/task...');
            try {
                const labsTaskResponse = await axios.post(
                    `${API_BASE}/labs/task`,
                    {
                        input: cleanText,  // Labs usa "input" não "text"
                        voice_id: voiceName,
                        model_id: 'eleven_multilingual_v2',
                        speed: 1.0  // Speed deve estar entre 0.7 e 1.2 (conforme API)
                    },
                    {
                        headers: authHeaders,
                        timeout: 30000,
                        validateStatus: (status) => true
                    }
                );
                
                console.log('[La Casa Dark Core] Resposta /labs/task status:', labsTaskResponse.status);
                console.log('[La Casa Dark Core] Resposta /labs/task data:', JSON.stringify(labsTaskResponse.data).substring(0, 500));
                
                // Verificar se está em manutenção
                if (labsTaskResponse.status === 503) {
                    const responseText = typeof labsTaskResponse.data === 'string' ? labsTaskResponse.data : '';
                    if (responseText.includes('Maintenance') || responseText.includes('Bảo Trì') || responseText.includes('<!DOCTYPE')) {
                        console.log('[La Casa Dark Core] ⚠️ API Labs está em manutenção');
                        throw new Error('O serviço de voz está temporariamente em manutenção. Por favor, tente novamente em alguns minutos.');
                    }
                }
                
                // Tratar erro 400 (Bad Request)
                if (labsTaskResponse.status === 400) {
                    const errorData = labsTaskResponse.data;
                    const errorMsg = errorData?.error || errorData?.message || 'Parâmetros inválidos';
                    console.log('[La Casa Dark Core] Labs retornou 400:', errorData);
                    throw new Error(`Erro ao gerar áudio: ${errorMsg}`);
                }
                
                if (labsTaskResponse.status === 200 || labsTaskResponse.status === 201) {
                    const data = labsTaskResponse.data;
                    
                    console.log('[La Casa Dark Core] Resposta Labs completa:', JSON.stringify(data).substring(0, 500));
                    
                    // Verificar se já tem resultado direto (múltiplos formatos possíveis)
                    const audioUrl = data.result || data.audio_url || data.url || data.output_url || data.file_url;
                    const status = (data.status || '').toLowerCase();
                    const successStatuses = ['completed', 'done', 'success', 'finished'];
                    
                    if (audioUrl) {
                        console.log('[La Casa Dark Core] ✅ Task Labs já tem áudio disponível:', audioUrl);
                        
                        // Se for URL relativa, adicionar base URL
                        let fullAudioUrl = audioUrl;
                        if (audioUrl.startsWith('/')) {
                            fullAudioUrl = `https://genaipro.vn${audioUrl}`;
                        } else if (!audioUrl.startsWith('http')) {
                            fullAudioUrl = `${API_BASE.replace('/api/v1', '')}${audioUrl}`;
                        }
                        
                        const audioDownload = await axios.get(fullAudioUrl, {
                            responseType: 'arraybuffer',
                            timeout: 60000
                        });
                        return {
                            audioBase64: Buffer.from(audioDownload.data).toString('base64'),
                            usage: null,
                            format: 'mp3'
                        };
                    }
                    
                    // Se retornou task_id, fazer polling
                    if (data.task_id || data.id) {
                        const taskId = data.task_id || data.id;
                        console.log('[La Casa Dark Core] Labs Task criada:', taskId, '- Aguardando...');
                        
                        // Verificação imediata após criar a task (algumas APIs retornam resultado síncrono)
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Aguardar 1s antes do primeiro poll
                        
                        const startTime = Date.now();
                        let pollCount = 0;
                        let lastStatus = null;
                        let statusChangeCount = 0;
                        let consecutiveProcessingCount = 0; // Contador de polls consecutivos em "processing"
                        
                        while (Date.now() - startTime < MAX_WAIT_TIME) {
                            pollCount++;
                            const elapsed = Math.floor((Date.now() - startTime) / 1000);
                            
                            // Log apenas a cada 5 polls para não poluir muito
                            if (pollCount % 5 === 1 || elapsed > 30) {
                                console.log(`[La Casa Dark Core] Polling Labs #${pollCount} (${elapsed}s decorridos)...`);
                            }
                            
                            try {
                                const statusResponse = await axios.get(
                                    `${API_BASE}/labs/task/${taskId}`,
                                    { headers: authHeaders, timeout: 8000 } // Timeout reduzido para 8s
                                );
                                
                                if (statusResponse.data) {
                                    const taskData = statusResponse.data;
                                    const status = (taskData.status || taskData.state || '').toLowerCase();
                                    
                                    // Verificar se há erro mesmo quando status é processing
                                    if (taskData.error && typeof taskData.error === 'string' && taskData.error.length > 0) {
                                        console.error('[La Casa Dark Core] ❌ Erro na task Labs:', taskData.error);
                                        throw new Error(taskData.error);
                                    }
                                    
                                    // PRIORIDADE 1: Verificar se tem resultado disponível (mesmo que status ainda seja processing)
                                    // Algumas APIs retornam o resultado antes de mudar o status para "completed"
                                    // Verificar múltiplos campos possíveis onde o resultado pode estar
                                    const audioUrl = taskData.result || taskData.audio_url || taskData.url || taskData.output_url || taskData.file_url;
                                    
                                    if (audioUrl && typeof audioUrl === 'string' && audioUrl.length > 0) {
                                        console.log('[La Casa Dark Core] ✅ Resultado encontrado! Baixando áudio (status:', status, ', URL:', audioUrl.substring(0, 100), ')');
                                        
                                        let fullAudioUrl = audioUrl.trim();
                                        if (!fullAudioUrl.startsWith('http')) {
                                            fullAudioUrl = `https://${fullAudioUrl}`;
                                        }
                                        
                                        try {
                                            const audioDownload = await axios.get(fullAudioUrl, {
                                                responseType: 'arraybuffer',
                                                timeout: 60000,
                                                validateStatus: (status) => status === 200
                                            });
                                            
                                            console.log('[La Casa Dark Core] ✅ Áudio baixado com sucesso (tamanho:', audioDownload.data.length, 'bytes)');
                                            
                                            return {
                                                audioBase64: Buffer.from(audioDownload.data).toString('base64'),
                                                usage: null,
                                                format: 'mp3'
                                            };
                                        } catch (downloadError) {
                                            // Se falhar o download, continuar polling
                                            console.log('[La Casa Dark Core] ⏳ URL ainda não acessível (erro:', downloadError.message, '), continuando polling...');
                                        }
                                    } else if (pollCount % 20 === 0) {
                                        // A cada 20 polls, logar estrutura completa para debug
                                        console.log('[La Casa Dark Core] 🔍 Estrutura completa da resposta:', JSON.stringify(taskData).substring(0, 800));
                                    }
                                    
                                    // Detectar se status mudou
                                    if (lastStatus !== status) {
                                        lastStatus = status;
                                        statusChangeCount++;
                                        consecutiveProcessingCount = 0; // Reset contador
                                        console.log(`[La Casa Dark Core] Status mudou para: "${status}" (mudança #${statusChangeCount})`);
                                    } else if (status === 'processing') {
                                        consecutiveProcessingCount++;
                                    }
                                    
                                    // Log detalhado apenas quando necessário
                                    const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                                    if (pollCount % 10 === 0 || elapsedSeconds > 30) {
                                        // Log completo da resposta para debug
                                        console.log(`[La Casa Dark Core] Labs Task ${taskId}:`, {
                                            status: status,
                                            hasResult: !!taskData.result,
                                            resultPreview: taskData.result ? taskData.result.substring(0, 100) : 'não disponível',
                                            elapsed: `${elapsedSeconds}s`,
                                            polls: pollCount,
                                            fullResponse: JSON.stringify(taskData).substring(0, 500)
                                        });
                                    }
                                    
                                    // Conforme documentação: quando status é "completed", o campo "result" contém a URL
                                    if (status === 'completed') {
                                        // Se chegou aqui e não tem result, aguardar mais um pouco
                                        if (!audioUrl) {
                                            console.log('[La Casa Dark Core] ⏳ Status completed mas sem result ainda, aguardando...');
                                            await new Promise(resolve => setTimeout(resolve, 2000)); // Aguardar 2s e verificar novamente
                                            continue;
                                        }
                                    } else if (status === 'failed' || status === 'error' || status === 'failure') {
                                        const errorMsg = taskData.error || taskData.message || 'Task Labs falhou';
                                        console.error('[La Casa Dark Core] ❌ Task Labs falhou:', errorMsg);
                                        throw new Error(errorMsg);
                                    } else if (status === 'processing' || status === 'pending' || status === 'queued') {
                                        // Ainda processando, continuar aguardando
                                    } else {
                                        // Status desconhecido
                                        console.log(`[La Casa Dark Core] ⚠️ Status desconhecido: "${status}", continuando polling...`);
                                    }
                                }
                            } catch (pollError) {
                                // Se for erro de rede/timeout, continuar tentando
                                if (pollError.code === 'ECONNABORTED' || pollError.code === 'ETIMEDOUT') {
                                    console.log('[La Casa Dark Core] Timeout no polling, continuando...');
                                } else if (pollError.message && !pollError.message.includes('Task Labs falhou')) {
                                    console.log('[La Casa Dark Core] Erro no polling Labs:', pollError.message);
                                } else {
                                    // Se for erro de task falhada, propagar
                                    throw pollError;
                                }
                            }
                            
                            // Aguardar antes do próximo poll (intervalo dinâmico)
                            // Se está em processing há muito tempo, aumentar intervalo para não sobrecarregar
                            const waitTime = consecutiveProcessingCount > 10 ? POLL_INTERVAL * 2 : POLL_INTERVAL;
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                        }
                        
                        // Timeout - task não completou no tempo esperado
                        const totalSeconds = Math.floor((Date.now() - startTime) / 1000);
                        console.error(`[La Casa Dark Core] ❌ Timeout após ${totalSeconds}s (${pollCount} tentativas). Task pode ainda estar processando.`);
                        throw new Error(`A geração de áudio está demorando mais que o esperado (${totalSeconds}s). A task pode ainda estar processando. Tente novamente em alguns instantes.`);
                    }
                }
            } catch (labsError) {
                console.log('[La Casa Dark Core] Erro Labs:', labsError.message);
                throw labsError;
            }
        }
        
        // =========================================================
        // MÉTODO MAX: POST /max/tasks (para vozes Max/numéricas)
        // =========================================================
        console.log('[La Casa Dark Core] Tentando POST /max/tasks...');
        try {
            const maxTaskResponse = await axios.post(
                `${API_BASE}/max/tasks`,
                {
                    text: cleanText,
                    voice_id: voiceName,
                    model_id: 'speech-2.5-hd-preview',
                    speed: 1.0,
                    pitch: 0,
                    volume: 1.0,
                    language: 'Auto'
                },
                {
                    headers: authHeaders,
                    timeout: 30000,
                    validateStatus: (status) => true // Aceitar qualquer status para tratar manualmente
                }
            );
            
            // Verificar se está em manutenção (503)
            if (maxTaskResponse.status === 503) {
                const responseText = typeof maxTaskResponse.data === 'string' ? maxTaskResponse.data : '';
                if (responseText.includes('Maintenance') || responseText.includes('Bảo Trì')) {
                    console.log('[La Casa Dark Core] ⚠️ API Max está em manutenção');
                    throw new Error('O serviço de Voz Premium está temporariamente em manutenção. Por favor, tente novamente em alguns minutos.');
                }
            }
            
            console.log('[La Casa Dark Core] Resposta /max/tasks status:', maxTaskResponse.status);
            console.log('[La Casa Dark Core] Resposta /max/tasks data:', JSON.stringify(maxTaskResponse.data).substring(0, 500));
            
            if (maxTaskResponse.status === 200 || maxTaskResponse.status === 201) {
                const data = maxTaskResponse.data;
                
                // Se já tem resultado direto
                if (data.result && data.status === 'completed') {
                    console.log('[La Casa Dark Core] ✅ Task já completa, baixando áudio...');
                    const audioDownload = await axios.get(data.result, {
                        responseType: 'arraybuffer',
                        timeout: 60000
                    });
                    return {
                        audioBase64: Buffer.from(audioDownload.data).toString('base64'),
                        usage: null,
                        format: 'mp3'
                    };
                }
                
                // Se retornou task_id, fazer polling
                if (data.id) {
                    const taskId = data.id;
                    console.log('[La Casa Dark Core] Task criada:', taskId, '- Aguardando processamento...');
                    
                    const startTime = Date.now();
                    while (Date.now() - startTime < MAX_WAIT_TIME) {
                        await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));
                        
                        try {
                            const statusResponse = await axios.get(
                                `${API_BASE}/max/tasks/${taskId}`,
                                { headers: authHeaders, timeout: 10000 }
                            );
                            
                            if (statusResponse.data) {
                                const taskData = statusResponse.data;
                                const status = taskData.status;
                                const percentage = taskData.process_percentage || 0;
                                
                                console.log(`[La Casa Dark Core] Task ${taskId}: ${status} (${percentage}%)`);
                                
                                if (status === 'completed') {
                                    if (taskData.result) {
                                        console.log('[La Casa Dark Core] ✅ Áudio pronto:', taskData.result);
                                        const audioDownload = await axios.get(taskData.result, {
                                            responseType: 'arraybuffer',
                                            timeout: 60000
                                        });
                                        return {
                                            audioBase64: Buffer.from(audioDownload.data).toString('base64'),
                                            usage: null,
                                            format: 'mp3'
                                        };
                                    }
                                } else if (status === 'failed' || status === 'error') {
                                    throw new Error(taskData.error || 'Task falhou');
                                }
                                // processing, pending - continuar polling
                            }
                        } catch (pollError) {
                            console.log('[La Casa Dark Core] Erro no polling:', pollError.message);
                        }
                    }
                    throw new Error('Timeout aguardando conclusão da task');
                }
            }
        } catch (maxTaskError) {
            console.log('[La Casa Dark Core] Erro /max/tasks:', maxTaskError.message);
            
            // Se for erro de manutenção, propagar diretamente
            if (maxTaskError.message && maxTaskError.message.includes('manutenção')) {
                throw maxTaskError;
            }
            
            if (maxTaskError.response) {
                console.log('[La Casa Dark Core] Status:', maxTaskError.response.status);
                console.log('[La Casa Dark Core] Data:', JSON.stringify(maxTaskError.response.data).substring(0, 300));
            }
        }
        
        // Se chegou aqui (vozes Max que falharam), nenhum método funcionou
        console.error('[La Casa Dark Core] Nenhum método de TTS funcionou');
        throw new Error('O serviço de Voz Premium está temporariamente indisponível. Por favor, tente novamente em alguns minutos ou selecione uma voz online.');
        
    } catch (error) {
        console.error('[La Casa Dark Core] Erro ao gerar TTS:', error.message);
        
        // Não verificar mais status 503 aqui, deixar a mensagem de erro original passar
        if (error.response) {
            console.error('[La Casa Dark Core] Status:', error.response.status);
            console.error('[La Casa Dark Core] Data:', JSON.stringify(error.response.data).substring(0, 500));
        }
        
        // Se o erro já tem uma mensagem amigável do catch anterior, manter
        if (error.message && !error.message.includes('AxiosError')) {
            throw error;
        }
        
        // Erro genérico
        throw new Error('Erro ao gerar áudio com Voz Premium. Verifique sua chave de API e tente novamente.');
    }
};

const generateLaozhangTtsAudio = async ({ apiKey, textInput, voiceName = 'alloy', speed = 1.0, model = 'tts-1' }) => {
    const cleanText = textInput.trim();
    if (!cleanText) {
        throw new Error('Texto de entrada vazio para geração de voz.');
    }

    const payload = {
        model: model,
        voice: voiceName || 'alloy',
        input: cleanText,
        speed: Math.min(Math.max(speed || 1.0, 0.25), 4.0)
    };

    try {
        console.log(`[DarkVoz TTS] Gerando áudio com voz "${voiceName}" (speed ${payload.speed})`);
        const response = await axios.post(
            'https://api.laozhang.ai/v1/audio/speech',
            payload,
            {
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'Accept': 'audio/mpeg'
                },
                responseType: 'arraybuffer',
                timeout: 120000
            }
        );

        if (!response || !response.data) {
            throw new Error('Resposta vazia da API do provedor de voz ao gerar áudio.');
        }

        const audioBuffer = Buffer.from(response.data);
        console.log(`[DarkVoz TTS] Áudio gerado (${audioBuffer.length} bytes)`);
        return {
            audioBase64: audioBuffer.toString('base64'),
            mimeType: 'audio/mp3'
        };
    } catch (error) {
        console.error('[DarkVoz TTS] Erro ao gerar áudio:', error.message);
        if (error.response) {
            console.error('[DarkVoz TTS] Status:', error.response.status);
            console.error('[DarkVoz TTS] Data:', typeof error.response.data === 'string' ? error.response.data.substring(0, 500) : error.response.data);
            if (error.response.status === 401) {
                throw new Error('Chave do DarkVoz inválida ou expirada. Atualize a chave no painel admin.');
            }
            if (error.response.status === 403) {
                throw new Error('Acesso negado pela API do DarkVoz. Verifique se a chave possui permissões para TTS.');
            }
            if (error.response.status === 503) {
                throw new Error('O DarkVoz está temporariamente indisponível. Tente novamente em alguns minutos.');
            }
        }
        if (error.code === 'ECONNABORTED') {
            throw new Error('Timeout ao conectar com a API do DarkVoz. Tente novamente em instantes.');
        }
        throw new Error(error.message || 'Erro ao gerar áudio com o DarkVoz.');
    }
};

// Função principal para gerar TTS
const generateTtsAudio = async ({ apiKey, model, textInput, speakerVoiceMap, provider = 'gemini', speed = 1.0 }, retryCount = 0) => {
    // Se o provedor for OpenAI, usa a função específica
    if (provider === 'openai') {
        const voiceName = Array.from(speakerVoiceMap.values())[0] || 'alloy';
        return await generateOpenAiTtsAudio({ apiKey, textInput, voiceName });
    }
    
    // Se o provedor for Voz Premium (GenAIPro)
    if (provider === 'voice_premium' || provider === 'genaipro') {
        const voiceName = Array.from(speakerVoiceMap.values())[0] || 'default';
        return await generateVoicePremiumTtsAudio({ apiKey, textInput, voiceName });
    }
    
    // Gemini TTS - usar API oficial do Google Gemini
    if (provider === 'gemini') {
        return await generateGeminiTtsAudio({ apiKey, textInput });
    }

    if (provider === 'laozhang') {
        const voiceName = Array.from(speakerVoiceMap.values())[0] || 'alloy';
        return await generateLaozhangTtsAudio({ apiKey, textInput, voiceName, speed, model });
    }
    
    throw new Error(`Provedor TTS "${provider}" não suportado. Use OpenAI, Voz Premium, Gemini ou DarkVoz.`);
};

// Função para gerar TTS usando a API oficial do Google Cloud Text-to-Speech
// Nota: O Google Gemini não tem TTS nativo, então usamos o Google Cloud Text-to-Speech API
// que pode usar a mesma chave de API do Google Cloud
const generateGeminiTtsAudio = async ({ apiKey, textInput }) => {
    const cleanText = textInput.trim();
    if (cleanText.length === 0) {
        throw new Error('Texto de entrada está vazia');
    }
    
    try {
        console.log('[La Casa Dark Core TTS] Gerando áudio usando Text-to-Speech');
        
        // Usar Google Cloud Text-to-Speech API
        // Endpoint: https://texttospeech.googleapis.com/v1/text:synthesize
        // A chave do Google Cloud pode ser usada diretamente aqui
        const response = await axios.post(
            `https://texttospeech.googleapis.com/v1/text:synthesize?key=${encodeURIComponent(apiKey)}`,
            {
                input: {
                    text: cleanText
                },
                voice: {
                    languageCode: 'pt-BR',
                    name: 'pt-BR-Neural2-C', // Voz neural em português brasileiro
                    ssmlGender: 'FEMALE' // NEUTRAL não é suportado, usar FEMALE ou MALE
                },
                audioConfig: {
                    audioEncoding: 'MP3',
                    speakingRate: 1.0,
                    pitch: 0.0,
                    volumeGainDb: 0.0
                }
            },
            {
                headers: {
                    'Content-Type': 'application/json'
                },
                timeout: 60000
            }
        );
        
        if (response.data && response.data.audioContent) {
            // O audioContent já vem em base64
            const audioBase64 = response.data.audioContent;
            
            console.log('[La Casa Dark Core TTS] Áudio gerado com sucesso');
            return {
                audioBase64: audioBase64,
                mimeType: 'audio/mp3'
            };
        } else {
            throw new Error('Resposta da API não contém áudio');
        }
    } catch (error) {
        console.error('[La Casa Dark Core TTS] Erro ao gerar áudio:', error.message);
        
        if (error.response) {
            const status = error.response.status;
            const errorData = error.response.data;
            
            console.error('[La Casa Dark Core TTS] Status:', status);
            console.error('[La Casa Dark Core TTS] Error Data:', JSON.stringify(errorData).substring(0, 500));
            
            if (status === 401 || status === 403) {
                throw new Error('Chave de API do Google inválida ou expirada. Verifique suas configurações. A chave precisa ter a API Text-to-Speech habilitada.');
            }
            
            if (status === 429) {
                throw new Error('Limite de requisições excedido. Aguarde alguns instantes e tente novamente.');
            }
            
            let errorMessage = 'Erro ao gerar áudio com Google Cloud Text-to-Speech';
            if (typeof errorData === 'object' && errorData.error) {
                errorMessage = errorData.error.message || errorData.error || errorMessage;
            } else if (typeof errorData === 'string') {
                errorMessage = errorData;
            }
            
            throw new Error(errorMessage);
        }
        
        if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {
            throw new Error('Timeout ao conectar com a API do Google. Tente novamente.');
        }
        
        throw error;
    }
};

// --- INICIALIZAÇÃO DO BANCO DE DADOS ---
(async () => {
    try {
        // Define o caminho do banco de dados, usando a variável de ambiente ou um padrão.
        const dbPath = process.env.DB_PATH || path.join(__dirname, 'data', 'lacasacorebd.db');
        
        // Garante que o diretório do banco de dados exista
        const dbDir = path.dirname(dbPath);
        if (!fs.existsSync(dbDir)) {
            fs.mkdirSync(dbDir, { recursive: true });
        }

        db = await sqlite.open({
            filename: dbPath, // Usa o caminho definido
            driver: sqlite3.Database
        });

        console.log(`Conectado ao banco de dados em: ${dbPath}`);

        // --- CRIAÇÃO DAS TABELAS ---

        await db.exec(`
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                email TEXT NOT NULL UNIQUE,
                whatsapp TEXT,
                password_hash TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                isAdmin BOOLEAN NOT NULL DEFAULT 0,
                isBlocked BOOLEAN NOT NULL DEFAULT 0,
                isApproved BOOLEAN NOT NULL DEFAULT 0,
                last_login_at DATETIME,
                plan TEXT DEFAULT 'plan-free',
                subscription_plan TEXT DEFAULT 'plan-free'
            );
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS password_reset_tokens (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                token TEXT NOT NULL UNIQUE,
                expires_at DATETIME NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                used BOOLEAN NOT NULL DEFAULT 0,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            );
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS analysis_folders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS monitored_channels (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                channel_name TEXT NOT NULL,
                channel_url TEXT NOT NULL,
                last_checked DATETIME,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                UNIQUE(user_id, channel_url)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS analyzed_videos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                folder_id INTEGER,
                
                youtube_video_id TEXT NOT NULL,
                video_url TEXT,
                original_title TEXT,
                translated_title TEXT,
                original_views INTEGER,
                original_comments INTEGER,
                original_days INTEGER,
                original_thumbnail_url TEXT,
                
                detected_niche TEXT,
                detected_subniche TEXT,
                
                analysis_data_json TEXT, -- JSON com a 'analiseOriginal'
                
                analyzed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                FOREIGN KEY (folder_id) REFERENCES analysis_folders (id) ON DELETE SET NULL
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS generated_titles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                video_analysis_id INTEGER NOT NULL,
                title_text TEXT NOT NULL,
                model_used TEXT,
                pontuacao INTEGER DEFAULT 0,
                explicacao TEXT,
                is_checked BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (video_analysis_id) REFERENCES analyzed_videos (id) ON DELETE CASCADE
            );
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS generated_thumbnails (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                video_analysis_id INTEGER NOT NULL,
                base_title TEXT, 
                description TEXT,
                hook_phrases_json TEXT,
                generated_image_base64 TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (video_analysis_id) REFERENCES analyzed_videos (id) ON DELETE CASCADE
            );
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_api_keys (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                service_name TEXT NOT NULL, 
                api_key TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                UNIQUE(user_id, service_name)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS pinned_videos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                monitored_channel_id INTEGER NOT NULL,
                youtube_video_id TEXT NOT NULL,
                title TEXT,
                thumbnail_url TEXT,
                pinned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                FOREIGN KEY (monitored_channel_id) REFERENCES monitored_channels (id) ON DELETE CASCADE,
                UNIQUE(user_id, monitored_channel_id, youtube_video_id)
            );
        `);

        // --- CORREÇÃO DO BANCO DE DADOS (MINI-MIGRAÇÃO) ---
        const usersInfo = await db.all("PRAGMA table_info(users)");
        if (!usersInfo.some(c => c.name === 'isApproved')) {
            console.log('MIGRATION: Adding column "isApproved" to "users"...');
            await db.exec('ALTER TABLE users ADD COLUMN isApproved BOOLEAN NOT NULL DEFAULT 0');
        }
        if (!usersInfo.some(c => c.name === 'last_login_at')) {
            console.log('MIGRATION: Adding column "last_login_at" to "users"...');
            await db.exec('ALTER TABLE users ADD COLUMN last_login_at DATETIME');
        }
        if (!usersInfo.some(c => c.name === 'plan')) {
            console.log('MIGRATION: Adding column "plan" to "users"...');
            await db.exec('ALTER TABLE users ADD COLUMN plan TEXT DEFAULT "plan-free"');
        }
        if (!usersInfo.some(c => c.name === 'subscription_plan')) {
            console.log('MIGRATION: Adding column "subscription_plan" to "users"...');
            await db.exec('ALTER TABLE users ADD COLUMN subscription_plan TEXT DEFAULT "plan-free"');
        }

        const analyzedVideosInfo = await db.all("PRAGMA table_info(analyzed_videos)");
        const analyzedVideosColumns = {
            video_url: 'TEXT',
            folder_id: 'INTEGER REFERENCES analysis_folders(id) ON DELETE SET NULL',
            translated_title: 'TEXT',
            original_views: 'INTEGER',
            original_comments: 'INTEGER',
            original_days: 'INTEGER',
            original_thumbnail_url: 'TEXT',
            analysis_data_json: 'TEXT'
        };
        for (const [col, type] of Object.entries(analyzedVideosColumns)) {
            if (!analyzedVideosInfo.some(c => c.name === col)) {
                console.log(`MIGRATION: Adding column "${col}" to "analyzed_videos"...`);
                await db.exec(`ALTER TABLE analyzed_videos ADD COLUMN ${col} ${type}`);
            }
        }

        const generatedTitlesInfo = await db.all("PRAGMA table_info(generated_titles)");
        const generatedTitlesColumns = {
            pontuacao: 'INTEGER DEFAULT 0',
            explicacao: 'TEXT',
            is_checked: 'BOOLEAN DEFAULT 0'
        };
        for (const [col, type] of Object.entries(generatedTitlesColumns)) {
            if (!generatedTitlesInfo.some(c => c.name === col)) {
                console.log(`MIGRATION: Adding column "${col}" to "generated_titles"...`);
                await db.exec(`ALTER TABLE generated_titles ADD COLUMN ${col} ${type}`);
            }
        }
        
        // Criar tabela de limites customizados de armazenamento
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_storage_limits (
                user_id INTEGER PRIMARY KEY,
                custom_limit INTEGER NOT NULL,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            )
        `);
        
        // Criar tabela de créditos por plano
        await db.exec(`
            CREATE TABLE IF NOT EXISTS plan_credits (
                plan_name TEXT PRIMARY KEY,
                monthly_credits INTEGER NOT NULL DEFAULT 0,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Inicializar créditos padrão dos planos
        const defaultPlanCredits = {
            'plan-free': 100,
            'plan-start': 1000,
            'plan-turbo': 2500,
            'plan-master': 5000,
            'plan-start-annual': 1000, // Mensal (12.000/12)
            'plan-turbo-annual': 2500, // Mensal (30.000/12)
            'plan-master-annual': 5000 // Mensal (60.000/12)
        };
        
        for (const [plan, credits] of Object.entries(defaultPlanCredits)) {
            await db.run(`
                INSERT OR IGNORE INTO plan_credits (plan_name, monthly_credits)
                VALUES (?, ?)
            `, [plan, credits]);
        }
        
        // Criar tabela de renovação de créditos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS credit_renewals (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                plan_name TEXT NOT NULL,
                credits_added INTEGER NOT NULL,
                renewal_date DATETIME NOT NULL,
                next_renewal_date DATETIME,
                is_annual BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            )
        `);
        
        // Criar tabela de permissões de planos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS plan_permissions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                plan_name TEXT NOT NULL,
                feature_name TEXT NOT NULL,
                is_allowed BOOLEAN DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(plan_name, feature_name)
            )
        `);
        
        // Criar tabela de notificações
        await db.exec(`
            CREATE TABLE IF NOT EXISTS notifications (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                title TEXT NOT NULL,
                message TEXT NOT NULL,
                type TEXT DEFAULT 'info',
                is_read BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            )
        `);
        
        // Criar tabela de usuários fictícios
        await db.exec(`
            CREATE TABLE IF NOT EXISTS fake_users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                email TEXT NOT NULL,
                type TEXT DEFAULT 'purchase',
                plan_name TEXT DEFAULT NULL,
                is_active BOOLEAN DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Migração: adicionar coluna plan_name se não existir
        try {
            const fakeUsersInfo = await db.all("PRAGMA table_info(fake_users)");
            if (!fakeUsersInfo.some(c => c.name === 'plan_name')) {
                console.log('MIGRATION: Adding column "plan_name" to "fake_users"...');
                await db.exec('ALTER TABLE fake_users ADD COLUMN plan_name TEXT DEFAULT NULL');
            }
        } catch (err) {
            // Ignorar se já existe
        }
        
        // Criar tabela de configurações de notificações
        await db.exec(`
            CREATE TABLE IF NOT EXISTS notification_config (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Criar tabela de loops ativos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS active_loops (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                loop_type TEXT NOT NULL UNIQUE,
                is_active BOOLEAN DEFAULT 0,
                interval_seconds INTEGER DEFAULT 5,
                started_at DATETIME,
                stopped_at DATETIME,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Inicializar permissões padrão
        const defaultFeatures = [
            'video_analyzer',
            'niche_explorer',
            'script_generator',
            'voice_generator',
            'image_generator',
            'video_generator',
            'youtube_integration',
            'api_propria',
            'batch_images',
            'analytics',
            'viral_library'
        ];
        
        const defaultPermissions = {
            'plan-free': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': false,
                'image_generator': false,
                'video_generator': false,
                'youtube_integration': false,
                'api_propria': false,
                'batch_images': false,
                'analytics': true,
                'viral_library': true
            },
            'plan-start': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': false,
                'api_propria': false,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-turbo': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': false,
                'api_propria': false,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-master': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': true,
                'api_propria': true,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-start-annual': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': true,
                'api_propria': true,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-turbo-annual': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': true,
                'api_propria': true,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-master-annual': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': true,
                'api_propria': true,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            }
        };
        
        for (const [plan, features] of Object.entries(defaultPermissions)) {
            for (const [feature, allowed] of Object.entries(features)) {
                await db.run(`
                    INSERT OR IGNORE INTO plan_permissions (plan_name, feature_name, is_allowed)
                    VALUES (?, ?, ?)
                `, [plan, feature, allowed ? 1 : 0]);
            }
        }
        // Migração: Corrigir constraint UNIQUE em monitored_channels (permitir múltiplos canais por usuário)
        try {
            const monitoredChannelsInfo = await db.all("PRAGMA table_info(monitored_channels)");
            const tableExists = monitoredChannelsInfo.length > 0;
            
            if (tableExists) {
                // Verificar schema atual da tabela
                const tableSchema = await db.get("SELECT sql FROM sqlite_master WHERE type='table' AND name='monitored_channels'");
                const schemaSql = (tableSchema?.sql || '').toUpperCase();
                
                console.log('[MIGRATION] Schema atual de monitored_channels:', schemaSql.substring(0, 200));
                
                // Se a constraint UNIQUE está apenas em channel_url (sem user_id), precisamos recriar
                if (schemaSql.includes('CHANNEL_URL') && schemaSql.includes('UNIQUE') && !schemaSql.includes('UNIQUE(USER_ID, CHANNEL_URL)')) {
                    console.log('[MIGRATION] Detectada constraint UNIQUE incorreta. Recriando tabela com UNIQUE(user_id, channel_url)...');
                    try {
                        // Criar nova tabela com constraint correta
                        await db.exec(`CREATE TABLE monitored_channels_new (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            user_id INTEGER NOT NULL,
                            channel_name TEXT NOT NULL,
                            channel_url TEXT NOT NULL,
                            last_checked DATETIME,
                            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                            FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                            UNIQUE(user_id, channel_url)
                        )`);
                        
                        // Copiar dados existentes (ignorar duplicatas se houver)
                        try {
                            await db.exec(`INSERT INTO monitored_channels_new (id, user_id, channel_name, channel_url, last_checked, created_at) 
                                         SELECT id, user_id, channel_name, channel_url, last_checked, created_at 
                                         FROM monitored_channels`);
                            console.log('[MIGRATION] Dados copiados com sucesso.');
                        } catch (copyErr) {
                            console.warn('[MIGRATION] Alguns dados podem ter duplicatas, tentando inserir apenas únicos...', copyErr.message);
                            // Tentar inserir apenas registros únicos
                            const existingChannels = await db.all('SELECT DISTINCT user_id, channel_url, MIN(id) as id, channel_name, last_checked, created_at FROM monitored_channels GROUP BY user_id, channel_url');
                            for (const channel of existingChannels) {
                                try {
                                    await db.run('INSERT INTO monitored_channels_new (id, user_id, channel_name, channel_url, last_checked, created_at) VALUES (?, ?, ?, ?, ?, ?)',
                                        [channel.id, channel.user_id, channel.channel_name, channel.channel_url, channel.last_checked, channel.created_at]);
                                } catch (insErr) {
                                    console.warn(`[MIGRATION] Erro ao inserir canal ${channel.id}:`, insErr.message);
                                }
                            }
                        }
                        
                        // Dropar tabela antiga
                        await db.exec('DROP TABLE monitored_channels');
                        
                        // Renomear nova tabela
                        await db.exec('ALTER TABLE monitored_channels_new RENAME TO monitored_channels');
                        
                        console.log('[MIGRATION] ✅ Tabela monitored_channels recriada com sucesso com constraint UNIQUE(user_id, channel_url).');
                    } catch (recreateErr) {
                        console.error('[MIGRATION] ❌ Erro ao recriar tabela monitored_channels:', recreateErr.message);
                        // Tentar criar índice único como fallback
                        try {
                            await db.exec('CREATE UNIQUE INDEX IF NOT EXISTS idx_monitored_channels_user_url ON monitored_channels(user_id, channel_url)');
                            console.log('[MIGRATION] ✅ Índice único criado como fallback.');
                        } catch (idxErr) {
                            console.warn('[MIGRATION] ⚠️ Não foi possível criar índice único:', idxErr.message);
                        }
                    }
                } else {
                    // Garantir que o índice único correto existe
                    try {
                        await db.exec('CREATE UNIQUE INDEX IF NOT EXISTS idx_monitored_channels_user_url ON monitored_channels(user_id, channel_url)');
                        console.log('[MIGRATION] ✅ Índice único verificado/criado.');
                    } catch (idxErr) {
                        // Índice já existe ou há outro problema, continuar
                        console.log('[MIGRATION] ℹ️ Índice único já existe ou constraint já está correta.');
                    }
                }
            }
        } catch (migErr) {
            console.error('[MIGRATION] ❌ Erro na migração de monitored_channels:', migErr.message);
        }

        const pinnedVideosInfo = await db.all("PRAGMA table_info(pinned_videos)");
        if (!pinnedVideosInfo.some(c => c.name === 'monitored_channel_id')) {
            console.log('MIGRATION: Adding column "monitored_channel_id" to "pinned_videos"...');
            // This is a simplified migration. In a real app, you'd handle existing data.
            await db.exec('DROP TABLE IF EXISTS pinned_videos');
            await db.exec(`
                CREATE TABLE pinned_videos (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    monitored_channel_id INTEGER NOT NULL,
                    youtube_video_id TEXT NOT NULL,
                    title TEXT,
                    thumbnail_url TEXT,
                    pinned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    FOREIGN KEY (monitored_channel_id) REFERENCES monitored_channels (id) ON DELETE CASCADE,
                    UNIQUE(user_id, monitored_channel_id, youtube_video_id)
                );
            `);
        }

        // --- CRIAÇÃO DAS NOVAS TABELAS PARA ANALYTICS, BIBLIOTECA E INTEGRAÇÃO ---
        
        // Sistema de Analytics e Tracking
        await db.exec(`
            CREATE TABLE IF NOT EXISTS video_tracking (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                analysis_id INTEGER,
                youtube_video_id TEXT,
                title_used TEXT,
                thumbnail_used TEXT,
                predicted_ctr REAL,
                predicted_views INTEGER,
                actual_views INTEGER DEFAULT 0,
                actual_ctr REAL DEFAULT 0,
                actual_likes INTEGER DEFAULT 0,
                actual_comments INTEGER DEFAULT 0,
                revenue_estimate REAL DEFAULT 0,
                published_at DATETIME,
                tracked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (analysis_id) REFERENCES analyzed_videos(id) ON DELETE SET NULL
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS analytics_snapshots (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                video_tracking_id INTEGER,
                views INTEGER,
                likes INTEGER,
                comments INTEGER,
                ctr REAL,
                snapshot_date DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (video_tracking_id) REFERENCES video_tracking(id) ON DELETE CASCADE
            );
        `);

        // Biblioteca de Títulos Virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_titles_library (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                title TEXT NOT NULL,
                niche TEXT,
                subniche TEXT,
                original_views INTEGER,
                original_ctr REAL,
                formula_type TEXT,
                keywords TEXT,
                viral_score INTEGER,
                is_favorite INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS title_templates (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                template_name TEXT NOT NULL,
                template_pattern TEXT NOT NULL,
                niche TEXT,
                subniche TEXT,
                usage_count INTEGER DEFAULT 0,
                success_rate REAL DEFAULT 0,
                is_public INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Biblioteca de Thumbnails Virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_thumbnails_library (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                thumbnail_url TEXT,
                thumbnail_description TEXT,
                niche TEXT,
                subniche TEXT,
                original_views INTEGER,
                original_ctr REAL,
                style TEXT,
                elements TEXT,
                viral_score INTEGER,
                is_favorite INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS thumbnail_templates (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                template_name TEXT NOT NULL,
                template_description TEXT NOT NULL,
                niche TEXT,
                subniche TEXT,
                style TEXT,
                usage_count INTEGER DEFAULT 0,
                success_rate REAL DEFAULT 0,
                is_public INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Integração YouTube API
        await db.exec(`
            CREATE TABLE IF NOT EXISTS youtube_integrations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                channel_id TEXT,
                channel_name TEXT,
                access_token TEXT,
                refresh_token TEXT,
                token_expires_at DATETIME,
                is_active INTEGER DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
            
            -- Criar índice para melhor performance (sem UNIQUE para permitir múltiplos canais)
            CREATE INDEX IF NOT EXISTS idx_youtube_integrations_user_channel 
            ON youtube_integrations(user_id, channel_id);
        `);

        // Sistema de Créditos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS api_providers (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                provider TEXT NOT NULL,
                model TEXT NOT NULL,
                api_key TEXT NOT NULL,
                unit_type TEXT NOT NULL DEFAULT 'tokens',
                unit_size INTEGER NOT NULL DEFAULT 1000,
                real_cost_per_unit REAL NOT NULL DEFAULT 0.0,
                credits_per_unit REAL NOT NULL DEFAULT 1.0,
                markup REAL NOT NULL DEFAULT 1.0,
                is_premium INTEGER NOT NULL DEFAULT 0,
                is_active INTEGER NOT NULL DEFAULT 1,
                is_default INTEGER NOT NULL DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_credits (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL UNIQUE,
                balance REAL NOT NULL DEFAULT 0.0,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS credit_transactions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                amount REAL NOT NULL,
                transaction_type TEXT NOT NULL,
                description TEXT,
                admin_id INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (admin_id) REFERENCES users(id)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS credit_usage (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                api_provider_id INTEGER NOT NULL,
                credits_used REAL NOT NULL,
                units_consumed REAL NOT NULL,
                operation_type TEXT NOT NULL,
                details TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (api_provider_id) REFERENCES api_providers(id)
            );
        `);

        // Tabela de configurações da aplicação
        await db.exec(`
            CREATE TABLE IF NOT EXISTS app_settings (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        `);

        // Tabela de preferências do usuário
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_preferences (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL UNIQUE,
                use_credits_instead_of_own_api INTEGER NOT NULL DEFAULT 0,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Inicializar configurações padrão
        try {
            const initialBonus = await db.get("SELECT value FROM app_settings WHERE key = 'initial_bonus_credits'");
            if (!initialBonus) {
                await db.run("INSERT INTO app_settings (key, value) VALUES ('initial_bonus_credits', '0')");
            }
            
            const ttsMultiplier = await db.get("SELECT value FROM app_settings WHERE key = 'tts_credits_multiplier'");
            if (!ttsMultiplier) {
                await db.run("INSERT INTO app_settings (key, value) VALUES ('tts_credits_multiplier', '1.0')");
            }
            
            const laozhangUseAsDefault = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
            if (!laozhangUseAsDefault) {
                await db.run("INSERT INTO app_settings (key, value) VALUES ('laozhang_use_as_default', 'false')");
            }
        } catch (e) {
            console.log('Configurações já inicializadas ou erro:', e);
        }

        // Criar índices para melhor performance
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_user_credits_user_id ON user_credits(user_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_id ON credit_transactions(user_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_user_preferences_user_id ON user_preferences(user_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_transactions_created_at ON credit_transactions(created_at);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_usage_user_id ON credit_usage(user_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_usage_api_provider_id ON credit_usage(api_provider_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_usage_created_at ON credit_usage(created_at);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_api_providers_is_active ON api_providers(is_active);`);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS scheduled_posts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                youtube_integration_id INTEGER,
                video_file_path TEXT,
                title TEXT NOT NULL,
                description TEXT,
                tags TEXT,
                thumbnail_url TEXT,
                scheduled_time DATETIME NOT NULL,
                status TEXT DEFAULT 'pending',
                published_video_id TEXT,
                error_message TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (youtube_integration_id) REFERENCES youtube_integrations(id) ON DELETE CASCADE
            );
        `);

        // === PARTE 2: TABELAS PARA MONITORAMENTO AUTOMÁTICO ===
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_alerts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                competitor_channel_id TEXT,
                competitor_channel_name TEXT,
                video_id TEXT NOT NULL,
                video_title TEXT,
                video_url TEXT,
                views INTEGER,
                views_per_day REAL,
                detected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                notified INTEGER DEFAULT 0,
                notified_at DATETIME,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS trend_analysis (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                niche TEXT,
                subniche TEXT,
                video_id TEXT NOT NULL,
                video_title TEXT,
                video_url TEXT,
                channel_id TEXT,
                channel_name TEXT,
                views INTEGER,
                views_per_day REAL,
                detected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                analyzed INTEGER DEFAULT 0,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS competitor_monitoring (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                competitor_channel_id TEXT NOT NULL,
                competitor_channel_name TEXT,
                niche TEXT,
                subniche TEXT,
                auto_analyze INTEGER DEFAULT 1,
                last_checked DATETIME,
                check_frequency TEXT DEFAULT 'daily',
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                UNIQUE(user_id, competitor_channel_id)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS ai_suggestions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                suggestion_type TEXT NOT NULL,
                title TEXT,
                description TEXT,
                niche TEXT,
                subniche TEXT,
                reason TEXT,
                priority INTEGER DEFAULT 5,
                viewed INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Tabela para agentes de roteiro
        await db.exec(`
            CREATE TABLE IF NOT EXISTS script_agents (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                agent_name TEXT NOT NULL,
                niche TEXT,
                subniche TEXT,
                source_video_id TEXT,
                source_video_url TEXT,
                source_video_title TEXT,
                full_transcript TEXT,
                agent_prompt TEXT,
                agent_instructions TEXT,
                viral_formula_json TEXT,
                usage_count INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Garantir que a coluna viral_formula_json exista (migração suave)
        try {
            await db.run(`ALTER TABLE script_agents ADD COLUMN viral_formula_json TEXT`);
            console.log('[DB] Coluna viral_formula_json adicionada à tabela script_agents.');
        } catch (columnErr) {
            if (!/duplicate column name/i.test(columnErr.message)) {
                throw columnErr;
            }
        }

        // Tabela para roteiros gerados
        await db.exec(`
            CREATE TABLE IF NOT EXISTS generated_scripts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                script_agent_id INTEGER,
                title TEXT NOT NULL,
                script_content TEXT NOT NULL,
                model_used TEXT,
                niche TEXT,
                subniche TEXT,
                optimization_score REAL,
                optimization_report TEXT,
                retention_score REAL,
                authenticity_score REAL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (script_agent_id) REFERENCES script_agents(id) ON DELETE SET NULL
            );
        `);

        // Tabela para Agentes Virais (seguindo modelo Claude AI)
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_agents (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                description TEXT,
                memory TEXT,
                instructions TEXT,
                model TEXT DEFAULT 'gpt-4o',
                is_favorite BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        // Adicionar coluna model se não existir (migração)
        try {
            await db.run(`ALTER TABLE viral_agents ADD COLUMN model TEXT DEFAULT 'gpt-4o'`);
            console.log('[DB] Coluna model adicionada à tabela viral_agents.');
        } catch (columnErr) {
            if (!/duplicate column name/i.test(columnErr.message)) {
                throw columnErr;
            }
        }

        // Tabela para arquivos dos agentes virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_agent_files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                agent_id INTEGER NOT NULL,
                file_name TEXT NOT NULL,
                file_content TEXT,
                file_type TEXT,
                file_size INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (agent_id) REFERENCES viral_agents(id) ON DELETE CASCADE
            );
        `);

        // Tabela para conversas com agentes virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_agent_conversations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                agent_id INTEGER NOT NULL,
                user_id INTEGER NOT NULL,
                title TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (agent_id) REFERENCES viral_agents(id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Tabela para mensagens das conversas
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_agent_messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                conversation_id INTEGER NOT NULL,
                role TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (conversation_id) REFERENCES viral_agent_conversations(id) ON DELETE CASCADE
            );
        `);

        // Tabela para histórico de prompts de cena
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS video_operations_cache (
                operation_id TEXT PRIMARY KEY,
                user_id INTEGER NOT NULL,
                api_key_source TEXT NOT NULL,
                user_key_id INTEGER,
                admin_api_id INTEGER,
                use_laozhang INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        console.log('✅ Novas tabelas criadas: Analytics, Biblioteca, Integração YouTube, Agentes de Roteiro e Histórico de Prompts de Cena');
        
        // === MIGRAÇÃO: Remover constraint UNIQUE de youtube_integrations (permitir múltiplos canais) ===
        try {
            const tableInfo = await db.all("PRAGMA table_info(youtube_integrations)");
            const indexes = await db.all("PRAGMA index_list(youtube_integrations)");
            
            // Verificar se existe constraint UNIQUE (através de índices únicos)
            const uniqueIndexes = indexes.filter(idx => idx.unique === 1);
            if (uniqueIndexes.length > 0) {
                console.log('MIGRATION: Removendo constraint UNIQUE de youtube_integrations para permitir múltiplos canais...');
                
                // Recriar tabela sem UNIQUE
                await db.exec(`
                    CREATE TABLE IF NOT EXISTS youtube_integrations_new (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        channel_id TEXT,
                        channel_name TEXT,
                        access_token TEXT,
                        refresh_token TEXT,
                        token_expires_at DATETIME,
                        is_active INTEGER DEFAULT 1,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                    );
                `);
                
                await db.exec(`INSERT INTO youtube_integrations_new SELECT * FROM youtube_integrations;`);
                await db.exec(`DROP TABLE youtube_integrations;`);
                await db.exec(`ALTER TABLE youtube_integrations_new RENAME TO youtube_integrations;`);
                
                // Criar índice não-único para performance
                await db.exec(`
                    CREATE INDEX IF NOT EXISTS idx_youtube_integrations_user_channel 
                    ON youtube_integrations(user_id, channel_id);
                `);
                
                console.log('✅ Migração concluída: múltiplos canais agora são permitidos');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migração de youtube_integrations:', migrationErr.message);
        }

        // === MIGRAÇÃO: Adicionar campos niche e subniche em youtube_integrations ===
        try {
            const youtubeIntegrationsInfo = await db.all("PRAGMA table_info(youtube_integrations)");
            const hasNiche = youtubeIntegrationsInfo.some(c => c.name === 'niche');
            const hasSubniche = youtubeIntegrationsInfo.some(c => c.name === 'subniche');
            
            if (!hasNiche) {
                console.log('MIGRATION: Adicionando coluna "niche" em youtube_integrations...');
                await db.exec(`ALTER TABLE youtube_integrations ADD COLUMN niche TEXT`);
            }
            if (!hasSubniche) {
                console.log('MIGRATION: Adicionando coluna "subniche" em youtube_integrations...');
                await db.exec(`ALTER TABLE youtube_integrations ADD COLUMN subniche TEXT`);
            }
            if (!hasNiche || !hasSubniche) {
                console.log('✅ Migração concluída: campos niche e subniche adicionados em youtube_integrations');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migração de youtube_integrations (niche/subniche):', migrationErr.message);
        }
        
        // === MIGRAÇÃO: Adicionar colunas de otimização em generated_scripts ===
        try {
            const scriptsInfo = await db.all("PRAGMA table_info(generated_scripts)");
            const hasOptimizationScore = scriptsInfo.some(c => c.name === 'optimization_score');
            const hasOptimizationReport = scriptsInfo.some(c => c.name === 'optimization_report');
            const hasRetentionScore = scriptsInfo.some(c => c.name === 'retention_score');
            const hasAuthenticityScore = scriptsInfo.some(c => c.name === 'authenticity_score');
            
            if (!hasOptimizationScore) {
                console.log('MIGRATION: Adicionando coluna "optimization_score" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN optimization_score REAL`);
            }
            if (!hasOptimizationReport) {
                console.log('MIGRATION: Adicionando coluna "optimization_report" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN optimization_report TEXT`);
            }
            if (!hasRetentionScore) {
                console.log('MIGRATION: Adicionando coluna "retention_score" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN retention_score REAL`);
            }
            if (!hasAuthenticityScore) {
                console.log('MIGRATION: Adicionando coluna "authenticity_score" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN authenticity_score REAL`);
            }
            if (!hasOptimizationScore || !hasOptimizationReport || !hasRetentionScore || !hasAuthenticityScore) {
                console.log('✅ Migração concluída: campos de otimização adicionados em generated_scripts');
            }
            
            // Verificar e adicionar colunas duration_minutes e language se não existirem
            const hasDurationMinutes = tableInfo.some(col => col.name === 'duration_minutes');
            const hasLanguage = tableInfo.some(col => col.name === 'language');
            
            if (!hasDurationMinutes) {
                console.log('MIGRATION: Adicionando coluna "duration_minutes" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN duration_minutes INTEGER`);
            }
            if (!hasLanguage) {
                console.log('MIGRATION: Adicionando coluna "language" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN language TEXT`);
            }
            if (!hasDurationMinutes || !hasLanguage) {
                console.log('✅ Migração concluída: campos duration_minutes e language adicionados em generated_scripts');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migração de generated_scripts (optimization):', migrationErr.message);
        }
        
        // === MIGRAÇÃO: Corrigir tabela viral_thumbnails_library ===
        try {
            const thumbnailsInfo = await db.all("PRAGMA table_info(viral_thumbnails_library)");
            const thumbnailUrlColumn = thumbnailsInfo.find(c => c.name === 'thumbnail_url');
            if (thumbnailUrlColumn && thumbnailUrlColumn.notnull === 1) {
                console.log('MIGRATION: Corrigindo constraint NOT NULL em viral_thumbnails_library.thumbnail_url...');
                // SQLite não suporta ALTER TABLE para remover NOT NULL diretamente
                // Vamos recriar a tabela sem o NOT NULL
                await db.exec(`
                    CREATE TABLE IF NOT EXISTS viral_thumbnails_library_new (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER,
                        thumbnail_url TEXT,
                        thumbnail_description TEXT,
                        niche TEXT,
                        subniche TEXT,
                        original_views INTEGER,
                        original_ctr REAL,
                        style TEXT,
                        elements TEXT,
                        viral_score INTEGER,
                        is_favorite INTEGER DEFAULT 0,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                    );
                `);
                await db.exec(`INSERT INTO viral_thumbnails_library_new SELECT * FROM viral_thumbnails_library;`);
                await db.exec(`DROP TABLE viral_thumbnails_library;`);
                await db.exec(`ALTER TABLE viral_thumbnails_library_new RENAME TO viral_thumbnails_library;`);
                console.log('✅ Migração concluída: thumbnail_url agora é opcional');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migração de viral_thumbnails_library:', migrationErr.message);
        }

        // === TABELA DE CANAIS DO USUÁRIO ===
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_channels (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                channel_name TEXT NOT NULL,
                channel_url TEXT,
                channel_id TEXT,
                niche TEXT,
                language TEXT DEFAULT 'pt-BR',
                country TEXT DEFAULT 'BR',
                is_active INTEGER DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                UNIQUE(user_id, channel_name)
            );
        `);

        // Adicionar coluna channel_id na tabela video_tracking se não existir
        try {
            const trackingInfo = await db.all("PRAGMA table_info(video_tracking)");
            if (!trackingInfo.some(c => c.name === 'channel_id')) {
                console.log('MIGRATION: Adicionando coluna channel_id em video_tracking...');
                await db.exec('ALTER TABLE video_tracking ADD COLUMN channel_id INTEGER REFERENCES user_channels(id) ON DELETE SET NULL');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migração de video_tracking:', migrationErr.message);
        }
        // Adicionar coluna full_transcript na tabela analyzed_videos se não existir
        try {
            const analyzedVideosInfo = await db.all("PRAGMA table_info(analyzed_videos)");
            if (!analyzedVideosInfo.some(c => c.name === 'full_transcript')) {
                console.log('MIGRATION: Adicionando coluna full_transcript em analyzed_videos...');
                await db.exec('ALTER TABLE analyzed_videos ADD COLUMN full_transcript TEXT');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migração de analyzed_videos (full_transcript):', migrationErr.message);
        }
        
        console.log('Tabelas e colunas sincronizadas.');

        // --- CRIAÇÃO DO ADMIN ---
        const adminEmail = 'rudysilvaads@gmail.com';
        const adminPassword = '253031';
        
        const adminExists = await db.get('SELECT * FROM users WHERE email = ?', [adminEmail]);
        
        if (!adminExists) {
            console.log('Criando utilizador administrador...');
            const salt = await bcrypt.genSalt(10);
            const admin_pass_hash = await bcrypt.hash(adminPassword, salt);
            
            await db.run(
                'INSERT INTO users (name, email, whatsapp, password_hash, isAdmin, isApproved) VALUES (?, ?, ?, ?, ?, ?)',
                ['Admin Core', adminEmail, '(00) 00000-0000', admin_pass_hash, 1, 1]
            );
            console.log('Utilizador administrador criado com sucesso!');
        } else {
            await db.run('UPDATE users SET isAdmin = 1, isBlocked = 0, isApproved = 1 WHERE email = ?', [adminEmail]);
            console.log('Utilizador administrador já existe. Status verificado.');
        }

        console.log('✅ Banco de dados inicializado com sucesso!');
        await rehydratePendingVideoOperations();
        
        // Sinalizar que o banco está pronto
        global.dbReady = true;

    } catch (err) {
        console.error('Erro ao conectar ou inicializar o banco de dados:', err);
        global.dbReady = false;
    }
})();


// --- ROTAS DE API ---
// ================================================
// ROTAS DE NOTIFICAÇÕES
// ================================================

// GET /api/notifications/pending - Obter notificações pendentes do usuário
app.get('/api/notifications/pending', authenticateToken, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS notifications (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    title TEXT NOT NULL,
                    message TEXT NOT NULL,
                    type TEXT DEFAULT 'info',
                    is_read BOOLEAN DEFAULT 0,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const notifications = await db.all(
            'SELECT * FROM notifications WHERE (user_id IS NULL OR user_id = ?) AND is_read = 0 ORDER BY created_at DESC LIMIT 10',
            [req.user.id]
        );
        res.json(notifications);
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao buscar notificações:', error);
        res.status(500).json({ message: 'Erro ao buscar notificações: ' + error.message });
    }
});

// POST /api/notifications/:id/read - Marcar notificação como lida
app.post('/api/notifications/:id/read', authenticateToken, async (req, res) => {
    try {
        await db.run('UPDATE notifications SET is_read = 1 WHERE id = ?', [req.params.id]);
        res.json({ success: true });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao marcar notificação como lida:', error);
        res.status(500).json({ message: 'Erro ao marcar notificação como lida' });
    }
});

// POST /api/admin/notifications/create - Criar notificação (admin)
app.post('/api/admin/notifications/create', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { title, message, type = 'info', user_id = null } = req.body;
        
        if (!title || !message) {
            return res.status(400).json({ message: 'Título e mensagem são obrigatórios' });
        }
        
        await db.run(
            'INSERT INTO notifications (user_id, title, message, type) VALUES (?, ?, ?, ?)',
            [user_id, title, message, type]
        );
        
        res.json({ success: true, message: 'Notificação criada com sucesso' });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao criar notificação:', error);
        res.status(500).json({ message: 'Erro ao criar notificação' });
    }
});

// GET /api/admin/notifications/config - Obter configurações de notificações
app.get('/api/admin/notifications/config', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS notification_config (
                    key TEXT PRIMARY KEY,
                    value TEXT NOT NULL,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const configs = await db.all('SELECT * FROM notification_config');
        const config = {};
        configs.forEach(c => {
            config[c.key] = c.value;
        });
        
        // Valores padrão
        res.json({
            purchase_enabled: config.purchase_enabled === 'true',
            purchase_interval: parseInt(config.purchase_interval) || 5,
            purchase_message: config.purchase_message || '🎉 {name} acabou de comprar o plano {plan}!',
            user_enabled: config.user_enabled === 'true',
            user_interval: parseInt(config.user_interval) || 5,
            user_message: config.user_message || '👋 {name} acabou de se cadastrar na plataforma!'
        });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao buscar configurações:', error);
        res.status(500).json({ message: 'Erro ao buscar configurações: ' + error.message });
    }
});

// POST /api/admin/notifications/config - Salvar configurações de notificações
app.post('/api/admin/notifications/config', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS notification_config (
                    key TEXT PRIMARY KEY,
                    value TEXT NOT NULL,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const { purchase_enabled, purchase_interval, purchase_message, user_enabled, user_interval, user_message } = req.body;
        
        const configs = [
            { key: 'purchase_enabled', value: String(purchase_enabled || false) },
            { key: 'purchase_interval', value: String(purchase_interval || 5) },
            { key: 'purchase_message', value: purchase_message || '🎉 {name} acabou de comprar o plano {plan}!' },
            { key: 'user_enabled', value: String(user_enabled || false) },
            { key: 'user_interval', value: String(user_interval || 5) },
            { key: 'user_message', value: user_message || '👋 {name} acabou de se cadastrar na plataforma!' }
        ];
        
        for (const config of configs) {
            await db.run(
                'INSERT OR REPLACE INTO notification_config (key, value, updated_at) VALUES (?, ?, CURRENT_TIMESTAMP)',
                [config.key, config.value]
            );
        }
        
        res.json({ success: true, message: 'Configurações salvas com sucesso' });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao salvar configurações:', error);
        res.status(500).json({ message: 'Erro ao salvar configurações: ' + error.message });
    }
});

// GET /api/admin/notifications/fake-users - Listar usuários fictícios
app.get('/api/admin/notifications/fake-users', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS fake_users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    email TEXT NOT NULL,
                    type TEXT DEFAULT 'purchase',
                    is_active BOOLEAN DEFAULT 1,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const users = await db.all('SELECT * FROM fake_users ORDER BY created_at DESC');
        res.json(users);
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao listar usuários fictícios:', error);
        res.status(500).json({ message: 'Erro ao listar usuários fictícios: ' + error.message });
    }
});

// POST /api/admin/notifications/fake-users - Criar usuário fictício
app.post('/api/admin/notifications/fake-users', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS fake_users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    email TEXT NOT NULL,
                    type TEXT DEFAULT 'purchase',
                    plan_name TEXT DEFAULT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const { name, email, type = 'purchase', plan_name = null, bulk = false } = req.body;
        
        if (bulk && Array.isArray(req.body.users)) {
            // Criar múltiplos usuários
            const results = [];
            for (const user of req.body.users) {
                try {
                    const result = await db.run(
                        'INSERT INTO fake_users (name, email, type, plan_name) VALUES (?, ?, ?, ?)',
                        [user.name, user.email, user.type, user.plan_name || null]
                    );
                    results.push({ id: result.lastID, email: user.email });
                } catch (err) {
                    console.error(`[NOTIFICATIONS] Erro ao criar usuário ${user.email}:`, err);
                }
            }
            res.json({ success: true, created: results.length, message: `${results.length} usuários fictícios criados com sucesso` });
        } else {
            if (!name || !email) {
                return res.status(400).json({ message: 'Nome e email são obrigatórios' });
            }
            
            const result = await db.run(
                'INSERT INTO fake_users (name, email, type, plan_name) VALUES (?, ?, ?, ?)',
                [name, email, type, plan_name]
            );
            
            res.json({ success: true, id: result.lastID, message: 'Usuário fictício criado com sucesso' });
        }
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao criar usuário fictício:', error);
        res.status(500).json({ message: 'Erro ao criar usuário fictício: ' + error.message });
    }
});

// DELETE /api/admin/notifications/fake-users/:id - Deletar usuário fictício
app.delete('/api/admin/notifications/fake-users/:id', authenticateToken, isAdmin, async (req, res) => {
    try {
        await db.run('DELETE FROM fake_users WHERE id = ?', [req.params.id]);
        res.json({ success: true, message: 'Usuário fictício deletado com sucesso' });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao deletar usuário fictício:', error);
        res.status(500).json({ message: 'Erro ao deletar usuário fictício' });
    }
});

// POST /api/admin/notifications/loop/start - Iniciar loop de notificações
app.post('/api/admin/notifications/loop/start', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { loop_type, interval_seconds } = req.body;
        
        if (!loop_type || (loop_type !== 'purchase' && loop_type !== 'user')) {
            return res.status(400).json({ message: 'Tipo de loop inválido. Use "purchase" ou "user"' });
        }
        
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS active_loops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    loop_type TEXT NOT NULL UNIQUE,
                    is_active BOOLEAN DEFAULT 0,
                    interval_seconds INTEGER DEFAULT 5,
                    started_at DATETIME,
                    stopped_at DATETIME,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        await db.run(
            'INSERT OR REPLACE INTO active_loops (loop_type, is_active, interval_seconds, started_at, updated_at) VALUES (?, 1, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)',
            [loop_type, interval_seconds || 5]
        );
        
        console.log(`[NOTIFICATIONS] Loop ${loop_type} iniciado e salvo no banco de dados`);
        res.json({ success: true, message: `Loop ${loop_type} iniciado com sucesso` });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao iniciar loop:', error);
        res.status(500).json({ message: 'Erro ao iniciar loop: ' + error.message });
    }
});

// POST /api/admin/notifications/loop/stop - Parar loop de notificações
app.post('/api/admin/notifications/loop/stop', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { loop_type } = req.body;
        
        if (!loop_type || (loop_type !== 'purchase' && loop_type !== 'user')) {
            return res.status(400).json({ message: 'Tipo de loop inválido. Use "purchase" ou "user"' });
        }
        
        await db.run(
            'UPDATE active_loops SET is_active = 0, stopped_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP WHERE loop_type = ?',
            [loop_type]
        );
        
        // Parar o loop imediatamente
        if (notificationLoops[loop_type]) {
            clearInterval(notificationLoops[loop_type]);
            notificationLoops[loop_type] = null;
        }
        
        console.log(`[NOTIFICATIONS] Loop ${loop_type} parado e salvo no banco de dados`);
        res.json({ success: true, message: `Loop ${loop_type} parado com sucesso` });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao parar loop:', error);
        res.status(500).json({ message: 'Erro ao parar loop: ' + error.message });
    }
});

// GET /api/admin/notifications/loop/status - Verificar status dos loops
app.get('/api/admin/notifications/loop/status', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS active_loops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    loop_type TEXT NOT NULL UNIQUE,
                    is_active BOOLEAN DEFAULT 0,
                    interval_seconds INTEGER DEFAULT 5,
                    started_at DATETIME,
                    stopped_at DATETIME,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const loops = await db.all('SELECT * FROM active_loops');
        const status = {
            purchase: { is_active: false, interval_seconds: 5 },
            user: { is_active: false, interval_seconds: 5 }
        };
        
        loops.forEach(loop => {
            if (loop.loop_type === 'purchase' || loop.loop_type === 'user') {
                status[loop.loop_type] = {
                    is_active: loop.is_active === 1,
                    interval_seconds: loop.interval_seconds,
                    started_at: loop.started_at,
                    stopped_at: loop.stopped_at
                };
            }
        });
        
        res.json(status);
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao verificar status dos loops:', error);
        res.status(500).json({ message: 'Erro ao verificar status dos loops: ' + error.message });
    }
});

// ================================================
// SISTEMA DE PERMISSÕES DE PLANOS
// ================================================

// Middleware para verificar permissão de funcionalidade
function checkPlanPermission(featureName) {
    return async (req, res, next) => {
        try {
            const userId = req.user.id;
            
            // Admin sempre tem acesso
            const user = await db.get('SELECT isAdmin FROM users WHERE id = ?', [userId]);
            if (user && (user.isAdmin === 1 || user.isAdmin === true || String(user.isAdmin) === '1')) {
                return next();
            }
            
            // Obter plano do usuário
            const userData = await db.get('SELECT plan, subscription_plan FROM users WHERE id = ?', [userId]);
            if (!userData) {
                return res.status(403).json({ message: 'Usuário não encontrado' });
            }
            
            const planName = userData.subscription_plan || userData.plan || 'plan-free';
            
            // Verificar permissão
            const permission = await db.get(
                'SELECT is_allowed FROM plan_permissions WHERE plan_name = ? AND feature_name = ?',
                [planName, featureName]
            );
            
            if (!permission || permission.is_allowed === 0) {
                return res.status(403).json({ 
                    message: `Esta funcionalidade não está disponível no seu plano atual.`,
                    feature: featureName,
                    plan: planName
                });
            }
            
            next();
        } catch (error) {
            console.error('[PERMISSIONS] Erro ao verificar permissão:', error);
            res.status(500).json({ message: 'Erro ao verificar permissão' });
        }
    };
}

// GET /api/admin/plan-permissions - Listar todas as permissões
app.get('/api/admin/plan-permissions', authenticateToken, isAdmin, async (req, res) => {
    try {
        const permissions = await db.all(`
            SELECT pp.*, pc.monthly_credits
            FROM plan_permissions pp
            LEFT JOIN plan_credits pc ON pp.plan_name = pc.plan_name
            ORDER BY pp.plan_name, pp.feature_name
        `);
        
        // Organizar por plano
        const organized = {};
        permissions.forEach(p => {
            if (!organized[p.plan_name]) {
                organized[p.plan_name] = {
                    plan_name: p.plan_name,
                    monthly_credits: p.monthly_credits || 0,
                    features: {}
                };
            }
            organized[p.plan_name].features[p.feature_name] = p.is_allowed === 1;
        });
        
        res.json(organized);
    } catch (error) {
        console.error('[PERMISSIONS] Erro ao listar permissões:', error);
        res.status(500).json({ message: 'Erro ao listar permissões' });
    }
});

// PUT /api/admin/plan-permissions/:planName/:featureName - Atualizar permissão
app.put('/api/admin/plan-permissions/:planName/:featureName', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { planName, featureName } = req.params;
        const { is_allowed } = req.body;
        
        await db.run(`
            INSERT OR REPLACE INTO plan_permissions (plan_name, feature_name, is_allowed, updated_at)
            VALUES (?, ?, ?, CURRENT_TIMESTAMP)
        `, [planName, featureName, is_allowed ? 1 : 0]);
        
        res.json({ success: true, message: 'Permissão atualizada com sucesso' });
    } catch (error) {
        console.error('[PERMISSIONS] Erro ao atualizar permissão:', error);
        res.status(500).json({ message: 'Erro ao atualizar permissão' });
    }
});

// PUT /api/admin/plan-credits/:planName - Atualizar créditos do plano
app.put('/api/admin/plan-credits/:planName', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { planName } = req.params;
        const { monthly_credits } = req.body;
        
        if (!monthly_credits || monthly_credits < 0) {
            return res.status(400).json({ message: 'Créditos mensais inválidos' });
        }
        
        await db.run(`
            INSERT OR REPLACE INTO plan_credits (plan_name, monthly_credits, updated_at)
            VALUES (?, ?, CURRENT_TIMESTAMP)
        `, [planName, monthly_credits]);
        
        res.json({ success: true, message: 'Créditos do plano atualizados com sucesso' });
    } catch (error) {
        console.error('[PLAN CREDITS] Erro ao atualizar créditos:', error);
        res.status(500).json({ message: 'Erro ao atualizar créditos' });
    }
});

// GET /api/user/permissions - Obter permissões do usuário atual
app.get('/api/user/permissions', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        
        // Admin sempre tem todas as permissões
        const user = await db.get('SELECT isAdmin FROM users WHERE id = ?', [userId]);
        if (user && (user.isAdmin === 1 || user.isAdmin === true || String(user.isAdmin) === '1')) {
            const allFeatures = ['video_analyzer', 'niche_explorer', 'script_generator', 'voice_generator', 
                               'image_generator', 'video_generator', 'youtube_integration', 'api_propria', 
                               'batch_images', 'analytics', 'viral_library'];
            const permissions = {};
            allFeatures.forEach(f => permissions[f] = true);
            return res.json({ permissions, plan: 'admin' });
        }
        
        // Obter plano do usuário
        const userData = await db.get('SELECT plan, subscription_plan FROM users WHERE id = ?', [userId]);
        const planName = userData?.subscription_plan || userData?.plan || 'plan-free';
        
        // Obter permissões
        const perms = await db.all(
            'SELECT feature_name, is_allowed FROM plan_permissions WHERE plan_name = ?',
            [planName]
        );
        
        const permissions = {};
        perms.forEach(p => {
            permissions[p.feature_name] = p.is_allowed === 1;
        });
        
        res.json({ permissions, plan: planName });
    } catch (error) {
        console.error('[PERMISSIONS] Erro ao obter permissões:', error);
        res.status(500).json({ message: 'Erro ao obter permissões' });
    }
});

// NOTA: Todas as rotas devem ser definidas ANTES do app.listen() para funcionarem corretamente

// === ROTAS DE AUTENTICAÇÃO ===

app.post('/api/auth/register', async (req, res) => {
    const { name, email, whatsapp, password } = req.body;

    if (!name || !email || !password) {
        return res.status(400).json({ msg: 'Por favor, preencha todos os campos obrigatórios.' });
    }

    try {
        const userExists = await db.get('SELECT * FROM users WHERE email = ?', [email]);
        if (userExists) {
            return res.status(400).json({ msg: 'Este e-mail já está registado.' });
        }

        const salt = await bcrypt.genSalt(10);
        const password_hash = await bcrypt.hash(password, salt);

        const result = await db.run(
            'INSERT INTO users (name, email, whatsapp, password_hash) VALUES (?, ?, ?, ?)',
            [name, email, whatsapp, password_hash]
        );
        
        const userId = result.lastID;
        
        // Inicializar saldo de créditos para novo usuário com bônus inicial
        try {
            const bonusSetting = await db.get("SELECT value FROM app_settings WHERE key = 'initial_bonus_credits'");
            const bonusAmount = bonusSetting ? parseFloat(bonusSetting.value) : 0;

            if (bonusAmount > 0) {
                await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, ?)', [userId, bonusAmount]);
                await db.run(
                    'INSERT INTO credit_transactions (user_id, amount, transaction_type, description, admin_id) VALUES (?, ?, ?, ?, NULL)',
                    [userId, bonusAmount, 'credit', 'Bônus de boas-vindas']
                );
                console.log(`✅ Créditos bônus iniciais (${bonusAmount}) adicionados para novo usuário ${email}`);
            } else {
                await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [userId]);
            }
        } catch (creditError) {
            console.error('⚠️ Erro ao inicializar créditos para novo usuário:', creditError);
        }

        // Enviar email de boas-vindas
        try {
            // Priorizar variável de ambiente, depois header, depois req.get('host')
            const baseUrl = process.env.BASE_URL || process.env.APP_URL || process.env.PUBLIC_URL;
            let loginUrl;
            
            if (baseUrl) {
                loginUrl = `${baseUrl.replace(/\/$/, '')}/la-casa-dark-core-auth.html`;
            } else {
                const protocol = req.protocol || (req.get('x-forwarded-proto') || 'http');
                const host = req.get('x-forwarded-host') || req.get('host') || 'localhost:5001';
                loginUrl = `${protocol}://${host}/la-casa-dark-core-auth.html`;
            }
            
            await sendTemplateEmail('register', email, {
                nome: name,
                email: email,
                creditos_iniciais: bonusAmount || 0,
                link_acesso: loginUrl
            });
        } catch (emailError) {
            console.error('[EMAIL] Erro ao enviar email de boas-vindas:', emailError.message);
            // Não falhar o registro se o email falhar
        }

        res.status(201).json({ msg: 'Utilizador registado com sucesso! A aguardar aprovação.', userId: userId });

    } catch (err) {
        console.error('Erro no registo:', err);
        res.status(500).json({ msg: 'Erro no servidor ao tentar registar.' });
    }
});

app.post('/api/auth/login', async (req, res) => {
    // Verificar se o banco de dados está inicializado
    if (!db) {
        return res.status(503).json({ msg: 'Servidor ainda não está pronto. Aguarde alguns instantes e tente novamente.' });
    }

    const { email, password } = req.body;

    if (!email || !password) {
        return res.status(400).json({ msg: 'Por favor, forneça e-mail e senha.' });
    }

    try {
        const user = await db.get('SELECT * FROM users WHERE email = ?', [email]);
        if (!user) {
            return res.status(400).json({ msg: 'Credenciais inválidas.' });
        }

        if (user.isBlocked) {
            return res.status(403).json({ msg: 'Esta conta está bloqueada. Entre em contacto com o suporte.' });
        }

        if (!user.isApproved && !user.isAdmin) {
            return res.status(403).json({ msg: 'A sua conta está pendente de aprovação.' });
        }

        const isMatch = await bcrypt.compare(password, user.password_hash);
        if (!isMatch) {
            return res.status(400).json({ msg: 'Credenciais inválidas.' });
        }

        await db.run('UPDATE users SET last_login_at = CURRENT_TIMESTAMP WHERE id = ?', [user.id]);

        const token = jwt.sign(
            { id: user.id, email: user.email, isAdmin: user.isAdmin },
            JWT_SECRET,
            { expiresIn: '8h' }
        );

        res.json({
            msg: 'Login feito com sucesso!',
            token,
            isAdmin: user.isAdmin
        });

    } catch (err) {
        console.error('Erro no login:', err);
        res.status(500).json({ msg: 'Erro no servidor durante o login.' });
    }
});

app.get('/api/auth/me', authenticateToken, async (req, res) => {
    try {
        const user = await db.get('SELECT id, name, email, whatsapp, isAdmin, isBlocked, plan, subscription_plan FROM users WHERE id = ?', [req.user.id]);
        
        if (!user) {
            return res.status(404).json({ msg: 'Utilizador não encontrado.' });
        }
        
        if (user.isBlocked) {
             return res.status(403).json({ msg: 'A sua conta foi bloqueada.' });
        }
        
        res.json(user);

    } catch (err) {
        console.error('Erro ao buscar dados do utilizador (/me):', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Rota para solicitar reset de senha
app.post('/api/auth/forgot-password', async (req, res) => {
    console.log('[AUTH] ========== SOLICITAÇÃO DE RESET DE SENHA ==========');
    console.log('[AUTH] Recebida requisição POST /api/auth/forgot-password');
    console.log('[AUTH] Body recebido:', JSON.stringify(req.body));
    
    const { email } = req.body;

    if (!email) {
        console.log('[AUTH] ❌ Email não fornecido');
        return res.status(400).json({ msg: 'Por favor, forneça um email.' });
    }

    console.log(`[AUTH] 📧 Processando reset de senha para: ${email}`);

    try {
        // Verificar se o usuário existe
        console.log('[AUTH] 🔍 Buscando usuário no banco de dados...');
        const user = await db.get('SELECT id, name, email FROM users WHERE email = ?', [email]);
        
        // Sempre retornar sucesso (por segurança, não revelar se o email existe ou não)
        const successMessage = 'Se este email estiver cadastrado, um link de reset será enviado!';
        
        if (user) {
            console.log(`[AUTH] ✅ Usuário encontrado: ${user.name} (ID: ${user.id})`);
            
            // Gerar token de reset (válido por 1 hora)
            console.log('[AUTH] 🔑 Gerando token de reset...');
            const resetToken = jwt.sign(
                { userId: user.id, type: 'password_reset' },
                JWT_SECRET,
                { expiresIn: '1h' }
            );
            console.log('[AUTH] ✅ Token gerado com sucesso');
            
            // Salvar token no banco de dados
            console.log('[AUTH] 💾 Salvando token no banco de dados...');
            await db.run(
                'INSERT OR REPLACE INTO password_reset_tokens (user_id, token, expires_at) VALUES (?, ?, datetime("now", "+1 hour"))',
                [user.id, resetToken]
            );
            console.log('[AUTH] ✅ Token salvo no banco de dados');
            
            // Construir URL de reset
            // Priorizar variável de ambiente, depois header X-Forwarded-Host, depois req.get('host')
            const baseUrl = process.env.BASE_URL || process.env.APP_URL || process.env.PUBLIC_URL;
            let resetUrl;
            
            if (baseUrl) {
                // Usar URL base configurada
                resetUrl = `${baseUrl.replace(/\/$/, '')}/la-casa-dark-core-auth.html?reset_token=${resetToken}`;
                console.log(`[AUTH] 🔗 Usando URL base configurada: ${baseUrl}`);
            } else {
                // Tentar detectar automaticamente
                const protocol = req.protocol || (req.get('x-forwarded-proto') || 'http');
                let host = req.get('x-forwarded-host') || req.get('host');
                
                // Se não tiver host, tentar usar o hostname da requisição
                if (!host) {
                    host = req.hostname || 'localhost:5001';
                    // Adicionar porta se não estiver no hostname
                    if (!host.includes(':') && req.socket && req.socket.localPort) {
                        host = `${host}:${req.socket.localPort}`;
                    } else if (!host.includes(':')) {
                        host = `${host}:5001`;
                    }
                }
                
                resetUrl = `${protocol}://${host}/la-casa-dark-core-auth.html?reset_token=${resetToken}`;
            }
            
            console.log(`[AUTH] 🔗 URL de reset gerada: ${resetUrl}`);
            console.log(`[AUTH] 📍 Servidor rodando na porta: ${PORT}`);
            console.log(`[AUTH] 🌐 Host detectado: ${req.get('host') || 'N/A'}`);
            console.log(`[AUTH] 🔒 Protocolo: ${req.protocol || 'http'}`);
            
            // Enviar email de reset
            console.log('[AUTH] 📨 Tentando enviar email de reset...');
            try {
                const emailResult = await sendTemplateEmail('password_reset', user.email, {
                    nome: user.name,
                    email: user.email,
                    senha_provisoria: null, // Não usamos senha provisória aqui
                    link_acesso: resetUrl
                });
                
                if (emailResult.success) {
                    console.log(`[AUTH] ✅ Email de reset de senha enviado com sucesso para: ${user.email}`);
                    console.log(`[AUTH] 📧 Message ID: ${emailResult.messageId || 'N/A'}`);
                    if (emailResult.accepted && emailResult.accepted.length > 0) {
                        console.log(`[AUTH] ✅ Email aceito para entrega: ${emailResult.accepted.join(', ')}`);
                    }
                    if (emailResult.rejected && emailResult.rejected.length > 0) {
                        console.error(`[AUTH] ❌ Email rejeitado: ${emailResult.rejected.join(', ')}`);
                    }
                    console.log(`[AUTH] 💡 Dica: Verifique a pasta de SPAM/Lixo Eletrônico se o email não chegar em alguns minutos.`);
                } else {
                    console.error(`[AUTH] ⚠️ Falha ao enviar email: ${emailResult.message || emailResult.error}`);
                }
            } catch (emailError) {
                console.error('[AUTH] ❌ Erro ao enviar email de reset:', emailError.message);
                console.error('[AUTH] Stack trace:', emailError.stack);
                // Continuar mesmo se o email falhar
            }
        } else {
            console.log(`[AUTH] ⚠️ Usuário não encontrado para o email: ${email}`);
            console.log('[AUTH] ℹ️ Retornando mensagem genérica por segurança');
        }
        
        // Sempre retornar a mesma mensagem (por segurança)
        console.log('[AUTH] ✅ Retornando resposta de sucesso');
        console.log('[AUTH] ============================================');
        res.json({ msg: successMessage });
        
    } catch (err) {
        console.error('[AUTH] ❌ Erro ao processar solicitação de reset de senha:', err);
        console.error('[AUTH] Stack trace:', err.stack);
        // Retornar sucesso mesmo em caso de erro (por segurança)
        res.json({ msg: 'Se este email estiver cadastrado, um link de reset será enviado!' });
    }
});

// ================================================
// ROTAS DO SISTEMA DE CRÉDITOS
// ================================================

// Função auxiliar para obter limite de armazenamento baseado no plano
async function getStorageLimit(planName, isAdmin = false, userId = null) {
    // Verificar se há limite customizado para o usuário
    if (userId) {
        try {
            const customLimit = await db.get('SELECT custom_limit FROM user_storage_limits WHERE user_id = ?', [userId]);
            if (customLimit) {
                return customLimit.custom_limit;
            }
        } catch (err) {
            // Tabela pode não existir ainda, continuar com limite padrão
        }
    }
    
    // Admin tem 100 GB de armazenamento e acesso ilimitado
    if (isAdmin) {
        return 100 * 1024 * 1024 * 1024; // 100 GB
    }
    
    const storageLimits = {
        'plan-free': 10 * 1024 * 1024, // 10 MB
        'plan-start': 150 * 1024 * 1024, // 150 MB
        'plan-turbo': 250 * 1024 * 1024, // 250 MB
        'plan-master': 500 * 1024 * 1024, // 500 MB
        'plan-start-annual': 1024 * 1024 * 1024, // 1 GB
        'plan-turbo-annual': 1024 * 1024 * 1024, // 1 GB
        'plan-master-annual': 1024 * 1024 * 1024 // 1 GB
    };
    return storageLimits[planName] || storageLimits['plan-free'];
}

// Função auxiliar para verificar se o usuário pode usar mais armazenamento
// Retorna true se pode usar, false se excedeu o limite
async function checkStorageLimit(userId, additionalSize = 0, isAdmin = false) {
    // Admin sempre tem acesso ilimitado
    if (isAdmin) {
        return true;
    }
    
    try {
        const storageUsed = await calculateUserStorage(userId);
        // Obter plano do usuário
        let userPlan = 'plan-free';
        try {
            const user = await db.get('SELECT plan, subscription_plan FROM users WHERE id = ?', [userId]);
            if (user) {
                userPlan = user.subscription_plan || user.plan || 'plan-free';
            }
        } catch (err) {
            // Usar padrão
        }
        
        const storageLimit = await getStorageLimit(userPlan, isAdmin, userId);
        return (storageUsed + additionalSize) <= storageLimit;
    } catch (error) {
        console.error('[STORAGE] Erro ao verificar limite de armazenamento:', error);
        return false; // Em caso de erro, bloquear por segurança
    }
}

// Função auxiliar para calcular armazenamento usado pelo usuário
async function calculateUserStorage(userId) {
    try {
        const fs = require('fs');
        const path = require('path');
        let totalSize = 0;
        
        // Calcular tamanho dos arquivos em temp_audio (todos os arquivos temporários)
        const tempAudioDir = path.join(__dirname, 'temp_audio');
        if (fs.existsSync(tempAudioDir)) {
            const files = fs.readdirSync(tempAudioDir);
            for (const file of files) {
                const filePath = path.join(tempAudioDir, file);
                try {
                    const stats = fs.statSync(filePath);
                    if (stats.isFile()) {
                        totalSize += stats.size;
                    }
                } catch (err) {
                    // Ignorar erros de arquivos individuais
                }
            }
        }
        
        // Calcular tamanho dos arquivos de vídeo/áudio gerados pelo usuário
        // (se houver uma tabela de arquivos ou estrutura similar)
        try {
            const userFiles = await db.all('SELECT file_path, file_size FROM user_files WHERE user_id = ?', [userId]);
            if (userFiles && userFiles.length > 0) {
                for (const file of userFiles) {
                    if (file.file_size) {
                        totalSize += file.file_size;
                    } else if (file.file_path) {
                        try {
                            const filePath = path.join(__dirname, file.file_path);
                            if (fs.existsSync(filePath)) {
                                const stats = fs.statSync(filePath);
                                totalSize += stats.size;
                            }
                        } catch (err) {
                            // Ignorar erros
                        }
                    }
                }
            }
        } catch (err) {
            // Tabela pode não existir ainda, ignorar
        }
        
        return totalSize;
    } catch (error) {
        console.error('[STORAGE] Erro ao calcular armazenamento:', error);
        return 0;
    }
}

// GET /api/credits/balance - Usuário consulta seu próprio saldo
app.get('/api/credits/balance', authenticateToken, async (req, res) => {
    try {
        console.log('[CRÉDITOS API] Consultando saldo para usuário:', req.user.id);
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [req.user.id]);
        if (!credits) {
            console.log('[CRÉDITOS API] Criando registro de créditos para usuário:', req.user.id);
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [req.user.id]);
            credits = { balance: 0 };
        }
        
        // Obter plano do usuário e verificar se é admin
        let userPlan = 'plan-free'; // Padrão
        let isAdmin = false;
        
        // Primeiro verificar se req.user já tem isAdmin (do token)
        if (req.user && req.user.isAdmin !== undefined) {
            isAdmin = req.user.isAdmin === 1 || req.user.isAdmin === true || req.user.isAdmin === '1';
        }
        
        try {
            // Buscar dados completos do usuário incluindo plano
            const user = await db.get('SELECT id, isAdmin, email, plan, subscription_plan FROM users WHERE id = ?', [req.user.id]);
            if (user) {
                // Obter plano do usuário
                userPlan = user.subscription_plan || user.plan || 'plan-free';
                
                // Verificação robusta de isAdmin (SQLite retorna como INTEGER)
                const adminValue = user.isAdmin;
                // Verificar todas as possibilidades
                isAdmin = adminValue === 1 || 
                         adminValue === true || 
                         adminValue === '1' || 
                         String(adminValue) === '1' ||
                         Number(adminValue) === 1;
                
                console.log('[CRÉDITOS API] Usuário:', user.email, 'ID:', user.id);
                console.log('[CRÉDITOS API] isAdmin valor bruto:', adminValue, 'tipo:', typeof adminValue);
                console.log('[CRÉDITOS API] isAdmin resultado:', isAdmin);
                console.log('[CRÉDITOS API] userPlan:', userPlan);
            } else {
                console.log('[CRÉDITOS API] Usuário não encontrado no banco de dados para ID:', req.user.id);
            }
        } catch (err) {
            console.error('[CRÉDITOS API] Erro ao buscar usuário:', err);
        }
        
        console.log('[CRÉDITOS API] Verificação final - isAdmin:', isAdmin, 'userPlan:', userPlan);
        
        // Calcular armazenamento
        const storageUsed = await calculateUserStorage(req.user.id);
        const storageLimit = await getStorageLimit(userPlan, isAdmin, req.user.id);
        
        console.log('[CRÉDITOS API] Saldo encontrado:', credits.balance);
        console.log('[CRÉDITOS API] Armazenamento - Usado:', (storageUsed / (1024*1024)).toFixed(2), 'MB, Limite:', (storageLimit / (1024*1024*1024)).toFixed(2), 'GB, isAdmin:', isAdmin);
        res.json({ 
            balance: credits.balance,
            storageUsed: storageUsed,
            storageLimit: storageLimit,
            plan: userPlan,
            isAdmin: isAdmin // Incluir isAdmin na resposta para debug
        });
    } catch (error) {
        console.error('[CRÉDITOS API] Erro ao consultar saldo:', error);
        res.status(500).json({ message: 'Erro ao consultar saldo' });
    }
});

// GET /api/user/credits - Alias para /api/credits/balance (compatibilidade)
app.get('/api/user/credits', authenticateToken, async (req, res) => {
    try {
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [req.user.id]);
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [req.user.id]);
            credits = { balance: 0 };
        }
        
        // Obter plano e armazenamento
        let userPlan = 'plan-free';
        let isAdmin = false;
        
        // Primeiro verificar se req.user já tem isAdmin (do token)
        if (req.user && req.user.isAdmin !== undefined) {
            isAdmin = req.user.isAdmin === 1 || req.user.isAdmin === true || req.user.isAdmin === '1';
        }
        
        try {
            // Buscar dados completos do usuário incluindo plano
            const user = await db.get('SELECT id, isAdmin, email, plan, subscription_plan FROM users WHERE id = ?', [req.user.id]);
            if (user) {
                // Obter plano do usuário
                userPlan = user.subscription_plan || user.plan || 'plan-free';
                
                // Verificação robusta de isAdmin (SQLite retorna como INTEGER)
                const adminValue = user.isAdmin;
                isAdmin = adminValue === 1 || 
                         adminValue === true || 
                         adminValue === '1' || 
                         String(adminValue) === '1' ||
                         Number(adminValue) === 1;
            }
        } catch (err) {
            console.error('[CRÉDITOS API] Erro ao buscar usuário:', err);
        }
        
        const storageUsed = await calculateUserStorage(req.user.id);
        const storageLimit = await getStorageLimit(userPlan, isAdmin, req.user.id);
        
        res.json({ 
            balance: credits.balance,
            storageUsed: storageUsed,
            storageLimit: storageLimit,
            plan: userPlan,
            isAdmin: isAdmin
        });
    } catch (error) {
        console.error('Erro ao consultar saldo:', error);
        res.status(500).json({ message: 'Erro ao consultar saldo' });
    }
});

// GET /api/user/preferences - Buscar preferências do usuário
app.get('/api/user/preferences', authenticateToken, async (req, res) => {
    try {
        let preferences = await db.get('SELECT * FROM user_preferences WHERE user_id = ?', [req.user.id]);
        if (!preferences) {
            // Criar preferências padrão
            await db.run('INSERT INTO user_preferences (user_id, use_credits_instead_of_own_api) VALUES (?, 0)', [req.user.id]);
            preferences = { use_credits_instead_of_own_api: 0 };
        }
        res.json({ 
            use_credits_instead_of_own_api: preferences.use_credits_instead_of_own_api === 1 
        });
    } catch (error) {
        console.error('Erro ao buscar preferências:', error);
        res.status(500).json({ message: 'Erro ao buscar preferências' });
    }
});

// POST /api/user/preferences - Salvar preferências do usuário
app.post('/api/user/preferences', authenticateToken, async (req, res) => {
    try {
        const { use_credits_instead_of_own_api } = req.body;
        
        // Verificar se já existe
        const existing = await db.get('SELECT id FROM user_preferences WHERE user_id = ?', [req.user.id]);
        
        if (existing) {
            await db.run(
                'UPDATE user_preferences SET use_credits_instead_of_own_api = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?',
                [use_credits_instead_of_own_api ? 1 : 0, req.user.id]
            );
        } else {
            await db.run(
                'INSERT INTO user_preferences (user_id, use_credits_instead_of_own_api) VALUES (?, ?)',
                [req.user.id, use_credits_instead_of_own_api ? 1 : 0]
            );
        }
        
        res.json({ 
            message: 'Preferências salvas com sucesso',
            use_credits_instead_of_own_api: use_credits_instead_of_own_api 
        });
    } catch (error) {
        console.error('Erro ao salvar preferências:', error);
        res.status(500).json({ message: 'Erro ao salvar preferências' });
    }
});

// GET /api/credits/transactions - Usuário consulta suas transações com detalhes
app.get('/api/credits/transactions', authenticateToken, async (req, res) => {
    try {
        // Buscar transações com JOIN para obter detalhes de uso
        const transactions = await db.all(`
            SELECT 
                ct.id,
                ct.amount,
                ct.transaction_type,
                ct.description,
                ct.created_at,
                cu.operation_type,
                cu.details,
                cu.units_consumed,
                ap.name as api_name,
                ap.provider as api_provider,
                ap.model as api_model
            FROM credit_transactions ct
            LEFT JOIN credit_usage cu ON ct.user_id = cu.user_id 
                AND ABS(ct.amount) = cu.credits_used 
                AND DATE(ct.created_at) = DATE(cu.created_at)
                AND ct.transaction_type = 'debit'
            LEFT JOIN api_providers ap ON cu.api_provider_id = ap.id
            WHERE ct.user_id = ?
            ORDER BY ct.created_at DESC
            LIMIT 100
        `, [req.user.id]);
        
        // Processar transações para adicionar informações detalhadas
        const processedTransactions = transactions.map(t => {
            let details = null;
            let operationInfo = null;
            
            if (t.details) {
                try {
                    details = typeof t.details === 'string' ? JSON.parse(t.details) : t.details;
                } catch (e) {
                    details = { raw: t.details };
                }
            }
            
            // Montar informação detalhada sobre a operação
            if (t.operation_type) {
                const operationTypes = {
                    // Roteiros
                    'api_script_agents_generate': 'Gerador de Roteiro',
                    '/api/generate': 'Gerador de Roteiro',
                    '/api/scripts': 'Gerador de Roteiro',
                    '/api/scripts/generate': 'Gerador de Roteiro',
                    '/api/script-agents/:agentId/generate': 'Gerador de Roteiro',
                    '/api/script-agents/:agentId/generate/laozhang': 'Gerador de Roteiro',
                    // Vídeos
                    'api_video_generation': 'Gerador de Vídeo',
                    // Voz
                    'api_tts_generation': 'Geração de Voz',
                    'api_tts_preview': 'Preview de Voz',
                    // Imagens
                    'api_image_generation': 'Geração de Imagem',
                    // Thumbnails
                    'api_analyze_thumbnail': 'Gerador de Thumbnail',
                    '/api/analyze/thumbnail': 'Gerador de Thumbnail',
                    '/api/analyze/thumbnail/laozhang': 'Gerador de Thumbnail',
                    // Cenas
                    '/api/generate/scene-prompts': 'Gerador de Cenas',
                    '/api/generate/scene-prompts/laozhang': 'Gerador de Cenas',
                    // Análise de Títulos
                    '/api/analyze/titles': 'Análise de Títulos',
                    '/api/analyze/titles/laozhang': 'Análise de Títulos',
                    // Detecção de Personagens
                    'api_detect_characters': 'Detecção de Personagens',
                    '/api/detect/characters': 'Detecção de Personagens',
                    '/api/detect/characters/laozhang': 'Detecção de Personagens',
                    // Busca de Subnicho
                    'api_niche_find_subniche': 'Busca de Subnicho',
                    '/api/niche/find-subniche': 'Busca de Subnicho',
                    '/api/niche/find-subniche/laozhang': 'Busca de Subnicho',
                    // Análise de Competidor
                    'api_niche_analyze_competitor': 'Análise de Competidor',
                    '/api/niche/analyze-competitor': 'Análise de Competidor',
                    '/api/niche/analyze-competitor/laozhang': 'Análise de Competidor',
                    // Criação de Agente
                    '/api/script-agents/create': 'Criação de Agente',
                    '/api/script-agents/create/laozhang': 'Criação de Agente',
                    // Reescrever Prompt
                    'api_rewrite_prompt': 'Reescrever Prompt',
                    '/api/rewrite/blocked-prompt': 'Reescrever Prompt',
                    '/api/rewrite/blocked-prompt/laozhang': 'Reescrever Prompt',
                    // Análise de Transcrição
                    'api_transcript_analyze': 'Análise de Transcrição',
                    '/api/video/transcript/analyze': 'Análise de Transcrição',
                    '/api/video/transcript/analyze/laozhang': 'Análise de Transcrição',
                    // Genéricos
                    'api_generation': 'Geração de Conteúdo',
                    'api_call': 'Ferramenta'
                };
                
                // Tentar extrair nome da ferramenta da descrição se ela contiver "Ferramenta - Laozhang.ai"
                let toolName = operationTypes[t.operation_type];
                
                // Se não encontrou pelo operationType, tentar pelo endpoint nos details
                if (!toolName && details?.endpoint) {
                    for (const [key, value] of Object.entries(operationTypes)) {
                        if (details.endpoint.includes(key) || key.includes(details.endpoint)) {
                            toolName = value;
                            break;
                        }
                    }
                }
                
                // Se ainda não encontrou, usar fallback
                if (!toolName) {
                    toolName = operationTypes[t.operation_type] || t.operation_type;
                }
                
                // Priorizar modelo dos details (modelo real usado), depois api_model (modelo do provider), depois descrição
                let modelName = details?.model || t.api_model || 'N/A';
                
                // Se a descrição contém "Ferramenta - Laozhang.ai", tentar extrair informações
                if ((!modelName || modelName === 'N/A') && t.description && t.description.includes('Ferramenta - Laozhang.ai')) {
                    // Tentar extrair o modelo da descrição
                    const modelMatch = t.description.match(/\(([^)]+)\)/);
                    if (modelMatch && modelMatch[1]) {
                        modelName = modelMatch[1];
                    }
                }
                
                // Se ainda não tem modelo, tentar extrair da descrição atual
                if ((!modelName || modelName === 'N/A') && t.description && t.description.includes(' - ')) {
                    const parts = t.description.split(' - ');
                    if (parts.length > 1) {
                        const possibleModel = parts[parts.length - 1];
                        // Verificar se parece um modelo (não é apenas o nome da ferramenta)
                        if (possibleModel && !possibleModel.includes('Gerador') && !possibleModel.includes('Ferramenta')) {
                            modelName = possibleModel;
                        }
                    }
                }
                
                // Formatar modelo se necessário
                if (modelName && modelName !== 'N/A') {
                    if (modelName.includes('claude-3-7-sonnet') || modelName === 'claude-3-7-sonnet-20250219') {
                        modelName = 'Claude 3.7 Sonnet';
                    } else if (modelName.includes('gemini-2.5-pro') || modelName === 'gemini-2.5-pro') {
                        modelName = 'Gemini 2.5 Pro';
                    } else if (modelName === 'gpt-4o' || modelName.includes('gpt-4o')) {
                        modelName = 'GPT-4o';
                    } else if (modelName.includes('veo-3.1-landscape-fast-fl') || modelName === 'veo-3.1-landscape-fast-fl') {
                        modelName = 'Veo 3.1 Landscape Fast';
                    } else if (modelName.includes('veo-3.1-landscape-fast') || modelName === 'veo-3.1-landscape-fast') {
                        modelName = 'Veo 3.1 Landscape Fast';
                    } else if (modelName.includes('veo-3.1-landscape-fl') || modelName === 'veo-3.1-landscape-fl') {
                        modelName = 'Veo 3.1 Landscape';
                    } else if (modelName.includes('veo-3.1-landscape') || modelName === 'veo-3.1-landscape') {
                        modelName = 'Veo 3.1 Landscape';
                    } else if (modelName.includes('veo-3.1-fast-fl') || modelName === 'veo-3.1-fast-fl') {
                        modelName = 'Veo 3.1 Fast';
                    } else if (modelName.includes('veo-3.1-fast') || modelName === 'veo-3.1-fast-generate-preview' || modelName === 'veo-3.1-fast') {
                        modelName = 'Veo 3.1 Fast';
                    } else if (modelName.includes('veo-3.1-fl') || modelName === 'veo-3.1-fl') {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('veo-3.1-generate') || modelName === 'veo-3.1-generate-preview' || modelName === 'veo-3.1') {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('veo-3.1')) {
                        modelName = 'Veo 3.1';
                    }
                }
                
                operationInfo = {
                    type: t.operation_type,
                    typeName: toolName,
                    model: modelName !== 'N/A' ? modelName : null,
                    units: t.units_consumed || null,
                    endpoint: details?.endpoint || null,
                    details: details
                };
            }
            
            // Se a descrição contém "Ferramenta - Laozhang.ai", substituir pela descrição correta baseada no operationInfo
            let finalDescription = t.description;
            if (finalDescription && finalDescription.includes('Ferramenta - Laozhang.ai')) {
                if (operationInfo && operationInfo.typeName) {
                    finalDescription = operationInfo.typeName;
                    if (operationInfo.model) {
                        finalDescription += ` - ${operationInfo.model}`;
                    }
                }
            }
            finalDescription = sanitizeUserFacingText(
                finalDescription || (operationInfo?.typeName || 'Operação'),
                operationInfo?.typeName || 'Operação'
            );
            
            return {
                id: t.id,
                amount: t.amount,
                transaction_type: t.transaction_type,
                description: finalDescription,
                created_at: t.created_at,
                operation: operationInfo,
                isCredit: t.transaction_type === 'credit'
            };
        });
        
        res.json({ data: processedTransactions });
    } catch (error) {
        console.error('Erro ao listar transações:', error);
        res.status(500).json({ message: 'Erro ao listar transações' });
    }
});

// === ROTAS ADMINISTRATIVAS DE CRÉDITOS ===

// GET /api/admin/credits/balance/:userId - Consulta saldo de um usuário específico
app.get('/api/admin/credits/balance/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId);
        if (!userId) {
            return res.status(400).json({ message: 'ID do usuário inválido' });
        }
        
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [userId]);
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [userId]);
            credits = { balance: 0 };
        }
        res.json({ balance: credits.balance });
    } catch (error) {
        console.error('Erro ao consultar saldo:', error);
        res.status(500).json({ message: 'Erro ao consultar saldo' });
    }
});

// POST /api/admin/credits/add - Adiciona créditos a um usuário
app.post('/api/admin/credits/add', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { user_id, amount, description } = req.body;
        if (!user_id || !amount || amount <= 0) {
            return res.status(400).json({ message: 'user_id e amount são obrigatórios e amount deve ser positivo' });
        }
        
        const user = await db.get('SELECT id FROM users WHERE id = ?', [user_id]);
        if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });
        
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [user_id]);
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [user_id]);
            credits = { balance: 0 };
        }
        
        const newBalance = credits.balance + parseFloat(amount);
        await db.run('UPDATE user_credits SET balance = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?', [newBalance, user_id]);
        await db.run(`
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description, admin_id)
            VALUES (?, ?, 'credit', ?, ?)
        `, [user_id, amount, description || 'Créditos adicionados pelo administrador', req.user.id]);
        
        res.json({ message: 'Créditos adicionados com sucesso', new_balance: newBalance });
    } catch (error) {
        console.error('Erro ao adicionar créditos:', error);
        res.status(500).json({ message: 'Erro ao adicionar créditos' });
    }
});

// ================================================
// ROTAS DE ADMINISTRAÇÃO - ARMAZENAMENTO
// ================================================

// GET /api/admin/storage/stats - Obter estatísticas de armazenamento do servidor
app.get('/api/admin/storage/stats', authenticateToken, isAdmin, async (req, res) => {
    try {
        const fs = require('fs');
        const path = require('path');
        const os = require('os');
        const { execSync } = require('child_process');
        
        // Calcular espaço total do disco (não RAM)
        let totalSpace = 0;
        try {
            // Tentar usar comando do sistema para obter espaço em disco
            if (process.platform === 'win32') {
                // Windows: usar wmic
                const output = execSync('wmic logicaldisk get size,freespace,caption', { encoding: 'utf-8' });
                const lines = output.split('\n').filter(line => line.trim() && !line.includes('Caption'));
                let total = 0;
                for (const line of lines) {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        const size = parseInt(parts[parts.length - 1]);
                        if (!isNaN(size)) {
                            total += size;
                        }
                    }
                }
                totalSpace = total;
            } else {
                // Linux/Unix: usar df
                const output = execSync('df -B1 /', { encoding: 'utf-8' });
                const lines = output.split('\n');
                if (lines.length > 1) {
                    const parts = lines[1].trim().split(/\s+/);
                    if (parts.length >= 2) {
                        totalSpace = parseInt(parts[1]); // Tamanho total em bytes
                    }
                }
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao obter espaço em disco, usando fallback:', err.message);
            // Fallback: tentar usar fs.statfs se disponível (Node.js 18+)
            try {
                const stats = fs.statfsSync ? fs.statfsSync('/') : null;
                if (stats && stats.blocks && stats.bsize) {
                    totalSpace = stats.blocks * stats.bsize;
                } else {
                    // Último fallback: usar espaço do diretório atual
                    const stats = fs.statSync(__dirname);
                    // Não temos como saber o tamanho total, então vamos usar um valor padrão ou calcular do diretório
                    totalSpace = 200 * 1024 * 1024 * 1024; // 200 GB como padrão se não conseguir detectar
                }
            } catch (fallbackErr) {
                console.warn('[STORAGE] Fallback também falhou, usando valor padrão');
                totalSpace = 200 * 1024 * 1024 * 1024; // 200 GB como padrão
            }
        }
        
        // Calcular espaço usado em temp_audio
        const tempAudioDir = path.join(__dirname, 'temp_audio');
        let tempAudioSize = 0;
        if (fs.existsSync(tempAudioDir)) {
            const files = fs.readdirSync(tempAudioDir);
            for (const file of files) {
                try {
                    const filePath = path.join(tempAudioDir, file);
                    const stats = fs.statSync(filePath);
                    if (stats.isFile()) {
                        tempAudioSize += stats.size;
                    }
                } catch (err) {
                    // Ignorar erros
                }
            }
        }
        
        // Calcular espaço usado por todos os usuários
        const allUsers = await db.all('SELECT id, email, name, isAdmin FROM users');
        const usersStorage = [];
        let totalUsersStorage = 0;
        
        for (const user of allUsers) {
            const userStorage = await calculateUserStorage(user.id);
            totalUsersStorage += userStorage;
            
            // Obter limite do usuário
            let userPlan = 'plan-free';
            let isUserAdmin = false;
            try {
                const userData = await db.get('SELECT plan, subscription_plan, isAdmin FROM users WHERE id = ?', [user.id]);
                if (userData) {
                    userPlan = userData.subscription_plan || userData.plan || 'plan-free';
                    isUserAdmin = userData.isAdmin === 1 || userData.isAdmin === true || String(userData.isAdmin) === '1';
                }
            } catch (err) {
                // Ignorar
            }
            
            const storageLimit = await getStorageLimit(userPlan, isUserAdmin, user.id);
            
            usersStorage.push({
                userId: user.id,
                email: user.email,
                name: user.name,
                isAdmin: isUserAdmin,
                plan: userPlan,
                storageUsed: userStorage,
                storageLimit: storageLimit,
                percentage: storageLimit > 0 ? (userStorage / storageLimit * 100) : 0
            });
        }
        
        res.json({
            serverTotalSpace: totalSpace,
            tempAudioSize: tempAudioSize,
            totalUsersStorage: totalUsersStorage,
            users: usersStorage,
            totalUsers: usersStorage.length
        });
    } catch (error) {
        console.error('[ADMIN STORAGE] Erro ao obter estatísticas:', error);
        res.status(500).json({ message: 'Erro ao obter estatísticas de armazenamento' });
    }
});

// PUT /api/admin/storage/reset/:userId - Zerar armazenamento de um usuário
app.put('/api/admin/storage/reset/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId);
        const fs = require('fs');
        const path = require('path');
        
        // Deletar arquivos em temp_audio do usuário (arquivos que contêm o userId ou são do usuário)
        const tempAudioDir = path.join(__dirname, 'temp_audio');
        let deletedFiles = 0;
        let freedSpace = 0;
        
        if (fs.existsSync(tempAudioDir)) {
            const files = fs.readdirSync(tempAudioDir);
            for (const file of files) {
                try {
                    // Verificar se o arquivo pertence ao usuário (pode conter userId no nome ou timestamp)
                    // Por segurança, vamos listar todos e verificar propriedades
                    const filePath = path.join(tempAudioDir, file);
                    const stats = fs.statSync(filePath);
                    
                    // Deletar arquivo (por enquanto deletamos todos os arquivos temporários)
                    // Em produção, você pode querer associar arquivos a usuários em uma tabela
                    fs.unlinkSync(filePath);
                    deletedFiles++;
                    freedSpace += stats.size;
                } catch (err) {
                    console.error(`[ADMIN STORAGE] Erro ao deletar arquivo ${file}:`, err);
                }
            }
        }
        
        // Deletar arquivos associados ao usuário em user_files (se a tabela existir)
        try {
            const userFiles = await db.all('SELECT file_path FROM user_files WHERE user_id = ?', [userId]);
            for (const file of userFiles) {
                try {
                    if (file.file_path) {
                        const filePath = path.join(__dirname, file.file_path);
                        if (fs.existsSync(filePath)) {
                            const stats = fs.statSync(filePath);
                            fs.unlinkSync(filePath);
                            freedSpace += stats.size;
                        }
                    }
                } catch (err) {
                    // Ignorar erros
                }
            }
            await db.run('DELETE FROM user_files WHERE user_id = ?', [userId]);
        } catch (err) {
            // Tabela pode não existir, ignorar
        }
        
        res.json({
            success: true,
            message: `Armazenamento zerado para o usuário ${userId}`,
            deletedFiles: deletedFiles,
            freedSpace: freedSpace
        });
    } catch (error) {
        console.error('[ADMIN STORAGE] Erro ao zerar armazenamento:', error);
        res.status(500).json({ message: 'Erro ao zerar armazenamento' });
    }
});

// PUT /api/admin/storage/limit/:userId - Alterar limite de armazenamento de um usuário
app.put('/api/admin/storage/limit/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId);
        const { storageLimit } = req.body;
        
        if (!storageLimit || storageLimit < 0) {
            return res.status(400).json({ message: 'Limite de armazenamento inválido' });
        }
        
        // Converter para bytes se necessário
        let limitInBytes = storageLimit;
        if (typeof storageLimit === 'string') {
            // Se vier como "100GB", "500MB", etc
            const match = storageLimit.match(/^(\d+(?:\.\d+)?)\s*(GB|MB|KB|B)$/i);
            if (match) {
                const value = parseFloat(match[1]);
                const unit = match[2].toUpperCase();
                if (unit === 'GB') limitInBytes = value * 1024 * 1024 * 1024;
                else if (unit === 'MB') limitInBytes = value * 1024 * 1024;
                else if (unit === 'KB') limitInBytes = value * 1024;
                else limitInBytes = value;
            } else {
                limitInBytes = parseInt(storageLimit);
            }
        }
        
        // Criar ou atualizar limite customizado na tabela user_storage_limits (se não existir, criar)
        try {
            await db.run(`
                CREATE TABLE IF NOT EXISTS user_storage_limits (
                    user_id INTEGER PRIMARY KEY,
                    custom_limit INTEGER NOT NULL,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                )
            `);
            
            await db.run(`
                INSERT OR REPLACE INTO user_storage_limits (user_id, custom_limit, updated_at)
                VALUES (?, ?, CURRENT_TIMESTAMP)
            `, [userId, limitInBytes]);
        } catch (err) {
            console.error('[ADMIN STORAGE] Erro ao salvar limite customizado:', err);
            return res.status(500).json({ message: 'Erro ao salvar limite de armazenamento' });
        }
        
        res.json({
            success: true,
            message: `Limite de armazenamento atualizado para ${(limitInBytes / (1024 * 1024 * 1024)).toFixed(2)} GB`,
            storageLimit: limitInBytes
        });
    } catch (error) {
        console.error('[ADMIN STORAGE] Erro ao alterar limite:', error);
        res.status(500).json({ message: 'Erro ao alterar limite de armazenamento' });
    }
});

// GET /api/admin/storage/limit/:userId - Obter limite customizado de um usuário
app.get('/api/admin/storage/limit/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId);
        
        try {
            const customLimit = await db.get('SELECT custom_limit FROM user_storage_limits WHERE user_id = ?', [userId]);
            if (customLimit) {
                return res.json({ hasCustomLimit: true, storageLimit: customLimit.custom_limit });
            }
        } catch (err) {
            // Tabela pode não existir ainda
        }
        
        res.json({ hasCustomLimit: false });
    } catch (error) {
        console.error('[ADMIN STORAGE] Erro ao obter limite:', error);
        res.status(500).json({ message: 'Erro ao obter limite de armazenamento' });
    }
});

// PUT /api/admin/credits/reset - Zerar créditos de um usuário
app.put('/api/admin/credits/reset', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { user_id } = req.body;
        if (!user_id) {
            return res.status(400).json({ message: 'user_id é obrigatório' });
        }
        
        const user = await db.get('SELECT id, email FROM users WHERE id = ?', [user_id]);
        if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });
        
        // Obter saldo atual antes de zerar
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [user_id]);
        const oldBalance = credits ? credits.balance : 0;
        
        // Zerar saldo
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [user_id]);
        } else {
            await db.run('UPDATE user_credits SET balance = 0, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?', [user_id]);
        }
        
        // Registrar transação
        if (oldBalance > 0) {
            await db.run(`
                INSERT INTO credit_transactions (user_id, amount, transaction_type, description, admin_id)
                VALUES (?, ?, 'debit', ?, ?)
            `, [user_id, -oldBalance, `Créditos zerados pelo administrador (saldo anterior: ${oldBalance.toFixed(2)})`, req.user.id]);
        }
        
        res.json({ message: 'Créditos zerados com sucesso', old_balance: oldBalance, new_balance: 0 });
    } catch (error) {
        console.error('Erro ao zerar créditos:', error);
        res.status(500).json({ message: 'Erro ao zerar créditos' });
    }
});

// ================================================
// ROTAS ADMINISTRATIVAS DE APIs
// ================================================

// GET /api/admin/api-providers - Listar todas as APIs
app.get('/api/admin/api-providers', authenticateToken, isAdmin, async (req, res) => {
    try {
        const apis = await db.all('SELECT * FROM api_providers ORDER BY created_at DESC');
        res.json(apis);
    } catch (error) {
        console.error('Erro ao listar APIs:', error);
        res.status(500).json({ message: 'Erro ao listar APIs' });
    }
});

// POST /api/admin/api-providers - Criar nova API
app.post('/api/admin/api-providers', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { name, provider, model, api_key, unit_type, unit_size, real_cost_per_unit, credits_per_unit, markup, is_premium, is_active, is_default } = req.body;
        
        if (!name || !provider || !model || !api_key) {
            return res.status(400).json({ message: 'Nome, provedor, modelo e chave de API são obrigatórios' });
        }
        
        // Se marcar como padrão, desmarcar outras
        if (is_default) {
            await db.run('UPDATE api_providers SET is_default = 0');
        }
        
        const result = await db.run(`
            INSERT INTO api_providers (
                name, provider, model, api_key, unit_type, unit_size,
                real_cost_per_unit, credits_per_unit, markup, is_premium,
                is_active, is_default
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
            name, provider, model, api_key, unit_type || 'tokens', unit_size || 1000,
            real_cost_per_unit || 0.0, credits_per_unit || 1.0, markup || 1.0,
            is_premium || 0, is_active !== undefined ? is_active : 1, is_default || 0
        ]);
        
        res.json({ message: 'API criada com sucesso', id: result.lastID });
    } catch (error) {
        console.error('Erro ao criar API:', error);
        res.status(500).json({ message: 'Erro ao criar API' });
    }
});

// PUT /api/admin/api-providers/:id - Editar API
app.put('/api/admin/api-providers/:id', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { id } = req.params;
        const { name, provider, model, api_key, unit_type, unit_size, real_cost_per_unit, credits_per_unit, markup, is_premium, is_active, is_default } = req.body;
        
        // Se marcar como padrão, desmarcar outras
        if (is_default) {
            await db.run('UPDATE api_providers SET is_default = 0 WHERE id != ?', [id]);
        }
        
        await db.run(`
            UPDATE api_providers SET
                name = ?, provider = ?, model = ?, api_key = ?,
                unit_type = ?, unit_size = ?, real_cost_per_unit = ?,
                credits_per_unit = ?, markup = ?, is_premium = ?,
                is_active = ?, is_default = ?, updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        `, [
            name, provider, model, api_key, unit_type, unit_size,
            real_cost_per_unit, credits_per_unit, markup, is_premium,
            is_active, is_default, id
        ]);
        
        res.json({ message: 'API atualizada com sucesso' });
    } catch (error) {
        console.error('Erro ao atualizar API:', error);
        res.status(500).json({ message: 'Erro ao atualizar API' });
    }
});

// DELETE /api/admin/api-providers/:id - Deletar API
app.delete('/api/admin/api-providers/:id', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { id } = req.params;
        await db.run('DELETE FROM api_providers WHERE id = ?', [id]);
        res.json({ message: 'API excluída com sucesso' });
    } catch (error) {
        console.error('Erro ao excluir API:', error);
        res.status(500).json({ message: 'Erro ao excluir API' });
    }
});

// GET /api/admin/credits/statistics - Estatísticas de créditos (completo)
app.get('/api/admin/credits/statistics', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { startDate, endDate, userId, tool } = req.query;
        
        let dateFilter = '';
        let params = [];
        
        if (startDate && endDate) {
            dateFilter = 'AND DATE(cu.created_at) BETWEEN DATE(?) AND DATE(?)';
            params.push(startDate, endDate);
        } else if (startDate) {
            dateFilter = 'AND DATE(cu.created_at) >= DATE(?)';
            params.push(startDate);
        } else if (endDate) {
            dateFilter = 'AND DATE(cu.created_at) <= DATE(?)';
            params.push(endDate);
        } else {
            // Padrão: últimos 30 dias
            dateFilter = 'AND DATE(cu.created_at) >= DATE("now", "-30 days")';
        }
        
        if (userId) {
            dateFilter += ' AND cu.user_id = ?';
            params.push(userId);
        }
        
        // Estatísticas gerais
        const totalStats = await db.get(`
            SELECT 
                COUNT(*) as total_operations,
                SUM(cu.credits_used) as total_credits,
                AVG(cu.credits_used) as avg_credits_per_operation,
                MIN(cu.credits_used) as min_credits,
                MAX(cu.credits_used) as max_credits,
                COUNT(DISTINCT cu.user_id) as unique_users,
                COUNT(DISTINCT DATE(cu.created_at)) as days_with_usage
            FROM credit_usage cu
            WHERE 1=1 ${dateFilter}
        `, params);
        
        // Estatísticas por dia
        const dailyStats = await db.all(`
            SELECT 
                DATE(cu.created_at) as date,
                COUNT(*) as operations,
                SUM(cu.credits_used) as total_credits,
                COUNT(DISTINCT cu.user_id) as unique_users
            FROM credit_usage cu
            WHERE 1=1 ${dateFilter}
            GROUP BY DATE(cu.created_at)
            ORDER BY date DESC
            LIMIT 90
        `, params);
        
        // Estatísticas por ferramenta
        let toolFilter = '';
        let toolParams = [...params];
        if (tool) {
            toolFilter = 'AND ct.description = ?';
            toolParams.push(tool);
        }
        
        let ctDateFilter = '';
        if (startDate && endDate) {
            ctDateFilter = 'AND DATE(ct.created_at) BETWEEN DATE(?) AND DATE(?)';
        } else if (startDate) {
            ctDateFilter = 'AND DATE(ct.created_at) >= DATE(?)';
        } else if (endDate) {
            ctDateFilter = 'AND DATE(ct.created_at) <= DATE(?)';
        } else {
            ctDateFilter = 'AND DATE(ct.created_at) >= DATE("now", "-30 days")';
        }
        
        const toolStats = await db.all(`
            SELECT 
                ct.description as tool_name,
                COUNT(*) as operations,
                SUM(ABS(ct.amount)) as total_credits,
                AVG(ABS(ct.amount)) as avg_credits,
                COUNT(DISTINCT ct.user_id) as unique_users
            FROM credit_transactions ct
            WHERE ct.transaction_type = 'debit' ${ctDateFilter} ${toolFilter}
            GROUP BY ct.description
            ORDER BY total_credits DESC
        `, toolParams);
        
        // Estatísticas por usuário (top 20)
        const userStats = await db.all(`
            SELECT 
                u.id,
                u.email,
                u.whatsapp,
                COUNT(cu.id) as operations,
                SUM(cu.credits_used) as total_credits,
                AVG(cu.credits_used) as avg_credits
            FROM credit_usage cu
            JOIN users u ON cu.user_id = u.id
            WHERE 1=1 ${dateFilter}
            GROUP BY u.id, u.email, u.whatsapp
            ORDER BY total_credits DESC
            LIMIT 20
        `, params);
        
        // Estatísticas por API Provider
        const apiStats = await db.all(`
            SELECT 
                ap.id,
                ap.name,
                ap.provider,
                ap.model,
                COUNT(cu.id) as operations,
                SUM(cu.credits_used) as total_credits,
                SUM(cu.units_consumed) as total_units
            FROM credit_usage cu
            JOIN api_providers ap ON cu.api_provider_id = ap.id
            WHERE 1=1 ${dateFilter}
            GROUP BY ap.id, ap.name, ap.provider, ap.model
            ORDER BY total_credits DESC
        `, params);
        
        // Total distribuído (créditos adicionados)
        const totalDistributed = await db.get(`
            SELECT SUM(amount) as total FROM credit_transactions WHERE transaction_type = 'credit'
        `);
        
        // Usuários com créditos
        const usersWithCredits = await db.get(`
            SELECT COUNT(*) as count FROM user_credits WHERE balance > 0
        `);
        
        res.json({
            summary: totalStats,
            daily: dailyStats,
            byTool: toolStats,
            byUser: userStats,
            byApi: apiStats,
            totalDistributed: totalDistributed?.total || 0,
            usersWithCredits: usersWithCredits?.count || 0,
            creditsUsed30Days: totalStats?.total_credits || 0
        });
    } catch (error) {
        console.error('Erro ao buscar estatísticas de créditos:', error);
        res.status(500).json({ message: 'Erro ao buscar estatísticas', details: error.message });
    }
});

// GET /api/admin/credits/export - Exportar dados de créditos (CSV)
app.get('/api/admin/credits/export', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { startDate, endDate, format = 'csv' } = req.query;
        
        let dateFilter = '';
        let params = [];
        
        if (startDate && endDate) {
            dateFilter = 'WHERE DATE(cu.created_at) BETWEEN DATE(?) AND DATE(?)';
            params.push(startDate, endDate);
        } else if (startDate) {
            dateFilter = 'WHERE DATE(cu.created_at) >= DATE(?)';
            params.push(startDate);
        } else if (endDate) {
            dateFilter = 'WHERE DATE(cu.created_at) <= DATE(?)';
            params.push(endDate);
        }
        
        const data = await db.all(`
            SELECT 
                cu.created_at as data,
                u.email,
                u.whatsapp,
                ap.name as api_name,
                ap.provider,
                ap.model,
                cu.operation_type as tipo_operacao,
                cu.credits_used as creditos_usados,
                cu.units_consumed as unidades_consumidas
            FROM credit_usage cu
            JOIN users u ON cu.user_id = u.id
            JOIN api_providers ap ON cu.api_provider_id = ap.id
            ${dateFilter}
            ORDER BY cu.created_at DESC
        `, params);
        
        if (format === 'json') {
            res.json({ data });
        } else {
            // CSV
            const headers = ['Data', 'Email', 'WhatsApp', 'API', 'Provider', 'Modelo', 'Tipo Operação', 'Créditos Usados', 'Unidades Consumidas'];
            const csvRows = [
                headers.join(','),
                ...data.map(row => [
                    row.data || '',
                    `"${(row.email || '').replace(/"/g, '""')}"`,
                    `"${(row.whatsapp || '').replace(/"/g, '""')}"`,
                    `"${(row.api_name || '').replace(/"/g, '""')}"`,
                    `"${(row.provider || '').replace(/"/g, '""')}"`,
                    `"${(row.model || '').replace(/"/g, '""')}"`,
                    `"${(row.tipo_operacao || '').replace(/"/g, '""')}"`,
                    row.creditos_usados || 0,
                    row.unidades_consumidas || 0
                ].join(','))
            ];
            
            res.setHeader('Content-Type', 'text/csv; charset=utf-8');
            res.setHeader('Content-Disposition', `attachment; filename="creditos_${Date.now()}.csv"`);
            res.send('\ufeff' + csvRows.join('\n')); // BOM para Excel
        }
    } catch (error) {
        console.error('Erro ao exportar créditos:', error);
        res.status(500).json({ message: 'Erro ao exportar créditos' });
    }
});

// GET /api/admin/credits/transactions/:userId - Histórico de transações de um usuário com detalhes
app.get('/api/admin/credits/transactions/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { userId } = req.params;
        
        // Buscar transações com JOIN para obter detalhes de uso
        const transactions = await db.all(`
            SELECT 
                ct.id,
                ct.amount,
                ct.transaction_type,
                ct.description,
                ct.created_at,
                cu.operation_type,
                cu.details,
                cu.units_consumed,
                ap.name as api_name,
                ap.provider as api_provider,
                ap.model as api_model
            FROM credit_transactions ct
            LEFT JOIN credit_usage cu ON ct.user_id = cu.user_id 
                AND ABS(ct.amount) = cu.credits_used 
                AND DATE(ct.created_at) = DATE(cu.created_at)
                AND ct.transaction_type = 'debit'
            LEFT JOIN api_providers ap ON cu.api_provider_id = ap.id
            WHERE ct.user_id = ?
            ORDER BY ct.created_at DESC
            LIMIT 100
        `, [userId]);
        
        // Processar transações para adicionar informações detalhadas
        const processedTransactions = transactions.map(t => {
            let details = null;
            let operationInfo = null;
            
            if (t.details) {
                try {
                    details = typeof t.details === 'string' ? JSON.parse(t.details) : t.details;
                } catch (e) {
                    details = { raw: t.details };
                }
            }
            
            // Montar informação detalhada sobre a operação
            if (t.operation_type) {
                const operationTypes = {
                    // Roteiros
                    'api_script_agents_generate': 'Gerador de Roteiro',
                    '/api/generate': 'Gerador de Roteiro',
                    '/api/scripts': 'Gerador de Roteiro',
                    '/api/scripts/generate': 'Gerador de Roteiro',
                    '/api/script-agents/:agentId/generate': 'Gerador de Roteiro',
                    '/api/script-agents/:agentId/generate/laozhang': 'Gerador de Roteiro',
                    // Vídeos
                    'api_video_generation': 'Gerador de Vídeo',
                    // Voz
                    'api_tts_generation': 'Geração de Voz',
                    'api_tts_preview': 'Preview de Voz',
                    // Imagens
                    'api_image_generation': 'Geração de Imagem',
                    // Thumbnails
                    'api_analyze_thumbnail': 'Gerador de Thumbnail',
                    '/api/analyze/thumbnail': 'Gerador de Thumbnail',
                    '/api/analyze/thumbnail/laozhang': 'Gerador de Thumbnail',
                    // Cenas
                    '/api/generate/scene-prompts': 'Gerador de Cenas',
                    '/api/generate/scene-prompts/laozhang': 'Gerador de Cenas',
                    // Análise de Títulos
                    '/api/analyze/titles': 'Análise de Títulos',
                    '/api/analyze/titles/laozhang': 'Análise de Títulos',
                    // Detecção de Personagens
                    'api_detect_characters': 'Detecção de Personagens',
                    '/api/detect/characters': 'Detecção de Personagens',
                    '/api/detect/characters/laozhang': 'Detecção de Personagens',
                    // Busca de Subnicho
                    'api_niche_find_subniche': 'Busca de Subnicho',
                    '/api/niche/find-subniche': 'Busca de Subnicho',
                    '/api/niche/find-subniche/laozhang': 'Busca de Subnicho',
                    // Análise de Competidor
                    'api_niche_analyze_competitor': 'Análise de Competidor',
                    '/api/niche/analyze-competitor': 'Análise de Competidor',
                    '/api/niche/analyze-competitor/laozhang': 'Análise de Competidor',
                    // Criação de Agente
                    '/api/script-agents/create': 'Criação de Agente',
                    '/api/script-agents/create/laozhang': 'Criação de Agente',
                    // Reescrever Prompt
                    'api_rewrite_prompt': 'Reescrever Prompt',
                    '/api/rewrite/blocked-prompt': 'Reescrever Prompt',
                    '/api/rewrite/blocked-prompt/laozhang': 'Reescrever Prompt',
                    // Análise de Transcrição
                    'api_transcript_analyze': 'Análise de Transcrição',
                    '/api/video/transcript/analyze': 'Análise de Transcrição',
                    '/api/video/transcript/analyze/laozhang': 'Análise de Transcrição',
                    // Genéricos
                    'api_generation': 'Geração de Conteúdo',
                    'api_call': 'Ferramenta'
                };
                
                // Tentar extrair nome da ferramenta da descrição se ela contiver "Ferramenta - Laozhang.ai"
                let toolName = operationTypes[t.operation_type];
                
                // Se não encontrou pelo operationType, tentar pelo endpoint nos details
                if (!toolName && details?.endpoint) {
                    for (const [key, value] of Object.entries(operationTypes)) {
                        if (details.endpoint.includes(key) || key.includes(details.endpoint)) {
                            toolName = value;
                            break;
                        }
                    }
                }
                
                // Se ainda não encontrou, usar fallback
                if (!toolName) {
                    toolName = operationTypes[t.operation_type] || t.operation_type;
                }
                
                // Priorizar modelo dos details (modelo real usado), depois api_model (modelo do provider), depois descrição
                let modelName = details?.model || t.api_model || 'N/A';
                
                // Se a descrição contém "Ferramenta - Laozhang.ai", tentar extrair informações
                if ((!modelName || modelName === 'N/A') && t.description && t.description.includes('Ferramenta - Laozhang.ai')) {
                    // Tentar extrair o modelo da descrição
                    const modelMatch = t.description.match(/\(([^)]+)\)/);
                    if (modelMatch && modelMatch[1]) {
                        modelName = modelMatch[1];
                    }
                }
                
                // Se ainda não tem modelo, tentar extrair da descrição atual
                if ((!modelName || modelName === 'N/A') && t.description && t.description.includes(' - ')) {
                    const parts = t.description.split(' - ');
                    if (parts.length > 1) {
                        const possibleModel = parts[parts.length - 1];
                        // Verificar se parece um modelo (não é apenas o nome da ferramenta)
                        if (possibleModel && !possibleModel.includes('Gerador') && !possibleModel.includes('Ferramenta')) {
                            modelName = possibleModel;
                        }
                    }
                }
                
                // Formatar modelo se necessário
                if (modelName && modelName !== 'N/A') {
                    if (modelName.includes('claude-3-7-sonnet') || modelName === 'claude-3-7-sonnet-20250219') {
                        modelName = 'Claude 3.7 Sonnet';
                    } else if (modelName.includes('gemini-2.5-pro') || modelName === 'gemini-2.5-pro') {
                        modelName = 'Gemini 2.5 Pro';
                    } else if (modelName === 'gpt-4o' || modelName.includes('gpt-4o')) {
                        modelName = 'GPT-4o';
                    } else if (modelName.includes('veo-3.1-landscape-fast-fl') || modelName === 'veo-3.1-landscape-fast-fl') {
                        modelName = 'Veo 3.1 Landscape Fast';
                    } else if (modelName.includes('veo-3.1-landscape-fast') || modelName === 'veo-3.1-landscape-fast') {
                        modelName = 'Veo 3.1 Landscape Fast';
                    } else if (modelName.includes('veo-3.1-landscape-fl') || modelName === 'veo-3.1-landscape-fl') {
                        modelName = 'Veo 3.1 Landscape';
                    } else if (modelName.includes('veo-3.1-landscape') || modelName === 'veo-3.1-landscape') {
                        modelName = 'Veo 3.1 Landscape';
                    } else if (modelName.includes('veo-3.1-fast-fl') || modelName === 'veo-3.1-fast-fl') {
                        modelName = 'Veo 3.1 Fast';
                    } else if (modelName.includes('veo-3.1-fast') || modelName === 'veo-3.1-fast-generate-preview' || modelName === 'veo-3.1-fast') {
                        modelName = 'Veo 3.1 Fast';
                    } else if (modelName.includes('veo-3.1-fl') || modelName === 'veo-3.1-fl') {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('veo-3.1-generate') || modelName === 'veo-3.1-generate-preview' || modelName === 'veo-3.1') {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('veo-3.1')) {
                        modelName = 'Veo 3.1';
                    }
                }
                
                operationInfo = {
                    type: t.operation_type,
                    typeName: toolName,
                    model: modelName !== 'N/A' ? modelName : null,
                    units: t.units_consumed || null,
                    endpoint: details?.endpoint || null,
                    details: details
                };
            }
            
            // Se a descrição contém "Ferramenta - Laozhang.ai", substituir pela descrição correta baseada no operationInfo
            let finalDescription = t.description;
            if (finalDescription && finalDescription.includes('Ferramenta - Laozhang.ai')) {
                if (operationInfo && operationInfo.typeName) {
                    finalDescription = operationInfo.typeName;
                    if (operationInfo.model) {
                        finalDescription += ` - ${operationInfo.model}`;
                    }
                }
            }
            
            return {
                id: t.id,
                amount: t.amount,
                transaction_type: t.transaction_type,
                description: finalDescription,
                created_at: t.created_at,
                operation: operationInfo,
                isCredit: t.transaction_type === 'credit'
            };
        });
        
        res.json({ data: processedTransactions });
    } catch (error) {
        console.error('Erro ao buscar transações:', error);
        res.status(500).json({ message: 'Erro ao buscar transações' });
    }
});

// DELETE /api/admin/credits/transactions/:userId/clear - Zerar histórico de transações de um usuário
app.delete('/api/admin/credits/transactions/:userId/clear', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { userId } = req.params;
        const userIdInt = parseInt(userId);
        
        if (!userIdInt || isNaN(userIdInt)) {
            return res.status(400).json({ message: 'ID do usuário inválido' });
        }
        
        // Verificar se o usuário existe
        const user = await db.get('SELECT id, email FROM users WHERE id = ?', [userIdInt]);
        if (!user) {
            return res.status(404).json({ message: 'Usuário não encontrado' });
        }
        
        // Deletar todas as transações do usuário
        const deleteResult = await db.run(
            'DELETE FROM credit_transactions WHERE user_id = ?',
            [userIdInt]
        );
        
        // Deletar também os registros de uso de créditos relacionados
        await db.run(
            'DELETE FROM credit_usage WHERE user_id = ?',
            [userIdInt]
        );
        
        console.log(`[Admin] Histórico de transações zerado para usuário ${userIdInt} (${user.email}) por admin ${req.user.id}`);
        
        res.json({ 
            success: true, 
            message: 'Histórico de transações zerado com sucesso',
            deletedTransactions: deleteResult.changes || 0
        });
    } catch (error) {
        console.error('Erro ao zerar histórico de transações:', error);
        res.status(500).json({ message: 'Erro ao zerar histórico de transações' });
    }
});

// GET /api/admin/credits/users-with-balance - Lista usuários com saldo (com paginação e busca)
app.get('/api/admin/credits/users-with-balance', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { min_balance = 0, limit = 100, offset = 0, search = '' } = req.query;
        
        // Construir cláusula WHERE com busca opcional
        let whereClause = 'WHERE COALESCE(uc.balance, 0) >= ?';
        let queryParams = [parseFloat(min_balance)];
        
        if (search && search.trim()) {
            const searchTerm = `%${search.trim()}%`;
            whereClause += ` AND (
                LOWER(u.email) LIKE LOWER(?) 
                OR LOWER(COALESCE(u.whatsapp, '')) LIKE LOWER(?)
                OR LOWER(COALESCE(u.name, '')) LIKE LOWER(?)
            )`;
            queryParams.push(searchTerm, searchTerm, searchTerm);
        }
        
        const users = await db.all(`
            SELECT 
                u.id,
                u.email,
                u.whatsapp,
                u.name,
                COALESCE(uc.balance, 0) as balance,
                uc.updated_at as last_updated
            FROM users u
            LEFT JOIN user_credits uc ON u.id = uc.user_id
            ${whereClause}
            ORDER BY uc.balance DESC, u.email ASC
            LIMIT ? OFFSET ?
        `, [...queryParams, parseInt(limit), parseInt(offset)]);
        
        // Query para total com mesma busca
        let totalWhereClause = 'WHERE COALESCE(uc.balance, 0) >= ?';
        let totalParams = [parseFloat(min_balance)];
        if (search && search.trim()) {
            const searchTerm = `%${search.trim()}%`;
            totalWhereClause += ` AND (
                LOWER(u.email) LIKE LOWER(?) 
                OR LOWER(COALESCE(u.whatsapp, '')) LIKE LOWER(?)
                OR LOWER(COALESCE(u.name, '')) LIKE LOWER(?)
            )`;
            totalParams.push(searchTerm, searchTerm, searchTerm);
        }
        
        const total = await db.get(`
            SELECT COUNT(*) as count
            FROM users u
            LEFT JOIN user_credits uc ON u.id = uc.user_id
            ${totalWhereClause}
        `, totalParams);
        
        res.json({ 
            users: users.map(u => ({
                id: u.id,
                email: u.email,
                whatsapp: u.whatsapp || null,
                name: u.name || null,
                balance: parseFloat(u.balance || 0),
                last_updated: u.last_updated
            })),
            total: total.count,
            limit: parseInt(limit),
            offset: parseInt(offset)
        });
    } catch (error) {
        console.error('Erro ao buscar usuários com créditos:', error);
        res.status(500).json({ message: 'Erro ao buscar usuários' });
    }
});

// POST /api/admin/credits/balance - Consulta saldo por email, WhatsApp ou nome
app.post('/api/admin/credits/balance', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { identifier } = req.body;
        if (!identifier) return res.status(400).json({ message: 'Identificador é obrigatório' });
        
        // Buscar por email, whatsapp ou nome (busca parcial, case-insensitive)
        const searchTerm = `%${identifier}%`;
        const user = await db.get(`
            SELECT id, email, whatsapp, name 
            FROM users 
            WHERE LOWER(email) LIKE LOWER(?) 
               OR LOWER(COALESCE(whatsapp, '')) LIKE LOWER(?)
               OR LOWER(COALESCE(name, '')) LIKE LOWER(?)
            LIMIT 1
        `, [searchTerm, searchTerm, searchTerm]);
        
        if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });
        
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [user.id]);
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [user.id]);
            credits = { balance: 0 };
        }
        
        res.json({ user: { id: user.id, email: user.email, whatsapp: user.whatsapp, name: user.name }, balance: credits.balance });
    } catch (error) {
        console.error('Erro ao consultar saldo:', error);
        res.status(500).json({ message: 'Erro ao consultar saldo' });
    }
});

// GET /api/app-settings/laozhang-status - Verificar se laozhang.ai está ativa (público para usuários autenticados)
app.get('/api/app-settings/laozhang-status', authenticateToken, async (req, res) => {
    try {
        const laozhangDefaultSetting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
        let laozhangUseAsDefault = false;
        if (laozhangDefaultSetting) {
            try {
                const parsedValue = JSON.parse(laozhangDefaultSetting.value);
                laozhangUseAsDefault = parsedValue === true || parsedValue === 'true' || parsedValue === 1;
            } catch (e) {
                laozhangUseAsDefault = laozhangDefaultSetting.value === 'true' || laozhangDefaultSetting.value === '1';
            }
        }
        res.json({ laozhang_use_as_default: laozhangUseAsDefault });
    } catch (err) {
        console.error("Erro ao verificar status laozhang.ai:", err.message);
        res.json({ laozhang_use_as_default: false });
    }
});

// GET /api/admin/app-settings - Buscar configurações da aplicação
app.get('/api/admin/app-settings', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings");
        const settings = rows.reduce((acc, row) => {
            try {
                acc[row.key] = JSON.parse(row.value);
            } catch (e) {
                acc[row.key] = row.value; // fallback for non-json values
            }
            return acc;
        }, {});
        
        // Garantir que initial_bonus_credits existe (padrão: 0)
        if (settings.initial_bonus_credits === undefined) {
            settings.initial_bonus_credits = 0;
        }
        
        // Garantir que tts_credits_multiplier existe (padrão: 1.0)
        if (settings.tts_credits_multiplier === undefined) {
            settings.tts_credits_multiplier = 1.0;
        }
        
        // Garantir que laozhang_use_as_default existe (padrão: false)
        if (settings.laozhang_use_as_default === undefined) {
            settings.laozhang_use_as_default = false;
        }
        
        res.json(settings);
    } catch (err) {
        console.error("Erro ao buscar app settings:", err.message);
        res.status(500).json({ message: "Erro ao buscar configurações." });
    }
});

// POST /api/admin/app-settings - Salvar configurações da aplicação
app.post('/api/admin/app-settings', authenticateToken, isAdmin, async (req, res) => {
    const { settings } = req.body;
    try {
        for (const [key, value] of Object.entries(settings)) {
            // Para voice_api_key, salvar como string simples (não JSON)
            if (key === 'voice_api_key' && typeof value === 'string') {
                await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [key, value]);
            } else {
                await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [key, JSON.stringify(value)]);
            }
        }
        res.json({ message: 'Configurações da aplicação salvas.' });
    } catch (err) {
        console.error("Erro ao salvar app settings:", err.message);
        res.status(500).json({ message: "Erro ao salvar configurações." });
    }
});

// GET /api/admin/whatsapp-config - Obter configurações do WhatsApp
app.get('/api/admin/whatsapp-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key IN ('whatsapp_token', 'whatsapp_number_id')");
        const config = {};
        rows.forEach(row => {
            try {
                config[row.key] = JSON.parse(row.value);
            } catch (e) {
                config[row.key] = row.value;
            }
        });
        res.json(config);
    } catch (err) {
        console.error("Erro ao buscar configurações do WhatsApp:", err.message);
        res.status(500).json({ message: "Erro ao buscar configurações do WhatsApp." });
    }
});

// POST /api/admin/whatsapp-config - Salvar configurações do WhatsApp
app.post('/api/admin/whatsapp-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { token, number_id } = req.body;
        
        if (token !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['whatsapp_token', JSON.stringify(token)]);
        }
        
        if (number_id !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['whatsapp_number_id', JSON.stringify(number_id)]);
        }
        
        res.json({ message: 'Configurações do WhatsApp salvas com sucesso.' });
    } catch (err) {
        console.error("Erro ao salvar configurações do WhatsApp:", err.message);
        res.status(500).json({ message: "Erro ao salvar configurações do WhatsApp." });
    }
});

// GET /api/admin/email-templates - Obter templates de email
app.get('/api/admin/email-templates', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key LIKE 'email_template_%'");
        const templates = {};
        rows.forEach(row => {
            try {
                const templateType = row.key.replace('email_template_', '').replace('_subject', '').replace('_body', '');
                if (!templates[templateType]) templates[templateType] = {};
                if (row.key.includes('_subject')) {
                    templates[templateType].subject = JSON.parse(row.value);
                } else if (row.key.includes('_body')) {
                    templates[templateType].body = JSON.parse(row.value);
                }
            } catch (e) {
                // Ignorar erros de parse
            }
        });
        res.json(templates);
    } catch (err) {
        console.error("Erro ao buscar templates de email:", err.message);
        res.status(500).json({ message: "Erro ao buscar templates de email." });
    }
});

// POST /api/admin/email-templates - Salvar template de email
app.post('/api/admin/email-templates', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { template_type, subject, body } = req.body;
        
        if (!template_type || !subject || !body) {
            return res.status(400).json({ message: 'template_type, subject e body são obrigatórios' });
        }
        
        await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [`email_template_${template_type}_subject`, JSON.stringify(subject)]);
        await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [`email_template_${template_type}_body`, JSON.stringify(body)]);
        
        res.json({ message: 'Template de email salvo com sucesso.' });
    } catch (err) {
        console.error("Erro ao salvar template de email:", err.message);
        res.status(500).json({ message: "Erro ao salvar template de email." });
    }
});

// POST /api/admin/email-templates/test - Testar envio de template de email
app.post('/api/admin/email-templates/test', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { template_type, test_email } = req.body;
        
        if (!template_type) {
            return res.status(400).json({ message: "Tipo de template é obrigatório." });
        }
        
        if (!test_email) {
            return res.status(400).json({ message: "Email de teste é obrigatório." });
        }
        
        // Validar formato de email
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(test_email)) {
            return res.status(400).json({ message: "Email inválido." });
        }
        
        // Variáveis de exemplo para cada tipo de template
        const exampleVariables = {
            register: {
                nome: 'João Silva',
                email: test_email,
                creditos_iniciais: '100',
                link_acesso: 'https://lacasadarkcore.com/login'
            },
            cancel: {
                nome: 'João Silva',
                email: test_email,
                plano: 'MASTER PRO Mensal',
                data_cancelamento: new Date().toLocaleDateString('pt-BR'),
                data_fim_acesso: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR')
            },
            payment: {
                nome: 'João Silva',
                email: test_email,
                plano: 'MASTER PRO Mensal',
                valor: 'R$ 297,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR')
            },
            package: {
                nome: 'João Silva',
                email: test_email,
                pacote: 'Pacote Premium',
                creditos: '500',
                valor: 'R$ 99,90',
                data_compra: new Date().toLocaleDateString('pt-BR'),
                saldo_atual: '600'
            },
            password_reset: {
                nome: 'João Silva',
                email: test_email,
                senha_provisoria: 'TempPass123!',
                link_acesso: 'https://lacasadarkcore.com/login'
            },
            'subscription_plan-start': {
                nome: 'João Silva',
                email: test_email,
                plano: 'START CREATOR Mensal',
                valor: 'R$ 79,90',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '100'
            },
            'subscription_plan-turbo': {
                nome: 'João Silva',
                email: test_email,
                plano: 'TURBO MAKER Mensal',
                valor: 'R$ 197,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '500'
            },
            'subscription_plan-master': {
                nome: 'João Silva',
                email: test_email,
                plano: 'MASTER PRO Mensal',
                valor: 'R$ 297,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '1000'
            },
            'subscription_plan-start-annual': {
                nome: 'João Silva',
                email: test_email,
                plano: 'START CREATOR Anual',
                valor: 'R$ 799,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '1200'
            },
            'subscription_plan-turbo-annual': {
                nome: 'João Silva',
                email: test_email,
                plano: 'TURBO MAKER Anual',
                valor: 'R$ 1.970,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '6000'
            },
            'subscription_plan-master-annual': {
                nome: 'João Silva',
                email: test_email,
                plano: 'MASTER PRO Anual',
                valor: 'R$ 2.970,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '12000'
            }
        };
        
        const variables = exampleVariables[template_type] || {
            nome: 'João Silva',
            email: test_email
        };
        
        console.log(`[EMAIL TEST] Enviando email de teste para template: ${template_type}`);
        console.log(`[EMAIL TEST] Email de destino: ${test_email}`);
        
        const result = await sendTemplateEmail(template_type, test_email, variables);
        
        if (result.success) {
            res.status(200).json({ 
                message: `Email de teste enviado com sucesso para ${test_email}`,
                messageId: result.messageId,
                accepted: result.accepted
            });
        } else {
            res.status(500).json({ 
                message: `Erro ao enviar email de teste: ${result.error || result.message}`,
                error: result.error
            });
        }
    } catch (err) {
        console.error("[EMAIL TEST] Erro ao testar template de email:", err.message);
        res.status(500).json({ message: "Erro ao testar template de email.", error: err.message });
    }
});

// GET /api/admin/smtp-config - Obter configurações SMTP
app.get('/api/admin/smtp-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key LIKE 'smtp_%'");
        const config = {};
        rows.forEach(row => {
                const key = row.key.replace('smtp_', '');
            // Valores já são strings simples, não precisam de JSON.parse
            let value = row.value;
            
            // Remover aspas duplas se existirem (corrigir dados antigos salvos incorretamente)
            if (typeof value === 'string') {
                value = value.replace(/^["']|["']$/g, '').trim();
            }
            
            // Se for senha, descriptografar
            if (key === 'password') {
                try {
                    // Verificar se está no formato criptografado (IV:encrypted)
                    if (value && value.includes(':') && !value.startsWith('"')) {
                        value = decrypt(value);
                        if (!value) {
                            // Se decrypt retornar null, usar o valor original (senha antiga não criptografada)
                            value = row.value.replace(/^["']|["']$/g, '').trim();
                        }
                    }
                    // Se não tiver ':', é senha antiga não criptografada, manter como está
            } catch (e) {
                    // Se falhar ao descriptografar, usar o valor original (senha antiga não criptografada)
                    console.warn('[SMTP Config] Senha não está criptografada ou erro ao descriptografar, usando valor original');
                    value = row.value.replace(/^["']|["']$/g, '').trim();
                }
            }
            
            // Converter secure para boolean
            if (key === 'secure') {
                value = value === 'true' || value === true;
            }
            
            // Converter port para número
            if (key === 'port') {
                value = parseInt(value) || 587;
            }
            
            config[key] = value;
        });
        console.log('[SMTP Config] Configurações carregadas:', Object.keys(config));
        res.json(config);
    } catch (err) {
        console.error("[SMTP Config] Erro ao buscar configurações SMTP:", err.message);
        res.status(500).json({ message: "Erro ao buscar configurações SMTP: " + err.message });
    }
});

// POST /api/admin/smtp-config - Salvar configurações SMTP
app.post('/api/admin/smtp-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { host, port, email, password, secure } = req.body;
        
        console.log('[SMTP Config] Salvando configurações:', { host, port, email, hasPassword: !!password, secure });
        
        // Remover aspas duplas dos valores antes de salvar
        const cleanHost = host ? String(host).replace(/^["']|["']$/g, '').trim() : null;
        const cleanEmail = email ? String(email).replace(/^["']|["']$/g, '').trim() : null;
        
        if (cleanHost && cleanHost !== '') {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_host', cleanHost]);
            console.log('[SMTP Config] Host salvo:', cleanHost);
        }
        if (port !== undefined && port !== null) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_port', String(port)]);
            console.log('[SMTP Config] Porta salva:', port);
        }
        if (cleanEmail && cleanEmail !== '') {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_email', cleanEmail]);
            console.log('[SMTP Config] Email salvo:', cleanEmail);
        }
        if (password !== undefined && password !== null && password !== '') {
            // Criptografar a senha antes de salvar
            const encryptedPassword = encrypt(password);
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_password', encryptedPassword]);
            console.log('[SMTP Config] Senha salva (criptografada)');
        }
        if (secure !== undefined && secure !== null) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_secure', String(secure)]);
            console.log('[SMTP Config] Secure salvo:', secure);
        }
        
        res.json({ message: 'Configurações SMTP salvas com sucesso.' });
    } catch (err) {
        console.error("[SMTP Config] Erro ao salvar configurações SMTP:", err.message);
        res.status(500).json({ message: "Erro ao salvar configurações SMTP: " + err.message });
    }
});

// POST /api/admin/smtp-config/test - Testar configuração SMTP enviando email de teste
app.post('/api/admin/smtp-config/test', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { testEmail } = req.body;
        
        if (!testEmail) {
            return res.status(400).json({ message: 'Email de teste não fornecido.' });
        }

        console.log('[SMTP Test] Iniciando teste de configuração SMTP...');
        console.log('[SMTP Test] Email de destino:', testEmail);

        // Obter configuração SMTP atual
        const smtpConfig = await getSMTPConfig();
        
        if (!smtpConfig || !smtpConfig.host || !smtpConfig.email || !smtpConfig.password) {
            return res.status(400).json({ 
                message: 'Configuração SMTP incompleta. Configure o servidor, email e senha antes de testar.' 
            });
        }

        // Limpar host e email de possíveis aspas (corrigir dados antigos)
        const cleanHost = smtpConfig.host ? String(smtpConfig.host).replace(/^["']|["']$/g, '').trim() : null;
        const cleanEmail = smtpConfig.email ? String(smtpConfig.email).replace(/^["']|["']$/g, '').trim() : null;
        
        console.log('[SMTP Test] Configuração SMTP encontrada:', {
            host: cleanHost,
            port: smtpConfig.port,
            email: cleanEmail,
            hasPassword: !!smtpConfig.password,
            secure: smtpConfig.secure
        });
        
        if (!cleanHost) {
            return res.status(400).json({ 
                message: 'Host SMTP inválido. Verifique as configurações.' 
            });
        }

        // Criar transporter com valores limpos
        const transporter = nodemailer.createTransport({
            host: cleanHost,
            port: parseInt(smtpConfig.port) || 587,
            secure: smtpConfig.secure === true || smtpConfig.secure === 'true',
            // Aceitar certificados autoassinados (comum em servidores SMTP privados)
            tls: {
                rejectUnauthorized: false,
                ciphers: 'SSLv3'
            },
            auth: {
                user: cleanEmail,
                pass: smtpConfig.password
            },
            // Timeout aumentado para conexões mais lentas
            connectionTimeout: 10000,
            greetingTimeout: 10000,
            socketTimeout: 10000
        });

        console.log('[SMTP Test] Verificando conexão SMTP...');
        
        // Verificar conexão
        await transporter.verify();
        console.log('[SMTP Test] ✅ Conexão SMTP verificada com sucesso');

        // Enviar email de teste
        const testSubject = 'Teste de Configuração SMTP - La Casa Dark Core';
        const testBody = `
            <html>
                <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
                    <div style="max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f9f9f9; border-radius: 8px;">
                        <h2 style="color: #f59e0b;">✅ Teste de Configuração SMTP</h2>
                        <p>Este é um email de teste para validar as configurações SMTP do La Casa Dark Core.</p>
                        <p><strong>Se você recebeu este email, significa que suas configurações SMTP estão funcionando corretamente!</strong></p>
                        <hr style="border: none; border-top: 1px solid #ddd; margin: 20px 0;">
                        <p style="color: #666; font-size: 12px;">
                            <strong>Detalhes da configuração:</strong><br>
                            Servidor: ${cleanHost}<br>
                            Porta: ${smtpConfig.port}<br>
                            Email de envio: ${cleanEmail}<br>
                            TLS/SSL: ${smtpConfig.secure ? 'Sim' : 'Não'}<br>
                            Data/Hora: ${new Date().toLocaleString('pt-BR')}
                        </p>
                    </div>
                </body>
            </html>
        `;

        console.log('[SMTP Test] Enviando email de teste...');
        
        const mailOptions = {
            from: `"La Casa Dark Core" <${cleanEmail}>`,
            to: testEmail,
            subject: testSubject,
            html: testBody,
            text: 'Este é um email de teste para validar as configurações SMTP do La Casa Dark Core. Se você recebeu este email, significa que suas configurações SMTP estão funcionando corretamente!'
        };

        const info = await transporter.sendMail(mailOptions);
        
        console.log('[SMTP Test] ✅ Email de teste enviado com sucesso!');
        console.log('[SMTP Test] Message ID:', info.messageId);

        res.json({ 
            message: `Email de teste enviado com sucesso para ${testEmail}! Verifique sua caixa de entrada.`,
            messageId: info.messageId
        });

    } catch (err) {
        console.error('[SMTP Test] ❌ Erro ao testar configuração SMTP:', err.message);
        console.error('[SMTP Test] Stack trace:', err.stack);
        
        let errorMessage = 'Erro ao enviar email de teste.';
        
        if (err.code === 'EAUTH') {
            errorMessage = 'Erro de autenticação. Verifique o email e senha do SMTP.';
        } else if (err.code === 'ECONNECTION' || err.code === 'ETIMEDOUT' || err.message.includes('Connection closed')) {
            errorMessage = 'Erro de conexão. Verifique o servidor SMTP, porta e se o TLS/SSL está configurado corretamente. Alguns servidores requerem STARTTLS na porta 587.';
        } else if (err.code === 'EENVELOPE') {
            errorMessage = 'Erro no endereço de email. Verifique o email de destino.';
        } else if (err.message.includes('self-signed certificate') || err.message.includes('certificate')) {
            errorMessage = 'Erro de certificado SSL. O servidor SMTP está usando um certificado autoassinado. Tente desmarcar "Usar TLS/SSL" ou verifique as configurações do servidor.';
        } else if (err.message) {
            errorMessage = `Erro: ${err.message}`;
        }
        
        res.status(500).json({ message: errorMessage });
    }
});

// ============================================
// SISTEMA DE ENVIO DE EMAILS
// ============================================

// Função para obter configuração SMTP
async function getSMTPConfig() {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key LIKE 'smtp_%'");
        const config = {};
        rows.forEach(row => {
                const key = row.key.replace('smtp_', '');
            let value = row.value;
            
            // Se for senha, descriptografar
            if (key === 'password') {
                try {
                    // Verificar se está no formato criptografado (IV:encrypted)
                    if (value && value.includes(':')) {
                        value = decrypt(value);
                        if (!value) {
                            // Se decrypt retornar null, usar o valor original (senha antiga não criptografada)
                            value = row.value;
                        }
                    }
                    // Se não tiver ':', é senha antiga não criptografada, manter como está
            } catch (e) {
                    // Se falhar ao descriptografar, usar o valor original (senha antiga não criptografada)
                    console.warn('[EMAIL] Senha SMTP não está criptografada ou erro ao descriptografar, usando valor original');
                    value = row.value;
            }
            }
            
            // Converter secure para boolean
            if (key === 'secure') {
                value = value === 'true' || value === true;
            }
            
            // Converter port para número
            if (key === 'port') {
                value = parseInt(value) || 587;
            }
            
            config[key] = value;
        });
        return config;
    } catch (error) {
        console.error('[EMAIL] Erro ao buscar configuração SMTP:', error.message);
        return null;
    }
}

// Função para criar transporter do nodemailer
async function createEmailTransporter() {
    const smtpConfig = await getSMTPConfig();
    
    if (!smtpConfig || !smtpConfig.host || !smtpConfig.email || !smtpConfig.password) {
        console.warn('[EMAIL] SMTP não configurado. Emails não serão enviados.');
        return null;
    }
    
    try {
        // Limpar host e email de possíveis aspas
        const cleanHost = smtpConfig.host ? String(smtpConfig.host).replace(/^["']|["']$/g, '').trim() : null;
        const cleanEmail = smtpConfig.email ? String(smtpConfig.email).replace(/^["']|["']$/g, '').trim() : null;
        
        const transporter = nodemailer.createTransport({
            host: cleanHost,
            port: parseInt(smtpConfig.port) || 587,
            secure: smtpConfig.secure === true || smtpConfig.secure === 'true',
            // Aceitar certificados autoassinados (comum em servidores SMTP privados)
            tls: {
                rejectUnauthorized: false,
                ciphers: 'SSLv3'
            },
            auth: {
                user: cleanEmail,
                pass: smtpConfig.password
            },
            // Timeout aumentado para conexões mais lentas
            connectionTimeout: 10000,
            greetingTimeout: 10000,
            socketTimeout: 10000
        });
        
        // Verificar conexão
        await transporter.verify();
        console.log('[EMAIL] SMTP configurado e verificado com sucesso');
        return transporter;
    } catch (error) {
        console.error('[EMAIL] Erro ao criar transporter:', error.message);
        return null;
    }
}

// Templates padrão para fallback
const defaultEmailTemplates = {
    password_reset: {
        subject: 'Reset de Senha - La Casa Dark Core',
        body: `
            <html>
                <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
                    <div style="background-color: #f9f9f9; border-radius: 8px; padding: 30px; border: 1px solid #ddd;">
                        <h2 style="color: #f59e0b; margin-top: 0;">🔐 Reset de Senha</h2>
                        <p>Olá <strong>{{nome}}</strong>,</p>
                        <p>Você solicitou a redefinição de senha para sua conta no La Casa Dark Core.</p>
                        <p>Clique no link abaixo para redefinir sua senha:</p>
                        <div style="text-align: center; margin: 30px 0;">
                            <a href="{{link_acesso}}" style="background-color: #f59e0b; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;">Redefinir Senha</a>
                        </div>
                        <p style="color: #666; font-size: 12px;">Ou copie e cole este link no seu navegador:</p>
                        <p style="color: #666; font-size: 12px; word-break: break-all;">{{link_acesso}}</p>
                        <p style="color: #999; font-size: 11px; margin-top: 30px; border-top: 1px solid #ddd; padding-top: 20px;">
                            Este link expira em 1 hora. Se você não solicitou esta redefinição, ignore este email.
                        </p>
                        <p style="color: #999; font-size: 11px;">
                            Equipe La Casa Dark Core
                        </p>
                    </div>
                </body>
            </html>
        `
    },
    register: {
        subject: 'Bem-vindo à La Casa Dark Core!',
        body: `
            <html>
                <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
                    <p>Olá {{nome}},</p>
                    <p>Bem-vindo à La Casa Dark Core! Sua conta foi criada com sucesso.</p>
                    <p>Créditos iniciais: {{creditos_iniciais}}</p>
                    <p><a href="{{link_acesso}}">Acessar minha conta</a></p>
                </body>
            </html>
        `
    }
};

// Função para obter template de email
async function getEmailTemplate(templateType) {
    try {
        const subjectRow = await db.get("SELECT value FROM app_settings WHERE key = ?", [`email_template_${templateType}_subject`]);
        const bodyRow = await db.get("SELECT value FROM app_settings WHERE key = ?", [`email_template_${templateType}_body`]);
        
        // Se não encontrar no banco, usar template padrão
        if (!subjectRow || !bodyRow) {
            if (defaultEmailTemplates[templateType]) {
                console.log(`[EMAIL] Usando template padrão para ${templateType}`);
                return defaultEmailTemplates[templateType];
            }
            return null;
        }
        
        let subject, body;
        try {
            subject = JSON.parse(subjectRow.value);
            body = JSON.parse(bodyRow.value);
        } catch {
            subject = subjectRow.value;
            body = bodyRow.value;
        }
        
        return { subject, body };
    } catch (error) {
        console.error(`[EMAIL] Erro ao buscar template ${templateType}:`, error.message);
        // Tentar usar template padrão em caso de erro
        if (defaultEmailTemplates[templateType]) {
            console.log(`[EMAIL] Usando template padrão para ${templateType} devido a erro`);
            return defaultEmailTemplates[templateType];
        }
        return null;
    }
}

// Função para substituir variáveis no template
function replaceTemplateVariables(template, variables) {
    if (!template) return '';
    
    let result = template;
    for (const [key, value] of Object.entries(variables)) {
        const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        result = result.replace(regex, value || '');
    }
    return result;
}

// Função para enviar email
async function sendEmail(to, subject, htmlBody, textBody = null) {
    try {
        const transporter = await createEmailTransporter();
        if (!transporter) {
            console.warn('[EMAIL] Transporter não disponível, email não enviado');
            return { success: false, message: 'SMTP não configurado' };
        }
        
        const smtpConfig = await getSMTPConfig();
        // Limpar email de possíveis aspas
        const fromEmail = smtpConfig && smtpConfig.email ? String(smtpConfig.email).replace(/^["']|["']$/g, '').trim() : 'noreply@lacasadarkcore.com';
        
        const mailOptions = {
            from: `"La Casa Dark Core" <${fromEmail}>`,
            to: to,
            subject: subject,
            html: htmlBody,
            text: textBody || htmlBody.replace(/<[^>]*>/g, ''), // Remover HTML se não houver texto
            // Adicionar headers para melhorar a entrega
            headers: {
                'X-Priority': '1',
                'X-MSMail-Priority': 'High',
                'Importance': 'high',
                'List-Unsubscribe': `<mailto:${fromEmail}?subject=unsubscribe>`,
                'X-Mailer': 'La Casa Dark Core'
            },
            // Adicionar informações de reply-to
            replyTo: fromEmail
        };
        
        console.log(`[EMAIL] Enviando email para: ${to}`);
        console.log(`[EMAIL] De: ${mailOptions.from}`);
        console.log(`[EMAIL] Assunto: ${mailOptions.subject}`);
        
        const info = await transporter.sendMail(mailOptions);
        
        console.log(`[EMAIL] ✅ Email aceito pelo servidor SMTP`);
        console.log(`[EMAIL] Message ID: ${info.messageId}`);
        console.log(`[EMAIL] Response: ${info.response || 'N/A'}`);
        console.log(`[EMAIL] Envelope:`, JSON.stringify(info.envelope || {}));
        
        // Verificar se o servidor SMTP realmente aceitou o email
        if (info.accepted && info.accepted.length > 0) {
            console.log(`[EMAIL] ✅ Email aceito para entrega: ${info.accepted.join(', ')}`);
        }
        if (info.rejected && info.rejected.length > 0) {
            console.error(`[EMAIL] ❌ Email rejeitado: ${info.rejected.join(', ')}`);
        }
        if (info.pending && info.pending.length > 0) {
            console.warn(`[EMAIL] ⚠️ Email pendente: ${info.pending.join(', ')}`);
        }
        
        return { success: true, messageId: info.messageId, response: info.response, accepted: info.accepted, rejected: info.rejected };
    } catch (error) {
        console.error('[EMAIL] ❌ Erro ao enviar email:', error.message);
        console.error('[EMAIL] Stack trace:', error.stack);
        if (error.response) {
            console.error('[EMAIL] Response do servidor:', error.response);
        }
        return { success: false, error: error.message };
    }
}

// Função para enviar email usando template
async function sendTemplateEmail(templateType, to, variables = {}) {
    try {
        const template = await getEmailTemplate(templateType);
        if (!template) {
            console.warn(`[EMAIL] Template ${templateType} não encontrado`);
            return { success: false, message: 'Template não encontrado' };
        }
        
        const subject = replaceTemplateVariables(template.subject, variables);
        const body = replaceTemplateVariables(template.body, variables);
        
        console.log(`[EMAIL] Preparando email ${templateType} para: ${to}`);
        console.log(`[EMAIL] Assunto: ${subject.substring(0, 50)}...`);
        
        const result = await sendEmail(to, subject, body);
        
        // Log adicional sobre o resultado
        if (result.success) {
            console.log(`[EMAIL] ✅ Email ${templateType} processado com sucesso`);
            if (result.accepted && result.accepted.length > 0) {
                console.log(`[EMAIL] 📬 Destinatários aceitos: ${result.accepted.join(', ')}`);
            }
            if (result.rejected && result.rejected.length > 0) {
                console.error(`[EMAIL] ❌ Destinatários rejeitados: ${result.rejected.join(', ')}`);
            }
        } else {
            console.error(`[EMAIL] ❌ Falha ao enviar email ${templateType}: ${result.error || result.message}`);
        }
        
        return result;
    } catch (error) {
        console.error(`[EMAIL] Erro ao enviar email com template ${templateType}:`, error.message);
        console.error(`[EMAIL] Stack trace:`, error.stack);
        return { success: false, error: error.message };
    }
}

// GET /api/admin/pixel-config - Obter configurações de Pixel/Ads
app.get('/api/admin/pixel-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key IN ('facebook_pixel_id', 'google_ads_id')");
        const config = {};
        rows.forEach(row => {
            try {
                config[row.key] = JSON.parse(row.value);
            } catch (e) {
                config[row.key] = row.value;
            }
        });
        res.json(config);
    } catch (err) {
        console.error("Erro ao buscar configurações de Pixel:", err.message);
        res.status(500).json({ message: "Erro ao buscar configurações de Pixel." });
    }
});

// POST /api/admin/pixel-config - Salvar configurações de Pixel/Ads
app.post('/api/admin/pixel-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { facebook_pixel_id, google_ads_id } = req.body;
        
        if (facebook_pixel_id !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['facebook_pixel_id', JSON.stringify(facebook_pixel_id)]);
        }
        
        if (google_ads_id !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['google_ads_id', JSON.stringify(google_ads_id)]);
        }
        
        res.json({ message: 'Configurações de Pixel salvas com sucesso.' });
    } catch (err) {
        console.error("Erro ao salvar configurações de Pixel:", err.message);
        res.status(500).json({ message: "Erro ao salvar configurações de Pixel." });
    }
});

// GET /api/admin/stripe-config - Obter configurações do Stripe
app.get('/api/admin/stripe-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key LIKE 'stripe_%'");
        const config = {};
        rows.forEach(row => {
            try {
                config[row.key.replace('stripe_', '')] = JSON.parse(row.value);
            } catch (e) {
                config[row.key.replace('stripe_', '')] = row.value;
            }
        });
        
        // Retornar em formato mais amigável
        res.json({
            publishable_key: config.publishable_key || null,
            secret_key: config.secret_key || null,
            webhook_secret: config.webhook_secret || null,
            plans: {
                'plan-free': config['plan-free'] || null,
                'plan-start': config['plan-start'] || null,
                'plan-turbo': config['plan-turbo'] || null,
                'plan-master': config['plan-master'] || null,
                'plan-start-annual': config['plan-start-annual'] || null,
                'plan-turbo-annual': config['plan-turbo-annual'] || null,
                'plan-master-annual': config['plan-master-annual'] || null,
                'package-1000': config['package-1000'] || null,
                'package-2500': config['package-2500'] || null,
                'package-5000': config['package-5000'] || null,
                'package-10000': config['package-10000'] || null,
                'package-20000': config['package-20000'] || null
            }
        });
    } catch (err) {
        console.error("Erro ao buscar configurações do Stripe:", err.message);
        res.status(500).json({ message: "Erro ao buscar configurações do Stripe." });
    }
});

// GET /api/admin/subscriptions - Obter dados de assinaturas
app.get('/api/admin/subscriptions', authenticateToken, isAdmin, async (req, res) => {
    try {
        const period = parseInt(req.query.period) || 30;
        const status = req.query.status || 'all';
        
        // Calcular datas
        const endDate = new Date();
        const startDate = new Date();
        if (period !== 0) {
            startDate.setDate(startDate.getDate() - period);
        } else {
            startDate.setFullYear(2000); // Para "all"
        }
        
        // Por enquanto, vamos criar uma estrutura de dados mockada
        // Quando você integrar com Stripe, substitua por dados reais
        const subscriptions = [];
        
        // Buscar assinaturas do banco (assumindo que você tem uma tabela de assinaturas)
        // Por enquanto, vamos retornar dados de exemplo
        const kpis = {
            mrr: 0,
            arr: 0,
            active_subscribers: 0,
            churn_rate: 0,
            mrr_change: 0,
            arr_change: 0,
            active_subscribers_change: 0,
            churn_rate_change: 0,
            new_subscribers: 0,
            cancellations: 0,
            ltv: 0,
            avg_duration: 0,
            // Novos campos
            total_revenue: 0,
            monthly_revenue: 0,
            total_subscriptions: 0,
            conversion_rate: 0,
            monthly_new: 0,
            monthly_canceled: 0,
            monthly_growth: 0,
            revenue_30d: 0,
            revenue_90d: 0,
            revenue_year: 0,
            avg_ticket: 0,
            total_canceled: 0,
            retention_rate: 0
        };
        
        const charts = {
            mrr: { labels: [], data: [] },
            subscribers: { labels: [], data: [] },
            plans_distribution: { labels: [], data: [] },
            churn: { labels: [], data: [] }
        };
        
        const insights = [
            {
                type: 'info',
                icon: 'info',
                title: 'Sistema de Assinaturas',
                message: 'Configure o Stripe e comece a receber assinaturas para ver dados reais aqui.'
            }
        ];
        
        // Tentar buscar dados reais se existir tabela de assinaturas
        try {
            // Verificar se existe tabela de assinaturas
            const tableExists = await db.get(`
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='subscriptions'
            `);
            
            if (tableExists) {
                // Verificar quais colunas existem na tabela
                const tableInfo = await db.all(`PRAGMA table_info(subscriptions)`);
                const columns = tableInfo.map(col => col.name);
                
                // Construir query dinamicamente baseado nas colunas disponíveis
                const hasMonthlyAmount = columns.includes('monthly_amount');
                const hasTotalPaid = columns.includes('total_paid');
                const hasDurationDays = columns.includes('duration_days');
                const hasPlanName = columns.includes('plan_name');
                const hasNextBilling = columns.includes('next_billing_date');
                const hasUpdatedAt = columns.includes('updated_at');
                const hasCanceledAt = columns.includes('canceled_at');
                
                // Buscar assinaturas
                let query = `
                    SELECT s.*, u.email as user_email, u.name as user_name
                    FROM subscriptions s
                    LEFT JOIN users u ON s.user_id = u.id
                    WHERE s.created_at >= ? AND s.created_at <= ?
                `;
                const params = [startDate.toISOString(), endDate.toISOString()];
                
                if (status !== 'all') {
                    query += ' AND s.status = ?';
                    params.push(status);
                }
                
                query += ' ORDER BY s.created_at DESC';
                
                const subs = await db.all(query, params);
                
                // Calcular KPIs
                let totalMRR = 0;
                let activeCount = 0;
                let newCount = 0;
                let cancelCount = 0;
                let totalPaid = 0;
                let totalDuration = 0;
                
                const planDistribution = {};
                
                subs.forEach(sub => {
                    if (sub.status === 'active') {
                        if (hasMonthlyAmount) {
                            totalMRR += parseFloat(sub.monthly_amount || 0);
                        }
                        activeCount++;
                    }
                    if (sub.status === 'canceled') {
                        cancelCount++;
                    }
                    if (new Date(sub.created_at) >= startDate) {
                        newCount++;
                    }
                    if (hasTotalPaid) {
                        totalPaid += parseFloat(sub.total_paid || 0);
                    }
                    if (hasDurationDays) {
                        totalDuration += parseInt(sub.duration_days || 0);
                    }
                    
                    const planName = (hasPlanName && sub.plan_name) ? sub.plan_name : 'Desconhecido';
                    planDistribution[planName] = (planDistribution[planName] || 0) + 1;
                });
                
                kpis.mrr = totalMRR;
                kpis.arr = totalMRR * 12;
                kpis.active_subscribers = activeCount;
                kpis.new_subscribers = newCount;
                kpis.cancellations = cancelCount;
                kpis.ltv = activeCount > 0 ? totalPaid / activeCount : 0;
                kpis.avg_duration = subs.length > 0 ? totalDuration / subs.length : 0;
                
                // Calcular receitas
                kpis.total_revenue = totalPaid;
                kpis.monthly_revenue = totalMRR;
                
                // Calcular receitas por período
                const now = new Date();
                const date30d = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                const date90d = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                const yearStart = new Date(now.getFullYear(), 0, 1);
                
                if (hasTotalPaid) {
                    const revenue30dQuery = `SELECT SUM(total_paid) as revenue FROM subscriptions WHERE created_at >= ?`;
                    const revenue30dResult = await db.get(revenue30dQuery, [date30d.toISOString()]);
                    kpis.revenue_30d = parseFloat(revenue30dResult?.revenue || 0);
                    
                    const revenue90dQuery = `SELECT SUM(total_paid) as revenue FROM subscriptions WHERE created_at >= ?`;
                    const revenue90dResult = await db.get(revenue90dQuery, [date90d.toISOString()]);
                    kpis.revenue_90d = parseFloat(revenue90dResult?.revenue || 0);
                    
                    const revenueYearQuery = `SELECT SUM(total_paid) as revenue FROM subscriptions WHERE created_at >= ?`;
                    const revenueYearResult = await db.get(revenueYearQuery, [yearStart.toISOString()]);
                    kpis.revenue_year = parseFloat(revenueYearResult?.revenue || 0);
                }
                
                // Calcular métricas mensais
                const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
                const monthlyNewQuery = `SELECT COUNT(*) as count FROM subscriptions WHERE created_at >= ?`;
                const monthlyNewResult = await db.get(monthlyNewQuery, [monthStart.toISOString()]);
                kpis.monthly_new = parseInt(monthlyNewResult?.count || 0);
                
                const monthlyCanceledQuery = `SELECT COUNT(*) as count FROM subscriptions WHERE status = 'canceled' AND updated_at >= ?`;
                const monthlyCanceledResult = await db.get(monthlyCanceledQuery, [monthStart.toISOString()]);
                kpis.monthly_canceled = parseInt(monthlyCanceledResult?.count || 0);
                
                // Calcular crescimento mensal
                const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
                const lastMonthNewQuery = `SELECT COUNT(*) as count FROM subscriptions WHERE created_at >= ? AND created_at <= ?`;
                const lastMonthNewResult = await db.get(lastMonthNewQuery, [lastMonthStart.toISOString(), lastMonthEnd.toISOString()]);
                const lastMonthNew = parseInt(lastMonthNewResult?.count || 0);
                kpis.monthly_growth = lastMonthNew > 0 ? ((kpis.monthly_new - lastMonthNew) / lastMonthNew) * 100 : 0;
                
                // Total de assinaturas
                const totalSubsQuery = `SELECT COUNT(*) as count FROM subscriptions`;
                const totalSubsResult = await db.get(totalSubsQuery);
                kpis.total_subscriptions = parseInt(totalSubsResult?.count || 0);
                
                // Total canceladas
                const totalCanceledQuery = `SELECT COUNT(*) as count FROM subscriptions WHERE status = 'canceled'`;
                const totalCanceledResult = await db.get(totalCanceledQuery);
                kpis.total_canceled = parseInt(totalCanceledResult?.count || 0);
                
                // Taxa de retenção
                const totalActive = kpis.active_subscribers;
                kpis.retention_rate = kpis.total_subscriptions > 0 ? (totalActive / kpis.total_subscriptions) * 100 : 0;
                
                // Ticket médio
                kpis.avg_ticket = subs.length > 0 ? totalPaid / subs.length : 0;
                
                // Taxa de conversão (assumindo que você tem dados de visitantes/usuários)
                // Por enquanto, vamos calcular baseado em novos assinantes vs total de usuários
                const totalUsersQuery = `SELECT COUNT(*) as count FROM users`;
                const totalUsersResult = await db.get(totalUsersQuery);
                const totalUsers = parseInt(totalUsersResult?.count || 1);
                kpis.conversion_rate = totalUsers > 0 ? (kpis.total_subscriptions / totalUsers) * 100 : 0;
                
                // Calcular churn rate (últimos 30 dias)
                if (hasUpdatedAt) {
                    const churnStartDate = new Date();
                    churnStartDate.setDate(churnStartDate.getDate() - 30);
                    const churnQuery = `
                        SELECT COUNT(*) as canceled_count
                        FROM subscriptions
                        WHERE status = 'canceled' AND updated_at >= ?
                    `;
                    const churnResult = await db.get(churnQuery, [churnStartDate.toISOString()]);
                    const canceledCount = churnResult?.canceled_count || 0;
                    const totalActive30DaysAgo = activeCount + canceledCount;
                    kpis.churn_rate = totalActive30DaysAgo > 0 ? (canceledCount / totalActive30DaysAgo) * 100 : 0;
                }
                
                // Preparar dados para gráficos (apenas se tiver colunas necessárias)
                if (hasMonthlyAmount) {
                    // MRR ao longo do tempo (últimos 12 meses)
                    for (let i = 11; i >= 0; i--) {
                        const date = new Date();
                        date.setMonth(date.getMonth() - i);
                        const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
                        const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                        
                        let mrrQuery = `
                            SELECT SUM(monthly_amount) as mrr
                            FROM subscriptions
                            WHERE status = 'active' AND created_at <= ?
                        `;
                        if (hasCanceledAt) {
                            mrrQuery += ' AND (status != \'canceled\' OR canceled_at > ?)';
                            const mrrResult = await db.get(mrrQuery, [monthEnd.toISOString(), monthEnd.toISOString()]);
                            charts.mrr.labels.push(monthStart.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                            charts.mrr.data.push(parseFloat(mrrResult?.mrr || 0));
                        } else {
                            const mrrResult = await db.get(mrrQuery, [monthEnd.toISOString()]);
                            charts.mrr.labels.push(monthStart.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                            charts.mrr.data.push(parseFloat(mrrResult?.mrr || 0));
                        }
                    }
                }
                
                // Assinantes ao longo do tempo
                for (let i = 11; i >= 0; i--) {
                    const date = new Date();
                    date.setMonth(date.getMonth() - i);
                    const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                    
                    let subsQuery = `
                        SELECT COUNT(*) as count
                        FROM subscriptions
                        WHERE status = 'active' AND created_at <= ?
                    `;
                    if (hasCanceledAt) {
                        subsQuery += ' AND (status != \'canceled\' OR canceled_at > ?)';
                        const subsResult = await db.get(subsQuery, [monthEnd.toISOString(), monthEnd.toISOString()]);
                        charts.subscribers.labels.push(date.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                        charts.subscribers.data.push(parseInt(subsResult?.count || 0));
                    } else {
                        const subsResult = await db.get(subsQuery, [monthEnd.toISOString()]);
                        charts.subscribers.labels.push(date.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                        charts.subscribers.data.push(parseInt(subsResult?.count || 0));
                    }
                }
                
                // Distribuição por plano
                charts.plans_distribution.labels = Object.keys(planDistribution);
                charts.plans_distribution.data = Object.values(planDistribution);
                
                // Churn mensal
                if (hasUpdatedAt) {
                    for (let i = 11; i >= 0; i--) {
                        const date = new Date();
                        date.setMonth(date.getMonth() - i);
                        const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
                        const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                        
                        const churnQuery = `
                            SELECT 
                                COUNT(CASE WHEN status = 'canceled' AND updated_at >= ? AND updated_at <= ? THEN 1 END) as canceled,
                                COUNT(CASE WHEN status = 'active' AND created_at <= ? THEN 1 END) as active
                            FROM subscriptions
                            WHERE created_at <= ?
                        `;
                        const churnResult = await db.get(churnQuery, [
                            monthStart.toISOString(), 
                            monthEnd.toISOString(),
                            monthEnd.toISOString(),
                            monthEnd.toISOString()
                        ]);
                        const canceled = churnResult?.canceled || 0;
                        const active = churnResult?.active || 1;
                        const churnRate = (canceled / active) * 100;
                        
                        charts.churn.labels.push(date.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                        charts.churn.data.push(churnRate);
                    }
                }
                
                // Preparar lista de assinaturas
                subscriptions.push(...subs.map(sub => ({
                    user_email: sub.user_email || 'N/A',
                    plan_name: (hasPlanName && sub.plan_name) ? sub.plan_name : 'N/A',
                    status: sub.status || 'unknown',
                    monthly_amount: hasMonthlyAmount ? parseFloat(sub.monthly_amount || 0) : 0,
                    start_date: sub.created_at,
                    next_billing_date: (hasNextBilling && sub.next_billing_date) ? sub.next_billing_date : null,
                    duration_days: hasDurationDays ? parseInt(sub.duration_days || 0) : 0,
                    total_paid: hasTotalPaid ? parseFloat(sub.total_paid || 0) : 0
                })));
                
                // Gerar insights
                insights.length = 0; // Limpar insights padrão
                
                if (kpis.mrr > 0) {
                    insights.push({
                        type: 'positive',
                        icon: 'trending-up',
                        title: 'MRR Crescente',
                        message: `Seu MRR atual é de ${kpis.mrr.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}. Continue focado em crescimento!`
                    });
                }
                
                if (kpis.churn_rate > 5) {
                    insights.push({
                        type: 'warning',
                        icon: 'alert-triangle',
                        title: 'Churn Rate Alto',
                        message: `Seu churn rate está em ${kpis.churn_rate.toFixed(2)}%. Considere melhorar a retenção de clientes.`
                    });
                }
                
                if (kpis.new_subscribers > 0) {
                    insights.push({
                        type: 'positive',
                        icon: 'user-plus',
                        title: 'Novos Assinantes',
                        message: `${kpis.new_subscribers} novos assinantes no período selecionado.`
                    });
                }
            }
        } catch (err) {
            console.log('Tabela de assinaturas não encontrada ou erro ao buscar:', err.message);
        }
        
        res.json({
            kpis,
            charts,
            subscriptions,
            insights
        });
    } catch (err) {
        console.error('Erro ao buscar assinaturas:', err);
        res.status(500).json({ message: 'Erro ao buscar dados de assinaturas' });
    }
});

// GET /api/admin/subscriptions/report/revenue - Relatório de receitas
app.get('/api/admin/subscriptions/report/revenue', authenticateToken, isAdmin, async (req, res) => {
    try {
        const tableExists = await db.get(`
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='subscriptions'
        `);
        
        if (!tableExists) {
            return res.status(404).json({ message: 'Tabela de assinaturas não encontrada' });
        }
        
        const tableInfo = await db.all(`PRAGMA table_info(subscriptions)`);
        const columns = tableInfo.map(col => col.name);
        const hasTotalPaid = columns.includes('total_paid');
        const hasMonthlyAmount = columns.includes('monthly_amount');
        
        const now = new Date();
        const date30d = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const date90d = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
        const yearStart = new Date(now.getFullYear(), 0, 1);
        
        let csv = 'Métrica,Valor\n';
        const totalRevenue = hasTotalPaid ? (await db.get('SELECT SUM(total_paid) as total FROM subscriptions')).total || 0 : 0;
        const revenue30d = hasTotalPaid ? (await db.get('SELECT SUM(total_paid) as total FROM subscriptions WHERE created_at >= ?', [date30d.toISOString()])).total || 0 : 0;
        const revenue90d = hasTotalPaid ? (await db.get('SELECT SUM(total_paid) as total FROM subscriptions WHERE created_at >= ?', [date90d.toISOString()])).total || 0 : 0;
        const revenueYear = hasTotalPaid ? (await db.get('SELECT SUM(total_paid) as total FROM subscriptions WHERE created_at >= ?', [yearStart.toISOString()])).total || 0 : 0;
        const mrr = hasMonthlyAmount ? (await db.get('SELECT SUM(monthly_amount) as mrr FROM subscriptions WHERE status = ?', ['active'])).mrr || 0 : 0;
        const arr = mrr * 12;
        
        csv += `Receita Total,${totalRevenue}\n`;
        csv += `Receita Últimos 30 Dias,${revenue30d}\n`;
        csv += `Receita Últimos 90 Dias,${revenue90d}\n`;
        csv += `Receita do Ano,${revenueYear}\n`;
        csv += `MRR,${mrr}\n`;
        csv += `ARR,${arr}\n`;
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=relatorio_receitas_${Date.now()}.csv`);
        res.send(csv);
    } catch (err) {
        console.error('Erro ao exportar relatório de receitas:', err);
        res.status(500).json({ message: 'Erro ao exportar relatório' });
    }
});

// GET /api/admin/subscriptions/report/subscriptions - Relatório de assinaturas
app.get('/api/admin/subscriptions/report/subscriptions', authenticateToken, isAdmin, async (req, res) => {
    try {
        const tableExists = await db.get(`
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='subscriptions'
        `);
        
        if (!tableExists) {
            return res.status(404).json({ message: 'Tabela de assinaturas não encontrada' });
        }
        
        const totalSubs = await db.get('SELECT COUNT(*) as count FROM subscriptions');
        const activeSubs = await db.get('SELECT COUNT(*) as count FROM subscriptions WHERE status = ?', ['active']);
        const canceledSubs = await db.get('SELECT COUNT(*) as count FROM subscriptions WHERE status = ?', ['canceled']);
        
        const now = new Date();
        const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
        const monthlyNew = await db.get('SELECT COUNT(*) as count FROM subscriptions WHERE created_at >= ?', [monthStart.toISOString()]);
        const monthlyCanceled = await db.get('SELECT COUNT(*) as count FROM subscriptions WHERE status = ? AND updated_at >= ?', ['canceled', monthStart.toISOString()]);
        
        let csv = 'Métrica,Valor\n';
        csv += `Total de Assinaturas,${totalSubs?.count || 0}\n`;
        csv += `Assinaturas Ativas,${activeSubs?.count || 0}\n`;
        csv += `Assinaturas Canceladas,${canceledSubs?.count || 0}\n`;
        csv += `Novos Este Mês,${monthlyNew?.count || 0}\n`;
        csv += `Cancelados Este Mês,${monthlyCanceled?.count || 0}\n`;
        const retentionRate = totalSubs?.count > 0 ? ((activeSubs?.count || 0) / totalSubs.count * 100).toFixed(2) : 0;
        csv += `Taxa de Retenção,${retentionRate}%\n`;
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=relatorio_assinaturas_${Date.now()}.csv`);
        res.send(csv);
    } catch (err) {
        console.error('Erro ao exportar relatório de assinaturas:', err);
        res.status(500).json({ message: 'Erro ao exportar relatório' });
    }
});

// GET /api/admin/subscriptions/export - Exportar assinaturas
app.get('/api/admin/subscriptions/export', authenticateToken, isAdmin, async (req, res) => {
    try {
        const period = parseInt(req.query.period) || 30;
        const status = req.query.status || 'all';
        
        const endDate = new Date();
        const startDate = new Date();
        if (period !== 0) {
            startDate.setDate(startDate.getDate() - period);
        }
        
        let query = `
            SELECT s.*, u.email as user_email, u.name as user_name
            FROM subscriptions s
            LEFT JOIN users u ON s.user_id = u.id
            WHERE s.created_at >= ? AND s.created_at <= ?
        `;
        const params = [startDate.toISOString(), endDate.toISOString()];
        
        if (status !== 'all') {
            query += ' AND s.status = ?';
            params.push(status);
        }
        
        query += ' ORDER BY s.created_at DESC';
        
        const subscriptions = await db.all(query, params);
        
        // Gerar CSV
        const csvHeader = 'Email,Plano,Status,Valor Mensal,Início,Próxima Cobrança,Duração (dias),Total Pago\n';
        const csvRows = subscriptions.map(sub => {
            return [
                sub.user_email || '',
                sub.plan_name || '',
                sub.status || '',
                parseFloat(sub.monthly_amount || 0).toFixed(2),
                sub.created_at || '',
                sub.next_billing_date || '',
                sub.duration_days || 0,
                parseFloat(sub.total_paid || 0).toFixed(2)
            ].join(',');
        }).join('\n');
        
        const csv = csvHeader + csvRows;
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=assinaturas_${Date.now()}.csv`);
        res.send(csv);
    } catch (err) {
        console.error('Erro ao exportar assinaturas:', err);
        res.status(500).json({ message: 'Erro ao exportar assinaturas' });
    }
});

// POST /api/admin/stripe-config - Salvar configurações do Stripe
app.post('/api/admin/stripe-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { publishable_key, secret_key, webhook_secret, plans } = req.body;
        
        if (publishable_key !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['stripe_publishable_key', JSON.stringify(publishable_key)]);
        }
        
        if (secret_key !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['stripe_secret_key', JSON.stringify(secret_key)]);
        }
        
        if (webhook_secret !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['stripe_webhook_secret', JSON.stringify(webhook_secret)]);
        }
        
        if (plans && typeof plans === 'object') {
            for (const [planKey, planValue] of Object.entries(plans)) {
                if (planValue !== undefined && planValue !== null && planValue !== '') {
                    await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [`stripe_${planKey}`, JSON.stringify(planValue)]);
                }
            }
        }
        
        res.json({ message: 'Configurações do Stripe salvas com sucesso.' });
    } catch (err) {
        console.error("Erro ao salvar configurações do Stripe:", err.message);
        res.status(500).json({ message: "Erro ao salvar configurações do Stripe." });
    }
});

// Função auxiliar para obter instância do Stripe
async function getStripeInstance() {
    try {
        const secretKeyRow = await db.get("SELECT value FROM app_settings WHERE key = 'stripe_secret_key'");
        if (!secretKeyRow || !secretKeyRow.value) {
            throw new Error('Chave secreta do Stripe não configurada');
        }
        const secretKey = JSON.parse(secretKeyRow.value);
        if (!secretKey || secretKey.trim() === '') {
            throw new Error('Chave secreta do Stripe inválida');
        }
        return new Stripe(secretKey);
    } catch (error) {
        console.error('[STRIPE] Erro ao criar instância:', error.message);
        throw error;
    }
}

// GET /api/stripe/plans - Obter IDs dos planos do Stripe
app.get('/api/stripe/plans', authenticateToken, async (req, res) => {
    try {
        const planKeys = [
            'plan-free',
            'plan-start',
            'plan-turbo',
            'plan-master',
            'plan-start-annual',
            'plan-turbo-annual',
            'plan-master-annual',
            'package-1000',
            'package-2500',
            'package-5000',
            'package-10000',
            'package-20000'
        ];
        
        const plans = {};
        for (const key of planKeys) {
            const row = await db.get("SELECT value FROM app_settings WHERE key = ?", [`stripe_${key}`]);
            if (row && row.value) {
                try {
                    plans[key] = JSON.parse(row.value);
                } catch {
                    plans[key] = row.value;
                }
            }
        }
        
        res.json({ success: true, plans });
    } catch (error) {
        console.error('[STRIPE] Erro ao buscar planos:', error.message);
        res.status(500).json({ success: false, message: 'Erro ao buscar planos do Stripe' });
    }
});

// POST /api/stripe/create-checkout - Criar sessão de checkout
app.post('/api/stripe/create-checkout', authenticateToken, async (req, res) => {
    try {
        const { planKey, planType } = req.body; // planType: 'subscription' ou 'one-time'
        
        if (!planKey) {
            return res.status(400).json({ success: false, message: 'ID do plano é obrigatório' });
        }
        
        // Buscar o Price ID do Stripe
        const row = await db.get("SELECT value FROM app_settings WHERE key = ?", [`stripe_${planKey}`]);
        if (!row || !row.value) {
            return res.status(404).json({ success: false, message: 'Plano não encontrado ou não configurado no Stripe' });
        }
        
        let priceId;
        try {
            priceId = JSON.parse(row.value);
        } catch {
            priceId = row.value;
        }
        
        if (!priceId || priceId.trim() === '') {
            return res.status(404).json({ success: false, message: 'Price ID do Stripe não configurado para este plano' });
        }
        
        // Validar se é um Price ID válido (deve começar com 'price_')
        if (!priceId.startsWith('price_')) {
            return res.status(400).json({ 
                success: false, 
                message: `ID inválido para o plano ${planKey}. Você configurou "${priceId}", mas precisa usar um Price ID (que começa com "price_"). Product IDs (que começam com "prod_") não funcionam.`,
                error: 'Invalid Price ID format',
                hint: 'No Stripe, você precisa usar o Price ID (price_...), não o Product ID (prod_...). Acesse o produto no Stripe e copie o Price ID correto.'
            });
        }
        
        // Obter dados do usuário
        const userId = req.user.id;
        const userData = await db.get("SELECT email FROM users WHERE id = ?", [userId]);
        if (!userData) {
            return res.status(404).json({ success: false, message: 'Usuário não encontrado' });
        }
        
        // Mapear planKey para nome do plano (ANTES de criar URLs)
        const planNames = {
            'plan-free': 'FREE',
            'plan-start': 'START CREATOR',
            'plan-turbo': 'TURBO MAKER',
            'plan-master': 'MASTER PRO',
            'plan-start-annual': 'START CREATOR Anual',
            'plan-turbo-annual': 'TURBO MAKER Anual',
            'plan-master-annual': 'MASTER PRO Anual',
            'package-1000': 'Pacote 1.000 Créditos',
            'package-2500': 'Pacote 2.500 Créditos',
            'package-5000': 'Pacote 5.000 Créditos',
            'package-10000': 'Pacote 10.000 Créditos',
            'package-20000': 'Pacote 20.000 Créditos'
        };
        
        const planName = planNames[planKey] || planKey;
        
        // Obter instância do Stripe
        let stripe;
        try {
            stripe = await getStripeInstance();
        } catch (error) {
            console.error('[STRIPE] Erro ao obter instância do Stripe:', error.message);
            return res.status(500).json({ 
                success: false, 
                message: 'Stripe não está configurado. Configure as chaves do Stripe no painel administrativo.',
                error: error.message
            });
        }
        
        // Configurar URLs de sucesso e cancelamento
        const protocol = req.protocol;
        const host = req.get('host');
        // URL de sucesso vai para página de agradecimento com informações do plano
        const successUrl = `${protocol}://${host}/thank-you.html?session_id={CHECKOUT_SESSION_ID}&planKey=${encodeURIComponent(planKey)}&planName=${encodeURIComponent(planName)}&success=true`;
        const cancelUrl = `${protocol}://${host}/plans.html?canceled=true`;
        
        console.log(`[STRIPE] Criando checkout para plano: ${planKey}, tipo: ${planType || 'subscription'}, priceId: ${priceId}`);
        
        // Criar sessão de checkout
        const sessionParams = {
            payment_method_types: ['card'],
            customer_email: userData.email,
            metadata: {
                userId: userId.toString(),
                planKey: planKey,
                planType: planType || 'subscription'
            },
            success_url: successUrl,
            cancel_url: cancelUrl
        };
        
        // Se for assinatura recorrente
        if (planType === 'subscription' || !planType) {
            sessionParams.mode = 'subscription';
            sessionParams.line_items = [{
                price: priceId,
                quantity: 1
            }];
        } else {
            // Se for pagamento único (pacotes avulsos)
            sessionParams.mode = 'payment';
            sessionParams.line_items = [{
                price: priceId,
                quantity: 1
            }];
        }
        
        let session;
        try {
            session = await stripe.checkout.sessions.create(sessionParams);
            console.log(`[STRIPE] Sessão criada com sucesso: ${session.id}`);
        } catch (stripeError) {
            console.error('[STRIPE] Erro ao criar sessão no Stripe:', stripeError.message);
            console.error('[STRIPE] Detalhes do erro:', stripeError);
            return res.status(500).json({ 
                success: false, 
                message: `Erro ao criar sessão no Stripe: ${stripeError.message}`,
                error: stripeError.message,
                details: stripeError.type || 'unknown'
            });
        }
        
        res.json({ 
            success: true, 
            sessionId: session.id,
            url: session.url
        });
    } catch (error) {
        console.error('[STRIPE] Erro geral ao criar checkout:', error.message);
        console.error('[STRIPE] Stack trace:', error.stack);
        res.status(500).json({ 
            success: false, 
            message: 'Erro ao criar sessão de checkout',
            error: error.message
        });
    }
});

// POST /api/stripe/webhook - Webhook do Stripe (não requer autenticação)
app.post('/api/stripe/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
    const sig = req.headers['stripe-signature'];
    
    try {
        // Obter webhook secret
        const webhookSecretRow = await db.get("SELECT value FROM app_settings WHERE key = 'stripe_webhook_secret'");
        if (!webhookSecretRow || !webhookSecretRow.value) {
            console.error('[STRIPE WEBHOOK] Webhook secret não configurado');
            return res.status(400).send('Webhook secret não configurado');
        }
        
        let webhookSecret;
        try {
            webhookSecret = JSON.parse(webhookSecretRow.value);
        } catch {
            webhookSecret = webhookSecretRow.value;
        }
        
        // Obter instância do Stripe
        const stripe = await getStripeInstance();
        
        // Verificar assinatura do webhook
        const event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
        
        // Processar eventos
        if (event.type === 'checkout.session.completed') {
            const session = event.data.object;
            const userId = session.metadata?.userId;
            const planKey = session.metadata?.planKey;
            
            if (userId && planKey) {
                // Obter dados do usuário
                const userData = await db.get("SELECT name, email, credits FROM users WHERE id = ?", [userId]);
                if (!userData) {
                    console.error(`[STRIPE WEBHOOK] Usuário ${userId} não encontrado`);
                    return res.json({ received: true });
                }
                
                // Mapear planKey para nome do plano no sistema
                const planMapping = {
                    'plan-free': 'plan-free',
                    'plan-start': 'plan-start',
                    'plan-turbo': 'plan-turbo',
                    'plan-master': 'plan-master',
                    'plan-start-annual': 'plan-start-annual',
                    'plan-turbo-annual': 'plan-turbo-annual',
                    'plan-master-annual': 'plan-master-annual',
                    'package-1000': 'plan-start', // Pacotes podem adicionar créditos
                    'package-2500': 'plan-turbo',
                    'package-5000': 'plan-master',
                    'package-10000': 'plan-master',
                    'package-20000': 'plan-master'
                };
                
                const systemPlan = planMapping[planKey] || planKey;
                
                // Nomes dos planos para email
                const planNames = {
                    'plan-start': 'START CREATOR',
                    'plan-turbo': 'TURBO MAKER',
                    'plan-master': 'MASTER PRO',
                    'plan-start-annual': 'START CREATOR Anual',
                    'plan-turbo-annual': 'TURBO MAKER Anual',
                    'plan-master-annual': 'MASTER PRO Anual',
                    'package-1000': 'Pacote 1.000 Créditos',
                    'package-2500': 'Pacote 2.500 Créditos',
                    'package-5000': 'Pacote 5.000 Créditos',
                    'package-10000': 'Pacote 10.000 Créditos',
                    'package-20000': 'Pacote 20.000 Créditos'
                };
                
                const planName = planNames[planKey] || planKey;
                const amount = session.amount_total ? (session.amount_total / 100).toFixed(2) : '0.00';
                const currency = session.currency?.toUpperCase() || 'BRL';
                const paymentDate = new Date().toLocaleDateString('pt-BR');
                
                // Atualizar plano do usuário
                if (session.mode === 'subscription') {
                    // Assinatura recorrente
                    await db.run(
                        "UPDATE users SET subscription_plan = ?, plan = ? WHERE id = ?",
                        [systemPlan, systemPlan, userId]
                    );
                    
                    // Recarregar créditos baseado no plano
                    const planCreditsRow = await db.get(
                        "SELECT monthly_credits FROM plan_credits WHERE plan_name = ?",
                        [systemPlan]
                    );
                    
                    if (planCreditsRow) {
                        await db.run(
                            "UPDATE users SET credits = ? WHERE id = ?",
                            [planCreditsRow.monthly_credits, userId]
                        );
                    }
                    
                    // Calcular próxima cobrança (30 dias para mensal, 365 para anual)
                    const nextBillingDate = new Date();
                    if (planKey.includes('annual')) {
                        nextBillingDate.setFullYear(nextBillingDate.getFullYear() + 1);
                    } else {
                        nextBillingDate.setMonth(nextBillingDate.getMonth() + 1);
                    }
                    const nextBilling = nextBillingDate.toLocaleDateString('pt-BR');
                    
                    // Enviar email de assinatura (usar template específico do plano ou genérico)
                    try {
                        const templateType = `subscription_${planKey}`;
                        const template = await getEmailTemplate(templateType);
                        
                        if (template) {
                            // Template específico do plano existe
                            await sendTemplateEmail(templateType, userData.email, {
                                nome: userData.name,
                                email: userData.email,
                                plano: planName,
                                valor: `R$ ${amount}`,
                                data_pagamento: paymentDate,
                                proxima_cobranca: nextBilling,
                                creditos: planCreditsRow?.monthly_credits || 0
                            });
                        } else {
                            // Usar template genérico de pagamento
                            await sendTemplateEmail('payment', userData.email, {
                                nome: userData.name,
                                email: userData.email,
                                plano: planName,
                                valor: `R$ ${amount}`,
                                data_pagamento: paymentDate,
                                proxima_cobranca: nextBilling
                            });
                        }
                    } catch (emailError) {
                        console.error('[EMAIL] Erro ao enviar email de assinatura:', emailError.message);
                    }
                } else {
                    // Pagamento único - adicionar créditos
                    const creditAmounts = {
                        'package-1000': 1000,
                        'package-2500': 2500,
                        'package-5000': 5000,
                        'package-10000': 10000,
                        'package-20000': 20000
                    };
                    
                    const creditsToAdd = creditAmounts[planKey] || 0;
                    if (creditsToAdd > 0) {
                        await db.run(
                            "UPDATE users SET credits = credits + ? WHERE id = ?",
                            [creditsToAdd, userId]
                        );
                        
                        // Obter saldo atualizado
                        const updatedUser = await db.get("SELECT credits FROM users WHERE id = ?", [userId]);
                        
                        // Enviar email de pacote comprado
                        try {
                            await sendTemplateEmail('package', userData.email, {
                                nome: userData.name,
                                email: userData.email,
                                pacote: planName,
                                creditos: creditsToAdd,
                                valor: `R$ ${amount}`,
                                data_compra: paymentDate,
                                saldo_atual: updatedUser?.credits || 0
                            });
                        } catch (emailError) {
                            console.error('[EMAIL] Erro ao enviar email de pacote:', emailError.message);
                        }
                    }
                }
                
                console.log(`[STRIPE WEBHOOK] Usuário ${userId} atualizado para plano ${systemPlan}`);
            }
        } else if (event.type === 'customer.subscription.deleted') {
            // Assinatura cancelada
            const subscription = event.data.object;
            const customerId = subscription.customer;
            
            // Buscar usuário pelo customer_id ou metadata
            try {
                // Tentar encontrar usuário pela subscription
                const userData = await db.get(
                    "SELECT id, name, email, subscription_plan FROM users WHERE id IN (SELECT user_id FROM subscriptions WHERE stripe_subscription_id = ?)",
                    [subscription.id]
                );
                
                if (userData) {
                    // Enviar email de cancelamento
                    const cancelDate = new Date().toLocaleDateString('pt-BR');
                    const endDate = new Date();
                    endDate.setMonth(endDate.getMonth() + 1); // Acesso até fim do período pago
                    const endAccessDate = endDate.toLocaleDateString('pt-BR');
                    
                    const planNames = {
                        'plan-start': 'START CREATOR',
                        'plan-turbo': 'TURBO MAKER',
                        'plan-master': 'MASTER PRO',
                        'plan-start-annual': 'START CREATOR Anual',
                        'plan-turbo-annual': 'TURBO MAKER Anual',
                        'plan-master-annual': 'MASTER PRO Anual'
                    };
                    
                    const planName = planNames[userData.subscription_plan] || userData.subscription_plan;
                    
                    await sendTemplateEmail('cancel', userData.email, {
                        nome: userData.name,
                        email: userData.email,
                        plano: planName,
                        data_cancelamento: cancelDate,
                        data_fim_acesso: endAccessDate
                    });
                }
            } catch (emailError) {
                console.error('[EMAIL] Erro ao enviar email de cancelamento:', emailError.message);
            }
            
            console.log(`[STRIPE WEBHOOK] Assinatura ${subscription.id} cancelada`);
        }
        
        res.json({ received: true });
    } catch (err) {
        console.error('[STRIPE WEBHOOK] Erro:', err.message);
        res.status(400).send(`Webhook Error: ${err.message}`);
    }
});

// POST /api/admin/voice-api-key/validate - Validar chave de voz do admin
app.post('/api/admin/voice-api-key/validate', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API é obrigatória' });
        }
        
        // Primeiro, tentar validar como chave do Google Cloud Text-to-Speech (que é o que vamos usar)
        try {
            const ttsResponse = await fetch(`https://texttospeech.googleapis.com/v1/voices?key=${encodeURIComponent(api_key)}&languageCode=pt-BR`);
            
            if (ttsResponse.status === 200) {
                const ttsData = await ttsResponse.json();
                if (ttsData.voices && ttsData.voices.length > 0) {
                    return res.json({ 
                        success: true, 
                        message: 'Chave do Google Cloud válida! Pode ser usada para Text-to-Speech.',
                        type: 'google-cloud',
                        details: `Encontradas ${ttsData.voices.length} vozes disponíveis para português brasileiro.`
                    });
                }
            } else if (ttsResponse.status === 401 || ttsResponse.status === 403) {
                const ttsError = await ttsResponse.json().catch(() => ({}));
                // Se a mensagem menciona que a API não está habilitada, a chave é válida mas precisa habilitar a API
                if (ttsError.error?.message && ttsError.error.message.includes('API has not been used')) {
                    return res.json({ 
                        success: true, 
                        message: 'Chave do Google Cloud válida. Habilite a API Text-to-Speech no Google Cloud Console.',
                        type: 'google-cloud',
                        warning: 'A API Text-to-Speech precisa ser habilitada no Google Cloud Console para usar TTS.'
                    });
                }
                return res.status(400).json({ 
                    success: false, 
                    message: ttsError.error?.message || 'Chave inválida ou sem permissão para Text-to-Speech.',
                    error: ttsError.error?.message
                });
            } else {
                const ttsError = await ttsResponse.json().catch(() => ({}));
                // Se der erro sobre API keys não suportadas, é chave do Google Cloud (não Gemini direto)
                if (ttsError.error?.message && ttsError.error.message.includes('API keys are not supported')) {
                    return res.json({ 
                        success: true, 
                        message: 'Chave do Google Cloud detectada. Esta chave funciona para Text-to-Speech e outros serviços do Google Cloud.',
                        type: 'google-cloud',
                        warning: 'Esta chave não funciona diretamente com a API do Gemini, mas funciona perfeitamente para Text-to-Speech (TTS).'
                    });
                }
                return res.status(400).json({ 
                    success: false, 
                    message: ttsError.error?.message || 'Erro ao validar chave do Google Cloud.',
                    error: ttsError.error?.message
                });
            }
        } catch (ttsErr) {
            console.log('[Validação] Erro ao validar via TTS, tentando validação Gemini...', ttsErr.message);
        }
        
        // Fallback: tentar validação Gemini (para chaves diretas do Gemini)
        const validationResult = await validateGeminiKey(api_key);
        
        if (validationResult.success) {
            res.json({ 
                success: true, 
                message: validationResult.message || 'Chave válida!',
                type: validationResult.type || 'gemini-api',
                warning: validationResult.warning || null
            });
        } else {
            // Se falhou, mas a mensagem indica que é chave do Google Cloud, considerar válida
            if (validationResult.error && validationResult.error.includes('API keys are not supported')) {
                return res.json({ 
                    success: true, 
                    message: 'Chave do Google Cloud detectada. Esta chave funciona para Text-to-Speech.',
                    type: 'google-cloud',
                    warning: 'Esta chave não funciona diretamente com a API do Gemini, mas funciona perfeitamente para Text-to-Speech (TTS).'
                });
            }
            
            res.status(400).json({ 
                success: false, 
                message: validationResult.error || 'Chave inválida',
                error: validationResult.error
            });
        }
    } catch (error) {
        console.error('Erro ao validar chave de voz:', error);
        res.status(500).json({ success: false, message: 'Erro ao validar chave', details: error.message });
    }
});

// POST /api/admin/openai-voice/validate - Validar chave de voz OpenAI
app.post('/api/admin/openai-voice/validate', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API é obrigatória' });
        }
        
        const validationResult = await validateOpenAIKey(api_key);
        if (validationResult.success) {
            return res.json({
                success: true,
                message: 'Chave OpenAI válida!',
                type: 'openai'
            });
        }
        
        return res.status(400).json({
            success: false,
            message: validationResult.error || 'Chave inválida',
            error: validationResult.error
        });
    } catch (error) {
        console.error('Erro ao validar chave OpenAI:', error);
        res.status(500).json({ success: false, message: 'Erro ao validar chave OpenAI', details: error.message });
    }
});

// POST /api/admin/video-api/validate - Validar chave de vídeo (Gemini/Veo)
app.post('/api/admin/video-api/validate', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API é obrigatória' });
        }
        
        const validationResult = await validateGeminiKey(api_key);
        if (validationResult.success) {
            return res.json({
                success: true,
                message: validationResult.message || 'Chave Gemini válida!',
                type: validationResult.type || 'gemini'
            });
        }
        
        return res.status(400).json({
            success: false,
            message: validationResult.error || 'Chave inválida',
            error: validationResult.error
        });
    } catch (error) {
        console.error('Erro ao validar chave de vídeo:', error);
        res.status(500).json({ success: false, message: 'Erro ao validar chave de vídeo', details: error.message });
    }
});

// POST /api/admin/voice-premium/check-balance - Verificar saldo da API Voz Premium
app.post('/api/admin/voice-premium/check-balance', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ message: 'Chave de API é obrigatória' });
        }
        
        // Verificar saldo na API GenAIPro conforme documentação oficial
        // Base URL: https://genaipro.vn/api/v1
        // Endpoint: GET /me - retorna informações do usuário incluindo balance
        try {
            const response = await axios.get('https://genaipro.vn/api/v1/me', {
                headers: {
                    'Authorization': `Bearer ${api_key}`,
                    'Content-Type': 'application/json'
                },
                timeout: 15000
            });
            
            if (response && response.data) {
                console.log('[La Casa Dark Core] Resposta do endpoint /me:', JSON.stringify(response.data).substring(0, 300));
                
                // Conforme documentação: { "balance": 1000, ... }
                const balance = response.data.balance;
                
                if (balance !== null && balance !== undefined) {
                    console.log(`[La Casa Dark Core] Saldo encontrado: ${balance}`);
                    res.json({ 
                        success: true, 
                        balance: parseFloat(balance),
                        message: 'Saldo verificado com sucesso'
                    });
                    return;
                }
            }
            
            // Se não encontrou balance, retornar sucesso mas sem saldo
            res.json({ 
                success: true, 
                balance: null,
                message: 'Chave válida, mas saldo não disponível na resposta'
            });
            
        } catch (apiError) {
            console.error('[La Casa Dark Core] Erro ao verificar saldo:', apiError.message);
            if (apiError.response) {
                console.error('[La Casa Dark Core] Status:', apiError.response.status);
                console.error('[La Casa Dark Core] Data:', apiError.response.data);
                
                // Se for erro 401, a chave é inválida
                if (apiError.response.status === 401) {
                    return res.status(401).json({ 
                        success: false,
                        message: 'Chave de API inválida ou expirada',
                        balance: null
                    });
                }
            }
            
            // Outros erros - retornar erro
            res.status(500).json({ 
                success: false,
                message: `Erro ao verificar saldo: ${apiError.message}`,
                balance: null
            });
        }
    } catch (error) {
        console.error('Erro ao verificar saldo:', error);
        res.status(500).json({ 
            success: false,
            message: 'Erro ao verificar saldo', 
            details: error.message,
            balance: null
        });
    }
});

// POST /api/admin/voice-premium/save - Salvar chave da API Voz Premium
app.post('/api/admin/voice-premium/save', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key, name = 'Voz Premium' } = req.body;
        if (!api_key) {
            return res.status(400).json({ message: 'Chave de API é obrigatória' });
        }
        
        // Verificar se já existe uma API Voz Premium
        let existingApi = await db.get(`
            SELECT * FROM api_providers 
            WHERE provider = 'genaipro' OR provider = 'voice_premium'
            LIMIT 1
        `);
        
        if (existingApi) {
            // Atualizar existente
            await db.run(`
                UPDATE api_providers SET
                    api_key = ?,
                    name = ?,
                    is_active = 1,
                    is_default = 1,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            `, [api_key, name, existingApi.id]);
            
            // Desmarcar outras como padrão
            await db.run('UPDATE api_providers SET is_default = 0 WHERE id != ?', [existingApi.id]);
            
            res.json({ message: 'Chave de API Voz Premium atualizada com sucesso', id: existingApi.id });
        } else {
            // Criar nova
            const result = await db.run(`
                INSERT INTO api_providers (
                    name, provider, model, api_key, unit_type, unit_size,
                    real_cost_per_unit, credits_per_unit, markup, is_premium,
                    is_active, is_default
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                name, 'genaipro', 'voice-premium-default', api_key, 'tokens', 1000,
                0.0, 1.0, 1.0, 1, 1, 1
            ]);
            
            // Desmarcar outras como padrão
            await db.run('UPDATE api_providers SET is_default = 0 WHERE id != ?', [result.lastID]);
            
            res.json({ message: 'Chave de API Voz Premium salva com sucesso', id: result.lastID });
        }
    } catch (error) {
        console.error('Erro ao salvar chave:', error);
        res.status(500).json({ message: 'Erro ao salvar chave', details: error.message });
    }
});

// POST /api/admin/laozhang/verify - Verificar chave da API Laozhang.ai
app.post('/api/admin/laozhang/verify', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API é obrigatória' });
        }
        
        // Verificar chave fazendo uma requisição simples para a API da laozhang.ai
        // Tentamos alguns endpoints comuns para verificar a chave
        const endpointsToTry = [
            'https://api.laozhang.ai/v1/status',
            'https://api.laozhang.ai/api/status',
            'https://api.laozhang.ai/status',
            'https://api.laozhang.ai/'
        ];
        
        let lastError = null;
        
        for (const endpoint of endpointsToTry) {
            try {
                const response = await axios.get(endpoint, {
                    headers: {
                        'Authorization': `Bearer ${api_key}`,
                        'Content-Type': 'application/json'
                    },
                    timeout: 5000,
                    validateStatus: (status) => status < 500 // Não lançar erro para 4xx
                });
                
                // Se a resposta for bem-sucedida (status 200-299), a chave é válida
                if (response.status >= 200 && response.status < 300) {
                    res.json({ 
                        success: true, 
                        message: 'Chave de API válida'
                    });
                    return;
                }
                
                // Se for erro 401/403, a chave é inválida
                if (response.status === 401 || response.status === 403) {
                    res.json({ 
                        success: false, 
                        message: 'Chave de API inválida ou expirada'
                    });
                    return;
                }
                
            } catch (apiError) {
                console.error(`[La Casa Dark Core] Erro ao verificar endpoint ${endpoint}:`, apiError.message);
                lastError = apiError;
                
                // Se for erro 401/403, a chave é inválida
                if (apiError.response && (apiError.response.status === 401 || apiError.response.status === 403)) {
                    res.json({ 
                        success: false, 
                        message: 'Chave de API inválida ou expirada'
                    });
                    return;
                }
                
                // Continuar tentando outros endpoints
                continue;
            }
        }
        
        // Se chegou aqui, nenhum endpoint funcionou, mas não foi erro de autenticação
        // Vamos considerar a chave como válida (pode ser que a API não tenha endpoint de verificação)
        // O importante é que não foi rejeitada por autenticação
        res.json({ 
            success: true, 
            message: 'Chave de API aceita (não foi possível verificar endpoint, mas não há erro de autenticação)'
        });
    } catch (error) {
        console.error('Erro ao verificar chave Laozhang.ai:', error);
        res.status(500).json({ 
            success: false,
            message: 'Erro ao verificar chave', 
            details: error.message
        });
    }
});

// ================================================
// ROTAS DO SISTEMA DE TTS (TEXT-TO-SPEECH)
// ================================================

// GET /api/tts/voices - Lista vozes disponíveis (Voz Premium)
app.get('/api/tts/voices', authenticateToken, async (req, res) => {
    try {
        const { provider = 'laozhang' } = req.query;
        
        console.log(`[TTS Voices] Requisição recebida - Provider: "${provider}"`);
        
        // Se provider for voice_premium ou genaipro, SEMPRE buscar vozes premium
        if (provider === 'voice_premium' || provider === 'genaipro') {
            console.log('[TTS Voices] Buscando vozes premium...');
            // Buscar API key do Voz Premium do usuário ou admin
            const userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'genaipro']);
            
            let apiKey = null;
            if (userApiKey) {
                // Descriptografar a chave
                apiKey = decrypt(userApiKey.api_key);
                if (!apiKey) {
                    console.error('[La Casa Dark Core] Erro ao descriptografar chave do usuário');
                }
            }
            
            // Se não tem chave do usuário ou falhou ao descriptografar, tentar usar API do admin
            if (!apiKey) {
                // Buscar especificamente a API Voz Premium do admin (não a API padrão genérica)
                const adminVoicePremiumApi = await db.get(`
                    SELECT * FROM api_providers 
                    WHERE (provider = 'genaipro' OR provider = 'voice_premium')
                    AND is_active = 1
                    LIMIT 1
                `);
                
                console.log('[La Casa Dark Core] Buscando API Voz Premium do admin:', adminVoicePremiumApi ? 'Encontrada' : 'Não encontrada');
                
                if (adminVoicePremiumApi && adminVoicePremiumApi.api_key) {
                    // Tentar descriptografar a chave do admin
                    // Se a chave contém ':' provavelmente está criptografada
                    if (adminVoicePremiumApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminVoicePremiumApi.api_key);
                        } catch (decryptError) {
                            console.warn('[La Casa Dark Core] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                            // Se falhar, tentar usar diretamente (pode não estar criptografada)
                            apiKey = adminVoicePremiumApi.api_key;
                        }
                    } else {
                        // Chave não parece estar criptografada, usar diretamente
                        apiKey = adminVoicePremiumApi.api_key;
                    }
                    console.log('[La Casa Dark Core] Usando API Voz Premium do admin');
                }
            }
            
            if (!apiKey) {
                console.error('[La Casa Dark Core] Nenhuma chave de API Voz Premium encontrada (nem do usuário nem do admin)');
                return res.status(400).json({ message: 'Chave de API Voz Premium não configurada. Configure no painel admin ou nas suas configurações.' });
            }
            
            console.log('[La Casa Dark Core] Buscando vozes com chave de API disponível');
            
            // Buscar vozes de AMBOS os endpoints (Max e Labs) e indicar status
            // Base URL: https://genaipro.vn/api/v1
            try {
                let allVoices = [];
                let maxStatus = 'online'; // Status do serviço Max
                let labsStatus = 'online'; // Status do serviço Labs
                
                // ============================================
                // BUSCAR VOZES LABS (ElevenLabs) - Geralmente mais estáveis
                // ============================================
                console.log('[La Casa Dark Core] Buscando vozes Labs...');
                
                // Primeiro, verificar se o serviço de TTS Labs está disponível
                try {
                    console.log('[La Casa Dark Core] Verificando status do serviço Labs TTS...');
                    const labsTtsCheck = await axios.post('https://genaipro.vn/api/v1/labs/task', 
                        { input: 'test', voice_id: 'test' },
                        {
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            timeout: 10000,
                            validateStatus: (status) => true
                        }
                    );
                    
                    // Se retornar 503 ou HTML de manutenção, marcar como em manutenção
                    if (labsTtsCheck.status === 503) {
                        labsStatus = 'maintenance';
                        console.log('[La Casa Dark Core] ⚠️ Serviço Labs TTS em manutenção (503)');
                    } else if (typeof labsTtsCheck.data === 'string' && 
                              (labsTtsCheck.data.includes('Maintenance') || labsTtsCheck.data.includes('Bảo Trì') || labsTtsCheck.data.includes('<!DOCTYPE'))) {
                        labsStatus = 'maintenance';
                        console.log('[La Casa Dark Core] ⚠️ Serviço Labs TTS em manutenção (HTML)');
                    } else {
                        console.log('[La Casa Dark Core] ✅ Serviço Labs TTS disponível (status:', labsTtsCheck.status, ')');
                    }
                } catch (labsCheckError) {
                    console.log('[La Casa Dark Core] Erro ao verificar status Labs:', labsCheckError.message);
                }
                
                try {
                    // Buscar TODAS as vozes Labs (sem filtro de idioma restritivo)
                    const labsResponse = await axios.get('https://genaipro.vn/api/v1/labs/voices', {
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        params: {
                            page: 1,
                            page_size: 100
                            // Removido filtro de idioma para buscar todas as vozes
                        },
                        timeout: 15000,
                        validateStatus: (status) => true
                    });
                    
                    console.log('[La Casa Dark Core] Labs voices response status:', labsResponse.status);
                    if (labsResponse.data) {
                        console.log('[La Casa Dark Core] Labs voices data keys:', Object.keys(labsResponse.data));
                    }
                    
                    // Verificar se está em manutenção
                    if (labsResponse.status === 503) {
                        const responseText = typeof labsResponse.data === 'string' ? labsResponse.data : '';
                        if (responseText.includes('Maintenance') || responseText.includes('Bảo Trì')) {
                            labsStatus = 'maintenance';
                            console.log('[La Casa Dark Core] ⚠️ Serviço Labs em manutenção');
                        }
                    } else if (labsResponse.status === 200 && labsResponse.data) {
                        console.log('[La Casa Dark Core] Labs data sample:', JSON.stringify(labsResponse.data).substring(0, 500));
                        
                        // Tentar diferentes formatos de resposta
                        let voiceList = [];
                        if (labsResponse.data.voices) {
                            voiceList = labsResponse.data.voices;
                            console.log('[La Casa Dark Core] Labs usando campo "voices"');
                        } else if (labsResponse.data.voice_list) {
                            voiceList = labsResponse.data.voice_list;
                            console.log('[La Casa Dark Core] Labs usando campo "voice_list"');
                        } else if (labsResponse.data.data) {
                            voiceList = labsResponse.data.data;
                            console.log('[La Casa Dark Core] Labs usando campo "data"');
                        } else if (Array.isArray(labsResponse.data)) {
                            voiceList = labsResponse.data;
                            console.log('[La Casa Dark Core] Labs resposta é array direto');
                        }
                        
                        if (Array.isArray(voiceList) && voiceList.length > 0) {
                            console.log(`[La Casa Dark Core] Labs: ${voiceList.length} vozes encontradas`);
                            
                            const labsVoices = voiceList.map(voice => {
                                let friendlyName = voice.name || 'Voz Labs';
                                
                                if (voice.labels) {
                                    const gender = voice.labels.gender || '';
                                    const description = voice.labels.description || '';
                                    
                                    if (gender) {
                                        const genderPt = gender === 'male' ? 'Masculina' : gender === 'female' ? 'Feminina' : '';
                                        if (genderPt) {
                                            friendlyName = `Voz ${genderPt}`;
                                            if (description) {
                                                friendlyName += ` - ${description}`;
                                            }
                                        }
                                    }
                                }
                                
                                return {
                                    id: voice.voice_id || voice.id || voice.name,
                                    name: voice.voice_id || voice.id || voice.name,
                                    label: `✅ ${friendlyName}`, // Indicar que está online
                                    language: voice.labels?.accent || 'pt-BR',
                                    gender: voice.labels?.gender || null,
                                    description: voice.labels?.description || null,
                                    category: voice.category,
                                    original_name: voice.name,
                                    api_type: 'labs',
                                    status: 'online'
                                };
                            });
                            
                            allVoices.push(...labsVoices);
                        }
                    }
                } catch (labsError) {
                    console.log('[La Casa Dark Core] Erro ao buscar vozes Labs:', labsError.message);
                    labsStatus = 'error';
                }
                
                // ============================================
                // BUSCAR VOZES MAX - Melhor para português
                // ============================================
                console.log('[La Casa Dark Core] Buscando vozes Max...');
                
                // Primeiro, verificar se o serviço de TTS Max está disponível
                try {
                    console.log('[La Casa Dark Core] Verificando status do serviço Max TTS...');
                    const maxTtsCheck = await axios.post('https://genaipro.vn/api/v1/max/tasks', 
                        { text: 'test', voice_id: 'test' },
                        {
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            timeout: 10000,
                            validateStatus: (status) => true
                        }
                    );
                    
                    // Se retornar 503 ou HTML de manutenção, marcar como em manutenção
                    if (maxTtsCheck.status === 503) {
                        maxStatus = 'maintenance';
                        console.log('[La Casa Dark Core] ⚠️ Serviço Max TTS em manutenção (503)');
                    } else if (typeof maxTtsCheck.data === 'string' && 
                              (maxTtsCheck.data.includes('Maintenance') || maxTtsCheck.data.includes('Bảo Trì') || maxTtsCheck.data.includes('<!DOCTYPE'))) {
                        maxStatus = 'maintenance';
                        console.log('[La Casa Dark Core] ⚠️ Serviço Max TTS em manutenção (HTML)');
                    } else {
                        console.log('[La Casa Dark Core] ✅ Serviço Max TTS disponível');
                    }
                } catch (maxCheckError) {
                    console.log('[La Casa Dark Core] Erro ao verificar status Max:', maxCheckError.message);
                }
                
                try {
                    const maxResponse = await axios.get('https://genaipro.vn/api/v1/max/voices', {
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        params: {
                            page: 1,
                            page_size: 100,
                            language: 'Portuguese'
                        },
                        timeout: 15000,
                        validateStatus: (status) => true
                    });
                    
                    // Verificar se está em manutenção
                    if (maxResponse.status === 503) {
                        const responseText = typeof maxResponse.data === 'string' ? maxResponse.data : '';
                        if (responseText.includes('Maintenance') || responseText.includes('Bảo Trì')) {
                            maxStatus = 'maintenance';
                            console.log('[La Casa Dark Core] ⚠️ Serviço Max em manutenção');
                        }
                    } else if (maxResponse.status === 200 && maxResponse.data) {
                        const voiceList = maxResponse.data.voice_list || maxResponse.data.voices || maxResponse.data.data || [];
                        
                        if (Array.isArray(voiceList) && voiceList.length > 0) {
                            console.log(`[La Casa Dark Core] Max: ${voiceList.length} vozes encontradas`);
                            
                            const maxVoices = voiceList.map(voice => {
                                let friendlyName = voice.voice_name || voice.name || 'Voz Max';
                                
                                const tagList = voice.tag_list || voice.tags || [];
                                const gender = tagList.find(tag => tag === 'Male' || tag === 'Female') || '';
                                const age = tagList.find(tag => ['Youth', 'Young Adult', 'Adult', 'Middle Aged', 'Senior'].includes(tag)) || '';
                                
                                if (gender && age) {
                                    const genderPt = gender === 'Male' ? 'Masculina' : 'Feminina';
                                    const agePt = age === 'Youth' ? 'Jovem' : 
                                                 age === 'Young Adult' ? 'Jovem Adulta' :
                                                 age === 'Adult' ? 'Adulto' :
                                                 age === 'Middle Aged' ? 'Meia Idade' : 'Sênior';
                                    friendlyName = `Voz ${genderPt} ${agePt}`;
                                } else if (gender) {
                                    const genderPt = gender === 'Male' ? 'Masculina' : 'Feminina';
                                    friendlyName = `Voz ${genderPt}`;
                                }
                                
                                // Indicador de status no label
                                const statusIndicator = maxStatus === 'maintenance' ? '🔧 ' : '✅ ';
                                const statusSuffix = maxStatus === 'maintenance' ? ' (Manutenção)' : '';
                                
                                return {
                                    id: voice.voice_id || voice.id || voice.voice_name || voice.name,
                                    name: voice.voice_id || voice.id || voice.voice_name || voice.name,
                                    label: `${statusIndicator}${friendlyName}${statusSuffix}`,
                                    language: 'Portuguese',
                                    gender: gender || null,
                                    description: voice.description || null,
                                    tags: tagList,
                                    original_name: voice.voice_name || voice.name,
                                    api_type: 'max',
                                    status: maxStatus
                                };
                            });
                            
                            allVoices.push(...maxVoices);
                        }
                    }
                } catch (maxError) {
                    console.log('[La Casa Dark Core] Erro ao buscar vozes Max:', maxError.message);
                    maxStatus = 'error';
                }
                
                // Ordenar vozes: online primeiro, depois manutenção
                allVoices.sort((a, b) => {
                    if (a.status === 'online' && b.status !== 'online') return -1;
                    if (a.status !== 'online' && b.status === 'online') return 1;
                    return 0;
                });
                
                if (allVoices.length > 0) {
                    const onlineCount = allVoices.filter(v => v.status === 'online').length;
                    const maintenanceCount = allVoices.filter(v => v.status === 'maintenance').length;
                    
                    console.log(`[La Casa Dark Core] ✅ Total: ${allVoices.length} vozes (${onlineCount} online, ${maintenanceCount} em manutenção)`);
                    
                    return res.json({ 
                        data: allVoices,
                        provider: 'voice_premium',
                        message: `${allVoices.length} vozes disponíveis (${onlineCount} online${maintenanceCount > 0 ? `, ${maintenanceCount} em manutenção` : ''})`,
                        status: {
                            labs: labsStatus,
                            max: maxStatus
                        }
                    });
                } else {
                    console.warn('[La Casa Dark Core] ⚠️ Nenhuma voz encontrada');
                    return res.status(404).json({ 
                        message: 'Nenhuma voz encontrada. Verifique se sua chave de API tem acesso às vozes premium.',
                        data: [],
                        status: {
                            labs: labsStatus,
                            max: maxStatus
                        }
                    });
                }
            } catch (apiError) {
                console.error('[La Casa Dark Core] Erro ao buscar vozes:', apiError.message);
                if (apiError.response) {
                    console.error('[La Casa Dark Core] Status:', apiError.response.status);
                    console.error('[La Casa Dark Core] Data:', JSON.stringify(apiError.response.data).substring(0, 500));
                    
                    if (apiError.response.status === 401 || apiError.response.status === 403) {
                        return res.status(401).json({ 
                            message: 'Chave de API inválida ou expirada. Verifique suas configurações.',
                            data: []
                        });
                    }
                }
                return res.status(500).json({ 
                    message: `Erro ao buscar vozes: ${apiError.message}`,
                    data: []
                });
            }
        }
        
        // Verificar preferência do usuário
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // Se provider for laozhang ou se useCredits estiver marcado, retornar vozes DarkVoz
        if (provider === 'laozhang' || useCredits) {
            console.log('[TTS Voices] Retornando vozes DarkVoz');
            
            // Verificar se tem chave de API configurada
            const laozhangKey = await getLaozhangApiKey();
            if (!laozhangKey) {
                return res.status(400).json({ 
                    message: 'Chave de API DarkVoz não configurada. Configure no painel admin.' 
                });
            }
            
            // Retornar todas as vozes disponíveis do DarkVoz
            const laozhangVoices = [
                {
                    id: 'alloy',
                    name: 'alloy',
                    voice_id: 'alloy',
                    label: 'Alloy - Neutra, clara e natural',
                    description: 'Voz neutra, clara e natural',
                    gender: 'neutral',
                    language: 'pt-BR'
                },
                {
                    id: 'echo',
                    name: 'echo',
                    voice_id: 'echo',
                    label: 'Echo - Masculina, firme e forte',
                    description: 'Voz masculina, firme e forte',
                    gender: 'male',
                    language: 'pt-BR'
                },
                {
                    id: 'fable',
                    name: 'fable',
                    voice_id: 'fable',
                    label: 'Fable - Sotaque britânico, elegante',
                    description: 'Voz com sotaque britânico, elegante',
                    gender: 'neutral',
                    language: 'en-GB'
                },
                {
                    id: 'onyx',
                    name: 'onyx',
                    voice_id: 'onyx',
                    label: 'Onyx - Masculina profunda, notícias/transmissão',
                    description: 'Voz masculina profunda, ideal para notícias e transmissão',
                    gender: 'male',
                    language: 'pt-BR'
                },
                {
                    id: 'nova',
                    name: 'nova',
                    voice_id: 'nova',
                    label: 'Nova - Feminina, calorosa e amigável',
                    description: 'Voz feminina, calorosa e amigável',
                    gender: 'female',
                    language: 'pt-BR'
                },
                {
                    id: 'shimmer',
                    name: 'shimmer',
                    voice_id: 'shimmer',
                    label: 'Shimmer - Feminina suave, narração',
                    description: 'Voz feminina suave, ideal para narração',
                    gender: 'female',
                    language: 'pt-BR'
                }
            ];
            
            return res.status(200).json({ 
                data: laozhangVoices,
                provider: 'darkvoz',
                message: `${laozhangVoices.length} vozes disponíveis`
            });
        }
        
        // Chave configurada no painel admin (sempre priorizar se existir)
        const adminVoiceApiKey = await getAdminVoiceApiKey();
        if (provider === 'gemini' && adminVoiceApiKey && adminVoiceApiKey.trim().length >= 10) {
            apiKey = adminVoiceApiKey.trim();
            console.log('[TTS Generate] ✅ Usando chave de voz configurada no painel admin (Google Cloud/Gemini)');
        }
        
        if (provider === 'gemini') {
            // Vozes Gemini (hardcoded conforme voices.js)
            const geminiVoices = [
                { name: "Zephyr", label: "Brisa - Voz Brilhante", lang: "pt-BR" },
                { name: "Puck", label: "Vibe - Voz Animada", lang: "pt-BR" },
                { name: "Charon", label: "Dorio - Voz Informativa", lang: "pt-BR" },
                { name: "Kore", label: "Livia - Voz Firme", lang: "pt-BR" },
                { name: "Fenrir", label: "Rafael - Voz Excitada", lang: "pt-BR" },
                { name: "Leda", label: "Clara - Voz Juvenil", lang: "pt-BR" },
                { name: "Orus", label: "Icaro - Voz Firme", lang: "pt-BR" },
                { name: "Aoede", label: "Marina - Voz Arejada", lang: "pt-BR" },
                { name: "Callirrhoe", label: "Nina - Voz Descontraida", lang: "pt-BR" },
                { name: "Autonoe", label: "Bia - Voz Brilhante", lang: "pt-BR" },
                { name: "Enceladus", label: "Dandara - Voz Sussurrada", lang: "pt-BR" },
                { name: "Iapetus", label: "Vitor - Voz Clara", lang: "pt-BR" },
                { name: "Umbriel", label: "Otavio - Voz Descontraida", lang: "pt-BR" },
                { name: "Algieba", label: "Joao - Voz Suave", lang: "pt-BR" },
                { name: "Despina", label: "Luna - Voz Suave", lang: "pt-BR" },
                { name: "Erinome", label: "Paula - Voz Clara", lang: "pt-BR" },
                { name: "Algenib", label: "Gustavo - Voz Grave", lang: "pt-BR" },
                { name: "Rasalgethi", label: "Henrique - Voz Informativa", lang: "pt-BR" },
                { name: "Laomedeia", label: "Taina - Voz Animada", lang: "pt-BR" },
                { name: "Achernar", label: "Noa - Voz Suave", lang: "pt-BR" },
                { name: "Alnilam", label: "Edu - Voz Firme", lang: "pt-BR" },
                { name: "Schedar", label: "Rafa - Voz Constante", lang: "pt-BR" },
                { name: "Gacrux", label: "Sergio - Voz Madura", lang: "pt-BR" },
                { name: "Pulcherrima", label: "Helena - Voz Projetada", lang: "pt-BR" },
                { name: "Achird", label: "Mia - Voz Amigavel", lang: "pt-BR" },
                { name: "Zubenelgenubi", label: "Teo - Voz Casual", lang: "pt-BR" },
                { name: "Vindemiatrix", label: "Erica - Voz Gentil", lang: "pt-BR" },
                { name: "Sadachbia", label: "Duda - Voz Vivaz", lang: "pt-BR" },
                { name: "Sadaltager", label: "Marcelo - Voz Conhecedora", lang: "pt-BR" },
                { name: "Sulafat", label: "Isis - Voz Acolhedora", lang: "pt-BR" }
            ];
            res.json({ data: geminiVoices });
        } else if (provider === 'laozhang') {
            const laozhangVoices = [
                { name: 'alloy', label: 'Alloy - Neutro e claro', lang: 'pt-BR' },
                { name: 'echo', label: 'Echo - Masculino forte', lang: 'pt-BR' },
                { name: 'fable', label: 'Fable - Inglês elegante', lang: 'en-US' },
                { name: 'onyx', label: 'Onyx - Grave jornalístico', lang: 'pt-BR' },
                { name: 'nova', label: 'Nova - Feminino acolhedor', lang: 'pt-BR' },
                { name: 'shimmer', label: 'Shimmer - Feminino suave', lang: 'pt-BR' }
            ];
            res.json({ data: laozhangVoices });
        } else {
            res.json({ data: [] });
        }
    } catch (error) {
        console.error('Erro ao listar vozes:', error);
        res.status(500).json({ message: 'Erro ao listar vozes' });
    }
});

// POST /api/tts/preview - Gera preview de voz
app.post('/api/tts/preview', authenticateToken, async (req, res) => {
    const { voice, model, provider = 'laozhang' } = req.body || {};
    const previewVoice = typeof voice === 'string' && voice.trim() ? voice.trim() : FALLBACK_TTS_VOICE;
    const previewText = DEFAULT_TTS_SAMPLE_TEXT; // Remover prefixo "Narrador:"
    const validatedModel = validateTtsModel(model);
    
    // Declarar actualProvider fora do try para estar disponível no catch
    let actualProvider = provider;

    try {
        // Verificar se tem API própria ou usar API do admin (com créditos)
        let apiKey = null;
        let useAdminApi = false;
        let adminApi = null;
        
        // Verificar preferência do usuário
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // IMPORTANTE: Se o provider é voice_premium/genaipro, SEMPRE usar a API GenAIPro, não laozhang
        // A lógica useCredits só se aplica a outros providers
        
        // Se useCredits estiver marcado E o provider NÃO é voice_premium, usar laozhang.ai
        if (useCredits && provider !== 'voice_premium' && provider !== 'genaipro') {
            console.log(`[TTS Preview] useCredits marcado (provider: ${provider}), usando DarkVoz`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Chave do DarkVoz não configurada. Configure no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            actualProvider = 'laozhang';
            console.log('[TTS Preview] ✅ Usando API DarkVoz (useCredits marcado)');
        } else if (provider === 'laozhang') {
            console.log(`[TTS Preview] Provider: laozhang, Voice: ${previewVoice}`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Configure a chave do DarkVoz no painel admin para usar este provedor.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            actualProvider = 'laozhang';
            console.log('[TTS Preview] ✅ Usando API DarkVoz (Laozhang.ai) do painel admin');
        } else if (provider === 'gemini') {
            // Chave configurada no painel admin (sempre priorizar se existir)
            const adminVoiceApiKey = await getAdminVoiceApiKey();
            if (adminVoiceApiKey && adminVoiceApiKey.trim().length >= 10) {
                apiKey = adminVoiceApiKey.trim();
                console.log('[TTS Preview] ✅ Usando chave de voz configurada no painel admin (Google Cloud/Gemini)');
            }
            console.log(`[TTS Preview] Provider: gemini, Voice: ${previewVoice}`);
            
            // PRIORIDADE 2: Se não houver chave do admin, buscar API do Gemini do usuário
            if (!apiKey && !useCredits) {
                let userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'gemini']);
                console.log('[TTS Preview] DEBUG - Gemini API do usuário encontrada:', !!userApiKey);
                
                if (userApiKey && userApiKey.api_key) {
                    // Descriptografar a chave do Gemini
                    if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(userApiKey.api_key);
                            console.log('[TTS Preview] Chave Gemini descriptografada (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                        } catch (decryptError) {
                            console.warn('[TTS Preview] Erro ao descriptografar chave Gemini, tentando usar diretamente:', decryptError.message);
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        apiKey = userApiKey.api_key;
                        console.log('[TTS Preview] Chave Gemini usada diretamente (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                    }
                    
                    // Validar se a chave não está vazia
                    if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                        console.warn('[TTS Preview] ⚠️ Chave Gemini está vazia, tentando API do admin');
                        apiKey = null;
                    } else {
                        console.log('[TTS Preview] ✅ Usando API Gemini do usuário');
                    }
                }
            }
            
            // Se não conseguiu usar API própria, tentar admin como fallback
            if (!apiKey) {
                console.log('[TTS Preview] Tentando usar API do admin como fallback para Gemini...');
                adminApi = await getDefaultAdminApi();
                console.log('[TTS Preview] Admin API encontrada:', adminApi ? `${adminApi.provider} - ${adminApi.name}` : 'Nenhuma');
                if (adminApi && adminApi.provider === 'gemini' && adminApi.api_key) {
                    // Descriptografar se necessário
                    if (adminApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminApi.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Preview] Erro ao descriptografar chave Gemini do admin, tentando usar diretamente:', decryptError.message);
                            apiKey = adminApi.api_key;
                        }
                    } else {
                        apiKey = adminApi.api_key;
                    }
                    
                    if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                        console.error('[TTS Preview] ❌ Chave Gemini do admin está vazia');
                        apiKey = null;
                    } else {
                        useAdminApi = true;
                        console.log('[TTS Preview] ✅ Usando API Gemini do admin com créditos');
                    }
                } else {
                    console.warn('[TTS Preview] ⚠️ Admin API não encontrada ou não é Gemini');
                }
                
                if (!apiKey) {
                    console.error('[TTS Preview] ❌ Nenhuma API Gemini disponível');
                    return res.status(400).json({ message: 'Configure uma chave de voz (Google Cloud/Gemini) no painel admin ou use créditos.' });
                }
            }
        } else if (provider === 'voice_premium' || provider === 'genaipro') {
            console.log(`[TTS Preview] Provider: ${provider}, Voice: ${previewVoice}`);
            
            // Buscar API do usuário - tentar tanto 'genaipro' quanto 'voice_premium'
            let userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'genaipro']);
            if (!userApiKey || !userApiKey.api_key) {
                // Tentar buscar como 'voice_premium' se não encontrou como 'genaipro'
                userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'voice_premium']);
                if (userApiKey) {
                    console.log('[TTS Preview] API encontrada como voice_premium');
                }
            } else {
                console.log('[TTS Preview] API encontrada como genaipro');
            }
            
            console.log('[TTS Preview] DEBUG - userApiKey encontrada:', !!userApiKey);
            console.log('[TTS Preview] DEBUG - userApiKey.api_key existe:', !!(userApiKey && userApiKey.api_key));
            if (userApiKey && userApiKey.api_key) {
                console.log('[TTS Preview] DEBUG - userApiKey.api_key tamanho:', userApiKey.api_key.length);
                console.log('[TTS Preview] DEBUG - userApiKey.api_key preview:', userApiKey.api_key.substring(0, 20) + '...');
            }
            
            if (useCredits) {
                // Usuário prefere usar créditos - buscar especificamente a API Voz Premium do admin
                // NÃO usar getDefaultAdminApi() pois pode retornar outra API
                adminApi = await db.get(`
                    SELECT * FROM api_providers 
                    WHERE (provider = 'genaipro' OR provider = 'voice_premium')
                    AND is_active = 1
                    LIMIT 1
                `);
                console.log('[TTS Preview] Buscando API Voz Premium do admin:', adminApi ? 'Encontrada' : 'Não encontrada');
                
                if (adminApi && adminApi.api_key) {
                    // Tentar descriptografar a chave do admin
                    if (adminApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminApi.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Preview] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                            apiKey = adminApi.api_key;
                        }
                    } else {
                        apiKey = adminApi.api_key;
                    }
                    useAdminApi = true;
                    actualProvider = 'voice_premium'; // Garantir que o provider seja correto
                    console.log('[TTS Preview] ✅ Usando API Voz Premium do admin');
                } else {
                    // Fallback: usar API própria se disponível
                    if (userApiKey && userApiKey.api_key) {
                        console.log('[TTS Preview] Fallback: tentando usar API própria do usuário...');
                        // Descriptografar a chave do usuário
                        if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                            try {
                                apiKey = decrypt(userApiKey.api_key);
                                console.log('[TTS Preview] Chave descriptografada (tamanho:', apiKey ? apiKey.length : 0, ')');
                            } catch (decryptError) {
                                console.warn('[TTS Preview] Erro ao descriptografar chave do usuário, tentando usar diretamente:', decryptError.message);
                                apiKey = userApiKey.api_key;
                            }
                        } else {
                            apiKey = userApiKey.api_key;
                            console.log('[TTS Preview] Chave usada diretamente (não criptografada, tamanho:', apiKey ? apiKey.length : 0, ')');
                        }
                        
                        // Validar se a chave não está vazia
                        if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                            console.error('[TTS Preview] Chave do usuário está vazia ou muito curta após descriptografar');
                            return res.status(400).json({ message: 'A chave da API Voz Premium configurada está vazia ou inválida. Verifique suas configurações.' });
                        }
                        
                        actualProvider = 'voice_premium'; // Garantir provider correto
                        console.log('[TTS Preview] ✅ Fallback: usando API própria (admin API não disponível)');
                    } else {
                        console.error('[TTS Preview] ❌ API própria não encontrada e admin API Voz Premium não disponível');
                        return res.status(400).json({ message: 'Configure uma chave da API Voz Premium no painel admin ou nas suas configurações.' });
                    }
                }
            } else {
                // Usuário prefere usar API própria quando disponível
                console.log('[TTS Preview] Verificando API própria do usuário (preferência: não usar créditos)');
                console.log('[TTS Preview] - userApiKey encontrada:', !!userApiKey);
                console.log('[TTS Preview] - userApiKey.api_key existe:', !!(userApiKey && userApiKey.api_key));
                
                if (userApiKey && userApiKey.api_key) {
                    // Descriptografar a chave do usuário
                    if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(userApiKey.api_key);
                            console.log('[TTS Preview] Chave descriptografada com sucesso (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                        } catch (decryptError) {
                            console.warn('[TTS Preview] Erro ao descriptografar chave do usuário, tentando usar diretamente:', decryptError.message);
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        apiKey = userApiKey.api_key;
                        console.log('[TTS Preview] Chave usada diretamente (não criptografada, tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                    }
                    
                    // Validar se a chave não está vazia após descriptografar
                    if (!apiKey || apiKey.trim() === '') {
                        console.warn('[TTS Preview] ⚠️ Chave do usuário está vazia após descriptografar, tentando API do admin');
                        apiKey = null; // Resetar para tentar admin
                    } else {
                        console.log('[TTS Preview] ✅ API key do usuário encontrada e válida (tamanho:', apiKey.length, 'caracteres)');
                    }
                } else {
                    console.log('[TTS Preview] ⚠️ API própria do usuário não encontrada ou vazia');
                }
                
                // Se não conseguiu usar API própria, tentar admin como fallback
                if (!apiKey) {
                    console.log('[TTS Preview] Tentando usar API Voz Premium do admin como fallback...');
                    // Buscar especificamente a API Voz Premium do admin
                    adminApi = await db.get(`
                        SELECT * FROM api_providers 
                        WHERE (provider = 'genaipro' OR provider = 'voice_premium')
                        AND is_active = 1
                        LIMIT 1
                    `);
                    console.log('[TTS Preview] Admin API Voz Premium encontrada:', adminApi ? 'Sim' : 'Não');
                    
                    if (adminApi && adminApi.api_key) {
                        // Tentar descriptografar a chave do admin
                        if (adminApi.api_key.includes(':')) {
                            try {
                                apiKey = decrypt(adminApi.api_key);
                                console.log('[TTS Preview] Chave do admin descriptografada (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                            } catch (decryptError) {
                                console.warn('[TTS Preview] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                                apiKey = adminApi.api_key;
                            }
                        } else {
                            apiKey = adminApi.api_key;
                            console.log('[TTS Preview] Chave do admin usada diretamente (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                        }
                        
                        // Validar se a chave não está vazia
                        if (!apiKey || apiKey.trim() === '') {
                            console.error('[TTS Preview] ❌ Chave do admin está vazia após descriptografar');
                            apiKey = null;
                        } else {
                            useAdminApi = true;
                            actualProvider = 'voice_premium'; // Garantir provider correto
                            console.log('[TTS Preview] ✅ Usando API Voz Premium do admin (fallback)');
                        }
                    } else {
                        console.warn('[TTS Preview] ⚠️ Admin API Voz Premium não encontrada');
                    }
                    
                    if (!apiKey) {
                        console.error('[TTS Preview] ❌ Nenhuma API Voz Premium disponível');
                        return res.status(400).json({ message: 'Configure uma chave da API Voz Premium no painel admin ou nas suas configurações.' });
                    }
                } else {
                    actualProvider = 'voice_premium'; // Garantir provider correto quando usando API do usuário
                }
            }
        } else if (provider === 'openai') {
            // Verificar preferência do usuário
            const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
            const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
            
            const userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'openai']);
            const adminOpenAiKey = await getAdminOpenAiVoiceApiKey();
            
            if (adminOpenAiKey) {
                apiKey = adminOpenAiKey;
                console.log('[TTS Preview] ✅ Usando chave de voz OpenAI do painel admin');
            }
            
            if (!apiKey && useCredits) {
                // Usuário prefere usar créditos mesmo tendo API própria
                adminApi = await getDefaultAdminApi();
                if (adminApi && adminApi.provider === 'openai') {
                    apiKey = adminApi.api_key;
                    useAdminApi = true;
                } else {
                    // Fallback: usar API própria se disponível
                    if (userApiKey) {
                        apiKey = userApiKey.api_key;
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API OpenAI ou use créditos.' });
                    }
                }
            }
        } else if (provider === 'laozhang') {
            console.log(`[TTS Preview] Provider: laozhang, Voice: ${previewVoice}`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Configure a chave do provedor externo no painel admin para usar este provedor.' });
            }
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (!laozhangProviderId) {
                return res.status(400).json({ message: 'Provedor externo não está ativo no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            adminApi = { id: laozhangProviderId, provider: 'laozhang' };
            actualProvider = 'laozhang';
        }
        
        // Validação final: verificar se apiKey não está vazia e tem formato válido
        if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
            console.error('[TTS Preview] ❌ API Key está vazia, inválida ou muito curta após todo o processamento');
            console.error('[TTS Preview] - Provider:', provider);
            console.error('[TTS Preview] - User ID:', req.user.id);
            const userPrefsDebug = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
            console.error('[TTS Preview] - useCredits:', userPrefsDebug ? (userPrefsDebug.use_credits_instead_of_own_api === 1) : 'N/A');
            console.error('[TTS Preview] - apiKey length:', apiKey ? apiKey.length : 0);
            console.error('[TTS Preview] - apiKey preview:', apiKey ? apiKey.substring(0, 10) + '...' : 'null');
            
            // Verificar se há API do admin disponível como última tentativa
            if (provider === 'voice_premium' || provider === 'genaipro' || provider === 'gemini') {
                const lastChanceAdminApi = await getDefaultAdminApi();
                // Para Gemini, buscar API do Gemini; para outros, buscar genaipro/voice_premium
                if (provider === 'gemini') {
                    if (lastChanceAdminApi && lastChanceAdminApi.provider === 'gemini' && lastChanceAdminApi.api_key) {
                        console.log('[TTS Preview] 🆘 Última tentativa: usando API Gemini do admin');
                        try {
                            if (lastChanceAdminApi.api_key.includes(':')) {
                                apiKey = decrypt(lastChanceAdminApi.api_key);
                            } else {
                                apiKey = lastChanceAdminApi.api_key;
                            }
                            if (apiKey && apiKey.trim() !== '' && apiKey.trim().length >= 10) {
                                useAdminApi = true;
                                console.log('[TTS Preview] ✅ API Gemini do admin funcionou como última tentativa');
                            } else {
                                apiKey = null;
                            }
                        } catch (err) {
                            console.error('[TTS Preview] Erro na última tentativa com admin Gemini API:', err.message);
                            apiKey = null;
                        }
                    }
                } else if (lastChanceAdminApi && (lastChanceAdminApi.provider === 'genaipro' || lastChanceAdminApi.provider === 'voice_premium') && lastChanceAdminApi.api_key) {
                    console.log('[TTS Preview] 🆘 Última tentativa: usando API do admin');
                    try {
                        if (lastChanceAdminApi.api_key.includes(':')) {
                            apiKey = decrypt(lastChanceAdminApi.api_key);
                        } else {
                            apiKey = lastChanceAdminApi.api_key;
                        }
                        if (apiKey && apiKey.trim() !== '' && apiKey.trim().length >= 10) {
                            useAdminApi = true;
                            console.log('[TTS Preview] ✅ API do admin funcionou como última tentativa');
                        } else {
                            apiKey = null;
                        }
                    } catch (err) {
                        console.error('[TTS Preview] Erro na última tentativa com admin API:', err.message);
                        apiKey = null;
                    }
                }
            }
            
            if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                return res.status(400).json({ 
                    message: 'Nenhuma API configurada ou a chave está vazia/inválida. Verifique suas configurações de API. Se sua chave foi marcada como inválida na validação, corrija-a ou use créditos.' 
                });
            }
        }
        
        console.log('[TTS Preview] ✅ API Key validada com sucesso (tamanho:', apiKey.length, 'caracteres, usando admin:', useAdminApi, ')');

        const speakerVoiceMap = new Map([['Narrador', previewVoice]]);
        console.log(`[TTS Preview] Gerando áudio com provider: ${provider}, voice: ${previewVoice}, text length: ${previewText.length}`);
        
        // Garantir que o provider seja correto para a função generateTtsAudio
        // Se for Gemini, usar genaipro mas com a API do Gemini
        actualProvider = provider;
        if (provider === 'voice_premium' || provider === 'genaipro') {
            actualProvider = 'genaipro';
        } else if (provider === 'gemini') {
            // Gemini TTS: usar 'gemini' para usar a API oficial do Google Gemini
            actualProvider = 'gemini';
            console.log('[TTS Preview] Usando Gemini TTS oficial com API do Google Gemini');
        }
        
        // Obter velocidade do body se for DarkVoz
        const speed = provider === 'laozhang' ? (parseFloat(req.body.speed) || 1.0) : 1.0;
        
        const { audioBase64 } = await generateTtsAudio({
            apiKey: apiKey,
            model: validatedModel,
            textInput: previewText,
            speakerVoiceMap: speakerVoiceMap,
            provider: actualProvider,
            speed: speed
        });
        
        console.log('[TTS Preview] Áudio gerado com sucesso');
        
        // Se usou API do admin, debitar créditos
        if (useAdminApi && adminApi) {
            try {
                // Estimar tokens (aproximadamente 1 token por caractere para TTS)
                const estimatedTokens = Math.ceil(previewText.length / 4);
                
                const creditResult = await checkAndDebitCredits(
                    req.user.id,
                    adminApi.id,
                    estimatedTokens,
                    'api_tts_preview',
                    JSON.stringify({ model: validatedModel, provider: provider, endpoint: '/api/tts/preview' })
                );
                
                console.log(`💳 [CRÉDITOS] ${creditResult.creditsUsed.toFixed(2)} créditos debitados. Saldo restante: ${creditResult.newBalance.toFixed(2)}`);
            } catch (creditError) {
                console.error('❌ [CRÉDITOS] Erro ao debitar créditos:', creditError);
            }
        }

        res.json({
            message: 'Prévia gerada.',
            audio: {
                mimeType: 'audio/mpeg',
                base64: audioBase64,
            }
        });
    } catch (err) {
        console.error('Erro ao gerar prévia de voz:', err);
        if (err.response) {
            console.error('Status:', err.response.status);
            console.error('Data:', err.response.data);
        }
        
        // Mensagem de erro mais amigável
        let errorMessage = err.message || 'Erro desconhecido ao gerar prévia de voz';
        const status = err.response?.status;
        const responseData = err.response?.data;
        
        // Usar actualProvider se disponível, senão usar provider do body
        const currentProvider = (typeof actualProvider !== 'undefined' ? actualProvider : provider) || 'unknown';
        const isVoicePremiumProvider = currentProvider === 'genaipro' || currentProvider === 'voice_premium';
        const isGeminiProvider = currentProvider === 'gemini';
        const isLaozhangProvider = currentProvider === 'laozhang';
        
        const responseString = typeof responseData === 'string' ? responseData : '';
        const maintenanceHints = ['manutenção', 'Đang Bảo Trì', 'maintenance'];
        const messageIndicatesMaintenance = maintenanceHints.some(hint => (err.message || '').toLowerCase().includes(hint) || responseString.toLowerCase().includes(hint));
        
        if (isVoicePremiumProvider && status === 503 && messageIndicatesMaintenance) {
            errorMessage = 'A API Voz Premium informou que está em manutenção. Por favor, tente novamente em alguns minutos.';
        } else if (messageIndicatesMaintenance) {
            errorMessage = err.message;
        } else if (isGeminiProvider && status === 401) {
            errorMessage = 'Chave do Google Cloud (Gemini) inválida ou expirada. Verifique a chave salva no painel admin.';
        } else if (isGeminiProvider && status === 403) {
            errorMessage = 'Acesso negado pela API do Google Cloud. Verifique se a chave tem permissão para usar o Text-to-Speech.';
        } else if (isLaozhangProvider && (status === 401 || status === 403)) {
            errorMessage = 'Chave do DarkVoz inválida ou sem permissão para TTS. Atualize a chave no painel admin.';
        } else if (isLaozhangProvider && status === 429) {
            errorMessage = 'Limite de requisições atingido no DarkVoz. Aguarde alguns instantes e tente novamente.';
        } else if (isLaozhangProvider && status === 503) {
            errorMessage = 'O DarkVoz está temporariamente indisponível. Tente novamente em alguns minutos.';
        } else if (!isGeminiProvider && !isLaozhangProvider && status === 401) {
            errorMessage = 'Chave de API inválida ou expirada. Verifique suas configurações no painel admin.';
        } else if (!isGeminiProvider && !isLaozhangProvider && status === 403) {
            errorMessage = 'Acesso negado. Verifique se sua chave de API tem permissões para gerar áudio.';
        } else if (err.message && err.message.toLowerCase().includes('timeout')) {
            errorMessage = 'Timeout ao conectar com a API. Tente novamente.';
        }
        
        res.status(err.response?.status || 500).json({ 
            message: errorMessage,
            details: err.response?.data?.message || err.message
        });
    }
});

// POST /api/tts/generate-from-script - Gera áudio completo a partir de roteiro
app.post('/api/tts/generate-from-script', authenticateToken, async (req, res) => {
    const { ttsModel, script, voice, styleInstructions, provider = 'laozhang', speed = 1.0 } = req.body;

    // Validar parâmetros obrigatórios
    if (!script || !voice) {
        return res.status(400).json({ message: 'Roteiro e voz são obrigatórios.' });
    }
    
    // Se não tiver modelo, usar padrão baseado no provider
    let finalTtsModel = ttsModel;
    if (!finalTtsModel || !finalTtsModel.trim()) {
        if (provider === 'laozhang') {
            finalTtsModel = 'tts-1'; // Modelo padrão para laozhang
        } else if (provider === 'openai') {
            finalTtsModel = 'tts-1-hd';
        } else if (provider === 'gemini') {
            finalTtsModel = 'gemini-2.5-pro-preview-tts';
        } else {
            finalTtsModel = 'genaipro-default';
        }
    }
    
    // Validar modelo
    finalTtsModel = validateTtsModel(finalTtsModel);

    try {
        // Verificar API e créditos
        let apiKey = null;
        let useAdminApi = false;
        let adminApi = null;
        
        // Verificar preferência do usuário
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // Se useCredits estiver marcado, usar laozhang.ai
        if (useCredits) {
            console.log(`[TTS Generate] useCredits marcado, usando laozhang.ai`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Chave da laozhang.ai não configurada. Configure no painel admin.' });
            }
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (!laozhangProviderId) {
                return res.status(400).json({ message: 'Provider laozhang.ai não está ativo no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            adminApi = { id: laozhangProviderId, provider: 'laozhang' };
            // Forçar provider para laozhang
            actualProvider = 'laozhang';
            console.log('[TTS Generate] ✅ Usando API laozhang.ai (useCredits marcado)');
        } else if (provider === 'laozhang') {
            console.log(`[TTS Generate] Provider: laozhang, Voice: ${voice}`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Configure a chave do DarkVoz no painel admin para usar este provedor.' });
            }
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (!laozhangProviderId) {
                return res.status(400).json({ message: 'Provider DarkVoz não está ativo no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            adminApi = { id: laozhangProviderId, provider: 'laozhang' };
            console.log('[TTS Generate] ✅ Usando API DarkVoz (Laozhang.ai) do painel admin');
        } else if (provider === 'gemini') {
            console.log(`[TTS Generate] Provider: gemini, Voice: ${voice}`);
            
            // PRIORIDADE 2: Se não houver chave do admin, buscar API do Gemini do usuário
            if (!apiKey && !useCredits) {
                let userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'gemini']);
                console.log('[TTS Generate] DEBUG - Gemini API do usuário encontrada:', !!userApiKey);
                
                if (userApiKey && userApiKey.api_key) {
                    // Descriptografar a chave do Gemini
                    if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(userApiKey.api_key);
                            console.log('[TTS Generate] Chave Gemini descriptografada (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                        } catch (decryptError) {
                            console.warn('[TTS Generate] Erro ao descriptografar chave Gemini, tentando usar diretamente:', decryptError.message);
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        apiKey = userApiKey.api_key;
                        console.log('[TTS Generate] Chave Gemini usada diretamente (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                    }
                    
                    // Validar se a chave não está vazia
                    if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                        console.warn('[TTS Generate] ⚠️ Chave Gemini está vazia, tentando API do admin');
                        apiKey = null;
                    } else {
                        console.log('[TTS Generate] ✅ Usando API Gemini do usuário');
                    }
                }
            }
            
            // Se não conseguiu usar API própria, tentar admin como fallback
            if (!apiKey) {
                console.log('[TTS Generate] Tentando usar API do admin como fallback para Gemini...');
                adminApi = await getDefaultAdminApi();
                console.log('[TTS Generate] Admin API encontrada:', adminApi ? `${adminApi.provider} - ${adminApi.name}` : 'Nenhuma');
                if (adminApi && adminApi.provider === 'gemini' && adminApi.api_key) {
                    // Descriptografar se necessário
                    if (adminApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminApi.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Generate] Erro ao descriptografar chave Gemini do admin, tentando usar diretamente:', decryptError.message);
                            apiKey = adminApi.api_key;
                        }
                    } else {
                        apiKey = adminApi.api_key;
                    }
                    useAdminApi = true;
                } else {
                    return res.status(400).json({ message: 'Nenhuma API configurada ou a chave está vazia/inválida. Verifique suas configurações de API. Se sua chave foi marcada como inválida na validação, corrija-a ou use créditos.' });
                }
            }
        } else if (provider === 'voice_premium' || provider === 'genaipro') {
            
            const userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'genaipro']);
            
            if (useCredits) {
                // Usuário prefere usar créditos mesmo tendo API própria
                adminApi = await getDefaultAdminApi();
                if (adminApi && (adminApi.provider === 'genaipro' || adminApi.provider === 'voice_premium')) {
                    // Tentar descriptografar a chave do admin
                    if (adminApi.api_key && adminApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminApi.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Generate] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                            apiKey = adminApi.api_key;
                        }
                    } else {
                        apiKey = adminApi.api_key;
                    }
                    useAdminApi = true;
                } else {
                    // Fallback: usar API própria se disponível
                    if (userApiKey) {
                        // Descriptografar a chave do usuário
                        if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                            try {
                                apiKey = decrypt(userApiKey.api_key);
                            } catch (decryptError) {
                                console.warn('[TTS Generate] Erro ao descriptografar chave do usuário, tentando usar diretamente:', decryptError.message);
                                apiKey = userApiKey.api_key;
                            }
                        } else {
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API Voz Premium ou use créditos.' });
                    }
                }
            } else {
                // Usuário prefere usar API própria quando disponível
                if (userApiKey) {
                    // Descriptografar a chave do usuário
                    if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(userApiKey.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Generate] Erro ao descriptografar chave do usuário, tentando usar diretamente:', decryptError.message);
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        apiKey = userApiKey.api_key;
                    }
                } else {
                    adminApi = await getDefaultAdminApi();
                    if (adminApi && (adminApi.provider === 'genaipro' || adminApi.provider === 'voice_premium')) {
                        // Tentar descriptografar a chave do admin
                        if (adminApi.api_key && adminApi.api_key.includes(':')) {
                            try {
                                apiKey = decrypt(adminApi.api_key);
                            } catch (decryptError) {
                                console.warn('[TTS Generate] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                                apiKey = adminApi.api_key;
                            }
                        } else {
                            apiKey = adminApi.api_key;
                        }
                        useAdminApi = true;
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API Voz Premium ou use créditos.' });
                    }
                }
            }
        } else if (provider === 'openai') {
            // Verificar preferência do usuário
            const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
            const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
            
            const userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'openai']);
            const adminOpenAiKey = await getAdminOpenAiVoiceApiKey();
            
            if (adminOpenAiKey) {
                apiKey = adminOpenAiKey;
                console.log('[TTS Generate] ✅ Usando chave de voz OpenAI do painel admin');
            }
            
            if (!apiKey && useCredits) {
                // Usuário prefere usar créditos mesmo tendo API própria
                adminApi = await getDefaultAdminApi();
                if (adminApi && adminApi.provider === 'openai') {
                    apiKey = adminApi.api_key;
                    useAdminApi = true;
                } else {
                    // Fallback: usar API própria se disponível
                    if (userApiKey) {
                        apiKey = userApiKey.api_key;
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API OpenAI ou use créditos.' });
                    }
                }
            } else if (!apiKey) {
                // Usuário prefere usar API própria quando disponível
                if (userApiKey) {
                    apiKey = userApiKey.api_key;
                } else {
                    adminApi = await getDefaultAdminApi();
                    if (adminApi && adminApi.provider === 'openai') {
                        apiKey = adminApi.api_key;
                        useAdminApi = true;
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API OpenAI ou use créditos.' });
                    }
                }
            }
        } else if (provider === 'laozhang') {
            console.log(`[TTS Generate] Provider: laozhang, Voice: ${voice}`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Configure a chave do DarkVoz no painel admin para usar este provedor.' });
            }
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (!laozhangProviderId) {
                return res.status(400).json({ message: 'Provider DarkVoz não está ativo no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            adminApi = { id: laozhangProviderId, provider: 'laozhang' };
            console.log('[TTS Generate] ✅ Usando API DarkVoz (Laozhang.ai) do painel admin');
        }
        
        if (!apiKey) {
            return res.status(400).json({ message: 'Nenhuma API configurada.' });
        }

        // Se usar API do admin, verificar créditos antes
        if (useAdminApi && adminApi) {
            // Estimar tokens necessários
            const estimatedTokens = Math.ceil(script.length / 4);
            
            try {
                const creditCheck = await checkAndDebitCredits(
                    req.user.id,
                    adminApi.id,
                    estimatedTokens,
                    'api_tts_generation',
                    JSON.stringify({ model: finalTtsModel, provider: provider, endpoint: '/api/tts/generate-from-script' })
                );
                
                console.log(`💳 [CRÉDITOS] Pré-débito: ${creditCheck.creditsUsed.toFixed(2)} créditos. Saldo restante: ${creditCheck.newBalance.toFixed(2)}`);
            } catch (creditError) {
                if (creditError.message.includes('Créditos insuficientes')) {
                    return res.status(402).json({ 
                        error: creditError.message,
                        code: 'INSUFFICIENT_CREDITS'
                    });
                }
                throw creditError;
            }
        }

        const jobId = `tts-script-${Date.now()}-${crypto.randomBytes(4).toString('hex')}`;
        const jobData = {
            apiKey,
            ttsModel: finalTtsModel,
            script,
            voice,
            styleInstructions,
            provider: provider,
            speed: parseFloat(speed) || 1.0,
            useAdminApi: useAdminApi,
            adminApi: adminApi,
            userId: req.user.id
        };

        ttsJobs[jobId] = {
            id: jobId,
            status: 'queued',
            progress: 0,
            total: 1,
            message: 'Na fila para processamento...',
            downloadUrl: null,
            createdAt: new Date(),
        };

        // Processar job em background (implementação simplificada)
        processScriptTtsJob(jobId, jobData);

        res.status(202).json({ jobId });

    } catch (error) {
        console.error("Erro ao iniciar trabalho de TTS a partir de roteiro:", error);
        res.status(500).json({ message: `Não foi possível iniciar a geração de áudio: ${error.message}` });
    }
});

// GET /api/tts/status/:jobId - Consulta status do job TTS
app.get('/api/tts/status/:jobId', authenticateToken, (req, res) => {
    const { jobId } = req.params;
    const job = ttsJobs[jobId];

    if (!job) {
        return res.status(404).json({ message: 'Job não encontrado.' });
    }

    res.json({
        status: job.status,
        progress: job.progress,
        total: job.total,
        message: job.message,
        downloadUrl: job.downloadUrl,
        partDownloads: job.partDownloads || []
    });
});

// Função para processar job TTS em background (versão completa do DARKSCRIPT)
async function processScriptTtsJob(jobId, jobData) {
    const job = ttsJobs[jobId];
    
    // Garante que o job existe e reinicializa os valores
    if (!job) {
        console.error(`Job ${jobId} não encontrado`);
        return;
    }
    
    // Reinicializa o progresso para garantir que comece do zero
    job.status = 'processing';
    job.progress = 0;
    job.total = 0;
    job.message = 'Dividindo o roteiro...';
    const tempFilePaths = [];

    try {
        // Define o modelo e limite baseado no provedor
        // SEMPRE usar 4000 caracteres por parte conforme DARKSCRIPT
        let validatedTtsModel;
        let charLimit = 4000; // SEMPRE 4000 caracteres por parte
        let minDelayBetweenRequests;
        
        if (jobData.provider === 'openai') {
            // OpenAI TTS: limite REAL é 4096 caracteres por requisição, mas vamos usar 4000 para padronizar
            validatedTtsModel = 'tts-1-hd';
            minDelayBetweenRequests = 500; // 0.5s (OpenAI é rápido)
            console.log(`📢 Usando OpenAI TTS para gerar áudio (4000 chars por parte)`);
        } else if (jobData.provider === 'genaipro' || jobData.provider === 'voice_premium') {
            validatedTtsModel = 'genaipro-default';
            minDelayBetweenRequests = 2000; // 2s entre requisições
            console.log(`📢 Usando GenAIPro TTS para gerar áudio (4000 chars por parte)`);
        } else if (jobData.provider === 'laozhang') {
            // Usar modelo do jobData se fornecido, senão usar padrão
            validatedTtsModel = jobData.ttsModel || 'tts-1';
            minDelayBetweenRequests = 1500;
            console.log(`📢 Usando DarkVoz TTS para gerar áudio (4000 chars por parte, modelo: ${validatedTtsModel}, velocidade: ${jobData.speed || 1.0}x)`);
        } else {
            // Gemini TTS: aceita textos MUITO longos, mas vamos usar 4000 para padronizar
            validatedTtsModel = 'gemini-2.5-flash-preview-tts';
            minDelayBetweenRequests = 2000; // 2s entre requisições
            console.log(`📢 Usando Gemini TTS para gerar áudio (4000 chars por parte)`);
        }
        
        // Log para monitorar processamento de áudios longos
        const estimatedMinutes = Math.ceil((jobData.script.length / charLimit) * 0.5); // ~0.5 min por chunk
        if (estimatedMinutes > 30) {
            console.log(`Processando áudio longo estimado em ~${estimatedMinutes} minutos (${jobData.script.length} caracteres)`);
        }

        // Usando a função splitTextIntoChunks com 4000 caracteres
        const chunks = splitTextIntoChunks(jobData.script, charLimit);

        if (!chunks || chunks.length === 0) {
            throw new Error("Não foi possível dividir o roteiro em partes.");
        }
        
        // Validação prévia: verifica se há chunks antes de processar
        console.log(`📊 Roteiro dividido em ${chunks.length} parte(s) de até ${charLimit} caracteres cada.`);
        console.log(`   Total de caracteres: ${jobData.script.length.toLocaleString('pt-BR')}`);
        console.log(`   Estimativa de tempo: ~${Math.ceil(chunks.length * minDelayBetweenRequests / 1000 / 60)} minutos`);

        // Atualiza o job com o total de chunks ANTES de começar o processamento
        job.total = chunks.length;
        job.progress = 0;
        job.message = `📋 Roteiro dividido em ${chunks.length} partes. Preparando geração...`;
        
        // Verificar FFmpeg ANTES de começar (para mostrar status correto)
        let ffmpegAvailable = false;
        try {
            await new Promise((resolve, reject) => {
                ffmpeg().version((err) => {
                    if (err) reject(err);
                    else resolve();
                });
            });
            ffmpegAvailable = true;
        } catch (e) {
            ffmpegAvailable = false;
        }
        
        if (ffmpegAvailable) {
            job.message = `✅ FFmpeg detectado. Gerando ${chunks.length} partes de áudio...`;
        } else {
            job.message = `⚠️ FFmpeg não encontrado. Usando método alternativo para ${chunks.length} partes...`;
        }
        
        const audioExt = 'mp3'; // Sempre usar MP3
        const validTempFiles = [];
        
        // Processar cada chunk
        for (let i = 0; i < chunks.length; i++) {
            job.progress = i;
            job.message = `🎙️ Gerando parte ${i + 1}/${chunks.length}...`;
            
            try {
                const speakerVoiceMap = new Map([['Narrador', jobData.voice]]);
                const result = await generateTtsAudio({
                    apiKey: jobData.apiKey,
                    model: validatedTtsModel,
                    textInput: chunks[i],
                    speakerVoiceMap: speakerVoiceMap,
                    provider: jobData.provider,
                    speed: jobData.speed || 1.0
                });
                
                // Salvar arquivo temporário
                const tempPath = path.join(TEMP_AUDIO_DIR, `${jobId}_part_${i}.${audioExt}`);
                const audioBuffer = Buffer.from(result.audioBase64, 'base64');
                await fs.promises.writeFile(tempPath, audioBuffer);
                validTempFiles.push(tempPath);
                tempFilePaths.push(tempPath);
                
                console.log(`✅ Parte ${i + 1}/${chunks.length} gerada: ${audioBuffer.length} bytes`);
                
                // Delay entre partes
                if (i < chunks.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, minDelayBetweenRequests));
                }
            } catch (chunkError) {
                console.error(`❌ Erro ao gerar parte ${i + 1}/${chunks.length}:`, chunkError);
                // Continuar com outras partes mesmo se uma falhar
            }
        }
        
        if (validTempFiles.length === 0) {
            throw new Error('Nenhuma parte de áudio foi gerada com sucesso.');
        }
        
        // CASO 1: apenas 1 arquivo → retornar direto
        if (validTempFiles.length === 1) {
            const singleFile = await fs.promises.readFile(validTempFiles[0]);
            const singleBase64 = singleFile.toString('base64');
            job.downloadUrl = `data:audio/${audioExt};base64,${singleBase64}`;
            job.status = 'completed';
            job.progress = job.total;
            job.message = 'Áudio gerado com sucesso!';
            console.log(`🎉 TTS de roteiro concluído (sem concatenação): ${jobId}.${audioExt}`);
            return;
        }
        
        // CASO 2: mais de 1 arquivo E FFmpeg disponível → concatenar com FFmpeg
        if (ffmpegAvailable) {
            job.message = `🔗 Concatenando ${validTempFiles.length} partes com FFmpeg...`;
            console.log(`✅ FFmpeg disponível - concatenando ${validTempFiles.length} arquivos ${audioExt.toUpperCase()}`);
            
            const finalPath = path.join(TEMP_AUDIO_DIR, `${jobId}_final.${audioExt}`);
            const listFilePath = path.join(TEMP_AUDIO_DIR, `${jobId}_filelist.txt`);
            const fileListContent = validTempFiles
                .map(fp => `file '${fp.replace(/\\/g, '/')}'`)
                .join('\n');
            
            await fs.promises.writeFile(listFilePath, fileListContent, 'utf8');
            tempFilePaths.push(listFilePath);
            
            await new Promise((resolve, reject) => {
                ffmpeg()
                    .input(listFilePath)
                    .inputOptions(['-f', 'concat', '-safe', '0'])
                    .outputOptions(['-c', 'copy'])
                    .output(finalPath)
                    .on('start', (cmd) => {
                        console.log(`🎬 [TTS] FFmpeg iniciado para concatenação: ${cmd}`);
                    })
                    .on('progress', (progress) => {
                        if (progress.percent) {
                            job.message = `🔗 Concatenando com FFmpeg: ${Math.round(progress.percent)}%`;
                        }
                    })
                    .on('end', async () => {
                        console.log(`✅ [TTS] FFmpeg concluído: ${finalPath}`);
                        resolve();
                    })
                    .on('error', (err) => {
                        console.error(`❌ [TTS] Erro no FFmpeg: ${err.message}`);
                        reject(err);
                    })
                    .run();
            });
            
            // Ler arquivo final
            const finalAudio = await fs.promises.readFile(finalPath);
            const finalBase64 = finalAudio.toString('base64');
            job.downloadUrl = `data:audio/${audioExt};base64,${finalBase64}`;
            tempFilePaths.push(finalPath);
        } else {
            // CASO 3: FFmpeg não disponível → retornar partes separadas
            job.message = `⚠️ ${validTempFiles.length} partes geradas (FFmpeg não disponível para concatenação)`;
            job.partDownloads = validTempFiles.map((filePath, idx) => {
                const fileBase64 = fs.readFileSync(filePath).toString('base64');
                return {
                    part: idx + 1,
                    downloadUrl: `data:audio/${audioExt};base64,${fileBase64}`,
                    filename: `parte_${idx + 1}.${audioExt}`
                };
            });
            job.status = 'partial';
        }
        
        job.status = job.status === 'partial' ? 'partial' : 'completed';
        job.progress = job.total;
        job.message = job.status === 'completed' ? 'Áudio gerado com sucesso!' : job.message;
        
    } catch (error) {
        console.error(`Erro no trabalho TTS ${jobId}:`, error);
        job.status = 'failed';
        job.message = error.message || 'Ocorreu um erro desconhecido.';
        
        // Reembolsar créditos em caso de erro
        if (jobData.useAdminApi && jobData.adminApi) {
            try {
                const estimatedTokens = Math.ceil(jobData.script.length / 4);
                await refundCredits(jobData.userId, estimatedTokens * 0.1, 'Erro na geração de TTS');
            } catch (refundError) {
                console.error('Erro ao reembolsar créditos:', refundError);
            }
        }
    } finally {
        // Limpar arquivos temporários
        for (const filePath of tempFilePaths) {
            try {
                await fs.promises.unlink(filePath);
            } catch (unlinkError) {
                console.warn(`Não foi possível excluir o arquivo temporário ${filePath}: ${unlinkError.message}`);
            }
        }
        job.finishedAt = new Date();
    }
}


// === ROTAS DE GESTÃO DE API KEYS ===

app.post('/api/keys/save', authenticateToken, async (req, res) => {
    const { service_name, api_key } = req.body;
    const userId = req.user.id;

    if (!service_name || !api_key) {
        return res.status(400).json({ msg: 'Serviço e Chave de API são obrigatórios.' });
    }

    // Verificar se é uma API que requer plano premium (Claude, Gemini, OpenAI)
    const premiumApis = ['claude', 'gemini', 'openai'];
    if (premiumApis.includes(service_name.toLowerCase())) {
        try {
            // Verificar plano do usuário
            const user = await db.get('SELECT plan, subscription_plan, isAdmin FROM users WHERE id = ?', [userId]);
            if (!user) {
                return res.status(404).json({ msg: 'Usuário não encontrado.' });
            }
            
            const userPlan = user.subscription_plan || user.plan || 'plan-free';
            const hasPremiumPlan = userPlan === 'plan-master' || 
                                  userPlan === 'plan-master-annual' || 
                                  userPlan === 'plan-start-annual' || 
                                  userPlan === 'plan-turbo-annual' ||
                                  (user.isAdmin === 1 || user.isAdmin === true || String(user.isAdmin) === '1');
            
            if (!hasPremiumPlan) {
                return res.status(403).json({ 
                    msg: 'Você precisa ter o plano MASTER ou um plano ANUAL para usar suas próprias chaves de API. Faça upgrade para desbloquear este recurso.',
                    requiresUpgrade: true
                });
            }
        } catch (planErr) {
            console.error('Erro ao verificar plano do usuário:', planErr);
            return res.status(500).json({ msg: 'Erro ao verificar plano do usuário.' });
        }
    }

    try {
        const encryptedKey = encrypt(api_key);
        
        await db.run(
            `INSERT INTO user_api_keys (user_id, service_name, api_key) 
             VALUES (?, ?, ?)
             ON CONFLICT(user_id, service_name) 
             DO UPDATE SET api_key = excluded.api_key, created_at = CURRENT_TIMESTAMP`,
            [userId, service_name, encryptedKey]
        );

        res.status(200).json({ msg: `Chave de API para ${service_name} salva com sucesso!` });
    
    } catch (err) {
        console.error('Erro ao salvar chave de API:', err);
        res.status(500).json({ msg: 'Erro no servidor ao salvar a chave.' });
    }
});

app.get('/api/keys/status', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    try {
        const keys = await db.all('SELECT service_name FROM user_api_keys WHERE user_id = ?', [userId]);
        const status = {
            gemini: keys.some(k => k.service_name === 'gemini'),
            openai: keys.some(k => k.service_name === 'openai'),
            claude: keys.some(k => k.service_name === 'claude'),
            imagefx: keys.some(k => k.service_name === 'imagefx'),
        };
        res.status(200).json(status);
    } catch (err) {
        console.error('Erro ao buscar status das chaves:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

app.post('/api/keys/validate-all', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    try {
        const keysData = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
        
        if (keysData.length === 0) {
            return res.status(400).json({ msg: 'Nenhuma chave de API foi salva ainda.' });
        }

        const allowedServices = new Set(['gemini', 'openai', 'claude', 'imagefx', 'youtube']);
        const filteredKeysData = keysData.filter(key => allowedServices.has(key.service_name));
        const ignoredServices = keysData.filter(key => !allowedServices.has(key.service_name));

        if (ignoredServices.length > 0) {
            console.warn(`[Validação de Chaves] Ignorando serviços não suportados: ${ignoredServices.map(s => s.service_name).join(', ')}`);
        }

        if (filteredKeysData.length === 0) {
            return res.status(400).json({ msg: 'Nenhuma chave dos serviços suportados (Gemini, Claude, OpenAI, YouTube ou ImageFX) foi encontrada para validação.' });
        }

        const validationPromises = filteredKeysData.map(async (keyData) => {
            const decryptedKey = decrypt(keyData.api_key);
            if (!decryptedKey) {
                return { service: keyData.service_name, success: false, error: 'Falha ao desencriptar' };
            }

            switch (keyData.service_name) {
                case 'gemini':
                    const geminiResult = await validateGeminiKey(decryptedKey);
                    return { service: 'gemini', ...geminiResult };
                case 'openai':
                    const openaiResult = await validateOpenAIKey(decryptedKey);
                    return { service: 'openai', ...openaiResult };
                case 'claude':
                    const claudeResult = await validateClaudeKey(decryptedKey);
                    return { service: 'claude', ...claudeResult };
                case 'youtube':
                    const youtubeResult = await validateYouTubeKey(decryptedKey);
                    return { service: 'youtube', ...youtubeResult };
                case 'imagefx':
                    return { service: 'imagefx', success: true };
                default:
                    return { service: keyData.service_name, success: false, error: 'Serviço desconhecido' };
            }
        });

        const results = await Promise.all(validationPromises);
        
        // Adicionar informações sobre o tipo de chave detectado
        const resultsWithDetails = results.map(result => {
            if (result.service === 'gemini' && result.success && result.type) {
                return {
                    ...result,
                    message: result.message || (result.type === 'gemini-api' ? 'Chave de API do Gemini válida' : 'Chave do Google Cloud válida'),
                    warning: result.warning || null
                };
            }
            return result;
        });
        
        res.status(200).json({ 
            msg: 'Validação concluída.',
            results: resultsWithDetails
        });

    } catch (err) {
        console.error('Erro ao validar chaves:', err);
        res.status(500).json({ msg: 'Erro no servidor durante a validação.' });
    }
});


// === FUNÇÕES AUXILIARES DE ANÁLISE ===

// Função para determinar se um vídeo é realmente viral
function isViralVideo(views, days, viewsPerDay) {
    // Critérios para considerar um vídeo como viral:
    // 1. Mínimo de 100.000 views totais
    // 2. Mínimo de 10.000 views/dia (para vídeos recentes)
    // 3. Ou mínimo de 50.000 views/dia nos primeiros 7 dias
    // 4. Para vídeos mais antigos (>30 dias), mínimo de 500.000 views totais
    
    if (days <= 0) {
        // Sem informação de dias, usar apenas views totais
        return views >= 500000; // 500k+ views sem info de tempo = provavelmente viral
    }
    
    if (days <= 7) {
        // Vídeo muito recente: precisa de crescimento explosivo
        return viewsPerDay >= 50000 || views >= 500000;
    } else if (days <= 30) {
        // Vídeo recente: precisa de bom crescimento
        return viewsPerDay >= 10000 || views >= 300000;
    } else {
        // Vídeo mais antigo: precisa de views totais altas
        return views >= 1000000; // 1M+ views para vídeos antigos
    }
}

// === ROTAS DE ANÁLISE (O CORAÇÃO DO SAAS) ===

app.post('/api/analyze/titles', authenticateToken, async (req, res) => {
    const { videoUrl, model, folderId } = req.body;
    const userId = req.user.id;

    if (!videoUrl || !model) {
        return res.status(400).json({ msg: 'URL do vídeo e modelo de IA são obrigatórios.' });
    }
    
    try {
        // Verificar se o banco de dados está disponível
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível. Aguarde alguns instantes.' });
        }
        
        // --- ETAPA 1: Mineração de Dados (YouTube) ---
        console.log(`[Análise] A iniciar mineração para: ${videoUrl}`);
        let videoId;
        try {
            videoId = ytdl.getVideoID(videoUrl);
        } catch (err) {
            return res.status(400).json({ msg: 'URL do YouTube inválida.' });
        }

        // Tentar usar chave específica do YouTube primeiro, depois fallback para Gemini
        let youtubeApiKey = null;
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
            if (!youtubeApiKey && youtubeKeyData.api_key && !youtubeKeyData.api_key.includes(':')) {
                // Chave pode não estar criptografada
                youtubeApiKey = youtubeKeyData.api_key;
            }
        }
        
        // Se não tem chave do YouTube, tentar usar Gemini (pode funcionar se for chave do Google Cloud)
        if (!youtubeApiKey) {
            const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
                if (!youtubeApiKey && geminiKeyData.api_key && !geminiKeyData.api_key.includes(':')) {
                    youtubeApiKey = geminiKeyData.api_key;
                }
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ 
                msg: 'Nenhuma chave de API do YouTube configurada. Configure uma chave do YouTube Data API v3 nas Configurações. A chave do Gemini não funciona para a API do YouTube.' 
            });
        }

        const videoDetails = await callYouTubeDataAPI(videoId, youtubeApiKey);
        
        let transcriptText;
        let fullTranscript = null;
        try {
            const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
            fullTranscript = transcriptData.map(t => t.text).join(' ');
            transcriptText = fullTranscript.substring(0, 500); // Apenas início para o prompt
        } catch (err) {
            console.warn(`[Análise] Não foi possível obter transcrição para ${videoId}. A continuar sem ela.`);
            transcriptText = "(Transcrição não disponível)";
            fullTranscript = null;
        }
        
        console.log(`[Análise] Vídeo encontrado: ${videoDetails.title}`);

        // --- ETAPA 1.5: Traduzir título original para português ---
        let translatedTitle = videoDetails.title;
        try {
            const translatePrompt = `Traduza o seguinte título de vídeo do YouTube para português brasileiro (PT-BR). Mantenha o sentido, impacto e estrutura original. Retorne APENAS a tradução, sem explicações ou formatação.
Título original: "${videoDetails.title}"

Tradução em PT-BR:`;
            
            // Usar o sistema de preferência para tradução (laozhang.ai se configurada como padrão)
            let translateProvider = await getPreferredAIProvider(userId, ['claude', 'openai', 'gemini']);
            let translateText;
            
            if (translateProvider && translateProvider.service === 'laozhang') {
                // Usar laozhang.ai
                const translateResponse = await callLaozhangAPI(
                    translatePrompt, 
                    translateProvider.apiKey, 
                    translateProvider.model, 
                    null, 
                    userId, 
                    'api_call', 
                    JSON.stringify({ endpoint: '/api/analyze/titles', operation: 'translate', model: translateProvider.model })
                );
                translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
            } else if (translateProvider && translateProvider.service === 'claude') {
                // Usar Claude
                const translateResponse = await callClaudeAPI(translatePrompt, translateProvider.apiKey, translateProvider.model);
                translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
            } else if (translateProvider && translateProvider.service === 'openai') {
                // Usar OpenAI
                const translateResponse = await callOpenAIAPI(translatePrompt, translateProvider.apiKey, translateProvider.model);
                translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
            } else {
                // Fallback para Gemini se nenhum outro estiver disponível
                const translateResponse = await callGeminiAPI(translatePrompt, geminiApiKey, 'gemini-2.0-flash');
                translateText = translateResponse.titles.trim();
            }
            
            // Limpar a resposta (remover markdown, aspas, etc)
            translatedTitle = translateText.replace(/^["']|["']$/g, '').replace(/```json|```/g, '').trim();
            if (translatedTitle.length > 200) {
                translatedTitle = translatedTitle.substring(0, 200);
            }
            console.log(`[Análise] Título traduzido: ${translatedTitle}`);
        } catch (err) {
            console.warn(`[Análise] Falha ao traduzir título, usando original: ${err.message}`);
            translatedTitle = videoDetails.title;
        }

        // --- ETAPA 2: IA - Análise de Título e Geração (PROMPT REFINADO) ---
        const viewsPerDay = Math.round(videoDetails.views / Math.max(videoDetails.days, 1));
        const isViral = isViralVideo(videoDetails.views, videoDetails.days, viewsPerDay);
        
        // Contexto de performance baseado na classificação real
        let performanceContext;
        let viralContext;
        
        if (isViral) {
            if (videoDetails.days > 0) {
                performanceContext = `Este vídeo VIRALIZOU com ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias (média de ${viewsPerDay.toLocaleString()} views/dia) - um desempenho EXCEPCIONAL que indica alta viralização.`;
            } else {
                performanceContext = `Este vídeo VIRALIZOU com ${videoDetails.views.toLocaleString()} views - um desempenho EXCEPCIONAL que indica alta viralização.`;
            }
            viralContext = 'que VIRALIZOU';
        } else {
            // Vídeo não viral - ser honesto sobre a performance
            if (videoDetails.days > 0) {
                const performanceLevel = viewsPerDay < 100 
                    ? 'baixo desempenho' 
                    : viewsPerDay < 1000 
                        ? 'desempenho moderado' 
                        : 'bom desempenho';
                performanceContext = `Este vídeo tem ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias (média de ${viewsPerDay.toLocaleString()} views/dia) - ${performanceLevel}. Este vídeo NÃO viralizou, mas pode ser analisado para identificar elementos que podem ser melhorados para criar versões com maior potencial viral.`;
            } else {
                performanceContext = `Este vídeo tem ${videoDetails.views.toLocaleString()} views. Este vídeo NÃO viralizou, mas pode ser analisado para identificar elementos que podem ser melhorados para criar versões com maior potencial viral.`;
            }
            viralContext = 'de referência';
        }

        const titlePrompt = `
            Você é um ESPECIALISTA EM VIRALIZAÇÃO NO YOUTUBE com experiência comprovada em criar títulos que geram MILHÕES DE VIEWS e ALTO CTR (taxa de cliques acima de 25%). Sua missão é analisar um vídeo ${isViral ? 'que VIRALIZOU' : 'de referência'} e criar variações MUITO CHAMATIVAS focadas em VIRALIZAÇÃO para canais subnichados.

            🚀 CONTEXTO DO VÍDEO ${isViral ? 'VIRAL' : 'DE REFERÊNCIA'}:
            ${performanceContext}
            
            DADOS DO VÍDEO ORIGINAL:
            - Título Original (traduzido para PT-BR): "${translatedTitle}"
            - Título Original (idioma original): "${videoDetails.title}"
            - Visualizações: ${videoDetails.views.toLocaleString()} views
            - Comentários: ${videoDetails.comments.toLocaleString()} comentários
            - Dias desde publicação: ${videoDetails.days} dias
            - Thumbnail URL: ${videoDetails.thumbnailUrl}
            - Descrição (início): ${videoDetails.description ? videoDetails.description.substring(0, 300) : 'N/A'}...
            - Transcrição (início): ${transcriptText.substring(0, 500)}...

            🎯 PROMPT DE ANÁLISE DE TÍTULOS ${isViral ? 'VIRAIS' : 'DE REFERÊNCIA'} (DIRETO DO VÍDEO):
            Este vídeo do canal ${isViral ? 'viralizou, pegou' : 'tem'} ${videoDetails.views.toLocaleString()} VIEWS${videoDetails.days > 0 ? ` EM ${videoDetails.days} DIAS` : ''} com o título: "${videoDetails.title}"
            
            OBJETIVO: Criar títulos e canais MILIONÁRIOS com MILHÕES DE VIEWS e ALTO CTR (acima de 25%).
            
            Preciso que você me dê variações MUITO CHAMATIVAS focadas em VIRALIZAÇÃO para meu canal subnichado. Cada título deve ter POTENCIAL PARA GERAR MILHÕES DE VIEWS, não apenas alguns milhares. Foque em criar títulos que se tornem virais e gerem engajamento massivo.

            🎯 SUA TAREFA (FOCO EM VIRALIZAÇÃO E MILHÕES DE VIEWS):
            1.  **Análise Profunda de Nicho e Subnicho:** 
                - Identifique o "nicho" exato e o "subniche" específico do vídeo.
                - Analise por que esse subnicho funcionou tão bem e qual o público-alvo que gerou essa viralização.
                - Identifique oportunidades de subnichos pouco explorados com alto potencial de viralização.

            2.  **Análise do Título ${isViral ? 'Viral' : 'de Referência'} (Por que ${isViral ? 'funcionou' : 'não funcionou tão bem'}?):** 
                Analise PROFUNDAMENTE o título ${isViral ? 'que viralizou' : 'de referência'} e identifique:
                - Explique o "motivoSucesso" detalhado: ${isViral ? `Por que esse título específico gerou ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias? O que tornou ele tão viral?` : `Por que esse título gerou apenas ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias? O que faltou para ele viralizar? Quais elementos podem ser melhorados?`}
                - Identifique a "formulaTitulo" (a estrutura exata, gatilhos mentais, palavras-chave ${isViral ? 'virais' : 'que podem ser otimizadas'}, padrões emocionais ${isViral ? 'que fizeram esse título viralizar e gerar milhões de views' : 'que podem ser melhorados para criar versões com maior potencial viral'}).
                - Analise a PSICOLOGIA POR TRÁS DO SUCESSO: Qual emoção ele despertou? Que curiosidade ele criou? Que gatilho mental ele acionou? Que palavra-chave teve maior impacto? Por que as pessoas CLICARAM nele?
                - Identifique os PADRÕES VIRAIS COMPROVADOS: números impactantes, perguntas intrigantes, segredos revelados, contrastes, FOMO, prova social, urgência, escassez.
                - Analise a ESTRUTURA DO TÍTULO: Quantas palavras? Qual é a ordem das palavras-chave? Onde estão os gatilhos mentais? Qual é o ritmo de leitura?
                - Identifique PALAVRAS-CHAVE PODEROSAS que geraram cliques: quais palavras específicas fizeram a diferença? Quais palavras emocionais criaram conexão?

            3.  **Geração de Títulos Virais (FOCO EM MILHÕES DE VIEWS E ALTO CTR):** 
                Usando a "formulaTitulo" identificada como base, crie 5 variações MUITO CHAMATIVAS de títulos EM PORTUGUÊS BRASILEIRO (PT-BR) que:
                - TENHAM ALTO POTENCIAL VIRAL (capazes de gerar MILHÕES DE VIEWS como o original, não apenas milhares)
                - USEM GATILHOS MENTAIS PODEROSOS E COMPROVADOS (curiosidade, FOMO, surpresa, urgência, escassez, autoridade, prova social, emoção intensa)
                - INCLUAM PALAVRAS-CHAVE VIRAIS E PODEROSAS (números impactantes, palavras emocionais, perguntas que prendem atenção, palavras que geram cliques)
                - SEJAM OTIMIZADOS PARA ALTO CTR (taxa de cliques acima de 25%, preferencialmente 30% ou mais)
                - MANTENHAM A ESSÊNCIA E PODER VIRAL DO TÍTULO ORIGINAL mas com MELHORIAS para maior viralização e mais views
                - SEJAM ADAPTADOS PARA O SUBNICHO identificado, mas mantendo o PODER VIRAL e a capacidade de gerar milhões de views
                - SIGAM A MESMA ESTRUTURA que funcionou no título original (ordem das palavras, ritmo, gatilhos mentais)
                - TENHAM POTENCIAL PARA VIRALIZAR e gerar engajamento massivo (compartilhamentos, comentários, views orgânicas)

                Para cada novo título, forneça:
                - "titulo": O novo título EM PORTUGUÊS BRASILEIRO (PT-BR), otimizado para viralização e milhões de views, seguindo a fórmula que funcionou no título original.
                - "pontuacao": Uma nota de 0 a 10, avaliando o potencial viral e de CTR (10 = capaz de gerar milhões de views como o original com CTR acima de 25%, 9-10 = alto potencial viral com milhões de views, 7-8 = bom potencial mas pode melhorar, abaixo de 7 = precisa ser reescrito).
                - "explicacao": Uma justificativa detalhada em PORTUGUÊS BRASILEIRO explicando: 
                  * Por que esse título tem potencial para gerar MILHÕES DE VIEWS? 
                  * Quais gatilhos mentais específicos ele usa e por que eles funcionam?
                  * Por que ele pode gerar alto CTR (acima de 25%)?
                  * Como ele se compara ao título original que viralizou?
                  * Quais elementos da "formulaTitulo" ele aplica?
                  * Por que as pessoas vão CLICAR nele?
                  * Qual é o potencial de viralização (compartilhamentos, engajamento)?

            📊 ESTRATÉGIAS DE VIRALIZAÇÃO PARA TÍTULOS (APLIQUE ESSAS TÉCNICAS):
            - **Números e Estatísticas Impactantes:** Use números específicos, grandes, ou surpreendentes (ex: "5000 anos", "1 milhão de views", "3 segundos", "10 segredos", "5 coisas que ninguém sabe").
            - **Gatilhos de Curiosidade:** Crie perguntas, mistérios, segredos revelados, coisas escondidas ou proibidas (ex: "O que ninguém te conta sobre...", "O segredo que...", "O que aconteceu com...").
            - **FOMO (Medo de Perder):** Urgência, exclusividade, oportunidade única, tempo limitado (ex: "Antes que seja tarde", "O que você está perdendo", "A última chance de...").
            - **Prova Social:** "Todo mundo está falando", "viralizou", "ninguém sabe", "revelado", "descoberto", "exclusivo" (ex: "O que todo mundo quer saber", "A verdade que ninguém conhece").
            - **Emoções Intensas:** Choque, surpresa, medo, alegria, raiva, curiosidade (ex: "Chocante", "Inacreditável", "Você não vai acreditar", "Preparado para isso?").
            - **Contraste e Oposição:** "Parecia X mas era Y", "Todo mundo pensa X mas a verdade é Y" (ex: "Você pensava que era X, mas na verdade é Y", "O que todos acreditam está errado").
            - **Palavras Poderosas:** "SECRETO", "REVELADO", "ESCONDIDO", "PROIBIDO", "NUNCA VISTO", "CHOCANTE", "INCRÍVEL", "IMPERDÍVEL", "EXCLUSIVO", "DESCOBERTO", "REAL", "VERDADEIRO".
            - **Personalização:** "Você não sabia", "Isso vai mudar sua vida", "O que ninguém te conta", "O que você precisa saber" (ex: "O que você não sabia sobre...", "Isso vai mudar como você vê...").

            ⚠️ REGRAS CRÍTICAS PARA TÍTULOS VIRAIS (CRIAR CANAIS MILIONÁRIOS):
            - TODOS os títulos sugeridos DEVEM estar em PORTUGUÊS BRASILEIRO (PT-BR).
            - A "explicacao" de cada título também deve estar em PORTUGUÊS BRASILEIRO.
            - Mantenha o IMPACTO, CURIOSIDADE e GATILHOS MENTAIS do título original, mas MELHORE-OS para maior viralização e mais views.
            - Foque APENAS em títulos que TENHAM POTENCIAL PARA GERAR MILHÕES DE VIEWS, não apenas alguns milhares. Rejeite títulos que não tenham potencial viral alto.
            - Cada título deve ter um POTENCIAL VIRAL MUITO ALTO (pontuação 9-10, preferencialmente 10). Títulos com pontuação abaixo de 9 devem ser reescritos.
            - Os títulos devem ser OTIMIZADOS PARA ALTO CTR (acima de 25%, preferencialmente 30% ou mais).
            - Adapte para o SUBNICHO identificado, mas SEMPRE mantenha o PODER VIRAL do título original e a capacidade de gerar milhões de views.
            - Use a mesma "formulaTitulo" que funcionou no título viral, mas com variações criativas e melhorias que aumentem o potencial de viralização.
            - Cada título deve seguir a ESTRUTURA COMPROVADA do título original (ordem das palavras, ritmo, posicionamento dos gatilhos mentais).
            - Foque em criar títulos que VIRALIZEM e gerem engajamento massivo (compartilhamentos, comentários, views orgânicas).
            - Priorize títulos que TENHAM POTENCIAL PARA CRIAR CANAIS MILIONÁRIOS com milhões de views e alto CTR.

            IMPORTANTE: A sua resposta completa deve ser APENAS o objeto JSON, sem nenhum texto, comentário ou formatação markdown à volta.
            {
              "niche": "...",
              "subniche": "...",
              "analiseOriginal": {
                "motivoSucesso": "...",
                "formulaTitulo": "..."
              },
              "titulosSugeridos": [
                { "titulo": "...", "pontuacao": 9, "explicacao": "..." },
                { "titulo": "...", "pontuacao": 8, "explicacao": "..." },
                { "titulo": "...", "pontuacao": 10, "explicacao": "..." },
                { "titulo": "...", "pontuacao": 7, "explicacao": "..." },
                { "titulo": "...", "pontuacao": 9, "explicacao": "..." }
              ]
            }
        `;
        
        let allGeneratedTitles = [];
        let modelUsedForDisplay = model;
        let finalAnalysisData;
        let finalNicheData;
        
        // --- INÍCIO DA LÓGICA DO DISTRIBUIDOR (SWITCHER) ---
        if (model === 'all') {
            // Verificar se laozhang.ai está configurada como padrão
            let useLaozhangAsDefault = false;
            let laozhangKey = null;
            try {
                const laozhangDefaultSetting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
                useLaozhangAsDefault = laozhangDefaultSetting && (
                    laozhangDefaultSetting.value === 'true' || 
                    laozhangDefaultSetting.value === '1' ||
                    JSON.parse(laozhangDefaultSetting.value) === true
                );
                
                if (useLaozhangAsDefault) {
                    laozhangKey = await getLaozhangApiKey();
                    if (laozhangKey) {
                        console.log('[Análise-All] Laozhang.ai configurada como padrão, usando para comparação');
                    } else {
                        useLaozhangAsDefault = false;
                    }
                }
            } catch (err) {
                console.warn('[Análise-All] Erro ao verificar laozhang.ai:', err.message);
            }
            
            if (useLaozhangAsDefault && laozhangKey) {
                // Se laozhang.ai está como padrão, usar ela + outras duas APIs
                modelUsedForDisplay = 'Comparação (3 Modelos)';
                const keysData = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
                const keys = {};
                keysData.forEach(k => { keys[k.service_name] = decrypt(k.api_key); });

                if (!keys.claude || !keys.openai) {
                    return res.status(400).json({ msg: 'Para "Comparar" com o provedor padrão, precisa de ter as chaves de Claude E OpenAI configuradas.' });
                }

                console.log('[Análise-All] A chamar IA em paralelo (Laozhang.ai + Claude + OpenAI)...');
                const pLaozhang = callLaozhangAPI(
                    titlePrompt, 
                    laozhangKey, 
                    'gpt-4o', 
                    null, 
                    userId, 
                    'api_call', 
                    JSON.stringify({ endpoint: '/api/analyze/titles', operation: 'compare', model: 'gpt-4o' })
                );
                const pClaude = callClaudeAPI(titlePrompt, keys.claude, 'claude-3-7-sonnet-20250219');
                const pOpenAI = callOpenAIAPI(titlePrompt, keys.openai, 'gpt-4o');

                const results = await Promise.allSettled([pLaozhang, pClaude, pOpenAI]);

                let firstSuccessfulAnalysis = null;
                results.forEach((result, index) => {
                    let serviceName = ['Laozhang.ai', 'Claude', 'OpenAI'][index];
                    if (result.status === 'fulfilled') {
                        const responseValue = result.value;
                        const titlesText = typeof responseValue === 'string' ? responseValue : (responseValue.titles || JSON.stringify(responseValue));
                        const parsedData = parseAIResponse(titlesText, serviceName);
                        if (!firstSuccessfulAnalysis) firstSuccessfulAnalysis = parsedData;
                        
                        parsedData.titulosSugeridos.forEach(t => {
                            allGeneratedTitles.push({ ...t, titulo: `[${serviceName}] ${t.titulo}`, model: serviceName });
                        });
                    } else {
                        console.error(`[Análise-All] Falha com ${serviceName}:`, result.reason.message);
                        allGeneratedTitles.push({
                            titulo: `[${serviceName}] Falhou: ${result.reason.message}`, pontuacao: 0, explicacao: "A API falhou.", model: serviceName
                        });
                    }
                });
                
                if (!firstSuccessfulAnalysis) throw new Error("Todas as IAs falharam em retornar uma análise válida.");
                
                // Verificar se a análise tem os dados necessários
                if (!firstSuccessfulAnalysis.analiseOriginal) {
                    throw new Error("A IA retornou uma análise incompleta. Verifique as chaves de API e tente novamente.");
                }
                
                // Garantir que o nicho sempre existe (usar padrão se não detectado)
                finalNicheData = { 
                    niche: firstSuccessfulAnalysis.niche || 'Entretenimento', 
                    subniche: firstSuccessfulAnalysis.subniche || 'N/A' 
                };
                finalAnalysisData = firstSuccessfulAnalysis.analiseOriginal;
            } else {
                // Modo original: comparar Gemini, Claude e OpenAI
                modelUsedForDisplay = 'Comparação (Gemini, Claude, OpenAI)';
                const keysData = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
                const keys = {};
                keysData.forEach(k => { keys[k.service_name] = decrypt(k.api_key); });

                if (!keys.gemini || !keys.claude || !keys.openai) {
                    return res.status(400).json({ msg: 'Para "Comparar", precisa de ter as chaves de Gemini, Claude E OpenAI configuradas.' });
                }

                console.log('[Análise-All] A chamar IA em paralelo...');
                // Usando os modelos específicos para a comparação
                const pGemini = callGeminiAPI(titlePrompt, keys.gemini, 'gemini-2.5-pro');
                const pClaude = callClaudeAPI(titlePrompt, keys.claude, 'claude-3-7-sonnet-20250219');
                const pOpenAI = callOpenAIAPI(titlePrompt, keys.openai, 'gpt-4o');

            const results = await Promise.allSettled([pGemini, pClaude, pOpenAI]);

            let firstSuccessfulAnalysis = null;
            results.forEach((result, index) => {
                let serviceName = ['Gemini', 'Claude', 'OpenAI'][index];
                if (result.status === 'fulfilled') {
                    const parsedData = parseAIResponse(result.value.titles, serviceName);
                    if (!firstSuccessfulAnalysis) firstSuccessfulAnalysis = parsedData;
                    
                    parsedData.titulosSugeridos.forEach(t => {
                        allGeneratedTitles.push({ ...t, titulo: `[${serviceName}] ${t.titulo}`, model: serviceName });
                    });
                } else {
                    console.error(`[Análise-All] Falha com ${serviceName}:`, result.reason.message);
                    allGeneratedTitles.push({
                        titulo: `[${serviceName}] Falhou: ${result.reason.message}`, pontuacao: 0, explicacao: "A API falhou.", model: serviceName
                    });
                }
            });
            
            if (!firstSuccessfulAnalysis) throw new Error("Todas as IAs falharam em retornar uma análise válida.");
            
            // Verificar se a análise tem os dados necessários
            if (!firstSuccessfulAnalysis.analiseOriginal) {
                throw new Error("A IA retornou uma análise incompleta. Verifique as chaves de API e tente novamente.");
            }
            
                // Garantir que o nicho sempre existe (usar padrão se não detectado)
                finalNicheData = { 
                    niche: firstSuccessfulAnalysis.niche || 'Entretenimento', 
                    subniche: firstSuccessfulAnalysis.subniche || 'N/A' 
                };
                finalAnalysisData = firstSuccessfulAnalysis.analiseOriginal;
            }
        } else {
            // --- LÓGICA DE MODELO ÚNICO ---
            // PRIMEIRO: Verificar se laozhang.ai está configurada como padrão
            let service;
            let decryptedKey;
            let apiCallFunction;
            let useLaozhang = false;
            
            try {
                const laozhangDefaultSetting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
                const laozhangUseAsDefault = laozhangDefaultSetting && (
                    laozhangDefaultSetting.value === 'true' || 
                    laozhangDefaultSetting.value === '1' ||
                    JSON.parse(laozhangDefaultSetting.value) === true
                );
                
                if (laozhangUseAsDefault) {
                    const laozhangKey = await getLaozhangApiKey();
                    if (laozhangKey) {
                        service = 'laozhang';
                        decryptedKey = laozhangKey;
                        apiCallFunction = callLaozhangAPI;
                        useLaozhang = true;
                        console.log('[Análise-Laozhang.ai] Usando Laozhang.ai como padrão (configuração do admin)');
                    }
                }
            } catch (err) {
                console.warn('[Análise] Erro ao verificar configuração padrão Laozhang.ai:', err.message);
            }
            
            // SEGUNDO: Se não usar laozhang.ai como padrão, verificar preferência do usuário
            if (!useLaozhang) {
                const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
                const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
                
                if (useCredits) {
                    // Usuário prefere usar créditos - usar laozhang.ai
                    const laozhangKey = await getLaozhangApiKey();
                    if (laozhangKey) {
                        service = 'laozhang';
                        decryptedKey = laozhangKey;
                        apiCallFunction = callLaozhangAPI;
                        useLaozhang = true;
                        console.log('[Análise-Laozhang.ai] Usando Laozhang.ai (preferência: usar créditos)');
                    }
                }
            }
            
            // TERCEIRO: Se não usar laozhang.ai, usar API própria do usuário
            if (!useLaozhang) {
                if (model.startsWith('gemini')) service = 'gemini';
                else if (model.startsWith('claude')) service = 'claude';
                else if (model.startsWith('gpt')) service = 'openai';
                else service = 'gemini'; // fallback
                
                const userKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                if (!userKeyData) return res.status(400).json({ msg: `Nenhuma Chave de API do ${service} configurada.` });
                
                decryptedKey = decrypt(userKeyData.api_key);
                if (!decryptedKey) return res.status(500).json({ msg: 'Falha ao desencriptar a sua chave de API.' });

                if (service === 'gemini') apiCallFunction = callGeminiAPI;
                else if (service === 'claude') apiCallFunction = callClaudeAPI;
                else apiCallFunction = callOpenAIAPI;
            }

            console.log(`[Análise-${service}] A chamar IA...`);
            const response = await apiCallFunction(titlePrompt, decryptedKey, model);
            
            const parsedData = parseAIResponse(response.titles, service);
            
            // Verificar se a análise tem os dados necessários
            if (!parsedData.analiseOriginal) {
                throw new Error("A IA retornou uma análise incompleta. Verifique as chaves de API e tente novamente.");
            }
            
            // Garantir que o nicho sempre existe (usar padrão se não detectado)
            finalNicheData = { 
                niche: parsedData.niche || 'Entretenimento', 
                subniche: parsedData.subniche || 'N/A' 
            };
            finalAnalysisData = parsedData.analiseOriginal;
            allGeneratedTitles = parsedData.titulosSugeridos.map(t => ({ ...t, model: model }));
        }
        // --- FIM DA LÓGICA DO DISTRIBUIDOR ---

        console.log('[Análise] Títulos gerados com sucesso.');

        // --- ETAPA 3: Salvar no Banco de Dados ---
        let analysisId;
        try {
             const analysisResult = await db.run(
                `INSERT INTO analyzed_videos (user_id, folder_id, youtube_video_id, video_url, original_title, translated_title, original_views, original_comments, original_days, original_thumbnail_url, detected_niche, detected_subniche, analysis_data_json, full_transcript) 
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                    userId, folderId || null, videoId, videoUrl, videoDetails.title, translatedTitle, videoDetails.views,
                    videoDetails.comments, videoDetails.days, videoDetails.thumbnailUrl,
                    finalNicheData.niche, finalNicheData.subniche, JSON.stringify(finalAnalysisData), fullTranscript
                ]
            );
            analysisId = analysisResult.lastID;

            for (const titleData of allGeneratedTitles) {
                await db.run(
                    'INSERT INTO generated_titles (video_analysis_id, title_text, model_used, pontuacao, explicacao) VALUES (?, ?, ?, ?, ?)',
                    [analysisId, titleData.titulo, titleData.model, titleData.pontuacao, titleData.explicacao]
                );
            }
            console.log(`[Análise] Análise ${analysisId} salva no histórico (Pasta: ${folderId || 'Nenhuma'}).`);
        } catch (dbErr) {
            console.error("[Análise] FALHA AO SALVAR NO BANCO DE DADOS:", dbErr.message);
        }

        // --- ETAPA 4: Calcular Receita e RPM baseado no nicho ---
        let estimatedRevenueUSD = 0;
        let estimatedRevenueBRL = 0;
        let rpmUSD = 2.0;
        let rpmBRL = 11.0;
        
        try {
            // Calcular receita e RPM sempre, mesmo se o nicho não foi detectado
            const nicheToUse = (finalNicheData && finalNicheData.niche) ? finalNicheData.niche : null;
            const rpm = getRPMByNiche(nicheToUse); // getRPMByNiche retorna padrão se niche for null
            
            // Verificar se rpm foi retornado corretamente
            if (!rpm || typeof rpm !== 'object' || typeof rpm.usd !== 'number' || typeof rpm.brl !== 'number') {
                console.warn('[Análise] RPM inválido, usando valores padrão', { rpm, niche: nicheToUse });
                // Usar valores padrão se rpm for inválido
                const defaultRPM = { usd: 2.0, brl: 11.0 };
                const views = parseInt(videoDetails.views) || 0;
                estimatedRevenueUSD = (views / 1000) * defaultRPM.usd;
                estimatedRevenueBRL = (views / 1000) * defaultRPM.brl;
                rpmUSD = defaultRPM.usd;
                rpmBRL = defaultRPM.brl;
            } else {
                const views = parseInt(videoDetails.views) || 0;
                estimatedRevenueUSD = (views / 1000) * rpm.usd;
                estimatedRevenueBRL = (views / 1000) * rpm.brl;
                rpmUSD = rpm.usd;
                rpmBRL = rpm.brl;
            }
            
            // Garantir que todas as variáveis estão definidas e são números válidos
            if (typeof estimatedRevenueUSD !== 'number' || isNaN(estimatedRevenueUSD)) {
                console.warn('[Análise] estimatedRevenueUSD inválido, recalculando', { estimatedRevenueUSD, rpm, views: videoDetails.views });
                const views = parseInt(videoDetails.views) || 0;
                estimatedRevenueUSD = (views / 1000) * rpm.usd;
                estimatedRevenueBRL = (views / 1000) * rpm.brl;
            }
            
            console.log('[Análise] Receita calculada:', {
                views: videoDetails.views,
                niche: nicheToUse || 'padrão',
                rpmUSD,
                rpmBRL,
                estimatedRevenueUSD: estimatedRevenueUSD.toFixed(2),
                estimatedRevenueBRL: estimatedRevenueBRL.toFixed(2)
            });
        } catch (revenueErr) {
            console.error('[Análise] Erro ao calcular receita:', revenueErr);
            // Usar valores padrão em caso de erro
            const views = parseInt(videoDetails.views) || 0;
            estimatedRevenueUSD = (views / 1000) * 2.0;
            estimatedRevenueBRL = (views / 1000) * 11.0;
            rpmUSD = 2.0;
            rpmBRL = 11.0;
        }

        // --- ETAPA 5: Enviar Resposta (com IDs dos títulos, receita e RPM) ---
        const finalTitlesWithIds = await db.all('SELECT id, title_text as titulo, model_used as model, pontuacao, explicacao, is_checked FROM generated_titles WHERE video_analysis_id = ?', [analysisId]);

        // NÃO salvar automaticamente - apenas quando o usuário marcar o checkbox
        // O salvamento será feito quando o usuário marcar o título como selecionado
        console.log(`[Biblioteca] Títulos gerados aguardando seleção do usuário para salvar na biblioteca`);
        
        // Garantir que todas as variáveis estão definidas antes de enviar
        const responseData = {
            niche: finalNicheData?.niche || 'N/A',
            subniche: finalNicheData?.subniche || 'N/A',
            analiseOriginal: finalAnalysisData || {},
            titulosSugeridos: finalTitlesWithIds || [],
            modelUsed: modelUsedForDisplay || 'N/A', 
            videoDetails: { 
                ...videoDetails, 
                videoId: videoId, 
                translatedTitle: translatedTitle || videoDetails.title,
                estimatedRevenueUSD: typeof estimatedRevenueUSD === 'number' ? estimatedRevenueUSD : 0,
                estimatedRevenueBRL: typeof estimatedRevenueBRL === 'number' ? estimatedRevenueBRL : 0,
                rpmUSD: typeof rpmUSD === 'number' ? rpmUSD : 2.0,
                rpmBRL: typeof rpmBRL === 'number' ? rpmBRL : 11.0
            },
            folderId: folderId || null
        };
        
        // Log para debug
        console.log('[Análise] Enviando resposta:', {
            hasEstimatedRevenueUSD: typeof responseData.videoDetails.estimatedRevenueUSD !== 'undefined',
            estimatedRevenueUSD: responseData.videoDetails.estimatedRevenueUSD,
            hasRpmUSD: typeof responseData.videoDetails.rpmUSD !== 'undefined',
            rpmUSD: responseData.videoDetails.rpmUSD
        });

        res.status(200).json(responseData);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/analyze/titles]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao processar a análise.' });
    }
});

// Rota alternativa que SEMPRE usa Laozhang.ai para análise de títulos
app.post('/api/analyze/titles/laozhang', authenticateToken, async (req, res) => {
    const { videoUrl, model: requestedModel, folderId } = req.body;
    const userId = req.user.id;

    if (!videoUrl) {
        return res.status(400).json({ msg: 'URL do vídeo é obrigatória.' });
    }
    
    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível. Aguarde alguns instantes.' });
        }
        
        // SEMPRE usar laozhang.ai
        const laozhangKey = await getLaozhangApiKey();
        if (!laozhangKey) {
            return res.status(400).json({ msg: 'Provedor externo não configurado no painel admin. Configure a chave de API primeiro.' });
        }

        // Determinar qual modelo usar (se especificado, usar ele; senão, usar gpt-4o como padrão)
        let modelToUse = requestedModel || 'gpt-4o';
        // Mapear modelos para os nomes corretos da laozhang.ai
        if (modelToUse === 'gpt-4o') {
            modelToUse = 'gpt-4o';
        } else if (modelToUse === 'claude-3-7-sonnet-20250219') {
            modelToUse = 'claude-3-7-sonnet-20250219';
        } else if (modelToUse === 'gemini-2.5-pro') {
            modelToUse = 'gemini-2.5-pro';
        }

        const userId = req.user.id;

        // Mineração de dados (mesma lógica da rota original)
        console.log(`[Análise Laozhang] A iniciar mineração para: ${videoUrl}`);
        let videoId;
        try {
            videoId = ytdl.getVideoID(videoUrl);
        } catch (err) {
            return res.status(400).json({ msg: 'URL do YouTube inválida.' });
        }

        // Tentar usar chave específica do YouTube primeiro, depois fallback para Gemini
        let youtubeApiKey = null;
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
            if (!youtubeApiKey && youtubeKeyData.api_key && !youtubeKeyData.api_key.includes(':')) {
                // Chave pode não estar criptografada
                youtubeApiKey = youtubeKeyData.api_key;
            }
            console.log('[Análise Laozhang] Usando chave do YouTube configurada');
        }
        
        // Se não tem chave do YouTube, tentar usar Gemini (pode funcionar se for chave do Google Cloud)
        if (!youtubeApiKey) {
            const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
                if (!youtubeApiKey && geminiKeyData.api_key && !geminiKeyData.api_key.includes(':')) {
                    youtubeApiKey = geminiKeyData.api_key;
                }
                console.log('[Análise Laozhang] Usando chave do Gemini como fallback para YouTube');
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ 
                msg: 'Nenhuma chave de API do YouTube configurada. Configure uma chave do YouTube Data API v3 nas Configurações.' 
            });
        }

        const videoDetails = await callYouTubeDataAPI(videoId, youtubeApiKey);
        
        let transcriptText;
        let fullTranscript = null;
        try {
            const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
            fullTranscript = transcriptData.map(t => t.text).join(' ');
            transcriptText = fullTranscript.substring(0, 500);
        } catch (err) {
            console.warn(`[Análise Laozhang] Não foi possível obter transcrição para ${videoId}.`);
            transcriptText = "(Transcrição não disponível)";
            fullTranscript = null;
        }
        
        console.log(`[Análise Laozhang] Vídeo encontrado: ${videoDetails.title}`);

        // Traduzir título usando laozhang.ai
        let translatedTitle = videoDetails.title;
        try {
            const translatePrompt = `Traduza o seguinte título de vídeo do YouTube para português brasileiro (PT-BR). Mantenha o sentido, impacto e estrutura original. Retorne APENAS a tradução, sem explicações ou formatação.
Título original: "${videoDetails.title}"

Tradução em PT-BR:`;
            
            const translateResponse = await callLaozhangAPI(
                translatePrompt, 
                laozhangKey, 
                'gpt-4o', 
                null, 
                userId, 
                'api_call', 
                JSON.stringify({ endpoint: '/api/analyze/titles/laozhang', operation: 'translate', model: 'gpt-4o' })
            );
            const translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
            translatedTitle = translateText.replace(/^["']|["']$/g, '').replace(/```json|```/g, '').trim();
            if (translatedTitle.length > 200) {
                translatedTitle = translatedTitle.substring(0, 200);
            }
            console.log(`[Análise Laozhang] Título traduzido: ${translatedTitle}`);
        } catch (err) {
            console.warn(`[Análise Laozhang] Falha ao traduzir título, usando original: ${err.message}`);
            translatedTitle = videoDetails.title;
        }

        // Criar prompt de análise (mesmo da rota original, mas simplificado para laozhang)
        const viewsPerDay = Math.round(videoDetails.views / Math.max(videoDetails.days, 1));
        const isViral = isViralVideo(videoDetails.views, videoDetails.days, viewsPerDay);
        
        const titlePrompt = `Você é um ESPECIALISTA EM TÍTULOS VIRAIS PARA YOUTUBE com experiência em criar canais milionários.

ANÁLISE DO VÍDEO VIRAL:
- Título Original: "${videoDetails.title}"
- Título Traduzido: "${translatedTitle}"
- Visualizações: ${videoDetails.views.toLocaleString()}
- Comentários: ${videoDetails.comments.toLocaleString()}
- Dias desde publicação: ${videoDetails.days}
- Visualizações por dia: ${viewsPerDay.toLocaleString()}
- Status: ${isViral ? 'VIRAL' : 'Popular'}
${transcriptText ? `\n- Transcrição (início): "${transcriptText.substring(0, 500)}..."` : ''}

SUA TAREFA:
1. Analise POR QUE este título viralizou
2. Identifique a FÓRMULA EXATA do título
3. Gere 5 títulos novos usando a mesma fórmula, mas com variações criativas

FORMATO DE RESPOSTA (JSON):
{
  "niche": "Nicho detectado",
  "subniche": "Subnicho detectado",
  "analiseOriginal": {
    "motivoSucesso": "Por que viralizou",
    "formulaTitulo": "Fórmula identificada"
  },
  "titulosSugeridos": [
    { "titulo": "Título 1", "pontuacao": 10, "explicacao": "Por que funciona" },
    { "titulo": "Título 2", "pontuacao": 9, "explicacao": "Por que funciona" },
    ...
  ]
}

IMPORTANTE: Retorne APENAS o JSON, sem texto adicional.`;

        console.log('[Análise Laozhang] A chamar Laozhang.ai...');
        const response = await callLaozhangAPI(
            titlePrompt, 
            laozhangKey, 
            modelToUse, 
            null, 
            userId, 
            'api_call', 
            JSON.stringify({ endpoint: '/api/analyze/titles/laozhang', model: modelToUse })
        );
        
        // callLaozhangAPI retorna string diretamente agora
        const responseText = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        console.log('[Análise Laozhang] Resposta recebida (primeiros 500 chars):', responseText.substring(0, 500));
        const parsedData = parseAIResponse(responseText, 'Laozhang.ai');
        
        if (!parsedData.analiseOriginal) {
            throw new Error("A IA retornou uma análise incompleta.");
        }
        
        const finalNicheData = { 
            niche: parsedData.niche || 'Entretenimento', 
            subniche: parsedData.subniche || 'N/A' 
        };
        const finalAnalysisData = parsedData.analiseOriginal;
        // Função para limpar nome do modelo (remover fornecedores)
        const cleanModelName = (modelName) => {
            if (!modelName) return 'GPT-4o';
            let clean = String(modelName)
                .replace(/laozhang\.ai/gi, '')
                .replace(/laozhang/gi, '')
                .replace(/openai/gi, '')
                .replace(/anthropic/gi, '')
                .replace(/google/gi, '')
                .trim();
            clean = clean.replace(/^(laozhang-|claude-|gemini-|gpt-|openai-|anthropic-)/i, '');
            clean = clean.replace(/-(laozhang|claude|gemini|gpt|openai|anthropic)$/i, '');
            // Mapear para nomes amigáveis
            if (clean.includes('gpt-4o')) return 'GPT-4o';
            if (clean.includes('claude-3-7-sonnet') || clean.includes('sonnet-3-7')) return 'Claude 3.7 Sonnet';
            if (clean.includes('claude-sonnet-4') || clean.includes('sonnet-4')) return 'Claude Sonnet 4';
            if (clean.includes('gemini-2.5-pro')) return 'Gemini 2.5 Pro';
            if (clean.includes('gemini-2.5-flash')) return 'Gemini 2.5 Flash';
            return clean || 'GPT-4o';
        };
        
        // Determinar nome do modelo baseado no modelo usado (sem expor fornecedor)
        const modelNameForDisplay = cleanModelName(model);
        const allGeneratedTitles = parsedData.titulosSugeridos.map(t => ({ ...t, model: modelNameForDisplay }));

        // Salvar no banco
        let analysisId;
        try {
             const analysisResult = await db.run(
                `INSERT INTO analyzed_videos (user_id, folder_id, youtube_video_id, video_url, original_title, translated_title, original_views, original_comments, original_days, original_thumbnail_url, detected_niche, detected_subniche, analysis_data_json, full_transcript) 
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                    userId, folderId || null, videoId, videoUrl, videoDetails.title, translatedTitle, videoDetails.views,
                    videoDetails.comments, videoDetails.days, videoDetails.thumbnailUrl,
                    finalNicheData.niche, finalNicheData.subniche, JSON.stringify(finalAnalysisData), fullTranscript
                ]
            );
            analysisId = analysisResult.lastID;

            for (const titleData of allGeneratedTitles) {
                await db.run(
                    'INSERT INTO generated_titles (video_analysis_id, title_text, model_used, pontuacao, explicacao) VALUES (?, ?, ?, ?, ?)',
                    [analysisId, titleData.titulo, titleData.model, titleData.pontuacao, titleData.explicacao]
                );
            }
            console.log(`[Análise Laozhang] Análise ${analysisId} salva no histórico.`);
        } catch (dbErr) {
            console.error("[Análise Laozhang] FALHA AO SALVAR NO BANCO DE DADOS:", dbErr.message);
        }

        // Calcular receita (mesma lógica)
        let estimatedRevenueUSD = 0;
        let estimatedRevenueBRL = 0;
        let rpmUSD = 2.0;
        let rpmBRL = 11.0;
        
        try {
            const nicheToUse = finalNicheData.niche || null;
            const rpm = getRPMByNiche(nicheToUse);
            if (rpm && typeof rpm === 'object' && typeof rpm.usd === 'number' && typeof rpm.brl === 'number') {
                const views = parseInt(videoDetails.views) || 0;
                estimatedRevenueUSD = (views / 1000) * rpm.usd;
                estimatedRevenueBRL = (views / 1000) * rpm.brl;
                rpmUSD = rpm.usd;
                rpmBRL = rpm.brl;
            }
        } catch (err) {
            console.warn('[Análise Laozhang] Erro ao calcular receita:', err);
        }

        res.status(200).json({
            niche: finalNicheData.niche,
            subniche: finalNicheData.subniche,
            analiseOriginal: finalAnalysisData,
            titulosSugeridos: allGeneratedTitles,
            modelUsed: modelNameForDisplay || 'GPT-4o',
            videoDetails: {
                ...videoDetails,
                videoId: videoId,
                translatedTitle: translatedTitle || videoDetails.title,
                estimatedRevenueUSD: estimatedRevenueUSD,
                estimatedRevenueBRL: estimatedRevenueBRL,
                rpmUSD: rpmUSD,
                rpmBRL: rpmBRL
            },
            folderId: folderId || null
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/analyze/titles/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao processar a análise.' });
    }
});

app.put('/api/titles/:titleId/check', authenticateToken, async (req, res) => {
    const { titleId } = req.params;
    const { is_checked } = req.body;
    const userId = req.user.id;

    try {
        // Buscar informações do título antes de atualizar
        const titleData = await db.get(`
            SELECT gt.id, gt.title_text, gt.pontuacao, gt.video_analysis_id, av.detected_niche, av.detected_subniche, av.original_views, av.analysis_data_json
            FROM generated_titles gt
            INNER JOIN analyzed_videos av ON gt.video_analysis_id = av.id
            WHERE gt.id = ? AND av.user_id = ?
        `, [titleId, userId]);

        if (!titleData) {
            return res.status(404).json({ msg: 'Título não encontrado ou não pertence a este utilizador.' });
        }

        // Atualiza o status do título específico
        const result = await db.run(
            `UPDATE generated_titles SET is_checked = ? 
             WHERE id = ? AND video_analysis_id IN (SELECT id FROM analyzed_videos WHERE user_id = ?)`,
            [is_checked, titleId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Título não encontrado ou não pertence a este utilizador.' });
        }

        // Se o título foi marcado (is_checked = true), salvar na biblioteca
        if (is_checked) {
            try {
                const cleanTitle = titleData.title_text.replace(/^\[.*?\]\s*/, ''); // Remove prefixo [Gemini], [Claude], etc
                const analysisData = titleData.analysis_data_json ? JSON.parse(titleData.analysis_data_json) : null;
                
                // Verificar se já existe na biblioteca para evitar duplicatas
                const existing = await db.get(
                    'SELECT id FROM viral_titles_library WHERE user_id = ? AND title = ?',
                    [userId, cleanTitle]
                );

                if (!existing) {
                    await db.run(
                        `INSERT INTO viral_titles_library (user_id, title, niche, subniche, original_views, formula_type, viral_score)
                         VALUES (?, ?, ?, ?, ?, ?, ?)`,
                        [userId, cleanTitle, titleData.detected_niche, titleData.detected_subniche, titleData.original_views, analysisData?.formulaTitulo || null, titleData.pontuacao || null]
                    );
                    console.log(`[Biblioteca] Título "${cleanTitle.substring(0, 50)}..." salvo na biblioteca`);
                }
            } catch (libErr) {
                console.warn('[Biblioteca] Erro ao salvar título marcado na biblioteca:', libErr.message);
            }
        }

        res.status(200).json({ msg: 'Status do título atualizado.' });
    } catch (err) {
        console.error('Erro ao atualizar status do título:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});
// Função helper para mapear estilos de arte para prompts específicos otimizados (mesmos estilos de prompts e imagens)
function getStyleSpecificPrompt(style, includePhrases) {
    // Mapear estilos do gerador de thumbnails para os estilos de prompts/imagens
    const styleMapping = {
        'Hiper-realista': 'photorealistic',
        'Fotografia de alta definicao (8K)': 'photorealistic',
        'Estilo cinematico (luz dramatica)': 'cinematic',
        'Foco nitido, alto detalhe': 'photorealistic',
        'Longa Exposicao': 'documentary',
        'Preto e Branco': 'documentary',
        'Fotografia Macro': 'photorealistic'
    };
    
    // Se o estilo já for um dos estilos de prompts/imagens, usar diretamente
    const mappedStyle = styleMapping[style] || style;
    
    // Usar os mesmos sufixos de estilo que são usados em prompts/imagens
    const styleSuffixes = {
        'photorealistic': 'Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyperrealistic, ultra high definition, 8K resolution, extreme sharpness, maximum detail, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography, taken with a high-end camera like a Sony α7 IV, detailed skin texture with pores visible in 8K, natural lighting, real textures with visible imperfections in ultra HD, real lighting with real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, extreme detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, National Geographic quality, BBC documentary style',
        'cinematic': 'Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, cinematic, dramatic lighting, film grain, anamorphic lens, color grading, movie still, Hollywood style, epic composition, dramatic shadows, professional color grading, cinematic composition, film noir lighting style, dramatic atmosphere',
        'documentary': 'Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, documentary style, natural lighting, authentic, candid photography, real moments, journalistic approach, raw and unfiltered',
        'cinematic-narrative': 'Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, cinematic narrative, storytelling composition, dramatic angles, emotional depth, visual storytelling, film photography',
        'anime': 'anime style, Japanese animation, vibrant colors, expressive characters, detailed backgrounds, manga-inspired, cel-shaded',
        'cartoon': 'cartoon style, animated, colorful, expressive, playful, hand-drawn aesthetic, vibrant palette',
        'cartoon-premium': 'premium cartoon style, high-quality animation, detailed character design, rich colors, professional animation studio quality',
        'fantasy': 'fantasy art, magical atmosphere, epic scale, mystical lighting, enchanted, otherworldly, detailed fantasy illustration',
        'stick-figure': 'stick figure style, minimalist line art, simple black lines on white background, clean and minimal',
        'whiteboard': 'whiteboard animation style, clean white background, hand-drawn illustrations, educational, clear and simple',
        'tech-minimalist': 'tech minimalist, clean design, modern aesthetic, geometric shapes, minimal color palette, futuristic, sleek',
        'spiritual-minimalist': 'spiritual minimalist, serene atmosphere, soft lighting, peaceful composition, meditative, zen aesthetic',
        'viral-vibrant': 'viral vibrant style, high contrast, saturated colors, bold composition, eye-catching, social media optimized, vibrant and energetic',
        'modern-documentary': 'modern documentary style, dynamic, contemporary, authentic moments, modern cinematography',
        'analog-horror': 'analog horror style, VHS quality, grainy texture, retro horror aesthetic, vintage feel',
        'dark-theater': 'dark theater style, dramatic stage lighting, intense shadows, theatrical composition',
        'naturalist-drama': 'naturalist drama style, realistic, emotional, authentic human moments',
        'spiritual-neorealism': 'spiritual neorealism style, transcendent realism, mystical atmosphere',
        'psychological-surrealism': 'psychological surrealism style, dreamlike images, abstract reality',
        'fragmented-memory': 'fragmented memory style, collage aesthetic, fragmented composition',
        'fragmented-narrative': 'fragmented narrative style, collage style, layered visual narrative',
        'dream-real': 'dream-real style, liminal space between dream and reality, ethereal atmosphere',
        'vhs-nostalgic': 'VHS nostalgic style, retro 80s/90s aesthetic, vintage quality, analog grain'
    };
    
    return styleSuffixes[mappedStyle] || styleSuffixes['photorealistic'];
}

// Função helper para gerar descrição SEO otimizada com emojis
function generateOptimizedSEODescription(title, subniche, language) {
    const emojiMap = {
        'pt': {
            'Marketing Digital': '📱💼',
            'YouTube': '🎥📺',
            'TikTok': '🎵📱',
            'Instagram': '📸✨',
            'Negócios': '💼🚀',
            'Educação': '📚🎓',
            'Tecnologia': '💻🔧',
            'Saúde': '💪🏥',
            'Fitness': '🏋️💪',
            'Viagem': '✈️🌍',
            'Culinária': '🍳👨‍🍳',
            'Entretenimento': '🎬🎭'
        },
        'en': {
            'Digital Marketing': '📱💼',
            'YouTube': '🎥📺',
            'TikTok': '🎵📱',
            'Instagram': '📸✨',
            'Business': '💼🚀',
            'Education': '📚🎓',
            'Technology': '💻🔧',
            'Health': '💪🏥',
            'Fitness': '🏋️💪',
            'Travel': '✈️🌍',
            'Cooking': '🍳👨‍🍳',
            'Entertainment': '🎬🎭'
        },
        'es': {
            'Marketing Digital': '📱💼',
            'YouTube': '🎥📺',
            'TikTok': '🎵📱',
            'Instagram': '📸✨',
            'Negocios': '💼🚀',
            'Educación': '📚🎓',
            'Tecnología': '💻🔧',
            'Salud': '💪🏥',
            'Fitness': '🏋️💪',
            'Viajes': '✈️🌍',
            'Cocina': '🍳👨‍🍳',
            'Entretenimiento': '🎬🎭'
        }
    };
    
    const langCode = language === 'Português' ? 'pt' : language === 'Inglês' ? 'en' : 'es';
    const emojis = emojiMap[langCode] || emojiMap['pt'];
    const nicheEmoji = emojis[subniche] || '🎯';
    
    if (langCode === 'pt') {
        return `${nicheEmoji} ${title}

📌 Neste vídeo você vai descobrir:
✅ Tudo sobre ${subniche}
✅ Estratégias comprovadas que funcionam
✅ Dicas exclusivas para resultados rápidos

🎯 Se você quer dominar ${subniche}, este vídeo é para você!

💡 Deixe seu like se este conteúdo te ajudou! 👍
📢 Compartilhe com quem precisa ver isso!
🔔 Ative o sininho para não perder nenhum conteúdo!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📚 CONTEÚDO DO VÍDEO:
Neste vídeo completo, você vai aprender tudo sobre ${subniche} e como aplicar estratégias eficazes para alcançar seus objetivos.

🎬 O QUE VOCÊ VAI APRENDER:
• Como dominar ${subniche}
• Estratégias práticas e aplicáveis
• Dicas exclusivas de especialistas
• Erros comuns a evitar

💼 SOBRE O CANAL:
Aqui você encontra conteúdo de qualidade sobre ${subniche}, com dicas práticas, tutoriais e estratégias que realmente funcionam.

🔗 LINKS IMPORTANTES:
📱 Siga-nos nas redes sociais para mais conteúdo exclusivo!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#${subniche.replace(/\s+/g, '')} #YouTube #Conteúdo #Dicas #Tutorial`;
    } else if (langCode === 'en') {
        return `${nicheEmoji} ${title}

📌 In this video you'll discover:
✅ Everything about ${subniche}
✅ Proven strategies that work
✅ Exclusive tips for quick results

🎯 If you want to master ${subniche}, this video is for you!

💡 Leave a like if this content helped you! 👍
📢 Share with those who need to see this!
🔔 Turn on notifications to never miss content!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📚 VIDEO CONTENT:
In this complete video, you'll learn everything about ${subniche} and how to apply effective strategies to achieve your goals.

🎬 WHAT YOU'LL LEARN:
• How to master ${subniche}
• Practical and applicable strategies
• Exclusive expert tips
• Common mistakes to avoid

💼 ABOUT THE CHANNEL:
Here you'll find quality content about ${subniche}, with practical tips, tutorials and strategies that really work.

🔗 IMPORTANT LINKS:
📱 Follow us on social media for more exclusive content!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#${subniche.replace(/\s+/g, '')} #YouTube #Content #Tips #Tutorial`;
    } else {
        return `${nicheEmoji} ${title}

📌 En este video descubrirás:
✅ Todo sobre ${subniche}
✅ Estrategias probadas que funcionan
✅ Consejos exclusivos para resultados rápidos

🎯 Si quieres dominar ${subniche}, ¡este video es para ti!

💡 ¡Dale like si este contenido te ayudó! 👍
📢 ¡Comparte con quien necesita ver esto!
🔔 ¡Activa las notificaciones para no perderte contenido!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📚 CONTENIDO DEL VIDEO:
En este video completo, aprenderás todo sobre ${subniche} y cómo aplicar estrategias efectivas para alcanzar tus objetivos.

🎬 LO QUE APRENDERÁS:
• Cómo dominar ${subniche}
• Estrategias prácticas y aplicables
• Consejos exclusivos de expertos
• Errores comunes a evitar

💼 SOBRE EL CANAL:
Aquí encontrarás contenido de calidad sobre ${subniche}, con consejos prácticos, tutoriales y estrategias que realmente funcionan.

🔗 ENLACES IMPORTANTES:
📱 ¡Síguenos en redes sociales para más contenido exclusivo!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#${subniche.replace(/\s+/g, '')} #YouTube #Contenido #Consejos #Tutorial`;
    }
}

// Função helper para gerar as 12 regras de thumbnail viral do YouTube
function getThumbnailViralRules(selectedRule = 'auto', selectedTitle = '') {
    const rules = {
        'rule1': {
            name: 'Regra da Clareza Imediata (1 segundo)',
            description: 'O cérebro precisa entender a thumbnail em menos de 1 segundo. Se houver confusão, o clique cai.',
            checklist: ['1 ideia principal', '1 personagem', '1 emoção', '1 objeto-chave'],
            instructions: 'A thumbnail DEVE ser compreendida em menos de 1 segundo. Use APENAS: 1 ideia principal, 1 personagem, 1 emoção, 1 objeto-chave. Elimine qualquer elemento que cause confusão ou distração.'
        },
        'rule2': {
            name: 'Regra do Assunto Único',
            description: 'Nada divide a atenção. A thumbnail boa é sempre uma história em uma imagem.',
            instructions: 'Foque em UM ÚNICO assunto dominante. Nada deve competir pela atenção. A thumbnail deve contar uma história completa em uma única imagem, sem elementos que dividam o foco.'
        },
        'rule3': {
            name: 'Regra do Rosto Grande',
            description: 'Rostos com forte expressão emocional aumentam CTR de 20% a 60%.',
            expressions: ['choque', 'surpresa', 'medo', 'raiva', 'felicidade extrema'],
            instructions: 'Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A expressão facial DEVE ser EXTREMA e EMOCIONAL: choque, surpresa, medo, raiva ou felicidade extrema. O rosto deve ser o elemento dominante e a primeira coisa que o olho vê.'
        },
        'rule4': {
            name: 'Regra do Contraste Brutal',
            description: 'Se não tiver contraste, a thumbnail fica invisível.',
            contrasts: ['texto vs fundo', 'personagem vs fundo', 'cores complementares (azul/laranja, amarelo/roxo)'],
            instructions: 'Use CONTRASTE BRUTAL entre: texto e fundo, personagem e fundo, cores complementares (azul/laranja, amarelo/roxo). O contraste deve ser tão forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.'
        },
        'rule5': {
            name: 'Regra da Cor Estratégica',
            description: 'Cada cor ativa um gatilho.',
            colors: {
                'Amarelo': 'atenção imediata',
                'Vermelho': 'urgência / perigo',
                'Azul': 'confiança',
                'Verde': 'dinheiro / solução',
                'Preto': 'premium / mistério'
            },
            instructions: 'Use cores estratégicas que ativem gatilhos mentais: Amarelo (atenção imediata), Vermelho (urgência/perigo), Azul (confiança), Verde (dinheiro/solução), Preto (premium/mistério). Escolha a cor baseada na emoção que o título transmite.'
        },
        'rule6': {
            name: 'Regra dos Terços',
            description: 'Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso dá harmonia e aumenta o foco natural.',
            instructions: 'Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos terços (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.'
        },
        'rule7': {
            name: 'Regra do Texto Ultra Curto',
            description: 'Texto deve ter 2 a 4 palavras, nunca mais.',
            examples: ['Ele mentiu', 'Descobri isso', 'Ninguém viu', 'Proibido'],
            instructions: 'O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Exemplos: "Ele mentiu", "Descobri isso", "Ninguém viu", "Proibido". Textos longos matam o CTR. Seja brutalmente direto e impactante.'
        },
        'rule8': {
            name: 'Regra do Zoom Emocional',
            description: 'Aparece sempre um elemento gigante que amplifica a emoção ou o conflito.',
            examples: ['uma conta bancária gigante', 'uma faca gigante', 'uma lupa gigante', 'um número gigante'],
            instructions: 'Use um elemento GIGANTE que amplifique a emoção ou conflito: uma conta bancária gigante, uma faca gigante, uma lupa gigante, um número gigante. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.'
        },
        'rule9': {
            name: 'Regra do Mistério',
            description: 'Toda thumbnail viral tem uma pergunta implícita.',
            examples: ['algo escondido atrás de blur', 'objeto cortado pela metade', 'pessoa olhando para fora do quadro', 'seta apontando para algo fora da tela'],
            instructions: 'Crie uma pergunta implícita na thumbnail usando: algo escondido atrás de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela. O espectador DEVE sentir curiosidade sobre o que está fora da imagem.'
        },
        'rule10': {
            name: 'Regra dos Pontos de Fuga',
            description: 'Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.',
            elements: ['setas', 'linhas diagonais', 'perspectiva'],
            instructions: 'Use linhas visuais que guiem o olhar para o foco: setas, linhas diagonais, perspectiva. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal (personagem ou objeto).'
        },
        'rule11': {
            name: 'Regra do Espaço Negativo',
            description: 'Deixar áreas vazias acentua o foco. Sem isso, a imagem vira bagunça.',
            instructions: 'Deixe áreas vazias (espaço negativo) que acentuem o foco no elemento principal. O espaço vazio cria respiração visual e faz o elemento principal "pular" da imagem. Sem espaço negativo, a thumbnail vira bagunça visual.'
        },
        'rule12': {
            name: 'Regra da Coerência com o Título',
            description: 'Thumbnail e título precisam contar a mesma história, mas com ângulos diferentes.',
            instructions: 'A thumbnail e o título DEVEM contar a mesma história, mas com ângulos diferentes: Título = contexto, Thumbnail = emoção. A thumbnail deve amplificar a emoção que o título promete, criando uma sinergia perfeita.'
        }
    };
    
    if (selectedRule === 'auto') {
        // IA deve identificar qual regra melhor se encaixa baseado no título
        return {
            mode: 'auto',
            instructions: `Analise o título "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral melhor se encaixa. Aplique a regra identificada de forma rigorosa. Se múltiplas regras se aplicarem, priorize a que tiver maior impacto no CTR.`,
            allRules: rules
        };
    } else {
        const rule = rules[selectedRule];
        if (!rule) {
            return { mode: 'auto', instructions: 'Regra não encontrada. Use modo automático.', allRules: rules };
        }
        return {
            mode: 'manual',
            rule: rule,
            instructions: rule.instructions
        };
    }
}

app.post('/api/analyze/thumbnail', authenticateToken, async (req, res) => {
    let { videoId, selectedTitle, model, niche, subniche, language, includePhrases, style, customPrompt, thumbnailRule } = req.body;
    const userId = req.user.id;

    if (!videoId || !selectedTitle || !model || !niche || !subniche || !language || includePhrases === undefined || !style) {
        return res.status(400).json({ msg: 'Dados insuficientes para gerar ideias de thumbnail.' });
    }
    
    // Se thumbnailRule não for fornecido, usar 'auto'
    thumbnailRule = thumbnailRule || 'auto';

    try {
        // Verificar se Laozhang está configurado como padrão
        const laozhangSettings = await db.get('SELECT laozhang_use_as_default FROM app_settings LIMIT 1');
        const useLaozhang = laozhangSettings && (laozhangSettings.laozhang_use_as_default === 1 || laozhangSettings.laozhang_use_as_default === true);
        
        if (useLaozhang) {
            // Redirecionar para rota Laozhang
            const laozhangKeyData = await db.get('SELECT api_key FROM app_settings WHERE setting_key = ?', ['laozhang_api_key']);
            if (!laozhangKeyData || !laozhangKeyData.api_key) {
                return res.status(400).json({ msg: 'Provedor externo configurado como padrão, mas chave não encontrada.' });
            }
            // Continuar com rota normal mas usando Laozhang internamente
        }
        
        // --- 1. Identificar serviço e buscar chaves ---
        let service;
        
        // Mapear modelos corretamente
        if (model === 'gpt-4o') {
            service = 'openai';
            model = 'gpt-4o';
        } else if (model === 'claude-3-7-sonnet-20250219') {
            service = 'claude';
            model = 'claude-3-7-sonnet-20250219';
        } else if (model === 'gemini-2.5-pro') {
            service = 'gemini';
            model = 'gemini-2.5-pro';
        } else if (model.startsWith('gemini')) {
            service = 'gemini';
        } else if (model.startsWith('claude')) {
            service = 'claude';
        } else if (model.startsWith('gpt')) {
            service = 'openai';
        } else {
            service = 'gemini'; // Fallback
            model = 'gemini-2.5-pro';
        }

        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
        if (!keyData) return res.status(400).json({ msg: `Chave de API do ${service} não configurada.` });
        const decryptedKey = decrypt(keyData.api_key);
        if (!decryptedKey) return res.status(500).json({ msg: 'Falha ao desencriptar a sua chave de API.' });
        
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        const geminiApiKey = decrypt(geminiKeyData.api_key);
        if (!geminiApiKey) return res.status(400).json({ msg: 'Chave do Gemini (necessária para o YouTube) não encontrada.' });

        // --- 2. Buscar dados do vídeo original ---
        const videoDetails = await callYouTubeDataAPI(videoId, geminiApiKey);
        
        // --- 2.5. Buscar análise original para pegar a fórmula do título ---
        let formulaTitulo = null;
        let motivoSucesso = null;
        try {
            const originalAnalysis = await db.get(
                'SELECT analysis_data_json FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                [videoId, userId]
            );
            if (originalAnalysis && originalAnalysis.analysis_data_json) {
                const analysisData = JSON.parse(originalAnalysis.analysis_data_json);
                if (analysisData.formulaTitulo) {
                    formulaTitulo = analysisData.formulaTitulo;
                }
                if (analysisData.motivoSucesso) {
                    motivoSucesso = analysisData.motivoSucesso;
                }
            }
        } catch (err) {
            console.warn(`[Análise-Thumb] Não foi possível buscar análise original: ${err.message}`);
        }
        
        // --- 3. Criar o prompt multimodal (PROMPT REFINADO ou CUSTOMIZADO) ---
        let thumbPrompt;
        
        if (customPrompt && customPrompt.trim()) {
            // Se houver prompt customizado, usar ele como base
            thumbPrompt = `
            Você é um especialista em YouTube, combinando as habilidades de um diretor de arte para thumbnails e um mestre de SEO.

            IMAGEM DE REFERÊNCIA: [A imagem da thumbnail original do vídeo está anexada]
            TÍTULO DO VÍDEO (para contexto): "${selectedTitle}"
            SUBNICHO (Público-Alvo): "${subniche}"
            ESTILO DE ARTE DESEJADO: "${style}"
            IDIOMA DO CONTEÚDO: "${language}"

            PROMPT PERSONALIZADO DO USUÁRIO:
            ${customPrompt}

            ⚠️ ATENÇÃO CRÍTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, não ilustrações, desenhos ou renderizações. A descriçãoThumbnail deve descrever uma FOTO REAL tirada por um fotógrafo profissional em um local real, com pessoas reais e objetos reais.
            
            ${(() => {
                const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
                if (ruleData.mode === 'auto') {
                    return `\n            🔍 MODO AUTOMÁTICO - ANÁLISE DE REGRA:\n            Analise o título "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPLÍCITA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.\n\n            📋 AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE (ALGORITMO OFICIAL):\n\n            1️⃣ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO):\n            O cérebro precisa entender a thumbnail em menos de 1 segundo. Se houver confusão, o clique cai.\n            Checklist OBRIGATÓRIO: 1 ideia principal, 1 personagem, 1 emoção, 1 objeto-chave.\n            A thumbnail DEVE ser compreendida instantaneamente. Elimine qualquer elemento que cause confusão ou distração.\n\n            2️⃣ REGRA DO ASSUNTO ÚNICO:\n            Nada divide a atenção. A thumbnail boa é sempre uma história em uma imagem.\n            Foque em UM ÚNICO assunto dominante. Nada deve competir pela atenção. A thumbnail deve contar uma história completa em uma única imagem, sem elementos que dividam o foco.\n\n            3️⃣ REGRA DO ROSTO GRANDE:\n            Rostos com forte expressão emocional aumentam CTR de 20% a 60%.\n            Expressões mais fortes: choque, surpresa, medo, raiva, felicidade extrema.\n            Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A expressão facial DEVE ser EXTREMA e EMOCIONAL. O rosto deve ser o elemento dominante e a primeira coisa que o olho vê.\n\n            4️⃣ REGRA DO CONTRASTE BRUTAL:\n            Se não tiver contraste, a thumbnail fica invisível.\n            Use CONTRASTE BRUTAL entre: texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n            O contraste deve ser tão forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.\n\n            5️⃣ REGRA DA COR ESTRATÉGICA:\n            Cada cor ativa um gatilho:\n            - Amarelo: atenção imediata\n            - Vermelho: urgência / perigo\n            - Azul: confiança\n            - Verde: dinheiro / solução\n            - Preto: premium / mistério\n            Escolha a cor baseada na emoção que o título transmite.\n\n            6️⃣ REGRA DOS TERÇOS:\n            Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso dá harmonia e aumenta o foco natural.\n            Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos terços (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.\n\n            7️⃣ REGRA DO TEXTO ULTRA CURTO:\n            Texto deve ter 2 a 4 palavras, nunca mais.\n            Exemplos: "Ele mentiu", "Descobri isso", "Ninguém viu", "Proibido".\n            O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Textos longos matam o CTR. Seja brutalmente direto e impactante.\n\n            8️⃣ REGRA DO ZOOM EMOCIONAL:\n            Aparece sempre um elemento gigante que amplifica a emoção ou o conflito.\n            Exemplos: uma conta bancária gigante, uma faca gigante, uma lupa gigante, um número gigante.\n            Use um elemento GIGANTE que amplifique a emoção ou conflito. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.\n\n            9️⃣ REGRA DO MISTÉRIO:\n            Toda thumbnail viral tem uma pergunta implícita.\n            Exemplos: algo escondido atrás de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela.\n            Crie uma pergunta implícita na thumbnail. O espectador DEVE sentir curiosidade sobre o que está fora da imagem.\n\n            🔟 REGRA DOS PONTOS DE FUGA:\n            Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.\n            Sinalizações: setas, linhas diagonais, perspectiva.\n            Use linhas visuais que guiem o olhar para o foco. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal.\n\n            1️⃣1️⃣ REGRA DO ESPAÇO NEGATIVO:\n            Deixar áreas vazias acentua o foco. Sem isso, a imagem vira bagunça.\n            Deixe áreas vazias (espaço negativo) que acentuem o foco no elemento principal. O espaço vazio cria respiração visual e faz o elemento principal "pular" da imagem.\n\n            1️⃣2️⃣ REGRA DA COERÊNCIA COM O TÍTULO:\n            Thumbnail e título precisam contar a mesma história, mas com ângulos diferentes.\n            Título = contexto, Thumbnail = emoção.\n            A thumbnail e o título DEVEM contar a mesma história, mas com ângulos diferentes. A thumbnail deve amplificar a emoção que o título promete, criando uma sinergia perfeita.\n\n            ⚠️ CRÍTICO: Identifique qual regra melhor se encaixa no título "${selectedTitle}" e aplique-a de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.`;
                } else {
                    return `\n            📋 REGRA SELECIONADA: ${ruleData.rule.name}\n            ${ruleData.rule.description}\n\n            ${ruleData.rule.checklist ? `✅ Checklist: ${ruleData.rule.checklist.join(', ')}` : ''}\n            ${ruleData.rule.expressions ? `😮 Expressões recomendadas: ${ruleData.rule.expressions.join(', ')}` : ''}\n            ${ruleData.rule.contrasts ? `🎨 Contrastes: ${ruleData.rule.contrasts.join(', ')}` : ''}\n            ${ruleData.rule.colors ? `🌈 Cores estratégicas: ${Object.entries(ruleData.rule.colors).map(([k, v]) => `${k} (${v})`).join(', ')}` : ''}\n            ${ruleData.rule.examples ? `💡 Exemplos: ${ruleData.rule.examples.join(', ')}` : ''}\n            ${ruleData.rule.elements ? `➡️ Elementos: ${ruleData.rule.elements.join(', ')}` : ''}\n\n            ⚠️ CRÍTICO: Aplique esta regra de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail:\n            ${ruleData.instructions}`;
                }
            })()}
            
            🎯 OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando técnicas de Thumbnail Designer profissional:
            - TEXTO PROFISSIONAL (COMO PHOTOSHOP): O texto DEVE parecer feito no Photoshop por um designer profissional. Use múltiplos efeitos de camada (stroke, drop shadow com valores específicos, outer glow, bevel and emboss), tipografia profissional com kerning perfeito, renderização profissional com anti-aliasing. Grande, estilizado, cores vibrantes (amarelo/vermelho/branco com outline preto), efeitos visuais profissionais com valores específicos (distância, spread, tamanho, opacidade, ângulo), posicionamento estratégico (topo/centro), ocupando 25-35% da imagem. O texto DEVE ter qualidade de agência de design, não amador.
            - COMPOSIÇÃO: Regra dos terços, hierarquia visual clara, elemento principal em destaque
            - CORES: Alto contraste, cores complementares, saturação otimizada, fundo que faz o texto "pular"
            - EMOÇÃO: Expressões faciais intensas, momentos de tensão, curiosidade visual
            - ELEMENTOS VIRAIS: FOMO (medo de perder), surpresa, contraste dramático, storytelling visual
            
            SUA TAREFA:
            Crie DUAS (2) ideias distintas para uma nova thumbnail baseadas no prompt personalizado acima.
            
            ⚠️⚠️⚠️ CRÍTICO - ORDEM DAS IDEIAS ⚠️⚠️⚠️
            - **IDEIA 1 (RÉPLICA E MELHORIA DA THUMBNAIL ORIGINAL DO VÍDEO):** 
              * OBRIGATÓRIO: Esta ideia DEVE replicar e melhorar a thumbnail ORIGINAL do vídeo ao qual foram feitos os títulos.
              * Analise cuidadosamente a IMAGEM DE REFERÊNCIA (thumbnail original do vídeo) que está anexada.
              * Replique a estrutura da thumbnail original quase 1:1: mantenha EXATAMENTE a mesma composição, ângulo de câmera, enquadramento, posição dos personagens/objetos, paleta de cores, quantidade de texto, posição do texto, elementos visuais principais e storytelling.
              * PRESERVE o poder viral da thumbnail original que gerou milhões de views.
              * Apenas ELEVE A QUALIDADE: mais nitidez (8K), contraste reforçado, iluminação cinematográfica profissional, correções de cor profissionais, tratamento de pele profissional, brilho nos olhos, textura realista, limpeza de ruídos, adicione luzes/sombras profissionais, aplique efeitos de texto Photoshop com valores específicos (stroke, drop shadow, outer glow, bevel & emboss).
              * NÃO altere o storytelling principal, apenas entregue a versão definitiva com acabamento premium.
              * Resultado: praticamente igual à thumbnail original, mas com sensação de upgrade premium e leitura instantânea mais clara e clicável.
              * IMPORTANTE: Se a thumbnail original não estiver disponível ou não puder ser analisada, ainda assim mantenha o mesmo conceito visual e estrutura, apenas melhorando a qualidade.
            
            - **IDEIA 2 (THUMBNAIL MELHORADA E OTIMIZADA):** 
              * Esta é uma versão COMPLETAMENTE NOVA, melhorada e otimizada para CTR alto (30%+).
              * Crie um conceito totalmente novo com foco em CTR máximo: novo enquadramento, nova composição, novos elementos que gerem curiosidade extrema.
              * Use gatilhos agressivos (perigo, segredo revelado, números gigantes, setas, antes/depois, close dramático) e cores super contrastantes.
              * Construa um storytelling diferente, alinhado ao título "${selectedTitle}", que prometa algo ainda mais irresistível que a versão original.
              * O texto deve ser redesenhado para máxima legibilidade mobile, com layer styles profissionais e valores precisos.
              * Pode mudar cenário, personagens, enquadramento e paleta, explorando um novo gancho visual com FOMO extremo, contraste máximo, expressões dramáticas e elementos que não existem na thumb original.
              * Objetivo: criar uma thumbnail inédita que pareça "campanha de performance", otimizada para CTR alto e retenção visual imediata.
              * Esta versão deve ser AINDA MELHOR que a original, com técnicas avançadas de viralização.

            PARA CADA UMA DAS 2 IDEIAS, GERE:
            1.  **"seoDescription"**: Uma descrição de vídeo para o YouTube, EXTREMAMENTE OTIMIZADA PARA SEO E VIRALIZAÇÃO, com:
               - Emojis estratégicos e relevantes (use emojis que representem o nicho e subnicho)
               - Parágrafos bem estruturados com quebras de linha
               - Chamadas para ação (CTA) claras e persuasivas
               - Uso estratégico de palavras-chave relevantes para o título "${selectedTitle}" e subnicho "${subniche}"
               - Formatação profissional com separadores visuais (━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━)
               - Seções organizadas: introdução, conteúdo do vídeo, sobre o canal, links importantes, hashtags
               - Linguagem persuasiva e envolvente que gere curiosidade e urgência
               - A descrição deve estar no idioma "${language}" e ter entre 300-500 palavras
               - IMPORTANTE: Use emojis de forma estratégica (não exagere, mas use para destacar seções importantes)
               - Inclua hashtags relevantes no final
               - Seja específico sobre o que o espectador vai aprender/ganhar
               
            2.  **"seoTags"**: Um array de strings com as 15-25 tags MAIS RELEVANTES E ESTRATÉGICAS para o vídeo (LIMITE MÁXIMO: 300 caracteres no total, incluindo vírgulas e espaços. NÃO ultrapasse 300 caracteres), incluindo:
               - Tags de cauda curta (1-2 palavras): termos populares e competitivos relacionados ao título "${selectedTitle}" e subnicho "${subniche}"
               - Tags de cauda longa (3-5 palavras): termos mais específicos e menos competitivos que capturam intenção de busca
               - Tags de nicho: termos específicos do subnicho "${subniche}"
               - Tags de tendência: termos que estão em alta no momento relacionados ao tema
               - Tags de formato: termos como "tutorial", "dicas", "como fazer", "guia completo", "passo a passo", etc.
               - Tags de plataforma: termos relacionados à plataforma (YouTube, TikTok, Instagram, etc.)
               - Tags de emoção: termos que capturam a emoção do título (ex: "surpresa", "revelação", "mistério", "urgência", "choque")
               - Tags de benefício: termos que descrevem o que o espectador vai ganhar/aprender
               - Tags de palavra-chave principal: extrair as palavras-chave mais importantes do título "${selectedTitle}"
               - Tags de sinônimos: variações e sinônimos das palavras-chave principais
               - IMPORTANTE: As tags devem ser EXTREMAMENTE RELEVANTES ao título "${selectedTitle}" e ao subnicho "${subniche}"
               - Evite tags genéricas que não agregam valor
               - Priorize tags que tenham volume de busca mas não sejam extremamente competitivas
               - Misture tags em português/inglês/espanhol conforme o idioma "${language}"
               - LIMITE MÁXIMO: 300 caracteres no total (incluindo vírgulas e espaços). NÃO ultrapasse 300 caracteres.
               - Cada tag deve ter entre 1-5 palavras, sendo a maioria com 2-3 palavras para otimizar o uso do espaço
               - Priorize tags mais relevantes e estratégicas. Se necessário, reduza a quantidade de tags para não ultrapassar 300 caracteres.
            3.  **"frasesDeGancho"**: Um array com 5 frases CURTAS de impacto (ganchos) para a thumbnail, OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne um array vazio [].' : `
                ⚠️⚠️⚠️ CRÍTICO E OBRIGATÓRIO - IDIOMA DAS FRASES DE GANCHO ⚠️⚠️⚠️
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Português' ? `
                ✅ CORRETO (Português): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : language === 'Inglês' ? `
                ✅ CORRETO (Inglês): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : `
                ✅ CORRETO (Espanhol): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante", "La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGATÓRIAS:
                1. Se "${language}" for "Português", TODAS as 5 frases DEVEM estar em PORTUGUÊS (Brasil)
                2. Se "${language}" for "Inglês", TODAS as 5 frases DEVEM estar em INGLÊS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em inglês se o idioma escolhido for português ou espanhol
                5. NUNCA, JAMAIS retorne frases em português se o idioma escolhido for inglês ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for português ou inglês
                7. Cada frase deve ter 2 a 4 palavras, no máximo
                8. As frases devem ser impactantes e relacionadas ao título "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases estão no idioma "${language}"?
                - Nenhuma frase está em inglês se "${language}" for português ou espanhol?
                - Nenhuma frase está em português se "${language}" for inglês ou espanhol?
                - Nenhuma frase está em espanhol se "${language}" for português ou inglês?
                
                Se alguma resposta for NÃO, CORRIJA as frases antes de retornar o JSON.
                `}
            4.  **"descricaoThumbnail"**: Um prompt EXTREMAMENTE DETALHADO e VÍVIDO, em INGLÊS, para uma IA de geração de imagem. ${!includePhrases ? 'NÃO inclua nenhum placeholder para texto. A thumbnail deve ser APENAS imagem, sem texto ou frases de gancho.' : 'A descrição DEVE incluir um placeholder claro, como "[FRASE DE GANCHO AQUI]", onde o texto da thumbnail deve ser inserido. CRÍTICO: Quando mencionar o texto, descreva-o como se fosse criado no Photoshop por um designer profissional: use termos como "Professional Photoshop-quality text design", "professional layer effects", "Photoshop stroke effect", "professional drop shadow with specific values (distance, spread, size, opacity, angle)", "professional outer glow", "professional bevel and emboss", "professional typography with perfect kerning", "professional text rendering with anti-aliasing", "looks like it was designed by a professional graphic designer". O texto DEVE ter múltiplos efeitos de camada do Photoshop com valores específicos, não apenas descrições genéricas. Fonte estilizada profissional, grande e impactante, cores vibrantes e contrastantes, efeitos visuais profissionais (sombra com valores específicos, brilho, outline, gradiente), posicionamento estratégico, tamanho grande que ocupa 25-35% da imagem.'}
            
            CRÍTICO PARA A "descricaoThumbnail" - DEVE SER FOTOGRAFIA REAL ULTRA HD 8K, NÃO ILUSTRAÇÃO:
            - OBRIGATÓRIO: A descrição DEVE começar EXATAMENTE com: "Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, real lighting, real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, 8K resolution, extreme sharpness, maximum detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography quality"
            
            - ENFATIZE REPETIDAMENTE E OBRIGATORIAMENTE: "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail", "every pore visible", "every texture crisp", "perfect focus", "ultra sharp", "no blur except intentional depth of field", "no artifacts", "no compression", "no pixelation", "perfect clarity", "real photograph", "shot on location", "documentary photography", "realistic textures with imperfections", "natural lighting with real shadows", "real depth of field", "real bokeh effects", "professional color grading", "high dynamic range (HDR)", "sharp focus on subject", "real camera grain", "real-world photography", "actual photograph", "photographed in real life", "real person", "real object", "real environment", "National Geographic quality", "BBC documentary style", "professional photography", "photorealistic", "hyper-realistic"
            
            - NUNCA, JAMAIS use estes termos: "illustration", "drawing", "artwork", "digital art", "render", "3D render", "CGI", "cartoon", "anime", "sketch", "painting", "stylized", "artistic", "concept art", "digital painting", "graphic design", "vector", "comic", "fantasy art", "artistic interpretation", "stylized", "artistic style", "digital illustration"
            
            - SEMPRE use APENAS estes termos: "photograph", "photo", "photography", "shot", "captured", "documentary photo", "realistic capture", "professional photography", "real-world photography", "actual photograph", "photographed", "real-life photography", "on-location photography", "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail"
            
            - IMPORTANTE: Descreva como se fosse uma FOTO REAL ULTRA HD 8K tirada por um fotógrafo profissional. Mencione detalhes realistas como: "real skin texture with pores and natural imperfections visible in 8K detail", "real fabric texture with visible fibers and weave patterns in ultra HD", "real stone texture with weathering, cracks, and imperfections visible in perfect 8K clarity", "real shadows cast by real light sources with perfect sharpness", "real depth of field blur with perfect bokeh", "real camera lens distortion", "real chromatic aberration", "real lens flare", "real motion blur if applicable", "every detail visible in 8K resolution", "extreme sharpness and clarity", "no compression artifacts", "perfect focus on subject"

            REGRAS IMPORTANTES:
            - A "descricaoThumbnail" é OBRIGATORIAMENTE em INGLÊS.
            - "seoDescription", "seoTags" e "frasesDeGancho" são OBRIGATORIAMENTE no idioma "${language}".
            ${!includePhrases ? '- IMPORTANTE: A "descricaoThumbnail" NÃO deve mencionar texto, palavras ou frases. Apenas descreva elementos visuais, composição, cores, iluminação, etc.' : ''}
            - Seja extremamente específico e detalhado nas descrições visuais. Use termos técnicos de fotografia profissional, cinematografia e psicologia visual quando apropriado.
            - Foque em elementos que maximizem CTR: expressões faciais intensas, momentos de tensão, curiosidade visual, contraste dramático, composição impactante.
            
            EXEMPLOS DE COMO DESCREVER PARA GARANTIR REALISMO:
            - Em vez de "um guerreiro maia", escreva: "a real person dressed as a Mayan warrior, photographed on location, real skin texture with pores and natural imperfections, real fabric of the costume with visible texture and wrinkles, real feathers in the headdress with natural variations"
            - Em vez de "uma pirâmide antiga", escreva: "a real ancient Mayan pyramid photographed on location, real weathered stone with cracks and imperfections, real moss and vegetation growing on the stones, real shadows cast by the sun, real depth of field blur in the background"
            - Em vez de "luz mística", escreva: "real natural lighting from the sun, real shadows cast by real objects, real depth of field, real bokeh in the background, real camera lens flare if the sun is in frame"
            - SEMPRE mencione: "real", "actual", "photographed", "shot on location", "documentary style", "real-world", "actual photograph"
            
            TÉCNICAS DE THUMBNAIL VIRAL PARA O TEXTO (quando includePhrases = true) - DESIGN PROFISSIONAL COMO PHOTOSHOP - CTR ACIMA DE 25%:
            
            📝 DESCRIÇÃO OBRIGATÓRIA DO TEXTO - DEVE PARECER FEITO NO PHOTOSHOP POR UM DESIGNER PROFISSIONAL:
            O texto DEVE ser descrito como se fosse criado no Photoshop com técnicas profissionais de design gráfico:
            
            1. TIPOGRAFIA PROFISSIONAL:
               - "Professional typography, Photoshop-quality text design"
               - "Large, bold, professionally designed text occupying 25-35% of the image height"
               - "Massive, oversized typography with professional letter spacing and kerning"
               - "Thick, chunky, professionally rendered letters"
               - "Typography that looks like it was designed by a professional graphic designer"
               - "High-end text design, magazine-quality typography"
            
            2. CORES PROFISSIONAIS E EFEITOS DE CAMADA (Layer Effects do Photoshop):
               - "Bright yellow (#FFD700) text with professional Photoshop layer effects: thick black stroke (6-8px), white drop shadow with distance 8px, spread 5px, size 12px, opacity 80%, angle 135 degrees"
               - "Pure white text with professional red stroke (6px), black drop shadow with blur radius 10px, and subtle outer glow effect in yellow"
               - "Neon orange (#FF6600) text with black stroke (7px), professional drop shadow with multiple layers, and yellow outer glow with spread 8px"
               - "Electric blue (#00FFFF) text with white stroke (6px), black shadow with distance 10px, and professional bevel and emboss effect"
               - "Bright red (#FF0000) text with yellow stroke (5px), white drop shadow, and professional gradient overlay from yellow to orange"
               - "Lime green (#00FF00) text with black stroke (8px), white glow effect, and professional inner shadow"
               - IMPORTANTE: Descreva como efeitos de camada do Photoshop (layer effects), não apenas "outline" ou "shadow"
            
            3. FONTES PROFISSIONAIS:
               - "Professional bold sans-serif font (Impact, Bebas Neue, Montserrat Black, or similar premium font)"
               - "Thick, chunky, professionally designed block letters"
               - "Modern, high-end typography with perfect letter spacing"
               - "YouTube viral thumbnail professional font style"
               - "Bold, condensed font with professional kerning and tracking"
               - "Premium typography, no serifs, maximum readability, professional design"
               - "Typography that looks like it came from a professional design agency"
            
            4. EFEITOS PROFISSIONAIS DO PHOTOSHOP (Layer Styles):
               - "Professional Photoshop stroke effect: thick black outline (6-8px width), position: outside, blend mode: normal, opacity: 100%"
               - "Professional drop shadow: distance 10px, spread 5px, size 12px, angle 135°, opacity 80%, color black, blend mode: multiply"
               - "Professional outer glow effect: spread 8px, size 15px, opacity 75%, color matching text or contrasting"
               - "Professional bevel and emboss effect: style: emboss, technique: smooth, depth 100%, size 5px, softness 2px"
               - "Professional gradient overlay: linear gradient from bright color to darker shade, angle 90°, opacity 80%"
               - "Professional inner shadow: distance 3px, choke 0%, size 5px, opacity 60%"
               - "Professional color overlay: solid color with blend mode overlay or soft light, opacity 50%"
               - "Text appears to pop out from the image with professional 3D effect"
               - "Professional text rendering with anti-aliasing, crisp edges, perfect clarity"
            
            5. COMPOSIÇÃO PROFISSIONAL:
               - "Positioned at the top center of the image with professional alignment"
               - "Bottom third of the image with professional composition and high contrast background"
               - "Centered horizontally, upper third vertically, following rule of thirds"
               - "Strategically placed to not cover important visual elements, professional layout"
               - "Text area has professional semi-transparent dark background (black overlay with 40% opacity) for better readability"
               - "Professional text box or banner behind text with gradient or solid color, rounded corners optional"
            
            6. CONTRASTE E VISIBILIDADE PROFISSIONAL:
               - "High contrast against the background, professionally optimized"
               - "Text stands out dramatically from the image with professional design techniques"
               - "Eye-catching text overlay that immediately draws attention, professional composition"
               - "Text that pops from the image with maximum visibility, professional rendering"
               - "Text is the first thing the eye is drawn to, professional visual hierarchy"
               - "Background is professionally darkened (vignette effect) or lightened behind text for maximum contrast"
               - "Professional color grading applied to background to make text stand out"
            
            7. EXEMPLO COMPLETO DE DESCRIÇÃO PROFISSIONAL:
               "Professional Photoshop-quality text design: Large, bold, stylized text '[FRASE DE GANCHO AQUI]' in bright yellow (#FFD700) with professional layer effects: thick black stroke (7px width, position outside), white drop shadow (distance 10px, spread 5px, size 12px, opacity 80%, angle 135°), subtle outer glow in white (spread 6px, size 10px, opacity 70%), positioned at the top center of the image, occupying 30% of the image height, professional bold sans-serif font (Impact or Bebas Neue style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, high contrast viral thumbnail text style, eye-catching and attention-grabbing, text appears to pop out from the image with professional 3D effect, maximum visibility for high CTR, looks like it was designed by a professional graphic designer in Photoshop"
            
            8. REGRAS DE OURO PARA DESIGN PROFISSIONAL:
               - O texto DEVE parecer feito no Photoshop por um designer profissional
               - O texto DEVE ter múltiplos efeitos de camada (stroke, shadow, glow, bevel)
               - O texto DEVE ter valores específicos de efeitos (distância, spread, tamanho, opacidade)
               - O texto DEVE ter tipografia profissional com kerning e tracking perfeitos
               - O texto DEVE ter renderização profissional (anti-aliasing, crisp edges)
               - O texto DEVE ter composição profissional (regra dos terços, hierarquia visual)
               - O texto DEVE parecer de qualidade de agência de design, não amador

            RESPONDA APENAS COM UM OBJETO JSON VÁLIDO, com a seguinte estrutura:
            {
              "ideias": [
                {
                  "seoDescription": "Descrição completa e otimizada para o YouTube aqui...",
                  "seoTags": ["tag1", "tag2", "tag3", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"]' : language === 'Inglês' ? '["He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"]' : '["Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'A detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'A detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                },
                {
                  "seoDescription": "Outra descrição completa e otimizada...",
                  "seoTags": ["tagA", "tagB", "tagC", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"]' : language === 'Inglês' ? '["The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything", "Surprising Revelation"]' : '["La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'Another detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'Another detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                }
              ]
            }
        `;
        } else {
            // Prompt padrão baseado na fórmula do título e otimizado por modelo
            const formulaContext = formulaTitulo ? `\n            FÓRMULA DO TÍTULO VIRAL IDENTIFICADA: "${formulaTitulo}"\n            MOTIVO DO SUCESSO: "${motivoSucesso || 'Análise não disponível'}"\n            \n            IMPORTANTE: Use esta fórmula como base para criar thumbnails que complementem e reforcem o mesmo gatilho mental e estratégia que tornaram o título viral.` : '';
            
            // Contexto de performance do vídeo - usar mesma classificação viral
            const viewsPerDayThumb = videoDetails.views && videoDetails.days 
                ? Math.round(videoDetails.views / Math.max(videoDetails.days, 1))
                : 0;
            const isViralThumb = isViralVideo(videoDetails.views || 0, videoDetails.days || 0, viewsPerDayThumb);
            
            const videoPerformanceContext = isViralThumb
                ? (videoDetails.views && videoDetails.days 
                    ? `\n            🚀 CONTEXTO DO VÍDEO VIRAL:\n            Esta thumbnail VIRALIZOU junto com o vídeo que alcançou ${videoDetails.views.toLocaleString()} views em apenas ${videoDetails.days} dias (média de ${viewsPerDayThumb.toLocaleString()} views/dia). Esta thumbnail foi parte do sucesso viral e precisa ser adaptada para o seu subnicho mantendo o mesmo poder de viralização.`
                    : `\n            🚀 CONTEXTO DO VÍDEO VIRAL:\n            Esta thumbnail VIRALIZOU junto com o vídeo que alcançou ${videoDetails.views.toLocaleString()} views. Esta thumbnail foi parte do sucesso viral e precisa ser adaptada para o seu subnicho mantendo o mesmo poder de viralização.`)
                : (videoDetails.views && videoDetails.days 
                    ? `\n            🚀 CONTEXTO DO VÍDEO DE REFERÊNCIA:\n            Esta thumbnail pertence a um vídeo que alcançou ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias (média de ${viewsPerDayThumb.toLocaleString()} views/dia). Este vídeo NÃO viralizou, mas a thumbnail pode ser analisada e melhorada para criar versões com maior potencial viral.`
                    : `\n            🚀 CONTEXTO DO VÍDEO DE REFERÊNCIA:\n            Esta thumbnail pertence a um vídeo que alcançou ${videoDetails.views.toLocaleString()} views. Este vídeo NÃO viralizou, mas a thumbnail pode ser analisada e melhorada para criar versões com maior potencial viral.`);
            
            // Prompts otimizados por modelo
            if (service === 'gemini') {
                thumbPrompt = `
            Você é um ESPECIALISTA EM THUMBNAILS VIRAIS NO YOUTUBE, combinando as habilidades de um diretor de arte profissional e um estrategista de viralização com experiência em criar thumbnails que geram MILHÕES DE VIEWS e ALTO CTR (acima de 25%).
            
            ⚠️⚠️⚠️ ATENÇÃO CRÍTICA - IDIOMA DAS FRASES DE GANCHO ⚠️⚠️⚠️
            O idioma selecionado é: "${language}"
            Se "${language}" for "Português", TODAS as frases de gancho DEVEM estar em PORTUGUÊS.
            Se "${language}" for "Inglês", TODAS as frases de gancho DEVEM estar em INGLÊS.
            Se "${language}" for "Espanhol", TODAS as frases de gancho DEVEM estar em ESPANHOL.
            NUNCA, JAMAIS retorne frases em inglês se o idioma for português ou espanhol.
            NUNCA, JAMAIS retorne frases em português se o idioma for inglês ou espanhol.
            NUNCA, JAMAIS retorne frases em espanhol se o idioma for português ou inglês.
            ANTES DE RETORNAR O JSON, VERIFIQUE SE TODAS AS 5 FRASES ESTÃO NO IDIOMA CORRETO "${language}".${formulaContext}${videoPerformanceContext}

            🎯 PROMPT DE ANÁLISE DE THUMBS (DIRETO DO VÍDEO VIRAL):
            Este vídeo ${isViralThumb ? 'COM ESTA THUMBNAIL VIRALIZOU' : 'DE REFERÊNCIA tem esta thumbnail'}, com o título: "${videoDetails.title}"
            
            OBJETIVO: Criar thumbnails que gerem MILHÕES DE VIEWS e ALTO CTR (acima de 25%) para canais milionários.
            
            Quero que você me dê uma ADAPTAÇÃO para meu SUBNICHO de "${subniche}" com o título: "${selectedTitle}"
            
            REGRAS CRÍTICAS:
            - Mantenha o PODER VIRAL da thumbnail original que gerou milhões de views
            - Adapte para o meu subnicho e título, mas SEMPRE mantenha a capacidade de gerar alto CTR e milhões de views
            - Analise PROFUNDAMENTE o que tornou a thumbnail original viral (composição, cores, elementos visuais, expressões, texto, contraste, psicologia visual)
            - Identifique os ELEMENTOS VIRAIS COMPROVADOS que funcionaram e mantenha-os na adaptação
            - Melhore o que for possível (cores mais vibrantes, contraste maior, composição mais impactante, iluminação mais dramática)
            - Crie thumbnails que TENHAM POTENCIAL PARA VIRALIZAR e gerar milhões de views como a original

            IMAGEM DE REFERÊNCIA: [A imagem da thumbnail original do vídeo VIRAL está anexada - analise cuidadosamente o que tornou esta thumbnail viral e gerou milhões de views]${formulaContext}

            IMAGEM DE REFERÊNCIA: [A imagem da thumbnail original do vídeo está anexada]
            TÍTULO DO VÍDEO (para contexto): "${selectedTitle}"
            SUBNICHO (Público-Alvo): "${subniche}"
            ESTILO DE ARTE DESEJADO: "${style}"
            IDIOMA DO CONTEÚDO: "${language}"

            ⚠️ ATENÇÃO CRÍTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, não ilustrações, desenhos ou renderizações. A descriçãoThumbnail deve descrever uma FOTO REAL tirada por um fotógrafo profissional em um local real, com pessoas reais e objetos reais.
            
            ${(() => {
                const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
                if (ruleData.mode === 'auto') {
                    return `\n            🔍 MODO AUTOMÁTICO - ANÁLISE DE REGRA:\n            Analise o título "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPLÍCITA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.\n\n            📋 AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE (ALGORITMO OFICIAL):\n\n            1️⃣ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO):\n            O cérebro precisa entender a thumbnail em menos de 1 segundo. Se houver confusão, o clique cai.\n            Checklist OBRIGATÓRIO: 1 ideia principal, 1 personagem, 1 emoção, 1 objeto-chave.\n            A thumbnail DEVE ser compreendida instantaneamente. Elimine qualquer elemento que cause confusão ou distração.\n\n            2️⃣ REGRA DO ASSUNTO ÚNICO:\n            Nada divide a atenção. A thumbnail boa é sempre uma história em uma imagem.\n            Foque em UM ÚNICO assunto dominante. Nada deve competir pela atenção. A thumbnail deve contar uma história completa em uma única imagem, sem elementos que dividam o foco.\n\n            3️⃣ REGRA DO ROSTO GRANDE:\n            Rostos com forte expressão emocional aumentam CTR de 20% a 60%.\n            Expressões mais fortes: choque, surpresa, medo, raiva, felicidade extrema.\n            Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A expressão facial DEVE ser EXTREMA e EMOCIONAL. O rosto deve ser o elemento dominante e a primeira coisa que o olho vê.\n\n            4️⃣ REGRA DO CONTRASTE BRUTAL:\n            Se não tiver contraste, a thumbnail fica invisível.\n            Use CONTRASTE BRUTAL entre: texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n            O contraste deve ser tão forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.\n\n            5️⃣ REGRA DA COR ESTRATÉGICA:\n            Cada cor ativa um gatilho:\n            - Amarelo: atenção imediata\n            - Vermelho: urgência / perigo\n            - Azul: confiança\n            - Verde: dinheiro / solução\n            - Preto: premium / mistério\n            Escolha a cor baseada na emoção que o título transmite.\n\n            6️⃣ REGRA DOS TERÇOS:\n            Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso dá harmonia e aumenta o foco natural.\n            Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos terços (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.\n\n            7️⃣ REGRA DO TEXTO ULTRA CURTO:\n            Texto deve ter 2 a 4 palavras, nunca mais.\n            Exemplos: "Ele mentiu", "Descobri isso", "Ninguém viu", "Proibido".\n            O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Textos longos matam o CTR. Seja brutalmente direto e impactante.\n\n            8️⃣ REGRA DO ZOOM EMOCIONAL:\n            Aparece sempre um elemento gigante que amplifica a emoção ou o conflito.\n            Exemplos: uma conta bancária gigante, uma faca gigante, uma lupa gigante, um número gigante.\n            Use um elemento GIGANTE que amplifique a emoção ou conflito. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.\n\n            9️⃣ REGRA DO MISTÉRIO:\n            Toda thumbnail viral tem uma pergunta implícita.\n            Exemplos: algo escondido atrás de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela.\n            Crie uma pergunta implícita na thumbnail. O espectador DEVE sentir curiosidade sobre o que está fora da imagem.\n\n            🔟 REGRA DOS PONTOS DE FUGA:\n            Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.\n            Sinalizações: setas, linhas diagonais, perspectiva.\n            Use linhas visuais que guiem o olhar para o foco. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal.\n\n            1️⃣1️⃣ REGRA DO ESPAÇO NEGATIVO:\n            Deixar áreas vazias acentua o foco. Sem isso, a imagem vira bagunça.\n            Deixe áreas vazias (espaço negativo) que acentuem o foco no elemento principal. O espaço vazio cria respiração visual e faz o elemento principal "pular" da imagem.\n\n            1️⃣2️⃣ REGRA DA COERÊNCIA COM O TÍTULO:\n            Thumbnail e título precisam contar a mesma história, mas com ângulos diferentes.\n            Título = contexto, Thumbnail = emoção.\n            A thumbnail e o título DEVEM contar a mesma história, mas com ângulos diferentes. A thumbnail deve amplificar a emoção que o título promete, criando uma sinergia perfeita.\n\n            ⚠️ CRÍTICO: Identifique qual regra melhor se encaixa no título "${selectedTitle}" e aplique-a de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.`;
                } else {
                    return `\n            📋 REGRA SELECIONADA: ${ruleData.rule.name}\n            ${ruleData.rule.description}\n\n            ${ruleData.rule.checklist ? `✅ Checklist: ${ruleData.rule.checklist.join(', ')}` : ''}\n            ${ruleData.rule.expressions ? `😮 Expressões recomendadas: ${ruleData.rule.expressions.join(', ')}` : ''}\n            ${ruleData.rule.contrasts ? `🎨 Contrastes: ${ruleData.rule.contrasts.join(', ')}` : ''}\n            ${ruleData.rule.colors ? `🌈 Cores estratégicas: ${Object.entries(ruleData.rule.colors).map(([k, v]) => `${k} (${v})`).join(', ')}` : ''}\n            ${ruleData.rule.examples ? `💡 Exemplos: ${ruleData.rule.examples.join(', ')}` : ''}\n            ${ruleData.rule.elements ? `➡️ Elementos: ${ruleData.rule.elements.join(', ')}` : ''}\n\n            ⚠️ CRÍTICO: Aplique esta regra de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail:\n            ${ruleData.instructions}`;
                }
            })()}
            
            🎯 OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando técnicas de Thumbnail Designer profissional:
            - TEXTO PROFISSIONAL (COMO PHOTOSHOP): O texto DEVE parecer feito no Photoshop por um designer profissional. Use múltiplos efeitos de camada (stroke, drop shadow com valores específicos, outer glow, bevel and emboss), tipografia profissional com kerning perfeito, renderização profissional com anti-aliasing. Grande, estilizado, cores vibrantes (amarelo/vermelho/branco com outline preto), efeitos visuais profissionais com valores específicos (distância, spread, tamanho, opacidade, ângulo), posicionamento estratégico (topo/centro), ocupando 25-35% da imagem. O texto DEVE ter qualidade de agência de design, não amador.
            - COMPOSIÇÃO: Regra dos terços, hierarquia visual clara, elemento principal em destaque
            - CORES: Alto contraste, cores complementares, saturação otimizada, fundo que faz o texto "pular"
            - EMOÇÃO: Expressões faciais intensas, momentos de tensão, curiosidade visual
            - ELEMENTOS VIRAIS: FOMO (medo de perder), surpresa, contraste dramático, storytelling visual
            
            SUA TAREFA (OTIMIZADA PARA VIRALIZAÇÃO - GEMINI):
            Analise a thumbnail VIRAL de referência e crie DUAS (2) adaptações que mantenham o PODER VIRAL original, mas adaptadas para o subnicho "${subniche}" e o título "${selectedTitle}".
            
            - **IDEIA 1 (RÉPLICA APRIMORADA DA ORIGINAL):** 
              * Copie a mesma estrutura da thumbnail de referência (ângulo da câmera, pose dos personagens, direção do olhar, escala dos elementos, posição do texto).
              * Mantenha a paleta de cores, quantidade de texto, ícones, props e o storytelling visual original.
              * Apenas eleve a execução: mais nitidez, contraste calibrado, recorte perfeito, tratamento de pele profissional, brilho nos olhos, texto com efeitos Photoshop refinados (stroke, drop shadow com valores específicos, outer glow, bevel & emboss).
              * Pequenos ajustes permitidos: limpar ruído visual, alinhar melhor elementos, reforçar a narrativa com micro detalhes, mas sem alterar a ideia central.
              * Resultado deve parecer uma versão “directors cut” da mesma thumbnail – quase idêntica, porém mais moderna e com sensação premium.
            
            - **IDEIA 2 (TURBO CTR INOVADOR):** 
              * Desapegue da composição original e proponha um conceito totalmente novo voltado para CTR 30%+.
              * Use novos enquadramentos, close dramático ou cena cinematográfica inédita que amplifique o gancho do título "${selectedTitle}".
              * Aplique gatilhos agressivos de curiosidade e FOMO (expressões extremas, contraste brutal, elementos inesperados).
              * Redesenhe texto, cores, objetos e iluminação para maximizar leitura instantânea em telas pequenas.
              * Traga um storytelling visual diferente (antes/depois, contagem regressiva, perigo iminente, segredo revelado etc.) que não existe na thumb original.
              * LEMBRE-SE: Deve ser descrito como uma FOTO REAL, e o texto precisa parecer produzido no Photoshop por um designer profissional com múltiplos efeitos de camada e valores específicos.

            PARA CADA UMA DAS 2 IDEIAS, GERE:
            1.  **"seoDescription"**: Uma descrição de vídeo para o YouTube, EXTREMAMENTE OTIMIZADA PARA SEO E VIRALIZAÇÃO, com:
               - Emojis estratégicos e relevantes (use emojis que representem o nicho e subnicho)
               - Parágrafos bem estruturados com quebras de linha
               - Chamadas para ação (CTA) claras e persuasivas
               - Uso estratégico de palavras-chave relevantes para o título "${selectedTitle}" e subnicho "${subniche}"
               - Formatação profissional com separadores visuais (━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━)
               - Seções organizadas: introdução, conteúdo do vídeo, sobre o canal, links importantes, hashtags
               - Linguagem persuasiva e envolvente que gere curiosidade e urgência
               - A descrição deve estar no idioma "${language}" e ter entre 300-500 palavras
               - IMPORTANTE: Use emojis de forma estratégica (não exagere, mas use para destacar seções importantes)
               - Inclua hashtags relevantes no final
               - Seja específico sobre o que o espectador vai aprender/ganhar
               
            2.  **"seoTags"**: Um array de strings com as 15-25 tags MAIS RELEVANTES E ESTRATÉGICAS para o vídeo (LIMITE MÁXIMO: 300 caracteres no total, incluindo vírgulas e espaços. NÃO ultrapasse 300 caracteres), incluindo:
               - Tags de cauda curta (1-2 palavras): termos populares e competitivos relacionados ao título "${selectedTitle}" e subnicho "${subniche}"
               - Tags de cauda longa (3-5 palavras): termos mais específicos e menos competitivos que capturam intenção de busca
               - Tags de nicho: termos específicos do subnicho "${subniche}"
               - Tags de tendência: termos que estão em alta no momento relacionados ao tema
               - Tags de formato: termos como "tutorial", "dicas", "como fazer", "guia completo", "passo a passo", etc.
               - Tags de plataforma: termos relacionados à plataforma (YouTube, TikTok, Instagram, etc.)
               - Tags de emoção: termos que capturam a emoção do título (ex: "surpresa", "revelação", "mistério", "urgência", "choque")
               - Tags de benefício: termos que descrevem o que o espectador vai ganhar/aprender
               - Tags de palavra-chave principal: extrair as palavras-chave mais importantes do título "${selectedTitle}"
               - Tags de sinônimos: variações e sinônimos das palavras-chave principais
               - IMPORTANTE: As tags devem ser EXTREMAMENTE RELEVANTES ao título "${selectedTitle}" e ao subnicho "${subniche}"
               - Evite tags genéricas que não agregam valor
               - Priorize tags que tenham volume de busca mas não sejam extremamente competitivas
               - Misture tags em português/inglês/espanhol conforme o idioma "${language}"
               - LIMITE MÁXIMO: 300 caracteres no total (incluindo vírgulas e espaços). NÃO ultrapasse 300 caracteres.
               - Cada tag deve ter entre 1-5 palavras, sendo a maioria com 2-3 palavras para otimizar o uso do espaço
               - Priorize tags mais relevantes e estratégicas. Se necessário, reduza a quantidade de tags para não ultrapassar 300 caracteres.
            3.  **"frasesDeGancho"**: Um array com 5 frases CURTAS de impacto (ganchos) para a thumbnail, OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne um array vazio [].' : `
                ⚠️⚠️⚠️ CRÍTICO E OBRIGATÓRIO - IDIOMA DAS FRASES DE GANCHO ⚠️⚠️⚠️
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Português' ? `
                ✅ CORRETO (Português): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : language === 'Inglês' ? `
                ✅ CORRETO (Inglês): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : `
                ✅ CORRETO (Espanhol): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante", "La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGATÓRIAS:
                1. Se "${language}" for "Português", TODAS as 5 frases DEVEM estar em PORTUGUÊS (Brasil)
                2. Se "${language}" for "Inglês", TODAS as 5 frases DEVEM estar em INGLÊS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em inglês se o idioma escolhido for português ou espanhol
                5. NUNCA, JAMAIS retorne frases em português se o idioma escolhido for inglês ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for português ou inglês
                7. Cada frase deve ter 2 a 4 palavras, no máximo
                8. As frases devem ser impactantes e relacionadas ao título "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases estão no idioma "${language}"?
                - Nenhuma frase está em inglês se "${language}" for português ou espanhol?
                - Nenhuma frase está em português se "${language}" for inglês ou espanhol?
                - Nenhuma frase está em espanhol se "${language}" for português ou inglês?
                
                Se alguma resposta for NÃO, CORRIJA as frases antes de retornar o JSON.
                `}
            4.  **"descricaoThumbnail"**: Um prompt EXTREMAMENTE DETALHADO e VÍVIDO, em INGLÊS, para uma IA de geração de imagem. ${!includePhrases ? 'NÃO inclua nenhum placeholder para texto. A thumbnail deve ser APENAS imagem, sem texto ou frases de gancho. Descreva apenas elementos visuais, composição, cores, iluminação, etc.' : 'A descrição DEVE incluir um placeholder claro, como "[FRASE DE GANCHO AQUI]", onde o texto da thumbnail deve ser inserido.'}
            
            CRÍTICO PARA A "descricaoThumbnail" - DEVE SER FOTOGRAFIA REAL ULTRA HD 8K, NÃO ILUSTRAÇÃO:
            - OBRIGATÓRIO: A descrição DEVE começar EXATAMENTE com: "Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, real lighting, real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, 8K resolution, extreme sharpness, maximum detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography quality"
            
            - ENFATIZE REPETIDAMENTE E OBRIGATORIAMENTE: "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail", "every pore visible", "every texture crisp", "perfect focus", "ultra sharp", "no blur except intentional depth of field", "no artifacts", "no compression", "no pixelation", "perfect clarity", "real photograph", "shot on location", "documentary photography", "realistic textures with imperfections", "natural lighting with real shadows", "real depth of field", "real bokeh effects", "professional color grading", "high dynamic range (HDR)", "sharp focus on subject", "real camera grain", "real-world photography", "actual photograph", "photographed in real life", "real person", "real object", "real environment", "National Geographic quality", "BBC documentary style", "professional photography", "photorealistic", "hyper-realistic"
            
            - NUNCA, JAMAIS use estes termos: "illustration", "drawing", "artwork", "digital art", "render", "3D render", "CGI", "cartoon", "anime", "sketch", "painting", "stylized", "artistic", "concept art", "digital painting", "graphic design", "vector", "comic", "fantasy art", "artistic interpretation", "stylized", "artistic style", "digital illustration"
            
            - SEMPRE use APENAS estes termos: "photograph", "photo", "photography", "shot", "captured", "documentary photo", "realistic capture", "professional photography", "real-world photography", "actual photograph", "photographed", "real-life photography", "on-location photography", "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail"
            
            - IMPORTANTE: Descreva como se fosse uma FOTO REAL ULTRA HD 8K tirada por um fotógrafo profissional. Mencione detalhes realistas como: "real skin texture with pores and natural imperfections visible in 8K detail", "real fabric texture with visible fibers and weave patterns in ultra HD", "real stone texture with weathering, cracks, and imperfections visible in perfect 8K clarity", "real shadows cast by real light sources with perfect sharpness", "real depth of field blur with perfect bokeh", "real camera lens distortion", "real chromatic aberration", "real lens flare", "real motion blur if applicable", "every detail visible in 8K resolution", "extreme sharpness and clarity", "no compression artifacts", "perfect focus on subject"

            REGRAS IMPORTANTES:
            - A "descricaoThumbnail" é OBRIGATORIAMENTE em INGLÊS.
            - "seoDescription", "seoTags" e "frasesDeGancho" são OBRIGATORIAMENTE no idioma "${language}".
            ${!includePhrases ? '- IMPORTANTE: A "descricaoThumbnail" NÃO deve mencionar texto, palavras ou frases. Apenas descreva elementos visuais, composição, cores, iluminação, etc.' : ''}
            - Seja extremamente específico e detalhado nas descrições visuais. Use termos técnicos de fotografia profissional, cinematografia e psicologia visual quando apropriado.
            - Foque em elementos que maximizem CTR: expressões faciais intensas, momentos de tensão, curiosidade visual, contraste dramático, composição impactante.
            
            EXEMPLOS DE COMO DESCREVER PARA GARANTIR REALISMO:
            - Em vez de "um guerreiro maia", escreva: "a real person dressed as a Mayan warrior, photographed on location, real skin texture with pores and natural imperfections, real fabric of the costume with visible texture and wrinkles, real feathers in the headdress with natural variations"
            - Em vez de "uma pirâmide antiga", escreva: "a real ancient Mayan pyramid photographed on location, real weathered stone with cracks and imperfections, real moss and vegetation growing on the stones, real shadows cast by the sun, real depth of field blur in the background"
            - Em vez de "luz mística", escreva: "real natural lighting from the sun, real shadows cast by real objects, real depth of field, real bokeh in the background, real camera lens flare if the sun is in frame"
            - SEMPRE mencione: "real", "actual", "photographed", "shot on location", "documentary style", "real-world", "actual photograph"
            
            TÉCNICAS DE THUMBNAIL VIRAL PARA O TEXTO (quando includePhrases = true) - DESIGN PROFISSIONAL COMO PHOTOSHOP - CTR ACIMA DE 25%:
            
            📝 DESCRIÇÃO OBRIGATÓRIA DO TEXTO - DEVE PARECER FEITO NO PHOTOSHOP POR UM DESIGNER PROFISSIONAL:
            O texto DEVE ser descrito como se fosse criado no Photoshop com técnicas profissionais de design gráfico:
            
            1. TIPOGRAFIA PROFISSIONAL:
               - "Professional typography, Photoshop-quality text design"
               - "Large, bold, professionally designed text occupying 25-35% of the image height"
               - "Massive, oversized typography with professional letter spacing and kerning"
               - "Thick, chunky, professionally rendered letters"
               - "Typography that looks like it was designed by a professional graphic designer"
               - "High-end text design, magazine-quality typography"
            
            2. CORES PROFISSIONAIS E EFEITOS DE CAMADA (Layer Effects do Photoshop):
               - "Bright yellow (#FFD700) text with professional Photoshop layer effects: thick black stroke (6-8px), white drop shadow with distance 8px, spread 5px, size 12px, opacity 80%, angle 135 degrees"
               - "Pure white text with professional red stroke (6px), black drop shadow with blur radius 10px, and subtle outer glow effect in yellow"
               - "Neon orange (#FF6600) text with black stroke (7px), professional drop shadow with multiple layers, and yellow outer glow with spread 8px"
               - "Electric blue (#00FFFF) text with white stroke (6px), black shadow with distance 10px, and professional bevel and emboss effect"
               - "Bright red (#FF0000) text with yellow stroke (5px), white drop shadow, and professional gradient overlay from yellow to orange"
               - "Lime green (#00FF00) text with black stroke (8px), white glow effect, and professional inner shadow"
               - IMPORTANTE: Descreva como efeitos de camada do Photoshop (layer effects), não apenas "outline" ou "shadow"
            
            3. FONTES PROFISSIONAIS:
               - "Professional bold sans-serif font (Impact, Bebas Neue, Montserrat Black, or similar premium font)"
               - "Thick, chunky, professionally designed block letters"
               - "Modern, high-end typography with perfect letter spacing"
               - "YouTube viral thumbnail professional font style"
               - "Bold, condensed font with professional kerning and tracking"
               - "Premium typography, no serifs, maximum readability, professional design"
               - "Typography that looks like it came from a professional design agency"
            
            4. EFEITOS PROFISSIONAIS DO PHOTOSHOP (Layer Styles):
               - "Professional Photoshop stroke effect: thick black outline (6-8px width), position: outside, blend mode: normal, opacity: 100%"
               - "Professional drop shadow: distance 10px, spread 5px, size 12px, angle 135°, opacity 80%, color black, blend mode: multiply"
               - "Professional outer glow effect: spread 8px, size 15px, opacity 75%, color matching text or contrasting"
               - "Professional bevel and emboss effect: style: emboss, technique: smooth, depth 100%, size 5px, softness 2px"
               - "Professional gradient overlay: linear gradient from bright color to darker shade, angle 90°, opacity 80%"
               - "Professional inner shadow: distance 3px, choke 0%, size 5px, opacity 60%"
               - "Professional color overlay: solid color with blend mode overlay or soft light, opacity 50%"
               - "Text appears to pop out from the image with professional 3D effect"
               - "Professional text rendering with anti-aliasing, crisp edges, perfect clarity"
            
            5. COMPOSIÇÃO PROFISSIONAL:
               - "Positioned at the top center of the image with professional alignment"
               - "Bottom third of the image with professional composition and high contrast background"
               - "Centered horizontally, upper third vertically, following rule of thirds"
               - "Strategically placed to not cover important visual elements, professional layout"
               - "Text area has professional semi-transparent dark background (black overlay with 40% opacity) for better readability"
               - "Professional text box or banner behind text with gradient or solid color, rounded corners optional"
            
            6. CONTRASTE E VISIBILIDADE PROFISSIONAL:
               - "High contrast against the background, professionally optimized"
               - "Text stands out dramatically from the image with professional design techniques"
               - "Eye-catching text overlay that immediately draws attention, professional composition"
               - "Text that pops from the image with maximum visibility, professional rendering"
               - "Text is the first thing the eye is drawn to, professional visual hierarchy"
               - "Background is professionally darkened (vignette effect) or lightened behind text for maximum contrast"
               - "Professional color grading applied to background to make text stand out"
            
            7. EXEMPLO COMPLETO DE DESCRIÇÃO PROFISSIONAL:
               "Professional Photoshop-quality text design: Large, bold, stylized text '[FRASE DE GANCHO AQUI]' in bright yellow (#FFD700) with professional layer effects: thick black stroke (7px width, position outside), white drop shadow (distance 10px, spread 5px, size 12px, opacity 80%, angle 135°), subtle outer glow in white (spread 6px, size 10px, opacity 70%), positioned at the top center of the image, occupying 30% of the image height, professional bold sans-serif font (Impact or Bebas Neue style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, high contrast viral thumbnail text style, eye-catching and attention-grabbing, text appears to pop out from the image with professional 3D effect, maximum visibility for high CTR, looks like it was designed by a professional graphic designer in Photoshop"
            
            8. REGRAS DE OURO PARA DESIGN PROFISSIONAL:
               - O texto DEVE parecer feito no Photoshop por um designer profissional
               - O texto DEVE ter múltiplos efeitos de camada (stroke, shadow, glow, bevel)
               - O texto DEVE ter valores específicos de efeitos (distância, spread, tamanho, opacidade)
               - O texto DEVE ter tipografia profissional com kerning e tracking perfeitos
               - O texto DEVE ter renderização profissional (anti-aliasing, crisp edges)
               - O texto DEVE ter composição profissional (regra dos terços, hierarquia visual)
               - O texto DEVE parecer de qualidade de agência de design, não amador

            RESPONDA APENAS COM UM OBJETO JSON VÁLIDO, com a seguinte estrutura:
            {
              "ideias": [
                {
                  "seoDescription": "Descrição completa e otimizada para o YouTube aqui...",
                  "seoTags": ["tag1", "tag2", "tag3", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"]' : language === 'Inglês' ? '["He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"]' : '["Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'A detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'A detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                },
                {
                  "seoDescription": "Outra descrição completa e otimizada...",
                  "seoTags": ["tagA", "tagB", "tagC", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"]' : language === 'Inglês' ? '["The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything", "Surprising Revelation"]' : '["La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'Another detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'Another detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                }
              ]
            }
        `;
            } else { // OpenAI
                thumbPrompt = `
            Você é um especialista em YouTube, combinando as habilidades de um diretor de arte para thumbnails e um mestre de SEO.${formulaContext}

            IMAGEM DE REFERÊNCIA: [A imagem da thumbnail original do vídeo está anexada]
            TÍTULO DO VÍDEO (para contexto): "${selectedTitle}"
            SUBNICHE (Público-Alvo): "${subniche}"
            ESTILO DE ARTE DESEJADO: "${style}"
            IDIOMA DO CONTEÚDO: "${language}"

            ⚠️ ATENÇÃO CRÍTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, não ilustrações, desenhos ou renderizações. A descriçãoThumbnail deve descrever uma FOTO REAL tirada por um fotógrafo profissional em um local real, com pessoas reais e objetos reais.
            
            ${(() => {
                const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
                if (ruleData.mode === 'auto') {
                    return `\n            🔍 MODO AUTOMÁTICO - ANÁLISE DE REGRA:\n            Analise o título "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPLÍCITA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.\n\n            📋 AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE (ALGORITMO OFICIAL):\n\n            1️⃣ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO):\n            O cérebro precisa entender a thumbnail em menos de 1 segundo. Se houver confusão, o clique cai.\n            Checklist OBRIGATÓRIO: 1 ideia principal, 1 personagem, 1 emoção, 1 objeto-chave.\n            A thumbnail DEVE ser compreendida instantaneamente. Elimine qualquer elemento que cause confusão ou distração.\n\n            2️⃣ REGRA DO ASSUNTO ÚNICO:\n            Nada divide a atenção. A thumbnail boa é sempre uma história em uma imagem.\n            Foque em UM ÚNICO assunto dominante. Nada deve competir pela atenção. A thumbnail deve contar uma história completa em uma única imagem, sem elementos que dividam o foco.\n\n            3️⃣ REGRA DO ROSTO GRANDE:\n            Rostos com forte expressão emocional aumentam CTR de 20% a 60%.\n            Expressões mais fortes: choque, surpresa, medo, raiva, felicidade extrema.\n            Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A expressão facial DEVE ser EXTREMA e EMOCIONAL. O rosto deve ser o elemento dominante e a primeira coisa que o olho vê.\n\n            4️⃣ REGRA DO CONTRASTE BRUTAL:\n            Se não tiver contraste, a thumbnail fica invisível.\n            Use CONTRASTE BRUTAL entre: texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n            O contraste deve ser tão forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.\n\n            5️⃣ REGRA DA COR ESTRATÉGICA:\n            Cada cor ativa um gatilho:\n            - Amarelo: atenção imediata\n            - Vermelho: urgência / perigo\n            - Azul: confiança\n            - Verde: dinheiro / solução\n            - Preto: premium / mistério\n            Escolha a cor baseada na emoção que o título transmite.\n\n            6️⃣ REGRA DOS TERÇOS:\n            Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso dá harmonia e aumenta o foco natural.\n            Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos terços (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.\n\n            7️⃣ REGRA DO TEXTO ULTRA CURTO:\n            Texto deve ter 2 a 4 palavras, nunca mais.\n            Exemplos: "Ele mentiu", "Descobri isso", "Ninguém viu", "Proibido".\n            O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Textos longos matam o CTR. Seja brutalmente direto e impactante.\n\n            8️⃣ REGRA DO ZOOM EMOCIONAL:\n            Aparece sempre um elemento gigante que amplifica a emoção ou o conflito.\n            Exemplos: uma conta bancária gigante, uma faca gigante, uma lupa gigante, um número gigante.\n            Use um elemento GIGANTE que amplifique a emoção ou conflito. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.\n\n            9️⃣ REGRA DO MISTÉRIO:\n            Toda thumbnail viral tem uma pergunta implícita.\n            Exemplos: algo escondido atrás de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela.\n            Crie uma pergunta implícita na thumbnail. O espectador DEVE sentir curiosidade sobre o que está fora da imagem.\n\n            🔟 REGRA DOS PONTOS DE FUGA:\n            Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.\n            Sinalizações: setas, linhas diagonais, perspectiva.\n            Use linhas visuais que guiem o olhar para o foco. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal.\n\n            1️⃣1️⃣ REGRA DO ESPAÇO NEGATIVO:\n            Deixar áreas vazias acentua o foco. Sem isso, a imagem vira bagunça.\n            Deixe áreas vazias (espaço negativo) que acentuem o foco no elemento principal. O espaço vazio cria respiração visual e faz o elemento principal "pular" da imagem.\n\n            1️⃣2️⃣ REGRA DA COERÊNCIA COM O TÍTULO:\n            Thumbnail e título precisam contar a mesma história, mas com ângulos diferentes.\n            Título = contexto, Thumbnail = emoção.\n            A thumbnail e o título DEVEM contar a mesma história, mas com ângulos diferentes. A thumbnail deve amplificar a emoção que o título promete, criando uma sinergia perfeita.\n\n            ⚠️ CRÍTICO: Identifique qual regra melhor se encaixa no título "${selectedTitle}" e aplique-a de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail. Se múltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.`;
                } else {
                    return `\n            📋 REGRA SELECIONADA: ${ruleData.rule.name}\n            ${ruleData.rule.description}\n\n            ${ruleData.rule.checklist ? `✅ Checklist: ${ruleData.rule.checklist.join(', ')}` : ''}\n            ${ruleData.rule.expressions ? `😮 Expressões recomendadas: ${ruleData.rule.expressions.join(', ')}` : ''}\n            ${ruleData.rule.contrasts ? `🎨 Contrastes: ${ruleData.rule.contrasts.join(', ')}` : ''}\n            ${ruleData.rule.colors ? `🌈 Cores estratégicas: ${Object.entries(ruleData.rule.colors).map(([k, v]) => `${k} (${v})`).join(', ')}` : ''}\n            ${ruleData.rule.examples ? `💡 Exemplos: ${ruleData.rule.examples.join(', ')}` : ''}\n            ${ruleData.rule.elements ? `➡️ Elementos: ${ruleData.rule.elements.join(', ')}` : ''}\n\n            ⚠️ CRÍTICO: Aplique esta regra de forma EXPLÍCITA e RIGOROSA na descrição da thumbnail:\n            ${ruleData.instructions}`;
                }
            })()}
            
            🎯 OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando técnicas de Thumbnail Designer profissional:
            - TEXTO PROFISSIONAL (COMO PHOTOSHOP): O texto DEVE parecer feito no Photoshop por um designer profissional. Use múltiplos efeitos de camada (stroke, drop shadow com valores específicos, outer glow, bevel and emboss), tipografia profissional com kerning perfeito, renderização profissional com anti-aliasing. Grande, estilizado, cores vibrantes (amarelo/vermelho/branco com outline preto), efeitos visuais profissionais com valores específicos (distância, spread, tamanho, opacidade, ângulo), posicionamento estratégico (topo/centro), ocupando 25-35% da imagem. O texto DEVE ter qualidade de agência de design, não amador.
            - COMPOSIÇÃO: Regra dos terços, hierarquia visual clara, elemento principal em destaque
            - CORES: Alto contraste, cores complementares, saturação otimizada, fundo que faz o texto "pular"
            - EMOÇÃO: Expressões faciais intensas, momentos de tensão, curiosidade visual
            - ELEMENTOS VIRAIS: FOMO (medo de perder), surpresa, contraste dramático, storytelling visual
            
            SUA TAREFA (OTIMIZADA PARA VIRALIZAÇÃO - GPT):
            Analise a thumbnail VIRAL de referência (IMAGEM DE REFERÊNCIA anexada) e crie DUAS (2) adaptações que mantenham o PODER VIRAL original, mas adaptadas para o subnicho "${subniche}" e o título "${selectedTitle}".
            
            ⚠️⚠️⚠️ CRÍTICO - ORDEM DAS IDEIAS ⚠️⚠️⚠️
            - **IDEIA 1 (RÉPLICA E MELHORIA DA THUMBNAIL ORIGINAL DO VÍDEO):** 
              * OBRIGATÓRIO: Esta ideia DEVE replicar e melhorar a thumbnail ORIGINAL do vídeo ao qual foram feitos os títulos.
              * Analise cuidadosamente a IMAGEM DE REFERÊNCIA (thumbnail original do vídeo) que está anexada.
              * Replique a estrutura da thumbnail de referência quase 1:1: mantenha EXATAMENTE ângulo de câmera, enquadramento, posição dos personagens/objetos, quantidade e posição do texto, paleta de cores e elementos de cenário.
              * PRESERVE exatamente o storytelling visual da thumbnail original que gerou milhões de views, apenas elevando a qualidade (recortes perfeitos, tratamento de pele profissional, brilho nos olhos, textura realista, correção de cor cinematográfica).
              * Ajustes permitidos: aumentar nitidez (8K), reforçar contraste, limpar ruídos, adicionar luzes/sombras profissionais e aplicar efeitos de texto Photoshop com valores específicos (stroke, drop shadow, outer glow, bevel & emboss).
              * Resultado: praticamente igual à thumb original, mas com sensação de upgrade premium e leitura instantânea mais clara e clicável.
              * IMPORTANTE: Se a thumbnail original não estiver disponível ou não puder ser analisada, ainda assim mantenha o mesmo conceito visual e estrutura, apenas melhorando a qualidade.
            
            - **IDEIA 2 (THUMBNAIL MELHORADA E OTIMIZADA):** 
              * Esta é uma versão COMPLETAMENTE NOVA, melhorada e otimizada para CTR alto (30%+).
              * Crie um conceito totalmente novo com foco em CTR máximo: novo enquadramento, nova composição, novos elementos que gerem curiosidade extrema.
              * Use gatilhos agressivos (perigo, segredo revelado, números gigantes, setas, antes/depois, close dramático) e cores super contrastantes.
              * Construa um storytelling diferente, alinhado ao título "${selectedTitle}", que prometa algo ainda mais irresistível que a versão original.
              * O texto deve ser redesenhado para máxima legibilidade mobile, com layer styles profissionais e valores precisos.
              * Objetivo: criar uma thumbnail inédita que pareça "campanha de performance", otimizada para CTR alto e retenção visual imediata.
              * Esta versão deve ser AINDA MELHOR que a original, com técnicas avançadas de viralização.

            PARA CADA UMA DAS 2 IDEIAS, GERE:
            1.  **"seoDescription"**: Uma descrição de vídeo para o YouTube, EXTREMAMENTE OTIMIZADA PARA SEO E VIRALIZAÇÃO, com:
               - Emojis estratégicos e relevantes (use emojis que representem o nicho e subnicho)
               - Parágrafos bem estruturados com quebras de linha
               - Chamadas para ação (CTA) claras e persuasivas
               - Uso estratégico de palavras-chave relevantes para o título "${selectedTitle}" e subnicho "${subniche}"
               - Formatação profissional com separadores visuais (━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━)
               - Seções organizadas: introdução, conteúdo do vídeo, sobre o canal, links importantes, hashtags
               - Linguagem persuasiva e envolvente que gere curiosidade e urgência
               - A descrição deve estar no idioma "${language}" e ter entre 300-500 palavras
               - IMPORTANTE: Use emojis de forma estratégica (não exagere, mas use para destacar seções importantes)
               - Inclua hashtags relevantes no final
               - Seja específico sobre o que o espectador vai aprender/ganhar
               
            2.  **"seoTags"**: Um array de strings com as 15-25 tags MAIS RELEVANTES E ESTRATÉGICAS para o vídeo (LIMITE MÁXIMO: 300 caracteres no total, incluindo vírgulas e espaços. NÃO ultrapasse 300 caracteres), incluindo:
               - Tags de cauda curta (1-2 palavras): termos populares e competitivos relacionados ao título "${selectedTitle}" e subnicho "${subniche}"
               - Tags de cauda longa (3-5 palavras): termos mais específicos e menos competitivos que capturam intenção de busca
               - Tags de nicho: termos específicos do subnicho "${subniche}"
               - Tags de tendência: termos que estão em alta no momento relacionados ao tema
               - Tags de formato: termos como "tutorial", "dicas", "como fazer", "guia completo", "passo a passo", etc.
               - Tags de plataforma: termos relacionados à plataforma (YouTube, TikTok, Instagram, etc.)
               - Tags de emoção: termos que capturam a emoção do título (ex: "surpresa", "revelação", "mistério", "urgência", "choque")
               - Tags de benefício: termos que descrevem o que o espectador vai ganhar/aprender
               - Tags de palavra-chave principal: extrair as palavras-chave mais importantes do título "${selectedTitle}"
               - Tags de sinônimos: variações e sinônimos das palavras-chave principais
               - IMPORTANTE: As tags devem ser EXTREMAMENTE RELEVANTES ao título "${selectedTitle}" e ao subnicho "${subniche}"
               - Evite tags genéricas que não agregam valor
               - Priorize tags que tenham volume de busca mas não sejam extremamente competitivas
               - Misture tags em português/inglês/espanhol conforme o idioma "${language}"
               - LIMITE MÁXIMO: 300 caracteres no total (incluindo vírgulas e espaços). NÃO ultrapasse 300 caracteres.
               - Cada tag deve ter entre 1-5 palavras, sendo a maioria com 2-3 palavras para otimizar o uso do espaço
               - Priorize tags mais relevantes e estratégicas. Se necessário, reduza a quantidade de tags para não ultrapassar 300 caracteres.
            3.  **"frasesDeGancho"**: Um array com 5 frases CURTAS de impacto (ganchos) para a thumbnail, OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne um array vazio [].' : `
                ⚠️⚠️⚠️ CRÍTICO E OBRIGATÓRIO - IDIOMA DAS FRASES DE GANCHO ⚠️⚠️⚠️
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Português' ? `
                ✅ CORRETO (Português): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : language === 'Inglês' ? `
                ✅ CORRETO (Inglês): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : `
                ✅ CORRETO (Espanhol): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante", "La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGATÓRIAS:
                1. Se "${language}" for "Português", TODAS as 5 frases DEVEM estar em PORTUGUÊS (Brasil)
                2. Se "${language}" for "Inglês", TODAS as 5 frases DEVEM estar em INGLÊS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em inglês se o idioma escolhido for português ou espanhol
                5. NUNCA, JAMAIS retorne frases em português se o idioma escolhido for inglês ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for português ou inglês
                7. Cada frase deve ter 2 a 4 palavras, no máximo
                8. As frases devem ser impactantes e relacionadas ao título "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases estão no idioma "${language}"?
                - Nenhuma frase está em inglês se "${language}" for português ou espanhol?
                - Nenhuma frase está em português se "${language}" for inglês ou espanhol?
                - Nenhuma frase está em espanhol se "${language}" for português ou inglês?
                
                Se alguma resposta for NÃO, CORRIJA as frases antes de retornar o JSON.
                `}
            4.  **"descricaoThumbnail"**: Um prompt EXTREMAMENTE DETALHADO e VÍVIDO, em INGLÊS, para uma IA de geração de imagem. ${!includePhrases ? 'NÃO inclua nenhum placeholder para texto. A thumbnail deve ser APENAS imagem, sem texto ou frases de gancho. Descreva apenas elementos visuais, composição, cores, iluminação, etc.' : 'A descrição DEVE incluir um placeholder claro, como "[FRASE DE GANCHO AQUI]", onde o texto da thumbnail deve ser inserido.'}
            
            CRÍTICO PARA A "descricaoThumbnail" - DEVE SER FOTOGRAFIA REAL ULTRA HD 8K, NÃO ILUSTRAÇÃO:
            - OBRIGATÓRIO: A descrição DEVE começar EXATAMENTE com: "Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, real lighting, real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, 8K resolution, extreme sharpness, maximum detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography quality"
            
            - ENFATIZE REPETIDAMENTE E OBRIGATORIAMENTE: "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail", "every pore visible", "every texture crisp", "perfect focus", "ultra sharp", "no blur except intentional depth of field", "no artifacts", "no compression", "no pixelation", "perfect clarity", "real photograph", "shot on location", "documentary photography", "realistic textures with imperfections", "natural lighting with real shadows", "real depth of field", "real bokeh effects", "professional color grading", "high dynamic range (HDR)", "sharp focus on subject", "real camera grain", "real-world photography", "actual photograph", "photographed in real life", "real person", "real object", "real environment", "National Geographic quality", "BBC documentary style", "professional photography", "photorealistic", "hyper-realistic"
            
            - NUNCA, JAMAIS use estes termos: "illustration", "drawing", "artwork", "digital art", "render", "3D render", "CGI", "cartoon", "anime", "sketch", "painting", "stylized", "artistic", "concept art", "digital painting", "graphic design", "vector", "comic", "fantasy art", "artistic interpretation", "stylized", "artistic style", "digital illustration"
            
            - SEMPRE use APENAS estes termos: "photograph", "photo", "photography", "shot", "captured", "documentary photo", "realistic capture", "professional photography", "real-world photography", "actual photograph", "photographed", "real-life photography", "on-location photography", "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail"
            
            - IMPORTANTE: Descreva como se fosse uma FOTO REAL ULTRA HD 8K tirada por um fotógrafo profissional. Mencione detalhes realistas como: "real skin texture with pores and natural imperfections visible in 8K detail", "real fabric texture with visible fibers and weave patterns in ultra HD", "real stone texture with weathering, cracks, and imperfections visible in perfect 8K clarity", "real shadows cast by real light sources with perfect sharpness", "real depth of field blur with perfect bokeh", "real camera lens distortion", "real chromatic aberration", "real lens flare", "real motion blur if applicable", "every detail visible in 8K resolution", "extreme sharpness and clarity", "no compression artifacts", "perfect focus on subject"

            REGRAS IMPORTANTES:
            - A "descricaoThumbnail" é OBRIGATORIAMENTE em INGLÊS.
            - "seoDescription", "seoTags" e "frasesDeGancho" são OBRIGATORIAMENTE no idioma "${language}".
            ${!includePhrases ? '- IMPORTANTE: A "descricaoThumbnail" NÃO deve mencionar texto, palavras ou frases. Apenas descreva elementos visuais, composição, cores, iluminação, etc.' : ''}
            - Seja extremamente específico e detalhado nas descrições visuais. Use termos técnicos de fotografia profissional, cinematografia e psicologia visual quando apropriado.
            - Foque em elementos que maximizem CTR: expressões faciais intensas, momentos de tensão, curiosidade visual, contraste dramático, composição impactante.
            
            EXEMPLOS DE COMO DESCREVER PARA GARANTIR REALISMO:
            - Em vez de "um guerreiro maia", escreva: "a real person dressed as a Mayan warrior, photographed on location, real skin texture with pores and natural imperfections, real fabric of the costume with visible texture and wrinkles, real feathers in the headdress with natural variations"
            - Em vez de "uma pirâmide antiga", escreva: "a real ancient Mayan pyramid photographed on location, real weathered stone with cracks and imperfections, real moss and vegetation growing on the stones, real shadows cast by the sun, real depth of field blur in the background"
            - Em vez de "luz mística", escreva: "real natural lighting from the sun, real shadows cast by real objects, real depth of field, real bokeh in the background, real camera lens flare if the sun is in frame"
            - SEMPRE mencione: "real", "actual", "photographed", "shot on location", "documentary style", "real-world", "actual photograph"
            
            TÉCNICAS DE THUMBNAIL VIRAL PARA O TEXTO (quando includePhrases = true) - DESIGN PROFISSIONAL COMO PHOTOSHOP - CTR ACIMA DE 25%:
            
            📝 DESCRIÇÃO OBRIGATÓRIA DO TEXTO - DEVE PARECER FEITO NO PHOTOSHOP POR UM DESIGNER PROFISSIONAL:
            O texto DEVE ser descrito como se fosse criado no Photoshop com técnicas profissionais de design gráfico:
            
            1. TIPOGRAFIA PROFISSIONAL:
               - "Professional typography, Photoshop-quality text design"
               - "Large, bold, professionally designed text occupying 25-35% of the image height"
               - "Massive, oversized typography with professional letter spacing and kerning"
               - "Thick, chunky, professionally rendered letters"
               - "Typography that looks like it was designed by a professional graphic designer"
               - "High-end text design, magazine-quality typography"
            
            2. CORES PROFISSIONAIS E EFEITOS DE CAMADA (Layer Effects do Photoshop):
               - "Bright yellow (#FFD700) text with professional Photoshop layer effects: thick black stroke (6-8px), white drop shadow with distance 8px, spread 5px, size 12px, opacity 80%, angle 135 degrees"
               - "Pure white text with professional red stroke (6px), black drop shadow with blur radius 10px, and subtle outer glow effect in yellow"
               - "Neon orange (#FF6600) text with black stroke (7px), professional drop shadow with multiple layers, and yellow outer glow with spread 8px"
               - "Electric blue (#00FFFF) text with white stroke (6px), black shadow with distance 10px, and professional bevel and emboss effect"
               - "Bright red (#FF0000) text with yellow stroke (5px), white drop shadow, and professional gradient overlay from yellow to orange"
               - "Lime green (#00FF00) text with black stroke (8px), white glow effect, and professional inner shadow"
               - IMPORTANTE: Descreva como efeitos de camada do Photoshop (layer effects), não apenas "outline" ou "shadow"
            
            3. FONTES PROFISSIONAIS:
               - "Professional bold sans-serif font (Impact, Bebas Neue, Montserrat Black, or similar premium font)"
               - "Thick, chunky, professionally designed block letters"
               - "Modern, high-end typography with perfect letter spacing"
               - "YouTube viral thumbnail professional font style"
               - "Bold, condensed font with professional kerning and tracking"
               - "Premium typography, no serifs, maximum readability, professional design"
               - "Typography that looks like it came from a professional design agency"
            
            4. EFEITOS PROFISSIONAIS DO PHOTOSHOP (Layer Styles):
               - "Professional Photoshop stroke effect: thick black outline (6-8px width), position: outside, blend mode: normal, opacity: 100%"
               - "Professional drop shadow: distance 10px, spread 5px, size 12px, angle 135°, opacity 80%, color black, blend mode: multiply"
               - "Professional outer glow effect: spread 8px, size 15px, opacity 75%, color matching text or contrasting"
               - "Professional bevel and emboss effect: style: emboss, technique: smooth, depth 100%, size 5px, softness 2px"
               - "Professional gradient overlay: linear gradient from bright color to darker shade, angle 90°, opacity 80%"
               - "Professional inner shadow: distance 3px, choke 0%, size 5px, opacity 60%"
               - "Professional color overlay: solid color with blend mode overlay or soft light, opacity 50%"
               - "Text appears to pop out from the image with professional 3D effect"
               - "Professional text rendering with anti-aliasing, crisp edges, perfect clarity"
            
            5. COMPOSIÇÃO PROFISSIONAL:
               - "Positioned at the top center of the image with professional alignment"
               - "Bottom third of the image with professional composition and high contrast background"
               - "Centered horizontally, upper third vertically, following rule of thirds"
               - "Strategically placed to not cover important visual elements, professional layout"
               - "Text area has professional semi-transparent dark background (black overlay with 40% opacity) for better readability"
               - "Professional text box or banner behind text with gradient or solid color, rounded corners optional"
            
            6. CONTRASTE E VISIBILIDADE PROFISSIONAL:
               - "High contrast against the background, professionally optimized"
               - "Text stands out dramatically from the image with professional design techniques"
               - "Eye-catching text overlay that immediately draws attention, professional composition"
               - "Text that pops from the image with maximum visibility, professional rendering"
               - "Text is the first thing the eye is drawn to, professional visual hierarchy"
               - "Background is professionally darkened (vignette effect) or lightened behind text for maximum contrast"
               - "Professional color grading applied to background to make text stand out"
            
            7. EXEMPLO COMPLETO DE DESCRIÇÃO PROFISSIONAL:
               "Professional Photoshop-quality text design: Large, bold, stylized text '[FRASE DE GANCHO AQUI]' in bright yellow (#FFD700) with professional layer effects: thick black stroke (7px width, position outside), white drop shadow (distance 10px, spread 5px, size 12px, opacity 80%, angle 135°), subtle outer glow in white (spread 6px, size 10px, opacity 70%), positioned at the top center of the image, occupying 30% of the image height, professional bold sans-serif font (Impact or Bebas Neue style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, high contrast viral thumbnail text style, eye-catching and attention-grabbing, text appears to pop out from the image with professional 3D effect, maximum visibility for high CTR, looks like it was designed by a professional graphic designer in Photoshop"
            
            8. REGRAS DE OURO PARA DESIGN PROFISSIONAL:
               - O texto DEVE parecer feito no Photoshop por um designer profissional
               - O texto DEVE ter múltiplos efeitos de camada (stroke, shadow, glow, bevel)
               - O texto DEVE ter valores específicos de efeitos (distância, spread, tamanho, opacidade)
               - O texto DEVE ter tipografia profissional com kerning e tracking perfeitos
               - O texto DEVE ter renderização profissional (anti-aliasing, crisp edges)
               - O texto DEVE ter composição profissional (regra dos terços, hierarquia visual)
               - O texto DEVE parecer de qualidade de agência de design, não amador

            RESPONDA APENAS COM UM OBJETO JSON VÁLIDO, com a seguinte estrutura:
            {
              "ideias": [
                {
                  "seoDescription": "Descrição completa e otimizada para o YouTube aqui...",
                  "seoTags": ["tag1", "tag2", "tag3", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"]' : language === 'Inglês' ? '["He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"]' : '["Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'A detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'A detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                },
                {
                  "seoDescription": "Outra descrição completa e otimizada...",
                  "seoTags": ["tagA", "tagB", "tagC", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Português' ? '["A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"]' : language === 'Inglês' ? '["The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything", "Surprising Revelation"]' : '["La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'Another detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'Another detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                }
              ]
            }
        `;
            }
        }
        
        // --- 4. Chamar a API Multimodal com fallback ---
        let apiCallFunction;
        if (service === 'gemini') apiCallFunction = callGeminiAPI;
        else if (service === 'claude') apiCallFunction = callClaudeAPI;
        else if (service === 'openai') apiCallFunction = callOpenAIAPI;
        
        console.log(`[Análise-Thumb] A chamar ${service} com o modelo ${model}...`);
        
        let response;
        let parsedData;
        let successfulService = service;
        
        try {
            response = await apiCallFunction(thumbPrompt, decryptedKey, model, videoDetails.thumbnailUrl);
            parsedData = parseAIResponse(response.titles, service);
            
            if (!parsedData.ideias || !Array.isArray(parsedData.ideias) || parsedData.ideias.length === 0) {
                throw new Error("A IA não retornou o array 'ideias' esperado.");
            }
        } catch (firstError) {
            console.warn(`[Análise-Thumb] Falha com ${service}:`, firstError.message);
            
            // Tentar fallback para outros modelos se o primeiro falhar
            const fallbackServices = service === 'gemini' 
                ? ['claude', 'openai'] 
                : service === 'claude' 
                    ? ['openai', 'gemini'] 
                    : ['gemini', 'claude'];
            
            let fallbackSuccess = false;
            
            for (const fallbackService of fallbackServices) {
                try {
                    console.log(`[Análise-Thumb] Tentando fallback com ${fallbackService}...`);
                    
                    const fallbackKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, fallbackService]);
                    if (!fallbackKeyData) {
                        console.warn(`[Análise-Thumb] Chave de API do ${fallbackService} não configurada para fallback.`);
                        continue;
                    }
                    
                    const fallbackDecryptedKey = decrypt(fallbackKeyData.api_key);
                    if (!fallbackDecryptedKey) {
                        console.warn(`[Análise-Thumb] Falha ao desencriptar chave do ${fallbackService}.`);
                        continue;
                    }
                    
                    let fallbackModel = model;
                    if (fallbackService === 'claude') fallbackModel = 'claude-3-5-haiku-20241022';
                    else if (fallbackService === 'openai') fallbackModel = 'gpt-4o';
                    else if (fallbackService === 'gemini') fallbackModel = 'gemini-2.0-flash';
                    
                    let fallbackApiCallFunction;
                    if (fallbackService === 'gemini') fallbackApiCallFunction = callGeminiAPI;
                    else if (fallbackService === 'claude') fallbackApiCallFunction = callClaudeAPI;
                    else fallbackApiCallFunction = callOpenAIAPI;
                    
                    response = await fallbackApiCallFunction(thumbPrompt, fallbackDecryptedKey, fallbackModel, videoDetails.thumbnailUrl);
                    parsedData = parseAIResponse(response.titles, fallbackService);
                    
                    if (!parsedData.ideias || !Array.isArray(parsedData.ideias) || parsedData.ideias.length === 0) {
                        throw new Error("A IA não retornou o array 'ideias' esperado.");
                    }
                    
                    successfulService = fallbackService;
                    fallbackSuccess = true;
                    console.log(`[Análise-Thumb] Sucesso com fallback ${fallbackService}!`);
                    break;
                } catch (fallbackError) {
                    console.warn(`[Análise-Thumb] Fallback ${fallbackService} também falhou:`, fallbackError.message);
                    continue;
                }
            }
            
            if (!fallbackSuccess) {
                throw new Error(`Todas as IAs falharam. Último erro: ${firstError.message}`);
            }
        }

        // --- 5. Validar e processar dados antes de enviar ---
        
        // Validar e corrigir tags (limite de 300 caracteres) e frases de gancho (idioma correto)
        if (parsedData.ideias && Array.isArray(parsedData.ideias)) {
            parsedData.ideias = parsedData.ideias.map(idea => {
                // Validar tags - limitar a 300 caracteres
                if (idea.seoTags && Array.isArray(idea.seoTags)) {
                    let tagsString = idea.seoTags.join(', ');
                    if (tagsString.length > 300) {
                        // Reduzir tags até ficar dentro do limite
                        let reducedTags = [];
                        let currentLength = 0;
                        for (const tag of idea.seoTags) {
                            const tagWithComma = reducedTags.length > 0 ? ', ' + tag : tag;
                            if (currentLength + tagWithComma.length <= 300) {
                                reducedTags.push(tag);
                                currentLength += tagWithComma.length;
                            } else {
                                break;
                            }
                        }
                        idea.seoTags = reducedTags;
                        console.log(`[Thumbnail] Tags reduzidas de ${idea.seoTags.length + (idea.seoTags.length - reducedTags.length)} para ${reducedTags.length} para respeitar limite de 300 caracteres`);
                    }
                }
                
                // Validar frases de gancho - garantir que estejam no idioma correto
                if (idea.frasesDeGancho && Array.isArray(idea.frasesDeGancho) && includePhrases) {
                    // Verificar se as frases estão no idioma correto (análise básica)
                    const isPortuguese = language === 'Português';
                    const isSpanish = language === 'Espanhol';
                    const isEnglish = language === 'Inglês';
                    
                    // Palavras comuns em português que não aparecem em inglês/espanhol
                    const portugueseWords = ['que', 'não', 'você', 'com', 'para', 'mais', 'muito', 'isso', 'aqui', 'agora', 'também', 'sempre', 'depois', 'antes', 'ainda', 'então', 'assim', 'mesmo', 'todo', 'toda', 'todos', 'todas', 'ele', 'ela', 'eles', 'elas', 'nosso', 'nossa', 'seus', 'suas', 'desse', 'dessa', 'deles', 'delas'];
                    const spanishWords = ['que', 'no', 'tú', 'con', 'para', 'más', 'muy', 'esto', 'aquí', 'ahora', 'también', 'siempre', 'después', 'antes', 'aún', 'entonces', 'así', 'mismo', 'todo', 'toda', 'todos', 'todas', 'él', 'ella', 'ellos', 'ellas', 'nuestro', 'nuestra', 'sus', 'de', 'del', 'de la'];
                    
                    idea.frasesDeGancho = idea.frasesDeGancho.map(frase => {
                        if (!frase || typeof frase !== 'string') return frase;
                        
                        const fraseLower = frase.toLowerCase();
                        let needsTranslation = false;
                        
                        if (isPortuguese) {
                            // Verificar se tem palavras em português
                            const hasPortugueseWords = portugueseWords.some(word => fraseLower.includes(word));
                            // Se não tem palavras portuguesas e tem palavras comuns em inglês, provavelmente está em inglês
                            if (!hasPortugueseWords && (fraseLower.includes('the ') || fraseLower.includes(' a ') || fraseLower.includes('this ') || fraseLower.includes('that '))) {
                                needsTranslation = true;
                            }
                        } else if (isSpanish) {
                            // Verificar se tem palavras em espanhol
                            const hasSpanishWords = spanishWords.some(word => fraseLower.includes(word));
                            // Se não tem palavras espanholas e tem palavras comuns em inglês, provavelmente está em inglês
                            if (!hasSpanishWords && (fraseLower.includes('the ') || fraseLower.includes(' a ') || fraseLower.includes('this ') || fraseLower.includes('that '))) {
                                needsTranslation = true;
                            }
                        } else if (isEnglish) {
                            // Se tem palavras portuguesas/espanholas, provavelmente não está em inglês
                            if (portugueseWords.some(word => fraseLower.includes(word)) || spanishWords.some(word => fraseLower.includes(word))) {
                                needsTranslation = true;
                            }
                        }
                        
                        // Se precisa traduzir, retornar a frase original (a IA deve ter gerado corretamente, mas vamos apenas logar)
                        if (needsTranslation) {
                            console.warn(`[Thumbnail] Frase de gancho pode estar no idioma errado: "${frase}" (idioma esperado: ${language})`);
                        }
                        
                        return frase;
                    });
                }
                
                return idea;
            });
        }

        // --- 6. Enviar resposta ---

        // NÃO salvar thumbnails automaticamente - apenas quando o usuário gerar a imagem e salvar na biblioteca
        // As thumbnails serão salvas apenas quando o usuário gerar a imagem com ImageFX e clicar em "Salvar na Biblioteca"
        console.log(`[Biblioteca] ${parsedData.ideias.length} ideias de thumbnails geradas. Aguardando geração de imagem pelo usuário para salvar na biblioteca.`);

        res.status(200).json(parsedData.ideias);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/analyze/thumbnail]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao gerar ideias de thumbnail.' });
    }
});

// === ROTA LAOZHANG PARA ANÁLISE DE THUMBNAIL ===
// Nota: Esta rota usa a mesma lógica da rota original, mas sempre usa Laozhang API
// A implementação completa seguiria o mesmo padrão, mas simplificamos para usar callLaozhangAPI
app.post('/api/analyze/thumbnail/laozhang', authenticateToken, async (req, res) => {
    let { videoId, selectedTitle, model, selectedModel, niche, subniche, language, includePhrases, style, customPrompt, thumbnailRule } = req.body;
    // Usar 'model' se 'selectedModel' não estiver presente (compatibilidade)
    const modelToUse = model || selectedModel;
    const userId = req.user.id;

    if (!videoId || !selectedTitle || !niche || !subniche || !language || includePhrases === undefined || !style) {
        return res.status(400).json({ msg: 'Dados insuficientes para gerar ideias de thumbnail.' });
    }
    
    // Se thumbnailRule não for fornecido, usar 'auto'
    thumbnailRule = thumbnailRule || 'auto';

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Mapear modelo selecionado para modelo Laozhang
        // O frontend envia: 'gpt-4o', 'claude-3-7-sonnet-20250219', 'gemini-2.5-pro'
        let laozhangModel;
        if (modelToUse === 'gpt-4o' || modelToUse === 'GPT-4o (2025)') {
            laozhangModel = 'gpt-4o';
        } else if (modelToUse === 'claude-3-7-sonnet-20250219' || modelToUse === 'Claude 3.7 Sonnet (Fev/25)') {
            laozhangModel = 'claude-3-7-sonnet-20250219';
        } else if (modelToUse === 'gemini-2.5-pro' || modelToUse === 'Gemini 2.5 Pro (2025)') {
            laozhangModel = 'gemini-2.5-pro';
        } else {
            laozhangModel = 'gpt-4o'; // Fallback
        }

        // Buscar chave do YouTube primeiro (prioridade)
        let videoDetails = null;
        let youtubeApiKey = null;
        
        try {
            const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
            if (youtubeKeyData && youtubeKeyData.api_key) {
                // Tentar descriptografar se estiver criptografada
                if (youtubeKeyData.api_key.includes(':')) {
                    try {
                        youtubeApiKey = decrypt(youtubeKeyData.api_key);
                    } catch (decryptErr) {
                        console.warn('[Thumbnail Laozhang] Erro ao descriptografar chave do YouTube, tentando usar diretamente:', decryptErr.message);
                        youtubeApiKey = youtubeKeyData.api_key;
                    }
                } else {
                    youtubeApiKey = youtubeKeyData.api_key;
                }
                
                if (youtubeApiKey) {
                    console.log('[Thumbnail Laozhang] Tentando usar chave do YouTube...');
                    try {
                        videoDetails = await callYouTubeDataAPI(videoId, youtubeApiKey);
                        console.log('[Thumbnail Laozhang] ✅ Sucesso com chave do YouTube');
                    } catch (youtubeErr) {
                        console.warn('[Thumbnail Laozhang] Erro ao usar chave do YouTube:', youtubeErr.message);
                        videoDetails = null;
                    }
                }
            }
        } catch (err) {
            console.warn('[Thumbnail Laozhang] Erro ao buscar chave do YouTube:', err.message);
        }
        
        // Se não funcionou com YouTube, tentar Gemini como fallback
        if (!videoDetails) {
            try {
                const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
                if (geminiKeyData && geminiKeyData.api_key) {
                    let geminiApiKey = null;
                    if (geminiKeyData.api_key.includes(':')) {
                        try {
                            geminiApiKey = decrypt(geminiKeyData.api_key);
                        } catch (decryptErr) {
                            console.warn('[Thumbnail Laozhang] Erro ao descriptografar chave do Gemini, tentando usar diretamente:', decryptErr.message);
                            geminiApiKey = geminiKeyData.api_key;
                        }
                    } else {
                        geminiApiKey = geminiKeyData.api_key;
                    }
                    
                    if (geminiApiKey) {
                        console.log('[Thumbnail Laozhang] Tentando usar chave do Gemini como fallback...');
                        try {
                            videoDetails = await callYouTubeDataAPI(videoId, geminiApiKey);
                            console.log('[Thumbnail Laozhang] ✅ Sucesso com chave do Gemini');
                        } catch (geminiErr) {
                            console.warn('[Thumbnail Laozhang] Erro ao usar chave do Gemini:', geminiErr.message);
                        }
                    }
                }
            } catch (err) {
                console.warn('[Thumbnail Laozhang] Erro ao buscar chave do Gemini:', err.message);
            }
        }

        if (!videoDetails) {
            return res.status(400).json({ 
                msg: 'Não foi possível buscar dados do vídeo. Verifique se a chave do YouTube Data API v3 está configurada corretamente nas Configurações. A chave do Gemini pode não funcionar para a API do YouTube.' 
            });
        }

        // Usar o mesmo prompt da rota original com todas as melhorias
        // Buscar análise original para pegar a fórmula do título
        let formulaTitulo = null;
        let motivoSucesso = null;
        try {
            const originalAnalysis = await db.get(
                'SELECT analysis_data_json FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                [videoId, userId]
            );
            if (originalAnalysis && originalAnalysis.analysis_data_json) {
                const analysisData = JSON.parse(originalAnalysis.analysis_data_json);
                if (analysisData.formulaTitulo) {
                    formulaTitulo = analysisData.formulaTitulo;
                }
                if (analysisData.motivoSucesso) {
                    motivoSucesso = analysisData.motivoSucesso;
                }
            }
        } catch (err) {
            console.warn(`[Análise-Thumb Laozhang] Não foi possível buscar análise original: ${err.message}`);
        }
        
        const formulaContext = formulaTitulo ? `\n            FÓRMULA DO TÍTULO VIRAL IDENTIFICADA: "${formulaTitulo}"\n            MOTIVO DO SUCESSO: "${motivoSucesso || 'Análise não disponível'}"\n            \n            IMPORTANTE: Use esta fórmula como base para criar thumbnails que complementem e reforcem o mesmo gatilho mental e estratégia que tornaram o título viral.` : '';
        
        const thumbPrompt = customPrompt && customPrompt.trim() ? customPrompt : `
Você é um ESPECIALISTA EM THUMBNAILS VIRAIS NO YOUTUBE, combinando as habilidades de um diretor de arte profissional e um estrategista de viralização com experiência em criar thumbnails que gerem MILHÕES DE VIEWS e ALTO CTR (acima de 25%).${formulaContext}

TÍTULO DO VÍDEO: "${selectedTitle}"
SUBNICHO: "${subniche}"
ESTILO DE ARTE: "${style}"
IDIOMA: "${language}"

⚠️ ATENÇÃO CRÍTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, não ilustrações, desenhos ou renderizações. A descriçãoThumbnail deve descrever uma FOTO REAL tirada por um fotógrafo profissional em um local real, com pessoas reais e objetos reais.

${(() => {
    const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
    if (ruleData.mode === 'auto') {
        return `\n🔍 MODO AUTOMÁTICO - ANÁLISE DE REGRA:\nAnalise o título "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPLÍCITA na descrição da thumbnail.\n\n📋 AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE:\n\n1️⃣ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO): Checklist: 1 ideia principal, 1 personagem, 1 emoção, 1 objeto-chave.\n\n2️⃣ REGRA DO ASSUNTO ÚNICO: Nada divide a atenção. Foque em UM ÚNICO assunto dominante.\n\n3️⃣ REGRA DO ROSTO GRANDE: Rostos com forte expressão emocional aumentam CTR de 20% a 60%. Expressões: choque, surpresa, medo, raiva, felicidade extrema.\n\n4️⃣ REGRA DO CONTRASTE BRUTAL: Use contraste entre texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n\n5️⃣ REGRA DA COR ESTRATÉGICA: Amarelo (atenção), Vermelho (urgência), Azul (confiança), Verde (dinheiro), Preto (premium/mistério).\n\n6️⃣ REGRA DOS TERÇOS: Posicione o assunto nos cruzamentos dos "9 quadrantes".\n\n7️⃣ REGRA DO TEXTO ULTRA CURTO: Texto deve ter 2 a 4 palavras. Exemplos: "Ele mentiu", "Descobri isso", "Ninguém viu".\n\n8️⃣ REGRA DO ZOOM EMOCIONAL: Use um elemento GIGANTE que amplifique a emoção (conta bancária gigante, faca gigante, lupa gigante, número gigante).\n\n9️⃣ REGRA DO MISTÉRIO: Crie uma pergunta implícita (algo escondido atrás de blur, objeto cortado pela metade, pessoa olhando para fora do quadro).\n\n🔟 REGRA DOS PONTOS DE FUGA: Use linhas visuais (setas, linhas diagonais, perspectiva) que guiem o olhar para o foco.\n\n1️⃣1️⃣ REGRA DO ESPAÇO NEGATIVO: Deixe áreas vazias que acentuem o foco no elemento principal.\n\n1️⃣2️⃣ REGRA DA COERÊNCIA COM O TÍTULO: Título = contexto, Thumbnail = emoção. Devem contar a mesma história com ângulos diferentes.\n\n⚠️ CRÍTICO: Identifique qual regra melhor se encaixa e aplique-a de forma EXPLÍCITA na descrição da thumbnail.`;
    } else {
        return `\n📋 REGRA SELECIONADA: ${ruleData.rule.name}\n${ruleData.rule.description}\n\n⚠️ CRÍTICO: Aplique esta regra de forma EXPLÍCITA e RIGOROSA:\n${ruleData.instructions}`;
    }
})()}

🎯 OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando técnicas profissionais e as regras acima.

SUA TAREFA:
Crie DUAS (2) ideias distintas para thumbnail:

⚠️⚠️⚠️ CRÍTICO - ORDEM DAS IDEIAS ⚠️⚠️⚠️
- **IDEIA 1 (RÉPLICA E MELHORIA DA THUMBNAIL ORIGINAL DO VÍDEO):** 
  * OBRIGATÓRIO: Esta ideia DEVE replicar e melhorar a thumbnail ORIGINAL do vídeo ao qual foram feitos os títulos.
  * Analise cuidadosamente a IMAGEM DE REFERÊNCIA (thumbnail original do vídeo) que está anexada.
  * Replique a estrutura da thumbnail de referência quase 1:1: mantenha EXATAMENTE a mesma composição, ângulo de câmera, enquadramento, posição dos personagens/objetos, paleta de cores, quantidade de texto, posição do texto, elementos visuais principais e storytelling.
  * PRESERVE o poder viral da thumbnail original que gerou milhões de views.
  * Apenas ELEVE A QUALIDADE: mais nitidez (8K), contraste reforçado, iluminação cinematográfica profissional, correções de cor profissionais, tratamento de pele profissional, brilho nos olhos, textura realista, limpeza de ruídos, adicione luzes/sombras profissionais, aplique efeitos de texto Photoshop com valores específicos.
  * NÃO altere o storytelling principal, apenas entregue a versão definitiva com acabamento premium.
  * Resultado: praticamente igual à thumbnail original, mas com sensação de upgrade premium e leitura instantânea mais clara e clicável.

- **IDEIA 2 (THUMBNAIL MELHORADA E OTIMIZADA):** 
  * Esta é uma versão COMPLETAMENTE NOVA, melhorada e otimizada para CTR alto (30%+).
  * Crie um conceito totalmente novo com foco em CTR máximo: novo enquadramento, nova composição, novos elementos que gerem curiosidade extrema.
  * Use gatilhos agressivos (perigo, segredo revelado, números gigantes, setas, antes/depois, close dramático) e cores super contrastantes.
  * Construa um storytelling diferente, alinhado ao título "${selectedTitle}", que prometa algo ainda mais irresistível que a versão original.
  * O texto deve ser redesenhado para máxima legibilidade mobile, com layer styles profissionais e valores precisos.
  * Esta versão deve ser AINDA MELHOR que a original, com técnicas avançadas de viralização.

PARA CADA UMA DAS 2 IDEIAS, GERE:
1. **"seoDescription"**: Descrição EXTREMAMENTE OTIMIZADA para SEO e viralização (300-500 palavras), com emojis estratégicos, parágrafos estruturados, CTAs claras, palavras-chave relevantes, formatação profissional com separadores visuais, seções organizadas (introdução, conteúdo, sobre canal, links, hashtags), linguagem persuasiva que gere curiosidade e urgência, no idioma "${language}".

2. **"seoTags"**: Array com 15-25 tags MAIS RELEVANTES (LIMITE MÁXIMO: 300 caracteres no total, incluindo vírgulas e espaços. NÃO ultrapasse 300 caracteres), incluindo: tags de cauda curta (1-2 palavras), tags de cauda longa (3-5 palavras), tags de nicho, tags de tendência, tags de formato, tags de emoção, tags de benefício, tags de palavra-chave principal, tags de sinônimos. Todas RELEVANTES ao título "${selectedTitle}" e subnicho "${subniche}", no idioma "${language}". Priorize tags mais relevantes e estratégicas. Se necessário, reduza a quantidade de tags para não ultrapassar 300 caracteres.

3. **"frasesDeGancho"**: Array com 5 frases CURTAS de impacto (2-4 palavras cada), OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne array vazio [].' : `
                ⚠️⚠️⚠️ CRÍTICO E OBRIGATÓRIO - IDIOMA DAS FRASES DE GANCHO ⚠️⚠️⚠️
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Português' ? `
                ✅ CORRETO (Português): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revelação Surpreendente"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : language === 'Inglês' ? `
                ✅ CORRETO (Inglês): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Espanhol - NÃO USAR): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante"
                ` : `
                ✅ CORRETO (Espanhol): "Él Mintió", "Descubrí Esto", "Nadie Vio", "Prohibido", "Revelación Impactante", "La Verdad", "Nunca Visto", "Descubrí Todo", "Esto Cambió Todo", "Revelación Sorprendente"
                ❌ ERRADO (Português - NÃO USAR): "Ele Mentiu", "Descobri Isso", "Ninguém Viu", "Proibido", "Revelação Chocante"
                ❌ ERRADO (Inglês - NÃO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGATÓRIAS:
                1. Se "${language}" for "Português", TODAS as 5 frases DEVEM estar em PORTUGUÊS (Brasil)
                2. Se "${language}" for "Inglês", TODAS as 5 frases DEVEM estar em INGLÊS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em inglês se o idioma escolhido for português ou espanhol
                5. NUNCA, JAMAIS retorne frases em português se o idioma escolhido for inglês ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for português ou inglês
                7. Cada frase deve ter 2 a 4 palavras, no máximo
                8. As frases devem ser impactantes e relacionadas ao título "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases estão no idioma "${language}"?
                - Nenhuma frase está em inglês se "${language}" for português ou espanhol?
                - Nenhuma frase está em português se "${language}" for inglês ou espanhol?
                - Nenhuma frase está em espanhol se "${language}" for português ou inglês?
                
                Se alguma resposta for NÃO, CORRIJA as frases antes de retornar o JSON.
                `}

4. **"descricaoThumbnail"**: Prompt EXTREMAMENTE DETALHADO em INGLÊS para IA de geração de imagem. ${!includePhrases ? 'NÃO inclua placeholder para texto. Apenas elementos visuais.' : 'DEVE incluir placeholder "[FRASE DE GANCHO AQUI]" com descrição profissional de texto Photoshop (layer effects, stroke, drop shadow, outer glow, bevel & emboss, tipografia profissional, valores específicos).'} DEVE começar com: "${getStyleSpecificPrompt(style, includePhrases)}" e aplicar as regras de thumbnail viral identificadas acima de forma EXPLÍCITA.

Retorne APENAS JSON válido:
{
  "ideias": [
    {
      "seoDescription": "Descrição completa e otimizada...",
      "seoTags": ["tag1", "tag2", ...],
      "frasesDeGancho": ${includePhrases ? '["Frase 1", "Frase 2", "Frase 3", "Frase 4", "Frase 5"]' : '[]'},
      "descricaoThumbnail": "Ultra-high-definition (8K) professional photograph... ${includePhrases ? '[FRASE DE GANCHO AQUI]' : ''}..."
    },
    {
      "seoDescription": "Outra descrição completa e otimizada...",
      "seoTags": ["tagA", "tagB", ...],
      "frasesDeGancho": ${includePhrases ? '["Outra 1", "Outra 2", "Outra 3", "Outra 4", "Outra 5"]' : '[]'},
      "descricaoThumbnail": "Ultra-high-definition (8K) professional photograph... ${includePhrases ? '[FRASE DE GANCHO AQUI]' : ''}..."
    }
  ]
}`;

        const response = await callLaozhangAPI(
            thumbPrompt,
            laozhangApiKey,
            laozhangModel,
            videoDetails.thumbnailUrl,
            userId,
            'api_analyze_thumbnail',
            JSON.stringify({ endpoint: '/api/analyze/thumbnail/laozhang', model: laozhangModel })
        );

        // Parsear resposta
        let parsedData;
        const rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        try {
            parsedData = JSON.parse(rawResponse);
        } catch (e) {
            const jsonMatch = rawResponse.match(/\{[\s\S]*"ideias"[\s\S]*\}/);
            if (jsonMatch) {
                parsedData = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('Resposta da IA não contém JSON válido.');
            }
        }

        if (!parsedData.ideias || !Array.isArray(parsedData.ideias) || parsedData.ideias.length === 0) {
            throw new Error("A IA não retornou o array 'ideias' esperado.");
        }

        // Validar e processar dados antes de enviar (mesma lógica da rota principal)
        if (parsedData.ideias && Array.isArray(parsedData.ideias)) {
            parsedData.ideias = parsedData.ideias.map(idea => {
                // Validar tags - limitar a 300 caracteres
                if (idea.seoTags && Array.isArray(idea.seoTags)) {
                    let tagsString = idea.seoTags.join(', ');
                    if (tagsString.length > 300) {
                        // Reduzir tags até ficar dentro do limite
                        let reducedTags = [];
                        let currentLength = 0;
                        for (const tag of idea.seoTags) {
                            const tagWithComma = reducedTags.length > 0 ? ', ' + tag : tag;
                            if (currentLength + tagWithComma.length <= 300) {
                                reducedTags.push(tag);
                                currentLength += tagWithComma.length;
                            } else {
                                break;
                            }
                        }
                        idea.seoTags = reducedTags;
                        console.log(`[Thumbnail Laozhang] Tags reduzidas para respeitar limite de 300 caracteres`);
                    }
                }
                
                // Validar frases de gancho - garantir que estejam no idioma correto
                if (idea.frasesDeGancho && Array.isArray(idea.frasesDeGancho) && includePhrases) {
                    const isPortuguese = language === 'Português';
                    const isSpanish = language === 'Espanhol';
                    const portugueseWords = ['que', 'não', 'você', 'com', 'para', 'mais', 'muito', 'isso', 'aqui', 'agora', 'também', 'sempre', 'depois', 'antes', 'ainda', 'então', 'assim', 'mesmo', 'todo', 'toda', 'todos', 'todas', 'ele', 'ela', 'eles', 'elas'];
                    const spanishWords = ['que', 'no', 'tú', 'con', 'para', 'más', 'muy', 'esto', 'aquí', 'ahora', 'también', 'siempre', 'después', 'antes', 'aún', 'entonces', 'así', 'mismo', 'todo', 'toda', 'todos', 'todas', 'él', 'ella', 'ellos', 'ellas'];
                    
                    idea.frasesDeGancho = idea.frasesDeGancho.map(frase => {
                        if (!frase || typeof frase !== 'string') return frase;
                        const fraseLower = frase.toLowerCase();
                        let needsTranslation = false;
                        
                        if (isPortuguese && !portugueseWords.some(word => fraseLower.includes(word)) && (fraseLower.includes('the ') || fraseLower.includes(' a ') || fraseLower.includes('this '))) {
                            needsTranslation = true;
                        } else if (isSpanish && !spanishWords.some(word => fraseLower.includes(word)) && (fraseLower.includes('the ') || fraseLower.includes(' a ') || fraseLower.includes('this '))) {
                            needsTranslation = true;
                        }
                        
                        if (needsTranslation) {
                            console.warn(`[Thumbnail Laozhang] Frase de gancho pode estar no idioma errado: "${frase}" (idioma esperado: ${language})`);
                        }
                        
                        return frase;
                    });
                }
                
                return idea;
            });
        }

        res.status(200).json(parsedData.ideias);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/analyze/thumbnail/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao gerar ideias de thumbnail.' });
    }
});

// === ROTA PARA GERAR PROMPTS DE CENA ===
app.post('/api/generate/scene-prompts', authenticateToken, async (req, res) => {
    const { script, model, style, imageModel, mode, wordsPerScene, characters, selectedModel } = req.body;
    const userId = req.user.id;

    if (!script || !script.trim()) {
        return res.status(400).json({ msg: 'O roteiro é obrigatório.' });
    }

    if (!model) {
        return res.status(400).json({ msg: 'O modelo de IA é obrigatório.' });
    }

    try {
        // Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem API própria configurada
        let service = 'gemini';
        if (model.includes('claude') || model.includes('sonnet')) {
            service = 'claude';
        } else if (model.includes('gpt') || model.includes('openai')) {
            service = 'openai';
        }

        const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
        let decryptedKey = null;
        let useLaozhang = false;
        let laozhangApiKey = null;

        if (creditsCheck.shouldUse) {
            // Usar créditos (laozhang.ai)
            console.log(`[Scene Prompts] ✅ Usando créditos (${creditsCheck.reason})`);
            laozhangApiKey = await getLaozhangApiKey();
            if (laozhangApiKey) {
                useLaozhang = true;
            } else {
                return res.status(500).json({ msg: 'Sistema de créditos não configurado. Entre em contato com o suporte.' });
            }
        } else {
            // Usar API própria
            console.log(`[Scene Prompts] ✅ Usando API própria (${creditsCheck.reason})`);
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (!keyData) {
                return res.status(400).json({ msg: `Chave de API do ${service} não configurada. Configure nas Configurações.` });
            }

            decryptedKey = decrypt(keyData.api_key);
            if (!decryptedKey) {
                return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
            }
        }

        // Calcular número estimado de cenas baseado no modo
        const wordCount = script.trim().split(/\s+/).filter(Boolean).length;
        let estimatedScenes, minScenes, maxScenes;
        
        if (mode === 'manual' && wordsPerScene) {
            // Modo manual: baseado em palavras por cena
            estimatedScenes = Math.max(1, Math.round(wordCount / parseInt(wordsPerScene)));
            minScenes = Math.max(1, Math.floor(wordCount / (parseInt(wordsPerScene) * 1.4)));
            maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / (parseInt(wordsPerScene) * 0.6)));
        } else {
            // Modo automático: 1 cena a cada ~90 palavras
            estimatedScenes = Math.max(1, Math.round(wordCount / 90));
            minScenes = Math.max(1, Math.floor(wordCount / 140));
            maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / 60));
        }

        // Mapeamento detalhado de estilos para instruções
        const styleInstructions = {
            'photorealistic': 'O estilo visual deve ser fotorealista, com detalhes perfeitos, ultra alta definição, foco nítido, fotografia profissional.',
            'cinematic': 'O estilo visual deve ser cinematográfico, com iluminação dramática, composição épica, estética de filme Hollywood.',
            'documentary': 'O estilo visual deve ser documental, natural, autêntico, com momentos reais e abordagem jornalística.',
            'cinematic-narrative': 'O estilo visual deve ser narrativo cinematográfico, focado em storytelling visual, profundidade emocional.',
            'anime': 'O estilo visual deve ser anime, com cores vibrantes, personagens expressivos, estética de animação japonesa.',
            'cartoon': 'O estilo visual deve ser desenho animado, colorido, expressivo, com estética de animação tradicional.',
            'cartoon-premium': 'O estilo visual deve ser cartoon premium, com alta qualidade de animação e design profissional.',
            'fantasy': 'O estilo visual deve ser fantasia, mágico, épico, com atmosfera encantada e elementos místicos.',
            'stick-figure': 'O estilo visual deve ser desenho de palitos, minimalista, linhas simples em fundo branco.',
            'whiteboard': 'O estilo visual deve ser animação de quadro branco, educativo, limpo, com ilustrações desenhadas à mão.',
            'tech-minimalist': 'O estilo visual deve ser tech minimalista, design limpo, estética moderna e futurista.',
            'spiritual-minimalist': 'O estilo visual deve ser espiritual minimalista, sereno, com atmosfera meditativa e zen.',
            'viral-vibrant': 'O estilo visual deve ser viral vibrante, alto contraste, cores saturadas, otimizado para redes sociais.',
            'modern-documentary': 'O estilo visual deve ser documentário moderno, dinâmico, contemporâneo, com momentos autênticos.',
            'analog-horror': 'O estilo visual deve ser terror analógico, qualidade VHS, textura granulada, estética retro de horror.',
            'dark-theater': 'O estilo visual deve ser teatro sombrio, iluminação dramática de palco, sombras intensas.',
            'naturalist-drama': 'O estilo visual deve ser drama naturalista, realista, emocional, com momentos humanos autênticos.',
            'spiritual-neorealism': 'O estilo visual deve ser neo-realismo espiritual, realismo transcendente, atmosfera mística.',
            'psychological-surrealism': 'O estilo visual deve ser surrealismo psicológico, imagens oníricas, realidade abstrata.',
            'fragmented-memory': 'O estilo visual deve ser memória fragmentada, estética de colagem, composição fragmentada.',
            'fragmented-narrative': 'O estilo visual deve ser narrativa fragmentada, estilo colagem, narrativa visual em camadas.',
            'dream-real': 'O estilo visual deve ser sonho-real, espaço liminar entre sonho e realidade, atmosfera etérea.',
            'vhs-nostalgic': 'O estilo visual deve ser VHS nostálgico, estética retro anos 80/90, qualidade vintage, grão analógico.'
        };
        
        const styleInstruction = style && style !== 'none' && styleInstructions[style] 
            ? ` ${styleInstructions[style]}` 
            : '';
        const imageModelInstruction = imageModel ? ` Os prompts devem ser otimizados para ${imageModel}.` : '';
        const charactersInstruction = characters ? `\n\nPERSONAGENS CONSISTENTES:\n${characters}\n\nIMPORTANTE: Use essas descrições de personagens de forma consistente em todas as cenas onde eles aparecerem.` : '';

        const prompt = `Você é um especialista em criação de prompts para geração de imagens usando IA.

TAREFA:
Analise o roteiro fornecido e crie prompts detalhados para cada cena do vídeo. Cada prompt deve descrever visualmente o que deve aparecer na imagem para aquela parte do roteiro.

ROTEIRO:
"""
${script}
"""

INSTRUÇÕES:
1. Divida o roteiro em aproximadamente ${estimatedScenes} cenas (entre ${minScenes} e ${maxScenes} cenas, se necessário)
2. Cada prompt deve ter entre 600-1200 caracteres
3. Cada prompt deve ser em INGLÊS e otimizado para geração de imagens
4. Seja específico e detalhado: descreva composição, iluminação, cores, atmosfera, personagens, cenário
5. Use termos técnicos de fotografia/cinematografia quando apropriado${styleInstruction}${imageModelInstruction}${charactersInstruction}
6. Os prompts devem ser fotorealísticos e cinematográficos, a menos que especificado outro estilo

FORMATO DE RESPOSTA (JSON):
{
  "scenes": [
    {
      "scene_number": 1,
      "scene_description": "Breve descrição da cena em português",
      "prompt_text": "Prompt detalhado em inglês para geração de imagem (600-1200 caracteres)"
    },
    {
      "scene_number": 2,
      "scene_description": "Breve descrição da cena em português",
      "prompt_text": "Prompt detalhado em inglês para geração de imagem (600-1200 caracteres)"
    }
  ]
}

IMPORTANTE:
- Responda APENAS com o JSON válido, sem texto adicional
- Certifique-se de que cada prompt_text tem entre 600-1200 caracteres
- Gere EXATAMENTE ${estimatedScenes} cenas (entre ${minScenes} e ${maxScenes} cenas). NÃO pare antes de gerar todas as cenas necessárias.
- O roteiro tem aproximadamente ${wordCount} palavras, então você DEVE gerar pelo menos ${minScenes} cenas e idealmente ${estimatedScenes} cenas.
- Se a resposta ficar muito longa, continue gerando todas as cenas mesmo assim. É CRÍTICO que você gere TODAS as ${estimatedScenes} cenas solicitadas.`;

        let apiCallFunction;
        let response;
        
        if (useLaozhang && laozhangApiKey) {
            // Usar créditos (laozhang.ai)
            console.log(`[Scene Prompts] Gerando prompts com laozhang.ai (créditos) - modelo: ${model}...`);
            response = await callLaozhangAPI(prompt, laozhangApiKey, model, null, userId, 'api_call', JSON.stringify({ endpoint: '/api/generate/scene-prompts', model }));
        } else {
            // Usar API própria
            if (service === 'gemini') apiCallFunction = callGeminiAPI;
            else if (service === 'claude') apiCallFunction = callClaudeAPI;
            else apiCallFunction = callOpenAIAPI;

            console.log(`[Scene Prompts] Gerando prompts com ${service} (API própria) - modelo: ${model}...`);
            response = await apiCallFunction(prompt, decryptedKey, model);
        }

        // Parsear resposta
        let scenesData;
        let rawResponse = response;
        
        if (typeof response === 'string') {
            rawResponse = response.trim();
        } else {
            rawResponse = JSON.stringify(response);
        }
        
        console.log('[Scene Prompts] Resposta bruta (primeiros 1000 chars):', rawResponse.substring(0, 1000));
        
        // Tentar parsear diretamente
        try {
            scenesData = JSON.parse(rawResponse);
        } catch (e) {
            console.log('[Scene Prompts] Tentativa 1 de parsing falhou, tentando extrair JSON...');
            
            // Tentar extrair JSON usando regex mais robusto
            const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    scenesData = JSON.parse(jsonMatch[0]);
                } catch (e2) {
                    console.log('[Scene Prompts] Tentativa 2 de parsing falhou, tentando corrigir JSON...');
                    
                    // Tentar corrigir JSON comum (remover markdown, code blocks, etc)
                    let cleanedJson = jsonMatch[0]
                        .replace(/```json\s*/g, '')
                        .replace(/```\s*/g, '')
                        .replace(/^[^{]*/, '')
                        .replace(/[^}]*$/, '');
                    
                    try {
                        scenesData = JSON.parse(cleanedJson);
                    } catch (e3) {
                        console.log('[Scene Prompts] Tentativa 3 de parsing falhou, tentando extrair scenes diretamente...');
                        
                        // Última tentativa: procurar por "scenes" no texto
                        const scenesMatch = rawResponse.match(/"scenes"\s*:\s*\[[\s\S]*\]/);
                        if (scenesMatch) {
                            try {
                                scenesData = JSON.parse(`{${scenesMatch[0]}}`);
                            } catch (e4) {
                                console.error('[Scene Prompts] Erro no parsing:', e4.message);
                                throw new Error(`Resposta da IA não contém JSON válido. Erro: ${e4.message}`);
                            }
                        } else {
                            throw new Error(`Resposta da IA não contém JSON válido. Primeiros 500 caracteres: ${rawResponse.substring(0, 500)}`);
                        }
                    }
                }
            } else {
                throw new Error(`Nenhum JSON encontrado na resposta. Primeiros 500 caracteres: ${rawResponse.substring(0, 500)}`);
            }
        }

        // Validar estrutura - verificar se há campos aninhados (como "titles" contendo JSON string)
        if (!scenesData) {
            throw new Error('Resposta da IA está vazia ou inválida.');
        }
        
        // Se a resposta tem um campo que contém JSON string, parsear novamente
        if (scenesData.titles && typeof scenesData.titles === 'string') {
            try {
                const parsedTitles = JSON.parse(scenesData.titles);
                if (parsedTitles.scenes) {
                    scenesData = parsedTitles;
                }
            } catch (e) {
                console.log('[Scene Prompts] Campo titles não é JSON válido, continuando...');
            }
        }
        
        // Se a resposta tem um campo que contém JSON string em outro formato
        if (scenesData.content && typeof scenesData.content === 'string') {
            try {
                const parsedContent = JSON.parse(scenesData.content);
                if (parsedContent.scenes) {
                    scenesData = parsedContent;
                }
            } catch (e) {
                console.log('[Scene Prompts] Campo content não é JSON válido, continuando...');
            }
        }
        
        // Verificar se scenes existe diretamente ou em algum nível aninhado
        if (!scenesData.scenes) {
            // Procurar em todos os níveis
            const findScenes = (obj) => {
                if (Array.isArray(obj)) {
                    return obj;
                }
                if (typeof obj === 'object' && obj !== null) {
                    if (obj.scenes && Array.isArray(obj.scenes)) {
                        return obj.scenes;
                    }
                    for (const key in obj) {
                        const found = findScenes(obj[key]);
                        if (found) return found;
                    }
                }
                return null;
            };
            
            const foundScenes = findScenes(scenesData);
            if (foundScenes) {
                scenesData = { scenes: foundScenes };
            } else {
                console.error('[Scene Prompts] Estrutura de resposta inválida:', JSON.stringify(scenesData).substring(0, 1000));
                throw new Error('A IA não retornou a estrutura esperada. Verifique se a resposta contém um campo "scenes".');
            }
        }
        
        if (!Array.isArray(scenesData.scenes)) {
            console.error('[Scene Prompts] Campo scenes não é array:', typeof scenesData.scenes);
            throw new Error('O campo "scenes" da resposta não é um array válido.');
        }
        
        if (scenesData.scenes.length === 0) {
            throw new Error('A IA retornou um array de cenas vazio. Tente novamente com um roteiro mais detalhado.');
        }
        
        // Validar cada cena
        const validScenes = scenesData.scenes.filter(scene => 
            scene && 
            (scene.prompt_text || scene.prompt || scene.text) &&
            (scene.scene_description || scene.description || scene.scene_number || scene.number)
        );
        
        if (validScenes.length === 0) {
            throw new Error('Nenhuma cena válida encontrada na resposta da IA. Verifique o formato esperado.');
        }
        
        // Normalizar estrutura das cenas
        scenesData.scenes = validScenes.map((scene, index) => ({
            scene_number: scene.scene_number || scene.number || index + 1,
            scene_description: scene.scene_description || scene.description || `Cena ${index + 1}`,
            prompt_text: scene.prompt_text || scene.prompt || scene.text || ''
        }));
        
        console.log(`[Scene Prompts] ✅ ${scenesData.scenes.length} cenas parseadas com sucesso!`);
        
        // Verificar se gerou todas as cenas esperadas
        if (scenesData.scenes.length < minScenes) {
            console.warn(`[Scene Prompts] ⚠️ Apenas ${scenesData.scenes.length} cenas foram geradas, mas esperávamos pelo menos ${minScenes} cenas (estimado: ${estimatedScenes}).`);
        }

        // Função auxiliar para limpar nome do modelo (remover fornecedores)
        const cleanModelName = (model) => {
            if (!model) return 'GPT-4o';
            let clean = String(model)
                .replace(/laozhang\.ai/gi, '')
                .replace(/laozhang/gi, '')
                .replace(/openai/gi, '')
                .replace(/anthropic/gi, '')
                .replace(/google/gi, '')
                .trim();
            clean = clean.replace(/^(laozhang-|claude-|gemini-|gpt-|openai-|anthropic-)/i, '');
            clean = clean.replace(/-(laozhang|claude|gemini|gpt|openai|anthropic)$/i, '');
            // Mapear para nomes amigáveis
            if (clean.includes('gpt-4o')) return 'GPT-4o';
            if (clean.includes('claude-3-7-sonnet') || clean.includes('sonnet-3-7')) return 'Claude 3.7 Sonnet';
            if (clean.includes('claude-sonnet-4') || clean.includes('sonnet-4')) return 'Claude Sonnet 4';
            if (clean.includes('gemini-2.5-pro')) return 'Gemini 2.5 Pro';
            return clean || 'GPT-4o';
        };
        
        // Usar selectedModel se fornecido (modelo selecionado no frontend), senão usar model
        const modelToReturn = cleanModelName(selectedModel || model);
        
        res.json({
            msg: `${scenesData.scenes.length} prompts de cena gerados com sucesso!${scenesData.scenes.length < minScenes ? ` (Esperávamos ${estimatedScenes} cenas, mas apenas ${scenesData.scenes.length} foram geradas. Tente novamente ou use um modelo com maior limite de tokens.)` : ''}`,
            scenes: scenesData.scenes,
            modelUsed: modelToReturn, // Retornar apenas o nome do modelo (sem fornecedor)
            expectedScenes: estimatedScenes,
            generatedScenes: scenesData.scenes.length
        });

    } catch (err) {
        console.error('[Scene Prompts] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar prompts de cena.' });
    }
});

// Rota alternativa que SEMPRE usa Laozhang.ai
app.post('/api/generate/scene-prompts/laozhang', authenticateToken, async (req, res) => {
    const { script, style, imageModel, mode, wordsPerScene, characters, selectedModel } = req.body;
    const userId = req.user.id;

    if (!script || !script.trim()) {
        return res.status(400).json({ msg: 'O roteiro é obrigatório.' });
    }

    try {
        // SEMPRE usar laozhang.ai
        const laozhangKey = await getLaozhangApiKey();
        if (!laozhangKey) {
            return res.status(400).json({ msg: 'Provedor externo não configurado no painel admin. Configure a chave de API primeiro.' });
        }

        // Calcular número estimado de cenas baseado no modo
        const wordCount = script.trim().split(/\s+/).filter(Boolean).length;
        let estimatedScenes, minScenes, maxScenes;
        
        if (mode === 'manual' && wordsPerScene) {
            estimatedScenes = Math.max(1, Math.round(wordCount / parseInt(wordsPerScene)));
            minScenes = Math.max(1, Math.floor(wordCount / (parseInt(wordsPerScene) * 1.4)));
            maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / (parseInt(wordsPerScene) * 0.6)));
        } else {
            estimatedScenes = Math.max(1, Math.round(wordCount / 90));
            minScenes = Math.max(1, Math.floor(wordCount / 140));
            maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / 60));
        }

        // Mapeamento de estilos (mesmo da rota original)
        const styleInstructions = {
            'photorealistic': 'O estilo visual deve ser fotorealista, com detalhes perfeitos, ultra alta definição, foco nítido, fotografia profissional.',
            'cinematic': 'O estilo visual deve ser cinematográfico, com iluminação dramática, composição épica, estética de filme Hollywood.',
            'documentary': 'O estilo visual deve ser documental, natural, autêntico, com momentos reais e abordagem jornalística.',
            'cinematic-narrative': 'O estilo visual deve ser narrativo cinematográfico, focado em storytelling visual, profundidade emocional.',
            'anime': 'O estilo visual deve ser anime, com cores vibrantes, personagens expressivos, estética de animação japonesa.',
            'cartoon': 'O estilo visual deve ser desenho animado, colorido, expressivo, com estética de animação tradicional.',
            'cartoon-premium': 'O estilo visual deve ser cartoon premium, com alta qualidade de animação e design profissional.',
            'fantasy': 'O estilo visual deve ser fantasia, mágico, épico, com atmosfera encantada e elementos místicos.',
            'stick-figure': 'O estilo visual deve ser desenho de palitos, minimalista, linhas simples em fundo branco.',
            'whiteboard': 'O estilo visual deve ser animação de quadro branco, educativo, limpo, com ilustrações desenhadas à mão.',
            'tech-minimalist': 'O estilo visual deve ser tech minimalista, design limpo, estética moderna e futurista.',
            'spiritual-minimalist': 'O estilo visual deve ser espiritual minimalista, sereno, com atmosfera meditativa e zen.',
            'viral-vibrant': 'O estilo visual deve ser viral vibrante, alto contraste, cores saturadas, otimizado para redes sociais.',
            'modern-documentary': 'O estilo visual deve ser documentário moderno, dinâmico, contemporâneo, com momentos autênticos.',
            'analog-horror': 'O estilo visual deve ser terror analógico, qualidade VHS, textura granulada, estética retro de horror.',
            'dark-theater': 'O estilo visual deve ser teatro sombrio, iluminação dramática de palco, sombras intensas.',
            'naturalist-drama': 'O estilo visual deve ser drama naturalista, realista, emocional, com momentos humanos autênticos.',
            'spiritual-neorealism': 'O estilo visual deve ser neo-realismo espiritual, realismo transcendente, atmosfera mística.',
            'psychological-surrealism': 'O estilo visual deve ser surrealismo psicológico, imagens oníricas, realidade abstrata.',
            'fragmented-memory': 'O estilo visual deve ser memória fragmentada, estética de colagem, composição fragmentada.',
            'fragmented-narrative': 'O estilo visual deve ser narrativa fragmentada, estilo colagem, narrativa visual em camadas.',
            'dream-real': 'O estilo visual deve ser sonho-real, espaço liminar entre sonho e realidade, atmosfera etérea.',
            'vhs-nostalgic': 'O estilo visual deve ser VHS nostálgico, estética retro anos 80/90, qualidade vintage, grão analógico.'
        };
        
        const styleInstruction = style && style !== 'none' && styleInstructions[style] 
            ? ` ${styleInstructions[style]}` 
            : '';
        const imageModelInstruction = imageModel ? ` Os prompts devem ser otimizados para ${imageModel}.` : '';
        const charactersInstruction = characters ? `\n\nPERSONAGENS CONSISTENTES:\n${characters}\n\nIMPORTANTE: Use essas descrições de personagens de forma consistente em todas as cenas onde eles aparecerem.` : '';

        const prompt = `Você é um especialista em criação de prompts para geração de imagens usando IA.

TAREFA:
Analise o roteiro fornecido e crie prompts detalhados para cada cena do vídeo. Cada prompt deve descrever visualmente o que deve aparecer na imagem para aquela parte do roteiro.

ROTEIRO:
"""
${script}
"""

INSTRUÇÕES:
1. Divida o roteiro em aproximadamente ${estimatedScenes} cenas (entre ${minScenes} e ${maxScenes} cenas, se necessário)
2. Cada prompt deve ter entre 600-1200 caracteres
3. Cada prompt deve ser em INGLÊS e otimizado para geração de imagens
4. Seja específico e detalhado: descreva composição, iluminação, cores, atmosfera, personagens, cenário
5. Use termos técnicos de fotografia/cinematografia quando apropriado${styleInstruction}${imageModelInstruction}${charactersInstruction}
6. Os prompts devem ser fotorealísticos e cinematográficos, a menos que especificado outro estilo

FORMATO DE RESPOSTA (JSON):
{
  "scenes": [
    {
      "scene_number": 1,
      "scene_description": "Breve descrição da cena",
      "prompt_text": "Prompt detalhado em inglês para geração de imagem"
    },
    ...
  ]
}

IMPORTANTE: 
- Retorne APENAS o JSON, sem texto adicional
- Gere EXATAMENTE ${estimatedScenes} cenas (entre ${minScenes} e ${maxScenes} cenas). NÃO pare antes de gerar todas as cenas necessárias.
- O roteiro tem aproximadamente ${wordCount} palavras, então você DEVE gerar pelo menos ${minScenes} cenas e idealmente ${estimatedScenes} cenas.
- Se a resposta ficar muito longa, continue gerando todas as cenas mesmo assim. É CRÍTICO que você gere TODAS as ${estimatedScenes} cenas solicitadas.
- NÃO pare na cena 10 ou qualquer número menor. Continue até gerar todas as ${estimatedScenes} cenas.`;

        // Mapear modelo selecionado para modelo da laozhang.ai
        let laozhangModel = 'gpt-4o'; // Padrão
        if (selectedModel) {
            // Mapear modelos do frontend para modelos da laozhang.ai
            const modelMapping = {
                'gpt-4o': 'gpt-4o',
                'gpt-4o-mini': 'gpt-4o-mini',
                'gpt-4-turbo': 'gpt-4-turbo',
                'claude-3-7-sonnet-20250219': 'claude-3-7-sonnet-20250219',
                'claude-sonnet-4-20250514': 'claude-sonnet-4-20250514',
                'claude-opus-4-20250514': 'claude-opus-4-20250514',
                'gemini-2.5-pro': 'gemini-2.5-pro',
                'gemini-2.5-flash': 'gemini-2.5-flash',
                'gemini-2.0-flash': 'gemini-2.0-flash'
            };
            laozhangModel = modelMapping[selectedModel] || selectedModel; // Usar o modelo selecionado se não estiver no mapeamento
        }
        
        console.log(`[Scene Prompts] Gerando prompts usando modelo: ${laozhangModel} (selecionado: ${selectedModel || 'N/A'})...`);
        const response = await callLaozhangAPI(
            prompt, 
            laozhangKey, 
            laozhangModel, 
            null, 
            userId, 
            '/api/generate/scene-prompts', 
            JSON.stringify({ endpoint: '/api/generate/scene-prompts/laozhang', model: laozhangModel })
        );

        // Parsear resposta - callLaozhangAPI retorna string diretamente agora
        let scenesData;
        let rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        console.log(`[Scene Prompts] Resposta bruta (primeiros 500 chars):`, rawResponse.substring(0, 500));
        
        // Limpar markdown code blocks primeiro
        rawResponse = rawResponse
            .replace(/^```json\s*/i, '')  // Remover ```json no início
            .replace(/^```\s*/i, '')      // Remover ``` no início
            .replace(/\s*```\s*$/i, '')   // Remover ``` no final
            .trim();
        
        try {
            // Tentar parsear diretamente
            scenesData = JSON.parse(rawResponse);
        } catch (e) {
            console.log('[Scene Prompts] Tentativa 1 de parsing falhou, tentando extrair JSON...');
            // Tentar extrair JSON usando regex (procurar por { ... } completo)
            const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    let jsonStr = jsonMatch[0];
                    // Limpar mais caracteres problemáticos
                    jsonStr = jsonStr
                        .replace(/```json\s*/gi, '')
                        .replace(/```\s*/g, '')
                        .replace(/^[^{]*/, '')  // Remover texto antes do {
                        .replace(/[^}]*$/, ''); // Remover texto depois do }
                    
                    scenesData = JSON.parse(jsonStr);
                } catch (e2) {
                    console.log('[Scene Prompts] Tentativa 2 de parsing falhou, tentando corrigir JSON truncado...');
                    // Tentar encontrar o array de scenes diretamente
                    const scenesArrayMatch = rawResponse.match(/"scenes"\s*:\s*\[([\s\S]*?)\]/);
                    if (scenesArrayMatch) {
                        try {
                            // Tentar construir JSON válido com o array encontrado
                            let scenesArrayStr = scenesArrayMatch[1];
                            // Tentar fechar o array corretamente
                            if (!scenesArrayStr.trim().endsWith('}')) {
                                // Procurar por objetos de cena completos
                                const sceneObjects = scenesArrayStr.match(/\{[^{}]*\}/g);
                                if (sceneObjects && sceneObjects.length > 0) {
                                    scenesArrayStr = sceneObjects.join(',\n');
                                }
                            }
                            scenesData = JSON.parse(`{"scenes": [${scenesArrayStr}]}`);
                        } catch (e3) {
                            console.log('[Scene Prompts] Tentativa 3 de parsing falhou, tentando extrair cenas individuais...');
                            // Última tentativa: extrair cenas individuais parseando objetos JSON completos
                            const simpleScenePattern = /\{\s*"scene_number"\s*:\s*\d+[\s\S]*?\}/g;
                            const simpleMatches = rawResponse.match(simpleScenePattern);
                            if (simpleMatches && simpleMatches.length > 0) {
                                const parsedScenes = [];
                                for (const sceneStr of simpleMatches) {
                                    try {
                                        const scene = JSON.parse(sceneStr);
                                        if (scene.scene_number && (scene.prompt_text || scene.prompt || scene.text)) {
                                            parsedScenes.push({
                                                scene_number: scene.scene_number || scene.number || parsedScenes.length + 1,
                                                scene_description: scene.scene_description || scene.description || `Cena ${parsedScenes.length + 1}`,
                                                prompt_text: scene.prompt_text || scene.prompt || scene.text || ''
                                            });
                                        }
                                    } catch (parseErr) {
                                        console.warn('[Scene Prompts] Erro ao parsear cena individual:', parseErr.message);
                                    }
                                }
                                if (parsedScenes.length > 0) {
                                    scenesData = { scenes: parsedScenes };
                                    console.log(`[Scene Prompts] ✅ Extraídas ${parsedScenes.length} cenas parseando objetos individuais!`);
                                } else {
                                    throw new Error(`Não foi possível extrair cenas da resposta. Primeiros 1000 caracteres: ${rawResponse.substring(0, 1000)}`);
                                }
                            } else {
                                throw new Error(`Não foi possível extrair cenas da resposta. Primeiros 1000 caracteres: ${rawResponse.substring(0, 1000)}`);
                            }
                        }
                    } else {
                        throw new Error(`Nenhum JSON encontrado na resposta. Primeiros 500 caracteres: ${rawResponse.substring(0, 500)}`);
                    }
                }
            } else {
                throw new Error(`Nenhum JSON encontrado na resposta. Primeiros 500 caracteres: ${rawResponse.substring(0, 500)}`);
            }
        }

        if (!scenesData.scenes || !Array.isArray(scenesData.scenes)) {
            // Tentar encontrar scenes em diferentes níveis
            console.log('[Scene Prompts] Tentando encontrar scenes em diferentes níveis...');
            console.log('[Scene Prompts] Estrutura completa:', JSON.stringify(scenesData).substring(0, 1000));
            
            // Procurar scenes em qualquer nível
            const findScenes = (obj, path = '') => {
                if (Array.isArray(obj) && obj.length > 0 && obj[0].prompt_text) {
                    return obj;
                }
                if (typeof obj === 'object' && obj !== null) {
                    for (const key in obj) {
                        if (key === 'scenes' && Array.isArray(obj[key])) {
                            return obj[key];
                        }
                        const found = findScenes(obj[key], `${path}.${key}`);
                        if (found) return found;
                    }
                }
                return null;
            };
            
            const foundScenes = findScenes(scenesData);
            if (foundScenes && Array.isArray(foundScenes)) {
                console.log('[Scene Prompts] ✅ Scenes encontradas em nível aninhado!');
                scenesData.scenes = foundScenes;
            } else {
                throw new Error(`A IA não retornou a estrutura esperada. Verifique se a resposta contém um campo "scenes". Estrutura recebida: ${JSON.stringify(scenesData).substring(0, 500)}`);
            }
        }

        const validScenes = scenesData.scenes.filter(scene => 
            scene && 
            (scene.prompt_text || scene.prompt || scene.text) &&
            (scene.scene_description || scene.description || scene.scene_number || scene.number)
        );
        
        if (validScenes.length === 0) {
            throw new Error('Nenhuma cena válida encontrada na resposta da IA.');
        }

        scenesData.scenes = validScenes.map((scene, index) => ({
            scene_number: scene.scene_number || scene.number || (index + 1),
            scene_description: scene.scene_description || scene.description || `Cena ${index + 1}`,
            prompt_text: scene.prompt_text || scene.prompt || scene.text || ''
        }));

        console.log(`[Scene Prompts] ✅ ${scenesData.scenes.length} cenas parseadas com sucesso!`);
        
        // Verificar se gerou todas as cenas esperadas
        if (scenesData.scenes.length < minScenes) {
            console.warn(`[Scene Prompts] ⚠️ Apenas ${scenesData.scenes.length} cenas foram geradas, mas esperávamos pelo menos ${minScenes} cenas (estimado: ${estimatedScenes}).`);
        }

        // Limpar nome do modelo (remover prefixos de fornecedores)
        const cleanModelName = (model) => {
            if (!model) return 'GPT-4o';
            // Remover prefixos de fornecedores
            let clean = model.replace(/^(laozhang-|claude-|gemini-|gpt-)/i, '');
            // Mapear para nomes amigáveis
            if (clean.includes('gpt-4o')) return 'GPT-4o';
            if (clean.includes('claude-3-7-sonnet') || clean.includes('sonnet-3-7')) return 'Claude 3.7 Sonnet';
            if (clean.includes('claude-sonnet-4') || clean.includes('sonnet-4')) return 'Claude Sonnet 4';
            if (clean.includes('gemini-2.5-pro')) return 'Gemini 2.5 Pro';
            if (clean.includes('gemini-2.5-flash')) return 'Gemini 2.5 Flash';
            return clean || 'GPT-4o';
        };
        
        const modelToReturn = cleanModelName(selectedModel || 'gpt-4o');
        
        res.json({
            msg: `${scenesData.scenes.length} prompts de cena gerados com sucesso!${scenesData.scenes.length < minScenes ? ` (Esperávamos ${estimatedScenes} cenas, mas apenas ${scenesData.scenes.length} foram geradas. Tente novamente.)` : ''}`,
            scenes: scenesData.scenes,
            modelUsed: modelToReturn, // Retornar apenas o nome do modelo (sem fornecedor)
            expectedScenes: estimatedScenes,
            generatedScenes: scenesData.scenes.length
        });

    } catch (err) {
        console.error('[Scene Prompts] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar prompts de cena.' });
    }
});

// === ROTAS DE HISTÓRICO DE PROMPTS DE CENA ===

// Salvar no histórico
app.post('/api/scene-prompts/history', authenticateToken, async (req, res) => {
    const { script, scenes, model, style, mode, wordsPerScene, characters, title } = req.body;
    const userId = req.user.id;

    if (!script || !scenes || !Array.isArray(scenes)) {
        return res.status(400).json({ msg: 'Script e cenas são obrigatórios.' });
    }

    try {
        // Garantir que a tabela existe
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        const result = await db.run(
            `INSERT INTO scene_prompts_history 
             (user_id, title, script, scenes_json, model, style, mode, words_per_scene, characters, scene_count)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
                userId,
                title || `Prompts gerados em ${new Date().toLocaleString('pt-BR')}`,
                script,
                JSON.stringify(scenes),
                model || null,
                style || null,
                mode || 'automatic',
                wordsPerScene || null,
                characters || null,
                scenes.length
            ]
        );

        res.json({ msg: 'Histórico salvo com sucesso!', id: result.lastID });
    } catch (err) {
        console.error('[Scene Prompts History] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao salvar histórico.' });
    }
});

// Listar histórico
app.get('/api/scene-prompts/history', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { limit = 20 } = req.query;

    try {
        // Garantir que a tabela existe
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        const history = await db.all(
            `SELECT id, title, scene_count, model, style, mode, created_at 
             FROM scene_prompts_history 
             WHERE user_id = ? 
             ORDER BY created_at DESC 
             LIMIT ?`,
            [userId, parseInt(limit)]
        );

        res.json({ history: history || [] });
    } catch (err) {
        console.error('[Scene Prompts History] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao carregar histórico.' });
    }
});

// Carregar prompt específico
app.get('/api/scene-prompts/history/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;

    try {
        // Garantir que a tabela existe
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        const item = await db.get(
            `SELECT * FROM scene_prompts_history WHERE id = ? AND user_id = ?`,
            [id, userId]
        );

        if (!item) {
            return res.status(404).json({ msg: 'Prompt não encontrado.' });
        }

        res.json({
            id: item.id,
            title: item.title,
            script: item.script,
            scenes: JSON.parse(item.scenes_json),
            model: item.model,
            style: item.style,
            mode: item.mode,
            wordsPerScene: item.words_per_scene,
            characters: item.characters,
            scene_count: item.scene_count,
            created_at: item.created_at
        });
    } catch (err) {
        console.error('[Scene Prompts History] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao carregar prompt.' });
    }
});

// Deletar prompt do histórico
app.delete('/api/scene-prompts/history/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;

    try {
        // Garantir que a tabela existe
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        const result = await db.run(
            `DELETE FROM scene_prompts_history WHERE id = ? AND user_id = ?`,
            [id, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Prompt não encontrado.' });
        }

        res.json({ msg: 'Prompt excluído com sucesso!' });
    } catch (err) {
        console.error('[Scene Prompts History] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao excluir prompt.' });
    }
});

// === ROTA PARA DETECTAR PERSONAGENS NO ROTEIRO ===
app.post('/api/detect/characters', authenticateToken, async (req, res) => {
    const { script, model } = req.body;
    const userId = req.user.id;

    if (!script || !script.trim()) {
        return res.status(400).json({ msg: 'O roteiro é obrigatório.' });
    }

    if (!model) {
        return res.status(400).json({ msg: 'O modelo de IA é obrigatório.' });
    }

    try {
        // Determinar qual serviço usar baseado no modelo
        let service = 'gemini';
        if (model.includes('claude') || model.includes('sonnet')) {
            service = 'claude';
        } else if (model.includes('gpt') || model.includes('openai')) {
            service = 'openai';
        }

        // Buscar chave de API
        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
        if (!keyData) {
            return res.status(400).json({ msg: `Chave de API do ${service} não configurada. Configure nas Configurações.` });
        }

        const decryptedKey = decrypt(keyData.api_key);
        if (!decryptedKey) {
            return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
        }

        const prompt = `Você é um diretor de elenco especializado em analisar roteiros e identificar personagens para geração de imagens com IA.

**ROTEIRO PARA ANALISAR:**
${script}

---

**INSTRUÇÕES:**
1. Identifique todos os personagens principais e secundários mencionados no roteiro.
2. Para cada personagem, crie uma descrição concisa e prática que inclua:
   - Nome do personagem (ou descrição se não tiver nome)
   - Idade aparente
   - Aparência física (cor de cabelo, olhos, tipo físico, traços distintivos)
   - Vestimentas principais
   - Características visuais importantes para manter consistência

3. **FORMATO DE SAÍDA OBRIGATÓRIO:** Você DEVE retornar um objeto JSON com a seguinte estrutura exata:
{
  "characters": [
    "Nome, idade, descrição física e características visuais",
    "Outro personagem, idade, descrição física e características visuais"
  ]
}

**EXEMPLO DE FORMATO:**
{
  "characters": [
    "João, um homem de 40 anos, cabelo grisalho, óculos, rosto marcado, vestindo terno escuro",
    "Maria, uma jovem de 25 anos, cabelo longo e ruivo, olhos verdes, vestindo vestido casual"
  ]
}

**REGRA CRÍTICA:**
- Retorne APENAS o JSON válido, sem texto adicional antes ou depois
- Cada string no array deve ser uma descrição completa e prática do personagem
- Foque em características visuais que ajudem a manter consistência nas imagens geradas
- Se um personagem não tem nome, use uma descrição clara (ex: "Policial veterano, 50 anos, cabelo grisalho curto, uniforme azul")
- Limite a descrição de cada personagem a uma linha, mas seja completo e detalhado
- Retorne no formato JSON exato especificado acima, com a propriedade "characters" contendo um array de strings

**AGORA ANALISE O ROTEIRO FORNECIDO E RETORNE O JSON COM OS PERSONAGENS IDENTIFICADOS:**`;

        let apiCallFunction;
        if (service === 'gemini') apiCallFunction = callGeminiAPI;
        else if (service === 'claude') apiCallFunction = callClaudeAPI;
        else apiCallFunction = callOpenAIAPI;

        console.log(`[Detect Characters] Detectando personagens com ${service} (modelo: ${model})...`);
        const rawResponse = await apiCallFunction(prompt, decryptedKey, model);

        // Parse robusto da resposta
        let characters = [];
        let parsedData = null;

        // Tentar extrair JSON da resposta
        if (typeof rawResponse === 'string') {
            try {
                parsedData = JSON.parse(rawResponse);
            } catch (e) {
                // Tentar extrair JSON de dentro de markdown ou texto
                const jsonMatch = rawResponse.match(/\{[\s\S]*"characters"[\s\S]*\[[\s\S]*\][\s\S]*\}/);
                if (jsonMatch) {
                    try {
                        parsedData = JSON.parse(jsonMatch[0]);
                    } catch (e2) {
                        console.warn('[Detect Characters] Erro ao parsear JSON extraído:', e2);
                    }
                }
            }
        } else {
            parsedData = rawResponse;
        }

        // Extrair characters de diferentes estruturas possíveis
        if (parsedData) {
            // Caso 1: { characters: [...] }
            if (parsedData.characters && Array.isArray(parsedData.characters)) {
                characters = parsedData.characters;
            }
            // Caso 2: { data: { characters: [...] } }
            else if (parsedData.data && parsedData.data.characters && Array.isArray(parsedData.data.characters)) {
                characters = parsedData.data.characters;
            }
            // Caso 3: { data: [...] }
            else if (parsedData.data && Array.isArray(parsedData.data)) {
                characters = parsedData.data;
            }
            // Caso 4: { titles: "..." } - tentar parsear o conteúdo
            else if (parsedData.titles && typeof parsedData.titles === 'string') {
                try {
                    const titlesParsed = JSON.parse(parsedData.titles);
                    if (titlesParsed.characters && Array.isArray(titlesParsed.characters)) {
                        characters = titlesParsed.characters;
                    } else if (Array.isArray(titlesParsed)) {
                        characters = titlesParsed;
                    }
                } catch (e) {
                    // Tentar extrair JSON do texto
                    const jsonMatch = parsedData.titles.match(/\{[\s\S]*"characters"[\s\S]*\[[\s\S]*\][\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            const extracted = JSON.parse(jsonMatch[0]);
                            if (extracted.characters && Array.isArray(extracted.characters)) {
                                characters = extracted.characters;
                            }
                        } catch (e2) {
                            console.warn('[Detect Characters] Erro ao parsear JSON de titles:', e2);
                        }
                    }
                }
            }
            // Caso 5: Buscar qualquer array no objeto
            else {
                for (const key in parsedData) {
                    if (Array.isArray(parsedData[key])) {
                        characters = parsedData[key];
                        break;
                    }
                }
            }
        }

        // Filtrar e limpar personagens
        if (characters.length > 0) {
            characters = characters
                .filter(char => char && typeof char === 'string' && char.trim().length > 0)
                .map(char => char.trim());
        }

        if (characters.length === 0) {
            return res.status(400).json({ 
                msg: 'Nenhum personagem foi detectado. Verifique se o roteiro contém personagens identificáveis.',
                characters: '',
                charactersList: []
            });
        }

        // Formatar para o campo de texto (uma linha por personagem)
        const charactersText = characters.join('\n');

        console.log(`[Detect Characters] ✅ ${characters.length} personagem(ns) detectado(s)!`);

        res.json({
            msg: `${characters.length} personagem(ns) detectado(s) com sucesso!`,
            characters: charactersText,
            charactersList: characters
        });

    } catch (err) {
        console.error('[Detect Characters] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao detectar personagens.' });
    }
});

// === ROTA LAOZHANG PARA DETECÇÃO DE PERSONAGENS ===
app.post('/api/detect/characters/laozhang', authenticateToken, async (req, res) => {
    const { script, selectedModel } = req.body;
    const userId = req.user.id;

    if (!script || !script.trim()) {
        return res.status(400).json({ msg: 'O roteiro é obrigatório.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Mapear modelo selecionado para modelo Laozhang
        // Se não houver modelo selecionado, usar GPT-4o como padrão
        const laozhangModel = selectedModel === 'Claude 3.7 Sonnet (Fev/25)' ? 'claude-3-7-sonnet-20250219' :
                             selectedModel === 'Gemini 2.5 Pro (2025)' ? 'gemini-2.5-pro' :
                             (!selectedModel || !selectedModel.trim()) ? 'gpt-4o' : selectedModel;

        const prompt = `Você é um diretor de elenco especializado em analisar roteiros e identificar personagens para geração de imagens com IA.

**ROTEIRO PARA ANALISAR:**
${script}

---

**INSTRUÇÕES:**
1. Identifique todos os personagens principais e secundários mencionados no roteiro.
2. Para cada personagem, crie uma descrição concisa e prática que inclua:
   - Nome do personagem (ou descrição se não tiver nome)
   - Idade aparente
   - Aparência física (cor de cabelo, olhos, tipo físico, traços distintivos)
   - Vestimentas principais
   - Características visuais importantes para manter consistência

3. **FORMATO DE SAÍDA OBRIGATÓRIO:** Você DEVE retornar um objeto JSON com a seguinte estrutura exata:
{
  "characters": [
    "Nome, idade, descrição física e características visuais",
    "Outro personagem, idade, descrição física e características visuais"
  ]
}

**EXEMPLO DE FORMATO:**
{
  "characters": [
    "João, um homem de 40 anos, cabelo grisalho, óculos, rosto marcado, vestindo terno escuro",
    "Maria, uma jovem de 25 anos, cabelo longo e ruivo, olhos verdes, vestindo vestido casual"
  ]
}

**REGRA CRÍTICA:**
- Retorne APENAS o JSON válido, sem texto adicional antes ou depois
- Cada string no array deve ser uma descrição completa e prática do personagem
- Foque em características visuais que ajudem a manter consistência nas imagens geradas
- Se um personagem não tem nome, use uma descrição clara (ex: "Policial veterano, 50 anos, cabelo grisalho curto, uniforme azul")
- Limite a descrição de cada personagem a uma linha, mas seja completo e detalhado
- Retorne no formato JSON exato especificado acima, com a propriedade "characters" contendo um array de strings

**AGORA ANALISE O ROTEIRO FORNECIDO E RETORNE O JSON COM OS PERSONAGENS IDENTIFICADOS:**`;

        console.log(`[Detect Characters Laozhang] Detectando personagens com modelo: ${laozhangModel}...`);
        const response = await callLaozhangAPI(
            prompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_detect_characters',
            JSON.stringify({ endpoint: '/api/detect/characters/laozhang', model: laozhangModel })
        );

        // Parse robusto da resposta
        let characters = [];
        let parsedData = null;

        // Tentar extrair JSON da resposta
        const rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        try {
            parsedData = JSON.parse(rawResponse);
        } catch (e) {
            // Tentar extrair JSON de dentro de markdown ou texto
            const jsonMatch = rawResponse.match(/\{[\s\S]*"characters"[\s\S]*\[[\s\S]*\][\s\S]*\}/);
            if (jsonMatch) {
                try {
                    parsedData = JSON.parse(jsonMatch[0]);
                } catch (e2) {
                    console.warn('[Detect Characters Laozhang] Erro ao parsear JSON extraído:', e2);
                }
            }
        }

        // Extrair characters de diferentes estruturas possíveis
        if (parsedData) {
            if (parsedData.characters && Array.isArray(parsedData.characters)) {
                characters = parsedData.characters;
            } else if (parsedData.data && parsedData.data.characters && Array.isArray(parsedData.data.characters)) {
                characters = parsedData.data.characters;
            } else if (parsedData.data && Array.isArray(parsedData.data)) {
                characters = parsedData.data;
            }
        }

        // Filtrar e limpar personagens
        if (characters.length > 0) {
            characters = characters
                .filter(char => char && typeof char === 'string' && char.trim().length > 0)
                .map(char => char.trim());
        }

        if (characters.length === 0) {
            return res.status(400).json({ 
                msg: 'Nenhum personagem foi detectado. Verifique se o roteiro contém personagens identificáveis.',
                characters: '',
                charactersList: []
            });
        }

        // Formatar para o campo de texto (uma linha por personagem)
        const charactersText = characters.join('\n');

        console.log(`[Detect Characters Laozhang] ✅ ${characters.length} personagem(ns) detectado(s)!`);

        res.json({
            msg: `${characters.length} personagem(ns) detectado(s) com sucesso!`,
            characters: charactersText,
            charactersList: characters
        });

    } catch (err) {
        console.error('[Detect Characters Laozhang] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao detectar personagens.' });
    }
});

// === ROTA PARA REESCREVER PROMPT BLOQUEADO ===
app.post('/api/rewrite/blocked-prompt', authenticateToken, async (req, res) => {
    const { prompt, model } = req.body;
    const userId = req.user.id;

    if (!prompt || !prompt.trim()) {
        return res.status(400).json({ msg: 'O prompt é obrigatório.' });
    }

    try {
        const selectedModel = model || 'gpt-4o';
        let service = 'gemini';
        if (selectedModel.includes('claude') || selectedModel.includes('sonnet')) {
            service = 'claude';
        } else if (selectedModel.includes('gpt') || selectedModel.includes('openai')) {
            service = 'openai';
        }

        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
        if (!keyData) {
            return res.status(400).json({ msg: `Chave de API do ${service} não configurada.` });
        }

        const decryptedKey = decrypt(keyData.api_key);
        if (!decryptedKey) {
            return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
        }

        const rewritePrompt = `O prompt a seguir foi bloqueado por violar políticas de conteúdo. Reescreva-o mantendo a essência visual, história e estilo, mas removendo qualquer conteúdo que possa ser considerado inseguro ou inadequado. O prompt reescrito deve ser em INGLÊS e otimizado para geração de imagens.

PROMPT ORIGINAL:
"""${prompt}"""

INSTRUÇÕES:
1. Mantenha a essência visual, composição e estilo do prompt original
2. Remova qualquer referência a violência, conteúdo adulto ou conteúdo inadequado
3. Mantenha a narrativa e a atmosfera geral
4. O prompt reescrito deve ter entre 600-1200 caracteres
5. Responda APENAS com o prompt reescrito, sem explicações adicionais

PROMPT REWRITTEN:`;

        let apiCallFunction;
        if (service === 'gemini') apiCallFunction = callGeminiAPI;
        else if (service === 'claude') apiCallFunction = callClaudeAPI;
        else apiCallFunction = callOpenAIAPI;

        const response = await apiCallFunction(rewritePrompt, decryptedKey, selectedModel);
        
        let rewrittenText = '';
        if (typeof response === 'string') {
            rewrittenText = response.trim();
        } else if (response.titles) {
            rewrittenText = response.titles;
        } else if (response.text) {
            rewrittenText = response.text;
        }
        
        // Limpar o texto
        rewrittenText = rewrittenText
            .replace(/```[\s\S]*?```/g, '')
            .replace(/`/g, '')
            .replace(/^[^"]*["']|["'][^"]*$/g, '')
            .replace(/^(Prompt|Prompt reformulado|Nova versão|Versão reformulada|PROMPT REWRITTEN)[:：]\s*/i, '')
            .replace(/\n+/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
        
        if (!rewrittenText || rewrittenText.length < 50) {
            throw new Error('Prompt reescrito inválido ou muito curto');
        }
        
        // Adicionar sufixos de qualidade se não estiverem presentes
        if (!rewrittenText.includes('photorealistic')) {
            rewrittenText += ', photorealistic, hyperrealistic, cinematic, 8k, ultra high definition, sharp focus, professional photography';
        }

        res.json({
            msg: 'Prompt reescrito com sucesso!',
            rewrittenPrompt: rewrittenText
        });

    } catch (err) {
        console.error('[Rewrite Prompt] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao reescrever prompt.' });
    }
});

// === ROTA LAOZHANG PARA REESCREVER PROMPT BLOQUEADO ===
app.post('/api/rewrite/blocked-prompt/laozhang', authenticateToken, async (req, res) => {
    const { prompt, selectedModel } = req.body;
    const userId = req.user.id;

    if (!prompt || !prompt.trim()) {
        return res.status(400).json({ msg: 'O prompt é obrigatório.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Mapear modelo selecionado para modelo Laozhang
        // Se não houver modelo selecionado, usar GPT-4o como padrão
        const laozhangModel = selectedModel === 'Claude 3.7 Sonnet (Fev/25)' ? 'claude-3-7-sonnet-20250219' :
                             selectedModel === 'Gemini 2.5 Pro (2025)' ? 'gemini-2.5-pro' :
                             (!selectedModel || !selectedModel.trim()) ? 'gpt-4o' : selectedModel;

        const rewritePrompt = `O prompt a seguir foi bloqueado por violar políticas de conteúdo. Reescreva-o mantendo a essência visual, história e estilo, mas removendo qualquer conteúdo que possa ser considerado inseguro ou inadequado. O prompt reescrito deve ser em INGLÊS e otimizado para geração de imagens.

PROMPT ORIGINAL:
"""${prompt}"""

INSTRUÇÕES:
1. Mantenha a essência visual, composição e estilo do prompt original
2. Remova qualquer referência a violência, conteúdo adulto ou conteúdo inadequado
3. Mantenha a narrativa e a atmosfera geral
4. O prompt reescrito deve ter entre 600-1200 caracteres
5. Responda APENAS com o prompt reescrito, sem explicações adicionais

PROMPT REWRITTEN:`;

        const response = await callLaozhangAPI(
            rewritePrompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_rewrite_prompt',
            JSON.stringify({ endpoint: '/api/rewrite/blocked-prompt/laozhang', model: laozhangModel })
        );
        
        let rewrittenText = '';
        if (typeof response === 'string') {
            rewrittenText = response.trim();
        } else if (response.titles) {
            rewrittenText = response.titles;
        } else if (response.text) {
            rewrittenText = response.text;
        }
        
        // Limpar o texto
        rewrittenText = rewrittenText
            .replace(/```[\s\S]*?```/g, '')
            .replace(/`/g, '')
            .replace(/^[^"]*["']|["'][^"]*$/g, '')
            .replace(/^(Prompt|Prompt reformulado|Nova versão|Versão reformulada|PROMPT REWRITTEN)[:：]\s*/i, '')
            .replace(/\n+/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
        
        if (!rewrittenText || rewrittenText.length < 50) {
            throw new Error('Prompt reescrito inválido ou muito curto');
        }
        
        // Adicionar sufixos de qualidade se não estiverem presentes
        if (!rewrittenText.includes('photorealistic')) {
            rewrittenText += ', photorealistic, hyperrealistic, cinematic, 8k, ultra high definition, sharp focus, professional photography';
        }

        res.json({
            msg: 'Prompt reescrito com sucesso!',
            rewrittenPrompt: rewrittenText
        });

    } catch (err) {
        console.error('[Rewrite Prompt Laozhang] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao reescrever prompt.' });
    }
});

// === ROTA PARA REGENERAR IMAGEM COM PROMPT EDITADO ===
app.post('/api/generate/imagefx/regenerate', authenticateToken, async (req, res) => {
    const { prompt, aspectRatio, style } = req.body;
    const userId = req.user.id;

    if (!prompt) {
        return res.status(400).json({ msg: 'O prompt é obrigatório.' });
    }

    try {
        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'imagefx']);
        if (!keyData) {
            return res.status(400).json({ msg: 'Cookies do ImageFX não configurados. Salve-os nas Configurações.' });
        }
        
        const decryptedCookies = decrypt(keyData.api_key);
        if (!decryptedCookies) {
            return res.status(500).json({ msg: 'Falha ao desencriptar os seus cookies.' });
        }
        
        const imageFx = new ImageFX(decryptedCookies);
        
        // Mapeamento de estilos (mesmo do generate/imagefx)
        const styleSuffixes = {
            'photorealistic': 'photorealistic, hyperrealistic, ultra high definition, 8k, sharp focus, professional photography, taken with a high-end camera like a Sony α7 IV, detailed skin texture, natural lighting',
            'cinematic': 'cinematic, dramatic lighting, film grain, anamorphic lens, color grading, movie still, Hollywood style, epic composition',
            'documentary': 'documentary style, natural lighting, authentic, candid photography, real moments, journalistic approach, raw and unfiltered',
            'cinematic-narrative': 'cinematic narrative, storytelling composition, dramatic angles, emotional depth, visual storytelling, film photography',
            'anime': 'anime style, Japanese animation, vibrant colors, expressive characters, detailed backgrounds, manga-inspired, cel-shaded',
            'cartoon': 'cartoon style, animated, colorful, expressive, playful, hand-drawn aesthetic, vibrant palette',
            'cartoon-premium': 'premium cartoon style, high-quality animation, detailed character design, rich colors, professional animation studio quality',
            'fantasy': 'fantasy art, magical atmosphere, epic scale, mystical lighting, enchanted, otherworldly, detailed fantasy illustration',
            'stick-figure': 'stick figure style, minimalist line art, simple black lines on white background, clean and minimal',
            'whiteboard': 'whiteboard animation style, clean white background, hand-drawn illustrations, educational, clear and simple',
            'tech-minimalist': 'tech minimalist, clean design, modern aesthetic, geometric shapes, minimal color palette, futuristic, sleek',
            'spiritual-minimalist': 'spiritual minimalist, serene atmosphere, soft lighting, peaceful composition, meditative, zen aesthetic',
            'viral-vibrant': 'viral vibrant style, high contrast, saturated colors, bold composition, eye-catching, social media optimized, vibrant and energetic',
            'modern-documentary': 'modern documentary style, contemporary aesthetic, dynamic composition, real-world setting, authentic moments',
            'analog-horror': 'analog horror aesthetic, VHS quality, grainy texture, retro horror, distorted colors, unsettling atmosphere, 80s/90s horror',
            'dark-theater': 'dark theater style, dramatic stage lighting, theatrical composition, intense shadows, dramatic performance',
            'naturalist-drama': 'naturalist drama, realistic emotional scenes, natural lighting, authentic human moments, raw emotion',
            'spiritual-neorealism': 'spiritual neorealism, transcendent realism, ethereal lighting, spiritual atmosphere, mystical realism',
            'psychological-surrealism': 'psychological surrealism, dreamlike imagery, surreal composition, psychological depth, abstract reality',
            'fragmented-memory': 'fragmented memory style, collage aesthetic, fragmented composition, memory-like quality, layered imagery',
            'fragmented-narrative': 'fragmented narrative, collage style, mixed media, layered storytelling, fragmented visual narrative',
            'dream-real': 'dream-real style, liminal space between dream and reality, surreal realism, ethereal atmosphere, dreamlike quality',
            'vhs-nostalgic': 'VHS nostalgic, retro 80s/90s aesthetic, vintage quality, nostalgic colors, retro film grain, analog feel'
        };
        
        // Obter sufixo do estilo ou usar padrão
        const styleSuffix = (style && styleSuffixes[style]) ? styleSuffixes[style] : styleSuffixes['photorealistic'];
        let currentPrompt = `${prompt}, ${styleSuffix}`;
        
        const aspectRatioMap = {
            '16:9': AspectRatio.LANDSCAPE,
            '9:16': AspectRatio.PORTRAIT,
            '1:1': AspectRatio.SQUARE
        };
        
        const results = await imageFx.generateImage(currentPrompt, {
            numberOfImages: 1,
            aspectRatio: aspectRatioMap[aspectRatio || '16:9'] || AspectRatio.LANDSCAPE,
            resizeTo16_9: (aspectRatio || '16:9') === '16:9'
        });

        if (!results || results.length === 0) {
            throw new Error('A API não retornou imagens.');
        }

        const imageData = results[0];
        const imageUrl = imageData.url || `data:image/png;base64,${imageData.base64 || ''}`;
        const imageBase64 = imageData.base64 || (imageUrl.startsWith('data:') ? imageUrl.split(',')[1] : null);

        res.status(200).json({ 
            msg: 'Imagem regenerada com sucesso!',
            image: imageBase64 || imageUrl,
            imageUrl: imageUrl,
            prompt: currentPrompt
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/generate/imagefx/regenerate]:', err);
        
        if (err instanceof AccountError || err.message?.includes('cookie') || err.message?.includes('autenticação')) {
            return res.status(401).json({ 
                msg: 'Cookies do ImageFX expirados ou inválidos. Por favor, atualize os cookies nas Configurações.',
                requiresAuth: true
            });
        }
        
        res.status(500).json({ msg: err.message || 'Erro ao regenerar imagem.' });
    }
});

// === ROTA PARA GERAR MÚLTIPLAS IMAGENS (BATCH) ===
app.post('/api/generate/imagefx/batch', authenticateToken, async (req, res) => {
    const { prompts, style, aspectRatio } = req.body;
    const userId = req.user.id;

    if (!prompts || !Array.isArray(prompts) || prompts.length === 0) {
        return res.status(400).json({ msg: 'Uma lista de prompts é obrigatória.' });
    }

    try {
        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'imagefx']);
        if (!keyData) {
            return res.status(400).json({ msg: 'Cookies do ImageFX não configurados. Salve-os nas Configurações.' });
        }
        
        const decryptedCookies = decrypt(keyData.api_key);
        if (!decryptedCookies) {
            return res.status(500).json({ msg: 'Falha ao desencriptar os seus cookies.' });
        }
        
        const imageFx = new ImageFX(decryptedCookies);
        const results = [];
        const errors = [];

        // Gerar imagens em paralelo (máximo 3 por vez para evitar rate limit)
        const batchSize = 3;
        for (let i = 0; i < prompts.length; i += batchSize) {
            const batch = prompts.slice(i, i + batchSize);
            const batchPromises = batch.map(async (prompt, index) => {
                try {
                    const fullPrompt = `${prompt}, photorealistic, hyperrealistic, cinematic, 8k, ultra high definition, sharp focus, professional photography, taken with a high-end camera like a Sony α7 IV, detailed skin texture, natural lighting`;
                    
                    const aspectRatioMap = {
                        '16:9': AspectRatio.LANDSCAPE,
                        '9:16': AspectRatio.PORTRAIT,
                        '1:1': AspectRatio.SQUARE
                    };
                    
                    const images = await imageFx.generateImage(fullPrompt, {
                        aspectRatio: aspectRatioMap[aspectRatio || '16:9'] || AspectRatio.LANDSCAPE,
                        numberOfImages: 1,
                        resizeTo16_9: (aspectRatio || '16:9') === '16:9'
                    });
                    
                    if (images && images.length > 0) {
                        return {
                            prompt: prompt,
                            image: images[0].getImageData(),
                            sceneNumber: i + index + 1,
                            success: true
                        };
                    }
                    throw new Error('Nenhuma imagem gerada');
                } catch (error) {
                    return {
                        prompt: prompt,
                        error: error.message,
                        sceneNumber: i + index + 1,
                        success: false
                    };
                }
            });

            const batchResults = await Promise.all(batchPromises);
            results.push(...batchResults);
        }

        const successCount = results.filter(r => r.success).length;
        const failCount = results.filter(r => !r.success).length;

        res.json({
            msg: `${successCount} imagem(ns) gerada(s) com sucesso${failCount > 0 ? `, ${failCount} falha(s)` : ''}`,
            results: results,
            successCount,
            failCount
        });

    } catch (err) {
        console.error('[ImageFX Batch] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar imagens em lote.' });
    }
});


// === ROTA PARA GERAR IMAGEM COM IMAGEFX ===
app.post('/api/generate/imagefx', authenticateToken, async (req, res) => {
    const { prompt, niche, subniche, style, saveToLibrary } = req.body;
    const userId = req.user.id;

    if (!prompt) {
        return res.status(400).json({ msg: 'Um prompt (descrição da thumbnail) é obrigatório.' });
    }

    try {
        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'imagefx']);
        if (!keyData) {
            return res.status(400).json({ msg: 'Cookies do ImageFX não configurados. Salve-os nas Configurações.' });
        }
        
        const decryptedCookies = decrypt(keyData.api_key);
        if (!decryptedCookies) {
            return res.status(500).json({ msg: 'Falha ao desencriptar os seus cookies.' });
        }
        
        console.log('[ImageFX] A iniciar geração...');
        const imageFx = new ImageFX(decryptedCookies);
        
        // Mapeamento de estilos para sufixos de prompt
        const styleSuffixes = {
            'photorealistic': 'photorealistic, hyperrealistic, ultra high definition, 8k, sharp focus, professional photography, taken with a high-end camera like a Sony α7 IV, detailed skin texture, natural lighting',
            'cinematic': 'cinematic, dramatic lighting, film grain, anamorphic lens, color grading, movie still, Hollywood style, epic composition',
            'documentary': 'documentary style, natural lighting, authentic, candid photography, real moments, journalistic approach, raw and unfiltered',
            'cinematic-narrative': 'cinematic narrative, storytelling composition, dramatic angles, emotional depth, visual storytelling, film photography',
            'anime': 'anime style, Japanese animation, vibrant colors, expressive characters, detailed backgrounds, manga-inspired, cel-shaded',
            'cartoon': 'cartoon style, animated, colorful, expressive, playful, hand-drawn aesthetic, vibrant palette',
            'cartoon-premium': 'premium cartoon style, high-quality animation, detailed character design, rich colors, professional animation studio quality',
            'fantasy': 'fantasy art, magical atmosphere, epic scale, mystical lighting, enchanted, otherworldly, detailed fantasy illustration',
            'stick-figure': 'stick figure style, minimalist line art, simple black lines on white background, clean and minimal',
            'whiteboard': 'whiteboard animation style, clean white background, hand-drawn illustrations, educational, clear and simple',
            'tech-minimalist': 'tech minimalist, clean design, modern aesthetic, geometric shapes, minimal color palette, futuristic, sleek',
            'spiritual-minimalist': 'spiritual minimalist, serene atmosphere, soft lighting, peaceful composition, meditative, zen aesthetic',
            'viral-vibrant': 'viral vibrant style, high contrast, saturated colors, bold composition, eye-catching, social media optimized, vibrant and energetic',
            'modern-documentary': 'modern documentary style, contemporary aesthetic, dynamic composition, real-world setting, authentic moments',
            'analog-horror': 'analog horror aesthetic, VHS quality, grainy texture, retro horror, distorted colors, unsettling atmosphere, 80s/90s horror',
            'dark-theater': 'dark theater style, dramatic stage lighting, theatrical composition, intense shadows, dramatic performance',
            'naturalist-drama': 'naturalist drama, realistic emotional scenes, natural lighting, authentic human moments, raw emotion',
            'spiritual-neorealism': 'spiritual neorealism, transcendent realism, ethereal lighting, spiritual atmosphere, mystical realism',
            'psychological-surrealism': 'psychological surrealism, dreamlike imagery, surreal composition, psychological depth, abstract reality',
            'fragmented-memory': 'fragmented memory style, collage aesthetic, fragmented composition, memory-like quality, layered imagery',
            'fragmented-narrative': 'fragmented narrative, collage style, mixed media, layered storytelling, fragmented visual narrative',
            'dream-real': 'dream-real style, liminal space between dream and reality, surreal realism, ethereal atmosphere, dreamlike quality',
            'vhs-nostalgic': 'VHS nostalgic, retro 80s/90s aesthetic, vintage quality, nostalgic colors, retro film grain, analog feel'
        };
        
        // Obter sufixo do estilo ou usar padrão
        const styleSuffix = styleSuffixes[style] || styleSuffixes['photorealistic'];
        let currentPrompt = `${prompt}, ${styleSuffix}`;
        
        const maxRetries = 5;
        let attempt = 0;
        let images = null;
        let lastError = null;
        
        // Função para detectar se o erro é de política de conteúdo
        const isPolicyError = (error) => {
            if (!error || !error.message) return false;
            const errorStr = error.message.toLowerCase();
            const errorCode = error.code;
            
            return (
                errorCode === 400 && (
                    errorStr.includes('bloqueado') ||
                    errorStr.includes('conteúdo inseguro') ||
                    errorStr.includes('public_error') ||
                    errorStr.includes('prominent_people') ||
                    errorStr.includes('filter_failed') ||
                    errorStr.includes('policy') ||
                    errorStr.includes('unsafe')
                )
            );
        };
        
        // Função para reformular o prompt usando IA
        const reformulatePrompt = async (originalPrompt, errorMessage) => {
            try {
                const services = ['gemini', 'claude', 'openai'];
                let reformulatedPrompt = null;
                
                for (const service of services) {
                    try {
                        const serviceKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                        if (!serviceKeyData) continue;
                        
                        const decryptedKey = decrypt(serviceKeyData.api_key);
                        if (!decryptedKey) continue;
                        
                        let apiCallFunction;
                        let model;
                        if (service === 'gemini') {
                            apiCallFunction = callGeminiAPI;
                            model = 'gemini-2.0-flash';
                        } else if (service === 'claude') {
                            apiCallFunction = callClaudeAPI;
                            model = 'claude-3-5-haiku-20241022';
                        } else {
                            apiCallFunction = callOpenAIAPI;
                            model = 'gpt-4o-mini';
                        }
                        
                        const reformulationPrompt = `O prompt a seguir foi bloqueado por violar políticas de conteúdo. Reescreva-o mantendo a essência visual, história e estilo, mas removendo qualquer conteúdo que possa ser considerado inseguro ou inadequado. O prompt reescrito deve ser em INGLÊS e otimizado para geração de imagens.

PROMPT ORIGINAL:
"""${originalPrompt}"""

INSTRUÇÕES:
1. Mantenha a essência visual, composição e estilo do prompt original
2. Remova qualquer referência a violência, conteúdo adulto ou conteúdo inadequado
3. Mantenha a narrativa e a atmosfera geral
4. O prompt reescrito deve ter entre 600-1200 caracteres
5. Responda APENAS com o prompt reescrito, sem explicações adicionais

PROMPT REWRITTEN:`;

                        const response = await apiCallFunction(reformulationPrompt, decryptedKey, model);
                        
                        let extractedText = '';
                        if (typeof response === 'string') {
                            extractedText = response;
                        } else if (response.titles) {
                            extractedText = response.titles;
                        } else if (response.text) {
                            extractedText = response.text;
                        }
                        
                        reformulatedPrompt = extractedText
                            .replace(/```[\s\S]*?```/g, '')
                            .replace(/`/g, '')
                            .replace(/^[^"]*["']|["'][^"]*$/g, '')
                            .replace(/^(Prompt|Prompt reformulado|Nova versão|Versão reformulada|PROMPT REWRITTEN)[:：]\s*/i, '')
                            .replace(/\n+/g, ' ')
                            .replace(/\s+/g, ' ')
                            .trim();
                        
                        if (reformulatedPrompt && reformulatedPrompt.length > 50 && reformulatedPrompt.length < 2000) {
                            console.log(`[ImageFX] Prompt reformulado usando ${service} (${reformulatedPrompt.length} caracteres)`);
                            if (!reformulatedPrompt.includes('photorealistic')) {
                                reformulatedPrompt += ', photorealistic, hyperrealistic, cinematic, 8k, ultra high definition, sharp focus, professional photography';
                            }
                            break;
                        }
                    } catch (serviceErr) {
                        console.warn(`[ImageFX] Falha ao reformular com ${service}:`, serviceErr.message);
                        continue;
                    }
                }
                
                if (!reformulatedPrompt) {
                    reformulatedPrompt = originalPrompt
                        .replace(/real person|actual person|specific person|celebrity|famous person/gi, 'generic person')
                        + ', generic characters, no specific individuals, artistic representation';
                }
                
                return reformulatedPrompt;
            } catch (err) {
                console.error('[ImageFX] Erro ao reformular prompt:', err);
                return originalPrompt.replace(/real person|actual person|specific person/gi, 'generic person') + ', generic characters';
            }
        };
        
        // Loop de tentativas com reformulação automática
        while (attempt < maxRetries && !images) {
            attempt++;
            try {
                console.log(`[ImageFX] Tentativa ${attempt}/${maxRetries} com prompt: ${currentPrompt.substring(0, 100)}...`);
                
                const results = await imageFx.generateImage(currentPrompt, {
                    numberOfImages: 1,
                    aspectRatio: AspectRatio.LANDSCAPE,
                    resizeTo16_9: true
                });

                if (results && results.length > 0) {
                    images = results;
                    console.log(`[ImageFX] Imagem gerada com sucesso na tentativa ${attempt}`);
                    break;
                }
            } catch (err) {
                lastError = err;
                console.warn(`[ImageFX] Erro na tentativa ${attempt}:`, err.message);
                
                if (isPolicyError(err) && attempt < maxRetries) {
                    console.log(`[ImageFX] Erro de política detectado. Reformulando prompt...`);
                    currentPrompt = await reformulatePrompt(currentPrompt, err.message);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    continue;
                } else {
                    throw err;
                }
            }
        }

        if (!images || images.length === 0) {
            throw new Error(lastError?.message || 'O ImageFX não retornou imagens após múltiplas tentativas.');
        }

        // O generateImage retorna um array de objetos com url, sanitizedPrompt, etc.
        const imageResult = images[0];
        const imageUrl = imageResult.url || '';
        
        // Extrair base64 da URL data:image
        let finalBase64 = null;
        if (imageUrl && imageUrl.startsWith('data:image')) {
            finalBase64 = imageUrl.split(',')[1];
        }
        
        const finalUrl = imageUrl || (finalBase64 ? `data:image/png;base64,${finalBase64}` : '');

        // Salvar automaticamente na biblioteca se solicitado
        let savedId = null;
        if (saveToLibrary && finalUrl) {
            try {
                const result = await db.run(
                    `INSERT INTO viral_thumbnails_library (user_id, thumbnail_url, thumbnail_description, niche, subniche, style, viral_score)
                     VALUES (?, ?, ?, ?, ?, ?, ?)`,
                    [userId, finalUrl, prompt, niche || null, subniche || null, style || null, 8]
                );
                savedId = result.lastID;
                console.log(`[ImageFX] Thumbnail salva na biblioteca com ID ${savedId}`);
            } catch (libErr) {
                console.warn('[ImageFX] Erro ao salvar thumbnail na biblioteca:', libErr.message);
            }
        }

        res.status(200).json({ 
            msg: 'Imagem gerada com sucesso!',
            image: finalBase64,
            imageUrl: finalUrl,
            base64: finalBase64,
            prompt: currentPrompt,
            savedToLibrary: savedId !== null,
            libraryId: savedId,
            attempts: attempt,
            wasRewritten: attempt > 1
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/generate/imagefx]:', err);
        
        // Verificar se é erro de autenticação (cookies expirados)
        if (err instanceof AccountError || err.message?.includes('cookie') || err.message?.includes('autenticação')) {
            return res.status(401).json({ 
                msg: 'Cookies do ImageFX expirados ou inválidos. Por favor, atualize os cookies nas Configurações.',
                requiresAuth: true
            });
        }
        
        // Verificar se é erro do ImageFX com código específico
        if (err.code === 400 && err.message) {
            const errorMsg = err.message;
            if (errorMsg.includes('PUBLIC_ERROR') || errorMsg.includes('filter_failed')) {
                return res.status(500).json({ 
                    msg: 'Não foi possível gerar a imagem após múltiplas tentativas de reformulação. O conteúdo pode violar políticas do gerador de imagens. Tente modificar o prompt manualmente para remover referências a pessoas reais ou conteúdo sensível.',
                    error: errorMsg
                });
            }
        }
        
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao gerar imagem.' });
    }
});

// === FUNÇÕES DE TRANSCRIÇÃO COM WHISPER ===

/**
 * Baixa o áudio usando yt-dlp (método mais estável - ignora bugs do ytdl-core)
 */
async function downloadAudioWithYtDlp(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const audioPath = path.join(TEMP_DIR, `${videoId}_${Date.now()}.mp3`);
    
    console.log(`[Whisper] ⏳ Baixando áudio com yt-dlp (método estável): ${videoId}`);
    
    try {
        // Verificar se yt-dlp está disponível
        try {
            await execAsync('yt-dlp --version');
        } catch (versionErr) {
            throw new Error('yt-dlp não está instalado. Instale com: pip install -U yt-dlp ou baixe de https://github.com/yt-dlp/yt-dlp/releases/latest');
        }
        
        // Baixar e converter para MP3 usando yt-dlp
        // -x: extrair áudio
        // --audio-format mp3: formato MP3
        // -o: nome do arquivo de saída
        const command = `yt-dlp -x --audio-format mp3 -o "${audioPath.replace('.mp3', '.%(ext)s')}" "${videoUrl}"`;
        
        console.log(`[Whisper] Executando: yt-dlp...`);
        const { stdout, stderr } = await execAsync(command, {
            maxBuffer: 10 * 1024 * 1024 // 10MB buffer
        });
        
        if (stderr && !stderr.includes('WARNING')) {
            console.warn(`[Whisper] Avisos do yt-dlp:`, stderr);
        }
        
        // Verificar se o arquivo foi criado
        if (!fs.existsSync(audioPath)) {
            // yt-dlp pode criar com extensão diferente, procurar arquivo
            const files = fs.readdirSync(TEMP_DIR);
            const audioFile = files.find(f => f.startsWith(videoId) && (f.endsWith('.mp3') || f.endsWith('.m4a') || f.endsWith('.webm')));
            if (audioFile) {
                const foundPath = path.join(TEMP_DIR, audioFile);
                // Se não for MP3, converter
                if (!audioFile.endsWith('.mp3')) {
                    const mp3Path = audioPath;
                    await new Promise((resolve, reject) => {
                        ffmpeg(foundPath)
                            .audioCodec('libmp3lame')
                            .format('mp3')
                            .on('end', () => {
                                fs.unlinkSync(foundPath); // Remover arquivo original
                                resolve();
                            })
                            .on('error', reject)
                            .save(mp3Path);
                    });
                }
                console.log(`[Whisper] ✅ Áudio baixado com yt-dlp: ${audioPath}`);
                return audioPath;
            }
            throw new Error('Arquivo de áudio não foi criado pelo yt-dlp');
        }
        
        console.log(`[Whisper] ✅ Áudio baixado com yt-dlp: ${audioPath}`);
        return audioPath;
    } catch (err) {
        console.error(`[Whisper] ❌ Erro ao baixar com yt-dlp:`, err.message);
        throw err;
    }
}

/**
 * Baixa o áudio de um vídeo do YouTube e extrai para arquivo MP3
 * Tenta primeiro com ytdl-core, depois com yt-dlp como fallback (100% estável)
 */
async function downloadAndExtractAudio(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const audioPath = path.join(TEMP_DIR, `${videoId}_${Date.now()}.mp3`);
    
    console.log(`[Whisper] ⏳ Baixando áudio do vídeo: ${videoId}`);
    
    // Tentar primeiro com ytdl-core
    try {
        return await new Promise((resolve, reject) => {
            try {
                // Baixar stream de áudio do YouTube
                // dlChunkSize: 0 evita o bug de segmentação de stream
                // highWaterMark: 1 << 25 evita travamento (33MB buffer)
                const stream = ytdl(videoUrl, {
                    quality: 'highestaudio',
                    filter: 'audioonly',
                    dlChunkSize: 0, // Corrige bug de segmentação
                    highWaterMark: 1 << 25 // 33MB buffer - evita travamento
                });
                
                // Verificar se o stream tem dados válidos
                let hasData = false;
                stream.on('data', (chunk) => {
                    hasData = true;
                });
                
                // Timeout para detectar se não há dados chegando
                const dataTimeout = setTimeout(() => {
                    if (!hasData) {
                        stream.destroy();
                        // Tentar yt-dlp quando stream vazio
                        console.log(`[Whisper] Stream vazio detectado, tentando yt-dlp...`);
                        downloadAudioWithYtDlp(videoId)
                            .then(resolve)
                            .catch((ytdlpErr) => {
                                reject(new Error(`Stream vazio e yt-dlp não disponível. Instale yt-dlp: pip install -U yt-dlp`));
                            });
                    }
                }, 5000); // 5 segundos para detectar falta de dados
                
                // Converter para MP3 usando FFmpeg (método simplificado do tutorial)
                const ffmpegProcess = ffmpeg(stream)
                    .audioCodec('libmp3lame')
                    .noVideo() // Garantir que só processa áudio
                    .on('start', (commandLine) => {
                        console.log(`[Whisper] FFmpeg iniciado...`);
                    })
                    .on('progress', (progress) => {
                        if (progress.percent) {
                            console.log(`[Whisper] Progresso: ${Math.round(progress.percent)}%`);
                        }
                    })
                    .on('end', () => {
                        clearTimeout(dataTimeout);
                        console.log(`[Whisper] ✅ Áudio extraído com sucesso: ${audioPath}`);
                        resolve(audioPath);
                    })
                    .on('error', (err) => {
                        clearTimeout(dataTimeout);
                        console.error(`[Whisper] ❌ Erro no FFmpeg:`, err.message);
                        
                        // Verificar se é erro relacionado a stream vazio - tentar yt-dlp
                        if (err.message && (
                            err.message.includes('Input stream error') ||
                            err.message.includes('pipe') ||
                            err.message.includes('EPIPE')
                        )) {
                            console.log(`[Whisper] FFmpeg falhou por stream vazio, tentando yt-dlp...`);
                            downloadAudioWithYtDlp(videoId)
                                .then(resolve)
                                .catch((ytdlpErr) => {
                                    reject(new Error(`FFmpeg falhou e yt-dlp não disponível. Instale yt-dlp: pip install -U yt-dlp`));
                                });
                        } else {
                            reject(new Error(`Erro ao processar áudio: ${err.message}`));
                        }
                    })
                    .save(audioPath);
                
                // Tratar erros do stream do YouTube
                stream.on('error', (streamErr) => {
                    clearTimeout(dataTimeout);
                    console.error(`[Whisper] ❌ Erro no stream do YouTube:`, streamErr.message);
                    
                    // Verificar se é o erro conhecido de parsing - tentar yt-dlp como fallback
                    if (streamErr.message && (
                        streamErr.message.includes('Could not parse') ||
                        streamErr.message.includes('decipher function') ||
                        streamErr.message.includes('Stream URLs will be missing')
                    )) {
                        console.log(`[Whisper] ytdl-core falhou, tentando yt-dlp (método 100% estável)...`);
                        // Tentar com yt-dlp
                        downloadAudioWithYtDlp(videoId)
                            .then(resolve)
                            .catch((ytdlpErr) => {
                                console.error(`[Whisper] yt-dlp também falhou:`, ytdlpErr.message);
                                reject(new Error(`Não foi possível baixar o áudio. ytdl-core falhou e yt-dlp não está instalado ou também falhou. Instale yt-dlp: pip install -U yt-dlp`));
                            });
                    } else {
                        reject(new Error(`Erro ao baixar áudio do YouTube: ${streamErr.message}`));
                    }
                });
                
                // Limpar timeout quando stream terminar
                stream.on('end', () => {
                    clearTimeout(dataTimeout);
                });
                
            } catch (err) {
                console.error(`[Whisper] ❌ Erro ao iniciar download com ytdl-core:`, err.message);
                
                // Verificar se é o erro conhecido de parsing - tentar yt-dlp como fallback
                if (err.message && (
                    err.message.includes('Could not parse') ||
                    err.message.includes('decipher function') ||
                    err.message.includes('Stream URLs will be missing')
                )) {
                    console.log(`[Whisper] ytdl-core falhou, tentando yt-dlp (método 100% estável)...`);
                    // Tentar com yt-dlp
                    downloadAudioWithYtDlp(videoId)
                        .then(resolve)
                        .catch((ytdlpErr) => {
                            console.error(`[Whisper] yt-dlp também falhou:`, ytdlpErr.message);
                            reject(new Error(`Não foi possível baixar o áudio. ytdl-core falhou e yt-dlp não está instalado ou também falhou. Instale yt-dlp: pip install -U yt-dlp`));
                        });
                } else {
                    reject(err);
                }
            }
        });
    } catch (err) {
        // Se ytdl-core falhar completamente, tentar yt-dlp
        console.log(`[Whisper] ytdl-core falhou completamente, tentando yt-dlp (método 100% estável)...`);
        try {
            return await downloadAudioWithYtDlp(videoId);
        } catch (ytdlpErr) {
            throw new Error(`Ambos os métodos falharam. ytdl-core: ${err.message.substring(0, 50)}. yt-dlp: ${ytdlpErr.message.substring(0, 50)}. Instale yt-dlp para maior estabilidade: pip install -U yt-dlp`);
        }
    }
}

/**
 * Transcreve áudio usando OpenAI Whisper
 */
async function transcribeWithWhisper(audioPath, userId) {
    try {
        // Buscar chave da OpenAI
        const openaiKeyData = await db.get(
            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
            [userId, 'openai']
        );
        
        if (!openaiKeyData) {
            throw new Error('Chave de API da OpenAI não configurada. Configure sua chave OpenAI nas configurações.');
        }
        
        const openaiApiKey = decrypt(openaiKeyData.api_key);
        if (!openaiApiKey) {
            throw new Error('Falha ao desencriptar a chave de API da OpenAI.');
        }
        
        // Inicializar cliente OpenAI
        const openai = new OpenAI({
            apiKey: openaiApiKey
        });
        
        console.log(`[Whisper] 🧠 Enviando para transcrição (Whisper)...`);
        
        // Transcrever usando Whisper (método simplificado do tutorial)
        const transcription = await openai.audio.transcriptions.create({
            file: fs.createReadStream(audioPath),
            model: 'whisper-1', // Modelo correto do Whisper
            language: 'pt' // Português por padrão
        });
        
        // A resposta do Whisper pode ser texto direto ou objeto com .text
        const transcriptText = typeof transcription === 'string' ? transcription : transcription.text || transcription;
        
        console.log(`[Whisper] ✅ Transcrição concluída! Tamanho: ${transcriptText.length} caracteres`);
        
        // Limpar arquivo temporário
        try {
            fs.unlinkSync(audioPath);
            console.log(`[Whisper] Arquivo temporário removido: ${audioPath}`);
        } catch (cleanupErr) {
            console.warn(`[Whisper] Aviso: Não foi possível remover arquivo temporário:`, cleanupErr.message);
        }
        
        return transcriptText;
    } catch (err) {
        // Limpar arquivo temporário em caso de erro
        try {
            if (fs.existsSync(audioPath)) {
                fs.unlinkSync(audioPath);
            }
        } catch (cleanupErr) {
            console.warn(`[Whisper] Erro ao limpar arquivo:`, cleanupErr.message);
        }
        throw err;
    }
}

/**
 * Função principal para transcrever vídeo usando Whisper (fallback universal)
 */
async function transcribeVideoWithWhisper(videoId, userId) {
    let audioPath = null;
    try {
        // 1. Baixar e extrair áudio
        audioPath = await downloadAndExtractAudio(videoId);
        
        // 2. Transcrever com Whisper
        const transcript = await transcribeWithWhisper(audioPath, userId);
        
        return transcript;
    } catch (err) {
        // Garantir limpeza do arquivo em caso de erro
        if (audioPath && fs.existsSync(audioPath)) {
            try {
                fs.unlinkSync(audioPath);
            } catch (cleanupErr) {
                console.warn(`[Whisper] Erro ao limpar arquivo após erro:`, cleanupErr.message);
            }
        }
        throw err;
    }
}

/**
 * Busca transcrição usando youtube-transcript (GRATUITO, busca legendas diretamente do YouTube)
 * Este é o método mais rápido e confiável quando o vídeo tem legendas
 */
async function getTranscriptFromYouTubeTranscript(videoId) {
    try {
        console.log(`[YouTube-Transcript] 🔍 Buscando transcrição via youtube-transcript para: ${videoId}`);
        
        // Tentar buscar transcrição com diferentes configurações
        let transcriptData;
        const languages = ['pt', 'en', 'es', null]; // Tentar português, inglês, espanhol, e sem especificar
        
        for (const lang of languages) {
            try {
                if (lang) {
                    console.log(`[YouTube-Transcript] Tentando idioma: ${lang}`);
                    transcriptData = await YoutubeTranscript.fetchTranscript(videoId, { lang });
                } else {
                    console.log(`[YouTube-Transcript] Tentando sem especificar idioma`);
                    transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
                }
                
                if (transcriptData && transcriptData.length > 0) {
                    break; // Sucesso, sair do loop
                }
            } catch (langErr) {
                console.log(`[YouTube-Transcript] Falha com idioma ${lang || 'padrão'}: ${langErr.message}`);
                continue; // Tentar próximo idioma
            }
        }
        
        if (!transcriptData || transcriptData.length === 0) {
            throw new Error('Nenhuma transcrição encontrada em nenhum idioma disponível');
        }
        
        // Juntar todos os textos
        const transcriptText = transcriptData.map(item => item.text).join(' ').trim();
        
        if (!transcriptText || transcriptText.length === 0) {
            throw new Error('Transcrição vazia');
        }
        
        console.log(`[YouTube-Transcript] ✅ Transcrição obtida! (${transcriptText.length} caracteres, ${transcriptData.length} segmentos)`);
        return transcriptText;
    } catch (err) {
        console.warn(`[YouTube-Transcript] ⚠️ Falha:`, err.message);
        throw new Error(`Nenhuma transcrição encontrada: ${err.message}`);
    }
}
/**
 * Busca transcrição usando múltiplos métodos com fallback automático
 * Ordem de prioridade:
 * 1. youtube-transcript (gratuito, mais rápido)
 * 2. Whisper Local (open-source, se instalado)
 */
async function getTranscriptWithFallback(videoUrl, userId, videoTitle = null) {
    const videoId = videoUrl.includes('youtu.be') 
        ? videoUrl.split('youtu.be/')[1]?.split('?')[0]
        : new URL(videoUrl).searchParams.get('v') || videoUrl;
    
    console.log(`[Transcrição] 🎯 Iniciando busca de transcrição com múltiplos métodos para: ${videoId}`);
    
    // MÉTODO 1: youtube-transcript (GRATUITO, mais rápido)
    try {
        console.log(`[Transcrição] Tentando método 1: youtube-transcript (gratuito)...`);
        const transcript = await getTranscriptFromYouTubeTranscript(videoId);
        console.log(`[Transcrição] ✅✅✅ SUCESSO com youtube-transcript!`);
        return { transcript, source: 'youtube-transcript' };
    } catch (youtubeTranscriptErr) {
        console.warn(`[Transcrição] Método 1 falhou:`, youtubeTranscriptErr.message);
    }
    
    // MÉTODO 2: Whisper Local (open-source, se instalado)
    try {
        console.log(`[Transcrição] Tentando método 2: Whisper Local (open-source)...`);
        
        // Verificar se Whisper está instalado usando método confiável
        if (!checkWhisperInstalled()) {
            console.warn('[Transcrição] ❌ Whisper não encontrado — pulando método local');
            throw new Error('Whisper não está instalado. Instale com: pip install git+https://github.com/openai/whisper.git');
        }
        
        console.log(`[Transcrição] ✅ Whisper detectado e disponível`);
        
        // Para Whisper, usar yt-dlp diretamente (mais confiável que ytdl-core)
        // ytdl-core está tendo problemas com YouTube, então vamos direto para yt-dlp
        console.log(`[Transcrição] Baixando áudio com yt-dlp (método mais confiável)...`);
        let audioPath;
        try {
            audioPath = await downloadAudioWithYtDlp(videoId);
        } catch (ytdlpErr) {
            // Se yt-dlp falhar, tentar com ytdl-core como último recurso
            console.log(`[Transcrição] yt-dlp falhou, tentando ytdl-core como fallback...`);
            audioPath = await downloadAndExtractAudio(videoId);
        }
        
        const transcript = await transcribeWithWhisperLocal(audioPath);
        console.log(`[Transcrição] ✅✅✅ SUCESSO com Whisper Local!`);
        return { transcript, source: 'whisper-local' };
    } catch (whisperErr) {
        console.warn(`[Transcrição] Método 2 falhou:`, whisperErr.message);
    }
    
    // Se todos os métodos falharam
    throw new Error('Todos os métodos de transcrição falharam. Verifique se o vídeo possui legendas habilitadas no YouTube ou instale o Whisper local para transcrição de áudio.');
}


/**
 * Verifica se o Whisper está instalado corretamente
 * @returns {boolean} true se Whisper está disponível, false caso contrário
 */
function checkWhisperInstalled() {
    try {
        const output = execSync('python -c "import whisper; print(\'OK\')"', {
            encoding: 'utf8',
            timeout: 5000,
            stdio: ['ignore', 'pipe', 'pipe']
        }).toString().trim();
        return output === 'OK';
    } catch (err) {
        return false;
    }
}

// Função para detectar idioma do título baseado em padrões comuns
function detectLanguageFromTitle(title) {
    if (!title || typeof title !== 'string') return null;
    
    const titleLower = title.toLowerCase();
    
    // Padrões para espanhol
    const spanishPatterns = [
        /\b(el|la|los|las|un|una|de|del|en|con|por|para|que|es|son|está|están|se|su|sus|más|muy|también|como|cuando|donde|porque|este|esta|estos|estas)\b/i,
        /[áéíóúñü]/i
    ];
    
    // Padrões para português
    const portuguesePatterns = [
        /\b(o|a|os|as|um|uma|de|do|da|dos|das|em|com|por|para|que|é|são|está|estão|se|seu|sua|seus|suas|mais|muito|também|como|quando|onde|porque|este|esta|estes|estas)\b/i,
        /[áéíóúâêôãõç]/i
    ];
    
    // Padrões para inglês
    const englishPatterns = [
        /\b(the|a|an|and|or|but|in|on|at|to|for|of|with|by|from|as|is|are|was|were|be|been|being|have|has|had|do|does|did|will|would|should|could|may|might|this|that|these|those|what|which|who|when|where|why|how)\b/i
    ];
    
    // Contar ocorrências de cada idioma
    let spanishScore = 0;
    let portugueseScore = 0;
    let englishScore = 0;
    
    spanishPatterns.forEach(pattern => {
        if (pattern.test(title)) spanishScore++;
    });
    
    portuguesePatterns.forEach(pattern => {
        if (pattern.test(title)) portugueseScore++;
    });
    
    englishPatterns.forEach(pattern => {
        if (pattern.test(title)) englishScore++;
    });
    
    // Retornar o idioma com maior score
    if (spanishScore > portugueseScore && spanishScore > englishScore) {
        return 'es';
    } else if (portugueseScore > englishScore) {
        return 'pt';
    } else if (englishScore > 0) {
        return 'en';
    }
    
    // Se não detectar, retornar null (usará fallback)
    return null;
}


/**
 * Transcreve áudio usando Whisper LOCAL (open-source oficial da OpenAI)
 * Requer: pip install -U openai-whisper
 * Documentação: https://github.com/openai/whisper
 * Aceita MP3, WAV, M4A e outros formatos suportados pelo Whisper
 * 
 * Modelos disponíveis:
 * - tiny: ~39M parâmetros, ~1GB VRAM, ~10x mais rápido
 * - base: ~74M parâmetros, ~1GB VRAM, ~7x mais rápido (recomendado)
 * - small: ~244M parâmetros, ~2GB VRAM, ~4x mais rápido
 * - medium: ~769M parâmetros, ~5GB VRAM, ~2x mais rápido
 * - large: ~1550M parâmetros, ~10GB VRAM, 1x (mais preciso)
 * - turbo: ~809M parâmetros, ~6GB VRAM, ~8x mais rápido (otimizado)
 */
async function transcribeWithWhisperLocal(audioPath) {
    try {
        console.log(`[Whisper Local] 🧠 Transcrevendo com Whisper local (open-source oficial da OpenAI)...`);
        
        // Verificar se arquivo existe
        if (!fs.existsSync(audioPath)) {
            throw new Error(`Arquivo de áudio não encontrado: ${audioPath}`);
        }
        
        // Preparar caminho do arquivo de saída
        const outputDir = path.dirname(audioPath);
        const audioName = path.basename(audioPath, path.extname(audioPath));
        const transcriptFile = path.join(outputDir, `${audioName}.txt`);
        
        // Executar Whisper local usando o modelo oficial da OpenAI
        // --model base: modelo base (equilíbrio entre velocidade e qualidade)
        // Sem --language: Whisper detecta automaticamente o idioma (comportamento padrão)
        // --output_format txt: formato texto simples
        // --output_dir: diretório de saída
        // Whisper aceita MP3, WAV, M4A, FLAC, etc automaticamente
        // Usar 'python -m whisper' para garantir que funcione mesmo se não estiver no PATH
        let command = `python -m whisper "${audioPath}" --model base --output_format txt --output_dir "${outputDir}"`;
        
        console.log(`[Whisper Local] Executando: python -m whisper "${path.basename(audioPath)}" com modelo base (detecção automática de idioma)...`);
        
        try {
            execSync(command, { 
                stdio: 'inherit',
                timeout: 600000 // 10 minutos de timeout
            });
        } catch (pythonErr) {
            console.error(`[Whisper Local] Erro ao executar Whisper:`, pythonErr.message);
            throw new Error(`Falha ao transcrever com Whisper: ${pythonErr.message}`);
        }
        
        // Ler arquivo de transcrição gerado
        if (!fs.existsSync(transcriptFile)) {
            throw new Error('Arquivo de transcrição não foi gerado pelo Whisper');
        }
        
        const transcriptText = fs.readFileSync(transcriptFile, 'utf8').trim();
        
        if (!transcriptText || transcriptText.length === 0) {
            throw new Error('Transcrição vazia - o áudio pode estar sem fala ou muito baixo');
        }
        
        console.log(`[Whisper Local] ✅ Transcrição concluída! Tamanho: ${transcriptText.length} caracteres`);
        
        // Limpar arquivos temporários
        try {
            fs.unlinkSync(audioPath);
            fs.unlinkSync(transcriptFile);
            // Limpar outros arquivos gerados pelo Whisper (JSON, VTT, SRT, etc)
            const files = fs.readdirSync(outputDir);
            files.forEach(file => {
                if (file.startsWith(audioName) && file !== audioName) {
                    try {
                        fs.unlinkSync(path.join(outputDir, file));
                    } catch (e) {
                        // Ignorar erros de limpeza
                    }
                }
            });
        } catch (cleanupErr) {
            console.warn(`[Whisper Local] Aviso: Não foi possível remover alguns arquivos temporários:`, cleanupErr.message);
        }
        
        return transcriptText;
    } catch (err) {
        // Limpar arquivo temporário em caso de erro
        try {
            if (fs.existsSync(audioPath)) {
                fs.unlinkSync(audioPath);
            }
        } catch (cleanupErr) {
            console.warn(`[Whisper Local] Erro ao limpar arquivo:`, cleanupErr.message);
        }
        throw err;
    }
}

/**
 * Baixa vídeo de URL (YouTube ou MP4 direto) e extrai áudio
 */
async function downloadVideoAndExtractAudio(videoUrl) {
    const tempVideo = path.join(TEMP_DIR, `video_${Date.now()}.mp4`);
    const tempAudio = path.join(TEMP_DIR, `audio_${Date.now()}.wav`);
    
    try {
        console.log(`[Download] 🎬 Baixando vídeo de: ${videoUrl}`);
        
        // Verificar se é URL do YouTube
        if (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be')) {
            // Extrair ID do vídeo
            let videoId = null;
            if (videoUrl.includes('youtu.be')) {
                videoId = videoUrl.split('youtu.be/')[1]?.split('?')[0];
            } else {
                const urlObj = new URL(videoUrl);
                videoId = urlObj.searchParams.get('v');
            }
            
            if (videoId) {
                // Usar método existente para baixar áudio do YouTube
                return await downloadAndExtractAudio(videoId);
            }
        }
        
        // Para URLs diretas de vídeo (MP4, etc)
        console.log(`[Download] Baixando vídeo direto...`);
        const response = await axios.get(videoUrl, { 
            responseType: 'arraybuffer',
            timeout: 300000 // 5 minutos
        });
        fs.writeFileSync(tempVideo, response.data);
        
        console.log(`[Download] 🎧 Extraindo áudio...`);
        await new Promise((resolve, reject) => {
            ffmpeg(tempVideo)
                .noVideo()
                .audioCodec('pcm_s16le')
                .audioChannels(1)
                .audioFrequency(16000)
                .save(tempAudio)
                .on('end', resolve)
                .on('error', reject);
        });
        
        // Limpar vídeo temporário
        try {
            fs.unlinkSync(tempVideo);
        } catch (e) {}
        
        return tempAudio;
    } catch (err) {
        // Limpar arquivos temporários em caso de erro
        try {
            if (fs.existsSync(tempVideo)) fs.unlinkSync(tempVideo);
            if (fs.existsSync(tempAudio)) fs.unlinkSync(tempAudio);
        } catch (e) {}
        throw err;
    }
}

// === ROTAS DE TRANSCRIÇÃO ===

/**
 * Rota para transcrever vídeo por URL (YouTube ou MP4 direto)
 * Usa Whisper LOCAL (open-source, sem API Key)
 * GET /api/transcribe?url=https://www.youtube.com/watch?v=XXXXX
 * GET /api/transcribe?url=https://meusite.com/video.mp4
 */
app.get('/api/transcribe', authenticateToken, async (req, res) => {
    const videoUrl = req.query.url;
    
    if (!videoUrl) {
        return res.status(400).json({ 
            error: 'URL obrigatória',
            msg: 'Forneça a URL do vídeo no parâmetro ?url='
        });
    }
    
    let tempAudio = null;
    
    try {
        console.log(`[Transcribe] 🎬 Iniciando transcrição para: ${videoUrl}`);
        
        // 1. Baixar vídeo e extrair áudio
        tempAudio = await downloadVideoAndExtractAudio(videoUrl);
        
        // 2. Transcrever com Whisper local
        const transcript = await transcribeWithWhisperLocal(tempAudio);
        
        console.log(`[Transcribe] ✅ Transcrição concluída!`);
        res.json({ 
            success: true, 
            text: transcript,
            source: 'whisper-local'
        });
    } catch (err) {
        console.error(`[Transcribe] ❌ Erro na transcrição:`, err.message);
        
        // Limpar arquivo temporário em caso de erro
        if (tempAudio && fs.existsSync(tempAudio)) {
            try {
                fs.unlinkSync(tempAudio);
            } catch (e) {}
        }
        
        res.status(500).json({ 
            error: 'Falha ao transcrever vídeo',
            msg: err.message || 'Erro desconhecido',
            hint: err.message?.includes('Whisper local não está instalado') 
                ? 'Instale Whisper com: pip install openai-whisper'
                : undefined
        });
    }
});

// === ROTAS DE AGENTES DE ROTEIRO ===

// Rota para obter transcrição completa de um vídeo
app.get('/api/video/transcript/:videoId', authenticateToken, async (req, res) => {
    let { videoId } = req.params;
    const userId = req.user.id;

    console.log(`[Transcrição] Rota chamada - Parâmetro recebido: "${videoId}"`);
    console.log(`[Transcrição] User ID: ${userId}`);
    console.log(`[Transcrição] URL completa: ${req.url}`);
    console.log(`[Transcrição] Parâmetros:`, req.params);
    
    // Garantir que a resposta não será fechada prematuramente
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('Keep-Alive', 'timeout=900'); // 15 minutos

    // Validar e limpar o ID do vídeo (fazer isso antes de qualquer coisa)
    // Remover qualquer caractere inválido que possa ter sido adicionado (como :1 no final)
    let cleanVideoId = String(videoId || '').trim();
    
    // Remover sufixos estranhos que podem aparecer (como :1, :2, etc)
    cleanVideoId = cleanVideoId.split(':')[0].split('?')[0].split('#')[0];
    
    // Validar formato básico do videoId do YouTube (11 caracteres alfanuméricos)
    if (!cleanVideoId || cleanVideoId.length < 10) {
        console.error(`[Transcrição] ❌ VideoId inválido: "${videoId}" -> "${cleanVideoId}"`);
        return res.status(400).json({ 
            msg: 'ID do vídeo inválido',
            error: `VideoId recebido: "${videoId}"`
        });
    }
    
    // Se for uma URL completa, extrair o ID
    if (cleanVideoId.includes('youtube.com') || cleanVideoId.includes('youtu.be')) {
        try {
            const urlObj = new URL(cleanVideoId.includes('http') ? cleanVideoId : `https://${cleanVideoId}`);
            if (urlObj.hostname.includes('youtu.be')) {
                cleanVideoId = urlObj.pathname.substring(1);
            } else {
                cleanVideoId = urlObj.searchParams.get('v') || cleanVideoId;
            }
        } catch (urlErr) {
            console.warn(`[Transcrição] Erro ao processar URL, usando como ID: ${cleanVideoId}`);
        }
    }

    // Log adicional para debug
    console.log(`[Transcrição] VideoId limpo: "${cleanVideoId}" (tamanho: ${cleanVideoId.length})`);
    
    try {
        // Primeiro, tentar buscar do banco de dados (cache)
        const analysis = await db.get(
            'SELECT full_transcript FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
            [cleanVideoId, userId]
        );

        if (analysis && analysis.full_transcript) {
            console.log(`[Transcrição] ✓ Transcrição encontrada no cache`);
            return res.status(200).json({ 
                transcript: analysis.full_transcript,
                source: 'database'
            });
        }

        // Buscar título do vídeo do banco de dados para detectar idioma
        let videoTitle = null;
        try {
            const videoData = await db.get(
                'SELECT original_title FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                [cleanVideoId, userId]
            );
            if (videoData && videoData.original_title) {
                videoTitle = videoData.original_title;
                console.log(`[Transcrição] Título encontrado: ${videoTitle}`);
            }
        } catch (titleErr) {
            console.warn(`[Transcrição] Não foi possível buscar título do vídeo:`, titleErr.message);
        }
        
        // Usar sistema de fallback com múltiplos métodos
        console.log(`[Transcrição] Buscando transcrição com sistema de fallback para vídeo ID: ${cleanVideoId}`);
        console.log(`[Transcrição] URL do vídeo: https://www.youtube.com/watch?v=${cleanVideoId}`);
        
        try {
            const videoUrl = `https://www.youtube.com/watch?v=${cleanVideoId}`;
            const result = await getTranscriptWithFallback(videoUrl, userId, videoTitle);
            
            if (result.transcript && result.transcript.trim().length > 0) {
                console.log(`[Transcrição] ✓✓✓ SUCESSO com ${result.source}! (${result.transcript.length} caracteres)`);
                
                // Salvar no banco de dados para cache
                try {
                    await db.run(
                        'UPDATE analyzed_videos SET full_transcript = ? WHERE youtube_video_id = ? AND user_id = ?',
                        [result.transcript, cleanVideoId, userId]
                    );
                } catch (dbErr) {
                    console.warn(`[Transcrição] Aviso: Não foi possível salvar transcrição no banco:`, dbErr.message);
                }
                
                return res.status(200).json({ 
                    transcript: result.transcript,
                    source: result.source
                });
            } else {
                throw new Error('Transcrição vazia retornada');
            }
        } catch (transcriptErr) {
            console.error(`[Transcrição] ✗✗✗ FALHA com todos os métodos:`, transcriptErr.message);
            console.error(`[Transcrição] Stack trace:`, transcriptErr.stack?.substring(0, 300));
            
            // Retornar erro específico
            let userMessage = 'Não foi possível obter a transcrição deste vídeo.';
            let statusCode = 404;
            
            if (transcriptErr.message.includes('Whisper não está instalado')) {
                userMessage = 'Transcrição via legendas falhou. Para usar transcrição de áudio, instale o Whisper oficial da OpenAI:\n\n1. Abra o terminal/PowerShell\n2. Execute: pip install -U openai-whisper\n3. Certifique-se de ter o FFmpeg instalado (já está no projeto)\n\nDocumentação: https://github.com/openai/whisper\n\nAlternativamente, você pode colar a transcrição manualmente ao criar o agente de roteiro.';
            } else if (transcriptErr.message.includes('Todos os métodos de transcrição falharam')) {
                userMessage = 'Não foi possível obter a transcrição com nenhum método disponível.\n\nPossíveis soluções:\n1. Verifique se o vídeo possui legendas habilitadas no YouTube\n2. Instale o Whisper local: pip install -U openai-whisper\n3. Cole a transcrição manualmente ao criar o agente de roteiro';
            } else {
                userMessage = `Erro ao buscar transcrição: ${transcriptErr.message}`;
            }
            
            if (!res.headersSent) {
                return res.status(statusCode).json({ 
                    msg: userMessage,
                    error: process.env.NODE_ENV === 'development' ? {
                        error: transcriptErr.message,
                        videoId: cleanVideoId,
                        videoUrl: `https://www.youtube.com/watch?v=${cleanVideoId}`
                    } : undefined
                });
            }
        }
    } catch (err) {
        console.error('[ERRO NA ROTA /api/video/transcript]:', err);
        console.error('[ERRO Stack]:', err.stack?.substring(0, 500));
        
        // Garantir que sempre retornamos uma resposta, mesmo em caso de erro
        if (!res.headersSent) {
            try {
                res.status(500).json({ 
                    msg: err.message || 'Erro ao obter transcrição do vídeo.',
                    error: process.env.NODE_ENV === 'development' ? {
                        message: err.message,
                        stack: err.stack?.substring(0, 300)
                    } : undefined
                });
            } catch (responseErr) {
                console.error('[ERRO ao enviar resposta de erro]:', responseErr);
            }
        } else {
            console.warn('[AVISO] Tentativa de enviar resposta quando headers já foram enviados');
        }
    }
});

app.post('/api/video/transcript/analyze', authenticateToken, async (req, res) => {
    const { transcript, videoId, videoTitle, niche, subniche } = req.body || {};
    const userId = req.user.id;

    if (!transcript || typeof transcript !== 'string' || transcript.trim().length < 400) {
        return res.status(400).json({ msg: 'Forneça a transcrição completa (mínimo ~400 caracteres) para gerar a análise.' });
    }

    try {
        const result = await analyzeTranscriptForVirality({
            userId,
            transcript,
            videoTitle,
            niche,
            subniche
        });

        res.status(200).json({
            analysis: result.analysis,
            provider: result.provider,
            videoId: videoId || null
        });
    } catch (err) {
        console.error('[ERRO /api/video/transcript/analyze]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao analisar o roteiro.' });
    }
});

// === ROTA LAOZHANG PARA ANÁLISE DE TRANSCRIÇÃO ===
app.post('/api/video/transcript/analyze/laozhang', authenticateToken, async (req, res) => {
    const { transcript, videoId, videoTitle, niche, subniche } = req.body || {};
    const userId = req.user.id;

    if (!transcript || typeof transcript !== 'string' || transcript.trim().length < 400) {
        return res.status(400).json({ msg: 'Forneça a transcrição completa (mínimo ~400 caracteres) para gerar a análise.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        const sanitizedTranscript = transcript.trim();
        const truncatedTranscript = sanitizedTranscript.length > 20000
            ? `${sanitizedTranscript.substring(0, 20000)}\n[... conteúdo truncado para análise ...]`
            : sanitizedTranscript;

        const analysisPrompt = `
Você é um ESTRATEGISTA DE CONTEÚDO para YouTube. Analise profundamente o roteiro abaixo e explique POR QUE ele viralizou.

Retorne APENAS um JSON válido no formato:
{
  "resumo": "síntese em 2-3 frases",
  "motivosVirais": ["motivo 1", "motivo 2", "..."],
  "gatilhosEmocionais": ["gatilho 1", "..."],
  "estruturaNarrativa": [
    { "etapa": "Nome curto", "descricao": "O que acontece nessa parte", "tempoAproximado": "0:00-0:45" }
  ],
  "formulaChecklist": [
    {
      "item": "Elemento da fórmula",
      "status": "aplicado" ou "melhorar",
      "porqueFunciona": "Explicação curta",
      "comoAplicarNoMeuConteudo": "Diretriz prática",
      "upgradeSugerido": "Ajuste para ficar 10/10"
    }
  ],
  "diferencialProposto": "Diferencial para deixar ainda melhor",
  "sugestoesAplicacao": ["ação 1", "ação 2"],
  "alertas": ["possíveis riscos ou pontos de atenção"]
}

Regras:
- Idioma: português do Brasil.
- Não copie trechos do roteiro; descreva a fórmula e o raciocínio.
- Mostre como replicar a estrutura sem plagiar.
- Foque em transformar os aprendizados em um checklist acionável.

Contexto do vídeo:
- Título: ${videoTitle || 'N/A'}
- Nicho: ${niche || 'N/A'}
- Subnicho: ${subniche || 'N/A'}

ROTEIRO COMPLETO:
"""${truncatedTranscript}"""`;

        const response = await callLaozhangAPI(
            analysisPrompt,
            laozhangApiKey,
            'gpt-4o',
            null,
            userId,
            'api_transcript_analyze',
            JSON.stringify({ endpoint: '/api/video/transcript/analyze/laozhang', model: 'gpt-4o' })
        );

        // Parsear resposta JSON
        let analysis;
        const rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        try {
            analysis = JSON.parse(rawResponse);
        } catch (e) {
            // Tentar extrair JSON
            const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    analysis = JSON.parse(jsonMatch[0]);
                } catch (e2) {
                    throw new Error('Resposta da IA não contém JSON válido.');
                }
            } else {
                throw new Error('Resposta da IA não contém JSON válido.');
            }
        }

        res.status(200).json({
            analysis: analysis,
            provider: 'laozhang',
            videoId: videoId || null
        });
    } catch (err) {
        console.error('[ERRO /api/video/transcript/analyze/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao analisar o roteiro.' });
    }
});

// Rota para criar um agente de roteiro a partir de um vídeo transcrito
app.post('/api/script-agents/create', authenticateToken, async (req, res) => {
    const { videoId, videoUrl, videoTitle, agentName, niche, subniche, manualTranscript, viralInsights } = req.body;
    const userId = req.user.id;

    if (!videoId || !agentName) {
        return res.status(400).json({ msg: 'ID do vídeo e nome do agente são obrigatórios.' });
    }

    try {
        // PRIORIDADE 1: Usar transcrição manual se fornecida
        let fullTranscript = null;
        
        if (manualTranscript && manualTranscript.trim().length > 0) {
            fullTranscript = manualTranscript.trim();
            console.log(`[Agente] ✅ Usando transcrição manual fornecida pelo usuário (${fullTranscript.length} caracteres)`);
        } else {
            // PRIORIDADE 2: Buscar transcrição do banco de dados
            try {
                const analysis = await db.get(
                    'SELECT full_transcript FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                    [videoId, userId]
                );

                if (analysis && analysis.full_transcript) {
                    fullTranscript = analysis.full_transcript;
                    console.log(`[Agente] ✅ Usando transcrição do banco de dados (${fullTranscript.length} caracteres)`);
                } else {
                    // PRIORIDADE 3: Tentar buscar diretamente do YouTube (fallback antigo)
                    console.log(`[Agente] ⚠️ Transcrição não encontrada no banco, tentando método alternativo...`);
                    const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
                    if (geminiKeyData) {
                        const geminiApiKey = decrypt(geminiKeyData.api_key);
                        if (geminiApiKey) {
                            try {
                                const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
                                fullTranscript = transcriptData.map(t => t.text).join(' ');
                                console.log(`[Agente] ✅ Transcrição obtida via YouTube Transcript (${fullTranscript.length} caracteres)`);
                            } catch (ytErr) {
                                console.warn(`[Agente] ⚠️ Falha ao buscar transcrição via YouTube Transcript:`, ytErr.message);
                            }
                        }
                    }
                }
            } catch (transcriptErr) {
                console.warn('[Agente] Erro ao obter transcrição:', transcriptErr.message);
            }
        }

        // Se não houver transcrição, permitir criar agente básico (será criado com prompt básico)
        if (!fullTranscript || fullTranscript.trim().length < 100) {
            console.warn(`[Agente] ⚠️ Transcrição não disponível ou muito curta (${fullTranscript?.length || 0} caracteres). Criando agente com prompt básico.`);
            // Não retornar erro, mas criar agente com prompt básico baseado apenas no título e nicho
        }

        // Analisar e capturar a fórmula viral durante a criação do agente
        let viralFormulaData = null;
        if (fullTranscript && fullTranscript.trim().length >= 500) {
            try {
                const claudeKeyRow = await db.get(
                    'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                    [userId, 'claude']
                );

                if (claudeKeyRow && claudeKeyRow.api_key) {
                    const claudeApiKey = decrypt(claudeKeyRow.api_key);
                    if (claudeApiKey) {
                        const viralReplicator = new ViralFormulaReplicator();
                        console.log('[Agente] 🔍 Analisando fórmula viral durante criação do agente...');
                        viralFormulaData = await viralReplicator.analyzeViralFormula(
                            fullTranscript,
                            claudeApiKey,
                            videoTitle,
                            niche || subniche || 'geral'
                        );
                        console.log('[Agente] ✅ Fórmula viral capturada e pronta para reutilização futura.');
                    } else {
                        console.warn('[Agente] ⚠️ Falha ao desencriptar API key do Claude para análise de fórmula.');
                    }
                } else {
                    console.warn('[Agente] ⚠️ API key do Claude não configurada. Fórmula viral não será armazenada.');
                }
            } catch (formulaErr) {
                console.error('[Agente] ⚠️ Erro ao analisar fórmula viral durante criação do agente:', formulaErr.message);
            }
        }

        // Buscar provedor de IA preferencial (Claude > GPT > Gemini)
        const aiProvider = await getPreferredAIProvider(userId, ['claude', 'openai', 'gemini']);
        if (!aiProvider) {
            return res.status(400).json({ msg: 'Configure uma chave do Claude, OpenAI ou Gemini para criar agentes.' });
        }

        // Criar prompt para o agente usando IA
        let agentPrompt;
        let insightsSection = '';
        if (viralInsights && typeof viralInsights === 'object') {
            try {
                const serializedInsights = JSON.stringify(viralInsights);
                insightsSection = `\nINSIGHTS DO VÍDEO VIRAL (checklist e diferencial identificados anteriormente):\n${serializedInsights.substring(0, 6000)}\n`;
            } catch (err) {
                console.warn('[Agente] Não foi possível serializar viralInsights:', err.message);
            }
        }
        
        if (fullTranscript && fullTranscript.trim().length >= 100) {
            // Usar o roteiro completo (ou até 20000 caracteres para análise mais profunda)
            const transcriptToAnalyze = fullTranscript.length > 20000 
                ? fullTranscript.substring(0, 20000) + '\n[... roteiro continua ...]'
                : fullTranscript;
            
            agentPrompt = `Você é um ESPECIALISTA EM ANÁLISE DE ROTEIROS VIRAIS para YouTube. Sua missão é analisar profundamente o roteiro transcrito abaixo e identificar EXATAMENTE por que ele foi viral, capturando sua fórmula completa para replicação.

ROTEIRO COMPLETO DO VÍDEO VIRAL (TRANSCRITO):
${transcriptToAnalyze}

TÍTULO DO VÍDEO: ${videoTitle || 'N/A'}
NICHE: ${niche || 'N/A'}
SUBNICHE: ${subniche || 'N/A'}

ANÁLISE PROFUNDA REQUERIDA:

1. **ESTRUTURA NARRATIVA EXATA:**
   - Como o roteiro começa? (primeiros 15-30 segundos)
   - Qual é a progressão da narrativa? (desenvolvimento, clímax, resolução)
   - Como termina? (últimos 30 segundos)
   - Identifique a estrutura temporal exata (timing de cada seção)

2. **ELEMENTOS VIRAIS IDENTIFICADOS:**
   - Ganchos específicos usados (perguntas, afirmações chocantes, curiosidade)
   - Técnicas de engajamento (quando pede like, compartilhar, comentar)
   - Ritmo e cadência da narrativa (rápido, lento, variado)
   - Tom de voz (sério, descontraído, emocional, informativo)
   - Elementos de suspense e curiosidade
   - Transições entre tópicos

3. **FÓRMULA DO SUCESSO:**
   - Por que este roteiro específico foi viral?
   - Quais padrões se repetem que geram engajamento?
   - O que mantém o espectador assistindo até o final?
   - Elementos únicos que diferenciam este roteiro

4. **PADRÕES REPLICÁVEIS:**
   - Estrutura que pode ser aplicada a outros títulos
   - Elementos que devem ser mantidos em qualquer replicação
   - Variações permitidas sem perder a essência viral

Sua tarefa é criar um "agente de roteiro" que capture COMPLETAMENTE esta fórmula viral e seja capaz de replicá-la para QUALQUER título fornecido, mantendo a mesma estrutura e elementos virais identificados.

Crie:`;
        } else {
            // Se não houver transcrição, criar um prompt básico baseado apenas no título e nicho
            agentPrompt = `Você é um especialista em criar roteiros virais para YouTube. Crie um "agente de roteiro" baseado nas informações disponíveis sobre um vídeo de sucesso.

TÍTULO DO VÍDEO: ${videoTitle || 'N/A'}
NICHE: ${niche || 'N/A'}
SUBNICHE: ${subniche || 'N/A'}

NOTA: A transcrição completa do vídeo não está disponível, mas você deve criar um agente de roteiro baseado no título, nicho e subnicho fornecidos. O agente deve ser capaz de gerar roteiros virais seguindo o padrão sugerido pelo título e contexto do nicho.

Crie:`;
        }

        agentPrompt += `${insightsSection}
IMPORTANTE:
- NÃO copie o texto do roteiro original.
- Extraia apenas a FÓRMULA, estrutura, ritmo e gatilhos que tornam o vídeo viral.
- Inclua melhorias e correções para levar o resultado a nível 10/10.
- Produza prompts e instruções claros para que qualquer novo título possa reutilizar essa fórmula com diferenciais.
`;

        agentPrompt += `
1. **"agent_prompt"**: Um prompt base que será usado para gerar novos roteiros. Este prompt deve:
   - Capturar a estrutura narrativa exata identificada no roteiro viral
   - Incluir os elementos virais específicos (ganchos, ritmo, tom, técnicas)
   - Ser capaz de adaptar essa estrutura para QUALQUER título fornecido
   - Manter a fórmula de sucesso identificada

2. **"agent_instructions"**: Instruções detalhadas que explicam:
   - A estrutura exata do roteiro (timing, seções, progressão)
   - Os elementos virais que DEVEM ser mantidos em cada replicação
   - Como adaptar o conteúdo para novos títulos mantendo a essência
   - Padrões e fórmulas identificadas que geram engajamento
   - Exemplos específicos do roteiro original que devem ser replicados

IMPORTANTE: O agente deve ser capaz de receber APENAS um título de vídeo e gerar um roteiro completo seguindo EXATAMENTE a mesma estrutura e fórmula viral do roteiro original analisado.

Responda APENAS com um objeto JSON válido no seguinte formato:
{
  "agent_prompt": "Prompt base detalhado que captura a estrutura e elementos virais do roteiro original...",
  "agent_instructions": "Instruções completas sobre a estrutura exata, timing, elementos virais, e como replicar a fórmula para qualquer título..."
}`;

        let response;
        let responseText = '';
        
        if (aiProvider.service === 'laozhang') {
            response = await callLaozhangAPI(
                agentPrompt, 
                aiProvider.apiKey, 
                aiProvider.model, 
                null, 
                userId, 
                'api_call', 
                JSON.stringify({ endpoint: '/api/script-agents/create', model: aiProvider.model })
            );
            // callLaozhangAPI retorna string diretamente
            responseText = typeof response === 'string' ? response : JSON.stringify(response);
        } else if (aiProvider.service === 'claude') {
            response = await callClaudeAPI(agentPrompt, aiProvider.apiKey, aiProvider.model);
        } else if (aiProvider.service === 'openai') {
            response = await callOpenAIAPI(agentPrompt, aiProvider.apiKey, aiProvider.model);
        } else {
            response = await callGeminiAPI(agentPrompt, aiProvider.apiKey, aiProvider.model);
        }
        
        // Extrair o texto da resposta (se ainda não foi extraído para laozhang)
        if (aiProvider.service !== 'laozhang') {
            if (response && response.titles) {
                responseText = response.titles;
            } else if (typeof response === 'string') {
                responseText = response;
            } else {
                console.error(`[Agente] Formato de resposta inesperado:`, typeof response);
                throw new Error('Formato de resposta inesperado da API');
            }
        }
        
        console.log(`[Agente] Resposta recebida (primeiros 500 caracteres):`, responseText.substring(0, 500));
        
        let agentPromptText = '';
        let agentInstructions = '';

        try {
            // Como o Gemini está configurado com responseMimeType: "application/json",
            // a resposta deve ser JSON válido diretamente
            let parsed;
            
            // Tentar parsear diretamente como JSON
            try {
                parsed = JSON.parse(responseText);
            } catch (directParseError) {
                // Se falhar, tentar extrair JSON da resposta (pode ter markdown ou texto extra)
                let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    // Tentar encontrar JSON entre markdown code blocks
                    jsonMatch = responseText.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
                    if (jsonMatch && jsonMatch[1]) {
                        parsed = JSON.parse(jsonMatch[1]);
                    } else {
                        throw new Error('Nenhum JSON encontrado na resposta');
                    }
                } else {
                    // Limpar e parsear JSON extraído
                    const cleanedJson = jsonMatch[0]
                        .replace(/```json|```/g, '')
                        .trim();
                    parsed = JSON.parse(cleanedJson);
                }
            }
            
            // Verificar se o JSON tem os campos esperados
            if (parsed && parsed.agent_prompt && parsed.agent_instructions) {
                agentPromptText = parsed.agent_prompt;
                agentInstructions = parsed.agent_instructions;
                console.log(`[Agente] ✅ Agente criado com sucesso a partir da resposta do Gemini`);
            } else {
                console.warn(`[Agente] JSON parseado mas campos ausentes. Campos encontrados:`, Object.keys(parsed || {}));
                throw new Error('JSON não contém agent_prompt e agent_instructions');
            }
        } catch (parseError) {
            console.warn(`[Agente] Erro ao parsear resposta do Gemini:`, parseError.message);
            console.log(`[Agente] Resposta completa recebida:`, responseText);
            
            // Fallback: criar um prompt básico baseado no vídeo
            agentPromptText = `Você é um roteirista especializado em criar documentários virais para YouTube. Analise o seguinte padrão comprovado e crie um novo roteiro de documentário cativante e informativo.

**Padrão de Sucesso (baseado no vídeo "${videoTitle}"):**
- Estrutura narrativa envolvente com ganchos poderosos
- Ritmo dinâmico que mantém o espectador engajado
- Informações precisas apresentadas de forma acessível
- Elementos visuais e sonoros que complementam a narrativa

**Nicho:** ${niche || 'N/A'}
**Sub-nicho:** ${subniche || 'N/A'}

Crie roteiros seguindo esta estrutura e estilo, adaptando o conteúdo para novos tópicos dentro do mesmo nicho.`;

            agentInstructions = `Este agente foi criado a partir do vídeo "${videoTitle || 'N/A'}".

**Como usar:**
1. Forneça um novo tópico dentro do nicho "${niche || 'geral'}"
2. O agente gerará um roteiro seguindo a mesma estrutura e estilo do vídeo original
3. Mantenha os elementos que tornaram o vídeo original um sucesso: ganchos poderosos, ritmo envolvente, estrutura narrativa clara

**Elementos virais identificados:**
- Abertura enigmática que captura atenção imediata
- Desenvolvimento progressivo da narrativa
- Informações apresentadas de forma envolvente
- Conclusão que deixa o espectador querendo mais`;
            
            console.log(`[Agente] Usando fallback: prompt básico criado`);
        }

        const viralFormulaJson = viralFormulaData ? JSON.stringify(viralFormulaData) : null;

        // Salvar o agente no banco de dados
        const result = await db.run(
            `INSERT INTO script_agents (user_id, agent_name, niche, subniche, source_video_id, source_video_url, source_video_title, full_transcript, agent_prompt, agent_instructions, viral_formula_json)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, agentName, niche || null, subniche || null, videoId, videoUrl || null, videoTitle || null, fullTranscript, agentPromptText, agentInstructions, viralFormulaJson]
        );

        res.status(200).json({
            msg: 'Agente de roteiro criado com sucesso!',
            agentId: result.lastID,
            agent: {
                id: result.lastID,
                name: agentName,
                niche: niche || null,
                subniche: subniche || null,
                hasViralFormula: !!viralFormulaJson
            }
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/create]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao criar agente de roteiro.' });
    }
});

// === ROTA LAOZHANG PARA CRIAÇÃO DE AGENTES ===
app.post('/api/script-agents/create/laozhang', authenticateToken, async (req, res) => {
    const { videoId, videoUrl, videoTitle, agentName, niche, subniche, manualTranscript, viralInsights } = req.body;
    const userId = req.user.id;

    if (!videoId || !agentName) {
        return res.status(400).json({ msg: 'ID do vídeo e nome do agente são obrigatórios.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Buscar transcrição (mesma lógica da rota original)
        let fullTranscript = null;
        if (manualTranscript && manualTranscript.trim().length > 0) {
            fullTranscript = manualTranscript.trim();
        } else {
            const analysis = await db.get(
                'SELECT full_transcript FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                [videoId, userId]
            );
            if (analysis && analysis.full_transcript) {
                fullTranscript = analysis.full_transcript;
            }
        }

        // Criar prompt (mesma lógica da rota original, simplificado)
        let agentPrompt = fullTranscript && fullTranscript.trim().length >= 100
            ? `Você é um ESPECIALISTA EM ANÁLISE DE ROTEIROS VIRAIS para YouTube. Analise o roteiro abaixo e crie um agente de roteiro.

ROTEIRO: ${fullTranscript.substring(0, 20000)}
TÍTULO: ${videoTitle || 'N/A'}
NICHE: ${niche || 'N/A'}
SUBNICHE: ${subniche || 'N/A'}

Retorne JSON:
{
  "agent_prompt": "Prompt base...",
  "agent_instructions": "Instruções detalhadas..."
}`
            : `Crie um agente de roteiro baseado em:
TÍTULO: ${videoTitle || 'N/A'}
NICHE: ${niche || 'N/A'}
SUBNICHE: ${subniche || 'N/A'}

Retorne JSON:
{
  "agent_prompt": "Prompt base...",
  "agent_instructions": "Instruções detalhadas..."
}`;

        const response = await callLaozhangAPI(
            agentPrompt,
            laozhangApiKey,
            'claude-3-7-sonnet-20250219',
            null,
            userId,
            'api_script_agents_create',
            JSON.stringify({ endpoint: '/api/script-agents/create/laozhang', model: 'claude-3-7-sonnet-20250219' })
        );

        // Parsear resposta
        let agentPromptText, agentInstructions;
        let rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        // Limpar caracteres de controle inválidos do JSON
        // Remover quebras de linha e tabs não escapados dentro de strings JSON
        rawResponse = rawResponse
            .replace(/\n/g, '\\n')  // Escapar quebras de linha
            .replace(/\r/g, '\\r')  // Escapar carriage return
            .replace(/\t/g, '\\t')  // Escapar tabs
            .replace(/\f/g, '\\f')  // Escapar form feed
            .replace(/\b/g, '\\b')  // Escapar backspace
            // Mas manter quebras de linha válidas fora de strings (formatação JSON)
            .replace(/\\n(?=\s*[,\}\]])/g, '\n')  // Restaurar quebras de linha válidas após vírgulas/fechamentos
            .replace(/\\n(?=\s*")/g, '\n');      // Restaurar quebras de linha válidas antes de strings
        
        // Tentar extrair JSON de markdown code blocks primeiro
        const codeBlockMatch = rawResponse.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
        if (codeBlockMatch && codeBlockMatch[1]) {
            rawResponse = codeBlockMatch[1];
        }
        
        try {
            // Tentar parse direto
            const parsed = JSON.parse(rawResponse);
            agentPromptText = parsed.agent_prompt || parsed.agentPrompt;
            agentInstructions = parsed.agent_instructions || parsed.agentInstructions;
        } catch (e) {
            console.warn('[Agente Laozhang] Erro ao parsear JSON diretamente, tentando extrair:', e.message);
            
            // Tentar extrair JSON usando regex mais robusto
            const jsonMatch = rawResponse.match(/\{[\s\S]*"agent_prompt"[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    // Limpar caracteres de controle problemáticos antes de parsear
                    let cleanedJson = jsonMatch[0]
                        .replace(/[\x00-\x1F\x7F]/g, '') // Remover caracteres de controle
                        .replace(/([^\\])\n/g, '$1\\n')  // Escapar quebras de linha não escapadas
                        .replace(/([^\\])\r/g, '$1\\r')  // Escapar carriage return não escapados
                        .replace(/([^\\])\t/g, '$1\\t'); // Escapar tabs não escapados
                    
                    const parsed = JSON.parse(cleanedJson);
                    agentPromptText = parsed.agent_prompt || parsed.agentPrompt;
                    agentInstructions = parsed.agent_instructions || parsed.agentInstructions;
                } catch (e2) {
                    console.error('[Agente Laozhang] Erro ao parsear JSON extraído:', e2.message);
                    // Fallback: tentar extrair valores diretamente com regex
                    const promptMatch = rawResponse.match(/"agent_prompt"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
                    const instructionsMatch = rawResponse.match(/"agent_instructions"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
                    
                    if (promptMatch && promptMatch[1]) {
                        agentPromptText = promptMatch[1].replace(/\\n/g, '\n').replace(/\\"/g, '"');
                    }
                    if (instructionsMatch && instructionsMatch[1]) {
                        agentInstructions = instructionsMatch[1].replace(/\\n/g, '\n').replace(/\\"/g, '"');
                    }
                    
                    // Se ainda não conseguiu, usar fallback
                    if (!agentPromptText) {
                        agentPromptText = `Crie roteiros virais para YouTube no nicho ${niche || 'geral'}.`;
                    }
                    if (!agentInstructions) {
                        agentInstructions = `Agente criado a partir do vídeo "${videoTitle || 'N/A'}".`;
                    }
                }
            } else {
                console.warn('[Agente Laozhang] Nenhum JSON encontrado na resposta, usando fallback');
                // Fallback
                agentPromptText = `Crie roteiros virais para YouTube no nicho ${niche || 'geral'}.`;
                agentInstructions = `Agente criado a partir do vídeo "${videoTitle || 'N/A'}".`;
            }
        }
        
        // Garantir que temos valores válidos
        if (!agentPromptText || agentPromptText.trim().length === 0) {
            agentPromptText = `Crie roteiros virais para YouTube no nicho ${niche || 'geral'}.`;
        }
        if (!agentInstructions || agentInstructions.trim().length === 0) {
            agentInstructions = `Agente criado a partir do vídeo "${videoTitle || 'N/A'}".`;
        }

        // Salvar agente
        const result = await db.run(
            `INSERT INTO script_agents (user_id, agent_name, niche, subniche, source_video_id, source_video_url, source_video_title, full_transcript, agent_prompt, agent_instructions)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, agentName, niche || null, subniche || null, videoId, videoUrl || null, videoTitle || null, fullTranscript, agentPromptText, agentInstructions]
        );

        res.status(201).json({
            msg: 'Agente de roteiro criado com sucesso!',
            agentId: result.lastID
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/create/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao criar agente de roteiro.' });
    }
});

// Rota para listar todos os agentes de roteiro do usuário
app.get('/api/script-agents', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const agents = await db.all(
            `SELECT id, agent_name, niche, subniche, source_video_title, usage_count, created_at, updated_at
             FROM script_agents
             WHERE user_id = ?
             ORDER BY updated_at DESC`,
            [userId]
        );

        res.status(200).json({ agents });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents]:', err);
        res.status(500).json({ msg: 'Erro ao listar agentes de roteiro.' });
    }
});

// Rota para obter detalhes de um agente específico
app.get('/api/script-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        const agent = await db.get(
            `SELECT * FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        res.status(200).json({ agent });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId]:', err);
        res.status(500).json({ msg: 'Erro ao buscar agente.' });
    }
});

// Função helper para enviar progresso via SSE
function sendProgress(sessionId, data) {
    const client = sseClients.get(sessionId);
    if (client) {
        client.write(`data: ${JSON.stringify(data)}\n\n`);
    }
}

// Rota SSE para progresso em tempo real (aceita token via header ou query string)
app.get('/api/script-agents/progress/:sessionId', (req, res) => {
    const { sessionId } = req.params;
    
    // Permite token via Authorization header ou query ?token=
    const authHeader = req.headers['authorization'];
    let token = authHeader && authHeader.split(' ')[1];
    if (!token && req.query && req.query.token) {
        token = req.query.token;
    }
    
    if (!token) {
        return res.status(401).json({ msg: 'Token não fornecido.' });
    }
    
    jwt.verify(token, JWT_SECRET, (err) => {
        if (err) {
            return res.status(403).json({ msg: 'Token inválido ou expirado.' });
        }
        
        res.setHeader('Content-Type', 'text/event-stream');
        res.setHeader('Cache-Control', 'no-cache');
        res.setHeader('Connection', 'keep-alive');
        res.flushHeaders();
        
        sseClients.set(sessionId, res);
        console.log(`[SSE] Cliente conectado: ${sessionId}`);
        
        req.on('close', () => {
            sseClients.delete(sessionId);
            console.log(`[SSE] Cliente desconectado: ${sessionId}`);
        });
    });
});

// Rota para gerar roteiro usando um agente
app.post('/api/script-agents/:agentId/generate', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { title, topic, duration, language, cta, model, additionalInstructions, sessionId, parts } = req.body;
    const userId = req.user.id;

    if (!title) {
        return res.status(400).json({ msg: 'Título do vídeo é obrigatório.' });
    }

        // Se não fornecer duração, usar 5 minutos como padrão
        let scriptDuration = duration ? parseInt(duration) : 5;
        
        // Se não fornecer idioma, usar português como padrão
        const scriptLanguage = language || 'pt';
        
        // Configurar CTAs (Call to Action)
        const ctaConfig = {
            inicio: cta?.inicio || false,
            meio: cta?.meio || false,
            final: cta?.final !== undefined ? cta.final : true // Padrão: CTA no final
        };
        
        // Se não fornecer modelo, usar Claude como padrão (recomendado para roteiros)
        const selectedModel = model || 'claude-3-7-sonnet-20250219';
        
        // A duração já vem ajustada do frontend (com 3-5 minutos extras)
        // Não adicionar mais minutos aqui para evitar duplicação
        // Mas aumentar wordsPerMinute para garantir margem de segurança
        const originalDuration = scriptDuration;
        console.log(`[Script Generate] Duração recebida do frontend: ${scriptDuration} minutos (já ajustada)`);

    try {
        console.log(`[Script Generate] Requisição recebida - agentId: ${agentId}, userId: ${userId}, title: ${title}`);
        
        if (!agentId) {
            console.error(`[Script Generate] agentId não fornecido na URL`);
            return res.status(400).json({ msg: 'ID do agente é obrigatório.' });
        }

        // Buscar o agente
        console.log(`[Script Generate] Buscando agente com id=${agentId} e user_id=${userId}`);
        
        // Primeiro, verificar se o agente existe (sem filtro de user_id)
        const agentExists = await db.get(
            `SELECT id, user_id, agent_name FROM script_agents WHERE id = ?`,
            [agentId]
        );
        
        if (!agentExists) {
            console.error(`[Script Generate] Agente ${agentId} não existe no banco de dados`);
            // Listar todos os agentes do usuário para debug
            const userAgents = await db.all(
                `SELECT id, agent_name FROM script_agents WHERE user_id = ?`,
                [userId]
            );
            console.log(`[Script Generate] Agentes disponíveis para user_id=${userId}:`, userAgents);
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }
        
        if (agentExists.user_id !== userId) {
            console.error(`[Script Generate] Agente ${agentId} existe mas pertence ao user_id=${agentExists.user_id}, não ao user_id=${userId}`);
            return res.status(403).json({ msg: 'Você não tem permissão para usar este agente.' });
        }
        
        // Buscar o agente completo
        const agent = await db.get(
            `SELECT * FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );
        
        if (!agent) {
            console.error(`[Script Generate] Erro inesperado: agente existe mas não foi encontrado com filtro user_id`);
            return res.status(500).json({ msg: 'Erro ao buscar agente.' });
        }

        console.log(`[Script Generate] Agente encontrado: ${agent.agent_name || 'Sem nome'}`);

        // Identificar serviço e buscar chave
        let service;
        if (selectedModel.startsWith('gemini')) service = 'gemini';
        else if (selectedModel.startsWith('claude')) service = 'claude';
        else if (selectedModel.startsWith('gpt')) service = 'openai';
        else service = 'gemini';

        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
        if (!keyData) {
            return res.status(400).json({ msg: `Chave de API do ${service} não configurada.` });
        }
        const decryptedKey = decrypt(keyData.api_key);
        if (!decryptedKey) {
            return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
        }

        // Dividir em blocos de 3 minutos para respeitar o front-end
        const BASE_PART_DURATION = 3;
        const idealParts = Math.max(1, Math.ceil(scriptDuration / BASE_PART_DURATION));
        let requestedParts = parseInt(parts, 10);
        if (Number.isNaN(requestedParts) || requestedParts <= 0) {
            requestedParts = null;
        }
        // SEMPRE respeitar o número de partes solicitado pelo frontend
        let numberOfParts = requestedParts || idealParts;
        if (requestedParts) {
            console.log(`[Roteiro] Usando número de partes solicitado pelo frontend: ${requestedParts} (ideal seria ${idealParts})`);
            numberOfParts = requestedParts; // SEMPRE usar o valor do frontend
        } else {
            console.log(`[Roteiro] Nenhuma parte especificada, usando cálculo ideal: ${idealParts}`);
            numberOfParts = idealParts;
        }
        
        const partDurations = [];
        for (let idx = 0; idx < numberOfParts; idx++) {
            if (idx === numberOfParts - 1) {
                const consumed = BASE_PART_DURATION * (numberOfParts - 1);
                const remaining = scriptDuration - consumed;
                partDurations.push(remaining > 0 ? remaining : BASE_PART_DURATION);
            } else {
                partDurations.push(Math.min(BASE_PART_DURATION, scriptDuration));
            }
        }
        
        console.log(`[Roteiro] Duração: ${scriptDuration} minutos. Dividindo em ${numberOfParts} parte(s) (~3 minutos cada). Última parte: ${partDurations[numberOfParts - 1]} minuto(s).`);

        let scriptContent = '';

        // Se for dividido em partes, gerar cada parte separadamente
        if (numberOfParts > 1) {
            console.log(`[Roteiro] Gerando roteiro em ${numberOfParts} partes...`);
            const scriptParts = [];
            
            // Enviar progresso inicial
            if (sessionId) {
                sendProgress(sessionId, {
                    stage: 'generating',
                    progress: 0,
                    currentPart: 0,
                    totalParts: numberOfParts,
                    message: `Iniciando geração de ${numberOfParts} partes...`
                });
            }
            
            for (let partIndex = 0; partIndex < numberOfParts; partIndex++) {
                const isLastPart = partIndex === numberOfParts - 1;
                const currentPartDuration = partDurations[partIndex] || BASE_PART_DURATION;
                const currentPartWords = currentPartDuration * wordsPerMinute;
                const partNumber = partIndex + 1;
                
                console.log(`[Roteiro] Gerando parte ${partNumber}/${numberOfParts} (${currentPartDuration} minutos, ~${currentPartWords} palavras)...`);
                
                const partPrompt = `${agent.agent_prompt || 'Crie um roteiro viral para YouTube seguindo a estrutura e fórmula identificada no roteiro viral original.'}

INSTRUÇÕES DETALHADAS DO AGENTE (FÓRMULA VIRAL):
${agent.agent_instructions || ''}

${additionalInstructions ? `\nINSTRUÇÕES ADICIONAIS DO USUÁRIO:\n${additionalInstructions}\n` : ''}

TÍTULO DO VÍDEO PARA O QUAL DEVO CRIAR O ROTEIRO:
"${title}"

IMPORTANTE: Este é apenas a PARTE ${partNumber} de ${numberOfParts} do roteiro completo.

DURAÇÃO DESTA PARTE: ${currentPartDuration} minutos (${currentPartDuration * 60} segundos)

IDIOMA DO ROTEIRO: ${scriptLanguage === 'pt' ? 'Português (Brasil)' : scriptLanguage === 'pt-PT' ? 'Português (Portugal)' : scriptLanguage === 'es' ? 'Español' : scriptLanguage === 'en' ? 'English' : scriptLanguage === 'fr' ? 'Français' : scriptLanguage === 'de' ? 'Deutsch' : scriptLanguage === 'it' ? 'Italiano' : scriptLanguage === 'ru' ? 'Русский' : scriptLanguage === 'ja' ? '日本語' : scriptLanguage === 'zh' ? '中文' : scriptLanguage}

${(ctaConfig.inicio && partIndex === 0) || (ctaConfig.meio && partIndex === Math.floor(numberOfParts / 2)) || (ctaConfig.final && isLastPart) ? `═══════════════════════════════════════════════════════════════════
⚠️⚠️⚠️ CALL TO ACTION (CTA) - OBRIGATÓRIO E NATURAL ⚠️⚠️⚠️
═══════════════════════════════════════════════════════════════════
${ctaConfig.inicio && partIndex === 0 ? `✅ CTA no INÍCIO (primeiros 30 segundos): 
   - Você DEVE incluir uma chamada para ação NATURAL e ORGÂNICA nos primeiros 30 segundos desta parte
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar forçado
   - Exemplos naturais: "Se você está gostando deste conteúdo, já deixa seu like e se inscreva no canal para não perder os próximos vídeos", "Antes de continuar, se inscreva no canal e ative o sininho para receber notificações", "Se este conteúdo está te ajudando, já deixa seu like e comenta o que achou"
   - O CTA deve fazer parte do fluxo narrativo natural, não deve parecer uma interrupção
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, não uma marcação separada\n` : ''}
${ctaConfig.meio && partIndex === Math.floor(numberOfParts / 2) ? `✅ CTA no MEIO (aproximadamente na metade do vídeo):
   - Você DEVE incluir uma chamada para ação NATURAL e ORGÂNICA no meio desta parte
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar forçado
   - Exemplos naturais: "Se você está aprendendo algo novo aqui, já deixa seu like e compartilha com quem precisa ver isso", "Antes de continuarmos, se inscreva no canal para não perder o restante deste conteúdo", "Se este vídeo está te ajudando, já deixa seu like e comenta suas dúvidas"
   - O CTA deve fazer parte do fluxo narrativo natural, não deve parecer uma interrupção
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, não uma marcação separada\n` : ''}
${ctaConfig.final && isLastPart ? `✅ CTA no FINAL (últimos 30 segundos):
   - Você DEVE incluir uma chamada para ação FORTE, NATURAL e ORGÂNICA nos últimos 30 segundos desta parte
   - Este é o CTA mais importante - deve ser impactante mas ainda assim natural
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar forçado
   - Exemplos naturais: "Se este conteúdo te ajudou, já deixa seu like, se inscreva no canal, ative o sininho, compartilhe com seus amigos e comente o que achou", "Não esqueça de deixar seu like, se inscrever no canal e compartilhar este vídeo com quem precisa ver isso", "Se você gostou deste conteúdo, já deixa seu like, se inscreva no canal, ative o sininho para receber notificações e compartilhe com seus amigos"
   - O CTA deve fazer parte do fluxo narrativo natural, não deve parecer uma interrupção
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, não uma marcação separada
   - CRÍTICO: Este CTA final é essencial para o engajamento do vídeo\n` : ''}
⚠️ REGRAS IMPORTANTES SOBRE CTAs:
- Os CTAs devem ser incluídos de forma NATURAL e ORGÂNICA no texto narrativo
- NÃO use marcações como "[CTA]", "(CTA)", ou qualquer indicação explícita de CTA
- NÃO interrompa o fluxo narrativo abruptamente para incluir o CTA
- O CTA deve fazer parte da narrativa, como se fosse uma conversa natural com o espectador
- Use linguagem conversacional e envolvente
- Seja persuasivo mas genuíno, não forçado
- O CTA deve parecer que faz parte naturalmente do roteiro, não algo adicionado depois
` : ''}

${topic ? `TÓPICO ESPECÍFICO (se fornecido): ${topic}\n` : ''}
NICHE: ${agent.niche || 'N/A'}
SUBNICHE: ${agent.subniche || 'N/A'}

TAREFA:
Crie a PARTE ${partNumber} de ${numberOfParts} do roteiro COMPLETO e DETALHADO para o título acima, seguindo EXATAMENTE a mesma estrutura, ritmo, tom e elementos virais identificados no roteiro original.

O roteiro desta parte deve:
- Ter EXATAMENTE ${currentPartDuration} minutos de duração (${currentPartDuration * 60} segundos)
${!isLastPart ? `- ⚠️ CRÍTICO - ESTRUTURA OBRIGATÓRIA: Esta parte DEVE ter EXATAMENTE 5 PARÁGRAFOS
- Cada parte DEVE ter ENTRE 390 e 450 PALAVRAS (total da parte)
- Cada parágrafo DEVE ter ENTRE 75 e 90 PALAVRAS
- Distribuição ideal: 5 parágrafos × 78-90 palavras cada = 390-450 palavras totais
- Cada parágrafo deve ser separado por uma quebra de linha dupla (espaço em branco entre parágrafos)
- Os 5 parágrafos devem estar bem distribuídos ao longo dos ${currentPartDuration} minutos desta parte
- Estrutura obrigatória: 5 parágrafos distintos e bem definidos, cada um com 75-90 palavras` : `- Esta é a ÚLTIMA parte do roteiro - pode ter um número variável de parágrafos conforme necessário para concluir o conteúdo`}
- Replicar a estrutura narrativa exata do roteiro viral original
- Manter os mesmos elementos virais (ganchos, ritmo, tom, técnicas de engajamento)
- Adaptar o conteúdo para o novo título fornecido
- CRÍTICO: NÃO inclua marcações como "(Música...)", "(Visual:...)", "NARRADOR:", etc.
- O roteiro deve ser APENAS texto puro para voice over, sem direções de cena, música ou visualizações
- Escreva como se estivesse narrando diretamente, sem prefixos ou marcações técnicas
- Manter a fórmula de sucesso que tornou o roteiro original viral
- Distribuir o conteúdo proporcionalmente para preencher os ${currentPartDuration} minutos desta parte

FORMATO DE RESPOSTA OBRIGATÓRIO:
- Responda APENAS com o roteiro em TEXTO SIMPLES (não use JSON, não use estruturas de dados)
- NÃO use formato JSON, não use objetos, não use arrays, não use chaves {}
${!isLastPart ? `- ⚠️ CRÍTICO: Esta parte DEVE ter EXATAMENTE 5 PARÁGRAFOS
- Cada parte DEVE ter ENTRE 390 e 450 PALAVRAS (total da parte)
- Cada parágrafo DEVE ter ENTRE 75 e 90 PALAVRAS
- Distribuição ideal: 5 parágrafos × 78-90 palavras cada = 390-450 palavras totais
- Cada parágrafo deve ser separado por uma quebra de linha dupla (espaço em branco entre parágrafos)
- Estrutura obrigatória: 5 parágrafos distintos e bem definidos, cada um com 75-90 palavras
- Os 5 parágrafos devem estar bem distribuídos ao longo dos ${currentPartDuration} minutos desta parte` : `- Esta é a ÚLTIMA parte - pode ter um número variável de parágrafos conforme necessário para concluir`}
- O roteiro deve ser texto corrido, dividido em parágrafos ou seções claras
- Cada seção pode ter indicação de tempo entre parênteses ou colchetes, mas o conteúdo deve ser texto narrativo direto
- Exemplo de formato correto:
  "[0:00-0:30] Texto do roteiro aqui... 
  
  [0:30-1:30] Continuação do roteiro...
  
  [1:30-3:00] Mais conteúdo..."
  
- NÃO use formato como: {"section": "...", "time": "...", "content": "..."}
- NÃO use listas numeradas ou com marcadores para estruturar o roteiro
- O roteiro deve ser texto narrativo fluido, como se fosse o texto que será narrado no vídeo

REGRAS CRÍTICAS DE DURAÇÃO PARA ESTA PARTE - OBRIGATÓRIO:
- Esta PARTE ${partNumber} do roteiro DEVE ter EXATAMENTE ${currentPartDuration} minutos de duração
${!isLastPart ? `- ⚠️ CRÍTICO: Esta PARTE DEVE ter ENTRE 390 e 450 PALAVRAS (total)
- Esta PARTE DEVE ter EXATAMENTE 5 PARÁGRAFOS
- Cada PARÁGRAFO deve ter ENTRE 75 e 90 PALAVRAS
- Distribuição: 5 parágrafos × 78-90 palavras = 390-450 palavras totais
- META DE PALAVRAS DA PARTE: 390-450 palavras
- META DE PALAVRAS POR PARÁGRAFO: 75-90 palavras` : `- Esta é a ÚLTIMA parte - pode ter número variável de palavras e parágrafos conforme necessário`}
- ⚠️ CRÍTICO: Se você retornar menos de ${currentPartWords - 50} palavras ou mais de ${currentPartWords + 50} palavras, o roteiro será REJEITADO
- ⚠️ CRÍTICO: NÃO retorne JSON vazio, NÃO retorne objetos, NÃO retorne apenas estrutura - ESCREVA O ROTEIRO COMPLETO COM ${currentPartWords} PALAVRAS
- Se esta parte tiver menos de ${currentPartWords} palavras, você DEVE expandir o conteúdo até atingir EXATAMENTE ${currentPartWords} palavras
- Distribua o conteúdo proporcionalmente para preencher TODOS os ${currentPartDuration} minutos desta parte
- IMPORTANTE: Conte as palavras antes de finalizar. Esta parte DEVE ter entre ${currentPartWords} e ${currentPartWords + 50} palavras
- CRÍTICO: Se você não conseguir gerar ${currentPartWords} palavras, continue expandindo o conteúdo até atingir essa quantidade

CONTEXTO DA PARTE:
${partIndex === 0 ? '- Esta é a PRIMEIRA parte do roteiro. Comece com um gancho poderoso e envolvente.' : ''}
${!isLastPart ? `- Esta é a parte ${partNumber} de ${numberOfParts}. Continue a narrativa de forma fluida, desenvolvendo o tema.` : ''}
${isLastPart ? `- Esta é a ÚLTIMA parte do roteiro (parte ${partNumber} de ${numberOfParts}). Conclua de forma impactante e envolvente.` : ''}
${partIndex > 0 ? `- A parte anterior terminou em um ponto específico. Continue naturalmente a partir desse ponto.` : ''}

RESPOSTA FINAL - CRÍTICO:
- Responda APENAS com o roteiro em TEXTO SIMPLES e DIRETO
- NÃO use JSON, NÃO use objetos {}, NÃO use arrays [], NÃO use chaves ou colchetes para estruturar
- NÃO use formato: {"roteiro": "...", "duracao": "...", "estrutura": "..."}
- NÃO use formato: [{"section": "...", "time": "...", "content": "..."}]
- O roteiro deve ser texto corrido, como se você estivesse escrevendo o texto que será narrado
- ⚠️ CRÍTICO - NÃO INCLUA MARCAÇÕES DE PARTE OU TEMPO:
  - NÃO inclua marcações como "PARTE 1", "Parte 1", "PARTE 1 0:00 - 3:00", "Parte 1 0:00 - 3:00"
  - NÃO inclua marcações de tempo como "[0:00-3:00]", "(0:00)", "0:00 - 3:00", "0:00-3:00"
  - NÃO inclua qualquer indicação de número de parte ou intervalo de tempo no texto
  - O roteiro deve ser APENAS texto narrativo puro, sem marcações técnicas
  - Escreva como se estivesse narrando diretamente, sem prefixos, sem marcações de parte ou tempo
  - CRÍTICO: Se você incluir marcações de parte ou tempo, o roteiro será rejeitado
- IMPORTANTE: O roteiro será usado para VOICE OVER, então escreva de forma natural e fluida
- Use pontos finais e dois pontos para separar frases naturalmente
- Exemplo CORRETO de resposta:
  "[0:00-0:30] Em meio às selvas densas da América Central, duas civilizações se enfrentaram...
  
  [0:30-1:30] Os Mayas, mestres do tempo e da escrita, construíram impérios...
  
  [1:30-3:00] As raízes dos Mayas se estendem por séculos, florescendo nas terras baixas..."
  
- Exemplo ERRADO (NÃO FAÇA ISSO):
  {"roteiro": "texto", "duracao": "15 minutos"}
- O texto deve estar pronto para ser copiado e usado diretamente na narração do vídeo
- NÃO inclua NADA além do roteiro em si - nem explicações, nem metadados, nem JSON
- NÃO mencione que é "parte X" no texto do roteiro - escreva como se fosse um roteiro contínuo
- CRÍTICO: NÃO inclua marcações como "(Música...)", "(Visual:...)", "NARRADOR:", etc.
- O roteiro deve ser APENAS texto puro para voice over, sem direções de cena, música ou visualizações
- Escreva como se estivesse narrando diretamente, sem prefixos ou marcações técnicas
- Meta de palavras para ESTA PARTE: ${currentPartWords} palavras para ${currentPartDuration} minutos`;

                // Sistema de retry: tentar gerar a parte até 3x em caso de erro
                let partGenerationSuccess = false;
                let partResponse;
                let retryCount = 0;
                const MAX_RETRIES = 3;
                
                while (!partGenerationSuccess && retryCount < MAX_RETRIES) {
                    try {
                        if (retryCount > 0) {
                            console.log(`[Roteiro] Tentativa ${retryCount + 1}/${MAX_RETRIES} para parte ${partNumber}...`);
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'generating',
                                    progress: Math.min(80, Math.round((partIndex / numberOfParts) * 80)),
                                    currentPart: partNumber,
                                    totalParts: numberOfParts,
                                    message: `Refazendo parte ${partNumber}/${numberOfParts} (tentativa ${retryCount + 1}/${MAX_RETRIES})...`,
                                    details: {
                                        partNumber,
                                        status: 'generating',
                                        percentage: 5,
                                        completedParts: partIndex
                                    }
                                });
                            }
                        } else {
                            console.log(`[Roteiro] Chamando API ${service} para parte ${partNumber}...`);
                            // Enviar progresso da parte atual
                            if (sessionId) {
                                const partProgressStart = Math.min(80, Math.round((partIndex / numberOfParts) * 80));
                                sendProgress(sessionId, {
                                    stage: 'generating',
                                    progress: partProgressStart,
                                    currentPart: partNumber,
                                    totalParts: numberOfParts,
                                    message: `Gerando parte ${partNumber}/${numberOfParts}...`,
                                    details: {
                                        partNumber,
                                        status: 'generating',
                                        percentage: 5,
                                        completedParts: partIndex
                                    }
                                });
                            }
                        }
                        
                        if (service === 'gemini') {
                            partResponse = await callGeminiAPI(partPrompt, decryptedKey, selectedModel);
                        } else if (service === 'claude') {
                            partResponse = await callClaudeAPI(partPrompt, decryptedKey, selectedModel);
                        } else {
                            partResponse = await callOpenAIAPI(partPrompt, decryptedKey, selectedModel);
                        }
                        console.log(`[Roteiro] API ${service} respondeu para parte ${partNumber}`);
                        partGenerationSuccess = true;
                    } catch (partError) {
                        retryCount++;
                        console.error(`[Roteiro] Erro ao gerar parte ${partNumber} (tentativa ${retryCount}/${MAX_RETRIES}):`, partError.message);
                        
                        if (retryCount < MAX_RETRIES) {
                            console.log(`[Roteiro] Aguardando 2 segundos antes de tentar novamente...`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        } else {
                            // Após todas as tentativas, gerar mensagem de erro específica
                            console.error(`[Roteiro] Falha definitiva na parte ${partNumber} após ${MAX_RETRIES} tentativas`);
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'error',
                                    progress: Math.min(80, Math.round((partIndex / numberOfParts) * 80)),
                                    currentPart: partNumber,
                                    totalParts: numberOfParts,
                                    message: `❌ Erro na parte ${partNumber}/${numberOfParts} após ${MAX_RETRIES} tentativas. Continuando...`,
                                    details: {
                                        partNumber,
                                        status: 'error',
                                        percentage: 0,
                                        completedParts: partIndex
                                    }
                                });
                            }
                            throw partError; // Re-throw para ser capturado pelo catch externo
                        }
                    }
                }
                
                // Se chegou aqui, a parte foi gerada com sucesso
                try {

                    // Limpar resposta da parte
                    let partContent = extractTextFromAIResponse(partResponse).trim();
                    partContent = partContent
                        .replace(/^```[\w]*\n?/gm, '')
                        .replace(/```$/gm, '')
                        .replace(/^\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                        .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                        .replace(/"content"\s*:\s*"([^"]+)"/gi, '$1')
                        .replace(/"script"\s*:\s*"([^"]+)"/gi, '$1')
                        .replace(/\{[\s\S]*\}/g, '')
                        .trim();
                    
                    // Remover marcações de roteiro (música, visual, narrador, etc.) - apenas texto para voice over
                    partContent = cleanScriptForVoiceOver(partContent);

                    const partWordCount = partContent.trim().split(/\s+/).filter(w => w.length > 0).length;
                    console.log(`[Roteiro] Parte ${partNumber}/${numberOfParts} gerada: ${partWordCount} palavras (meta: ${currentPartWords})`);

                    // Validar e expandir parte se necessário
                    if (partWordCount < currentPartWords - 50) {
                        console.warn(`[Roteiro] Parte ${partNumber} muito curta: ${partWordCount} palavras. Expandindo...`);
                        if (sessionId) {
                            sendProgress(sessionId, {
                                stage: 'generating',
                                progress: Math.min(82, Math.round((partIndex / numberOfParts) * 80) + 5),
                                currentPart: partNumber,
                                totalParts: numberOfParts,
                                message: `Expandindo parte ${partNumber}/${numberOfParts} para atingir a minutagem...`,
                                details: {
                                    partNumber,
                                    status: 'expanding',
                                    percentage: Math.min(90, Math.round((partWordCount / currentPartWords) * 100)),
                                    completedParts: partIndex
                                }
                            });
                        }
                        const partExpansionPrompt = `O roteiro abaixo é a parte ${partNumber} de ${numberOfParts} e tem apenas ${partWordCount} palavras, mas precisa ter EXATAMENTE ${currentPartWords} palavras.

ROTEIRO DA PARTE ${partNumber} (${partWordCount} palavras - MUITO CURTO):
${partContent}

INSTRUÇÕES:
1. Expanda esta parte para ter EXATAMENTE ${currentPartWords} palavras
2. Mantenha o mesmo estilo e tom
3. Adicione mais detalhes, exemplos, explicações
4. NÃO use JSON, objetos ou arrays - apenas texto corrido
5. Responda APENAS com o roteiro expandido`;

                        try {
                            let expansionResponse;
                            if (service === 'gemini') {
                                expansionResponse = await callGeminiAPI(partExpansionPrompt, decryptedKey, selectedModel);
                            } else if (service === 'claude') {
                                expansionResponse = await callClaudeAPI(partExpansionPrompt, decryptedKey, selectedModel);
                            } else {
                                expansionResponse = await callOpenAIAPI(partExpansionPrompt, decryptedKey, selectedModel);
                            }

                            let expandedPart = extractTextFromAIResponse(expansionResponse).trim();
                            expandedPart = cleanScriptForVoiceOver(expandedPart)
                                .replace(/^```[\w]*\n?/gm, '')
                                .replace(/```$/gm, '')
                                .replace(/^\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                                .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                                .replace(/\{[\s\S]*\}/g, '')
                                .trim();

                            const expandedWordCount = expandedPart.trim().split(/\s+/).filter(w => w.length > 0).length;
                            if (expandedWordCount >= currentPartWords - 50) {
                                partContent = expandedPart;
                                console.log(`[Roteiro] Parte ${partNumber} expandida: ${expandedWordCount} palavras`);
                            }
                        } catch (expansionErr) {
                            console.error(`[Roteiro] Erro ao expandir parte ${partNumber}:`, expansionErr.message);
                        }
                    }

                    scriptParts.push(partContent);
                    
                    if (sessionId) {
                        const completedParts = partNumber;
                        const completionProgress = Math.min(85, Math.round((completedParts / numberOfParts) * 80));
                        const finalPartWords = partContent.trim().split(/\s+/).filter(w => w.length > 0).length;
                        sendProgress(sessionId, {
                            stage: 'generating',
                            progress: completionProgress,
                            currentPart: partNumber,
                            totalParts: numberOfParts,
                            message: `Parte ${partNumber}/${numberOfParts} concluída (${finalPartWords} palavras).`,
                            details: {
                                partNumber,
                                status: 'completed',
                                percentage: 100,
                                completedParts,
                                words: finalPartWords
                            }
                        });
                    }
                } catch (partErr) {
                    console.error(`[Roteiro] ❌ Erro DEFINITIVO ao processar parte ${partNumber} após ${MAX_RETRIES} tentativas:`, partErr.message);
                    
                    // Adicionar mensagem de erro ao array de partes (mantendo a posição)
                    scriptParts.push(`[ERRO NA PARTE ${partNumber}/${numberOfParts}]\n\n❌ Não foi possível gerar esta parte do roteiro após ${MAX_RETRIES} tentativas.\nMotivo: ${partErr.message}\n\nPor favor, gere novamente ou edite manualmente.\n\n[FIM DO ERRO - PARTE ${partNumber}]`);
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'error',
                            progress: Math.min(85, Math.round((partNumber / numberOfParts) * 80)),
                            currentPart: partNumber,
                            totalParts: numberOfParts,
                            message: `❌ Erro definitivo na parte ${partNumber}/${numberOfParts}. Continuando...`,
                            details: {
                                partNumber,
                                status: 'error',
                                percentage: 0,
                                completedParts: partNumber - 1
                            }
                        });
                    }
                    
                    // NÃO INTERROMPE O LOOP - continua gerando as próximas partes
                    console.log(`[Roteiro] Continuando com a próxima parte...`);
                }
            }
            
            // Após todas as partes serem geradas (com sucesso ou erro), continuar o processamento
            console.log(`[Roteiro] Todas as ${numberOfParts} partes foram processadas. Montando roteiro final...`);
            
            // Unir todas as partes em um roteiro completo
            const fullScript = scriptParts.join('\n\n---\n\n');
            const totalWords = fullScript.trim().split(/\s+/).filter(w => w.length > 0).length;
            
            console.log(`[Roteiro] Roteiro final montado: ${totalWords} palavras (${scriptParts.length} partes)`);
            
            // Verificar se há partes com erro
            const hasErrors = scriptParts.some(part => part.includes('[ERRO NA PARTE'));
            if (hasErrors) {
                console.warn(`[Roteiro] ⚠️ Roteiro contém partes com erro. O usuário deverá revisar.`);
            }
            
            // Continuar com a otimização e validação (mesmo com erros em algumas partes)
            if (sessionId) {
                sendProgress(sessionId, {
                    stage: hasErrors ? 'partial_success' : 'optimizing',
                    progress: 85,
                    message: hasErrors ? '⚠️ Roteiro gerado com algumas partes com erro. Otimizando...' : 'Otimizando roteiro...',
                    totalParts: numberOfParts,
                    details: {
                        completedParts: numberOfParts,
                        hasErrors: hasErrors
                    }
                });
            }
            
            // Usar o fullScript já montado com as partes (incluindo erros, se houver)
            scriptContent = fullScript;
        } else {
            // Se não precisa dividir, gerar normalmente
            const scriptPrompt = `${agent.agent_prompt}

TÍTULO DO VÍDEO PARA O QUAL VOCÊ DEVE GERAR O ROTEIRO:
"${title}"

${topic ? `CONTEXTO ADICIONAL FORNECIDO PELO USUÁRIO:
"${topic}"

` : ''}INSTRUÇÕES PARA GERAÇÃO DO ROTEIRO:

O roteiro deve:
- Ter EXATAMENTE ${scriptDuration} minutos de duração (${scriptDuration * 60} segundos)
- Replicar a estrutura narrativa exata do roteiro viral original
- Manter os mesmos elementos virais (ganchos, ritmo, tom, técnicas de engajamento)
- Adaptar o conteúdo para o novo título fornecido
- Incluir timing específico de cada seção para totalizar ${scriptDuration} minutos
- Manter a fórmula de sucesso que tornou o roteiro original viral
- Distribuir o conteúdo proporcionalmente para preencher os ${scriptDuration} minutos

FORMATO DE RESPOSTA OBRIGATÓRIO:
- Responda APENAS com o roteiro em TEXTO SIMPLES (não use JSON, não use estruturas de dados)
- NÃO use formato JSON, não use objetos, não use arrays, não use chaves {}
- O roteiro deve ser texto corrido, dividido em parágrafos ou seções claras
- Cada seção pode ter indicação de tempo entre parênteses ou colchetes, mas o conteúdo deve ser texto narrativo direto
- Exemplo de formato correto:
  "[0:00-0:30] Texto do roteiro aqui... 
  
  [0:30-1:30] Continuação do roteiro...
  
  [1:30-3:00] Mais conteúdo..."
  
- NÃO use formato como: {"section": "...", "time": "...", "content": "..."}
- NÃO use listas numeradas ou com marcadores para estruturar o roteiro
- O roteiro deve ser texto narrativo fluido, como se fosse o texto que será narrado no vídeo

REGRAS CRÍTICAS DE DURAÇÃO - OBRIGATÓRIO:
- O roteiro DEVE ter EXATAMENTE ${scriptDuration} minutos de duração
- O roteiro DEVE ter EXATAMENTE ${scriptDuration * wordsPerMinute} palavras (${wordsPerMinute} palavras por minuto)
- NÃO aceite menos de ${scriptDuration * wordsPerMinute} palavras - o roteiro DEVE ter NO MÍNIMO ${scriptDuration * wordsPerMinute} palavras
- NÃO aceite mais de ${(scriptDuration * wordsPerMinute) + 100} palavras - o roteiro DEVE ter NO MÁXIMO ${(scriptDuration * wordsPerMinute) + 100} palavras
- Se o roteiro tiver menos de ${scriptDuration * wordsPerMinute} palavras, você DEVE expandir o conteúdo até atingir EXATAMENTE ${scriptDuration * wordsPerMinute} palavras
- Distribua o conteúdo proporcionalmente para preencher TODOS os ${scriptDuration} minutos
- Certifique-se de que o tempo total indicado nas seções some ${scriptDuration} minutos (${scriptDuration * 60} segundos)
- IMPORTANTE: Conte as palavras antes de finalizar. O roteiro DEVE ter entre ${scriptDuration * wordsPerMinute} e ${(scriptDuration * wordsPerMinute) + 100} palavras
- CRÍTICO: Se você não conseguir gerar ${scriptDuration * wordsPerMinute} palavras, continue expandindo o conteúdo até atingir essa quantidade

RESPOSTA FINAL - CRÍTICO:
- Responda APENAS com o roteiro em TEXTO SIMPLES e DIRETO
- NÃO use JSON, NÃO use objetos {}, NÃO use arrays [], NÃO use chaves ou colchetes para estruturar
- NÃO use formato: {"roteiro": "...", "duracao": "...", "estrutura": "..."}
- NÃO use formato: [{"section": "...", "time": "...", "content": "..."}]
- O roteiro deve ser texto corrido, como se você estivesse escrevendo o texto que será narrado
- Você pode usar [0:00-0:30] para indicar tempo, mas o resto deve ser texto narrativo puro
- IMPORTANTE: O roteiro será usado para VOICE OVER, então escreva de forma natural e fluida
- Use pontos finais e dois pontos para separar frases naturalmente
- O texto deve estar pronto para ser copiado e usado diretamente na narração do vídeo
- NÃO inclua NADA além do roteiro em si - nem explicações, nem metadados, nem JSON
- Meta de palavras: aproximadamente ${scriptDuration * wordsPerMinute} palavras para ${scriptDuration} minutos`;

            let apiCallFunction;
            if (service === 'gemini') apiCallFunction = callGeminiAPI;
            else if (service === 'claude') apiCallFunction = callClaudeAPI;
            else apiCallFunction = callOpenAIAPI;

            const originalResponse = await apiCallFunction(scriptPrompt, decryptedKey, selectedModel);
            
            // Extrair conteúdo da resposta (pode vir em diferentes formatos)
            scriptContent = extractTextFromAIResponse(originalResponse) || '';

        // Limpar o roteiro: remover explicações, metadados, markdown, JSON, etc.
        // Garantir que a saída seja apenas o roteiro limpo em texto simples
        scriptContent = scriptContent
            // Remover estruturas JSON completas (objetos e arrays)
            .replace(/\{[\s\S]*?"script"[\s\S]*?\}/g, '')
            .replace(/\{[\s\S]*?"section"[\s\S]*?\}/g, '')
            .replace(/\{[\s\S]*?"content"[\s\S]*?\}/g, '')
            .replace(/\{[\s\S]*?"time"[\s\S]*?\}/g, '')
            // Remover arrays JSON
            .replace(/\[[\s\S]*?\{[\s\S]*?\}[\s\S]*?\]/g, '')
            // Extrair apenas o conteúdo de texto de estruturas JSON (se ainda houver)
            .replace(/"content"\s*:\s*"([^"]+)"/gi, '$1')
            .replace(/"text"\s*:\s*"([^"]+)"/gi, '$1')
            .replace(/"script"\s*:\s*"([^"]+)"/gi, '$1')
            // Remover blocos de código markdown
            .replace(/```[\s\S]*?```/g, '')
            // Remover JSON completo entre chaves (mais agressivo)
            .replace(/\{[^{}]*"roteiro"[\s\S]*?\}/g, '')
            .replace(/\{[^{}]*"duracao"[\s\S]*?\}/g, '')
            .replace(/\{[^{}]*"estrutura"[\s\S]*?\}/g, '')
            .replace(/\{[\s\S]{0,5000}\}/g, '')
            // Remover cabeçalhos markdown excessivos
            .replace(/^#{1,6}\s+.+$/gm, '')
            // Remover linhas que começam com "Roteiro:", "Script:", etc (metadados)
            .replace(/^(Roteiro|Script|Conteúdo|Texto|Output|Resultado|Aqui está|Segue|Abaixo está|Este é o|O roteiro é|title|section|time):\s*/gmi, '')
            // Remover explicações comuns no início/fim
            .replace(/\s*(Espero que|Espero|Boa sorte|Bom trabalho|Sucesso|Bom vídeo)\.?$/gmi, '')
            // Remover aspas JSON restantes
            .replace(/^["']|["']$/gm, '')
            // Remover múltiplas quebras de linha (mais de 2)
            .replace(/\n{3,}/g, '\n\n')
            // Limpar espaços no início e fim
            .trim();
        
        // Se o conteúdo ainda estiver muito curto ou vazio após limpeza, tentar extrair texto de JSON
        if (scriptContent.length < 100) {
            try {
                // Tentar encontrar e parsear JSON na resposta original
                const rawText = typeof originalResponse === 'string'
                    ? originalResponse
                    : JSON.stringify(originalResponse || '');
                const jsonMatch = rawText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const jsonObj = JSON.parse(jsonMatch[0]);
                    
                    if (jsonObj.script && Array.isArray(jsonObj.script)) {
                        // Extrair conteúdo de array de objetos (formato do exemplo do usuário)
                        scriptContent = jsonObj.script.map(item => {
                            if (item.content) {
                                const timeStr = item.time ? `[${item.time}] ` : '';
                                return timeStr + item.content;
                            }
                            if (typeof item === 'string') return item;
                            return '';
                        }).filter(Boolean).join('\n\n');
                    } else if (jsonObj.content) {
                        scriptContent = jsonObj.content;
                    } else if (jsonObj.script && typeof jsonObj.script === 'string') {
                        scriptContent = jsonObj.script;
                    } else if (jsonObj.text) {
                        scriptContent = jsonObj.text;
                    }
                }
            } catch (e) {
                // Se falhar ao parsear JSON, tentar extrair texto diretamente
                console.warn('[Roteiro] Erro ao parsear JSON, tentando extração direta:', e.message);
                
                // Tentar extrair conteúdo de strings JSON sem parsear completamente
                const rawText = typeof originalResponse === 'string'
                    ? originalResponse
                    : JSON.stringify(originalResponse || '');
                const contentMatches = rawText.match(/"content"\s*:\s*"([^"]+)"/gi);
                if (contentMatches && contentMatches.length > 0) {
                    scriptContent = contentMatches.map(match => {
                        const extracted = match.match(/"content"\s*:\s*"([^"]+)"/i);
                        return extracted ? extracted[1] : '';
                    }).filter(Boolean).join('\n\n');
                }
            }
        }
        
            // Garantir que o conteúdo final não esteja vazio
            if (!scriptContent || scriptContent.trim().length < 50) {
                console.warn('[Roteiro] Conteúdo muito curto após limpeza, usando resposta original');
                scriptContent = extractTextFromAIResponse(originalResponse) || '';
            }
        }

        // Validar quantidade de palavras e expandir se necessário
        const expectedWords = scriptDuration * wordsPerMinute;
        const minWords = expectedWords - 50; // Tolerância de -50 palavras
        const maxWords = expectedWords + 100; // Tolerância de +100 palavras
        
        let wordCount = scriptContent.trim().split(/\s+/).filter(w => w.length > 0).length;
        console.log(`[Roteiro] Validação inicial: ${wordCount} palavras encontradas, esperado: ${expectedWords} (tolerância: ${minWords}-${maxWords})`);

        // Tentar expandir até atingir a quantidade mínima (máximo 3 tentativas)
        let expansionAttempts = 0;
        const maxExpansionAttempts = 3;
        
        while (wordCount < minWords && expansionAttempts < maxExpansionAttempts) {
            expansionAttempts++;
            const wordsNeeded = expectedWords - wordCount;
            const expansionRatio = expectedWords / wordCount; // Quantas vezes precisa expandir
            
            console.warn(`[Roteiro] Tentativa ${expansionAttempts}/${maxExpansionAttempts}: Roteiro muito curto: ${wordCount} palavras (mínimo: ${minWords}). Expandindo...`);
            
            // Criar prompt de expansão mais agressivo
            const expansionPrompt = `O roteiro abaixo tem apenas ${wordCount} palavras, mas precisa ter EXATAMENTE ${expectedWords} palavras para ${scriptDuration} minutos de narração.

IMPORTANTE: 
- NÃO inclua marcações como "(Música...)", "(Visual:...)", "NARRADOR:", etc.
- O roteiro deve ser APENAS texto puro para voice over, sem direções de cena, música ou visualizações
- Escreva como se estivesse narrando diretamente, sem prefixos ou marcações técnicas

ROTEIRO ATUAL (${wordCount} palavras - MUITO CURTO):
${scriptContent}

INSTRUÇÕES CRÍTICAS:
1. Você DEVE expandir este roteiro para ter EXATAMENTE ${expectedWords} palavras (atualmente tem apenas ${wordCount})
2. Você precisa adicionar aproximadamente ${wordsNeeded} palavras a mais
3. Mantenha o mesmo estilo, tom e estrutura narrativa
4. Expanda CADA seção do roteiro proporcionalmente
5. Adicione mais detalhes, exemplos concretos, explicações profundas, desenvolvimento de ideias, contexto histórico, curiosidades, análises mais detalhadas
6. NÃO altere o início ou o final, mas expanda significativamente o conteúdo do meio
7. O roteiro deve continuar sendo texto corrido, SEM JSON, sem objetos, sem arrays
8. Cada parágrafo deve ser expandido com mais informações relevantes
9. Adicione transições mais elaboradas entre as seções
10. Desenvolva mais profundamente cada ideia apresentada
11. CRÍTICO: O roteiro final DEVE ter entre ${expectedWords} e ${expectedWords + 50} palavras
12. Conte mentalmente as palavras enquanto escreve. Se o roteiro não tiver pelo menos ${expectedWords} palavras, continue expandindo até atingir essa quantidade.
13. CRÍTICO: NÃO inclua marcações como "(Música...)", "(Visual:...)", "NARRADOR:", etc.
14. O roteiro deve ser APENAS texto puro para voice over, sem direções de cena, música ou visualizações
15. Escreva como se estivesse narrando diretamente, sem prefixos ou marcações técnicas

RESPOSTA FINAL - CRÍTICO:
Escreva APENAS o texto do roteiro expandido em TEXTO SIMPLES, sem explicações adicionais, sem metadados, NÃO use JSON.
Responda com o roteiro expandido imediatamente, sem envolver em objetos ou formatação especial.`;

            try {
                let expansionResponse;
                let usedService = service;
                
                // Tentar com a API principal
                try {
                if (service === 'gemini') {
                    expansionResponse = await callGeminiAPI(expansionPrompt, decryptedKey, selectedModel);
                } else if (service === 'claude') {
                    expansionResponse = await callClaudeAPI(expansionPrompt, decryptedKey, selectedModel);
                } else {
                    expansionResponse = await callOpenAIAPI(expansionPrompt, decryptedKey, selectedModel);
                    }
                } catch (apiErr) {
                    // Se falhou (503, timeout, etc), tentar API alternativa
                    const errorMsg = apiErr.message || '';
                    if (errorMsg.includes('overloaded') || errorMsg.includes('503') || errorMsg.includes('timeout') || errorMsg.includes('UNAVAILABLE')) {
                        console.warn(`[Roteiro] ⚠️ ${service} falhou (${errorMsg.substring(0, 100)}). Tentando API alternativa...`);
                        
                        // Tentar fallback: Gemini → Claude → OpenAI → (loop)
                        const fallbackOrder = service === 'gemini' 
                            ? ['claude', 'openai'] 
                            : service === 'claude'
                            ? ['openai', 'gemini']
                            : ['claude', 'gemini'];
                        
                        let fallbackSuccess = false;
                        for (const fallbackService of fallbackOrder) {
                            try {
                                const fallbackKey = await db.get(
                                    'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                                    [userId, fallbackService]
                                );
                                
                                if (fallbackKey) {
                                    const fallbackDecryptedKey = decrypt(fallbackKey.api_key);
                                    const fallbackModel = fallbackService === 'gemini' 
                                        ? 'gemini-2.5-pro' 
                                        : fallbackService === 'claude'
                                        ? 'claude-3-7-sonnet-20250219'
                                        : 'gpt-4o';
                                    
                                    console.log(`[Roteiro] 🔄 Tentando ${fallbackService} como fallback...`);
                                    
                                    if (fallbackService === 'gemini') {
                                        expansionResponse = await callGeminiAPI(expansionPrompt, fallbackDecryptedKey, fallbackModel);
                                    } else if (fallbackService === 'claude') {
                                        expansionResponse = await callClaudeAPI(expansionPrompt, fallbackDecryptedKey, fallbackModel);
                                    } else {
                                        expansionResponse = await callOpenAIAPI(expansionPrompt, fallbackDecryptedKey, fallbackModel);
                                    }
                                    
                                    usedService = fallbackService;
                                    fallbackSuccess = true;
                                    console.log(`[Roteiro] ✅ Fallback para ${fallbackService} bem-sucedido!`);
                                    break;
                                }
                            } catch (fallbackErr) {
                                console.warn(`[Roteiro] ⚠️ Fallback ${fallbackService} também falhou: ${fallbackErr.message.substring(0, 100)}`);
                            }
                        }
                        
                        if (!fallbackSuccess) {
                            throw apiErr; // Se todos falharam, lançar erro original
                        }
                    } else {
                        throw apiErr; // Se não é erro de sobrecarga, lançar erro
                    }
                }

                // Limpar resposta de expansão
                let expandedContent = extractTextFromAIResponse(expansionResponse).trim();
                expandedContent = cleanScriptForVoiceOver(expandedContent);
                expandedContent = expandedContent
                    .replace(/^```[\w]*\n?/gm, '')
                    .replace(/```$/gm, '')
                    .replace(/^\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                    .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/"content"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/"script"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/\{[\s\S]*\}/g, '')
                    .replace(/\[[\s\S]*?\]/g, '') // Remover arrays JSON
                    .trim();

                const expandedWordCount = expandedContent.trim().split(/\s+/).filter(w => w.length > 0).length;
                console.log(`[Roteiro] Após tentativa ${expansionAttempts}: ${expandedWordCount} palavras (meta: ${expectedWords})`);

                if (expandedWordCount >= minWords) {
                    scriptContent = expandedContent;
                    wordCount = expandedWordCount;
                    console.log(`[Roteiro] ✅ Expansão bem-sucedida! Roteiro agora tem ${wordCount} palavras.`);
                    break; // Sair do loop se atingiu o mínimo
                } else if (expandedWordCount > wordCount) {
                    // Mesmo que não tenha atingido o mínimo, se expandiu, usar o expandido
                    scriptContent = expandedContent;
                    wordCount = expandedWordCount;
                    console.log(`[Roteiro] Roteiro expandido de ${wordCount} para ${expandedWordCount} palavras, mas ainda abaixo do mínimo. Tentando novamente...`);
                } else {
                    console.warn(`[Roteiro] Expansão não aumentou o número de palavras. Tentando abordagem diferente...`);
                }
            } catch (expansionErr) {
                console.error(`[Roteiro] Erro na tentativa ${expansionAttempts} de expansão:`, expansionErr.message);
                // Continuar para próxima tentativa ou usar o que temos
            }
        }

        // Verificação final - se ainda estiver muito curto, fazer uma última tentativa com prompt diferente
        if (wordCount < minWords) {
            console.warn(`[Roteiro] Roteiro ainda muito curto após ${expansionAttempts} tentativas: ${wordCount} palavras. Fazendo última tentativa...`);
            
            // Última tentativa: pedir para duplicar e expandir o conteúdo
            const finalExpansionPrompt = `O roteiro abaixo precisa ser DUPLICADO e EXPANDIDO para ter EXATAMENTE ${expectedWords} palavras.

IMPORTANTE: 
- NÃO inclua marcações como "(Música...)", "(Visual:...)", "NARRADOR:", etc.
- O roteiro deve ser APENAS texto puro para voice over, sem direções de cena, música ou visualizações
- Escreva como se estivesse narrando diretamente, sem prefixos ou marcações técnicas

ROTEIRO ATUAL (${wordCount} palavras):
${scriptContent}

INSTRUÇÕES FINAIS:
1. Você DEVE criar um roteiro com EXATAMENTE ${expectedWords} palavras
2. Mantenha a estrutura e o estilo, mas EXPANDA CADA IDEIA significativamente
3. Adicione exemplos, detalhes, explicações, contexto, curiosidades
4. Desenvolva cada parágrafo com muito mais profundidade
5. SEM JSON, objetos ou arrays - apenas texto corrido
6. CRÍTICO: NÃO inclua marcações como "(Música...)", "(Visual:...)", "NARRADOR:", etc.
7. O roteiro deve ser APENAS texto puro para voice over, sem direções de cena, música ou visualizações
8. Escreva como se estivesse narrando diretamente, sem prefixos ou marcações técnicas
9. Responda APENAS com o roteiro expandido

RESPOSTA FINAL - CRÍTICO:
Escreva APENAS o texto do roteiro expandido em TEXTO SIMPLES, NÃO use JSON.`;

            try {
                let finalResponse;
                if (service === 'gemini') {
                    finalResponse = await callGeminiAPI(finalExpansionPrompt, decryptedKey, selectedModel);
                } else if (service === 'claude') {
                    finalResponse = await callClaudeAPI(finalExpansionPrompt, decryptedKey, selectedModel);
                } else {
                    finalResponse = await callOpenAIAPI(finalExpansionPrompt, decryptedKey, selectedModel);
                }

                let finalContent = extractTextFromAIResponse(finalResponse).trim()
                    .replace(/^```[\w]*\n?/gm, '')
                    .replace(/```$/gm, '')
                    .replace(/^\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                    .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/\{[\s\S]*\}/g, '')
                    .trim();

                const finalWordCount = finalContent.trim().split(/\s+/).filter(w => w.length > 0).length;
                if (finalWordCount >= minWords) {
                    scriptContent = finalContent;
                    wordCount = finalWordCount;
                    console.log(`[Roteiro] ✅ Última tentativa bem-sucedida! Roteiro agora tem ${wordCount} palavras.`);
                }
            } catch (finalErr) {
                console.error('[Roteiro] Erro na última tentativa de expansão:', finalErr.message);
            }
        }

        // Verificação final - se ainda estiver muito curto, usar o que temos mas avisar
        const finalWordCount = scriptContent.trim().split(/\s+/).filter(w => w.length > 0).length;
        if (finalWordCount < minWords) {
            console.warn(`[Roteiro] ⚠️ Roteiro final ainda abaixo do mínimo após todas as tentativas: ${finalWordCount} palavras (mínimo: ${minWords})`);
            // Em vez de retornar erro, vamos usar o roteiro mesmo que curto, mas adicionar uma nota
            // O sistema vai continuar funcionando, mas o usuário será avisado
            console.log(`[Roteiro] Usando roteiro com ${finalWordCount} palavras (abaixo do ideal de ${expectedWords}, mas funcional)`);
        } else {
            console.log(`[Roteiro] ✅ Roteiro validado com sucesso: ${finalWordCount} palavras (meta: ${expectedWords})`);
        }

        // === OTIMIZAÇÃO DO ROTEIRO ===
        console.log('[Otimizador] 🔍 Analisando roteiro gerado...');
        
        // Progresso: 90% - Iniciando otimização
        if (sessionId) {
            sendProgress(sessionId, {
                stage: 'optimizing',
                progress: 90,
                message: 'Analisando qualidade do roteiro...'
            });
        }
        
        const optimizer = new ScriptOptimizer(agent.niche || 'geral');
        const analysis = optimizer.analyzeScript(scriptContent);
        const optimizationReport = optimizer.generateReport(analysis);
        
        console.log('[Otimizador] 📊 Análise concluída:');
        console.log(`  - Score Geral: ${analysis.overallScore}/10`);
        console.log(`  - Retenção: ${analysis.retentionScore}/10`);
        console.log(`  - Autenticidade: ${analysis.authenticityScore}/10`);
        console.log(`  - Alinhamento: ${analysis.nicheAlignment}/10`);
        console.log(`  - Problemas detectados: ${analysis.problems.length}`);
        console.log(`  - Indicadores de IA: ${analysis.aiIndicators.length}`);
        console.log(`  - Clichês: ${analysis.cliches.length}`);
        
        // === PÓS-PROCESSAMENTO AUTOMÁTICO ===
        // Se score < 8 ou tem muitos problemas, aplicar otimizações automáticas
        let finalScriptContent = scriptContent;
        let needsOptimization = false;
        let optimizationReason = '';
        
        // 🚨 CRÍTICO: SEMPRE otimizar se há inconsistências de nomes (DESASTRE TOTAL)
        if (analysis.nameInconsistencies && analysis.nameInconsistencies.length > 0) {
            needsOptimization = true;
            optimizationReason = `🚨 DESASTRE TOTAL: ${analysis.nameInconsistencies.length} inconsistências de nomes detectadas`;
            console.log(`[Otimizador] 🚨 CRÍTICO: ${analysis.nameInconsistencies.length} inconsistências de nomes! FORÇANDO otimização...`);
        } 
        // Verificar se precisa otimizar por score baixo
        else if (analysis.overallScore < 8) {
            needsOptimization = true;
            optimizationReason = `Score ${analysis.overallScore}/10 está abaixo de 8`;
            console.log(`[Otimizador] 🔧 ${optimizationReason}. Aplicando correções...`);
        } 
        // Verificar se tem muitos clichês
        else if (analysis.cliches.length > 3) {
            needsOptimization = true;
            optimizationReason = `${analysis.cliches.length} clichês detectados`;
            console.log(`[Otimizador] 🔧 ${optimizationReason}. Aplicando correções...`);
        } 
        // Verificar se tem muitos indicadores de IA
        else if (analysis.aiIndicators.length > 2) {
            needsOptimization = true;
            optimizationReason = `${analysis.aiIndicators.length} indicadores de IA detectados`;
            console.log(`[Otimizador] 🔧 ${optimizationReason}. Aplicando correções...`);
        }
        
        if (needsOptimization) {
            // Progresso: 93% - Otimizando
            if (sessionId) {
                sendProgress(sessionId, {
                    stage: 'optimizing',
                    progress: 93,
                    message: 'Removendo repetições e clichês...'
                });
            }
            
            try {
                const originalWordCount = scriptContent.split(/\s+/).filter(w => w.length > 0).length;
                
                // FASE 1: Otimizações Básicas
                if (sessionId) {
                    sendProgress(sessionId, {
                        stage: 'optimizing',
                        progress: 93,
                        message: '🔧 Normalizando nomes de personagens...',
                        details: {
                            phase: 'basic',
                            step: 'normalize_names'
                        }
                    });
                }
                
                finalScriptContent = optimizer.optimizeScript(scriptContent);
                
                if (sessionId) {
                    sendProgress(sessionId, {
                        stage: 'optimizing',
                        progress: 94,
                        message: '🧹 Removendo repetições e clichês...',
                        details: {
                            phase: 'basic',
                            step: 'remove_repetitions'
                        }
                    });
                }
                
                finalScriptContent = removeRepetitions(finalScriptContent);
                finalScriptContent = optimizer.humanizeText(finalScriptContent);
                
                // Garantir que não diminuiu muito o tamanho
                const currentWordCount = finalScriptContent.split(/\s+/).filter(w => w.length > 0).length;
                if (currentWordCount < originalWordCount * 0.85) {
                    console.warn(`[Otimizador] ⚠️ Roteiro reduziu muito: ${originalWordCount} → ${currentWordCount} palavras. Revertendo...`);
                    finalScriptContent = scriptContent; // Reverter para o original
                }
                
                // Re-analisar após otimizações básicas
                let finalAnalysis = optimizer.analyzeScript(finalScriptContent);
                console.log(`[Otimizador] ✅ Otimização básica concluída! Score: ${analysis.overallScore}/10 → ${finalAnalysis.overallScore}/10`);
                
                if (sessionId) {
                    sendProgress(sessionId, {
                        stage: 'optimizing',
                        progress: 94,
                        message: `✅ Fase 1 concluída - Score: ${finalAnalysis.overallScore}/10`,
                        details: {
                            phase: 'basic',
                            step: 'complete',
                            score: finalAnalysis.overallScore,
                            wordCount: currentWordCount
                        }
                    });
                }
                
                // FASE 2: 🎯 REPLICADOR DE FÓRMULA VIRAL (usa fórmula armazenada ou transcrição original)
                const hasOriginalScript = agent.full_transcript && agent.full_transcript.trim().length > 500;
                let storedViralFormula = null;
                if (agent.viral_formula_json) {
                    try {
                        storedViralFormula = JSON.parse(agent.viral_formula_json);
                    } catch (formulaParseErr) {
                        console.warn('[Otimizador] ⚠️ Não foi possível parsear viral_formula_json do agente:', formulaParseErr.message);
                    }
                }
                const canReplicateStructure = !!storedViralFormula || hasOriginalScript;
                
                if (canReplicateStructure) {
                    console.log('[Otimizador] 🎯 Aplicando REPLICADOR DE FÓRMULA VIRAL (obrigatório para manter a estrutura original).');
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'viral_replication',
                            progress: 95,
                            message: storedViralFormula
                                ? '🎯 Aplicando fórmula viral armazenada...'
                                : '🎯 Analisando fórmula viral do roteiro original...',
                            details: {
                                phase: 'viral',
                                step: storedViralFormula ? 'loading_formula' : 'analyzing_formula'
                            }
                        });
                    }
                    
                    try {
                        const claudeKeyData = await db.get(
                            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                            [userId, 'claude']
                        );
                        
                        if (claudeKeyData && claudeKeyData.api_key) {
                            const claudeApiKey = decrypt(claudeKeyData.api_key);
                            const viralReplicator = new ViralFormulaReplicator();
                            
                            let viralFormula = storedViralFormula;
                            
                            // Passo 1: Analisar fórmula viral do roteiro original caso não exista uma armazenada
                            if (!viralFormula && hasOriginalScript) {
                                viralFormula = await viralReplicator.analyzeViralFormula(
                                    agent.full_transcript,
                                    claudeApiKey,
                                    agent.source_video_title || title,
                                    agent.niche
                                );
                                
                                // Armazenar para reutilização futura
                                if (viralFormula) {
                                    try {
                                        await db.run(
                                            `UPDATE script_agents SET viral_formula_json = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                            [JSON.stringify(viralFormula), agent.id]
                                        );
                                        console.log('[Otimizador] 💾 Fórmula viral salva no agente para reutilização.');
                                    } catch (saveErr) {
                                        console.warn('[Otimizador] ⚠️ Não foi possível salvar a fórmula viral no agente:', saveErr.message);
                                    }
                                }
                            }

                            if (!viralFormula) {
                                console.warn('[Otimizador] ⚠️ Fórmula viral não disponível. Pulando replicação.');
                                if (sessionId) {
                                    sendProgress(sessionId, {
                                        stage: 'viral_replication',
                                        progress: 96,
                                        message: '⚠️ Fórmula viral indisponível para replicação',
                                        details: {
                                            phase: 'viral',
                                            step: 'skipped',
                                            reason: 'formula_missing'
                                        }
                                    });
                                }
                                throw new Error('Fórmula viral indisponível');
                            }
                            
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'viral_replication',
                                    progress: 96,
                                    message: storedViralFormula ? '🚀 Aplicando fórmula viral armazenada...' : '🚀 Replicando fórmula viral no novo roteiro...',
                                    details: {
                                        phase: 'viral',
                                        step: storedViralFormula ? 'applying_formula' : 'replicating_formula',
                                        formula: viralFormula
                                    }
                                });
                            }
                            
                            // Passo 2: Replicar fórmula no novo roteiro
                            const replicationResult = await viralReplicator.replicateFormula(
                                viralFormula,
                                title,
                                agent.full_transcript || '[Fórmula carregada sem transcrição completa]',
                                finalScriptContent,
                                claudeApiKey,
                                agent.niche,
                                scriptDuration
                            );
                            
                            if (replicationResult.success) {
                                const newWordCount = replicationResult.replicatedScript.split(/\s+/).filter(w => w.length > 0).length;
                                
                                // Validar que não diminuiu muito
                                if (newWordCount < originalWordCount * 0.85) {
                                    console.warn(`[Otimizador] ⚠️ Replicação diminuiu muito: ${originalWordCount} → ${newWordCount}. Mantendo versão anterior.`);
                                } else {
                                    finalScriptContent = replicationResult.replicatedScript;
                                    console.log('[Otimizador] 🎉 Fórmula viral replicada com sucesso!');
                                    
                                    if (sessionId) {
                                        sendProgress(sessionId, {
                                            stage: 'viral_replication',
                                            progress: 97,
                                            message: '✅ Fórmula viral replicada! Roteiro 10/10',
                                            details: {
                                                phase: 'viral',
                                                step: 'replicated',
                                                newWordCount: newWordCount,
                                                formula: viralFormula
                                            }
                                        });
                                    }
                                    
                                    // Re-analisar após replicação
                                    finalAnalysis = optimizer.analyzeScript(finalScriptContent);
                                    console.log(`[Otimizador] 🚀 Score FINAL após replicação viral: ${finalAnalysis.overallScore}/10`);
                                }
                            }
                        } else {
                            console.warn('[Otimizador] ⚠️ API Key do Claude não encontrada para replicação viral.');
                        }
                    } catch (viralErr) {
                        console.error('[Otimizador] ⚠️ Erro na replicação viral:', viralErr.message);
                        console.log('[Otimizador] Continuando sem replicação viral.');
                    }
                }
                
                // FASE 3: 🤖 VALIDAÇÃO INTELIGENTE COM CLAUDE AI (se score ainda baixo e não tem roteiro original)
                const needsAICorrection = (
                    finalAnalysis.overallScore < 7 ||
                    (finalAnalysis.nameInconsistencies && finalAnalysis.nameInconsistencies.length > 0) ||
                    finalAnalysis.aiIndicators.length > 2 ||
                    finalAnalysis.cliches.length > 5
                );
                
                if (needsAICorrection) {
                    console.log(`[Otimizador] 🤖 Score ${finalAnalysis.overallScore}/10 ainda baixo. Ativando VALIDADOR INTELIGENTE (Claude AI)...`);
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'ai_correction',
                            progress: 95,
                            message: '🤖 Claude AI analisando problemas...',
                            details: {
                                phase: 'ai',
                                step: 'analyzing',
                                currentScore: finalAnalysis.overallScore,
                                problems: finalAnalysis.problems.length,
                                nameInconsistencies: finalAnalysis.nameInconsistencies?.length || 0
                            }
                        });
                    }
                    
                    try {
                        // Buscar API key do Claude
                        const claudeKeyData = await db.get(
                            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                            [userId, 'claude']
                        );
                        
                        if (claudeKeyData && claudeKeyData.api_key) {
                            const claudeApiKey = decrypt(claudeKeyData.api_key);
                            const aiValidator = new AIScriptValidator();
                            
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'ai_correction',
                                    progress: 96,
                                    message: '✍️ Claude AI reescrevendo roteiro...',
                                    details: {
                                        phase: 'ai',
                                        step: 'rewriting'
                                    }
                                });
                            }
                            
                            const validationResult = await aiValidator.validateAndFixScript(
                                finalScriptContent,
                                finalAnalysis,
                                claudeApiKey,
                                agent.niche,
                                title
                            );
                            
                            if (validationResult.success) {
                                const newWordCount = validationResult.correctedScript.split(/\s+/).filter(w => w.length > 0).length;
                                
                                // Validar que não diminuiu o tamanho
                                if (newWordCount < originalWordCount * 0.85) {
                                    console.warn(`[Otimizador] ⚠️ Claude reduziu muito o roteiro: ${originalWordCount} → ${newWordCount}. Mantendo versão anterior.`);
                                    if (sessionId) {
                                        sendProgress(sessionId, {
                                            stage: 'ai_correction',
                                            progress: 97,
                                            message: '⚠️ Roteiro corrigido muito curto, mantendo versão anterior',
                                            details: {
                                                phase: 'ai',
                                                step: 'rejected',
                                                reason: 'too_short'
                                            }
                                        });
                                    }
                                } else {
                                    finalScriptContent = validationResult.correctedScript;
                                    console.log('[Otimizador] 🎉 Claude AI corrigiu o roteiro!');
                                    console.log(`[Otimizador] 📊 Melhorias: ${validationResult.improvements.join(', ')}`);
                                    
                                    if (sessionId) {
                                        sendProgress(sessionId, {
                                            stage: 'ai_correction',
                                            progress: 97,
                                            message: '✅ Claude AI finalizou correção!',
                                            details: {
                                                phase: 'ai',
                                                step: 'corrected',
                                                improvements: validationResult.improvements,
                                                newWordCount: newWordCount
                                            }
                                        });
                                    }
                                    
                                    // Re-analisar após correção da IA
                                    finalAnalysis = optimizer.analyzeScript(finalScriptContent);
                                    console.log(`[Otimizador] 🚀 Score FINAL após Claude: ${finalAnalysis.overallScore}/10`);
                                }
                            }
                        } else {
                            console.warn('[Otimizador] ⚠️ API Key do Claude não encontrada. Pulando validação inteligente.');
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'ai_correction',
                                    progress: 95,
                                    message: '⚠️ API Key do Claude não configurada',
                                    details: {
                                        phase: 'ai',
                                        step: 'skipped',
                                        reason: 'no_api_key'
                                    }
                                });
                            }
                        }
                    } catch (aiErr) {
                        console.error('[Otimizador] ⚠️ Erro na validação com Claude:', aiErr.message);
                        console.log('[Otimizador] Continuando com otimização básica.');
                        if (sessionId) {
                            sendProgress(sessionId, {
                                stage: 'ai_correction',
                                progress: 95,
                                message: `⚠️ Erro no Claude: ${aiErr.message}`,
                                details: {
                                    phase: 'ai',
                                    step: 'error',
                                    error: aiErr.message
                                }
                            });
                        }
                    }
                }
                
                // Atualizar análise final
                analysis.overallScore = finalAnalysis.overallScore;
                analysis.retentionScore = finalAnalysis.retentionScore;
                analysis.authenticityScore = finalAnalysis.authenticityScore;
                analysis.nicheAlignment = finalAnalysis.nicheAlignment;
                analysis.problems = finalAnalysis.problems;
                analysis.cliches = finalAnalysis.cliches;
                analysis.aiIndicators = finalAnalysis.aiIndicators;
                analysis.nameInconsistencies = finalAnalysis.nameInconsistencies || [];
                
                // 🚨 VALIDAÇÃO CRÍTICA: NOTA MÍNIMA 8.5/10
                const MIN_SCORE_REQUIRED = 9;
                if (finalAnalysis.overallScore < MIN_SCORE_REQUIRED) {
                    const errorMsg = `Roteiro não atingiu a nota mínima de ${MIN_SCORE_REQUIRED}/10. Score atual: ${finalAnalysis.overallScore}/10`;
                    console.error(`[Otimizador] ❌ ${errorMsg}`);
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'failed',
                            progress: 98,
                            message: `❌ Score ${finalAnalysis.overallScore}/10 abaixo do mínimo (${MIN_SCORE_REQUIRED})`,
                            details: {
                                phase: 'validation',
                                step: 'failed',
                                score: finalAnalysis.overallScore,
                                minRequired: MIN_SCORE_REQUIRED,
                                problems: finalAnalysis.problems,
                                suggestions: finalAnalysis.suggestions
                            }
                        });
                    }
                    
                    throw new Error(`${errorMsg}\n\nProblemas encontrados:\n${finalAnalysis.problems.join('\n')}\n\nSugestões:\n${finalAnalysis.suggestions.join('\n')}\n\nPor favor, tente:\n1. Usar outro modelo de IA (Claude recomendado)\n2. Fornecer um título mais específico\n3. Revisar o agente de roteiro\n4. Gerar novamente com instruções mais detalhadas`);
                }
                
                // Validar que não há inconsistências críticas
                if (finalAnalysis.nameInconsistencies && finalAnalysis.nameInconsistencies.length > 0) {
                    const errorMsg = `Roteiro ainda contém ${finalAnalysis.nameInconsistencies.length} inconsistências de nomes após otimização`;
                    console.error(`[Otimizador] ❌ ${errorMsg}`);
                    console.error(`Inconsistências: ${finalAnalysis.nameInconsistencies.join(', ')}`);
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'failed',
                            progress: 98,
                            message: '❌ Inconsistências de nomes não corrigidas',
                            details: {
                                phase: 'validation',
                                step: 'failed',
                                nameInconsistencies: finalAnalysis.nameInconsistencies
                            }
                        });
                    }
                    
                    throw new Error(`${errorMsg}:\n${finalAnalysis.nameInconsistencies.join('\n')}\n\nO roteiro não pode ser finalizado com nomes de personagens inconsistentes. Tente gerar novamente.`);
                }
                
                console.log(`[Otimizador] ✅ Validação final aprovada! Score: ${finalAnalysis.overallScore}/10`);
                
                if (sessionId) {
                    sendProgress(sessionId, {
                        stage: 'validating',
                        progress: 98,
                        message: `✅ Validação aprovada! Score: ${finalAnalysis.overallScore}/10`,
                        details: {
                            phase: 'validation',
                            step: 'passed',
                            score: finalAnalysis.overallScore,
                            wordCount: finalScriptContent.split(/\s+/).filter(w => w.length > 0).length
                        }
                    });
                }
                
            } catch (optErr) {
                console.error('[Otimizador] Erro na otimização:', optErr.message);
                console.log('[Otimizador] Usando roteiro original sem otimizações');
                finalScriptContent = scriptContent;
            }
        } else {
            console.log(`[Otimizador] ✅ Roteiro já está em alta qualidade (score ${analysis.overallScore}/10)`);
        }
        
        scriptContent = finalScriptContent;
        
        // Aplicar limpeza final para remover qualquer marcação restante
        scriptContent = cleanScriptForVoiceOver(scriptContent);

        // Salvar o roteiro gerado com análise de otimização
        const scriptResult = await db.run(
            `INSERT INTO generated_scripts (user_id, script_agent_id, title, script_content, model_used, niche, subniche, optimization_score, optimization_report, retention_score, authenticity_score)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, agentId, title, scriptContent, selectedModel, agent.niche, agent.subniche, analysis.overallScore, optimizationReport, analysis.retentionScore, analysis.authenticityScore]
        );

        // Atualizar contador de uso do agente
        await db.run(
            `UPDATE script_agents SET usage_count = usage_count + 1, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
            [agentId]
        );

        // Garantir que scriptContent não esteja vazio
        if (!scriptContent || scriptContent.trim().length === 0) {
            console.error('[Roteiro] Erro: Roteiro gerado está vazio');
            return res.status(500).json({ 
                msg: 'Erro ao gerar roteiro: O conteúdo retornado está vazio. Tente novamente ou use outro modelo de IA.' 
            });
        }

        // Progresso: 100% - Concluído
        if (sessionId) {
            sendProgress(sessionId, {
                stage: 'complete',
                progress: 100,
                message: 'Roteiro gerado com sucesso!',
                viralScore: analysis.overallScore,
                totalParts: numberOfParts,
                details: {
                    score: analysis.overallScore,
                    scriptId: scriptResult.lastID
                }
            });
        }

        res.status(200).json({
            msg: 'Roteiro gerado com sucesso!',
            script: scriptContent,
            scriptId: scriptResult.lastID,
            title: title,
            model: selectedModel,
            duration: scriptDuration,
            language: scriptLanguage,
            wordCount: scriptContent.trim().split(/\s+/).filter(w => w.length > 0).length,
            optimization: {
                overallScore: analysis.overallScore,
                retentionScore: analysis.retentionScore,
                authenticityScore: analysis.authenticityScore,
                nicheAlignment: analysis.nicheAlignment,
                problems: analysis.problems,
                suggestions: analysis.suggestions,
                aiIndicators: analysis.aiIndicators,
                cliches: analysis.cliches,
                nameInconsistencies: analysis.nameInconsistencies || [],
                wasOptimized: needsOptimization,
                optimizationReason: needsOptimization ? optimizationReason : null
            }
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId/generate]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar roteiro.' });
    }
});

// === ROTA LAOZHANG PARA GERAÇÃO DE ROTEIROS ===
app.post('/api/script-agents/:agentId/generate/laozhang', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { title, topic, duration, language, cta, selectedModel, additionalInstructions, sessionId, parts } = req.body;
    const userId = req.user.id;

    console.log(`[Script Laozhang] Requisição recebida - agentId: ${agentId}, userId: ${userId}, title: ${title}`);

    if (!title) {
        return res.status(400).json({ msg: 'Título do vídeo é obrigatório.' });
    }

    if (!agentId) {
        console.error(`[Script Laozhang] agentId não fornecido na URL`);
        return res.status(400).json({ msg: 'ID do agente é obrigatório.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Buscar o agente
        console.log(`[Script Laozhang] Buscando agente com id=${agentId} e user_id=${userId}`);
        
        // Primeiro, verificar se o agente existe (sem filtro de user_id)
        const agentExists = await db.get(
            `SELECT id, user_id, agent_name FROM script_agents WHERE id = ?`,
            [agentId]
        );
        
        if (!agentExists) {
            console.error(`[Script Laozhang] Agente ${agentId} não existe no banco de dados`);
            // Listar todos os agentes do usuário para debug
            const userAgents = await db.all(
                `SELECT id, agent_name FROM script_agents WHERE user_id = ?`,
                [userId]
            );
            console.log(`[Script Laozhang] Agentes disponíveis para user_id=${userId}:`, userAgents);
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }
        
        if (agentExists.user_id !== userId) {
            console.error(`[Script Laozhang] Agente ${agentId} existe mas pertence ao user_id=${agentExists.user_id}, não ao user_id=${userId}`);
            return res.status(403).json({ msg: 'Você não tem permissão para usar este agente.' });
        }
        
        // Buscar o agente completo
        const agent = await db.get(
            `SELECT * FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );
        
        if (!agent) {
            console.error(`[Script Laozhang] Erro inesperado: agente existe mas não foi encontrado com filtro user_id`);
            return res.status(500).json({ msg: 'Erro ao buscar agente.' });
        }

        console.log(`[Script Laozhang] Agente encontrado: ${agent.agent_name || 'Sem nome'}`);

        let scriptDuration = duration ? parseInt(duration) : 5;
        const scriptLanguage = language || 'pt';
        
        // Configurar CTAs (Call to Action)
        const ctaConfig = {
            inicio: cta?.inicio || false,
            meio: cta?.meio || false,
            final: cta?.final !== undefined ? cta.final : true // Padrão: CTA no final
        };
        
        console.log(`[Script Laozhang] CTAs configurados: início=${ctaConfig.inicio}, meio=${ctaConfig.meio}, final=${ctaConfig.final}`);
        
        // Mapear o modelo selecionado (aceitar tanto os valores do frontend quanto os nomes completos)
        let laozhangModel = 'gpt-4o'; // padrão
        if (selectedModel) {
            const modelLower = selectedModel.toLowerCase();
            if (modelLower.includes('claude') || modelLower.includes('sonnet') || selectedModel === 'claude-3-7-sonnet-20250219' || selectedModel === 'Claude 3.7 Sonnet (Fev/25)') {
                laozhangModel = 'claude-3-7-sonnet-20250219';
            } else if (modelLower.includes('gemini') || modelLower.includes('pro') || selectedModel === 'gemini-2.5-pro' || selectedModel === 'Gemini 2.5 Pro (2025)') {
                laozhangModel = 'gemini-2.5-pro';
            } else if (modelLower.includes('gpt') || modelLower.includes('4o') || selectedModel === 'gpt-4o' || selectedModel === 'GPT-4o (2025)') {
                laozhangModel = 'gpt-4o';
            }
        }
        
        console.log(`[Script Laozhang] Modelo selecionado: "${selectedModel}" -> Mapeado para: "${laozhangModel}"`);

        // A duração já vem ajustada do frontend (com 3-5 minutos extras)
        // Não adicionar mais minutos aqui para evitar duplicação
        // Mas aumentar wordsPerMinute para garantir margem de segurança
        const originalDuration = scriptDuration;
        console.log(`[Script Laozhang] Duração recebida do frontend: ${scriptDuration} minutos (já ajustada)`);
        
        // Definir palavras por minuto baseado no modelo
        // Aumentar para garantir que sempre seja suficiente (margem de segurança)
        // GPT: 200 palavras/minuto (aumentado para garantir duração mínima)
        // Claude: 180 palavras/minuto (aumentado para garantir duração mínima)
        // Gemini: 180 palavras/minuto (aumentado para garantir duração mínima)
        let wordsPerMinute = 180; // Base aumentada para todos os modelos
        if (laozhangModel === 'gpt-4o') {
            wordsPerMinute = 200; // Aumentado para 200 para garantir duração mínima
            console.log(`[Script Laozhang] GPT detectado: usando ${wordsPerMinute} palavras/minuto (aumentado para garantir duração mínima)`);
        } else if (laozhangModel === 'claude-3-7-sonnet-20250219') {
            wordsPerMinute = 180; // Aumentado para 180 para garantir duração mínima
            console.log(`[Script Laozhang] Claude detectado: usando ${wordsPerMinute} palavras/minuto (aumentado para garantir duração mínima)`);
        } else {
            wordsPerMinute = 180; // Gemini aumentado para 180
            console.log(`[Script Laozhang] Gemini detectado: usando ${wordsPerMinute} palavras/minuto (aumentado para garantir duração mínima)`);
        }

        // Criar prompt detalhado e específico
        // IMPORTANTE: Incluir palavras-chave para detectar como script request
        const targetWords = scriptDuration * wordsPerMinute;
        
        // Calcular número de partes ANTES de criar o prompt (para usar no prompt)
        // SEMPRE respeitar o número de partes solicitado pelo frontend
        let requestedParts = parseInt(parts, 10);
        if (Number.isNaN(requestedParts) || requestedParts <= 0) {
            requestedParts = null;
        }
        const idealParts = Math.max(1, Math.ceil(scriptDuration / 3));
        const numberOfParts = requestedParts || idealParts;
        if (requestedParts) {
            console.log(`[Script Laozhang] Usando número de partes solicitado pelo frontend: ${requestedParts} (ideal seria ${idealParts})`);
        } else {
            console.log(`[Script Laozhang] Nenhuma parte especificada, usando cálculo ideal: ${idealParts}`);
        }
        
        const prompt = `${agent.agent_prompt || 'Você é um ESPECIALISTA EM ROTEIROS VIRAIS para YouTube. Crie roteiros envolventes, cativantes e otimizados para viralização.'}

═══════════════════════════════════════════════════════════════════
INSTRUÇÕES DETALHADAS DO AGENTE (FÓRMULA VIRAL):
═══════════════════════════════════════════════════════════════════
${agent.agent_instructions || 'Siga a estrutura e fórmula viral identificada no roteiro original analisado.'}

${additionalInstructions ? `\n═══════════════════════════════════════════════════════════════════
INSTRUÇÕES ADICIONAIS DO USUÁRIO:
═══════════════════════════════════════════════════════════════════
${additionalInstructions}\n` : ''}

═══════════════════════════════════════════════════════════════════
PARÂMETROS DO ROTEIRO:
═══════════════════════════════════════════════════════════════════
TÍTULO: "${title}"
DURAÇÃO: ${scriptDuration} minutos (aproximadamente ${targetWords} palavras - ${wordsPerMinute} palavras/minuto)
IDIOMA: ${scriptLanguage === 'pt' ? 'Português (Brasil)' : scriptLanguage === 'en' ? 'Inglês' : 'Espanhol'}
${topic ? `TÓPICO ADICIONAL: ${topic}\n` : ''}
NICHE: ${agent.niche || 'N/A'}
SUBNICHE: ${agent.subniche || 'N/A'}

${(ctaConfig.inicio || ctaConfig.meio || ctaConfig.final) ? `═══════════════════════════════════════════════════════════════════
⚠️⚠️⚠️ CALL TO ACTION (CTA) - OBRIGATÓRIO E NATURAL ⚠️⚠️⚠️
═══════════════════════════════════════════════════════════════════
${ctaConfig.inicio ? `✅ CTA no INÍCIO (primeiros 30 segundos): 
   - Você DEVE incluir uma chamada para ação NATURAL e ORGÂNICA nos primeiros 30 segundos do roteiro
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar forçado
   - Exemplos naturais: "Se você está gostando deste conteúdo, já deixa seu like e se inscreva no canal para não perder os próximos vídeos", "Antes de continuar, se inscreva no canal e ative o sininho para receber notificações", "Se este conteúdo está te ajudando, já deixa seu like e comenta o que achou"
   - O CTA deve fazer parte do fluxo narrativo natural, não deve parecer uma interrupção
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, não uma marcação separada\n` : ''}
${ctaConfig.meio ? `✅ CTA no MEIO (aproximadamente na metade do vídeo):
   - Você DEVE incluir uma chamada para ação NATURAL e ORGÂNICA no meio do roteiro
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar forçado
   - Exemplos naturais: "Se você está aprendendo algo novo aqui, já deixa seu like e compartilha com quem precisa ver isso", "Antes de continuarmos, se inscreva no canal para não perder o restante deste conteúdo", "Se este vídeo está te ajudando, já deixa seu like e comenta suas dúvidas"
   - O CTA deve fazer parte do fluxo narrativo natural, não deve parecer uma interrupção
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, não uma marcação separada\n` : ''}
${ctaConfig.final ? `✅ CTA no FINAL (últimos 30 segundos):
   - Você DEVE incluir uma chamada para ação FORTE, NATURAL e ORGÂNICA nos últimos 30 segundos do roteiro
   - Este é o CTA mais importante - deve ser impactante mas ainda assim natural
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar forçado
   - Exemplos naturais: "Se este conteúdo te ajudou, já deixa seu like, se inscreva no canal, ative o sininho, compartilhe com seus amigos e comente o que achou", "Não esqueça de deixar seu like, se inscrever no canal e compartilhar este vídeo com quem precisa ver isso", "Se você gostou deste conteúdo, já deixa seu like, se inscreva no canal, ative o sininho para receber notificações e compartilhe com seus amigos"
   - O CTA deve fazer parte do fluxo narrativo natural, não deve parecer uma interrupção
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, não uma marcação separada
   - CRÍTICO: Este CTA final é essencial para o engajamento do vídeo\n` : ''}
⚠️ REGRAS IMPORTANTES SOBRE CTAs:
- Os CTAs devem ser incluídos de forma NATURAL e ORGÂNICA no texto narrativo
- NÃO use marcações como "[CTA]", "(CTA)", ou qualquer indicação explícita de CTA
- NÃO interrompa o fluxo narrativo abruptamente para incluir o CTA
- O CTA deve fazer parte da narrativa, como se fosse uma conversa natural com o espectador
- Use linguagem conversacional e envolvente
- Seja persuasivo mas genuíno, não forçado
- O CTA deve parecer que faz parte naturalmente do roteiro, não algo adicionado depois
- CRÍTICO: Se os CTAs não forem incluídos de forma natural, o roteiro será considerado incompleto

` : ''}
═══════════════════════════════════════════════════════════════════
RESPOSTA FINAL - CRÍTICO: ROTEIRO EM TEXTO SIMPLES
═══════════════════════════════════════════════════════════════════
⚠️⚠️⚠️ FORMATO DE RESPOSTA OBRIGATÓRIO ⚠️⚠️⚠️

Você DEVE retornar APENAS o texto do roteiro em TEXTO SIMPLES. NÃO use JSON. NÃO use markdown. NÃO use objetos ou estruturas de dados.

NÃO retorne:
❌ JSON (não use { }, não use "roteiro": "...", não use "script": "...")
❌ Markdown (não use code blocks, não use #, não use **)
❌ Objetos ou estruturas de dados
❌ Metadados ou informações adicionais

RETORNE APENAS:
✅ O texto puro do roteiro
✅ Texto corrido e natural
✅ Direto ao ponto, sem formatações especiais
✅ Apenas o conteúdo do roteiro em si

⚠️⚠️⚠️ DURAÇÃO OBRIGATÓRIA - CRÍTICO ⚠️⚠️⚠️
O roteiro DEVE ter EXATAMENTE ${scriptDuration} minutos de duração quando narrado.
Isso significa NO MÍNIMO ${targetWords} palavras (${scriptDuration} minutos × ${wordsPerMinute} palavras por minuto).
⚠️ CRÍTICO: O roteiro NUNCA pode ter MENOS de ${targetWords} palavras. Se tiver menos, será REJEITADO.
⚠️ CRÍTICO: O roteiro deve ter PELO MENOS ${targetWords} palavras para garantir ${scriptDuration} minutos de narração.
⚠️ CRÍTICO: Se o roteiro tiver menos de ${targetWords} palavras, você DEVE expandir o conteúdo até atingir PELO MENOS ${targetWords} palavras.
⚠️ CRÍTICO: É melhor ter mais palavras do que menos. Se necessário, adicione mais detalhes, exemplos, explicações ou contexto para atingir ${targetWords} palavras.
⚠️ CRÍTICO: Conte as palavras antes de finalizar. O roteiro DEVE ter PELO MENOS ${targetWords} palavras.

EXEMPLO DE FORMATO CORRETO:
Olviden todo lo que saben sobre las guerras antiguas. Olviden los ejércitos, las lanzas y los escudos. Existió una batalla mucho más sofisticada. Una guerra silenciosa librada no en los campos de batalla, sino en los observatorios, en los calendarios, y en la mente de los ingenieros más brillantes de la historia de América.

EXEMPLO DE FORMATO INCORRETO (NÃO FAÇA ISSO):
{
  "roteiro": "Olviden todo lo que saben..."
}

ou

code block json com:
{
  "roteiro": "..."
}

═══════════════════════════════════════════════════════════════════
INSTRUÇÕES FINAIS:
═══════════════════════════════════════════════════════════════════
1. Crie um roteiro completo, envolvente e otimizado para viralização
2. Siga EXATAMENTE a fórmula viral identificada nas instruções do agente
3. Adapte o conteúdo para o título "${title}" mantendo a estrutura viral
4. ⚠️⚠️⚠️ CRÍTICO - DURAÇÃO OBRIGATÓRIA ⚠️⚠️⚠️:
   - O roteiro DEVE ter PELO MENOS ${targetWords} palavras (${scriptDuration} minutos de duração) distribuídas em ${numberOfParts} partes
   - ⚠️ CRÍTICO: O roteiro NUNCA pode ter MENOS de ${targetWords} palavras. Se tiver menos, será REJEITADO.
   - ⚠️ CRÍTICO: É melhor ter mais palavras do que menos. Se necessário, expanda o conteúdo até atingir PELO MENOS ${targetWords} palavras.
   - ⚠️ CRÍTICO: Conte as palavras antes de finalizar. O roteiro DEVE ter PELO MENOS ${targetWords} palavras.
   - ⚠️ CRÍTICO: Você DEVE gerar conteúdo para TODAS as ${numberOfParts} partes. NÃO pare antes de completar todas as partes.
   - ⚠️ CRÍTICO: Se você gerar apenas ${Math.ceil(numberOfParts * 0.35)} partes ou menos, o roteiro estará INCOMPLETO e será REJEITADO.
   - ⚠️ CRÍTICO: Você tem tempo suficiente - NÃO tenha pressa, complete TODAS as partes e garanta PELO MENOS ${targetWords} palavras.
5. Use o idioma ${scriptLanguage === 'pt' ? 'Português (Brasil)' : scriptLanguage === 'en' ? 'Inglês' : 'Espanhol'}
6. ⚠️⚠️⚠️ CRÍTICO - ESTRUTURA DE PARÁGRAFOS E PALAVRAS - GERAR TODAS AS PARTES ⚠️⚠️⚠️:
   - O roteiro DEVE ser dividido em EXATAMENTE ${numberOfParts} PARTES (cada parte = aproximadamente 3 minutos)
   - ⚠️ CRÍTICO: Você DEVE gerar conteúdo para TODAS as ${numberOfParts} partes. NÃO pare antes de completar todas as partes.
   - Cada parte (EXCETO A ÚLTIMA) DEVE ter EXATAMENTE 5 PARÁGRAFOS
   - Cada parte (EXCETO A ÚLTIMA) DEVE ter ENTRE 390 e 450 PALAVRAS (total da parte)
   - Cada parágrafo (EXCETO NA ÚLTIMA PARTE) DEVE ter ENTRE 75 e 90 PALAVRAS
   - Distribuição ideal: 5 parágrafos × 78-90 palavras cada = 390-450 palavras totais por parte
   - Cada parágrafo deve ser separado por uma quebra de linha dupla (espaço em branco entre parágrafos)
   - A última parte pode ter um número variável de parágrafos e palavras conforme necessário para concluir o conteúdo
   - Estrutura obrigatória (você DEVE gerar TODAS estas partes): 
     ${Array.from({ length: numberOfParts }, (_, i) => {
         const partNum = i + 1;
         if (partNum === numberOfParts) {
             return `     * Parte ${partNum} (ÚLTIMA): número variável de parágrafos e palavras (conforme necessário para concluir)`;
         } else {
             return `     * Parte ${partNum}: 5 parágrafos (390-450 palavras totais, 75-90 palavras por parágrafo)`;
         }
     }).join('\n')}
   - ⚠️ CRÍTICO: Você DEVE gerar conteúdo para TODAS as ${numberOfParts} partes listadas acima. NÃO pare na parte ${numberOfParts === 1 ? '1' : numberOfParts > 2 ? '2 ou 3' : '2'}. Continue até completar a parte ${numberOfParts}.
   - Os parágrafos devem estar bem distribuídos ao longo de cada parte
   - IMPORTANTE: Separe claramente cada parágrafo com uma linha em branco
   - CRÍTICO: Conte as palavras de cada parágrafo e da parte completa antes de finalizar
   - CRÍTICO: O roteiro completo DEVE ter ${targetWords} palavras distribuídas entre as ${numberOfParts} partes
7. Escreva APENAS o texto do roteiro, SEM JSON, SEM markdown, SEM formatações especiais
8. ⚠️ CRÍTICO - NÃO INCLUA MARCAÇÕES DE PARTE OU TEMPO:
   - NÃO inclua marcações como "PARTE 1", "Parte 1", "PARTE 1 0:00 - 3:00", "Parte 1 0:00 - 3:00"
   - NÃO inclua marcações de tempo como "[0:00-3:00]", "(0:00)", "0:00 - 3:00", "0:00-3:00"
   - NÃO inclua qualquer indicação de número de parte ou intervalo de tempo no texto
   - O roteiro deve ser APENAS texto narrativo puro, sem marcações técnicas
   - Escreva como se estivesse narrando diretamente, sem prefixos, sem marcações de parte ou tempo
   - CRÍTICO: Se você incluir marcações de parte ou tempo, o roteiro será rejeitado

⚠️⚠️⚠️ LEMBRE-SE: Você DEVE gerar conteúdo para TODAS as ${numberOfParts} partes. O roteiro completo deve ter ${targetWords} palavras. NÃO pare antes de completar todas as ${numberOfParts} partes. Se você parar antes da parte ${numberOfParts}, o roteiro estará incompleto e será rejeitado.

AGORA, CRIE O ROTEIRO COMPLETO COM TODAS AS ${numberOfParts} PARTES (SEM MARCAÇÕES DE PARTE OU TEMPO):`;

        console.log(`[Script Laozhang] Gerando roteiro com modelo: ${laozhangModel}, duração: ${scriptDuration} minutos (${targetWords} palavras), partes: ${numberOfParts}`);
        
        // Enviar progresso inicial
        if (sessionId) {
            sendProgress(sessionId, {
                stage: 'initializing',
                progress: 5,
                message: 'Inicializando geração...',
                totalParts: numberOfParts,
                currentPart: 0,
                details: { totalParts: numberOfParts }
            });
            
            sendProgress(sessionId, {
                stage: 'preparing',
                progress: 10,
                message: `Preparando IA do agente (meta: ${targetWords.toLocaleString()} palavras)...`,
                totalParts: numberOfParts,
                currentPart: 0,
                details: { model: laozhangModel, targetWords, totalParts: numberOfParts }
            });
        }
        
        const startTime = Date.now();
        
        // Simular progresso por partes durante a geração
        let currentPartSimulated = 0;
        const progressInterval = setInterval(() => {
            if (sessionId && currentPartSimulated < numberOfParts) {
                currentPartSimulated++;
                const progress = Math.min(80, 10 + (currentPartSimulated / numberOfParts) * 70);
                sendProgress(sessionId, {
                    stage: 'generating',
                    progress: progress,
                    currentPart: currentPartSimulated,
                    totalParts: numberOfParts,
                    message: `Gerando parte ${currentPartSimulated}/${numberOfParts}...`,
                    details: {
                        partNumber: currentPartSimulated,
                        status: 'generating',
                        percentage: Math.round((currentPartSimulated / numberOfParts) * 100),
                        completedParts: currentPartSimulated - 1
                    }
                });
            }
        }, 2000); // Atualizar a cada 2 segundos
        
        const response = await callLaozhangAPI(
            prompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_script_agents_generate',
            JSON.stringify({ endpoint: '/api/script-agents/:agentId/generate/laozhang', model: laozhangModel })
        );
        
        clearInterval(progressInterval);
        
        console.log(`[Script Laozhang] Resposta recebida do modelo ${laozhangModel}`);
        
        // Marcar todas as partes como concluídas sequencialmente
        if (sessionId) {
            for (let partNum = 1; partNum <= numberOfParts; partNum++) {
                sendProgress(sessionId, {
                    stage: 'generating',
                    progress: Math.min(95, 10 + (partNum / numberOfParts) * 85),
                    currentPart: partNum,
                    totalParts: numberOfParts,
                    message: `Parte ${partNum}/${numberOfParts} concluída!`,
                    details: {
                        partNumber: partNum,
                        status: 'completed',
                        percentage: 100,
                        completedParts: partNum
                    }
                });
                // Pequeno delay entre cada atualização para visualização
                await new Promise(resolve => setTimeout(resolve, 400));
            }
            
            sendProgress(sessionId, {
                stage: 'completed',
                progress: 100,
                currentPart: numberOfParts,
                totalParts: numberOfParts,
                message: 'Roteiro gerado com sucesso!',
                details: { completed: true, completedParts: numberOfParts }
            });
        }

        let scriptContent = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        console.log(`[Script Laozhang] Resposta recebida (primeiros 500 chars):`, scriptContent.substring(0, 500));
        
        // Limpar o roteiro (remover JSON, markdown, etc) - processo mais robusto
        let cleanedScript = scriptContent;
        
        // 1. Remover markdown code blocks
        cleanedScript = cleanedScript.replace(/```[\s\S]*?```/g, '');
        cleanedScript = cleanedScript.replace(/```json[\s\S]*?```/gi, '');
        cleanedScript = cleanedScript.replace(/```text[\s\S]*?```/gi, '');
        
        // 2. Tentar extrair texto de estruturas JSON comuns
        const jsonPatterns = [
            /"roteiro"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /"script"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /"content"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /"texto"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /"text"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /roteiro["']?\s*:\s*["']([^"']+)["']/gi,
            /script["']?\s*:\s*["']([^"']+)["']/gi
        ];
        
        for (const pattern of jsonPatterns) {
            const match = cleanedScript.match(pattern);
            if (match && match[1]) {
                cleanedScript = match[1]
                    .replace(/\\n/g, '\n')
                    .replace(/\\r/g, '\r')
                    .replace(/\\t/g, '\t')
                    .replace(/\\"/g, '"')
                    .replace(/\\'/g, "'")
                    .replace(/\\\\/g, '\\');
                console.log(`[Script Laozhang] Extraído texto de JSON usando padrão: ${pattern}`);
                break;
            }
        }
        
        // 3. Remover estruturas JSON restantes
        cleanedScript = cleanedScript
            .replace(/^[^{]*\{[\s\S]*?"roteiro"\s*:\s*/, '')  // Remove início de JSON até "roteiro":
            .replace(/^[^{]*\{[\s\S]*?"script"\s*:\s*/, '')  // Remove início de JSON até "script":
            .replace(/^[^{]*\{[\s\S]*?"content"\s*:\s*/, '')  // Remove início de JSON até "content":
            .replace(/["']roteiro["']\s*:\s*["']?/gi, '')     // Remove "roteiro": "
            .replace(/["']script["']\s*:\s*["']?/gi, '')      // Remove "script": "
            .replace(/["']content["']\s*:\s*["']?/gi, '')     // Remove "content": "
            .replace(/["']texto["']\s*:\s*["']?/gi, '')       // Remove "texto": "
            .replace(/["']text["']\s*:\s*["']?/gi, '')        // Remove "text": "
            .replace(/^[^{]*\{/, '')                          // Remove { no início
            .replace(/\}[^}]*$/, '')                          // Remove } no final
            .replace(/^[\s\n\r]*["']/, '')                    // Remove " no início
            .replace(/["'][\s\n\r]*$/, '')                    // Remove " no final
            .trim();
        
        // 4. Se ainda parece JSON, tentar parsear e extrair
        if (cleanedScript.trim().startsWith('{') || cleanedScript.trim().startsWith('[')) {
            try {
                const parsed = JSON.parse(cleanedScript);
                if (parsed.roteiro) {
                    cleanedScript = typeof parsed.roteiro === 'string' ? parsed.roteiro : JSON.stringify(parsed.roteiro);
                } else if (parsed.script) {
                    cleanedScript = typeof parsed.script === 'string' ? parsed.script : JSON.stringify(parsed.script);
                } else if (parsed.content) {
                    cleanedScript = typeof parsed.content === 'string' ? parsed.content : JSON.stringify(parsed.content);
                } else if (typeof parsed === 'string') {
                    cleanedScript = parsed;
                }
                console.log(`[Script Laozhang] Parseado JSON e extraído conteúdo`);
            } catch (parseErr) {
                console.warn(`[Script Laozhang] Não foi possível parsear como JSON, usando texto limpo:`, parseErr.message);
            }
        }
        
        // 5. Limpeza final - remover TODAS as marcações para voice over
        cleanedScript = cleanedScript
            // Remover marcações de PARTE X com intervalos de tempo (mais agressivo - múltiplas tentativas)
            .replace(/PARTE\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gi, '') // Remove linha inteira com "PARTE 1 0:00 - 3:00"
            .replace(/Parte\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gi, '') // Remove linha inteira com "Parte 1 0:00 - 3:00"
            .replace(/PARTE\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}/gi, '') // Remove "PARTE 1 0:00 - 3:00" (sem quebra de linha)
            .replace(/Parte\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}/gi, '') // Remove "Parte 1 0:00 - 3:00" (sem quebra de linha)
            .replace(/PARTE\s+\d+.*?(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})/gi, '') // Remove "PARTE 1 0:00 - 3:00" (qualquer variação)
            .replace(/Parte\s+\d+.*?(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})/gi, '') // Remove "Parte 1 0:00 - 3:00" (qualquer variação)
            .replace(/^\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gmi, '') // Remove linha que começa com "0:00 - 3:00"
            .replace(/^\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}\s*/gmi, '') // Remove "0:00 - 3:00" no início da linha (sem quebra)
            .replace(/PARTE\s+\d+\s*$/gmi, '') // Remove "PARTE 1" sozinho no final da linha
            .replace(/Parte\s+\d+\s*$/gmi, '') // Remove "Parte 1" sozinho no final da linha
            // Remover marcações de cenas
            .replace(/^Cena\s+\d+:\s*/gmi, '') // Remove "Cena 1:", "Cena 2:", etc.
            .replace(/^CENA\s+\d+:\s*/gmi, '') // Remove "CENA 1:", "CENA 2:", etc.
            .replace(/^Scene\s+\d+:\s*/gmi, '') // Remove "Scene 1:", "Scene 2:", etc.
            .replace(/^SCENE\s+\d+:\s*/gmi, '') // Remove "SCENE 1:", "SCENE 2:", etc.
            .replace(/^Parte\s+\d+:\s*/gmi, '') // Remove "Parte 1:", "Parte 2:", etc.
            .replace(/^PARTE\s+\d+:\s*/gmi, '') // Remove "PARTE 1:", "PARTE 2:", etc.
            // Remover marcações de tempo
            .replace(/\[?\d{1,2}:\d{2}-\d{1,2}:\d{2}\]?\s*/g, '') // Remove [0:00-0:30]
            .replace(/\(\d{1,2}:\d{2}\)\s*/g, '') // Remove (0:30)
            .replace(/^\d{1,2}:\d{2}\s*/gm, '') // Remove 0:30 no início da linha
            // Remover títulos de seções em maiúsculas
            .replace(/^[A-Z][A-Z\s]+:\s*/gm, '') // Remove títulos em maiúsculas seguidos de dois pontos
            // Limpar aspas
            .replace(/^\s*["']+/, '')  // Remove aspas no início
            .replace(/["']+\s*$/, '')  // Remove aspas no final
            // Limpar espaços e quebras excessivas
            .replace(/\n{3,}/g, '\n\n') // Remove múltiplas quebras de linha
            .replace(/^\s+/gm, '') // Remove espaços no início de cada linha
            .replace(/\s+$/gm, '') // Remove espaços no final de cada linha
            .trim();
        
        // 6. Se o script estiver vazio ou muito curto, usar a resposta original
        if (!cleanedScript || cleanedScript.length < 100) {
            console.warn(`[Script Laozhang] Script limpo muito curto (${cleanedScript?.length || 0} chars), usando resposta original`);
            cleanedScript = scriptContent.trim();
        }
        
        console.log(`[Script Laozhang] Script final (primeiros 300 chars):`, cleanedScript.substring(0, 300));
        
        // Validar e expandir roteiro se necessário
        let wordCount = cleanedScript.split(/\s+/).filter(word => word.length > 0).length;
        const expectedWordCount = targetWords;
        const wordCountDifference = Math.abs(wordCount - expectedWordCount);
        const wordCountPercentage = ((wordCount / expectedWordCount) * 100).toFixed(1);
        
        console.log(`[Script Laozhang] Validação de duração:`);
        console.log(`  - Palavras esperadas: ${expectedWordCount} (${scriptDuration} minutos)`);
        console.log(`  - Palavras geradas: ${wordCount}`);
        console.log(`  - Diferença: ${wordCountDifference} palavras (${wordCountPercentage}% do esperado)`);
        
        // Se o roteiro estiver muito curto (menos de 95% do esperado), expandir
        const minWordCount = Math.floor(expectedWordCount * 0.95); // 95% do esperado como mínimo absoluto
        if (wordCount < minWordCount) {
            const wordsNeeded = minWordCount - wordCount;
            console.warn(`[Script Laozhang] ⚠️⚠️⚠️ CRÍTICO: Roteiro MUITO CURTO! Esperado MÍNIMO: ${minWordCount} palavras, Gerado: ${wordCount} palavras (${wordCountPercentage}%). Faltam ${wordsNeeded} palavras.`);
            console.log(`[Script Laozhang] 🔄 Expandindo roteiro para atingir a duração mínima...`);
            const expansionPrompt = `O roteiro abaixo está muito curto. Ele tem ${wordCount} palavras, mas precisa ter PELO MENOS ${minWordCount} palavras para garantir ${scriptDuration} minutos de duração.

ROTEIRO ATUAL:
${cleanedScript.substring(0, 2000)}

INSTRUÇÕES:
1. EXPANDA o roteiro acima adicionando pelo menos ${wordsNeeded} palavras
2. Mantenha o mesmo estilo, tom e estrutura
3. Adicione mais detalhes, exemplos, explicações ou desenvolvimentos
4. NÃO altere o início ou o final, apenas EXPANDA o conteúdo do meio
5. ⚠️ CRÍTICO: O roteiro expandido DEVE ter PELO MENOS ${minWordCount} palavras (é melhor ter mais do que menos)
6. ⚠️ CRÍTICO: Conte as palavras antes de finalizar. O roteiro DEVE ter PELO MENOS ${minWordCount} palavras
7. Retorne APENAS o roteiro expandido em texto simples, SEM JSON, SEM markdown, SEM marcações de parte ou tempo

ROTEIRO EXPANDIDO:`;

            try {
                const expansionResponse = await callLaozhangAPI(
                    expansionPrompt,
                    laozhangApiKey,
                    laozhangModel,
                    null,
                    userId,
                    'api_script_agents_generate',
                    JSON.stringify({ endpoint: '/api/script-agents/:agentId/generate/laozhang', model: laozhangModel, action: 'expand' })
                );
                
                let expandedScript = typeof expansionResponse === 'string' ? expansionResponse.trim() : JSON.stringify(expansionResponse);
                
                // Limpar o roteiro expandido da mesma forma
                expandedScript = expandedScript
                    .replace(/```[\s\S]*?```/g, '')
                    .replace(/```json[\s\S]*?```/gi, '')
                    .replace(/\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                    .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/\{[\s\S]*\}/g, '')
                    .trim();
                
                const expandedWordCount = expandedScript.split(/\s+/).filter(word => word.length > 0).length;
                
                if (expandedWordCount >= expectedWordCount * 0.8) {
                    cleanedScript = expandedScript;
                    wordCount = expandedWordCount;
                    console.log(`[Script Laozhang] ✅ Roteiro expandido com sucesso! Nova contagem: ${wordCount} palavras (${((wordCount / expectedWordCount) * 100).toFixed(1)}%)`);
                } else {
                    console.warn(`[Script Laozhang] ⚠️ Expansão não foi suficiente. Mantendo roteiro original.`);
                }
            } catch (expandErr) {
                console.error(`[Script Laozhang] Erro ao expandir roteiro:`, expandErr);
                console.warn(`[Script Laozhang] Mantendo roteiro original apesar de estar curto.`);
            }
        } else if (wordCount > expectedWordCount * 1.3) {
            console.warn(`[Script Laozhang] ⚠️ ATENÇÃO: Roteiro muito longo! Esperado: ${expectedWordCount} palavras, Gerado: ${wordCount} palavras (${wordCountPercentage}%)`);
        } else {
            console.log(`[Script Laozhang] ✅ Duração do roteiro está dentro do esperado (${wordCountPercentage}%)`);
        }

        // Salvar roteiro no banco
        // Verificar se as colunas duration_minutes e language existem
        let columnsToInsert = ['user_id', 'script_agent_id', 'title', 'script_content', 'model_used', 'niche', 'subniche'];
        // Limpar nome do modelo para salvar (sem prefixo de fornecedor)
        const cleanModelForSave = (model) => {
            if (!model) return 'GPT-4o';
            // Remover prefixos e mapear para nomes amigáveis
            let clean = model.replace(/^(laozhang-|claude-|gemini-|gpt-)/i, '');
            if (clean.includes('gpt-4o')) return 'GPT-4o';
            if (clean.includes('claude-3-7-sonnet') || clean.includes('sonnet-3-7')) return 'Claude 3.7 Sonnet';
            if (clean.includes('claude-sonnet-4') || clean.includes('sonnet-4')) return 'Claude Sonnet 4';
            if (clean.includes('gemini-2.5-pro')) return 'Gemini 2.5 Pro';
            return clean || 'GPT-4o';
        };
        let valuesToInsert = [userId, agentId, title, cleanedScript, cleanModelForSave(laozhangModel), agent.niche, agent.subniche];
        
        try {
            // Tentar verificar se as colunas existem
            const tableInfo = await db.all(`PRAGMA table_info(generated_scripts)`);
            const columnNames = tableInfo.map(col => col.name);
            
            if (columnNames.includes('duration_minutes')) {
                columnsToInsert.push('duration_minutes');
                valuesToInsert.push(scriptDuration);
            }
            if (columnNames.includes('language')) {
                columnsToInsert.push('language');
                valuesToInsert.push(scriptLanguage);
            }
        } catch (pragmaErr) {
            console.warn('[Script Laozhang] Erro ao verificar colunas, usando apenas colunas básicas:', pragmaErr.message);
        }
        
        const result = await db.run(
            `INSERT INTO generated_scripts (${columnsToInsert.join(', ')})
             VALUES (${columnsToInsert.map(() => '?').join(', ')})`,
            valuesToInsert
        );

        // Enviar progresso final
        if (sessionId) {
            sendProgress(sessionId, {
                stage: 'completed',
                progress: 100,
                message: 'Roteiro gerado com sucesso!',
                details: { completed: true, scriptId: result.lastID }
            });
        }

        res.status(200).json({
            msg: 'Roteiro gerado com sucesso!',
            scriptId: result.lastID,
            script: cleanedScript
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId/generate/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar roteiro.' });
    }
});

// Rota para atualizar um agente
app.put('/api/script-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { agentName, niche, subniche, agentPrompt, agentInstructions } = req.body;
    const userId = req.user.id;

    try {
        const agent = await db.get(
            `SELECT id FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        const updates = [];
        const values = [];

        if (agentName !== undefined) {
            updates.push('agent_name = ?');
            values.push(agentName);
        }
        if (niche !== undefined) {
            updates.push('niche = ?');
            values.push(niche);
        }
        if (subniche !== undefined) {
            updates.push('subniche = ?');
            values.push(subniche);
        }
        if (agentPrompt !== undefined) {
            updates.push('agent_prompt = ?');
            values.push(agentPrompt);
        }
        if (agentInstructions !== undefined) {
            updates.push('agent_instructions = ?');
            values.push(agentInstructions);
        }

        if (updates.length === 0) {
            return res.status(400).json({ msg: 'Nenhum campo para atualizar.' });
        }

        updates.push('updated_at = CURRENT_TIMESTAMP');
        values.push(agentId);

        await db.run(
            `UPDATE script_agents SET ${updates.join(', ')} WHERE id = ?`,
            values
        );

        res.status(200).json({ msg: 'Agente atualizado com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId PUT]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar agente.' });
    }
});
// Rota para deletar um agente
app.delete('/api/script-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        const result = await db.run(
            `DELETE FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        res.status(200).json({ msg: 'Agente deletado com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao deletar agente.' });
    }
});

// Rota para listar roteiros gerados
app.get('/api/scripts', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { agentId } = req.query;

    try {
        let scripts;
        if (agentId) {
            scripts = await db.all(
                `SELECT gs.*, sa.agent_name
                 FROM generated_scripts gs
                 LEFT JOIN script_agents sa ON gs.script_agent_id = sa.id
                 WHERE gs.user_id = ? AND gs.script_agent_id = ?
                 ORDER BY gs.created_at DESC`,
                [userId, agentId]
            );
        } else {
            scripts = await db.all(
                `SELECT gs.*, sa.agent_name
                 FROM generated_scripts gs
                 LEFT JOIN script_agents sa ON gs.script_agent_id = sa.id
                 WHERE gs.user_id = ?
                 ORDER BY gs.created_at DESC`,
                [userId]
            );
        }

        res.status(200).json({ scripts });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts]:', err);
        res.status(500).json({ msg: 'Erro ao listar roteiros.' });
    }
});

// Rota para obter um roteiro específico
app.get('/api/scripts/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scriptId = req.params.id;

    try {
        const script = await db.get(
            `SELECT gs.*, sa.agent_name
             FROM generated_scripts gs
             LEFT JOIN script_agents sa ON gs.script_agent_id = sa.id
             WHERE gs.id = ? AND gs.user_id = ?`,
            [scriptId, userId]
        );

        if (!script) {
            return res.status(404).json({ msg: 'Roteiro não encontrado.' });
        }

        res.json({ script });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts/:id]:', err);
        res.status(500).json({ msg: 'Erro ao obter roteiro.' });
    }
});

// Rota para deletar um roteiro
app.delete('/api/scripts/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scriptId = req.params.id;

    try {
        const result = await db.run(
            `DELETE FROM generated_scripts WHERE id = ? AND user_id = ?`,
            [scriptId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Roteiro não encontrado.' });
        }

        res.json({ msg: 'Roteiro excluído com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir roteiro.' });
    }
});

// ==================== ROTAS PARA AGENTES VIRAIS ====================

// Rota para criar um agente viral
app.post('/api/viral-agents', authenticateToken, async (req, res) => {
    const { name, description, memory, instructions, model } = req.body;
    const userId = req.user.id;

    if (!name || name.trim().length === 0) {
        return res.status(400).json({ msg: 'Nome do agente é obrigatório.' });
    }

    try {
        const result = await db.run(
            `INSERT INTO viral_agents (user_id, name, description, memory, instructions, model)
             VALUES (?, ?, ?, ?, ?, ?)`,
            [userId, name.trim(), description || null, memory || null, instructions || null, model || 'gpt-4o']
        );

        const newAgent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ?`,
            [result.lastID]
        );

        res.status(201).json({
            msg: 'Agente viral criado com sucesso!',
            agent: newAgent
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents POST]:', err);
        res.status(500).json({ msg: 'Erro ao criar agente viral.' });
    }
});

// Rota para listar todos os agentes virais do usuário
app.get('/api/viral-agents', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const agents = await db.all(
            `SELECT va.*, 
                    COUNT(DISTINCT vaf.id) as file_count,
                    COUNT(DISTINCT vac.id) as conversation_count
             FROM viral_agents va
             LEFT JOIN viral_agent_files vaf ON va.id = vaf.agent_id
             LEFT JOIN viral_agent_conversations vac ON va.id = vac.agent_id
             WHERE va.user_id = ?
             GROUP BY va.id
             ORDER BY va.is_favorite DESC, va.updated_at DESC`,
            [userId]
        );

        res.status(200).json({ agents });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents GET]:', err);
        res.status(500).json({ msg: 'Erro ao listar agentes virais.' });
    }
});

// Rota para obter um agente viral específico
app.get('/api/viral-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        const agent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        // Buscar arquivos do agente
        const files = await db.all(
            `SELECT * FROM viral_agent_files WHERE agent_id = ? ORDER BY created_at DESC`,
            [agentId]
        );

        // Buscar conversas do agente
        const conversations = await db.all(
            `SELECT * FROM viral_agent_conversations 
             WHERE agent_id = ? AND user_id = ? 
             ORDER BY updated_at DESC`,
            [agentId, userId]
        );

        res.status(200).json({
            agent: {
                ...agent,
                files,
                conversations
            }
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId GET]:', err);
        res.status(500).json({ msg: 'Erro ao obter agente viral.' });
    }
});

// Rota para atualizar um agente viral
app.put('/api/viral-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { name, description, memory, instructions, is_favorite, model } = req.body;
    const userId = req.user.id;

    try {
        const agent = await db.get(
            `SELECT id FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        const updates = [];
        const values = [];

        if (name !== undefined) {
            updates.push('name = ?');
            values.push(name.trim());
        }
        if (description !== undefined) {
            updates.push('description = ?');
            values.push(description);
        }
        if (memory !== undefined) {
            updates.push('memory = ?');
            values.push(memory);
        }
        if (instructions !== undefined) {
            updates.push('instructions = ?');
            values.push(instructions);
        }
        if (model !== undefined) {
            updates.push('model = ?');
            values.push(model);
        }
        if (is_favorite !== undefined) {
            updates.push('is_favorite = ?');
            values.push(is_favorite ? 1 : 0);
        }

        if (updates.length === 0) {
            return res.status(400).json({ msg: 'Nenhum campo para atualizar.' });
        }

        updates.push('updated_at = CURRENT_TIMESTAMP');
        values.push(agentId);

        await db.run(
            `UPDATE viral_agents SET ${updates.join(', ')} WHERE id = ?`,
            values
        );

        const updatedAgent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ?`,
            [agentId]
        );

        res.status(200).json({
            msg: 'Agente atualizado com sucesso!',
            agent: updatedAgent
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId PUT]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar agente viral.' });
    }
});

// Rota para deletar um agente viral
app.delete('/api/viral-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        const result = await db.run(
            `DELETE FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        res.status(200).json({ msg: 'Agente deletado com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao deletar agente viral.' });
    }
});

// Rota para adicionar arquivo a um agente viral
app.post('/api/viral-agents/:agentId/files', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { file_name, file_content, file_type, file_size } = req.body;
    const userId = req.user.id;

    if (!file_name || !file_content) {
        return res.status(400).json({ msg: 'Nome e conteúdo do arquivo são obrigatórios.' });
    }

    try {
        // Verificar se o agente pertence ao usuário
        const agent = await db.get(
            `SELECT id FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        const result = await db.run(
            `INSERT INTO viral_agent_files (agent_id, file_name, file_content, file_type, file_size)
             VALUES (?, ?, ?, ?, ?)`,
            [agentId, file_name, file_content, file_type || 'text/plain', file_size || file_content.length]
        );

        const newFile = await db.get(
            `SELECT * FROM viral_agent_files WHERE id = ?`,
            [result.lastID]
        );

        res.status(201).json({
            msg: 'Arquivo adicionado com sucesso!',
            file: newFile
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/files POST]:', err);
        res.status(500).json({ msg: 'Erro ao adicionar arquivo.' });
    }
});

// Rota para listar arquivos de um agente viral
app.get('/api/viral-agents/:agentId/files', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        // Verificar se o agente pertence ao usuário
        const agent = await db.get(
            `SELECT id FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        const files = await db.all(
            `SELECT * FROM viral_agent_files WHERE agent_id = ? ORDER BY created_at DESC`,
            [agentId]
        );

        res.status(200).json({ files });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/files GET]:', err);
        res.status(500).json({ msg: 'Erro ao listar arquivos.' });
    }
});

// Rota para deletar arquivo de um agente viral
app.delete('/api/viral-agents/:agentId/files/:fileId', authenticateToken, async (req, res) => {
    const { agentId, fileId } = req.params;
    const userId = req.user.id;

    try {
        // Verificar se o agente pertence ao usuário
        const agent = await db.get(
            `SELECT id FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        const result = await db.run(
            `DELETE FROM viral_agent_files WHERE id = ? AND agent_id = ?`,
            [fileId, agentId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Arquivo não encontrado.' });
        }

        res.status(200).json({ msg: 'Arquivo deletado com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/files/:fileId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao deletar arquivo.' });
    }
});

// Rota para criar uma nova conversa com um agente viral
app.post('/api/viral-agents/:agentId/conversations', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { title } = req.body;
    const userId = req.user.id;

    try {
        // Verificar se o agente pertence ao usuário
        const agent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        const result = await db.run(
            `INSERT INTO viral_agent_conversations (agent_id, user_id, title)
             VALUES (?, ?, ?)`,
            [agentId, userId, title || 'Nova Conversa']
        );

        const newConversation = await db.get(
            `SELECT * FROM viral_agent_conversations WHERE id = ?`,
            [result.lastID]
        );

        res.status(201).json({
            msg: 'Conversa criada com sucesso!',
            conversation: newConversation
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/conversations POST]:', err);
        res.status(500).json({ msg: 'Erro ao criar conversa.' });
    }
});

// Rota para enviar mensagem para um agente viral (chat) - COM STREAMING
app.post('/api/viral-agents/:agentId/chat', authenticateToken, async (req, res) => {
        const { agentId } = req.params;
        const { conversation_id, message, model: requestModel, stream = true } = req.body;
        const userId = req.user.id;

    if (!message || !conversation_id) {
        return res.status(400).json({ msg: 'Mensagem e ID da conversa são obrigatórios.' });
    }

    try {
        // Verificar se o agente pertence ao usuário
        const agent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }
        
        // Usar modelo do agente ou o modelo da requisição
        const modelToUse = requestModel || agent.model || 'gpt-4o';

        // Verificar se a conversa pertence ao usuário e ao agente
        const conversation = await db.get(
            `SELECT * FROM viral_agent_conversations 
             WHERE id = ? AND agent_id = ? AND user_id = ?`,
            [conversation_id, agentId, userId]
        );

        if (!conversation) {
            return res.status(404).json({ msg: 'Conversa não encontrada.' });
        }

        // Salvar mensagem do usuário
        await db.run(
            `INSERT INTO viral_agent_messages (conversation_id, role, content)
             VALUES (?, ?, ?)`,
            [conversation_id, 'user', message]
        );

        // Buscar histórico de mensagens da conversa
        const messageHistory = await db.all(
            `SELECT role, content FROM viral_agent_messages 
             WHERE conversation_id = ? 
             ORDER BY created_at ASC`,
            [conversation_id]
        );

        // Buscar arquivos do agente
        const agentFiles = await db.all(
            `SELECT file_name, file_content FROM viral_agent_files WHERE agent_id = ?`,
            [agentId]
        );

        // Preparar contexto para o Claude (CRÍTICO: sempre incluir memória e instruções)
        // FORMATO RIGOROSO: Priorizar instruções e memória de forma clara e enfática
        let systemPrompt = '';
        
        // INÍCIO: Instrução crítica para seguir as configurações
        systemPrompt += `# ⚠️ INSTRUÇÕES CRÍTICAS - SIGA RIGOROSAMENTE\n\n`;
        systemPrompt += `Você é um agente especializado que DEVE seguir EXATAMENTE as instruções e memória configuradas abaixo.\n`;
        systemPrompt += `NÃO invente ou ignore essas configurações. Elas definem seu comportamento e conhecimento.\n\n`;
        
        // MEMÓRIA PRIMEIRO (contexto sobre o usuário/agente)
        if (agent.memory && agent.memory.trim()) {
            systemPrompt += `# 📝 MEMÓRIA DO AGENTE (CONTEXTO OBRIGATÓRIO)\n`;
            systemPrompt += `A seguir está a memória configurada para este agente. Use essas informações para personalizar suas respostas:\n\n`;
            systemPrompt += `${agent.memory}\n\n`;
            systemPrompt += `---\n\n`;
            console.log('[Viral Agents] ✅ Memória incluída, tamanho:', agent.memory.length);
        } else {
            console.warn('[Viral Agents] ⚠️ Memória vazia ou não definida');
        }
        
        // INSTRUÇÕES (comportamento e formato)
        if (agent.instructions && agent.instructions.trim()) {
            systemPrompt += `# 🎯 INSTRUÇÕES DO AGENTE (SEGUIR OBRIGATORIAMENTE)\n`;
            systemPrompt += `As instruções abaixo definem COMO você deve se comportar e QUAIS regras seguir:\n\n`;
            systemPrompt += `${agent.instructions}\n\n`;
            systemPrompt += `---\n\n`;
            console.log('[Viral Agents] ✅ Instruções incluídas, tamanho:', agent.instructions.length);
        } else {
            console.warn('[Viral Agents] ⚠️ Instruções vazias ou não definidas');
        }
        
        // ARQUIVOS (referências adicionais)
        if (agentFiles.length > 0) {
            systemPrompt += `# 📎 ARQUIVOS DISPONÍVEIS (REFERÊNCIA)\n`;
            systemPrompt += `Use os arquivos abaixo como referência adicional quando relevante:\n\n`;
            agentFiles.forEach(file => {
                systemPrompt += `## ${file.file_name}\n${file.file_content}\n\n`;
            });
            systemPrompt += `---\n\n`;
            console.log('[Viral Agents] ✅ Arquivos incluídos:', agentFiles.length);
        }
        
        // RELEMBRAR: Seguir as configurações
        systemPrompt += `# ⚠️ LEMBRETE FINAL\n`;
        systemPrompt += `- Use a MEMÓRIA para personalizar suas respostas ao contexto do usuário\n`;
        systemPrompt += `- Siga as INSTRUÇÕES rigorosamente para manter consistência\n`;
        systemPrompt += `- Se as instruções pedirem um formato específico, use EXATAMENTE esse formato\n`;
        systemPrompt += `- Se a memória descrever o propósito do agente, mantenha esse propósito em todas as respostas\n\n`;
        
        // Adicionar instrução para gerar avaliação separadamente (não no roteiro)
        systemPrompt += `# 📊 AVALIAÇÃO DO ROTEIRO\n`;
        systemPrompt += `Após finalizar o roteiro completo, gere uma avaliação separada no formato JSON:\n`;
        systemPrompt += `{"nota": X, "checklist": {"gancho_inicial": true/false, "estrutura_narrativa": true/false, "engajamento_emocional": true/false, "densidade_valor": true/false, "tecnicas_retencao": true/false, "linguagem_tom": true/false, "elementos_estruturais": true/false, "loops_abertos": true/false, "variacao_emocional": true/false, "final_satisfatorio": true/false}}\n`;
        systemPrompt += `Onde X é uma nota de 1 a 10 baseada nos critérios:\n`;
        systemPrompt += `1. GANCHO INICIAL (0-30 segundos): Abertura magnética que cria "lacuna de curiosidade". Promessa clara do valor do vídeo.\n`;
        systemPrompt += `2. ESTRUTURA NARRATIVA: Arco dramático completo, ritmo variado, transições fluidas.\n`;
        systemPrompt += `3. ENGAJAMENTO EMOCIONAL: Apelo a emoções primárias, personagens identificáveis, stakes claros.\n`;
        systemPrompt += `4. DENSIDADE DE VALOR: Informação surpreendente a cada 30-60s, especificidade, sem enchimento.\n`;
        systemPrompt += `5. TÉCNICAS DE RETENÇÃO: Pattern interrupts, foreshadowing, cliffhangers internos, payoff satisfatório.\n`;
        systemPrompt += `6. LINGUAGEM E TOM: Voz ativa, frases variadas, naturalidade, vocabulário acessível.\n`;
        systemPrompt += `7. ELEMENTOS ESTRUTURAIS: Duração otimizada, CTA orgânica, final memorável.\n`;
        systemPrompt += `8. LOOPS ABERTOS: Loops abertos sendo fechados no momento certo.\n`;
        systemPrompt += `9. VARIAÇÃO EMOCIONAL: A emoção varia ao longo do roteiro.\n`;
        systemPrompt += `10. FINAL SATISFATÓRIO: Todas as promessas cumpridas, final memorável.\n`;
        systemPrompt += `Avalie cada critério como true/false e calcule a nota baseada na quantidade de critérios atendidos.\n\n`;
        
        // INSTRUÇÃO CRÍTICA: Gerar roteiro completo
        systemPrompt += `# 🎬 INSTRUÇÃO FINAL - CRÍTICA\n\n`;
        systemPrompt += `VOCÊ DEVE:\n`;
        systemPrompt += `1. Seguir RIGOROSAMENTE as INSTRUÇÕES e MEMÓRIA configuradas acima\n`;
        systemPrompt += `2. Gerar um ROTEIRO COMPLETO baseado na mensagem do usuário\n`;
        systemPrompt += `3. O roteiro deve ser detalhado, completo e seguir o formato especificado nas instruções\n`;
        systemPrompt += `4. NÃO pare no meio do roteiro - complete TODA a história até o final\n`;
        systemPrompt += `5. NÃO corte o roteiro - continue até concluir completamente a narrativa\n`;
        systemPrompt += `6. Use a memória para personalizar o roteiro ao contexto do usuário\n`;
        systemPrompt += `7. Após o roteiro completo, adicione a avaliação JSON no final\n`;
        systemPrompt += `8. Se o roteiro for longo, continue escrevendo até o final - NÃO pare antes de concluir\n\n`;
        systemPrompt += `IMPORTANTE: Se as instruções pedirem um formato específico de roteiro, use EXATAMENTE esse formato.\n`;
        systemPrompt += `Se a memória descrever o propósito do agente, mantenha esse propósito ao gerar o roteiro.\n`;
        systemPrompt += `CRÍTICO: Você tem até 16384 tokens disponíveis. Use TODOS se necessário para completar o roteiro.\n`;
        systemPrompt += `NÃO pare no meio - continue até o final completo do roteiro.\n\n`;

        // Verificar preferência do usuário: usar créditos (laozhang.ai) ou APIs próprias
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        console.log('[Viral Agents] Preferência do usuário:', { userId, useCredits, userPrefs });
        
        let useLaozhang = false;
        let laozhangApiKey = null;
        
        // REGRA CRÍTICA: Se preferência marcada, SEMPRE usar Laozhang (créditos)
        if (useCredits) {
            // Buscar chave da laozhang.ai usando a função existente
            const laozhangKey = await getLaozhangApiKey();
            console.log('[Viral Agents] Chave Laozhang encontrada:', laozhangKey ? 'Sim' : 'Não', typeof laozhangKey);
            
            if (laozhangKey) {
                // Normalizar a chave (já vem normalizada da função, mas garantir)
                if (typeof laozhangKey === 'string') {
                    laozhangApiKey = laozhangKey.trim();
                } else if (typeof laozhangKey === 'object' && laozhangKey !== null) {
                    // Se ainda for objeto, extrair api_key
                    laozhangApiKey = (laozhangKey.api_key || laozhangKey.key || JSON.stringify(laozhangKey)).trim();
                } else {
                    laozhangApiKey = String(laozhangKey).trim();
                }
                
                console.log('[Viral Agents] Chave Laozhang normalizada:', laozhangApiKey ? `Sim (${laozhangApiKey.length} chars)` : 'Não');
                
                if (laozhangApiKey && laozhangApiKey.length > 10) {
                    useLaozhang = true;
                    console.log('[Viral Agents] ✅ Usando Laozhang.ai (preferência: usar créditos) com modelo:', modelToUse);
                } else {
                    console.error('[Viral Agents] ❌ Chave Laozhang inválida ou muito curta. Tamanho:', laozhangApiKey?.length || 0);
                    return res.status(500).json({ 
                        msg: 'Chave da API Laozhang.ai não configurada ou inválida. Configure no painel admin.' 
                    });
                }
            } else {
                console.error('[Viral Agents] ❌ Chave Laozhang não encontrada, mesmo com preferência marcada');
                return res.status(500).json({ 
                    msg: 'Chave da API Laozhang.ai não configurada. Configure no painel admin ou desmarque a preferência de usar créditos.' 
                });
            }
        } else {
            console.log('[Viral Agents] Preferência não marcada, verificando se deve usar créditos por falta de API própria...');
            // Mesmo sem preferência marcada, verificar se deve usar créditos (sem API própria)
            const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
            if (creditsCheck.shouldUse && !creditsCheck.hasOwnApi) {
                console.log('[Viral Agents] ✅ Usando créditos (sem API própria configurada)');
                const laozhangKey = await getLaozhangApiKey();
                if (laozhangKey) {
                    laozhangApiKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : String(laozhangKey).trim();
                    if (laozhangApiKey && laozhangApiKey.length > 10) {
                        useLaozhang = true;
                    }
                }
            }
        }
        
        // Se não usar laozhang, determinar qual serviço usar baseado no modelo
        let serviceName = 'claude';
        if (!useLaozhang) {
            if (modelToUse && (modelToUse.includes('gpt') || modelToUse.includes('GPT'))) {
                serviceName = 'openai';
            } else if (modelToUse && modelToUse.includes('gemini')) {
                serviceName = 'gemini';
            }

            // Buscar API key do serviço apropriado
            const apiKeyRow = await db.get(
                'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                [userId, serviceName]
            );

            if (!apiKeyRow || !apiKeyRow.api_key) {
                return res.status(400).json({ msg: `API key do ${serviceName === 'openai' ? 'OpenAI' : serviceName === 'gemini' ? 'Gemini' : 'Claude'} não configurada. Configure nas configurações.` });
            }

            var apiKey = decrypt(apiKeyRow.api_key);
            if (!apiKey) {
                return res.status(500).json({ msg: 'Erro ao descriptografar API key.' });
            }
        }

        // Preparar mensagens
        const messages = [];
        
        // Adicionar histórico de mensagens (apenas user e assistant)
        messageHistory.forEach(msg => {
            if (msg.role === 'user' || msg.role === 'assistant') {
                messages.push({
                    role: msg.role,
                    content: msg.content
                });
            }
        });

        let assistantMessage = '';
        
        // Preparar prompt completo para laozhang (usado tanto em streaming quanto não-streaming)
        // IMPORTANTE: Incluir systemPrompt de forma enfática no início
        let fullPrompt = '';
        if (useLaozhang && laozhangApiKey) {
            // Começar com systemPrompt (memória + instruções) de forma muito clara
            if (systemPrompt && systemPrompt.trim()) {
                fullPrompt = `=== CONFIGURAÇÕES DO AGENTE (SEGUIR RIGOROSAMENTE) ===\n\n${systemPrompt}\n\n=== FIM DAS CONFIGURAÇÕES ===\n\n`;
            } else {
                fullPrompt = 'Você é um assistente útil.\n\n';
            }
            
            // Adicionar histórico de conversa
            if (messages.length > 0) {
                fullPrompt += `=== HISTÓRICO DA CONVERSA ===\n\n`;
                messages.forEach(msg => {
                    fullPrompt += `${msg.role === 'user' ? 'Usuário' : 'Assistente'}: ${msg.content}\n\n`;
                });
                fullPrompt += `=== FIM DO HISTÓRICO ===\n\n`;
            }
            
            // Adicionar mensagem atual com instrução clara
            fullPrompt += `=== MENSAGEM ATUAL DO USUÁRIO ===\n\n`;
            fullPrompt += `Usuário: ${message}\n\n`;
            fullPrompt += `=== SUA RESPOSTA (SEGUINDO AS CONFIGURAÇÕES ACIMA) ===\n\n`;
            fullPrompt += `INSTRUÇÕES PARA SUA RESPOSTA:\n`;
            fullPrompt += `1. Siga RIGOROSAMENTE as CONFIGURAÇÕES DO AGENTE acima (memória e instruções)\n`;
            fullPrompt += `2. Gere um ROTEIRO COMPLETO baseado na mensagem do usuário\n`;
            fullPrompt += `3. O roteiro deve ser detalhado e seguir o formato especificado nas instruções\n`;
            fullPrompt += `4. NÃO pare no meio - complete TODA a história/roteiro até o final\n`;
            fullPrompt += `5. NÃO corte o roteiro - continue escrevendo até concluir completamente\n`;
            fullPrompt += `6. Use a memória para personalizar o roteiro ao contexto\n`;
            fullPrompt += `7. Após o roteiro completo, adicione a avaliação JSON no final\n`;
            fullPrompt += `8. Você tem até 16384 tokens disponíveis - use TODOS se necessário para completar o roteiro\n\n`;
            fullPrompt += `Agora gere sua resposta seguindo essas instruções:\n\n`;
            fullPrompt += `Assistente:`;
            
            console.log('[Viral Agents] 📋 FullPrompt construído, tamanho:', fullPrompt.length);
            console.log('[Viral Agents] 📋 Primeiros 500 chars do fullPrompt:', fullPrompt.substring(0, 500));
        }

        // Se usar laozhang.ai, chamar API laozhang
        if (useLaozhang && laozhangApiKey) {
            console.log('[Viral Agents] 🚀 Iniciando chamada Laozhang.ai com modelo:', modelToUse, 'Stream:', stream);
            
            if (stream) {
                // Streaming com laozhang (usar endpoint direto com streaming)
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                
                try {
                    // Mapear modelo para formato laozhang (manter o mesmo formato)
                    const laozhangModel = modelToUse || 'gpt-4o';
                    console.log('[Viral Agents] 📝 Modelo Laozhang:', laozhangModel);
                    
                    // Preparar mensagens para cálculo de tokens (CRÍTICO: sempre incluir systemPrompt com memória e instruções)
                    const systemContent = systemPrompt && systemPrompt.trim() ? systemPrompt : 'Você é um assistente útil.';
                    console.log('[Viral Agents] 📋 System content incluído no streaming, tamanho:', systemContent.length);
                    const allMessages = [
                        { role: 'system', content: systemContent },
                        ...messages,
                        { role: 'user', content: message }
                    ];
                    
                    // Calcular tokens aproximados (input + output estimado)
                    const promptText = allMessages.map(m => m.content).join('\n');
                    const promptTokens = Math.ceil(promptText.length / 4);
                    // Estimativa para roteiros: baseado no max_tokens configurado (16384)
                    // Usar 80% do max_tokens como estimativa conservadora
                    const estimatedOutputTokens = Math.ceil(16384 * 0.8);
                    const totalTokens = promptTokens + estimatedOutputTokens;
                    
                    console.log('[Viral Agents] 💰 Calculando créditos:', {
                        promptTokens,
                        estimatedOutputTokens,
                        totalTokens
                    });
                    
                    // Debitar créditos ANTES da chamada
                    let creditDebitResult = null;
                    try {
                        const laozhangProviderId = await getLaozhangApiProviderId();
                        if (laozhangProviderId) {
                            creditDebitResult = await checkAndDebitCredits(
                                userId,
                                laozhangProviderId,
                                totalTokens,
                                'viral_agent_chat',
                                JSON.stringify({ agent_id: agentId, conversation_id: conversation_id, model: laozhangModel, stream: true })
                            );
                            console.log(`[Viral Agents] 💰 Créditos debitados: ${creditDebitResult.creditsUsed.toFixed(4)}, Novo saldo: ${creditDebitResult.newBalance.toFixed(4)}`);
                        } else {
                            console.warn('[Viral Agents] ⚠️ Provider Laozhang não encontrado, pulando débito de créditos');
                        }
                    } catch (creditError) {
                        console.error('[Viral Agents] ❌ Erro ao debitar créditos:', creditError.message);
                        // Se não tiver créditos suficientes, lançar erro
                        if (creditError.message.includes('Créditos insuficientes')) {
                            res.write(`data: ${JSON.stringify({ error: creditError.message })}\n\n`);
                            res.end();
                            return;
                        }
                        // Se for outro erro, continuar mas logar
                    }
                    
                    const payload = {
                        model: laozhangModel,
                        messages: allMessages,
                        temperature: 0.7,
                        max_tokens: 16384, // Aumentado para permitir roteiros mais longos
                        stream: true
                    };
                    
                    console.log('[Viral Agents] 📤 Enviando requisição para Laozhang.ai:', {
                        endpoint: LAOZHANG_CHAT_ENDPOINT,
                        model: laozhangModel,
                        messages_count: payload.messages.length,
                        system_prompt_length: systemPrompt?.length || 0
                    });
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 300000);
                    
                    const response = await fetch(LAOZHANG_CHAT_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${laozhangApiKey}`,
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });
                    
                    console.log('[Viral Agents] 📥 Resposta Laozhang:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        const error = await response.json().catch(() => ({ error: { message: 'Erro desconhecido' } }));
                        console.error('[Viral Agents] ❌ Erro Laozhang:', error);
                        res.write(`data: ${JSON.stringify({ error: error.error?.message || error.message || 'Erro ao processar mensagem' })}\n\n`);
                        res.end();
                        return;
                    }
                    
                    console.log('[Viral Agents] ✅ Resposta OK, iniciando leitura do stream...');
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let fullMessage = '';
                    let streamEnded = false;
                    
                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) {
                                streamEnded = true;
                                break;
                            }
                            
                            const chunk = decoder.decode(value, { stream: true });
                            const lines = chunk.split('\n');
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6).trim();
                                    if (!data || data === '[DONE]') {
                                        streamEnded = true;
                                        break;
                                    }
                                    
                                    try {
                                        const parsed = JSON.parse(data);
                                        if (parsed.choices?.[0]?.delta?.content) {
                                            const text = parsed.choices[0].delta.content;
                                            fullMessage += text;
                                            res.write(`data: ${JSON.stringify({ text: text })}\n\n`);
                                        } else if (parsed.choices?.[0]?.message?.content) {
                                            // Algumas APIs retornam conteúdo completo
                                            fullMessage += parsed.choices[0].message.content;
                                            res.write(`data: ${JSON.stringify({ text: parsed.choices[0].message.content })}\n\n`);
                                        }
                                    } catch (e) {
                                        // Ignorar erros de parsing de linhas inválidas
                                        console.warn('[Viral Agents] Erro ao parsear linha:', e.message);
                                    }
                                }
                            }
                            
                            if (streamEnded) break;
                        }
                    } catch (streamError) {
                        console.error('[Viral Agents] Erro durante leitura do stream:', streamError);
                        // Continuar para finalizar mesmo com erro
                    }
                    
                    // Garantir que sempre finalize o stream e salve a mensagem
                    clearTimeout(timeoutId);
                    
                    try {
                        // Extrair nota e checklist
                        let nota = null;
                        let checklist = null;
                        let roteiroFinal = fullMessage.trim();
                        
                        if (roteiroFinal) {
                            const jsonMatch = roteiroFinal.match(/\{[\s\S]*"nota"[\s\S]*\}/);
                            if (jsonMatch) {
                                try {
                                    const avaliacao = JSON.parse(jsonMatch[0]);
                                    nota = avaliacao.nota;
                                    checklist = avaliacao.checklist || null;
                                    roteiroFinal = roteiroFinal.replace(/\{[\s\S]*"nota"[\s\S]*\}/, '').trim();
                                } catch (e) {
                                    const notaMatch = roteiroFinal.match(/nota[:\s]*(\d+)\/10/i);
                                    if (notaMatch) {
                                        nota = parseInt(notaMatch[1]);
                                        roteiroFinal = roteiroFinal.replace(/nota[:\s]*\d+\/10[\s\S]*/i, '').trim();
                                    }
                                }
                            }
                            
                            // Salvar mensagem no banco (CRÍTICO: sempre salvar)
                            await db.run(
                                `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                 VALUES (?, ?, ?)`,
                                [conversation_id, 'assistant', roteiroFinal]
                            );
                            console.log('[Viral Agents] ✅ Mensagem salva no banco, tamanho:', roteiroFinal.length);
                            
                            // Atualizar título da conversa
                            const conversationTitle = await db.get(
                                `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                                [conversation_id]
                            );
                            
                            if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                                const firstPhrase = message.substring(0, 50).trim();
                                const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                                await db.run(
                                    `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                    [title, conversation_id]
                                );
                            } else {
                                await db.run(
                                    `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                    [conversation_id]
                                );
                            }
                            
                            // Enviar evento de finalização (CRÍTICO: sempre enviar)
                            res.write(`data: ${JSON.stringify({ done: true, nota: nota, checklist: checklist })}\n\n`);
                            console.log('[Viral Agents] ✅ Evento done:true enviado');
                        } else {
                            // Se não houver mensagem, ainda assim enviar done
                            console.warn('[Viral Agents] ⚠️ Mensagem vazia, enviando done mesmo assim');
                            res.write(`data: ${JSON.stringify({ done: true, nota: null, checklist: null })}\n\n`);
                        }
                    } catch (saveError) {
                        console.error('[Viral Agents] ❌ Erro ao salvar mensagem:', saveError);
                        // Mesmo com erro ao salvar, enviar done para o frontend
                        res.write(`data: ${JSON.stringify({ done: true, error: 'Erro ao salvar mensagem', nota: null, checklist: null })}\n\n`);
                    }
                    
                    // Sempre finalizar a resposta
                    res.end();
                    console.log('[Viral Agents] ✅ Stream finalizado');
                    return;
                } catch (err) {
                    console.error('[La Casa Dark Core Streaming] Erro:', err);
                    clearTimeout(timeoutId);
                    try {
                        // Tentar salvar mensagem parcial se houver
                        if (fullMessage && fullMessage.trim()) {
                            await db.run(
                                `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                 VALUES (?, ?, ?)`,
                                [conversation_id, 'assistant', fullMessage.trim()]
                            );
                        }
                        // Sempre enviar evento de erro ou finalização
                        res.write(`data: ${JSON.stringify({ done: true, error: err.message || 'Erro no streaming', nota: null, checklist: null })}\n\n`);
                    } catch (finalError) {
                        console.error('[Viral Agents] Erro ao finalizar stream:', finalError);
                        res.write(`data: ${JSON.stringify({ done: true, error: 'Erro crítico no streaming' })}\n\n`);
                    }
                    res.end();
                }
                return;
            } else {
                // Modo não-streaming com laozhang
                try {
                    const laozhangModel = modelToUse || 'gpt-4o';
                    console.log('[Viral Agents] 📝 Modo não-streaming Laozhang com modelo:', laozhangModel);
                    console.log('[Viral Agents] 📤 Chamando callLaozhangAPI...');
                    console.log('[Viral Agents] 📋 FullPrompt tamanho:', fullPrompt?.length || 0, 'SystemPrompt incluído:', systemPrompt ? 'Sim' : 'Não');
                    
                    // Garantir que fullPrompt está construído corretamente com systemPrompt enfático
                    if (!fullPrompt || fullPrompt.trim().length === 0) {
                        console.warn('[Viral Agents] ⚠️ FullPrompt vazio, reconstruindo com systemPrompt...');
                        // Reconstruir com formatação enfática
                        if (systemPrompt && systemPrompt.trim()) {
                            fullPrompt = `=== CONFIGURAÇÕES DO AGENTE (SEGUIR RIGOROSAMENTE) ===\n\n${systemPrompt}\n\n=== FIM DAS CONFIGURAÇÕES ===\n\n`;
                        } else {
                            fullPrompt = 'Você é um assistente útil.\n\n';
                        }
                        
                        // Adicionar histórico
                        if (messages.length > 0) {
                            fullPrompt += `=== HISTÓRICO DA CONVERSA ===\n\n`;
                            messages.forEach(msg => {
                                fullPrompt += `${msg.role === 'user' ? 'Usuário' : 'Assistente'}: ${msg.content}\n\n`;
                            });
                            fullPrompt += `=== FIM DO HISTÓRICO ===\n\n`;
                        }
                        
                        // Adicionar mensagem atual
                        fullPrompt += `=== MENSAGEM ATUAL DO USUÁRIO ===\n\n`;
                        fullPrompt += `Usuário: ${message}\n\n`;
                        fullPrompt += `=== SUA RESPOSTA (SEGUINDO AS CONFIGURAÇÕES ACIMA) ===\n\n`;
                        fullPrompt += `Assistente:`;
                    }
                    
                    // Adicionar marcador para callLaozhangAPI detectar como roteiro
                    const promptWithMarker = fullPrompt + '\n\nIMPORTANTE: Gere o roteiro completo em TEXTO SIMPLES, sem usar JSON ou formatações especiais.';
                    console.log('[Viral Agents] 📝 Prompt final tamanho:', promptWithMarker.length);
                    console.log('[Viral Agents] 💰 Chamando callLaozhangAPI com userId:', userId ? 'Sim' : 'Não');
                    assistantMessage = await callLaozhangAPI(promptWithMarker, laozhangApiKey, laozhangModel, null, userId, 'viral_agent_chat', JSON.stringify({ agent_id: agentId, conversation_id: conversation_id, model: laozhangModel }));
                    console.log('[Viral Agents] ✅ Resposta recebida, tamanho:', assistantMessage?.length || 0);
                    
                    // Extrair nota e checklist do JSON (se houver) - modo não-streaming laozhang
                    let nota = null;
                    let checklist = null;
                    let roteiroFinal = assistantMessage;
                    
                    const jsonMatch = assistantMessage.match(/\{[\s\S]*"nota"[\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            const avaliacao = JSON.parse(jsonMatch[0]);
                            nota = avaliacao.nota;
                            checklist = avaliacao.checklist || null;
                            roteiroFinal = assistantMessage.replace(/\{[\s\S]*"nota"[\s\S]*\}/, '').trim();
                        } catch (e) {
                            const notaMatch = assistantMessage.match(/nota[:\s]*(\d+)\/10/i);
                            if (notaMatch) {
                                nota = parseInt(notaMatch[1]);
                                roteiroFinal = assistantMessage.replace(/nota[:\s]*\d+\/10[\s\S]*/i, '').trim();
                            }
                        }
                    }
                    
                    // Salvar roteiro completo (sem a nota)
                    await db.run(
                        `INSERT INTO viral_agent_messages (conversation_id, role, content)
                         VALUES (?, ?, ?)`,
                        [conversation_id, 'assistant', roteiroFinal]
                    );
                    
                    const conversationTitle = await db.get(
                        `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                        [conversation_id]
                    );
                    
                    if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                        const firstPhrase = message.substring(0, 50).trim();
                        const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                        await db.run(
                            `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                            [title, conversation_id]
                        );
                    } else {
                        await db.run(
                            `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                            [conversation_id]
                        );
                    }
                    
                    return res.status(200).json({ response: roteiroFinal, nota: nota, checklist: checklist });
                } catch (err) {
                    console.error('[La Casa Dark Core API] Erro:', err);
                    return res.status(500).json({ msg: err.message || 'Erro ao processar mensagem.' });
                }
            }
        } else if (serviceName === 'claude') {
            // API do Claude
            const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';
            
            // Mapear modelo se necessário
            const modelAliases = {
                'claude-3-5-sonnet-20241022': 'claude-3-7-sonnet-20250219',
                'claude-3-5-sonnet-20240620': 'claude-3-7-sonnet-20250219',
                'claude-3-5-sonnet-latest': 'claude-3-7-sonnet-20250219',
                'claude-3-sonnet-20240229': 'claude-3-7-sonnet-20250219',
                'claude-3.5-sonnet-20241022': 'claude-3-7-sonnet-20250219',
                'claude-3.5-sonnet-20240620': 'claude-3-7-sonnet-20250219',
                'claude-3-haiku-20240307': 'claude-3-7-sonnet-20250219',
                'claude-3.5-haiku-20241022': 'claude-3-7-sonnet-20250219',
                'claude-3-5-haiku-20241022': 'claude-3-7-sonnet-20250219',
                'claude-3-5-haiku-latest': 'claude-3-7-sonnet-20250219',
                'claude-3-opus-20240229': 'claude-opus-4-20250514'
            };
            
            let modelName = modelAliases[modelToUse] || modelToUse;
            const supportedModels = new Set([
                'claude-3-7-sonnet-20250219',
                'claude-sonnet-4-20250514',
                'claude-opus-4-20250514'
            ]);
            
            if (!supportedModels.has(modelName)) {
                if (modelToUse && modelToUse.toLowerCase().includes('opus')) {
                    modelName = 'claude-opus-4-20250514';
                } else if (modelToUse && (modelToUse.toLowerCase().includes('sonnet') || modelToUse.toLowerCase().includes('4'))) {
                    modelName = 'claude-sonnet-4-20250514';
                } else {
                    modelName = 'claude-3-7-sonnet-20250219';
                }
            }
            
            // Preparar mensagens com system prompt
            const claudeMessages = [...messages];
            
            const payload = {
                model: modelName,
                max_tokens: 16384, // Aumentado para permitir roteiros mais longos e completos
                messages: claudeMessages,
                stream: stream // Habilitar streaming
            };
            
            // Adicionar system prompt se houver (CRÍTICO: sempre incluir memória e instruções)
            // Claude usa o campo 'system' que tem alta prioridade e deve seguir rigorosamente
            if (systemPrompt && systemPrompt.trim()) {
                payload.system = systemPrompt;
                console.log('[Viral Agents] ✅ System prompt incluído no payload Claude (memória + instruções), tamanho:', systemPrompt.length);
                console.log('[Viral Agents] 📋 Primeiros 500 chars do system prompt:', systemPrompt.substring(0, 500));
            } else {
                console.warn('[Viral Agents] ⚠️ System prompt vazio ou não definido - Claude pode não seguir instruções!');
            }

            if (stream) {
                // Configurar SSE para streaming
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000); // 5 minutos para roteiros longos

                try {
                    const response = await fetch(CLAUDE_API_URL, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        res.write(`data: ${JSON.stringify({ error: error.error?.message || 'Erro ao processar mensagem' })}\n\n`);
                        res.end();
                        return;
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let fullMessage = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                    if (data === '[DONE]') {
                                        clearTimeout(timeoutId);
                                        
                                        // Extrair nota e checklist do JSON (se houver)
                                        let nota = null;
                                        let checklist = null;
                                        let roteiroFinal = fullMessage;
                                        
                                        // Tentar encontrar JSON no final da mensagem
                                        const jsonMatch = fullMessage.match(/\{[\s\S]*"nota"[\s\S]*\}/);
                                        if (jsonMatch) {
                                            try {
                                                const avaliacao = JSON.parse(jsonMatch[0]);
                                                nota = avaliacao.nota;
                                                checklist = avaliacao.checklist || null;
                                                // Remover JSON do roteiro
                                                roteiroFinal = fullMessage.replace(/\{[\s\S]*"nota"[\s\S]*\}/, '').trim();
                                            } catch (e) {
                                                // Se não conseguir parsear, tentar extrair nota manualmente
                                                const notaMatch = fullMessage.match(/nota[:\s]*(\d+)\/10/i);
                                                if (notaMatch) {
                                                    nota = parseInt(notaMatch[1]);
                                                    roteiroFinal = fullMessage.replace(/nota[:\s]*\d+\/10[\s\S]*/i, '').trim();
                                                }
                                            }
                                        }
                                        
                                        // Salvar roteiro completo (sem a nota)
                                        await db.run(
                                            `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                             VALUES (?, ?, ?)`,
                                            [conversation_id, 'assistant', roteiroFinal]
                                        );
                                        
                                        // Atualizar título da conversa
                                        const conversationTitle = await db.get(
                                            `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                                            [conversation_id]
                                        );
                                        
                                        if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                                            const firstPhrase = message.substring(0, 50).trim();
                                            const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                                            await db.run(
                                                `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                                [title, conversation_id]
                                            );
                                        } else {
                                            await db.run(
                                                `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                                [conversation_id]
                                            );
                                        }
                                        
                                        res.write(`data: ${JSON.stringify({ done: true, nota: nota, checklist: checklist })}\n\n`);
                                        res.end();
                                        return;
                                    }

                                try {
                                    const parsed = JSON.parse(data);
                                    if (parsed.type === 'content_block_delta' && parsed.delta?.text) {
                                        const text = parsed.delta.text;
                                        fullMessage += text;
                                        res.write(`data: ${JSON.stringify({ text: text })}\n\n`);
                                    }
                                } catch (e) {
                                    // Ignorar linhas inválidas
                                }
                            }
                        }
                        
                        // Se o loop terminou sem receber [DONE], finalizar manualmente
                        if (fullMessage.trim()) {
                            clearTimeout(timeoutId);
                            
                            // Extrair nota e checklist
                            let nota = null;
                            let checklist = null;
                            let roteiroFinal = fullMessage.trim();
                            
                            const jsonMatch = roteiroFinal.match(/\{[\s\S]*"nota"[\s\S]*\}/);
                            if (jsonMatch) {
                                try {
                                    const avaliacao = JSON.parse(jsonMatch[0]);
                                    nota = avaliacao.nota;
                                    checklist = avaliacao.checklist || null;
                                    roteiroFinal = roteiroFinal.replace(/\{[\s\S]*"nota"[\s\S]*\}/, '').trim();
                                } catch (e) {
                                    const notaMatch = roteiroFinal.match(/nota[:\s]*(\d+)\/10/i);
                                    if (notaMatch) {
                                        nota = parseInt(notaMatch[1]);
                                        roteiroFinal = roteiroFinal.replace(/nota[:\s]*\d+\/10[\s\S]*/i, '').trim();
                                    }
                                }
                            }
                            
                            // Salvar mensagem
                            await db.run(
                                `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                 VALUES (?, ?, ?)`,
                                [conversation_id, 'assistant', roteiroFinal]
                            );
                            
                            // Atualizar conversa
                            const conversationTitle = await db.get(
                                `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                                [conversation_id]
                            );
                            
                            if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                                const firstPhrase = message.substring(0, 50).trim();
                                const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                                await db.run(
                                    `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                    [title, conversation_id]
                                );
                            } else {
                                await db.run(
                                    `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                    [conversation_id]
                                );
                            }
                            
                            res.write(`data: ${JSON.stringify({ done: true, nota: nota, checklist: checklist })}\n\n`);
                            res.end();
                            return;
                        }
                    }
                } catch (err) {
                    clearTimeout(timeoutId);
                    console.error('[Claude Streaming] Erro:', err);
                    try {
                        // Tentar salvar mensagem parcial
                        if (fullMessage && fullMessage.trim()) {
                            await db.run(
                                `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                 VALUES (?, ?, ?)`,
                                [conversation_id, 'assistant', fullMessage.trim()]
                            );
                        }
                        res.write(`data: ${JSON.stringify({ done: true, error: err.message || 'Erro no streaming', nota: null, checklist: null })}\n\n`);
                    } catch (finalError) {
                        res.write(`data: ${JSON.stringify({ done: true, error: 'Erro crítico no streaming' })}\n\n`);
                    }
                    res.end();
                }
                return;
            } else {
                // Modo não-streaming (fallback)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000);

                const response = await fetch(CLAUDE_API_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify(payload),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (!response.ok) {
                    console.error('[Claude API] Erro:', result);
                    return res.status(response.status).json({ 
                        msg: result.error?.message || 'Erro ao processar mensagem com Claude.',
                        error: result.error 
                    });
                }

                assistantMessage = result.content[0].text;
            }
            
        } else if (serviceName === 'openai') {
            // API do OpenAI
            const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
            
            const openaiMessages = [];
            if (systemPrompt) {
                openaiMessages.push({
                    role: 'system',
                    content: systemPrompt
                });
            }
            openaiMessages.push(...messages);
            
            const payload = {
                model: modelToUse || 'gpt-4o',
                messages: openaiMessages,
                max_tokens: 16384, // Aumentado para permitir roteiros mais longos e completos
                temperature: 0.7,
                stream: stream
            };
            
            if (stream) {
                // Streaming para OpenAI
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000);

                try {
                    const response = await fetch(OPENAI_API_URL, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        res.write(`data: ${JSON.stringify({ error: error.error?.message || 'Erro ao processar mensagem' })}\n\n`);
                        res.end();
                        return;
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let fullMessage = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') {
                                    clearTimeout(timeoutId);
                                    
                                    // Extrair nota e pontos fortes do JSON (se houver)
                                    let nota = null;
                                    let pontosFortes = [];
                                    let roteiroFinal = fullMessage;
                                    
                                    // Tentar encontrar JSON no final da mensagem
                                    const jsonMatch = fullMessage.match(/\{[\s\S]*"nota"[\s\S]*\}/);
                                    if (jsonMatch) {
                                        try {
                                            const avaliacao = JSON.parse(jsonMatch[0]);
                                            nota = avaliacao.nota;
                                                checklist = avaliacao.checklist || null;
                                            // Remover JSON do roteiro
                                            roteiroFinal = fullMessage.replace(/\{[\s\S]*"nota"[\s\S]*\}/, '').trim();
                                        } catch (e) {
                                            // Se não conseguir parsear, tentar extrair nota manualmente
                                            const notaMatch = fullMessage.match(/nota[:\s]*(\d+)\/10/i);
                                            if (notaMatch) {
                                                nota = parseInt(notaMatch[1]);
                                                roteiroFinal = fullMessage.replace(/nota[:\s]*\d+\/10[\s\S]*/i, '').trim();
                                            }
                                        }
                                    }
                                    
                                    // Salvar roteiro completo (sem a nota)
                                    await db.run(
                                        `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                         VALUES (?, ?, ?)`,
                                        [conversation_id, 'assistant', roteiroFinal]
                                    );
                                    
                                    const conversationTitle = await db.get(
                                        `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                                        [conversation_id]
                                    );
                                    
                                    if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                                        const firstPhrase = message.substring(0, 50).trim();
                                        const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                                        await db.run(
                                            `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                            [title, conversation_id]
                                        );
                                    } else {
                                        await db.run(
                                            `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                            [conversation_id]
                                        );
                                    }
                                    
                                    res.write(`data: ${JSON.stringify({ done: true, nota: nota, checklist: checklist })}\n\n`);
                                    res.end();
                                    return;
                                }

                                try {
                                    const parsed = JSON.parse(data);
                                    if (parsed.choices?.[0]?.delta?.content) {
                                        const text = parsed.choices[0].delta.content;
                                        fullMessage += text;
                                        res.write(`data: ${JSON.stringify({ text: text })}\n\n`);
                                    }
                                } catch (e) {
                                    // Ignorar linhas inválidas
                                }
                            }
                        }
                    }
                } catch (err) {
                    clearTimeout(timeoutId);
                    console.error('[La Casa Dark Core Streaming] Erro:', err);
                    res.write(`data: ${JSON.stringify({ error: err.message || 'Erro no streaming' })}\n\n`);
                    res.end();
                }
                return;
            } else {
                // Modo não-streaming (fallback)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000);

                const response = await fetch(OPENAI_API_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(payload),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (!response.ok) {
                    console.error('[La Casa Dark Core API] Erro:', result);
                    return res.status(response.status).json({ 
                        msg: result.error?.message || 'Erro ao processar mensagem com OpenAI.',
                        error: result.error 
                    });
                }

                assistantMessage = result.choices[0].message.content;
            }
            
        } else if (serviceName === 'gemini') {
            // API do Gemini usando @google/genai
            const { GoogleGenAI } = require('@google/genai');
            const genAI = new GoogleGenAI(apiKey);
            
            // Preparar prompt completo com system prompt, histórico e mensagem atual
            let fullPrompt = '';
            if (systemPrompt) {
                fullPrompt += systemPrompt + '\n\n';
            }
            
            // Adicionar histórico
            messages.forEach(msg => {
                fullPrompt += `${msg.role === 'user' ? 'Usuário' : 'Assistente'}: ${msg.content}\n\n`;
            });
            
            // Adicionar mensagem atual
            fullPrompt += `Usuário: ${message}\nAssistente:`;

            const model = genAI.getGenerativeModel({ model: modelToUse || 'gemini-2.5-pro' });
            const result = await model.generateContent(fullPrompt);
            assistantMessage = result.response.text();
        }

        // Extrair nota e pontos fortes do JSON (se houver) - modo não-streaming
        let nota = null;
        let pontosFortes = [];
        let roteiroFinal = assistantMessage;
        
        // Tentar encontrar JSON no final da mensagem
        const jsonMatch = assistantMessage.match(/\{[\s\S]*"nota"[\s\S]*\}/);
        if (jsonMatch) {
            try {
                const avaliacao = JSON.parse(jsonMatch[0]);
                nota = avaliacao.nota;
                                                checklist = avaliacao.checklist || null;
                // Remover JSON do roteiro
                roteiroFinal = assistantMessage.replace(/\{[\s\S]*"nota"[\s\S]*\}/, '').trim();
            } catch (e) {
                // Se não conseguir parsear, tentar extrair nota manualmente
                const notaMatch = assistantMessage.match(/nota[:\s]*(\d+)\/10/i);
                if (notaMatch) {
                    nota = parseInt(notaMatch[1]);
                    roteiroFinal = assistantMessage.replace(/nota[:\s]*\d+\/10[\s\S]*/i, '').trim();
                }
            }
        }
        
        // Salvar roteiro completo (sem a nota)
        await db.run(
            `INSERT INTO viral_agent_messages (conversation_id, role, content)
             VALUES (?, ?, ?)`,
            [conversation_id, 'assistant', roteiroFinal]
        );

        // Atualizar título da conversa com primeira frase da mensagem do usuário (se ainda for "Nova Conversa")
        const conversationTitle = await db.get(
            `SELECT title FROM viral_agent_conversations WHERE id = ?`,
            [conversation_id]
        );
        
        if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
            // Pegar primeira frase da mensagem do usuário (primeiros 50 caracteres)
            const firstPhrase = message.substring(0, 50).trim();
            const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
            
            await db.run(
                `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                [title, conversation_id]
            );
        } else {
            // Apenas atualizar timestamp
            await db.run(
                `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                [conversation_id]
            );
        }

        res.status(200).json({ response: roteiroFinal, nota: nota, checklist: checklist });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/chat POST]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao processar mensagem.' });
    }
});

// Rota para obter mensagens de uma conversa
app.get('/api/viral-agents/:agentId/conversations/:conversationId/messages', authenticateToken, async (req, res) => {
    const { agentId, conversationId } = req.params;
    const userId = req.user.id;

    try {
        // Verificar se a conversa pertence ao usuário e ao agente
        const conversation = await db.get(
            `SELECT * FROM viral_agent_conversations 
             WHERE id = ? AND agent_id = ? AND user_id = ?`,
            [conversationId, agentId, userId]
        );

        if (!conversation) {
            return res.status(404).json({ msg: 'Conversa não encontrada.' });
        }

        const messages = await db.all(
            `SELECT * FROM viral_agent_messages 
             WHERE conversation_id = ? 
             ORDER BY created_at ASC`,
            [conversationId]
        );

        res.status(200).json({ messages });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/conversations/:conversationId/messages GET]:', err);
        res.status(500).json({ msg: 'Erro ao obter mensagens.' });
    }
});

// Rota para deletar uma conversa
app.delete('/api/viral-agents/:agentId/conversations/:conversationId', authenticateToken, async (req, res) => {
    const { agentId, conversationId } = req.params;
    const userId = req.user.id;

    try {
        const result = await db.run(
            `DELETE FROM viral_agent_conversations 
             WHERE id = ? AND agent_id = ? AND user_id = ?`,
            [conversationId, agentId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Conversa não encontrada.' });
        }

        res.status(200).json({ msg: 'Conversa deletada com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/conversations/:conversationId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao deletar conversa.' });
    }
});

// Rota para gerar documento MD de uma conversa
app.get('/api/viral-agents/:agentId/conversations/:conversationId/markdown', authenticateToken, async (req, res) => {
    const { agentId, conversationId } = req.params;
    const userId = req.user.id;

    try {
        // Verificar se o agente pertence ao usuário
        const agent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente não encontrado.' });
        }

        // Verificar se a conversa pertence ao usuário e ao agente
        const conversation = await db.get(
            `SELECT * FROM viral_agent_conversations 
             WHERE id = ? AND agent_id = ? AND user_id = ?`,
            [conversationId, agentId, userId]
        );

        if (!conversation) {
            return res.status(404).json({ msg: 'Conversa não encontrada.' });
        }

        // Buscar todas as mensagens da conversa
        const messages = await db.all(
            `SELECT role, content, created_at FROM viral_agent_messages 
             WHERE conversation_id = ? 
             ORDER BY created_at ASC`,
            [conversationId]
        );

        // Gerar conteúdo Markdown
        let mdContent = `# ${conversation.title || 'Conversa'}\n\n`;
        mdContent += `**Agente:** ${agent.name}\n`;
        mdContent += `**Data:** ${new Date(conversation.created_at).toLocaleString('pt-BR')}\n\n`;
        mdContent += `---\n\n`;

        messages.forEach(msg => {
            const roleLabel = msg.role === 'user' ? '**Usuário:**' : '**Assistente:**';
            const timestamp = new Date(msg.created_at).toLocaleString('pt-BR');
            mdContent += `${roleLabel} (${timestamp})\n\n`;
            mdContent += `${msg.content}\n\n`;
            mdContent += `---\n\n`;
        });

        // Retornar como HTML para abrir em nova aba
        const htmlContent = `<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${conversation.title || 'Conversa'} - ${agent.name}</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        pre {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #3a3a3a;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        code {
            background: #2a2a2a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        h1 { color: #f59e0b; border-bottom: 2px solid #f59e0b; padding-bottom: 10px; }
        h2 { color: #fbbf24; margin-top: 30px; }
        hr { border: none; border-top: 1px solid #3a3a3a; margin: 20px 0; }
        .copy-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 1000;
        }
        .copy-btn:hover { background: #d97706; }
    </style>
</head>
<body>
    <button class="copy-btn" onclick="copyAll()">Copiar Tudo</button>
    <pre id="content">${mdContent.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
    <script>
        function copyAll() {
            const content = document.getElementById('content').textContent;
            navigator.clipboard.writeText(content).then(() => {
                alert('Conteúdo copiado!');
            });
        }
    </script>
</body>
</html>`;

        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.send(htmlContent);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/conversations/:conversationId/markdown GET]:', err);
        res.status(500).json({ msg: 'Erro ao gerar documento.' });
    }
});

// ==================== FIM DAS ROTAS PARA AGENTES VIRAIS ====================

// Rota para download de roteiro em formato TXT
app.get('/api/scripts/:id/download/txt', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scriptId = req.params.id;

    try {
        const script = await db.get(
            `SELECT * FROM generated_scripts WHERE id = ? AND user_id = ?`,
            [scriptId, userId]
        );

        if (!script) {
            return res.status(404).json({ msg: 'Roteiro não encontrado.' });
        }

        // Criar conteúdo TXT com cabeçalho
        let txtContent = `TÍTULO: ${script.title}\n`;
        txtContent += `DATA: ${new Date(script.created_at).toLocaleString('pt-BR')}\n`;
        txtContent += `MODELO: ${script.model_used || 'N/A'}\n`;
        if (script.niche) txtContent += `NICHO: ${script.niche}\n`;
        if (script.subniche) txtContent += `SUBNICHO: ${script.subniche}\n`;
        if (script.optimization_score) {
            txtContent += `\nANÁLISE DE OTIMIZAÇÃO:\n`;
            txtContent += `Score Geral: ${script.optimization_score}/10\n`;
            txtContent += `Retenção: ${script.retention_score}/10\n`;
            txtContent += `Autenticidade: ${script.authenticity_score}/10\n`;
        }
        txtContent += `\n${'='.repeat(60)}\n\nROTEIRO:\n\n`;
        txtContent += script.script_content;
        
        if (script.optimization_report) {
            txtContent += `\n\n${'='.repeat(60)}\n\n`;
            txtContent += script.optimization_report;
        }

        // Definir headers para download
        const filename = `roteiro_${script.id}_${script.title.replace(/[^a-z0-9]/gi, '_').substring(0, 50)}.txt`;
        res.setHeader('Content-Type', 'text/plain; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        res.send(txtContent);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts/:id/download/txt]:', err);
        res.status(500).json({ msg: 'Erro ao fazer download do roteiro.' });
    }
});

// Rota para download de roteiro em formato SRT (legendas)
app.get('/api/scripts/:id/download/srt', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scriptId = req.params.id;

    try {
        const script = await db.get(
            `SELECT * FROM generated_scripts WHERE id = ? AND user_id = ?`,
            [scriptId, userId]
        );

        if (!script) {
            return res.status(404).json({ msg: 'Roteiro não encontrado.' });
        }

        // Converter roteiro em formato SRT
        // Estimativa: 150 palavras por minuto, 3-5 palavras por legenda
        const scriptText = script.script_content;
        const sentences = scriptText.split(/[.!?]\s+/).filter(s => s.trim().length > 0);
        
        let srtContent = '';
        let counter = 1;
        let currentTime = 0; // em segundos
        
        for (const sentence of sentences) {
            const words = sentence.trim().split(/\s+/);
            const wordsPerSubtitle = 8; // Máximo de palavras por legenda
            
            // Dividir sentença em partes menores se necessário
            for (let i = 0; i < words.length; i += wordsPerSubtitle) {
                const chunk = words.slice(i, i + wordsPerSubtitle).join(' ');
                const chunkWords = chunk.split(/\s+/).length;
                const duration = (chunkWords / 150) * 60; // 150 palavras por minuto
                
                // Formatar timestamps
                const startTime = formatSRTTime(currentTime);
                const endTime = formatSRTTime(currentTime + duration);
                
                srtContent += `${counter}\n`;
                srtContent += `${startTime} --> ${endTime}\n`;
                srtContent += `${chunk}\n\n`;
                
                counter++;
                currentTime += duration;
            }
        }

        // Definir headers para download
        const filename = `roteiro_${script.id}_${script.title.replace(/[^a-z0-9]/gi, '_').substring(0, 50)}.srt`;
        res.setHeader('Content-Type', 'text/plain; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        res.send(srtContent);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts/:id/download/srt]:', err);
        res.status(500).json({ msg: 'Erro ao fazer download do roteiro em SRT.' });
    }
});

// Função auxiliar para formatar tempo no formato SRT (HH:MM:SS,mmm)
function formatSRTTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const millis = Math.floor((seconds % 1) * 1000);
    
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')},${String(millis).padStart(3, '0')}`;
}


// === ROTAS DE EXPLORAÇÃO DE NICHO ===

app.post('/api/niche/find-subniche', authenticateToken, async (req, res) => {
    const { nichePrincipal, ideiaInicial, model } = req.body;
    const userId = req.user.id;

    if (!nichePrincipal || !ideiaInicial || !model) {
        return res.status(400).json({ msg: 'Todos os campos são obrigatórios.' });
    }

    try {
        const prompt = `
            Você é um ESPECIALISTA EM CRIAÇÃO DE CANAIS MILIONÁRIOS NO YOUTUBE com experiência em identificar oportunidades de subnichos com alto potencial de viralização.
            
            OBJETIVO: Encontrar um subnicho dentro de "${nichePrincipal}" que permita criar um canal MILIONÁRIO com MILHÕES DE VIEWS, ALTO CTR e conteúdo que VIRALIZE.
            
            PROMPT INICIAL PARA EDUCAR O GPT:
            Quero criar um canal no YouTube dentro do nicho de "${nichePrincipal}", inicialmente pensei em abordar "${ideiaInicial}", mas percebi que já há bastante concorrência nesse subnicho. 
            
            Estou em busca de uma ideia de subnicho dentro de "${nichePrincipal}" que:
            - Ainda esteja pouco explorada no YouTube, com pouca ou nenhuma concorrência
            - Tenha alto volume de buscas e interesse crescente
            - Tenha bom potencial de monetização
            - TENHA ALTO POTENCIAL DE VIRALIZAÇÃO e capacidade de gerar milhões de views
            - Permita criar conteúdo com alto CTR (acima de 25%)
            - Tenha oportunidades de criar títulos e thumbnails virais
            
            O objetivo é encontrar uma oportunidade única para criar conteúdo relevante, com forte demanda, baixa competição, e POTENCIAL PARA CRIAR UM CANAL MILIONÁRIO com milhões de views e alto CTR.
            
            Com base em dados atuais e tendências, o que você recomenda? Forneça uma análise detalhada que inclua:
            - O subnicho recomendado e por que ele tem potencial para gerar milhões de views
            - Análise de concorrência e oportunidades
            - Potencial de viralização e alto CTR
            - Estratégias para criar conteúdo que viralize
            - Sugestões de títulos e thumbnails que gerem alto CTR
        `;

        let service;
        if (model.startsWith('gemini')) service = 'gemini';
        else if (model.startsWith('claude')) service = 'claude';
        else if (model.startsWith('gpt')) service = 'openai';
        else return res.status(400).json({ msg: 'Modelo de IA inválido.' });

        const userKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
        if (!userKeyData) return res.status(400).json({ msg: `Nenhuma Chave de API do ${service} configurada.` });
        
        const decryptedKey = decrypt(userKeyData.api_key);
        if (!decryptedKey) return res.status(500).json({ msg: 'Falha ao desencriptar a sua chave de API.' });

        let apiCallFunction;
        if (service === 'gemini') apiCallFunction = callGeminiAPI;
        else if (service === 'claude') apiCallFunction = callClaudeAPI;
        else apiCallFunction = callOpenAIAPI;

        const response = await apiCallFunction(prompt, decryptedKey, model);
        const recommendation = parseAIResponse(response.titles, service);

        res.status(200).json({ recommendation: recommendation.text || recommendation });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/niche/find-subniche]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});

// === ROTA LAOZHANG PARA ENCONTRAR SUBNICHOS ===
app.post('/api/niche/find-subniche/laozhang', authenticateToken, async (req, res) => {
    const { nichePrincipal, ideiaInicial, selectedModel } = req.body;
    const userId = req.user.id;

    if (!nichePrincipal || !ideiaInicial) {
        return res.status(400).json({ msg: 'Nicho principal e ideia inicial são obrigatórios.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Se não houver modelo selecionado, usar GPT-4o como padrão
        const laozhangModel = selectedModel === 'Claude 3.7 Sonnet (Fev/25)' ? 'claude-3-7-sonnet-20250219' :
                             selectedModel === 'Gemini 2.5 Pro (2025)' ? 'gemini-2.5-pro' :
                             (!selectedModel || !selectedModel.trim()) ? 'gpt-4o' : selectedModel;

        const prompt = `
Você é um ESPECIALISTA EM CRIAÇÃO DE CANAIS MILIONÁRIOS NO YOUTUBE.

OBJETIVO: Encontrar um subnicho dentro de "${nichePrincipal}" que permita criar um canal MILIONÁRIO.

Quero criar um canal no YouTube dentro do nicho de "${nichePrincipal}", inicialmente pensei em abordar "${ideiaInicial}", mas percebi que já há bastante concorrência.

Estou em busca de uma ideia de subnicho dentro de "${nichePrincipal}" que:
- Ainda esteja pouco explorada no YouTube, com pouca ou nenhuma concorrência
- Tenha alto volume de buscas e interesse crescente
- Tenha bom potencial de monetização
- TENHA ALTO POTENCIAL DE VIRALIZAÇÃO e capacidade de gerar milhões de views
- Permita criar conteúdo com alto CTR (acima de 25%)
- Tenha oportunidades de criar títulos e thumbnails virais

IMPORTANTE: Responda APENAS com um JSON válido no seguinte formato (sem texto adicional antes ou depois):

{
  "subnicho_recomendado": "Nome do subnicho recomendado",
  "analise_potencial": "Análise detalhada explicando por que este subnicho tem potencial para gerar milhões de views, incluindo dados de mercado, tendências e oportunidades",
  "analise_concorrencia": "Análise da concorrência atual, mostrando por que há pouca competição e quais são as oportunidades de diferenciação",
  "potencial_viralizacao": "Explicação detalhada do potencial de viralização, incluindo fatores que podem fazer o conteúdo viralizar e gerar milhões de views",
  "estrategias_conteudo": [
    "Estratégia 1 para criar conteúdo que viralize",
    "Estratégia 2 para criar conteúdo que viralize",
    "Estratégia 3 para criar conteúdo que viralize",
    "Estratégia 4 para criar conteúdo que viralize"
  ],
  "sugestoes_titulos_thumbnails": {
    "titulos": [
      "Título viral 1 que gere alto CTR",
      "Título viral 2 que gere alto CTR",
      "Título viral 3 que gere alto CTR",
      "Título viral 4 que gere alto CTR"
    ],
    "thumbnails": [
      {
        "imagem": "Descrição da imagem do thumbnail 1",
        "texto": "Texto do thumbnail 1",
        "cores": "Cores recomendadas para o thumbnail 1"
      },
      {
        "imagem": "Descrição da imagem do thumbnail 2",
        "texto": "Texto do thumbnail 2",
        "cores": "Cores recomendadas para o thumbnail 2"
      },
      {
        "imagem": "Descrição da imagem do thumbnail 3",
        "texto": "Texto do thumbnail 3",
        "cores": "Cores recomendadas para o thumbnail 3"
      },
      {
        "imagem": "Descrição da imagem do thumbnail 4",
        "texto": "Texto do thumbnail 4",
        "cores": "Cores recomendadas para o thumbnail 4"
      }
    ]
  }
}

Responda APENAS com o JSON, sem texto adicional antes ou depois.
`;

        const response = await callLaozhangAPI(
            prompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_niche_find_subniche',
            JSON.stringify({ endpoint: '/api/niche/find-subniche/laozhang', model: laozhangModel })
        );

        // Tentar extrair JSON da resposta
        let recommendation = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        // Tentar parsear JSON se a resposta contém JSON
        try {
            const jsonMatch = recommendation.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                recommendation = parsed;
            }
        } catch (e) {
            console.warn('[Find Subniche] Falha ao parsear JSON, retornando texto:', e.message);
        }
        
        res.status(200).json({ recommendation: recommendation });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/niche/find-subniche/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});

app.post('/api/niche/analyze-competitor', authenticateToken, async (req, res) => {
    const { competitorUrl, model } = req.body;
    const userId = req.user.id;

    if (!competitorUrl || !model) {
        return res.status(400).json({ msg: 'URL do canal e modelo de IA são obrigatórios.' });
    }

    try {
        // 1. Obter chaves de API
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        if (!geminiKeyData) return res.status(400).json({ msg: 'Chave de API do Gemini é necessária para buscar dados do YouTube.' });
        const geminiApiKey = decrypt(geminiKeyData.api_key);
        if (!geminiApiKey) return res.status(500).json({ msg: 'Falha ao desencriptar a chave do Gemini.' });

        // 2. Obter ID do canal a partir da URL
        const match = competitorUrl.match(/youtube\.com\/(?:@([\w.-]+)|channel\/([\w-]+))/);
        if (!match) return res.status(400).json({ msg: 'Formato de URL do canal não suportado.' });
        
        let ytChannelId;
        const handle = match[1];
        const legacyId = match[2];

        if (handle) {
            const searchApiUrl = `https://www.googleapis.com/youtube/v3/search?part=id&q=${handle}&type=channel&maxResults=1&key=${geminiApiKey}`;
            const searchResponse = await fetch(searchApiUrl);
            const searchData = await searchResponse.json();
            if (!searchResponse.ok || !searchData.items || searchData.items.length === 0) {
                throw new Error(`Não foi possível encontrar o canal para o handle: @${handle}.`);
            }
            ytChannelId = searchData.items[0].id.channelId;
        } else {
            ytChannelId = legacyId;
        }
        if (!ytChannelId) throw new Error('Não foi possível determinar o ID do canal.');

        // 3. Buscar vídeos do canal
        const [popularVideos, latestVideos] = await Promise.all([
            getChannelVideosWithDetails(ytChannelId, geminiApiKey, 'viewCount', 10),
            getChannelVideosWithDetails(ytChannelId, geminiApiKey, 'date', 10)
        ]);

        let videoDataForPrompt = "Lista de vídeos publicados pelo canal:\n\n";
        videoDataForPrompt += "--- VÍDEOS MAIS POPULARES ---\n";
        popularVideos.forEach(v => {
            videoDataForPrompt += `- Título: "${v.title}", Visualizações: ${v.views}, Publicado há: ${v.days} dias\n`;
        });
        videoDataForPrompt += "\n--- VÍDEOS MAIS RECENTES ---\n";
        latestVideos.forEach(v => {
            videoDataForPrompt += `- Título: "${v.title}", Visualizações: ${v.views}, Publicado há: ${v.days} dias\n`;
        });

        // 4. Construir o PROMPT 2 (OTIMIZADO PARA CRIAR CANAIS MILIONÁRIOS)
        const prompt = `
            Você é um ESPECIALISTA EM CRIAÇÃO DE CANAIS MILIONÁRIOS NO YOUTUBE com experiência em analisar canais de sucesso e criar estratégias vencedoras.
            
            OBJETIVO: Analisar um canal de sucesso no YouTube e usar essa análise como base para criar um canal MILIONÁRIO com MILHÕES DE VIEWS e ALTO CTR dentro do mesmo nicho.
            
            PROMPT 2 - ANÁLISE DE CANAL COMPETIDOR:
            Preciso da sua ajuda para analisar um canal de sucesso no YouTube e usar essa análise como base para a criação do meu próprio canal dentro do mesmo nicho.
            
            Vou te fornecer as seguintes informações:
            ${videoDataForPrompt}
            
            Com base nesses dados, preciso que você faça uma ANÁLISE PROFUNDA E ESTRATÉGICA e me responda com:
            
            1. **Análise de Nicho e Subnicho:**
               - Qual é o nicho exato desse canal e seu subnicho (se houver)?
               - Por que esse nicho/subnicho funcionou tão bem?
               - Há oportunidades de subnichos pouco explorados com alto potencial de viralização?
            
            2. **Diferenciais de Sucesso:**
               - Quais são os principais diferenciais que tornam esse canal bem-sucedido?
               - O que faz esse canal gerar milhões de views?
               - Quais são os elementos únicos que criam alta taxa de engajamento?
            
            3. **Público-Alvo:**
               - Qual é o público-alvo (perfil demográfico, interesses, comportamento)?
               - Que tipo de conteúdo esse público consome?
               - Quais são as necessidades e desejos não atendidos desse público?
            
            4. **Estratégias de Conteúdo Virais:**
               - Quais estratégias de conteúdo parecem ser as mais eficazes (tipo de vídeo, frequência, estilo de narrativa, títulos, miniaturas, SEO)?
               - Quais padrões ou formatos se repetem nos vídeos de maior sucesso?
               - O que faz os vídeos terem alto CTR e gerarem milhões de views?
               - Quais são as fórmulas de títulos e thumbnails que funcionaram?
            
            5. **Análise de Oportunidades:**
               - Há algo nos comentários que revele desejos ou insatisfações da audiência que eu possa usar como oportunidade? (Simule uma análise de sentimentos com base nos títulos e views)
               - Quais são as oportunidades que eu posso explorar para criar um canal similar, porém com diferenciais competitivos?
               - Como posso criar conteúdo que viralize e gere milhões de views?
            
            6. **Orientação Estratégica para Criar Canal Milionário:**
               - Como devo estruturar o conteúdo do meu canal para gerar milhões de views?
               - Qual linha editorial devo seguir para alto CTR e viralização?
               - Sugestões de nome de canal, temas iniciais e identidade visual que atraiam milhões de views
               - Ideias de roteiros para os primeiros vídeos, baseados no que mais funciona no canal analisado
               - Estratégias para criar títulos e thumbnails que gerem alto CTR (acima de 25%)
               - Como criar conteúdo que viralize e gere engajamento massivo
            
            FOCO: Criar um canal MILIONÁRIO com MILHÕES DE VIEWS, ALTO CTR (acima de 25%), e conteúdo que VIRALIZE.
            
            Analise tudo com atenção e me dê uma resposta estratégica e prática, voltada para resultados e criação de canais milionários, em formato JSON. O JSON deve ter chaves como "analise_nicho", "diferenciais_sucesso", "publico_alvo", "estrategias_conteudo", "padroes_videos", "analise_comentarios", "oportunidades_explorar", e "orientacoes_finais" (que por sua vez contém "estrutura_conteudo", "linha_editorial", "sugestoes_branding", "ideias_roteiros", "estrategias_viralizacao", "titulos_ctr_alto", "thumbnails_virais").
        `;

        // 5. Chamar a IA
        let service;
        if (model.startsWith('gemini')) service = 'gemini';
        else if (model.startsWith('claude')) service = 'claude';
        else if (model.startsWith('gpt')) service = 'openai';
        else return res.status(400).json({ msg: 'Modelo de IA inválido.' });

        const userKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
        if (!userKeyData) return res.status(400).json({ msg: `Nenhuma Chave de API do ${service} configurada.` });
        
        const decryptedKey = decrypt(userKeyData.api_key);
        if (!decryptedKey) return res.status(500).json({ msg: 'Falha ao desencriptar a sua chave de API.' });

        let apiCallFunction;
        if (service === 'gemini') apiCallFunction = callGeminiAPI;
        else if (service === 'claude') apiCallFunction = callClaudeAPI;
        else apiCallFunction = callOpenAIAPI;

        const response = await apiCallFunction(prompt, decryptedKey, model);
        const analysis = parseAIResponse(response.titles, service);

        res.status(200).json(analysis);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/niche/analyze-competitor]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});

// === ROTA LAOZHANG PARA ANÁLISE DE CONCORRENTES ===
app.post('/api/niche/analyze-competitor/laozhang', authenticateToken, async (req, res) => {
    const { competitorUrl, selectedModel } = req.body;
    const userId = req.user.id;

    if (!competitorUrl) {
        return res.status(400).json({ msg: 'URL do canal é obrigatória.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo não configurada no painel admin.' });
        }

        // Buscar chave do Gemini/YouTube para buscar dados do canal
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        
        let apiKey = null;
        if (youtubeKeyData) {
            apiKey = youtubeKeyData.api_key.includes(':') ? decrypt(youtubeKeyData.api_key) : youtubeKeyData.api_key;
        } else if (geminiKeyData) {
            apiKey = geminiKeyData.api_key.includes(':') ? decrypt(geminiKeyData.api_key) : geminiKeyData.api_key;
        }
        
        if (!apiKey) {
            return res.status(400).json({ msg: 'Chave de API do YouTube ou Gemini é necessária para buscar dados do canal.' });
        }

        // Obter ID do canal (mesma lógica da rota original)
        const match = competitorUrl.match(/youtube\.com\/(?:@([\w.-]+)|channel\/([\w-]+))/);
        if (!match) return res.status(400).json({ msg: 'Formato de URL do canal não suportado.' });
        
        let ytChannelId;
        const handle = match[1];
        const legacyId = match[2];

        if (handle) {
            const searchApiUrl = `https://www.googleapis.com/youtube/v3/search?part=id&q=${handle}&type=channel&maxResults=1&key=${apiKey}`;
            const searchResponse = await fetch(searchApiUrl);
            const searchData = await searchResponse.json();
            if (searchResponse.ok && searchData.items && searchData.items.length > 0) {
                ytChannelId = searchData.items[0].id.channelId;
            }
        }

        if (!ytChannelId && legacyId) {
            ytChannelId = legacyId;
        }

        if (!ytChannelId) {
            return res.status(400).json({ msg: 'Não foi possível identificar o canal a partir da URL fornecida.' });
        }

        // Buscar dados do canal e vídeos (mesma lógica da rota original, simplificada)
        const channelUrl = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${ytChannelId}&key=${apiKey}`;
        const channelResponse = await fetch(channelUrl);
        const channelData = await channelResponse.json();

        if (!channelResponse.ok || !channelData.items || channelData.items.length === 0) {
            return res.status(400).json({ msg: 'Canal não encontrado.' });
        }

        const channel = channelData.items[0];
        const competitorData = await getChannelVideosWithDetails(ytChannelId, apiKey, 'viewCount', 5);

        // Criar prompt para análise - usar GPT-4o como padrão se não houver modelo selecionado
        const laozhangModel = selectedModel === 'Claude 3.7 Sonnet (Fev/25)' ? 'claude-3-7-sonnet-20250219' :
                             selectedModel === 'Gemini 2.5 Pro (2025)' ? 'gemini-2.5-pro' :
                             selectedModel && selectedModel.trim() ? selectedModel : 'gpt-4o';

        const prompt = `
Você é um ESPECIALISTA EM CRIAÇÃO DE CANAIS MILIONÁRIOS NO YOUTUBE.

OBJETIVO: Analisar um canal concorrente de sucesso e fornecer um plano estratégico completo para criar um canal milionário no mesmo nicho.

DADOS DO CANAL ANALISADO:
- NOME: ${channel.snippet.title}
- DESCRIÇÃO: ${channel.snippet.description || 'N/A'}
- INSCRITOS: ${channel.statistics.subscriberCount || 'N/A'}
- TOTAL DE VÍDEOS: ${channel.statistics.videoCount || 'N/A'}
- TOTAL DE VIEWS: ${channel.statistics.viewCount || 'N/A'}

VÍDEOS MAIS POPULARES:
${competitorData.map((v, i) => `${i + 1}. "${v.title}" - ${v.views.toLocaleString('pt-BR')} visualizações`).join('\n')}

IMPORTANTE: Responda APENAS com um JSON válido no seguinte formato (sem texto adicional antes ou depois):

{
  "content_strategies": {
    "overview": "Visão geral das estratégias de conteúdo que fazem este canal ter sucesso",
    "playlist_strategy": "Estratégia de playlists e organização de conteúdo (se aplicável)",
    "storytelling": "Técnicas de storytelling e narrativa utilizadas",
    "engagement_tactics": "Táticas de engajamento que geram milhões de views"
  },
  "title_and_thumbnail_patterns": {
    "title_patterns": "Padrões identificados nos títulos que geram alto CTR e milhões de views",
    "thumbnail_patterns": "Padrões visuais e elementos que aparecem nos thumbnails de sucesso"
  },
  "posting_frequency": {
    "current_frequency": "Análise da frequência atual de postagem do canal",
    "recommendation": "Recomendação de frequência ideal para maximizar views e engajamento"
  },
  "niche_and_subniches": {
    "primary_niche": "Nicho principal identificado",
    "subniches": [
      "Subnicho 1 explorado",
      "Subnicho 2 explorado",
      "Subnicho 3 explorado"
    ]
  },
  "differentiation_opportunities": {
    "live_interactions": "Oportunidades de interação ao vivo que podem diferenciar seu canal",
    "exclusive_interviews": "Oportunidades de entrevistas exclusivas ou conteúdo único",
    "collaborations": "Estratégias de colaboração para aumentar alcance",
    "content_gaps": "Lacunas de conteúdo identificadas que você pode explorar",
    "unique_angles": "Ângulos únicos que você pode usar para se diferenciar"
  },
  "strategic_recommendations": {
    "channel_name_suggestions": [
      "Sugestão de nome 1",
      "Sugestão de nome 2",
      "Sugestão de nome 3"
    ],
    "first_videos_ideas": [
      "Ideia de vídeo inicial 1",
      "Ideia de vídeo inicial 2",
      "Ideia de vídeo inicial 3"
    ],
    "growth_strategy": "Estratégia completa de crescimento para alcançar milhões de views",
    "monetization_opportunities": "Oportunidades de monetização específicas para este nicho"
  }
}

Responda APENAS com o JSON, sem texto adicional antes ou depois.
`;

        const response = await callLaozhangAPI(
            prompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_niche_analyze_competitor',
            JSON.stringify({ endpoint: '/api/niche/analyze-competitor/laozhang', model: laozhangModel })
        );

        // Tentar extrair JSON da resposta
        let analysis = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        // Tentar parsear JSON se a resposta contém JSON
        try {
            const jsonMatch = analysis.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                analysis = parsed;
            }
        } catch (e) {
            console.warn('[Analyze Competitor] Falha ao parsear JSON, retornando texto:', e.message);
        }
        
        res.status(200).json(analysis);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/niche/analyze-competitor/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});


// === ROTAS DE ADMIN ===

app.get('/api/admin/stats', authenticateToken, isAdmin, async (req, res) => {
    try {
        const totalUsers = await db.get('SELECT COUNT(*) as count FROM users');
        const pendingUsers = await db.get('SELECT COUNT(*) as count FROM users WHERE isApproved = 0');
        const onlineUsers = await db.get("SELECT COUNT(*) as count FROM users WHERE last_login_at > datetime('now', '-15 minutes')");
        const logins24h = await db.get("SELECT COUNT(*) as count FROM users WHERE last_login_at > datetime('now', '-24 hours')");

        res.json({
            totalUsers: totalUsers.count,
            pendingUsers: pendingUsers.count,
            onlineUsers: onlineUsers.count,
            logins24h: logins24h.count
        });
    } catch (err) {
        console.error('Erro ao buscar estatísticas admin:', err);
        res.status(500).json({ msg: 'Erro ao buscar estatísticas.' });
    }
});

app.get('/api/admin/users', authenticateToken, isAdmin, async (req, res) => {
    const { search, status } = req.query;
    try {
        let query = 'SELECT id, name, email, whatsapp, isAdmin, isBlocked, isApproved, plan, subscription_plan, created_at FROM users';
        const params = [];
        const conditions = [];

        if (search) {
            conditions.push('(email LIKE ? OR whatsapp LIKE ? OR name LIKE ?)');
            params.push(`%${search}%`, `%${search}%`, `%${search}%`);
        }

        if (status) {
            if (status === 'pending') conditions.push('isApproved = 0');
            if (status === 'active') conditions.push('isApproved = 1 AND isBlocked = 0');
            if (status === 'blocked') conditions.push('isBlocked = 1');
        }

        if (conditions.length > 0) {
            query += ' WHERE ' + conditions.join(' AND ');
        }
        
        const users = await db.all(query, params);
        res.json(users);
    } catch (err) {
        console.error('Erro ao buscar utilizadores admin:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

app.post('/api/admin/users/approve-all', authenticateToken, isAdmin, async (req, res) => {
    try {
        await db.run('UPDATE users SET isApproved = 1 WHERE isApproved = 0');
        res.status(200).json({ msg: 'Todos os utilizadores pendentes foram aprovados.' });
    } catch (err) {
        console.error('Erro ao aprovar todos os utilizadores:', err);
        res.status(500).json({ msg: 'Erro ao aprovar utilizadores.' });
    }
});

app.put('/api/admin/users/:id', authenticateToken, isAdmin, async (req, res) => {
    const { id } = req.params;
    const { name, whatsapp, isAdmin, isBlocked, isApproved } = req.body;
    try {
        await db.run('UPDATE users SET name = ?, whatsapp = ?, isAdmin = ?, isBlocked = ?, isApproved = ? WHERE id = ?', [name, whatsapp, isAdmin, isBlocked, isApproved, id]);
        res.status(200).json({ msg: 'Utilizador atualizado com sucesso.' });
    } catch (err) {
        res.status(500).json({ msg: 'Erro ao atualizar utilizador.' });
    }
});

app.put('/api/admin/users/:id/password', authenticateToken, isAdmin, async (req, res) => {
    const { id } = req.params;
    const { password } = req.body;
    if (!password || password.length < 6) {
        return res.status(400).json({ msg: 'A senha deve ter pelo menos 6 caracteres.' });
    }
    try {
        // Obter dados do usuário antes de atualizar
        const userData = await db.get('SELECT name, email FROM users WHERE id = ?', [id]);
        if (!userData) {
            return res.status(404).json({ msg: 'Usuário não encontrado.' });
        }
        
        const salt = await bcrypt.genSalt(10);
        const password_hash = await bcrypt.hash(password, salt);
        await db.run('UPDATE users SET password_hash = ? WHERE id = ?', [password_hash, id]);
        
        // Enviar email de senha provisória
        try {
            const protocol = req.protocol;
            const host = req.get('host');
            const loginUrl = `${protocol}://${host}/la-casa-dark-core-auth.html`;
            
            await sendTemplateEmail('password_reset', userData.email, {
                nome: userData.name,
                email: userData.email,
                senha_provisoria: password,
                link_acesso: loginUrl
            });
        } catch (emailError) {
            console.error('[EMAIL] Erro ao enviar email de senha provisória:', emailError.message);
            // Não falhar a operação se o email falhar
        }
        
        res.status(200).json({ msg: 'Senha atualizada com sucesso e email enviado.' });
    } catch (err) {
        res.status(500).json({ msg: 'Erro ao atualizar a senha.' });
    }
});

// Função para adicionar créditos automáticos baseado no plano
async function addPlanCredits(userId, planName, isRenewal = false) {
    try {
        // Obter créditos do plano
        const planCredits = await db.get('SELECT monthly_credits FROM plan_credits WHERE plan_name = ?', [planName]);
        if (!planCredits) {
            console.warn(`[PLAN CREDITS] Plano ${planName} não encontrado na tabela plan_credits`);
            return;
        }
        
        const creditsToAdd = planCredits.monthly_credits;
        if (creditsToAdd <= 0) return;
        
        // Verificar se usuário já tem créditos
        let userCredits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [userId]);
        
        if (!userCredits) {
            // Criar registro de créditos
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, ?)', [userId, creditsToAdd]);
        } else {
            // Adicionar créditos
            await db.run(
                'UPDATE user_credits SET balance = balance + ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?',
                [creditsToAdd, userId]
            );
        }
        
        // Registrar transação
        await db.run(`
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description)
            VALUES (?, ?, 'credit', ?)
        `, [userId, creditsToAdd, isRenewal ? `Renovação mensal de créditos - Plano ${planName}` : `Créditos iniciais - Plano ${planName}`]);
        
        // Registrar renovação
        const isAnnual = planName.includes('annual');
        const nextRenewal = new Date();
        nextRenewal.setMonth(nextRenewal.getMonth() + 1);
        
        await db.run(`
            INSERT INTO credit_renewals (user_id, plan_name, credits_added, renewal_date, next_renewal_date, is_annual)
            VALUES (?, ?, ?, CURRENT_TIMESTAMP, ?, ?)
        `, [userId, planName, creditsToAdd, nextRenewal.toISOString(), isAnnual ? 1 : 0]);
        
        console.log(`[PLAN CREDITS] ${creditsToAdd} créditos adicionados ao usuário ${userId} (Plano: ${planName})`);
    } catch (error) {
        console.error('[PLAN CREDITS] Erro ao adicionar créditos:', error);
    }
}

// Função para verificar e renovar créditos mensalmente
async function checkAndRenewCredits() {
    try {
        // Buscar usuários com planos ativos que precisam renovar
        const usersToRenew = await db.all(`
            SELECT u.id, u.subscription_plan, u.plan, cr.next_renewal_date
            FROM users u
            LEFT JOIN credit_renewals cr ON u.id = cr.user_id
            WHERE (u.subscription_plan IS NOT NULL AND u.subscription_plan != 'plan-free')
               OR (u.plan IS NOT NULL AND u.plan != 'plan-free')
            GROUP BY u.id
            HAVING MAX(cr.next_renewal_date) < datetime('now')
               OR MAX(cr.next_renewal_date) IS NULL
        `);
        
        for (const user of usersToRenew) {
            const planName = user.subscription_plan || user.plan;
            if (planName && planName !== 'plan-free') {
                await addPlanCredits(user.id, planName, true);
            }
        }
        
        console.log(`[PLAN CREDITS] Verificação de renovação concluída. ${usersToRenew.length} usuários processados.`);
    } catch (error) {
        console.error('[PLAN CREDITS] Erro ao verificar renovações:', error);
    }
}

// Executar verificação de renovação a cada hora
setInterval(checkAndRenewCredits, 60 * 60 * 1000); // 1 hora

// PUT /api/admin/users/:id/plan - Alterar plano do usuário
app.put('/api/admin/users/:id/plan', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.id);
        const { plan } = req.body;
        
        if (!plan) {
            return res.status(400).json({ message: 'Plano é obrigatório' });
        }
        
        const validPlans = ['plan-free', 'plan-start', 'plan-turbo', 'plan-master', 'plan-start-annual', 'plan-turbo-annual', 'plan-master-annual'];
        if (!validPlans.includes(plan)) {
            return res.status(400).json({ message: 'Plano inválido' });
        }
        
        const user = await db.get('SELECT id, email FROM users WHERE id = ?', [userId]);
        if (!user) {
            return res.status(404).json({ message: 'Usuário não encontrado' });
        }
        
        // Atualizar plano
        await db.run('UPDATE users SET subscription_plan = ?, plan = ? WHERE id = ?', [plan, plan, userId]);
        
        // Adicionar créditos automáticos se não for plano free
        if (plan !== 'plan-free') {
            await addPlanCredits(userId, plan, false);
        }
        
        res.json({ 
            message: 'Plano alterado com sucesso',
            plan: plan
        });
    } catch (error) {
        console.error('Erro ao alterar plano:', error);
        res.status(500).json({ message: 'Erro ao alterar plano' });
    }
});

app.put('/api/admin/users/:id/status', authenticateToken, isAdmin, async (req, res) => {
    const { id } = req.params;
    const { isBlocked } = req.body;
    try {
        await db.run('UPDATE users SET isBlocked = ? WHERE id = ?', [isBlocked, id]);
        res.status(200).json({ msg: `Utilizador ${isBlocked ? 'bloqueado' : 'desbloqueado'} com sucesso.` });
    } catch (err) {
        res.status(500).json({ msg: 'Erro ao alterar o status do utilizador.' });
    }
});

app.delete('/api/admin/users/:id', authenticateToken, isAdmin, async (req, res) => {
    const { id } = req.params;
    if (parseInt(id, 10) === req.user.id) {
        return res.status(400).json({ msg: 'Não pode excluir a sua própria conta de administrador.' });
    }
    try {
        await db.run('DELETE FROM users WHERE id = ?', [id]);
        res.status(200).json({ msg: 'Utilizador excluído com sucesso.' });
    } catch (err) {
        res.status(500).json({ msg: 'Erro ao excluir utilizador.' });
    }
});


// === ROTAS DE PASTAS E HISTÓRICO ===

app.post('/api/folders', authenticateToken, async (req, res) => {
    const { name } = req.body;
    const userId = req.user.id;

    if (!name) {
        return res.status(400).json({ msg: 'O nome da pasta é obrigatório.' });
    }
    try {
        const result = await db.run(
            'INSERT INTO analysis_folders (user_id, name) VALUES (?, ?)',
            [userId, name]
        );
        res.status(201).json({ id: result.lastID, name });
    } catch (err) {
        console.error('Erro ao criar pasta:', err);
        res.status(500).json({ msg: 'Erro no servidor ao criar pasta.' });
    }
});

app.get('/api/folders', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    try {
        const folders = await db.all('SELECT id, name FROM analysis_folders WHERE user_id = ? ORDER BY name', [userId]);
        res.status(200).json(folders);
    } catch (err) {
        console.error('Erro ao listar pastas:', err);
        res.status(500).json({ msg: 'Erro no servidor ao listar pastas.' });
    }
});

app.delete('/api/folders/:folderId', authenticateToken, async (req, res) => {
    const { folderId } = req.params;
    const userId = req.user.id;
    try {
        const result = await db.run(
            'DELETE FROM analysis_folders WHERE id = ? AND user_id = ?',
            [folderId, userId]
        );
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Pasta não encontrada ou não pertence a este utilizador.' });
        }
        res.status(200).json({ msg: 'Pasta excluída com sucesso. As análises foram movidas para o Histórico Geral.' });
    } catch (err) {
        console.error('Erro ao excluir pasta:', err);
        res.status(500).json({ msg: 'Erro no servidor ao excluir pasta.' });
    }
});
app.get('/api/history', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { folderId, page = 1, limit = 50, search, niche, dateFilter } = req.query;
    
    try {
        const pageNum = parseInt(page) || 1;
        const limitNum = parseInt(limit) || 50;
        const offset = (pageNum - 1) * limitNum;
        
        let baseWhere = 'user_id = ?';
        let params = [userId];
        let countParams = [userId];
        
        if (folderId) {
            baseWhere += ' AND folder_id = ?';
            params.push(folderId);
            countParams.push(folderId);
        } else {
            baseWhere += ' AND folder_id IS NULL';
        }
        
        // Filtro de busca
        if (search) {
            baseWhere += ' AND original_title LIKE ?';
            params.push(`%${search}%`);
            countParams.push(`%${search}%`);
        }
        
        // Filtro de nicho
        if (niche) {
            baseWhere += ' AND detected_subniche LIKE ?';
            params.push(`%${niche}%`);
            countParams.push(`%${niche}%`);
        }
        
        // Filtro de data
        if (dateFilter) {
            const now = new Date();
            let dateStart;
            switch (dateFilter) {
                case 'today':
                    dateStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    break;
                case 'week':
                    dateStart = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    break;
                case 'month':
                    dateStart = new Date(now.getFullYear(), now.getMonth(), 1);
                    break;
                case 'year':
                    dateStart = new Date(now.getFullYear(), 0, 1);
                    break;
            }
            if (dateStart) {
                baseWhere += ' AND analyzed_at >= ?';
                params.push(dateStart.toISOString());
                countParams.push(dateStart.toISOString());
            }
        }
        
        let query = `SELECT id, original_title, detected_subniche, analyzed_at FROM analyzed_videos WHERE ${baseWhere} ORDER BY analyzed_at DESC LIMIT ? OFFSET ?`;
        params.push(limitNum, offset);
        
        let countQuery = `SELECT COUNT(*) as total FROM analyzed_videos WHERE ${baseWhere}`;
        
        const [history, totalResult] = await Promise.all([
            db.all(query, params),
            db.get(countQuery, countParams)
        ]);
        
        // Garantir que history é sempre um array
        const historyArray = Array.isArray(history) ? history : [];
        
        const total = totalResult?.total || 0;
        const totalPages = Math.ceil(total / limitNum);
        
        res.status(200).json({
            data: historyArray,
            pagination: {
                page: pageNum,
                limit: limitNum,
                total: total,
                totalPages: totalPages,
                hasNext: pageNum < totalPages,
                hasPrev: pageNum > 1
            }
        });
        
    } catch (err) {
        console.error('Erro ao listar histórico:', err);
        res.status(500).json({ msg: 'Erro no servidor ao listar histórico.' });
    }
});

app.delete('/api/history', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { ids } = req.body;

    if (!ids || !Array.isArray(ids) || ids.length === 0) {
        return res.status(400).json({ msg: 'Nenhum ID de análise fornecido.' });
    }

    try {
        const placeholders = ids.map(() => '?').join(',');
        const result = await db.run(
            `DELETE FROM analyzed_videos WHERE id IN (${placeholders}) AND user_id = ?`,
            [...ids, userId]
        );
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Nenhuma análise encontrada ou não pertence a este utilizador.' });
        }
        
        res.status(200).json({ msg: `${result.changes} análise(s) excluída(s) com sucesso.` });
        
    } catch (err) {
        console.error('Erro ao excluir análises:', err);
        res.status(500).json({ msg: 'Erro no servidor ao excluir análises.' });
    }
});

// Rota para buscar nichos únicos do histórico
app.get('/api/history/niches', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const niches = await db.all(
            `SELECT DISTINCT detected_subniche as niche 
             FROM analyzed_videos 
             WHERE user_id = ? AND detected_subniche IS NOT NULL AND detected_subniche != '' 
             ORDER BY detected_subniche`,
            [userId]
        );

        const nichesArray = niches.map(row => row.niche).filter(Boolean);
        res.status(200).json({ niches: nichesArray });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/history/niches]:', err);
        res.status(500).json({ msg: 'Erro ao buscar nichos.' });
    }
});

app.get('/api/history/load/:analysisId', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { analysisId } = req.params;

    try {
        const analysis = await db.get(
            'SELECT * FROM analyzed_videos WHERE id = ? AND user_id = ?',
            [analysisId, userId]
        );
        if (!analysis) return res.status(404).json({ msg: 'Análise não encontrada.' });

        const titles = await db.all(
            'SELECT id, title_text as titulo, model_used as model, pontuacao, explicacao, is_checked FROM generated_titles WHERE video_analysis_id = ?',
            [analysisId]
        );

        // Calcular receita e RPM baseado no nicho
        const rpm = getRPMByNiche(analysis.detected_niche);
        const views = parseInt(analysis.original_views) || 0;
        const estimatedRevenueUSD = (views / 1000) * rpm.usd;
        const estimatedRevenueBRL = (views / 1000) * rpm.brl;

        const responseData = {
            niche: analysis.detected_niche,
            subniche: analysis.detected_subniche,
            analiseOriginal: JSON.parse(analysis.analysis_data_json || '{}'),
            titulosSugeridos: titles,
            modelUsed: titles.length > 0 ? titles[0].model : 'Carregado',
            videoDetails: {
                title: analysis.original_title,
                translatedTitle: analysis.translated_title || null,
                views: views,
                comments: analysis.original_comments,
                days: analysis.original_days,
                thumbnailUrl: analysis.original_thumbnail_url,
                videoId: analysis.youtube_video_id,
                estimatedRevenueUSD: estimatedRevenueUSD,
                estimatedRevenueBRL: estimatedRevenueBRL,
                rpmUSD: rpm.usd,
                rpmBRL: rpm.brl
            },
            originalVideoUrl: analysis.video_url 
        };
        res.status(200).json(responseData);

    } catch (err) {
        console.error('Erro ao carregar análise:', err);
        res.status(500).json({ msg: 'Erro no servidor ao carregar análise.' });
    }
});


// === ROTAS DE CANAIS MONITORADOS (para análise de canais) ===
app.post('/api/channels/monitor', authenticateToken, async (req, res) => {
    const { channelUrl, channelName } = req.body;
    const userId = req.user.id;

    if (!channelUrl || !channelName) {
        return res.status(400).json({ msg: 'Nome e URL do canal são obrigatórios.' });
    }

    try {
        // Verificar limite de 5 canais por usuário
        const channelCount = await db.get('SELECT COUNT(*) as count FROM monitored_channels WHERE user_id = ?', [userId]);
        if (channelCount && channelCount.count >= 5) {
            return res.status(400).json({ msg: 'Limite de 5 canais monitorados atingido. Exclua um canal antes de adicionar outro.' });
        }

        const result = await db.run(
            'INSERT INTO monitored_channels (user_id, channel_name, channel_url) VALUES (?, ?, ?)',
            [userId, channelName, channelUrl]
        );
        res.status(201).json({ id: result.lastID, channel_name: channelName, channel_url: channelUrl });
    } catch (err) {
        console.error('Erro ao adicionar canal:', err);
        if (err.message.includes('UNIQUE constraint failed')) {
            return res.status(400).json({ msg: 'Este canal já está sendo monitorado por você.' });
        }
        res.status(500).json({ msg: 'Erro no servidor ao adicionar canal.' });
    }
});

app.get('/api/channels/monitor', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    try {
        if (!db) {
            console.error('[Canais Monitorados] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }
        
        const channels = await db.all(
            'SELECT id, channel_name, channel_url, last_checked FROM monitored_channels WHERE user_id = ? ORDER BY channel_name',
            [userId]
        );
        
        console.log(`[Canais Monitorados] Encontrados ${channels.length} canais para usuário ${userId}`);
        res.status(200).json(channels || []);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/monitor]:', err);
        res.status(500).json({ msg: 'Erro no servidor ao listar canais.' });
    }
});

app.delete('/api/channels/monitor/:channelId', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { channelId } = req.params;

    try {
        const result = await db.run(
            'DELETE FROM monitored_channels WHERE id = ? AND user_id = ?',
            [channelId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Canal não encontrado ou não pertence a este utilizador.' });
        }
        
        res.status(200).json({ msg: 'Canal removido com sucesso.' });
    } catch (err) {
        console.error('Erro ao excluir canal:', err);
        res.status(500).json({ msg: 'Erro no servidor ao excluir canal.' });
    }
});

app.get('/api/channels/monitor/:channelId/check', authenticateToken, async (req, res) => {
    const { channelId } = req.params;
    const userId = req.user.id;
    try {
        const channel = await db.get('SELECT channel_url FROM monitored_channels WHERE id = ? AND user_id = ?', [channelId, userId]);
        if (!channel) {
            return res.status(404).json({ msg: 'Canal não encontrado.' });
        }

        // Buscar chave do YouTube primeiro, se não encontrar, usar Gemini como fallback
        let youtubeApiKey = null;
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData && youtubeKeyData.api_key) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
            if (!youtubeApiKey && youtubeKeyData.api_key && !youtubeKeyData.api_key.includes(':')) {
                youtubeApiKey = youtubeKeyData.api_key;
            }
        }
        
        // Se não encontrou chave do YouTube, tentar usar Gemini como fallback
        if (!youtubeApiKey) {
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData && geminiKeyData.api_key) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
                if (!youtubeApiKey && geminiKeyData.api_key && !geminiKeyData.api_key.includes(':')) {
                    youtubeApiKey = geminiKeyData.api_key;
                }
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ msg: 'Chave de API do YouTube ou Gemini é necessária para esta função. Configure uma delas nas configurações.' });
        }

        // Extrair ID do canal da URL (suporta múltiplos formatos)
        let ytChannelId = null;
        let channelUrl = channel.channel_url.trim();
        
        console.log(`[Canais Monitorados] Tentando extrair ID do canal da URL: ${channelUrl}`);
        
        // Se for URL de vídeo, extrair o canal do vídeo
        // Suporta múltiplos formatos: youtube.com/watch?v=, youtu.be/, youtube.com/embed/, etc.
        const videoMatch = channelUrl.match(/(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
        if (videoMatch) {
            try {
                const videoId = videoMatch[1];
                console.log(`[Canais Monitorados] URL de vídeo detectada, ID do vídeo: ${videoId}`);
                const videoUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${youtubeApiKey}`;
                const videoResponse = await fetch(videoUrl);
                const videoData = await videoResponse.json();
                
                if (!videoResponse.ok) {
                    console.error(`[Canais Monitorados] Erro na API do YouTube ao buscar vídeo: ${videoResponse.status}`, videoData);
                } else if (videoData.items && videoData.items.length > 0) {
                    ytChannelId = videoData.items[0].snippet.channelId;
                    console.log(`[Canais Monitorados] Canal ID extraído do vídeo: ${ytChannelId}`);
                } else {
                    console.warn(`[Canais Monitorados] Vídeo não encontrado na API do YouTube: ${videoId}`);
                }
            } catch (videoErr) {
                console.error('[Canais Monitorados] Erro ao extrair canal do vídeo:', videoErr);
            }
        } else {
            console.log(`[Canais Monitorados] URL não é de vídeo, tentando formatos de canal...`);
        }
        
        // Se não encontrou via vídeo, tentar formatos de canal
        if (!ytChannelId) {
            // Regex melhorada para capturar mais formatos, incluindo URLs truncadas
            // Suporta: @handle, /channel/ID, /c/ID, /user/ID, ou ID direto (UC...)
            let match = channelUrl.match(/youtube\.com\/(?:@([\w.-]+)|channel\/([\w-]+)|c\/([\w-]+)|user\/([\w-]+)|(?:embed\/)?([\w-]{24}))/);
            
            // Se não encontrou, tentar formatos alternativos
            if (!match) {
                // Tentar capturar handle mesmo em URLs truncadas ou sem domínio completo
                match = channelUrl.match(/@([\w.-]+)/);
                if (match) {
                    match = [null, match[1], null, null, null, null];
                }
                // Tentar capturar ID de canal direto (UC...)
                else if (channelUrl.match(/^UC[\w-]{22}$/)) {
                    match = [null, null, channelUrl, null, null, null];
                }
            }
            
            if (match) {
                const handle = match[1];
                const legacyId = match[2] || match[3] || match[4] || match[5];

                if (handle) {
                    try {
                        console.log(`[Canais Monitorados] Tentando buscar canal por handle: @${handle}`);
                        // Tentar buscar via channels.list primeiro (mais preciso)
                        const channelsApiUrl = `https://www.googleapis.com/youtube/v3/channels?part=id&forHandle=${encodeURIComponent(handle)}&key=${youtubeApiKey}`;
                        const channelsResponse = await fetch(channelsApiUrl);
                        const channelsData = await channelsResponse.json();
                        
                        if (channelsResponse.ok && channelsData.items && channelsData.items.length > 0) {
                            ytChannelId = channelsData.items[0].id;
                            console.log(`[Canais Monitorados] Canal ID encontrado via channels.list: ${ytChannelId}`);
                        } else {
                            // Fallback: usar search
                            console.log(`[Canais Monitorados] Tentando buscar via search como fallback`);
                            const searchApiUrl = `https://www.googleapis.com/youtube/v3/search?part=id,snippet&q=${encodeURIComponent('@' + handle)}&type=channel&maxResults=1&key=${youtubeApiKey}`;
                            const searchResponse = await fetch(searchApiUrl);
                            const searchData = await searchResponse.json();

                            if (searchResponse.ok && searchData.items && searchData.items.length > 0) {
                                ytChannelId = searchData.items[0].id.channelId;
                                console.log(`[Canais Monitorados] Canal ID encontrado via search: ${ytChannelId}`);
                            } else {
                                console.warn(`[Canais Monitorados] Nenhum canal encontrado para handle: @${handle}`);
                            }
                        }
                    } catch (searchErr) {
                        console.error(`[Canais Monitorados] Erro ao buscar canal por handle:`, searchErr);
                    }
                } else if (legacyId) {
                    // Tentar validar se é um ID de canal válido
                    console.log(`[Canais Monitorados] Tentando validar ID de canal: ${legacyId}`);
                    // IDs de canal do YouTube começam com UC e têm 24 caracteres
                    if (legacyId.length >= 24 || legacyId.startsWith('UC')) {
                        // Verificar se é um ID válido fazendo uma busca
                        try {
                            const validateUrl = `https://www.googleapis.com/youtube/v3/channels?part=id&id=${legacyId}&key=${youtubeApiKey}`;
                            const validateResponse = await fetch(validateUrl);
                            const validateData = await validateResponse.json();
                            
                            if (validateResponse.ok && validateData.items && validateData.items.length > 0) {
                                ytChannelId = legacyId;
                                console.log(`[Canais Monitorados] ID de canal validado: ${ytChannelId}`);
                            } else {
                                console.warn(`[Canais Monitorados] ID de canal não é válido: ${legacyId}`);
                            }
                        } catch (validateErr) {
                            console.error(`[Canais Monitorados] Erro ao validar ID:`, validateErr);
                        }
                    }
                }
            } else {
                console.warn(`[Canais Monitorados] Não foi possível fazer match da URL: ${channelUrl}`);
            }
        }

        if (!ytChannelId) {
            return res.status(400).json({ msg: 'Não foi possível determinar o ID do canal. Verifique se a URL está correta. Formatos suportados: @handle, /channel/ID, /c/ID, /user/ID, ou URL de vídeo.' });
        }

        // Fetch latest, popular, and pinned videos com tratamento de erro robusto
        let latestVideos = [];
        let popularVideos = [];
        let pinnedVideoIds = [];
        
        try {
            const results = await Promise.allSettled([
                getChannelVideosWithDetails(ytChannelId, youtubeApiKey, 'date', 5).catch(err => {
                    console.error('[Canais Monitorados] Erro ao buscar vídeos recentes:', err);
                    return [];
                }),
                getChannelVideosWithDetails(ytChannelId, youtubeApiKey, 'viewCount', 5).catch(err => {
                    console.error('[Canais Monitorados] Erro ao buscar vídeos populares:', err);
                    return [];
                }),
                db.all('SELECT id, youtube_video_id FROM pinned_videos WHERE user_id = ? AND monitored_channel_id = ? ORDER BY pinned_at DESC', [userId, channelId]).catch(err => {
                    console.error('[Canais Monitorados] Erro ao buscar vídeos fixados:', err);
                    return [];
                })
            ]);
            
            if (results[0].status === 'fulfilled') latestVideos = Array.isArray(results[0].value) ? results[0].value : [];
            if (results[1].status === 'fulfilled') popularVideos = Array.isArray(results[1].value) ? results[1].value : [];
            if (results[2].status === 'fulfilled') pinnedVideoIds = Array.isArray(results[2].value) ? results[2].value : [];
        } catch (fetchErr) {
            console.error('[Canais Monitorados] Erro ao buscar vídeos:', fetchErr);
            // Continuar com arrays vazios
        }

        let pinnedVideos = [];
        if (pinnedVideoIds.length > 0) {
            try {
                const idsToFetch = pinnedVideoIds.map(p => p.youtube_video_id).filter(id => id).join(',');
                if (!idsToFetch) {
                    console.warn('[Canais Monitorados] Nenhum ID válido para vídeos fixados');
                } else {
                    const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${idsToFetch}&key=${youtubeApiKey}`;
                    const detailsResponse = await fetch(detailsUrl);
                    
                    if (!detailsResponse.ok) {
                        const errorText = await detailsResponse.text();
                        console.error('[Canais Monitorados] Erro ao buscar vídeos fixados:', detailsResponse.status, errorText.substring(0, 200));
                    } else {
                        const detailsData = await detailsResponse.json();
                        if (detailsData.items && Array.isArray(detailsData.items)) {
                            // Calcular receita e RPM para vídeos fixados
                            pinnedVideos = detailsData.items.map(item => {
                                const pinData = pinnedVideoIds.find(p => p.youtube_video_id === item.id);
                                const views = parseInt(item.statistics.viewCount || 0);
                                // Buscar nicho do canal para calcular RPM correto
                                // Por enquanto usar padrão, pode ser melhorado buscando do user_channels
                                const rpm = getRPMByNiche(null);
                                const estimatedRevenueUSD = (views / 1000) * rpm.usd;
                                const estimatedRevenueBRL = (views / 1000) * rpm.brl;
                                
                                return {
                                    pinId: pinData.id,
                                    videoId: item.id,
                                    title: item.snippet.title,
                                    thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default?.url || '',
                                    views: views,
                                    likes: parseInt(item.statistics.likeCount || 0),
                                    comments: parseInt(item.statistics.commentCount || 0),
                                    estimatedRevenueUSD: estimatedRevenueUSD,
                                    estimatedRevenueBRL: estimatedRevenueBRL,
                                    rpmUSD: rpm.usd,
                                    rpmBRL: rpm.brl
                                };
                            });
                        }
                    }
                }
            } catch (pinnedErr) {
                console.error('[Canais Monitorados] Erro ao processar vídeos fixados:', pinnedErr);
                // Continuar com array vazio
            }
        }
        
        try {
            await db.run('UPDATE monitored_channels SET last_checked = CURRENT_TIMESTAMP WHERE id = ?', [channelId]);
        } catch (updateErr) {
            console.warn('[Canais Monitorados] Erro ao atualizar last_checked:', updateErr);
            // Não bloquear a resposta por causa disso
        }
        
        res.status(200).json({
            latest: Array.isArray(latestVideos) ? latestVideos : [],
            popular: Array.isArray(popularVideos) ? popularVideos : [],
            pinned: Array.isArray(pinnedVideos) ? pinnedVideos : []
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/monitor/:channelId/check]:', err);
        // Sempre retornar JSON, nunca HTML
        res.status(500).json({ msg: err.message || 'Erro ao buscar vídeos do canal.' });
    }
});

app.get('/api/channels/:channelId/pinned', authenticateToken, async (req, res) => {
    const { channelId } = req.params;
    const userId = req.user.id;
    try {
        // Buscar chave do YouTube primeiro, se não encontrar, usar Gemini como fallback
        let youtubeApiKey = null;
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData && youtubeKeyData.api_key) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
            if (!youtubeApiKey && youtubeKeyData.api_key && !youtubeKeyData.api_key.includes(':')) {
                youtubeApiKey = youtubeKeyData.api_key;
            }
        }
        
        // Se não encontrou chave do YouTube, tentar usar Gemini como fallback
        if (!youtubeApiKey) {
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData && geminiKeyData.api_key) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
                if (!youtubeApiKey && geminiKeyData.api_key && !geminiKeyData.api_key.includes(':')) {
                    youtubeApiKey = geminiKeyData.api_key;
                }
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ msg: 'Chave de API do YouTube ou Gemini é necessária. Configure uma delas nas configurações.' });
        }

        const pinnedVideoIds = await db.all('SELECT id, youtube_video_id FROM pinned_videos WHERE user_id = ? AND monitored_channel_id = ? ORDER BY pinned_at DESC', [userId, channelId]);
        
        if (pinnedVideoIds.length === 0) {
            return res.json([]);
        }

        const idsToFetch = pinnedVideoIds.map(p => p.youtube_video_id).join(',');
        const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${idsToFetch}&key=${youtubeApiKey}`;
        const detailsResponse = await fetch(detailsUrl);
        const detailsData = await detailsResponse.json();
        
        let pinnedVideos = [];
        if (detailsResponse.ok && detailsData.items) {
            pinnedVideos = detailsData.items.map(item => {
                const pinData = pinnedVideoIds.find(p => p.youtube_video_id === item.id);
                return {
                    pinId: pinData.id,
                    videoId: item.id,
                    title: item.snippet.title,
                    thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default.url,
                    views: item.statistics.viewCount || 0,
                    likes: item.statistics.likeCount || 0,
                    comments: item.statistics.commentCount || 0,
                };
            });
        }
        res.status(200).json(pinnedVideos);

    } catch (err) {
        console.error('Erro ao buscar vídeos fixados do canal:', err);
        res.status(500).json({ msg: err.message });
    }
});


// === ROTAS DE VÍDEOS (PIN) ===
app.post('/api/videos/pin', authenticateToken, async (req, res) => {
    const { videoId, title, thumbnail, channelId } = req.body;
    const userId = req.user.id;

    if (!videoId || !title || !thumbnail || !channelId) {
        return res.status(400).json({ msg: 'Dados do vídeo e do canal insuficientes.' });
    }

    try {
        const count = await db.get('SELECT COUNT(*) as count FROM pinned_videos WHERE user_id = ? AND monitored_channel_id = ?', [userId, channelId]);
        if (count.count >= 6) {
            return res.status(400).json({ msg: 'Limite de 6 vídeos fixados por canal atingido.' });
        }

        await db.run(
            'INSERT INTO pinned_videos (user_id, monitored_channel_id, youtube_video_id, title, thumbnail_url) VALUES (?, ?, ?, ?, ?)',
            [userId, channelId, videoId, title, thumbnail]
        );
        res.status(201).json({ msg: 'Vídeo fixado com sucesso.' });
    } catch (err) {
        if (err.code === 'SQLITE_CONSTRAINT') {
            return res.status(409).json({ msg: 'Este vídeo já foi fixado neste canal.' });
        }
        console.error("Erro ao fixar vídeo:", err);
        res.status(500).json({ msg: 'Erro no servidor ao fixar vídeo.' });
    }
});

app.delete('/api/videos/unpin/:pinId', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { pinId } = req.params;
    try {
        const result = await db.run(
            'DELETE FROM pinned_videos WHERE id = ? AND user_id = ?',
            [pinId, userId]
        );
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Vídeo fixado não encontrado ou não pertence a este utilizador.' });
        }
        res.status(200).json({ msg: 'Vídeo removido dos fixados.' });
    } catch (err) {
        console.error("Erro ao remover vídeo fixado:", err);
        res.status(500).json({ msg: 'Erro no servidor ao remover vídeo fixado.' });
    }
});
// === ROTAS DE ANALYTICS E TRACKING ===

// Registrar tracking de vídeo publicado
app.post('/api/analytics/track', authenticateToken, async (req, res) => {
    const { analysisId, youtubeVideoId, titleUsed, thumbnailUsed, predictedCtr, predictedViews, publishedAt } = req.body;
    const userId = req.user.id;

    if (!youtubeVideoId || !titleUsed) {
        return res.status(400).json({ msg: 'YouTube Video ID e título são obrigatórios.' });
    }

    try {
        const result = await db.run(
            `INSERT INTO video_tracking (user_id, analysis_id, youtube_video_id, title_used, thumbnail_used, predicted_ctr, predicted_views, published_at, channel_id)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, analysisId || null, youtubeVideoId, titleUsed, thumbnailUsed || null, predictedCtr || null, predictedViews || null, publishedAt || new Date().toISOString(), req.body.channelId || null]
        );
        res.status(201).json({ id: result.lastID, msg: 'Tracking iniciado com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/track]:', err);
        res.status(500).json({ msg: 'Erro ao registrar tracking.' });
    }
});

// Função helper para obter RPM baseado no nicho (usada em múltiplas rotas)
// Função para analisar canal e detectar nicho/subnicho automaticamente
async function analyzeChannelNiche(channelId, channelName, accessToken, userId) {
    try {
        console.log(`[Análise Canal] Analisando canal ${channelId} (${channelName})...`);
        
        // Buscar os 5 vídeos mais recentes do canal (reduzido para ser mais rápido)
        const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${channelId}&order=date&maxResults=5&type=video`;
        const searchResponse = await fetch(searchUrl, {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        
        if (!searchResponse.ok) {
            console.warn(`[Análise Canal] Erro ao buscar vídeos do canal ${channelId}`);
            return { niche: null, subniche: null };
        }
        
        const searchData = await searchResponse.json();
        if (!searchData.items || searchData.items.length === 0) {
            console.warn(`[Análise Canal] Nenhum vídeo encontrado no canal ${channelId}`);
            return { niche: null, subniche: null };
        }
        
        // Extrair títulos dos vídeos
        const videoTitles = searchData.items
            .map(item => item.snippet?.title || '')
            .filter(title => title.length > 0)
            .slice(0, 5); // Limitar a 5 títulos para análise mais rápida
        
        if (videoTitles.length === 0) {
            return { niche: null, subniche: null };
        }
        
        // Buscar chaves de API do usuário para análise
        const keysData = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
        const keys = {};
        keysData.forEach(k => { keys[k.service_name] = decrypt(k.api_key); });
        
        // Tentar usar Gemini, Claude ou OpenAI (nesta ordem)
        let detectedNiche = null;
        let detectedSubniche = null;
        
        const analysisPrompt = `Você é um especialista em análise de conteúdo do YouTube. Analise os seguintes títulos de vídeos de um canal do YouTube e identifique o NICHO e SUBNICHE do canal.

Títulos dos vídeos:
${videoTitles.map((title, i) => `${i + 1}. ${title}`).join('\n')}

Nome do canal: ${channelName}

Analise os padrões, temas e assuntos recorrentes nos títulos para identificar:
- O NICHO principal (categoria ampla: Entretenimento, Educação, Tecnologia, Finanças, Gaming, etc.)
- O SUBNICHE específico (área mais específica dentro do nicho: Gaming FPS, Finanças Pessoais, Programação Web, etc.)

IMPORTANTE: Responda APENAS com um objeto JSON válido, sem nenhum texto adicional antes ou depois:
{
  "niche": "Nome do nicho principal",
  "subniche": "Nome do subnicho específico ou null se não houver subnicho claro"
}

Seja específico e preciso. Se não conseguir identificar claramente, use "Entretenimento" como nicho padrão e deixe subniche como null.`;

        // Tentar Gemini primeiro
        if (keys.gemini) {
            try {
                const response = await callGeminiAPI(analysisPrompt, keys.gemini, 'gemini-2.0-flash');
                const parsed = parseAIResponse(response.titles, 'gemini');
                if (parsed.niche) {
                    detectedNiche = parsed.niche;
                    detectedSubniche = parsed.subniche || null;
                    console.log(`[Análise Canal] Nicho detectado via Gemini: ${detectedNiche} / ${detectedSubniche}`);
                    return { niche: detectedNiche, subniche: detectedSubniche };
                }
            } catch (err) {
                console.warn(`[Análise Canal] Erro ao usar Gemini: ${err.message}`);
            }
        }
        
        // Tentar Claude
        if (keys.claude) {
            try {
                const response = await callClaudeAPI(analysisPrompt, keys.claude, 'claude-3-5-haiku-20241022');
                const parsed = parseAIResponse(response.titles, 'claude');
                if (parsed.niche) {
                    detectedNiche = parsed.niche;
                    detectedSubniche = parsed.subniche || null;
                    console.log(`[Análise Canal] Nicho detectado via Claude: ${detectedNiche} / ${detectedSubniche}`);
                    return { niche: detectedNiche, subniche: detectedSubniche };
                }
            } catch (err) {
                console.warn(`[Análise Canal] Erro ao usar Claude: ${err.message}`);
            }
        }
        
        // Tentar OpenAI
        if (keys.openai) {
            try {
                const response = await callOpenAIAPI(analysisPrompt, keys.openai, 'gpt-4o-mini');
                const parsed = parseAIResponse(response.titles, 'openai');
                if (parsed.niche) {
                    detectedNiche = parsed.niche;
                    detectedSubniche = parsed.subniche || null;
                    console.log(`[Análise Canal] Nicho detectado via OpenAI: ${detectedNiche} / ${detectedSubniche}`);
                    return { niche: detectedNiche, subniche: detectedSubniche };
                }
            } catch (err) {
                console.warn(`[Análise Canal] Erro ao usar OpenAI: ${err.message}`);
            }
        }
        
        // Se nenhuma IA funcionou, retornar null
        console.warn(`[Análise Canal] Não foi possível detectar nicho para o canal ${channelId}`);
        return { niche: null, subniche: null };
        
    } catch (err) {
        console.error(`[Análise Canal] Erro ao analisar canal ${channelId}:`, err.message);
        return { niche: null, subniche: null };
    }
}

function getRPMByNiche(niche) {
    if (!niche) return { usd: 2.0, brl: 11.0 }; // Padrão: Entretenimento
    
    const nicheLower = niche.toLowerCase();
    
    // RPMs reais por nicho (USD por 1000 views) - baseado em dados do mercado
    const rpmMap = {
        'finança': { usd: 15.0, brl: 82.5 },
        'financeiro': { usd: 15.0, brl: 82.5 },
        'investimento': { usd: 18.0, brl: 99.0 },
        'investimentos': { usd: 18.0, brl: 99.0 },
        'educação financeira': { usd: 12.0, brl: 66.0 },
        'tecnologia': { usd: 7.0, brl: 38.5 },
        'tech': { usd: 7.0, brl: 38.5 },
        'programação': { usd: 8.0, brl: 44.0 },
        'gaming': { usd: 3.5, brl: 19.25 },
        'jogos': { usd: 3.5, brl: 19.25 },
        'game': { usd: 3.5, brl: 19.25 },
        'educação': { usd: 5.0, brl: 27.5 },
        'educacional': { usd: 5.0, brl: 27.5 },
        'culinária': { usd: 3.0, brl: 16.5 },
        'receitas': { usd: 3.0, brl: 16.5 },
        'fitness': { usd: 4.0, brl: 22.0 },
        'saúde': { usd: 4.5, brl: 24.75 },
        'entretenimento': { usd: 2.0, brl: 11.0 },
        'vlogs': { usd: 2.5, brl: 13.75 },
        'viagens': { usd: 4.0, brl: 22.0 },
        'história': { usd: 3.5, brl: 19.25 },
        'ciência': { usd: 5.5, brl: 30.25 },
        'negócios': { usd: 10.0, brl: 55.0 },
        'empreendedorismo': { usd: 9.0, brl: 49.5 },
        'marketing': { usd: 8.0, brl: 44.0 },
        'vendas': { usd: 9.0, brl: 49.5 }
    };
    
    // Buscar nicho correspondente (busca parcial)
    for (const [key, value] of Object.entries(rpmMap)) {
        if (nicheLower.includes(key)) {
            return value;
        }
    }
    
    // Se não encontrar, retornar padrão baseado em palavras-chave
    if (nicheLower.includes('finance') || nicheLower.includes('dinheiro') || nicheLower.includes('invest')) {
        return { usd: 12.0, brl: 66.0 };
    }
    if (nicheLower.includes('tech') || nicheLower.includes('program') || nicheLower.includes('software')) {
        return { usd: 7.0, brl: 38.5 };
    }
    if (nicheLower.includes('game') || nicheLower.includes('jogo')) {
        return { usd: 3.5, brl: 19.25 };
    }
    if (nicheLower.includes('educ') || nicheLower.includes('curso') || nicheLower.includes('aprend')) {
        return { usd: 5.0, brl: 27.5 };
    }
    
    // Padrão: Entretenimento
    return { usd: 2.0, brl: 11.0 };
}

// Atualizar métricas de vídeo (buscar do YouTube)
app.post('/api/analytics/update/:trackingId', authenticateToken, async (req, res) => {
    const { trackingId } = req.params;
    const userId = req.user.id;

    try {
        // Buscar tracking com informações do canal
        const tracking = await db.get(`
            SELECT vt.youtube_video_id, vt.channel_id, uc.niche 
            FROM video_tracking vt
            LEFT JOIN user_channels uc ON vt.channel_id = uc.id
            WHERE vt.id = ? AND vt.user_id = ?
        `, [trackingId, userId]);
        
        if (!tracking) {
            return res.status(404).json({ msg: 'Tracking não encontrado.' });
        }

        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        if (!geminiKeyData) {
            return res.status(400).json({ msg: 'Chave de API do Gemini é necessária.' });
        }
        const geminiApiKey = decrypt(geminiKeyData.api_key);

        let videoDetails;
        try {
            videoDetails = await callYouTubeDataAPI(tracking.youtube_video_id, geminiApiKey);
        } catch (apiErr) {
            console.error('[Analytics Update] Erro ao buscar dados do YouTube:', apiErr.message);
            return res.status(500).json({ msg: `Erro ao buscar dados do YouTube: ${apiErr.message}` });
        }
        
        // Calcular CTR estimado (YouTube não fornece CTR diretamente, então estimamos)
        // Usar uma fórmula mais realista baseada nas views
        // Vídeos com muitas views geralmente têm CTR mais baixo, vídeos novos podem ter CTR mais alto
        const views = parseInt(videoDetails.views) || 0;
        let estimatedCtr = 0;
        if (views > 0) {
            // Fórmula mais realista: CTR diminui conforme views aumentam
            // Vídeos com 1K views: ~15% CTR, 10K views: ~10% CTR, 100K views: ~5% CTR, 1M views: ~3% CTR
            if (views < 10000) {
                estimatedCtr = 15 - (views / 10000) * 5; // 15% a 10%
            } else if (views < 100000) {
                estimatedCtr = 10 - ((views - 10000) / 90000) * 5; // 10% a 5%
            } else if (views < 1000000) {
                estimatedCtr = 5 - ((views - 100000) / 900000) * 2; // 5% a 3%
            } else {
                estimatedCtr = Math.max(2, 3 - ((views - 1000000) / 10000000) * 1); // 3% a 2%
            }
            estimatedCtr = Math.max(2, Math.min(30, estimatedCtr)); // Limitar entre 2% e 30%
        }
        
        // Calcular receita baseada no RPM do nicho do canal
        const rpm = getRPMByNiche(tracking.niche);
        const estimatedRevenue = (views / 1000) * rpm.usd;

        await db.run(
            `UPDATE video_tracking 
             SET actual_views = ?, actual_likes = ?, actual_comments = ?, actual_ctr = ?, revenue_estimate = ?, last_updated = CURRENT_TIMESTAMP
             WHERE id = ?`,
            [videoDetails.views, videoDetails.likes, videoDetails.comments, estimatedCtr, estimatedRevenue, trackingId]
        );

        // Criar snapshot
        await db.run(
            `INSERT INTO analytics_snapshots (user_id, video_tracking_id, views, likes, comments, ctr)
             VALUES (?, ?, ?, ?, ?, ?)`,
            [userId, trackingId, videoDetails.views, videoDetails.likes, videoDetails.comments, estimatedCtr]
        );

        res.status(200).json({ 
            views: videoDetails.views,
            likes: videoDetails.likes,
            comments: videoDetails.comments,
            ctr: estimatedCtr,
            revenue: estimatedRevenue
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/update]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar métricas.' });
    }
});

// Obter dashboard de analytics
app.get('/api/analytics/dashboard', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    console.log(`[Analytics Dashboard] Requisição recebida para userId: ${userId}`);

    try {
        if (!db) {
            console.error('[Analytics Dashboard] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        // Verificar se a tabela existe e tem dados
        let stats = {
            total_videos: 0,
            total_views: 0,
            total_likes: 0,
            total_comments: 0,
            avg_ctr: 0,
            total_revenue: 0,
            viral_videos: 0
        };
        
        try {
            // Verificar se a tabela existe primeiro
            const tableCheck = await db.get(`
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='video_tracking'
            `);
            
            if (tableCheck) {
                stats = await db.get(`
                    SELECT 
                        COUNT(*) as total_videos,
                        COALESCE(SUM(actual_views), 0) as total_views,
                        COALESCE(SUM(actual_likes), 0) as total_likes,
                        COALESCE(SUM(actual_comments), 0) as total_comments,
                        COALESCE(AVG(actual_ctr), 0) as avg_ctr,
                        COALESCE(SUM(revenue_estimate), 0) as total_revenue,
                        COUNT(CASE WHEN actual_views >= 1000000 THEN 1 END) as viral_videos
                    FROM video_tracking
                    WHERE user_id = ?
                `, [userId]) || stats;
            }
            console.log(`[Analytics Dashboard] Stats encontrados:`, stats);
        } catch (dbErr) {
            console.error('[Analytics Dashboard] Erro ao buscar stats:', dbErr);
            // Manter valores padrão
        }

        let recentVideos = [];
        try {
            // Verificar se a tabela existe primeiro
            const tableCheck = await db.get(`
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='video_tracking'
            `);
            
            if (tableCheck) {
                recentVideos = await db.all(`
                    SELECT vt.id, vt.youtube_video_id, vt.title_used, vt.actual_views, vt.actual_ctr, vt.revenue_estimate, 
                           vt.published_at, vt.tracked_at, vt.channel_id, uc.channel_name
                    FROM video_tracking vt
                    LEFT JOIN user_channels uc ON vt.channel_id = uc.id
                    WHERE vt.user_id = ?
                    ORDER BY COALESCE(vt.published_at, vt.tracked_at) DESC
                    LIMIT 50
                `, [userId]) || [];
            }
            console.log(`[Analytics Dashboard] Vídeos recentes encontrados:`, recentVideos.length);
        } catch (dbErr) {
            console.error('[Analytics Dashboard] Erro ao buscar vídeos recentes:', dbErr);
            recentVideos = [];
        }

        // Usar a função getRPMByNiche definida globalmente acima
        
        // Calcular RPM por canal (baseado no nicho)
        let totalRPMUSD = 0;
        let totalRPMBRL = 0;
        let channelsCount = 0;
        
        try {
            const channelsWithNiche = await db.all(`
                SELECT DISTINCT uc.niche 
                FROM user_channels uc
                INNER JOIN video_tracking vt ON vt.channel_id = uc.id
                WHERE uc.user_id = ? AND uc.niche IS NOT NULL AND uc.niche != ''
            `, [userId]);
            
            if (channelsWithNiche && channelsWithNiche.length > 0) {
                channelsWithNiche.forEach(ch => {
                    const rpm = getRPMByNiche(ch.niche);
                    totalRPMUSD += rpm.usd;
                    totalRPMBRL += rpm.brl;
                    channelsCount++;
                });
                // Média dos RPMs
                totalRPMUSD = totalRPMUSD / channelsCount;
                totalRPMBRL = totalRPMBRL / channelsCount;
            } else {
                // Se não há canais com nicho, usar padrão
                const defaultRPM = getRPMByNiche(null);
                totalRPMUSD = defaultRPM.usd;
                totalRPMBRL = defaultRPM.brl;
            }
        } catch (rpmErr) {
            console.error('[Analytics] Erro ao calcular RPM por nicho:', rpmErr);
            const defaultRPM = getRPMByNiche(null);
            totalRPMUSD = defaultRPM.usd;
            totalRPMBRL = defaultRPM.brl;
        }
        
        // Calcular receita estimada baseada no RPM real do nicho
        const totalViews = parseInt(stats?.total_views || 0);
        const usdToBrlRate = 5.50;
        
        // Calcular receita total: somar receita do banco + receita estimada baseada no RPM do nicho
        // Se há receita no banco, usar ela; senão, calcular baseado no RPM do nicho
        let totalRevenueUSD = parseFloat(stats?.total_revenue || 0);
        
        // Se não há receita no banco mas há views, calcular baseado no RPM do nicho
        if (totalRevenueUSD === 0 && totalViews > 0 && totalRPMUSD > 0) {
            totalRevenueUSD = (totalViews * totalRPMUSD) / 1000;
        }
        // Se há receita no banco, recalcular baseado no RPM do nicho para atualizar
        else if (totalViews > 0 && totalRPMUSD > 0) {
            // Recalcular receita baseada no RPM atual do nicho (mais preciso)
            totalRevenueUSD = (totalViews * totalRPMUSD) / 1000;
        }
        
        const totalRevenueBRL = totalRevenueUSD * usdToBrlRate;
        
        // RPM final (usar o calculado baseado no nicho, ou calcular a partir da receita se houver)
        let rpmUSD = totalRPMUSD;
        let rpmBRL = totalRPMBRL;
        
        // Se não há RPM calculado mas há receita, calcular RPM a partir da receita
        if (rpmUSD === 0 && totalRevenueUSD > 0 && totalViews > 0) {
            rpmUSD = (totalRevenueUSD / totalViews) * 1000;
            rpmBRL = (totalRevenueBRL / totalViews) * 1000;
        }

        // Garantir que recentVideos é sempre um array
        const recentVideosArray = Array.isArray(recentVideos) ? recentVideos : [];
        
        const response = {
            stats: {
                totalVideos: parseInt(stats?.total_videos || 0),
                totalViews: totalViews,
                totalLikes: parseInt(stats?.total_likes || 0),
                totalComments: parseInt(stats?.total_comments || 0),
                avgCtr: parseFloat(stats?.avg_ctr || 0),
                totalRevenue: totalRevenueUSD,
                totalRevenueBRL: totalRevenueBRL,
                rpmUSD: rpmUSD,
                rpmBRL: rpmBRL,
                viralVideos: parseInt(stats?.viral_videos || 0)
            },
            recentVideos: recentVideosArray
        };

        console.log(`[Analytics Dashboard] Enviando resposta:`, JSON.stringify(response).substring(0, 200));
        res.status(200).json(response);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/dashboard]:', err);
        // Sempre retornar JSON válido, nunca HTML
        res.status(500).json({ 
            stats: {
                totalVideos: 0,
                totalViews: 0,
                totalLikes: 0,
                totalComments: 0,
                avgCtr: 0,
                totalRevenue: 0,
                totalRevenueBRL: 0,
                rpmUSD: 2.0,
                rpmBRL: 11.0,
                viralVideos: 0
            },
            recentVideos: [],
            error: err.message || 'Erro no servidor ao buscar dados do dashboard.'
        });
    }
});

// Excluir vídeo do tracking
app.delete('/api/analytics/track/:trackingId', authenticateToken, async (req, res) => {
    const { trackingId } = req.params;
    const userId = req.user.id;

    try {
        if (!db) {
            console.error('[Analytics Delete] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        // Verificar se o tracking pertence ao usuário
        const tracking = await db.get('SELECT id FROM video_tracking WHERE id = ? AND user_id = ?', [trackingId, userId]);
        if (!tracking) {
            return res.status(404).json({ msg: 'Tracking não encontrado ou não pertence a este usuário.' });
        }

        // Excluir snapshots relacionados primeiro (devido à foreign key)
        await db.run('DELETE FROM analytics_snapshots WHERE video_tracking_id = ?', [trackingId]);

        // Excluir o tracking
        const result = await db.run('DELETE FROM video_tracking WHERE id = ? AND user_id = ?', [trackingId, userId]);
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Tracking não encontrado.' });
        }

        console.log(`[Analytics Delete] Vídeo ${trackingId} excluído pelo usuário ${userId}`);
        res.status(200).json({ msg: 'Vídeo excluído do tracking com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/track/:trackingId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir vídeo do tracking.' });
    }
});
// === NOVAS FUNCIONALIDADES DE ANALYTICS E VALIDAÇÃO ===

// 1. ROI Calculator - Calcular receita total gerada pelos vídeos
app.get('/api/analytics/roi', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { startDate, endDate } = req.query;

    try {
        let query = `
            SELECT 
                COUNT(*) as total_videos,
                SUM(actual_views) as total_views,
                SUM(revenue_estimate) as total_revenue,
                AVG(actual_ctr) as avg_ctr,
                SUM(actual_likes) as total_likes,
                SUM(actual_comments) as total_comments
            FROM video_tracking
            WHERE user_id = ? AND actual_views > 0
        `;
        const params = [userId];

        if (startDate) {
            query += ' AND published_at >= ?';
            params.push(startDate);
        }
        if (endDate) {
            query += ' AND published_at <= ?';
            params.push(endDate);
        }

        const stats = await db.get(query, params);

        // Calcular ROI (assumindo que cada análise custa $0.50 ou similar)
        const costPerAnalysis = 0.50;
        const totalCost = (stats.total_videos || 0) * costPerAnalysis;
        const totalRevenue = stats.total_revenue || 0;
        const roi = totalCost > 0 ? ((totalRevenue - totalCost) / totalCost) * 100 : 0;

        res.status(200).json({
            totalVideos: stats.total_videos || 0,
            totalViews: stats.total_views || 0,
            totalRevenue: totalRevenue,
            totalCost: totalCost,
            roi: roi.toFixed(2),
            avgCtr: (stats.avg_ctr || 0).toFixed(2),
            totalLikes: stats.total_likes || 0,
            totalComments: stats.total_comments || 0,
            netProfit: (totalRevenue - totalCost).toFixed(2)
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/roi]:', err);
        res.status(500).json({ msg: 'Erro ao calcular ROI.' });
    }
});

// 2. Leaderboard - Melhores títulos/thumbnails por views
app.get('/api/analytics/leaderboard', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { type = 'all', limit = 10 } = req.query; // type: 'titles', 'thumbnails', 'all'

    try {
        let leaderboard = [];

        if (type === 'titles' || type === 'all') {
            const topTitles = await db.all(`
                SELECT 
                    title_used as item,
                    'title' as type,
                    actual_views as views,
                    actual_ctr as ctr,
                    revenue_estimate as revenue,
                    published_at
                FROM video_tracking
                WHERE user_id = ? AND title_used IS NOT NULL AND actual_views > 0
                ORDER BY actual_views DESC
                LIMIT ?
            `, [userId, parseInt(limit)]);
            leaderboard = leaderboard.concat(topTitles);
        }

        if (type === 'thumbnails' || type === 'all') {
            const topThumbnails = await db.all(`
                SELECT 
                    thumbnail_used as item,
                    'thumbnail' as type,
                    actual_views as views,
                    actual_ctr as ctr,
                    revenue_estimate as revenue,
                    published_at
                FROM video_tracking
                WHERE user_id = ? AND thumbnail_used IS NOT NULL AND actual_views > 0
                ORDER BY actual_views DESC
                LIMIT ?
            `, [userId, parseInt(limit)]);
            leaderboard = leaderboard.concat(topThumbnails);
        }

        // Ordenar por views e limitar
        leaderboard.sort((a, b) => (b.views || 0) - (a.views || 0));
        leaderboard = leaderboard.slice(0, parseInt(limit));

        res.status(200).json({ leaderboard });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/leaderboard]:', err);
        res.status(500).json({ msg: 'Erro ao buscar leaderboard.' });
    }
});

// 3. Heatmap de Sucesso - Fórmulas de título que funcionam melhor por nicho
app.get('/api/analytics/heatmap', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        // Buscar títulos da biblioteca com suas métricas de sucesso
        // Nota: JOIN pode não funcionar se não houver correspondência exata, então fazemos query separada
        const heatmapData = await db.all(`
            SELECT 
                COALESCE(uc.niche, 'Geral') as niche,
                COALESCE(uc.subniche, '') as subniche,
                COUNT(*) as usage_count,
                AVG(vt.actual_views) as avg_views,
                AVG(vt.actual_ctr) as avg_ctr,
                MAX(vt.actual_views) as max_views
            FROM video_tracking vt
            LEFT JOIN user_channels uc ON vt.channel_id = uc.id
            WHERE vt.user_id = ? AND vt.actual_views > 0
            GROUP BY COALESCE(uc.niche, 'Geral'), COALESCE(uc.subniche, '')
            ORDER BY avg_views DESC
        `, [userId]);

        // Também buscar dados da biblioteca de títulos
        const libraryData = await db.all(`
            SELECT 
                niche,
                subniche,
                formula_type,
                COUNT(*) as count,
                AVG(original_views) as avg_views,
                AVG(original_ctr) as avg_ctr
            FROM viral_titles_library
            WHERE user_id = ? AND original_views > 0
            GROUP BY niche, subniche, formula_type
        `, [userId]);

        res.status(200).json({
            tracking: heatmapData,
            library: libraryData
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/heatmap]:', err);
        res.status(500).json({ msg: 'Erro ao buscar heatmap.' });
    }
});

// 4. Score Predictor - IA prevê potencial de views antes de publicar
app.post('/api/analytics/predict-score', authenticateToken, async (req, res) => {
    const { title, thumbnailDescription, niche, subniche } = req.body;
    const userId = req.user.id;

    if (!title) {
        return res.status(400).json({ msg: 'Título é obrigatório.' });
    }

    try {
        // Buscar histórico de sucesso do usuário
        const userHistory = await db.all(`
            SELECT 
                AVG(actual_views) as avg_views,
                AVG(actual_ctr) as avg_ctr,
                COUNT(*) as total_videos
            FROM video_tracking
            WHERE user_id = ? AND actual_views > 0
        `, [userId]);

        // Buscar títulos similares na biblioteca
        const similarTitles = await db.all(`
            SELECT 
                original_views,
                original_ctr,
                viral_score
            FROM viral_titles_library
            WHERE user_id = ? AND niche = ? AND original_views > 0
            ORDER BY original_views DESC
            LIMIT 10
        `, [userId, niche || '']);

        // Calcular score baseado em múltiplos fatores
        let predictedViews = 0;
        let predictedCtr = 0;
        let score = 0;

        // Fator 1: Histórico do usuário
        if (userHistory[0] && userHistory[0].total_videos > 0) {
            predictedViews = userHistory[0].avg_views || 0;
            predictedCtr = userHistory[0].avg_ctr || 0;
        }

        // Fator 2: Títulos similares
        if (similarTitles.length > 0) {
            const avgSimilarViews = similarTitles.reduce((sum, t) => sum + (t.original_views || 0), 0) / similarTitles.length;
            const avgSimilarCtr = similarTitles.reduce((sum, t) => sum + (t.original_ctr || 0), 0) / similarTitles.length;
            
            // Média ponderada: 60% histórico do usuário, 40% títulos similares
            predictedViews = (predictedViews * 0.6) + (avgSimilarViews * 0.4);
            predictedCtr = (predictedCtr * 0.6) + (avgSimilarCtr * 0.4);
        }

        // Fator 3: Análise do título (comprimento, palavras-chave, etc)
        const titleLength = title.length;
        const hasNumbers = /\d/.test(title);
        const hasQuestion = title.includes('?');
        const hasExclamation = title.includes('!');
        const powerWords = ['SECRETO', 'REVELADO', 'ESCONDIDO', 'PROIBIDO', 'CHOCANTE', 'INCRÍVEL', 'NUNCA VISTO'];
        const hasPowerWords = powerWords.some(word => title.toUpperCase().includes(word));

        // Ajustar score baseado em características do título
        let titleScore = 50; // Base
        if (titleLength >= 40 && titleLength <= 60) titleScore += 10; // Tamanho ideal
        if (hasNumbers) titleScore += 5;
        if (hasQuestion) titleScore += 8;
        if (hasExclamation) titleScore += 5;
        if (hasPowerWords) titleScore += 15;

        // Calcular score final (0-100)
        score = Math.min(100, Math.max(0, titleScore + (predictedCtr * 2)));

        // Ajustar views previstas baseado no score
        predictedViews = predictedViews * (score / 50);

        res.status(200).json({
            predictedViews: Math.round(predictedViews),
            predictedCtr: predictedCtr.toFixed(2),
            score: Math.round(score),
            factors: {
                titleLength,
                hasNumbers,
                hasQuestion,
                hasExclamation,
                hasPowerWords,
                userHistory: userHistory[0] || null,
                similarTitlesCount: similarTitles.length
            }
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/predict-score]:', err);
        res.status(500).json({ msg: 'Erro ao prever score.' });
    }
});

// 5. Validação de Título
app.post('/api/analytics/validate-title', authenticateToken, async (req, res) => {
    const { title, niche } = req.body;

    if (!title) {
        return res.status(400).json({ msg: 'Título é obrigatório.' });
    }

    try {
        const validations = {
            length: {
                value: title.length,
                min: 30,
                max: 70,
                ideal: 40,
                passed: title.length >= 30 && title.length <= 70,
                score: title.length >= 40 && title.length <= 60 ? 100 : title.length >= 30 && title.length <= 70 ? 70 : 50
            },
            hasNumbers: {
                value: /\d/.test(title),
                passed: /\d/.test(title),
                score: /\d/.test(title) ? 100 : 50,
                tip: 'Números aumentam CTR em até 20%'
            },
            hasQuestion: {
                value: title.includes('?'),
                passed: title.includes('?'),
                score: title.includes('?') ? 100 : 60,
                tip: 'Perguntas geram curiosidade'
            },
            hasPowerWords: {
                value: ['SECRETO', 'REVELADO', 'ESCONDIDO', 'PROIBIDO', 'CHOCANTE', 'INCRÍVEL', 'NUNCA VISTO', 'EXCLUSIVO'].some(w => title.toUpperCase().includes(w)),
                passed: ['SECRETO', 'REVELADO', 'ESCONDIDO', 'PROIBIDO', 'CHOCANTE', 'INCRÍVEL', 'NUNCA VISTO', 'EXCLUSIVO'].some(w => title.toUpperCase().includes(w)),
                score: ['SECRETO', 'REVELADO', 'ESCONDIDO', 'PROIBIDO', 'CHOCANTE', 'INCRÍVEL', 'NUNCA VISTO', 'EXCLUSIVO'].some(w => title.toUpperCase().includes(w)) ? 100 : 50,
                tip: 'Palavras poderosas aumentam engajamento'
            },
            capitalization: {
                value: title.split(' ').filter(w => w[0] && w[0] === w[0].toUpperCase()).length,
                passed: title.split(' ').filter(w => w[0] && w[0] === w[0].toUpperCase()).length >= 3,
                score: title.split(' ').filter(w => w[0] && w[0] === w[0].toUpperCase()).length >= 3 ? 100 : 70,
                tip: 'Capitalização adequada melhora legibilidade'
            }
        };

        const totalScore = Object.values(validations).reduce((sum, v) => sum + (v.score || 0), 0) / Object.keys(validations).length;
        const passedCount = Object.values(validations).filter(v => v.passed).length;
        const totalChecks = Object.keys(validations).length;

        res.status(200).json({
            title,
            validations,
            overallScore: Math.round(totalScore),
            passedChecks: `${passedCount}/${totalChecks}`,
            recommendation: totalScore >= 80 ? 'excellent' : totalScore >= 60 ? 'good' : 'needs_improvement',
            tips: Object.values(validations).filter(v => !v.passed && v.tip).map(v => v.tip)
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/validate-title]:', err);
        res.status(500).json({ msg: 'Erro ao validar título.' });
    }
});

// 6. Validação de Thumbnail (análise básica)
app.post('/api/analytics/validate-thumbnail', authenticateToken, async (req, res) => {
    const { thumbnailDescription, niche } = req.body;

    if (!thumbnailDescription) {
        return res.status(400).json({ msg: 'Descrição da thumbnail é obrigatória.' });
    }

    try {
        const validations = {
            hasFace: {
                value: /face|rosto|pessoa|person|human/i.test(thumbnailDescription),
                passed: /face|rosto|pessoa|person|human/i.test(thumbnailDescription),
                score: /face|rosto|pessoa|person|human/i.test(thumbnailDescription) ? 100 : 50,
                tip: 'Rostos humanos aumentam CTR em até 30%'
            },
            hasText: {
                value: /text|texto|phrase|frase|word|palavra/i.test(thumbnailDescription),
                passed: /text|texto|phrase|frase|word|palavra/i.test(thumbnailDescription),
                score: /text|texto|phrase|frase|word|palavra/i.test(thumbnailDescription) ? 100 : 60,
                tip: 'Texto na thumbnail aumenta cliques'
            },
            hasContrast: {
                value: /contrast|contraste|bright|brilhante|vibrant|vibrante|color/i.test(thumbnailDescription),
                passed: /contrast|contraste|bright|brilhante|vibrant|vibrante|color/i.test(thumbnailDescription),
                score: /contrast|contraste|bright|brilhante|vibrant|vibrante|color/i.test(thumbnailDescription) ? 100 : 50,
                tip: 'Alto contraste melhora visibilidade'
            },
            hasEmotion: {
                value: /emotion|emoção|expression|expressão|surprised|surpreso|shocked|chocado|excited|animado/i.test(thumbnailDescription),
                passed: /emotion|emoção|expression|expressão|surprised|surpreso|shocked|chocado|excited|animado/i.test(thumbnailDescription),
                score: /emotion|emoção|expression|expressão|surprised|surpreso|shocked|chocado|excited|animado/i.test(thumbnailDescription) ? 100 : 50,
                tip: 'Expressões emocionais geram mais cliques'
            },
            composition: {
                value: 'center' in thumbnailDescription.toLowerCase() || 'rule of thirds' in thumbnailDescription.toLowerCase(),
                passed: 'center' in thumbnailDescription.toLowerCase() || 'rule of thirds' in thumbnailDescription.toLowerCase(),
                score: 'center' in thumbnailDescription.toLowerCase() || 'rule of thirds' in thumbnailDescription.toLowerCase() ? 100 : 70,
                tip: 'Composição adequada melhora impacto visual'
            }
        };

        const totalScore = Object.values(validations).reduce((sum, v) => sum + (v.score || 0), 0) / Object.keys(validations).length;
        const passedCount = Object.values(validations).filter(v => v.passed).length;
        const totalChecks = Object.keys(validations).length;

        res.status(200).json({
            thumbnailDescription,
            validations,
            overallScore: Math.round(totalScore),
            passedChecks: `${passedCount}/${totalChecks}`,
            recommendation: totalScore >= 80 ? 'excellent' : totalScore >= 60 ? 'good' : 'needs_improvement',
            tips: Object.values(validations).filter(v => !v.passed && v.tip).map(v => v.tip)
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/validate-thumbnail]:', err);
        res.status(500).json({ msg: 'Erro ao validar thumbnail.' });
    }
});

// 7. Comparação com Competidores
app.post('/api/analytics/compare-competitors', authenticateToken, async (req, res) => {
    const { title, thumbnailDescription, niche, competitorVideoIds } = req.body;
    const userId = req.user.id;

    if (!title || !competitorVideoIds || !Array.isArray(competitorVideoIds)) {
        return res.status(400).json({ msg: 'Título e lista de IDs de vídeos competidores são obrigatórios.' });
    }

    try {
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        if (!geminiKeyData) {
            return res.status(400).json({ msg: 'Chave de API do Gemini é necessária.' });
        }
        const geminiApiKey = decrypt(geminiKeyData.api_key);

        // Buscar dados dos vídeos competidores
        const competitorData = await Promise.all(
            competitorVideoIds.slice(0, 5).map(async (videoId) => {
                try {
                    const data = await callYouTubeDataAPI(videoId, geminiApiKey);
                    return {
                        videoId,
                        title: data.title,
                        views: data.views,
                        likes: data.likes,
                        comments: data.comments,
                        days: data.days
                    };
                } catch (err) {
                    console.error(`Erro ao buscar vídeo ${videoId}:`, err);
                    return null;
                }
            })
        );

        const validCompetitors = competitorData.filter(c => c !== null);

        if (validCompetitors.length === 0) {
            return res.status(400).json({ msg: 'Nenhum vídeo competidor válido encontrado.' });
        }

        // Calcular métricas médias dos competidores
        const avgViews = validCompetitors.reduce((sum, c) => sum + (c.views || 0), 0) / validCompetitors.length;
        const avgLikes = validCompetitors.reduce((sum, c) => sum + (c.likes || 0), 0) / validCompetitors.length;
        const avgComments = validCompetitors.reduce((sum, c) => sum + (c.comments || 0), 0) / validCompetitors.length;

        // Comparar características do título
        const yourTitleLength = title.length;
        const competitorTitleLengths = validCompetitors.map(c => (c.title || '').length);
        const avgCompetitorTitleLength = competitorTitleLengths.reduce((sum, l) => sum + l, 0) / competitorTitleLengths.length;

        // Análise comparativa
        const comparison = {
            titleLength: {
                yours: yourTitleLength,
                average: Math.round(avgCompetitorTitleLength),
                difference: yourTitleLength - avgCompetitorTitleLength,
                better: Math.abs(yourTitleLength - 50) < Math.abs(avgCompetitorTitleLength - 50)
            },
            performance: {
                avgCompetitorViews: Math.round(avgViews),
                avgCompetitorLikes: Math.round(avgLikes),
                avgCompetitorComments: Math.round(avgComments)
            },
            recommendations: []
        };

        if (yourTitleLength < 30) {
            comparison.recommendations.push('Seu título é muito curto. Títulos entre 40-60 caracteres performam melhor.');
        } else if (yourTitleLength > 70) {
            comparison.recommendations.push('Seu título é muito longo. Considere reduzir para melhorar CTR.');
        }

        if (avgViews > 100000) {
            comparison.recommendations.push(`Competidores têm média de ${Math.round(avgViews / 1000)}K views. Considere estudar seus títulos.`);
        }

        res.status(200).json({
            yourTitle: title,
            competitors: validCompetitors,
            comparison,
            score: comparison.titleLength.better ? 75 : 50
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/compare-competitors]:', err);
        res.status(500).json({ msg: 'Erro ao comparar com competidores.' });
    }
});

// === ROTAS DE BIBLIOTECA DE TÍTULOS VIRAIS ===

// Adicionar título à biblioteca (automático quando análise é feita)
app.post('/api/library/titles', authenticateToken, async (req, res) => {
    const { title, niche, subniche, originalViews, originalCtr, formulaType, keywords, viralScore } = req.body;
    const userId = req.user.id;

    if (!title) {
        return res.status(400).json({ msg: 'Título é obrigatório.' });
    }

    try {
        const result = await db.run(
            `INSERT INTO viral_titles_library (user_id, title, niche, subniche, original_views, original_ctr, formula_type, keywords, viral_score)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, title, niche || null, subniche || null, originalViews || null, originalCtr || null, formulaType || null, keywords || null, viralScore || null]
        );
        res.status(201).json({ id: result.lastID, msg: 'Título adicionado à biblioteca.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles]:', err);
        res.status(500).json({ msg: 'Erro ao adicionar título à biblioteca.' });
    }
});
// Buscar títulos da biblioteca
app.get('/api/library/titles', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { niche, subniche, minViews, minCtr, favorite, search } = req.query;
    console.log(`[Biblioteca Titles] Requisição recebida para userId: ${userId}`, { niche, subniche, minViews, favorite, search });

    try {
        if (!db) {
            console.error('[Biblioteca Titles] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        let query = 'SELECT * FROM viral_titles_library WHERE user_id = ?';
        const params = [userId];

        if (niche) {
            query += ' AND niche = ?';
            params.push(niche);
        }
        if (subniche) {
            query += ' AND subniche = ?';
            params.push(subniche);
        }
        if (minViews) {
            query += ' AND original_views >= ?';
            params.push(parseInt(minViews));
        }
        if (minCtr) {
            query += ' AND original_ctr >= ?';
            params.push(parseFloat(minCtr));
        }
        if (favorite === 'true') {
            query += ' AND is_favorite = 1';
        }
        if (search) {
            query += ' AND title LIKE ?';
            params.push(`%${search}%`);
        }

        query += ' ORDER BY created_at DESC LIMIT 100';

        console.log(`[Biblioteca Titles] Executando query:`, query.substring(0, 100));
        let titles = [];
        try {
            titles = await db.all(query, params);
            console.log(`[Biblioteca Titles] Títulos encontrados:`, titles.length);
        } catch (dbErr) {
            console.error('[Biblioteca Titles] Erro ao buscar títulos:', dbErr);
            titles = [];
        }

        // Garantir que titles é sempre um array
        const titlesArray = Array.isArray(titles) ? titles : [];
        res.status(200).json(titlesArray);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles]:', err);
        // Sempre retornar JSON válido (array vazio), nunca HTML
        res.status(200).json([]);
    }
});

// Excluir título da biblioteca
app.delete('/api/library/titles/:id', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const result = await db.run('DELETE FROM viral_titles_library WHERE id = ? AND user_id = ?', [id, userId]);
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Título não encontrado ou não pertence a este usuário.' });
        }

        console.log(`[Biblioteca] Título ${id} excluído pelo usuário ${userId}`);
        res.status(200).json({ msg: 'Título excluído da biblioteca com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir título da biblioteca.' });
    }
});

// Marcar/desmarcar título como favorito
app.put('/api/library/titles/:id/favorite', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const { isFavorite } = req.body;
    const userId = req.user.id;

    try {
        await db.run(
            'UPDATE viral_titles_library SET is_favorite = ? WHERE id = ? AND user_id = ?',
            [isFavorite ? 1 : 0, id, userId]
        );
        res.status(200).json({ msg: 'Favorito atualizado.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles/:id/favorite]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar favorito.' });
    }
});

// === ROTAS DE BIBLIOTECA DE THUMBNAILS VIRAIS ===

// Adicionar thumbnail à biblioteca
app.post('/api/library/thumbnails', authenticateToken, async (req, res) => {
    const { thumbnailUrl, thumbnailDescription, niche, subniche, originalViews, originalCtr, style, elements, viralScore } = req.body;
    const userId = req.user.id;

    if (!thumbnailUrl && !thumbnailDescription) {
        return res.status(400).json({ msg: 'URL da thumbnail ou descrição é obrigatória.' });
    }

    try {
        const result = await db.run(
            `INSERT INTO viral_thumbnails_library (user_id, thumbnail_url, thumbnail_description, niche, subniche, original_views, original_ctr, style, elements, viral_score)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, thumbnailUrl || null, thumbnailDescription || null, niche || null, subniche || null, originalViews || null, originalCtr || null, style || null, elements || null, viralScore || null]
        );
        res.status(201).json({ id: result.lastID, msg: 'Thumbnail adicionada à biblioteca.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails]:', err);
        res.status(500).json({ msg: 'Erro ao adicionar thumbnail à biblioteca.' });
    }
});

// Buscar thumbnails da biblioteca
app.get('/api/library/thumbnails', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { niche, subniche, minViews, minCtr, favorite, style, search } = req.query;
    console.log(`[Biblioteca Thumbnails] Requisição recebida para userId: ${userId}`, { niche, minViews, favorite, style, search });

    try {
        if (!db) {
            console.error('[Biblioteca Thumbnails] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        let query = 'SELECT * FROM viral_thumbnails_library WHERE user_id = ?';
        const params = [userId];

        if (niche) {
            query += ' AND niche = ?';
            params.push(niche);
        }
        if (subniche) {
            query += ' AND subniche = ?';
            params.push(subniche);
        }
        if (minViews) {
            query += ' AND original_views >= ?';
            params.push(parseInt(minViews));
        }
        if (minCtr) {
            query += ' AND original_ctr >= ?';
            params.push(parseFloat(minCtr));
        }
        if (favorite === 'true') {
            query += ' AND is_favorite = 1';
        }
        if (style) {
            query += ' AND style = ?';
            params.push(style);
        }
        if (search) {
            query += ' AND (niche LIKE ? OR subniche LIKE ? OR thumbnail_description LIKE ?)';
            const searchPattern = `%${search}%`;
            params.push(searchPattern, searchPattern, searchPattern);
        }

        query += ' ORDER BY created_at DESC LIMIT 100';

        console.log(`[Biblioteca Thumbnails] Executando query:`, query.substring(0, 100));
        let thumbnails = [];
        try {
            thumbnails = await db.all(query, params);
            console.log(`[Biblioteca Thumbnails] Thumbnails encontradas:`, thumbnails.length);
        } catch (dbErr) {
            console.error('[Biblioteca Thumbnails] Erro ao buscar thumbnails:', dbErr);
            thumbnails = [];
        }

        // Garantir que thumbnails é sempre um array
        const thumbnailsArray = Array.isArray(thumbnails) ? thumbnails : [];
        res.status(200).json(thumbnailsArray);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails]:', err);
        // Sempre retornar JSON válido (array vazio), nunca HTML
        res.status(200).json([]);
    }
});

// Rota para buscar nichos únicos da biblioteca
app.get('/api/library/niches', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        if (!db) {
            console.error('[Biblioteca Niches] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        // Buscar nichos únicos de títulos e thumbnails
        const titlesNiches = await db.all(
            `SELECT DISTINCT niche FROM viral_titles_library WHERE user_id = ? AND niche IS NOT NULL AND niche != ''`,
            [userId]
        );
        
        const thumbnailsNiches = await db.all(
            `SELECT DISTINCT niche FROM viral_thumbnails_library WHERE user_id = ? AND niche IS NOT NULL AND niche != ''`,
            [userId]
        );

        // Combinar e remover duplicatas
        const allNiches = new Set();
        titlesNiches.forEach(row => {
            if (row.niche) allNiches.add(row.niche);
        });
        thumbnailsNiches.forEach(row => {
            if (row.niche) allNiches.add(row.niche);
        });

        const nichesArray = Array.from(allNiches).sort();
        res.status(200).json({ niches: nichesArray });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/niches]:', err);
        res.status(500).json({ msg: 'Erro ao buscar nichos.' });
    }
});

// Excluir thumbnail da biblioteca
app.delete('/api/library/thumbnails/:id', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const result = await db.run('DELETE FROM viral_thumbnails_library WHERE id = ? AND user_id = ?', [id, userId]);
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Thumbnail não encontrada ou não pertence a este usuário.' });
        }

        console.log(`[Biblioteca] Thumbnail ${id} excluída pelo usuário ${userId}`);
        res.status(200).json({ msg: 'Thumbnail excluída da biblioteca com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir thumbnail da biblioteca.' });
    }
});

// Marcar/desmarcar thumbnail como favorito
app.put('/api/library/thumbnails/:id/favorite', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const { isFavorite } = req.body;
    const userId = req.user.id;

    try {
        await db.run(
            'UPDATE viral_thumbnails_library SET is_favorite = ? WHERE id = ? AND user_id = ?',
            [isFavorite ? 1 : 0, id, userId]
        );
        res.status(200).json({ msg: 'Favorito atualizado.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails/:id/favorite]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar favorito.' });
    }
});

// === ROTAS DE INTEGRAÇÃO YOUTUBE API ===

// Iniciar OAuth do YouTube (retorna URL de autorização)
app.get('/api/youtube/oauth/authorize', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const CLIENT_ID = process.env.YOUTUBE_CLIENT_ID || 'YOUR_CLIENT_ID';
    const REDIRECT_URI = process.env.YOUTUBE_REDIRECT_URI || 'http://localhost:5001/api/youtube/oauth/callback';
    const SCOPE = 'https://www.googleapis.com/auth/youtube.upload https://www.googleapis.com/auth/youtube';

    if (CLIENT_ID === 'YOUR_CLIENT_ID') {
        return res.status(500).json({ msg: 'Credenciais do YouTube não configuradas. Configure YOUTUBE_CLIENT_ID no arquivo .env. Veja CONFIGURACAO_YOUTUBE.md para mais informações.' });
    }

    // Validar e limpar REDIRECT_URI
    let cleanRedirectUri = REDIRECT_URI.trim();
    // Remover barra final se houver
    if (cleanRedirectUri.endsWith('/')) {
        cleanRedirectUri = cleanRedirectUri.slice(0, -1);
    }

    // Criar um state token seguro com o userId
    // Em produção, você deve usar um token JWT ou criptografado
    const stateToken = Buffer.from(JSON.stringify({ userId, timestamp: Date.now() })).toString('base64');

    // Construir URL de autorização com parâmetros corretos
    const authParams = new URLSearchParams({
        client_id: CLIENT_ID,
        redirect_uri: cleanRedirectUri,
        response_type: 'code',
        scope: SCOPE,
        access_type: 'offline',
        prompt: 'consent', // Força seleção de conta mesmo se já logado
        include_granted_scopes: 'true', // Permite múltiplas contas
        state: stateToken
    });

    const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?${authParams.toString()}`;

    console.log(`[YouTube OAuth] URL de autorização gerada para userId: ${userId}`);
    console.log(`[YouTube OAuth] Redirect URI: ${cleanRedirectUri}`);

    res.status(200).json({ authUrl, msg: 'Use esta URL para autorizar o acesso ao YouTube.' });
});

// Callback OAuth (será chamado pelo Google após autorização)
// NOTA: Este endpoint não usa authenticateToken porque o Google redireciona diretamente
// O userId é validado através do state parameter
app.get('/api/youtube/oauth/callback', async (req, res) => {
    const { code, error, state } = req.query;
    
    let userId = null;
    
    // Decodificar state para obter userId
    try {
        if (state) {
            const stateData = JSON.parse(Buffer.from(state, 'base64').toString());
            userId = stateData.userId;
            
            // Validar que o state não é muito antigo (máximo 10 minutos)
            const maxAge = 10 * 60 * 1000; // 10 minutos
            if (Date.now() - stateData.timestamp > maxAge) {
                return res.status(400).send(`
                    <!DOCTYPE html>
                    <html>
                    <head><title>Erro - Token Expirado</title></head>
                    <body style="font-family: Arial; text-align: center; padding: 50px;">
                        <h1>❌ Token Expirado</h1>
                        <p>O token de autorização expirou. Por favor, tente novamente.</p>
                        <button onclick="window.close()">Fechar</button>
                    </body>
                    </html>
                `);
            }
        } else {
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Erro - Estado Inválido</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px;">
                    <h1>❌ Erro na Autorização</h1>
                    <p>Estado inválido. Por favor, tente conectar novamente.</p>
                    <button onclick="window.close()">Fechar</button>
                </body>
                </html>
            `);
        }
    } catch (e) {
        console.error('[YouTube OAuth] Erro ao decodificar state:', e);
        return res.status(400).send(`
            <!DOCTYPE html>
            <html>
            <head><title>Erro - Estado Inválido</title></head>
            <body style="font-family: Arial; text-align: center; padding: 50px;">
                <h1>❌ Erro na Autorização</h1>
                <p>Estado inválido ou corrompido. Por favor, tente conectar novamente.</p>
                <button onclick="window.close()">Fechar</button>
            </body>
            </html>
        `);
    }

    if (error) {
        console.error('[YouTube OAuth] Erro na autorização:', error);
        return res.status(400).send(`
            <!DOCTYPE html>
            <html>
            <head><title>Erro na Autorização</title></head>
            <body style="font-family: Arial; text-align: center; padding: 50px;">
                <h1>❌ Erro na Autorização</h1>
                <p>${error}</p>
                <button onclick="window.close()">Fechar</button>
            </body>
            </html>
        `);
    }

    if (!code) {
        return res.status(400).json({ msg: 'Código de autorização não fornecido.' });
    }

    const CLIENT_ID = process.env.YOUTUBE_CLIENT_ID || 'YOUR_CLIENT_ID';
    const CLIENT_SECRET = process.env.YOUTUBE_CLIENT_SECRET || 'YOUR_CLIENT_SECRET';
    let REDIRECT_URI = process.env.YOUTUBE_REDIRECT_URI || 'http://localhost:5001/api/youtube/oauth/callback';

    // Limpar e validar REDIRECT_URI
    REDIRECT_URI = REDIRECT_URI.trim();
    if (REDIRECT_URI.endsWith('/')) {
        REDIRECT_URI = REDIRECT_URI.slice(0, -1);
    }

    if (CLIENT_ID === 'YOUR_CLIENT_ID' || CLIENT_SECRET === 'YOUR_CLIENT_SECRET') {
        return res.status(500).json({ msg: 'Credenciais do YouTube não configuradas. Configure YOUTUBE_CLIENT_ID e YOUTUBE_CLIENT_SECRET no arquivo .env' });
    }
    try {
        // Trocar code por access_token e refresh_token
        const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                code: code,
                client_id: CLIENT_ID,
                client_secret: CLIENT_SECRET,
                redirect_uri: REDIRECT_URI,
                grant_type: 'authorization_code',
            }),
        });

        if (!tokenResponse.ok) {
            const errorText = await tokenResponse.text();
            console.error('[YouTube OAuth] Erro ao trocar código por token:', errorText);
            return res.status(400).json({ msg: 'Falha ao obter tokens de acesso.' });
        }

        const tokenData = await tokenResponse.json();
        const { access_token, refresh_token, expires_in } = tokenData;

        if (!access_token) {
            return res.status(400).json({ msg: 'Token de acesso não recebido.' });
        }

        // Buscar TODOS os canais da conta Google (até 50 canais)
        const channelsResponse = await fetch('https://www.googleapis.com/youtube/v3/channels?part=snippet&mine=true&maxResults=50', {
            headers: {
                'Authorization': `Bearer ${access_token}`,
            },
        });

        let availableChannels = [];
        
        if (channelsResponse.ok) {
            const channelsData = await channelsResponse.json();
            if (channelsData.items && channelsData.items.length > 0) {
                availableChannels = channelsData.items.map(item => ({
                    id: item.id,
                    name: item.snippet?.title || 'Canal sem nome',
                    thumbnail: item.snippet?.thumbnails?.default?.url || '',
                    description: item.snippet?.description || ''
                }));
            }
        }

        if (availableChannels.length === 0) {
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Nenhum Canal Encontrado</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px;">
                    <h1>❌ Nenhum Canal Encontrado</h1>
                    <p>Não foi possível encontrar canais nesta conta Google.</p>
                    <button onclick="window.close()">Fechar</button>
                </body>
                </html>
            `);
        }

        // Verificar quantos canais já estão conectados
        const existingChannelsCount = await db.get(
            'SELECT COUNT(*) as count FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
            [userId]
        );
        const currentCount = existingChannelsCount?.count || 0;
        const maxChannels = 10;
        const remainingSlots = maxChannels - currentCount;

        if (remainingSlots <= 0) {
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Limite Atingido</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px;">
                    <h1>❌ Limite de Canais Atingido</h1>
                    <p>Você já tem 10 canais conectados. Desconecte um canal antes de adicionar outro.</p>
                    <button onclick="window.close()">Fechar</button>
                </body>
                </html>
            `);
        }

        // Verificar quais canais já estão conectados
        const existingChannels = await db.all(
            'SELECT channel_id FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
            [userId]
        );
        const existingChannelIds = new Set(existingChannels.map(c => c.channel_id));

        // Filtrar canais já conectados e limitar aos slots disponíveis
        const selectableChannels = availableChannels
            .filter(ch => !existingChannelIds.has(ch.id))
            .slice(0, remainingSlots);

        if (selectableChannels.length === 0) {
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Todos os Canais Já Conectados</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px;">
                    <h1>ℹ️ Todos os Canais Já Estão Conectados</h1>
                    <p>Todos os canais desta conta Google já estão conectados ou você atingiu o limite de 10 canais.</p>
                    <button onclick="window.close()">Fechar</button>
                </body>
                </html>
            `);
        }

        // Calcular quando o token expira
        const expiresAt = expires_in 
            ? new Date(Date.now() + expires_in * 1000).toISOString()
            : null;

        // Armazenar temporariamente os tokens e dados para processamento posterior
        // Usar uma sessão temporária ou passar via state
        const tempSessionId = `temp_${userId}_${Date.now()}`;
        
        // Salvar dados temporários (em produção, use Redis ou similar)
        // Por enquanto, vamos passar via query params criptografados ou usar uma abordagem diferente
        // Vou criar uma rota POST para processar a seleção
        
        // Retornar página de seleção de canais
        const channelsHTML = selectableChannels.map((channel, index) => `
            <div class="channel-item" style="display: flex; align-items: center; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 8px; margin-bottom: 1rem; cursor: pointer; transition: all 0.3s;" 
                 onmouseover="this.style.background='rgba(255,255,255,0.2)'" 
                 onmouseout="this.style.background='rgba(255,255,255,0.1)'"
                 onclick="toggleChannel('${channel.id}', '${channel.name.replace(/'/g, "\\'")}')">
                <input type="checkbox" id="channel_${channel.id}" value="${channel.id}" style="margin-right: 1rem; width: 20px; height: 20px; cursor: pointer;">
                ${channel.thumbnail ? `<img src="${channel.thumbnail}" style="width: 48px; height: 48px; border-radius: 50%; margin-right: 1rem;" alt="${channel.name}">` : ''}
                <div style="flex: 1;">
                    <div style="font-weight: bold; margin-bottom: 0.25rem;">${channel.name}</div>
                    <div style="font-size: 0.85rem; opacity: 0.8;">ID: ${channel.id}</div>
                </div>
            </div>
        `).join('');

        res.status(200).send(`
            <!DOCTYPE html>
            <html>
            <head>
                <title>Selecionar Canais - YouTube</title>
                <style>
                    * { box-sizing: border-box; }
                    body {
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                        margin: 0;
                        padding: 2rem;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        min-height: 100vh;
                    }
                    .container {
                        max-width: 600px;
                        margin: 0 auto;
                        background: rgba(255, 255, 255, 0.1);
                        border-radius: 15px;
                        padding: 2rem;
                        backdrop-filter: blur(10px);
                    }
                    h1 { margin-top: 0; text-align: center; }
                    .info {
                        background: rgba(255, 255, 255, 0.15);
                        padding: 1rem;
                        border-radius: 8px;
                        margin-bottom: 1.5rem;
                        font-size: 0.9rem;
                    }
                    .channel-item:hover {
                        transform: translateX(5px);
                    }
                    .actions {
                        display: flex;
                        gap: 1rem;
                        margin-top: 2rem;
                    }
                    button {
                        flex: 1;
                        padding: 1rem;
                        border: none;
                        border-radius: 8px;
                        font-size: 1rem;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.3s;
                    }
                    .btn-primary {
                        background: white;
                        color: #667eea;
                    }
                    .btn-primary:hover {
                        background: #f0f0f0;
                        transform: scale(1.02);
                    }
                    .btn-secondary {
                        background: rgba(255, 255, 255, 0.2);
                        color: white;
                    }
                    .btn-secondary:hover {
                        background: rgba(255, 255, 255, 0.3);
                    }
                    .btn-primary:disabled {
                        opacity: 0.5;
                        cursor: not-allowed;
                    }
                </style>
            </head>
            <body>
                <div class="container">
                    <h1>🎬 Selecione os Canais</h1>
                    <div class="info">
                        <strong>📊 Encontrados:</strong> ${selectableChannels.length} canal(is) disponível(is)<br>
                        <strong>✅ Você pode selecionar até:</strong> ${remainingSlots} canal(is)
                    </div>
                    <form id="channelsForm">
                        ${channelsHTML}
                    </form>
                    <div class="actions">
                        <button type="button" class="btn-secondary" onclick="window.close()">Cancelar</button>
                        <button type="button" class="btn-primary" id="connectBtn" onclick="connectSelectedChannels()" disabled>
                            Conectar Canais Selecionados (0)
                        </button>
                    </div>
                </div>
                <script>
                    const selectedChannels = new Set();
                    const channelsData = ${JSON.stringify(selectableChannels)};
                    const accessToken = '${access_token}';
                    const refreshToken = '${refresh_token || ''}';
                    const expiresAt = '${expiresAt || ''}';
                    const userId = ${userId};
                    
                    function toggleChannel(channelId, channelName) {
                        const checkbox = document.getElementById('channel_' + channelId);
                        if (selectedChannels.has(channelId)) {
                            selectedChannels.delete(channelId);
                            checkbox.checked = false;
                        } else {
                            selectedChannels.add(channelId);
                            checkbox.checked = true;
                        }
                        updateButton();
                    }
                    
                    function updateButton() {
                        const btn = document.getElementById('connectBtn');
                        const count = selectedChannels.size;
                        btn.disabled = count === 0;
                        btn.textContent = 'Conectar Canais Selecionados (' + count + ')';
                    }
                    
                    async function connectSelectedChannels() {
                        if (selectedChannels.size === 0) return;
                        
                        const btn = document.getElementById('connectBtn');
                        btn.disabled = true;
                        btn.textContent = 'Conectando...';
                        
                        try {
                            // Detectar a URL base automaticamente
                            // Se estiver em localhost, usar porta 5001, senão usar a mesma origem
                            let apiBase;
                            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                                apiBase = 'http://localhost:5001';
                            } else {
                                // Em produção, usar a mesma origem
                                apiBase = window.location.origin;
                            }
                            
                            const response = await fetch(apiBase + '/api/youtube/oauth/connect-channels', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    userId: userId,
                                    channelIds: Array.from(selectedChannels),
                                    accessToken: accessToken,
                                    refreshToken: refreshToken,
                                    expiresAt: expiresAt
                                })
                            });
                            
                            const data = await response.json();
                            
                            if (response.ok) {
                                document.body.innerHTML = \`
                                    <div class="container" style="text-align: center;">
                                        <h1>✅ Canais Conectados com Sucesso!</h1>
                                        <p>\${data.connected} canal(is) conectado(s)</p>
                                        <p>Você pode fechar esta janela e voltar ao dashboard.</p>
                                        <button class="btn-primary" onclick="window.close()">Fechar</button>
                                    </div>
                                \`;
                            } else {
                                throw new Error(data.msg || 'Erro ao conectar canais');
                            }
                        } catch (err) {
                            alert('Erro: ' + err.message);
                            btn.disabled = false;
                            updateButton();
                        }
                    }
                    
                    // Permitir clicar em qualquer lugar do item para selecionar
                    document.querySelectorAll('.channel-item').forEach(item => {
                        item.addEventListener('click', function(e) {
                            if (e.target.type !== 'checkbox') {
                                const checkbox = this.querySelector('input[type="checkbox"]');
                                checkbox.click();
                            }
                        });
                    });
                </script>
            </body>
            </html>
        `);
    } catch (err) {
        console.error('[YouTube OAuth] Erro no callback:', err);
        return res.status(500).json({ msg: `Erro ao processar autorização: ${err.message}` });
    }
});

// === PARTE 2: AUTOMAÇÃO E INTEGRAÇÃO COM YOUTUBE ===

// A.1 - Agendamento Inteligente: IA sugere melhor horário para publicar baseado no nicho
app.post('/api/youtube/suggest-best-time', authenticateToken, async (req, res) => {
    const { niche, subniche, timezone } = req.body;
    const userId = req.user.id;

    if (!niche) {
        return res.status(400).json({ msg: 'Nicho é obrigatório para sugerir horário.' });
    }

    try {
        // Verificar se deve usar créditos (laozhang.ai)
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        let bestTime = null;
        let explanation = '';
        
        // Se deve usar créditos, usar laozhang.ai primeiro
        if (useCredits) {
            const laozhangKey = await getLaozhangApiKey();
            if (laozhangKey) {
                try {
                    const prompt = `Você é um especialista em estratégia de YouTube e análise de dados de engajamento.

Analise o nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''} e sugira o MELHOR horário para publicar vídeos neste nicho.

Considere:
1. Horários de pico de engajamento para este nicho específico
2. Fuso horário do público-alvo (principalmente Brasil/América Latina)
3. Dias da semana que performam melhor
4. Padrões de comportamento do público deste nicho

Responda APENAS com um JSON válido no formato:
{
  "bestTime": "HH:MM" (formato 24h, ex: "18:00"),
  "bestDays": ["segunda", "terça", "quarta", "quinta", "sexta", "sábado", "domingo"] (array com os melhores dias),
  "explanation": "Explicação detalhada do porquê este horário é ideal",
  "alternativeTimes": ["HH:MM", "HH:MM"] (2-3 horários alternativos)
}

IMPORTANTE: Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await callLaozhangAPI(prompt, laozhangKey, 'gpt-4o', null, userId, 'api_call', JSON.stringify({ endpoint: '/api/youtube/suggest-best-time' }));
                    const responseText = response.titles || response.text || '';
                    
                    // Tentar extrair JSON da resposta
                    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.bestTime) {
                                bestTime = parsed;
                                explanation = parsed.explanation || '';
                                console.log(`[Agendamento Inteligente] Horário sugerido usando API configurada como padrão: ${parsed.bestTime}`);
                            }
                        } catch (e) {
                            console.warn(`[Agendamento Inteligente] Falha ao parsear JSON:`, e.message);
                        }
                    }
                } catch (serviceErr) {
                    console.warn(`[Agendamento Inteligente] Falha com API configurada como padrão:`, serviceErr.message);
                }
            }
        }
        
        // Se não usar créditos ou se laozhang falhou, usar APIs próprias
        if (!bestTime) {
            // Tentar usar Gemini primeiro, depois Claude, depois OpenAI
            const services = ['gemini', 'claude', 'openai'];

            for (const service of services) {
                try {
                    const serviceKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                    if (!serviceKeyData) continue;

                    const decryptedKey = decrypt(serviceKeyData.api_key);
                    if (!decryptedKey) continue;

                    let apiCallFunction;
                    let model;
                    if (service === 'gemini') {
                        apiCallFunction = callGeminiAPI;
                        model = 'gemini-2.0-flash';
                    } else if (service === 'claude') {
                        apiCallFunction = callClaudeAPI;
                        model = 'claude-3-5-haiku-20241022';
                    } else {
                        apiCallFunction = callOpenAIAPI;
                        model = 'gpt-4o-mini';
                    }

                    const prompt = `Você é um especialista em estratégia de YouTube e análise de dados de engajamento.

Analise o nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''} e sugira o MELHOR horário para publicar vídeos neste nicho.

Considere:
1. Horários de pico de engajamento para este nicho específico
2. Fuso horário do público-alvo (principalmente Brasil/América Latina)
3. Dias da semana que performam melhor
4. Padrões de comportamento do público deste nicho

Responda APENAS com um JSON válido no formato:
{
  "bestTime": "HH:MM" (formato 24h, ex: "18:00"),
  "bestDays": ["segunda", "terça", "quarta", "quinta", "sexta", "sábado", "domingo"] (array com os melhores dias),
  "explanation": "Explicação detalhada do porquê este horário é ideal",
  "alternativeTimes": ["HH:MM", "HH:MM"] (2-3 horários alternativos)
}

IMPORTANTE: Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await apiCallFunction(prompt, decryptedKey, model);
                    const responseText = response.titles || response.text || '';
                    
                    // Tentar extrair JSON da resposta
                    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.bestTime) {
                                bestTime = parsed;
                                explanation = parsed.explanation || '';
                                console.log(`[Agendamento Inteligente] Horário sugerido usando ${service}: ${parsed.bestTime}`);
                                break;
                            }
                        } catch (e) {
                            console.warn(`[Agendamento Inteligente] Falha ao parsear JSON de ${service}:`, e.message);
                        }
                    }
                } catch (serviceErr) {
                    console.warn(`[Agendamento Inteligente] Falha com ${service}:`, serviceErr.message);
                    continue;
                }
            }
        }

        // Fallback: horários padrão baseados em pesquisas gerais
        if (!bestTime) {
            const defaultTimes = {
                'Entretenimento': { bestTime: '18:00', bestDays: ['sexta', 'sábado', 'domingo'], explanation: 'Horário de pico para entretenimento: fim de tarde e fins de semana' },
                'Educação': { bestTime: '19:00', bestDays: ['segunda', 'terça', 'quarta', 'quinta'], explanation: 'Horário ideal para conteúdo educativo: início da noite em dias úteis' },
                'Tecnologia': { bestTime: '20:00', bestDays: ['terça', 'quarta', 'quinta'], explanation: 'Público de tecnologia mais ativo no início da noite' },
                'Finanças': { bestTime: '08:00', bestDays: ['segunda', 'terça', 'quarta'], explanation: 'Horário de trabalho: público financeiro mais ativo pela manhã' }
            };
            
            const nicheKey = Object.keys(defaultTimes).find(k => niche.toLowerCase().includes(k.toLowerCase()));
            bestTime = nicheKey ? defaultTimes[nicheKey] : { bestTime: '18:00', bestDays: ['sexta', 'sábado'], explanation: 'Horário padrão otimizado para engajamento geral' };
            bestTime.alternativeTimes = ['16:00', '20:00'];
        }

        res.status(200).json({
            suggestedTime: bestTime.bestTime,
            suggestedDays: bestTime.bestDays || ['sexta', 'sábado'],
            explanation: bestTime.explanation || explanation,
            alternativeTimes: bestTime.alternativeTimes || []
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/suggest-best-time]:', err);
        res.status(500).json({ msg: 'Erro ao sugerir horário de publicação.' });
    }
});

// A.3 - Auto-tags e Descrição: Preencher automaticamente tags e descrição otimizadas
app.post('/api/youtube/generate-metadata', authenticateToken, async (req, res) => {
    const { title, model: requestedModel, niche, subniche, videoDescription } = req.body;
    const userId = req.user.id;

    if (!title) {
        return res.status(400).json({ msg: 'Título é obrigatório para gerar metadata.' });
    }

    try {
        // Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem API própria configurada
        const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
        
        console.log(`[Generate Metadata] shouldUseCredits: ${creditsCheck.shouldUse}, reason: ${creditsCheck.reason}, requestedModel: ${requestedModel}`);
        
        let metadata = null;
        
        // Se deve usar créditos, usar laozhang.ai
        if (creditsCheck.shouldUse) {
            console.log('[Generate Metadata] Verificando chave laozhang.ai...');
            const laozhangKey = await getLaozhangApiKey();
            console.log('[Generate Metadata] Chave laozhang.ai encontrada:', laozhangKey ? 'Sim' : 'Não');
            if (laozhangKey) {
                // Determinar modelo a usar
                let modelToUse = 'gpt-4o';
                if (requestedModel) {
                    if (requestedModel.includes('gpt') || requestedModel === 'gpt-4o') {
                        modelToUse = 'gpt-4o';
                    } else if (requestedModel.includes('claude') || requestedModel === 'claude-3-7-sonnet-20250219') {
                        modelToUse = 'claude-3-7-sonnet-20250219';
                    } else if (requestedModel.includes('gemini') || requestedModel === 'gemini-2.5-pro') {
                        modelToUse = 'gemini-2.5-pro';
                    }
                }
                
                try {
                    const prompt = `Você é um ESPECIALISTA EM ALGORITMO DO YOUTUBE e otimização de conteúdo, com conhecimento profundo sobre como o algoritmo do YouTube classifica, recomenda e promove vídeos.

Título do vídeo: "${title}"
${niche ? `Nicho: "${niche}"` : ''}
${subniche ? `Subnicho: "${subniche}"` : ''}
${videoDescription ? `Descrição do conteúdo: "${videoDescription}"` : ''}

Sua tarefa é gerar metadata ALTAMENTE OTIMIZADA PARA O ALGORITMO DO YOUTUBE:

1. DESCRIÇÃO OTIMIZADA PARA O ALGORITMO DO YOUTUBE (MÁXIMO 500 CARACTERES):
   
   ESTRUTURA OBRIGATÓRIA (seguir EXATAMENTE nesta ordem):
   
   a) PRIMEIRA LINHA (Hook + Palavra-chave principal):
      - Repetir a palavra-chave principal do título nas primeiras palavras
      - Criar um hook que desperte curiosidade e aumente CTR
      - Exemplo: "Descubra como [palavra-chave] mudou tudo..."
   
   b) SEGUNDA E TERCEIRA LINHAS (Conteúdo + Contexto):
      - Expandir o tema usando variações da palavra-chave
      - Adicionar contexto que o algoritmo usa para categorizar
      - Incluir termos relacionados que o YouTube associa ao conteúdo
   
   c) QUARTA LINHA (Call-to-Action):
      - CTA direto para aumentar engajamento (inscrever-se, like, comentar)
      - Use emojis estratégicos (máximo 3-4) para aumentar CTR
   
   d) ÚLTIMA LINHA (Hashtags):
      - 2-3 hashtags relevantes (sem # no início, apenas o texto)
      - Use hashtags que o YouTube reconhece como categorias
   
   REGRAS PARA O ALGORITMO:
   - Palavras-chave principais devem aparecer nas primeiras 125 caracteres (YouTube indexa isso)
   - Use termos que o YouTube associa a vídeos virais no nicho
   - Evite palavras genéricas, seja específico
   - Estrutura clara ajuda o algoritmo a entender o conteúdo
   - MÁXIMO 500 caracteres (o algoritmo prioriza descrições concisas)

2. TAGS OTIMIZADAS PARA O ALGORITMO (25-35 tags):

   DISTRIBUIÇÃO ESTRATÉGICA:
   
   a) Palavras-chave principais (8-10 tags):
      - Extrair todas as palavras-chave importantes do título
      - Incluir variações exatas das palavras do título
      - Exemplo: se título tem "jantar família", incluir "jantar", "família", "jantar família"
   
   b) Long-tail keywords (8-10 tags):
      - Frases de busca que pessoas realmente usam
      - Termos de 3-5 palavras que combinam palavras-chave
      - Exemplo: "jantar em família", "história de família", "testamento família"
   
   c) Termos relacionados ao nicho (5-7 tags):
      - Termos que o YouTube associa ao conteúdo similar
      - Palavras que aparecem em vídeos virais do mesmo tema
      - Termos de tendência no nicho
   
   d) Termos em inglês estratégicos (4-6 tags):
      - Traduções das palavras-chave principais
      - Termos internacionais que aumentam alcance
      - Misture português e inglês
   
   ESTRATÉGIA PARA O ALGORITMO:
   - Primeiras 5 tags são as MAIS IMPORTANTES (YouTube prioriza)
   - Use tags que aparecem em vídeos com alta performance no nicho
   - Evite tags genéricas demais (ex: "vídeo", "youtube")
   - Foque em tags específicas que o algoritmo usa para recomendar
   - Total: 25-35 tags (YouTube permite até 500 caracteres em tags)

REGRAS CRÍTICAS PARA O ALGORITMO:
- Descrição: MÁXIMO 500 caracteres, palavras-chave nas primeiras 125
- Tags: 25-35 tags, primeiras 5 são críticas
- SEO: Otimize para busca E recomendação do algoritmo
- Engajamento: CTAs aumentam sinais de engajamento (algoritmo prioriza)
- Idioma: Português (Brasil) para descrição, português + inglês para tags
- Especificidade: Seja específico, não genérico (algoritmo recompensa)

Responda APENAS com um JSON válido no formato:
{
  "description": "Descrição otimizada para algoritmo do YouTube (máximo 500 caracteres)...",
  "tags": ["tag1", "tag2", "tag3", ...] (25-35 tags, primeiras 5 são as mais importantes)
}

IMPORTANTE: A descrição deve seguir EXATAMENTE a estrutura: Hook+Palavra-chave → Conteúdo → CTA → Hashtags

Responda APENAS com o JSON, sem texto adicional.`;

                    console.log(`[Auto-metadata] Chamando API configurada como padrão com modelo ${modelToUse} para gerar metadata`);
                    const response = await callLaozhangAPI(prompt, laozhangKey, modelToUse, null, userId, 'api_call', JSON.stringify({ endpoint: '/api/youtube/generate-metadata', model: modelToUse }));
                    // callLaozhangAPI retorna uma string diretamente, não um objeto
                    const responseText = typeof response === 'string' ? response : (response?.titles || response?.text || response?.content || JSON.stringify(response) || '');
                    
                    console.log(`[Auto-metadata] Resposta recebida da API configurada como padrão (${responseText.length} caracteres)`);
                    console.log(`[Auto-metadata] Primeiros 500 caracteres da resposta:`, responseText.substring(0, 500));
                    
                    // Tentar extrair JSON da resposta - usar regex mais robusto para pegar JSON completo
                    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    // Se não encontrar, tentar remover markdown code blocks
                    if (!jsonMatch) {
                        const cleaned = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                        jsonMatch = cleaned.match(/\{[\s\S]*\}/);
                    }
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.description && parsed.tags && Array.isArray(parsed.tags)) {
                                // Garantir que a descrição não ultrapasse 500 caracteres
                                if (parsed.description.length > 500) {
                                    parsed.description = parsed.description.substring(0, 497) + '...';
                                    console.log(`[Auto-metadata] Descrição truncada para 500 caracteres`);
                                }
                                
                                // Limitar tags a 35 e garantir que sejam strings válidas
                                parsed.tags = parsed.tags
                                    .filter(tag => tag && typeof tag === 'string' && tag.trim().length > 0)
                                    .map(tag => tag.trim())
                                    .slice(0, 35);
                                
                                metadata = parsed;
                                console.log(`[Auto-metadata] ✅ Metadata gerada usando API configurada como padrão com modelo ${modelToUse} (${parsed.tags.length} tags, descrição: ${parsed.description.length} caracteres)`);
                            } else {
                                console.warn(`[Auto-metadata] Resposta da API configurada como padrão não tem formato esperado`);
                                console.warn(`[Auto-metadata] Resposta completa:`, responseText.substring(0, 1000));
                            }
                        } catch (e) {
                            console.warn(`[Auto-metadata] Falha ao parsear JSON:`, e.message);
                        }
                    } else {
                        console.warn(`[Auto-metadata] Nenhum JSON encontrado na resposta da API configurada como padrão`);
                    }
                } catch (serviceErr) {
                    console.error(`[Auto-metadata] Erro ao usar API configurada como padrão:`, serviceErr.message);
                    // Se deve usar créditos e laozhang falhou, não tentar APIs próprias
                    if (creditsCheck.shouldUse) {
                        return res.status(500).json({ 
                            msg: 'Erro ao gerar metadata usando sistema de créditos. Verifique se a chave está configurada corretamente no painel admin.' 
                        });
                    }
                }
            } else if (creditsCheck.shouldUse) {
                // Se deve usar créditos mas não tem chave
                return res.status(400).json({ 
                    msg: 'Sistema de créditos não está configurado. Configure a chave no painel admin ou configure uma API própria nas Configurações.' 
                });
            }
        }
        
        // Se não usar créditos ou se laozhang falhou (e não é obrigatório), usar APIs próprias
        if (!metadata && !creditsCheck.shouldUse) {
            // Se o modelo foi especificado, usar APENAS ele (não tentar todos)
            let service = null;
            let targetModel = requestedModel || null;
            
            if (targetModel) {
                // Mapear modelo para serviço - usar APENAS o serviço correspondente
                if (targetModel.includes('gpt') || targetModel === 'gpt-4o') {
                    service = 'openai';
                    targetModel = 'gpt-4o';
                } else if (targetModel.includes('claude') || targetModel === 'claude-3-7-sonnet-20250219') {
                    service = 'claude';
                    targetModel = 'claude-3-7-sonnet-20250219';
                } else if (targetModel.includes('gemini') || targetModel === 'gemini-2.5-pro') {
                    service = 'gemini';
                    targetModel = 'gemini-2.5-pro';
                }
            }
            
            // Se não especificou modelo ou não encontrou correspondência, tentar todos (fallback)
            const services = service ? [service] : ['gemini', 'claude', 'openai'];

            for (const serviceToUse of services) {
                try {
                    const serviceKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, serviceToUse]);
                    if (!serviceKeyData) {
                        if (service) {
                            // Se especificou um modelo mas não tem a chave, retornar erro
                            return res.status(400).json({ 
                                msg: `Chave de API do ${serviceToUse === 'openai' ? 'OpenAI' : serviceToUse === 'claude' ? 'Claude' : 'Gemini'} não configurada. Configure a chave nas Configurações.` 
                            });
                        }
                        continue;
                    }

                    const decryptedKey = decrypt(serviceKeyData.api_key);
                    if (!decryptedKey) {
                        if (service) {
                            return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
                        }
                        continue;
                    }

                    let apiCallFunction;
                    let model;
                    if (serviceToUse === 'gemini') {
                        apiCallFunction = callGeminiAPI;
                        model = targetModel && targetModel.includes('gemini') ? targetModel : 'gemini-2.5-pro';
                    } else if (serviceToUse === 'claude') {
                        apiCallFunction = callClaudeAPI;
                        model = targetModel && targetModel.includes('claude') ? targetModel : 'claude-3-7-sonnet-20250219';
                    } else {
                        apiCallFunction = callOpenAIAPI;
                        model = targetModel && targetModel.includes('gpt') ? targetModel : 'gpt-4o';
                    }
                    
                    console.log(`[Auto-metadata] Usando ${serviceToUse} com modelo ${model}`);

                    const prompt = `Você é um ESPECIALISTA EM ALGORITMO DO YOUTUBE e otimização de conteúdo, com conhecimento profundo sobre como o algoritmo do YouTube classifica, recomenda e promove vídeos.

Título do vídeo: "${title}"
${niche ? `Nicho: "${niche}"` : ''}
${subniche ? `Subnicho: "${subniche}"` : ''}
${videoDescription ? `Descrição do conteúdo: "${videoDescription}"` : ''}

Sua tarefa é gerar metadata ALTAMENTE OTIMIZADA PARA O ALGORITMO DO YOUTUBE:

1. DESCRIÇÃO OTIMIZADA PARA O ALGORITMO DO YOUTUBE (MÁXIMO 500 CARACTERES):
   
   ESTRUTURA OBRIGATÓRIA (seguir EXATAMENTE nesta ordem):
   
   a) PRIMEIRA LINHA (Hook + Palavra-chave principal):
      - Repetir a palavra-chave principal do título nas primeiras palavras
      - Criar um hook que desperte curiosidade e aumente CTR
      - Exemplo: "Descubra como [palavra-chave] mudou tudo..."
   
   b) SEGUNDA E TERCEIRA LINHAS (Conteúdo + Contexto):
      - Expandir o tema usando variações da palavra-chave
      - Adicionar contexto que o algoritmo usa para categorizar
      - Incluir termos relacionados que o YouTube associa ao conteúdo
   
   c) QUARTA LINHA (Call-to-Action):
      - CTA direto para aumentar engajamento (inscrever-se, like, comentar)
      - Use emojis estratégicos (máximo 3-4) para aumentar CTR
   
   d) ÚLTIMA LINHA (Hashtags):
      - 2-3 hashtags relevantes (sem # no início, apenas o texto)
      - Use hashtags que o YouTube reconhece como categorias
   
   REGRAS PARA O ALGORITMO:
   - Palavras-chave principais devem aparecer nas primeiras 125 caracteres (YouTube indexa isso)
   - Use termos que o YouTube associa a vídeos virais no nicho
   - Evite palavras genéricas, seja específico
   - Estrutura clara ajuda o algoritmo a entender o conteúdo
   - MÁXIMO 500 caracteres (o algoritmo prioriza descrições concisas)

2. TAGS OTIMIZADAS PARA O ALGORITMO (25-35 tags):

   DISTRIBUIÇÃO ESTRATÉGICA:
   
   a) Palavras-chave principais (8-10 tags):
      - Extrair todas as palavras-chave importantes do título
      - Incluir variações exatas das palavras do título
      - Exemplo: se título tem "jantar família", incluir "jantar", "família", "jantar família"
   
   b) Long-tail keywords (8-10 tags):
      - Frases de busca que pessoas realmente usam
      - Termos de 3-5 palavras que combinam palavras-chave
      - Exemplo: "jantar em família", "história de família", "testamento família"
   
   c) Termos relacionados ao nicho (5-7 tags):
      - Termos que o YouTube associa ao conteúdo similar
      - Palavras que aparecem em vídeos virais do mesmo tema
      - Termos de tendência no nicho
   
   d) Termos em inglês estratégicos (4-6 tags):
      - Traduções das palavras-chave principais
      - Termos internacionais que aumentam alcance
      - Misture português e inglês
   
   ESTRATÉGIA PARA O ALGORITMO:
   - Primeiras 5 tags são as MAIS IMPORTANTES (YouTube prioriza)
   - Use tags que aparecem em vídeos com alta performance no nicho
   - Evite tags genéricas demais (ex: "vídeo", "youtube")
   - Foque em tags específicas que o algoritmo usa para recomendar
   - Total: 25-35 tags (YouTube permite até 500 caracteres em tags)

REGRAS CRÍTICAS PARA O ALGORITMO:
- Descrição: MÁXIMO 500 caracteres, palavras-chave nas primeiras 125
- Tags: 25-35 tags, primeiras 5 são críticas
- SEO: Otimize para busca E recomendação do algoritmo
- Engajamento: CTAs aumentam sinais de engajamento (algoritmo prioriza)
- Idioma: Português (Brasil) para descrição, português + inglês para tags
- Especificidade: Seja específico, não genérico (algoritmo recompensa)

Responda APENAS com um JSON válido no formato:
{
  "description": "Descrição otimizada para algoritmo do YouTube (máximo 500 caracteres)...",
  "tags": ["tag1", "tag2", "tag3", ...] (25-35 tags, primeiras 5 são as mais importantes)
}

IMPORTANTE: A descrição deve seguir EXATAMENTE a estrutura: Hook+Palavra-chave → Conteúdo → CTA → Hashtags

Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await apiCallFunction(prompt, decryptedKey, model);
                    // A resposta pode ser string direta ou objeto
                    const responseText = typeof response === 'string' ? response : (response?.titles || response?.text || response?.content || JSON.stringify(response) || '');
                    
                    console.log(`[Auto-metadata] Resposta de ${serviceToUse} (modelo ${model}):`, responseText.substring(0, 200));
                    console.log(`[Auto-metadata] Tamanho da resposta: ${responseText.length} caracteres`);
                    
                    // Tentar extrair JSON da resposta - usar regex mais robusto para pegar JSON completo
                    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    // Se não encontrar, tentar remover markdown code blocks
                    if (!jsonMatch) {
                        const cleaned = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                        jsonMatch = cleaned.match(/\{[\s\S]*\}/);
                    }
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.description && parsed.tags && Array.isArray(parsed.tags)) {
                                // Garantir que a descrição não ultrapasse 500 caracteres
                                if (parsed.description.length > 500) {
                                    parsed.description = parsed.description.substring(0, 497) + '...';
                                    console.log(`[Auto-metadata] Descrição truncada para 500 caracteres`);
                                }
                                
                                // Limitar tags a 35 e garantir que sejam strings válidas
                                // IMPORTANTE: Ordenar tags para que as mais importantes fiquem primeiro (YouTube prioriza)
                                parsed.tags = parsed.tags
                                    .filter(tag => tag && typeof tag === 'string' && tag.trim().length > 0)
                                    .map(tag => tag.trim())
                                    .slice(0, 35);
                                
                                metadata = parsed;
                                console.log(`[Auto-metadata] ✅ Metadata gerada usando ${serviceToUse} com modelo ${model} (${parsed.tags.length} tags, descrição: ${parsed.description.length} caracteres)`);
                                console.log(`[Auto-metadata] Primeiras 5 tags (mais importantes):`, parsed.tags.slice(0, 5).join(', '));
                                break; // Parar o loop quando encontrar sucesso
                            }
                        } catch (e) {
                            console.warn(`[Auto-metadata] Falha ao parsear JSON de ${serviceToUse}:`, e.message);
                        }
                    }
                } catch (serviceErr) {
                    console.warn(`[Auto-metadata] Falha com ${serviceToUse}:`, serviceErr.message);
                    // Se especificou um modelo e falhou, retornar erro
                    if (service) {
                        return res.status(500).json({ 
                            msg: `Erro ao gerar metadata usando ${serviceToUse === 'openai' ? 'OpenAI' : serviceToUse === 'claude' ? 'Claude' : 'Gemini'}. Verifique sua chave de API.` 
                        });
                    }
                    continue;
                }
            }
        }

        // Fallback: gerar metadata básica
        if (!metadata) {
            const keywords = title.toLowerCase().split(/\s+/).filter(w => w.length > 3);
            const fallbackDescription = `${title}\n\n${videoDescription || 'Conteúdo exclusivo sobre ' + (subniche || niche || 'este tema') + '. Não perca!'}\n\n🔔 Inscreva-se no canal para mais conteúdo!\n👍 Deixe seu like se gostou!\n💬 Comente o que achou!\n\n#${(subniche || niche || 'youtube').replace(/\s+/g, '')}`;
            
            // Gerar mais tags do fallback
            const baseTags = keywords.slice(0, 20);
            const nicheTags = [niche, subniche].filter(Boolean);
            const relatedTags = niche ? [
                `${niche} brasil`,
                `${niche} youtube`,
                `${niche} 2025`,
                `vídeo ${niche}`,
                `conteúdo ${niche}`
            ] : [];
            
            metadata = {
                description: fallbackDescription.length > 500 ? fallbackDescription.substring(0, 497) + '...' : fallbackDescription,
                tags: [...baseTags, ...nicheTags, ...relatedTags].slice(0, 35)
            };
        }

        // Validação final: garantir que descrição não ultrapasse 500 caracteres
        if (metadata.description && metadata.description.length > 500) {
            metadata.description = metadata.description.substring(0, 497) + '...';
            console.log(`[Auto-metadata] ⚠️ Descrição final truncada para 500 caracteres`);
        }
        
        // Validação final: garantir que tags sejam válidas e limitadas a 35
        if (metadata.tags && Array.isArray(metadata.tags)) {
            metadata.tags = metadata.tags
                .filter(tag => tag && typeof tag === 'string' && tag.trim().length > 0)
                .map(tag => tag.trim())
                .slice(0, 35);
        }
        
        res.status(200).json({
            description: metadata.description,
            tags: metadata.tags
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/generate-metadata]:', err);
        res.status(500).json({ msg: 'Erro ao gerar metadata.' });
    }
});

// === ROTAS DE GERAÇÃO DE VÍDEO (VEO) ===

// Armazenar operações de geração de vídeo em memória (em produção, usar Redis ou banco)
const videoOperations = new Map();

const decodeOperationId = (encodedId) => {
    try {
        let decoded = decodeURIComponent(encodedId);
        decoded = decoded.replace(/^\/+/, '');
        return decoded;
    } catch (error) {
        console.error('[Veo] Erro ao decodificar operationId:', error.message);
        return encodedId;
    }
};

// POST /api/video/generate - Gerar vídeo usando Veo
app.post('/api/video/generate', authenticateToken, async (req, res) => {
    const {
        prompt,
        model = 'sora_video2-15s',
        aspectRatio = '16:9',
        resolution = '720p',
        mode = 'text-to-video',
        startFrame,
        endFrame,
        referenceImages = [],
        styleImage,
        inputVideo,
        isLooping = false
    } = req.body;

    const userId = req.user.id;

    console.log('[Veo] Dados recebidos do frontend:', {
        prompt: prompt ? `"${prompt.substring(0, 50)}..."` : 'VAZIO',
        model,
        mode,
        aspectRatio,
        resolution,
        hasStartFrame: !!startFrame,
        hasEndFrame: !!endFrame,
        hasReferenceImages: referenceImages?.length > 0,
        hasInputVideo: !!inputVideo
    });

    try {
        // Verificar preferência do usuário (usar créditos ou API própria)
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;

        let useLaozhang = false;
        let useAdminApi = false;
        let adminApi = null;
        let apiKey = null;
        let usingPanelVideoKey = false;
        let apiKeySource = null;
        let userGeminiKeyRow = null;

        let laozhangApiKey = null;
        
        // Se usuário prefere usar créditos, usar Laozhang.ai (obrigatório)
        if (useCredits) {
            laozhangApiKey = await getLaozhangApiKey();
            if (laozhangApiKey) {
                // Normalizar a chave
                if (typeof laozhangApiKey === 'object' && laozhangApiKey.api_key) {
                    laozhangApiKey = laozhangApiKey.api_key;
                } else if (typeof laozhangApiKey === 'string') {
                    laozhangApiKey = laozhangApiKey.trim();
                } else {
                    laozhangApiKey = String(laozhangApiKey).trim();
                }
                
                if (laozhangApiKey && laozhangApiKey.length > 10) {
                    useLaozhang = true;
                    apiKeySource = 'laozhang';
                    console.log('[Veo] ✅ Usando Laozhang.ai com créditos (preferência do usuário)');
                } else {
                    console.warn('[Veo] ⚠️ Chave Laozhang inválida ou muito curta');
                    return res.status(400).json({
                        message: 'Chave do provedor externo inválida. Configure corretamente no painel admin.',
                        details: 'A geração via créditos depende da API configurada no painel admin. Configure a chave corretamente.'
                    });
                }
            } else {
                console.warn('[Veo] ⚠️ Preferência por créditos, mas Laozhang.ai não está configurada');
                return res.status(400).json({
                    message: 'Para usar créditos, configure a chave do provedor externo no painel admin.',
                    details: 'A geração via créditos depende da API configurada no painel admin. Configure a chave ou desmarque a opção de créditos.'
                });
            }
        }
        
        // Só buscar outras APIs se não usar laozhang
        if (!useLaozhang) {
            const panelVideoApiKey = await getAdminVideoApiKey();
            if (panelVideoApiKey) {
                apiKey = panelVideoApiKey;
                usingPanelVideoKey = true;
                apiKeySource = 'panel_video';
                console.log('[Veo] Usando chave de vídeo configurada no painel admin');
            }
        }

        // Se não usar Laozhang, buscar chave do usuário ou admin
        if (!useLaozhang && !usingPanelVideoKey) {
            // Buscar chave do usuário
            const geminiKeyData = await db.get('SELECT id, api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            let userApiKey = null;
            if (geminiKeyData && geminiKeyData.api_key) {
                try {
                    userApiKey = decrypt(geminiKeyData.api_key);
                } catch (decryptError) {
                    console.warn('[Veo] Erro ao descriptografar chave do usuário:', decryptError.message);
                    // Se falhar, tentar usar diretamente (pode não estar criptografada)
                    userApiKey = geminiKeyData.api_key;
                }
            }
            if (userApiKey) {
                userGeminiKeyRow = geminiKeyData;
            }
            // Buscar API do admin (qualquer tipo, mas preferir Gemini)
            adminApi = await getDefaultAdminApi();
            let adminApiKey = null;
            
            // Primeiro tentar buscar API Gemini do admin
            if (adminApi && adminApi.provider === 'gemini' && adminApi.api_key) {
                // Tentar descriptografar a chave do admin se necessário
                if (adminApi.api_key.includes(':')) {
                    try {
                        adminApiKey = decrypt(adminApi.api_key);
                    } catch (decryptError) {
                        console.warn('[Veo] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                        adminApiKey = adminApi.api_key;
                    }
                } else {
                    adminApiKey = adminApi.api_key;
                }
            }
            
            // Se não encontrou Gemini, buscar qualquer API do admin ativa
            if (!adminApiKey && adminApi && adminApi.api_key) {
                console.warn('[Veo] API do admin não é Gemini, mas tentando usar mesmo assim');
                if (adminApi.api_key.includes(':')) {
                    try {
                        adminApiKey = decrypt(adminApi.api_key);
                    } catch (decryptError) {
                        adminApiKey = adminApi.api_key;
                    }
                } else {
                    adminApiKey = adminApi.api_key;
                }
            }

            // Decidir qual chave usar
            if (userApiKey) {
                apiKey = userApiKey;
                apiKeySource = 'user_gemini';
                console.log('[Veo] Usando API própria do usuário');
            } else if (adminApiKey) {
                // Fallback: usar API do admin se própria não disponível
                apiKey = adminApiKey;
                useAdminApi = true;
                apiKeySource = 'admin_provider';
                console.log('[Veo] Usando API do admin (API própria não disponível)');
            }
        }

        // Validar API key antes de usar
        if (!useLaozhang && (!apiKey || apiKey.trim() === '')) {
            console.error('[Veo] ❌ API Key não encontrada ou vazia');
            console.error('[Veo] - useCredits:', useCredits);
            console.error('[Veo] - useLaozhang:', useLaozhang);
            
            // Se preferir créditos mas não tem API, sugerir configurar Laozhang.ai ou API Gemini no admin
            if (useCredits) {
                return res.status(400).json({ 
                    message: 'Para usar créditos na geração de vídeo, configure uma API no painel admin.',
                    details: 'Veo requer uma API configurada no painel admin. Configure no painel admin.'
                });
            }
            
            return res.status(400).json({ 
                message: 'Chave de API do Gemini não configurada ou inválida. Veo requer uma chave do Gemini com billing habilitado. Configure no painel admin (tipo Gemini) ou nas suas configurações.' 
            });
        }
        
        // Se usar Laozhang, usar a API da Laozhang.ai com modelo Veo
        if (useLaozhang) {
            const laozhangKey = laozhangApiKey || await getLaozhangApiKey();
            if (!laozhangKey) {
                return res.status(400).json({ 
                    message: 'Provedor externo não configurado no painel admin. Configure a chave de API primeiro.' 
                });
            }
            
            // Mapear modelo do frontend para modelo Laozhang.ai
            // Documentação: https://docs1.laozhang.ai/api-capabilities/veo/veo-31-overview
            // Para 16:9 (paisagem), usar modelos landscape: veo-3.1-landscape-fast ou veo-3.1-landscape
            // Para outros formatos, usar modelos padrão: veo-3.1-fast ou veo-3.1
            let laozhangModel = model;
            
            // Modo fixo: text-to-video (não suporta image-to-video)
            const isImageToVideo = false; // Sempre false para text-to-video
            
            // Determinar se é paisagem (16:9)
            const isLandscape = aspectRatio === '16:9';
            
            // Mapear modelos Sora 2 (apenas 15s - maior qualidade)
            if (model === 'sora_video2-15s' || model === 'sora_video2-landscape-15s' || model.includes('sora_video2')) {
                // Sora 2 de 15s usa modelos específicos conforme aspect ratio
                // sora_video2-15s = Portrait (704×1280, 15s), sora_video2-landscape-15s = Landscape (1280×704, 15s)
                if (isLandscape) {
                    laozhangModel = 'sora_video2-landscape-15s';
                } else {
                    laozhangModel = 'sora_video2-15s';
                }
                // Sora 2 suporta image-to-video nativamente, não precisa de modelo diferente
                console.log(`[Sora 2 Laozhang] Modelo selecionado: ${laozhangModel} (${isLandscape ? 'Landscape' : 'Portrait'}, 15s)`);
            } else if (model === 'veo-3.1-fast' || model.includes('veo-3.1-fast')) {
                if (isLandscape) {
                    // Para paisagem 16:9, usar modelos landscape
                    laozhangModel = isImageToVideo ? 'veo-3.1-landscape-fast-fl' : 'veo-3.1-landscape-fast';
                } else {
                    // Para outros formatos, usar modelos padrão
                    laozhangModel = isImageToVideo ? 'veo-3.1-fast-fl' : 'veo-3.1-fast';
                }
            } else if (model === 'veo-3.1' || model.includes('veo-3.1')) {
                if (isLandscape) {
                    // Para paisagem 16:9, usar modelos landscape
                    laozhangModel = isImageToVideo ? 'veo-3.1-landscape-fl' : 'veo-3.1-landscape';
                } else {
                    // Para outros formatos, usar modelos padrão
                    laozhangModel = isImageToVideo ? 'veo-3.1-fl' : 'veo-3.1';
                }
            } else {
                // Se já for um modelo específico (Sora 2), usar diretamente
                laozhangModel = model;
            }
            
            const isSora2 = laozhangModel.includes('sora_video2');
            const modelType = isSora2 ? 'Sora 2' : 'Veo';
            console.log(`[${modelType} Laozhang] Modo detectado: ${mode}, Image-to-video: ${isImageToVideo}, Aspect Ratio: ${aspectRatio}, Landscape: ${isLandscape}, Modelo selecionado: ${laozhangModel}`);
            
            console.log(`[${modelType} Laozhang] Usando Laozhang.ai com modelo:`, laozhangModel);
            console.log('[Veo Laozhang] Prompt:', prompt ? `"${prompt.substring(0, 100)}..."` : 'VAZIO');
            
            // Construir payload no formato Chat Completions da Laozhang.ai
            // Documentação: https://docs1.laozhang.ai/api-capabilities/veo/veo-31-overview
            // Formato: messages com role "user" e content como array de objetos {type, text/image_url}
            
            const laozhangMessages = [];
            
            // Adicionar texto do prompt (modo text-to-video)
            if (prompt && prompt.trim()) {
                laozhangMessages.push({
                    type: 'text',
                    text: prompt.trim()
                });
            }
            
            // Modo text-to-video: não adiciona frames, referências ou vídeos de entrada
            // (código removido - apenas text-to-video suportado)
            
            // Construir payload final no formato Chat Completions
            const laozhangPayload = {
                model: laozhangModel,
                messages: [
                    {
                        role: 'user',
                        content: laozhangMessages
                    }
                ],
                stream: true, // Recomendado pela documentação para obter progresso
                n: 1 // Número de vídeos a gerar (1-4)
            };
            
            // Adicionar parâmetros adicionais se necessário
            // Nota: resolução e aspect ratio são controlados pelo modelo escolhido
            // veo-3.1-landscape* para 16:9, outros para formato padrão
            
            try {
                // Laozhang.ai usa endpoint Chat Completions padrão
                const endpoint = LAOZHANG_CHAT_ENDPOINT;
                
                console.log(`[Veo Laozhang] Usando endpoint: ${endpoint}`);
                console.log(`[Veo Laozhang] Modelo: ${laozhangModel}`);
                console.log(`[Veo Laozhang] Modo: ${mode}`);
                console.log(`[Veo Laozhang] Payload (resumido):`, JSON.stringify({
                    model: laozhangPayload.model,
                    messages: laozhangPayload.messages.map(m => ({
                        role: m.role,
                        content: m.content.map(c => c.type === 'text' ? { type: c.type, text: c.text.substring(0, 50) + '...' } : { type: c.type })
                    })),
                    stream: laozhangPayload.stream,
                    n: laozhangPayload.n
                }, null, 2));
                
                // Debitar créditos antes da chamada
                const laozhangProviderId = await getLaozhangApiProviderId();
                if (laozhangProviderId && userId) {
                    // Estimar créditos baseado na resolução e modelo
                    // Sora 2 = $0.15, veo-3.1-fast* = $0.15, veo-3.1 (padrão) = $0.25
                    const isSora2 = laozhangModel.includes('sora_video2');
                    const isFastModel = laozhangModel.includes('fast');
                    const estimatedCredits = (isSora2 || isFastModel) ? 15 : 25; // Aproximado em créditos
                    await checkAndDebitCredits(
                        userId,
                        laozhangProviderId,
                        estimatedCredits,
                        'api_video_generation',
                        JSON.stringify({ 
                            endpoint: '/api/video/generate', 
                            model: laozhangModel, 
                            mode, 
                            resolution, 
                            aspectRatio 
                        })
                    );
                }
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${laozhangKey}`
                    },
                    body: JSON.stringify(laozhangPayload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`[Veo Laozhang] ❌ Erro HTTP ${response.status}:`, errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                // Laozhang.ai retorna stream quando stream=true
                // Processar resposta stream ou JSON
                let laozhangResponse;
                const contentType = response.headers.get('content-type');
                
                // Verificar se o frontend quer SSE para progresso em tempo real
                const acceptHeader = req.headers.accept || '';
                const wantsSSE = acceptHeader.includes('text/event-stream');
                
                if (contentType && contentType.includes('text/event-stream')) {
                    // Resposta é stream - processar eventos SSE
                    console.log('[Veo Laozhang] Resposta é stream, processando eventos SSE...');
                    
                    // Se frontend quer SSE, configurar resposta como SSE
                    if (wantsSSE) {
                        res.setHeader('Content-Type', 'text/event-stream');
                        res.setHeader('Cache-Control', 'no-cache');
                        res.setHeader('Connection', 'keep-alive');
                    }
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    let operationId = null;
                    let fullContent = ''; // Acumular todo o conteúdo
                    let isFinished = false;
                    let lastProgress = 0; // Última porcentagem enviada
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';
                        
                        for (const line of lines) {
                            if (line.trim() === '' || line === '[DONE]') continue;
                            
                            if (line.startsWith('data: ')) {
                                try {
                                    const dataStr = line.substring(6);
                                    if (dataStr === '[DONE]') {
                                        isFinished = true;
                                        break;
                                    }
                                    
                                    const data = JSON.parse(dataStr);
                                    
                                    // Procurar por operationId
                                    if (data.id) {
                                        operationId = data.id;
                                    }
                                    
                                    // Acumular conteúdo dos chunks
                                    if (data.choices && data.choices.length > 0) {
                                        const choice = data.choices[0];
                                        if (choice.delta) {
                                            // Acumular conteúdo se existir
                                            if (choice.delta.content) {
                                                fullContent += choice.delta.content;
                                                console.log('[Veo Laozhang] Conteúdo acumulado:', fullContent.length, 'chars. Último chunk:', choice.delta.content.substring(0, 50));
                                                
                                                // Extrair porcentagem de progresso do conteúdo
                                                // Padrões: "进度：9.0%", "Progress: 36.0%", "🏃 进度：44.9%"
                                                const progressMatch = choice.delta.content.match(/(?:进度|Progress)[：:]\s*(\d+\.?\d*)%/i) || 
                                                                     choice.delta.content.match(/(\d+\.?\d*)%/);
                                                if (progressMatch && progressMatch[1]) {
                                                    const progressPercent = parseFloat(progressMatch[1]);
                                                    if (!isNaN(progressPercent) && progressPercent !== lastProgress) {
                                                        lastProgress = progressPercent;
                                                        console.log(`[Veo Laozhang] 📊 Progresso detectado: ${progressPercent}%`);
                                                        
                                                        // Atualizar progresso na operação se já existir
                                                        if (operationId && videoOperations.has(operationId)) {
                                                            const op = videoOperations.get(operationId);
                                                            op.progress = progressPercent;
                                                            op.progressMessage = `Gerando vídeo... ${progressPercent.toFixed(1)}%`;
                                                            videoOperations.set(operationId, op);
                                                        }
                                                    }
                                                }
                                            }
                                            
                                            // Verificar se há vídeo diretamente no delta
                                            if (choice.delta.video || choice.delta.uri || choice.delta.url) {
                                                const videoUri = choice.delta.video?.uri || choice.delta.uri || choice.delta.url;
                                                console.log('[Veo Laozhang] ✅ Vídeo URI encontrado no delta:', videoUri);
                                                return res.json({
                                                    video: { uri: videoUri },
                                                    status: 'completed',
                                                    message: 'Vídeo gerado com sucesso.'
                                                });
                                            }
                                            
                                            // Verificar outros campos que podem conter o vídeo
                                            if (choice.delta.role === 'assistant' && choice.delta.function_call) {
                                                console.log('[Veo Laozhang] Function call encontrado no delta');
                                            }
                                        }
                                        
                                        // Verificar se terminou
                                        if (choice.finish_reason === 'stop') {
                                            isFinished = true;
                                            console.log('[Veo Laozhang] ✅ Stream finalizado. Conteúdo total acumulado:', fullContent.length, 'caracteres');
                                            if (fullContent.length > 0) {
                                                console.log('[Veo Laozhang] Primeiros 500 chars do conteúdo:', fullContent.substring(0, 500));
                                            }
                                        }
                                    }
                                    
                                    // Se vídeo estiver pronto diretamente no evento
                                    if (data.video || data.uri || data.url) {
                                        const videoUri = data.video?.uri || data.uri || data.url;
                                        return res.json({
                                            video: { uri: videoUri },
                                            status: 'completed',
                                            message: 'Vídeo gerado com sucesso.'
                                        });
                                    }
                                } catch (e) {
                                    // Ignorar linhas que não são JSON
                                    console.warn('[Veo Laozhang] Erro ao parsear evento SSE:', e.message);
                                }
                            }
                        }
                        
                        if (isFinished) break;
                    }
                    
                    // Processar conteúdo completo quando stream terminar
                    if (fullContent && fullContent.trim()) {
                        console.log('[Veo Laozhang] Conteúdo completo recebido (', fullContent.length, 'caracteres):', fullContent.substring(0, 500));
                        
                        // Limpar o conteúdo (pode ter markdown code blocks)
                        let cleanContent = fullContent.trim();
                        cleanContent = cleanContent.replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/```\s*$/i, '');
                        
                        // Tentar parsear como JSON
                        let contentData = null;
                        try {
                            contentData = JSON.parse(cleanContent);
                            console.log('[Veo Laozhang] ✅ Conteúdo parseado como JSON');
                        } catch (parseError) {
                            // Se não for JSON válido, tentar extrair JSON do texto
                            console.log('[Veo Laozhang] Conteúdo não é JSON puro, tentando extrair JSON...');
                            const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
                            if (jsonMatch) {
                                try {
                                    contentData = JSON.parse(jsonMatch[0]);
                                    console.log('[Veo Laozhang] ✅ JSON extraído do texto');
                                } catch (e) {
                                    console.warn('[Veo Laozhang] Não foi possível parsear JSON extraído');
                                }
                            }
                        }
                        
                        // Se conseguiu parsear como JSON
                        if (contentData) {
                            // Procurar vídeo URI em diferentes formatos
                            const videoUri = contentData.video?.uri || 
                                          contentData.video?.url ||
                                          contentData.uri || 
                                          contentData.url ||
                                          contentData.videoUri ||
                                          contentData.video_url;
                            
                            if (videoUri) {
                                console.log('[Veo Laozhang] ✅ Vídeo URI encontrado no JSON:', videoUri);
                                return res.json({
                                    video: { uri: videoUri },
                                    status: 'completed',
                                    message: 'Vídeo gerado com sucesso.'
                                });
                            }
                            
                            // Se contém operationId para polling
                            if (contentData.operationId || contentData.id || contentData.operation) {
                                operationId = contentData.operationId || contentData.id || contentData.operation;
                            }
                        }
                        
                        // Se não encontrou no JSON, tentar extrair URI do texto (regex)
                        console.log('[Veo Laozhang] Tentando extrair URI do texto com regex...');
                        // Padrões mais específicos primeiro, depois genéricos
                        // Sora 2 retorna links em formato markdown: [click here](https://sora.gptkey.asia/assets/sora/xxx.mp4)
                        const uriPatterns = [
                            /\[[^\]]+\]\(([^\)]+\.mp4[^\)]*)\)/g,  // Markdown links [text](url.mp4) - Sora 2
                            /https?:\/\/[^\s"',<>\)]+\.mp4[^\)]*/g,  // URLs .mp4 (prioridade)
                            /https?:\/\/[^\s"',<>\)]+/g,  // URLs completas (sem parênteses no final)
                            /https?:\/\/[^\s"',<>]+/g,  // URLs completas (fallback)
                            /uri["\s:]+["']?([^"'\s]+)["']?/i,  // uri: "url"
                            /url["\s:]+["']?([^"'\s]+)["']?/i   // url: "url"
                        ];
                        
                        for (const pattern of uriPatterns) {
                            const matches = cleanContent.match(pattern);
                            if (matches && matches.length > 0) {
                                console.log('[Veo Laozhang] Matches encontrados:', matches.length, matches.slice(0, 3));
                                
                                // Pegar a primeira URL que parece ser de vídeo
                                let videoUri = matches.find(url => 
                                    url.includes('googleapis.com') || 
                                    url.includes('storage.googleapis.com') ||
                                    url.includes('aliyuncs.com') ||  // Laozhang.ai usa Aliyun CDN
                                    url.includes('sora.gptkey.asia') ||  // Sora 2 CDN
                                    url.includes('mycdn') ||
                                    url.includes('video') ||
                                    url.match(/https?:\/\/[^\s"']+\.mp4/i)
                                ) || matches[0];
                                
                                // Se o match foi de markdown, extrair apenas a URL
                                if (videoUri && videoUri.includes('](')) {
                                    const markdownMatch = videoUri.match(/\]\(([^\)]+)\)/);
                                    if (markdownMatch && markdownMatch[1]) {
                                        videoUri = markdownMatch[1];
                                    }
                                }
                                
                                if (videoUri) {
                                    // Limpar a URL: remover parênteses, colchetes, aspas e outros caracteres inválidos no final
                                    videoUri = videoUri.replace(/[\)\]\}"']+$/, '').trim();
                                    
                                    // Verificar se é uma URL válida
                                    try {
                                        new URL(videoUri);
                                        console.log('[Veo Laozhang] ✅ Vídeo URI extraído e limpo:', videoUri);
                                        console.log('[Veo Laozhang] Retornando resposta com vídeo URI...');
                                        
                                        // IMPORTANTE: Retornar resposta no formato que o frontend espera
                                        // Frontend espera: { status: 'completed', videoUri: '...' }
                                        const responseData = {
                                            status: 'completed',
                                            videoUri: videoUri,
                                            message: 'Vídeo gerado com sucesso.'
                                        };
                                        console.log('[Veo Laozhang] Resposta sendo enviada:', JSON.stringify(responseData));
                                        
                                        // Armazenar também na operação para polling
                                        if (operationId) {
                                            videoOperations.set(operationId, {
                                                userId,
                                                operation: { id: operationId },
                                                useAdminApi: false,
                                                adminApi: null,
                                                createdAt: new Date(),
                                                status: 'completed',
                                                videoUri: videoUri,
                                                useLaozhang: true,
                                                laozhangKey: laozhangKey
                                            });
                                        }
                                        
                                        return res.json(responseData);
                                    } catch (urlError) {
                                        console.warn('[Veo Laozhang] ⚠️ URL extraída não é válida:', videoUri, urlError.message);
                                    }
                                }
                            }
                        }
                        
                        console.warn('[Veo Laozhang] ⚠️ Não foi possível extrair vídeo URI do conteúdo');
                        console.log('[Veo Laozhang] Conteúdo completo para debug:', cleanContent.substring(0, 1000));
                    }
                    
                    // Se chegou aqui e tem operationId, retornar para polling
                    if (operationId) {
                        // Tentar fazer uma chamada adicional para obter o vídeo se o conteúdo não tiver URI
                        // A Laozhang.ai pode retornar o vídeo em uma chamada separada
                        if (fullContent && !fullContent.match(/https?:\/\/[^\s"']+/)) {
                            console.log('[Veo Laozhang] Conteúdo não contém URI, tentando obter vídeo via polling...');
                            
                            // Tentar fazer polling imediatamente (algumas APIs retornam o vídeo logo após)
                            try {
                                // Aguardar um pouco antes de fazer polling
                                await new Promise(resolve => setTimeout(resolve, 2000));
                                
                                // Fazer uma chamada para verificar se o vídeo está pronto
                                // Nota: A Laozhang.ai pode ter um endpoint específico para isso
                                // Por enquanto, armazenar e deixar o polling do frontend verificar
                            } catch (pollError) {
                                console.warn('[Veo Laozhang] Erro ao tentar polling imediato:', pollError.message);
                            }
                        }
                        
                        // Extrair última porcentagem do conteúdo completo
                        let finalProgress = 0;
                        const finalProgressMatch = fullContent.match(/(?:进度|Progress)[：:]\s*(\d+\.?\d*)%/gi);
                        if (finalProgressMatch && finalProgressMatch.length > 0) {
                            const lastMatch = finalProgressMatch[finalProgressMatch.length - 1];
                            const percentMatch = lastMatch.match(/(\d+\.?\d*)%/);
                            if (percentMatch && percentMatch[1]) {
                                finalProgress = parseFloat(percentMatch[1]);
                            }
                        }
                        
                        // Armazenar operação com o conteúdo completo para processamento posterior
                        videoOperations.set(operationId, {
                            userId,
                            operation: { 
                                id: operationId,
                                content: fullContent,
                                model: laozhangModel
                            },
                            useAdminApi: false,
                            adminApi: null,
                            createdAt: new Date(),
                            status: fullContent && fullContent.length > 0 ? 'processing' : 'processing',
                            useLaozhang: true,
                            laozhangKey: laozhangKey,
                            // Armazenar conteúdo para processamento na rota de status
                            rawContent: fullContent,
                            // Armazenar progresso extraído
                            progress: finalProgress,
                            progressMessage: finalProgress > 0 ? `Gerando vídeo... ${finalProgress.toFixed(1)}%` : 'Processando...'
                        });
                        
                        console.log(`[Veo Laozhang] Operação ${operationId} armazenada para polling. Conteúdo (${fullContent.length} chars): ${fullContent.substring(0, 200)}...`);
                        
                        return res.json({
                            operationId: operationId,
                            status: 'processing',
                            message: 'Geração de vídeo iniciada. Use o operationId para verificar o status.'
                        });
                    }
                    
                    // Se não tem operationId nem conteúdo, retornar erro
                    throw new Error('Não foi possível obter operationId ou vídeo da resposta. Conteúdo recebido: ' + (fullContent ? fullContent.substring(0, 200) : 'vazio'));
                } else {
                    // Resposta é JSON normal
                    laozhangResponse = await response.json();
                    console.log(`[Veo Laozhang] ✅ Resposta JSON recebida:`, JSON.stringify(laozhangResponse, null, 2).substring(0, 500));
                }
                
                // Processar resposta JSON
                let responseData = laozhangResponse;
                
                // Se a resposta contém choices (formato Chat Completions)
                if (responseData.choices && responseData.choices.length > 0) {
                    const choice = responseData.choices[0];
                    if (choice.message && choice.message.content) {
                        // Tentar parsear o content como JSON
                        try {
                            const contentData = JSON.parse(choice.message.content);
                            responseData = contentData;
                        } catch (e) {
                            // Se não for JSON, usar o content como está
                            responseData = { content: choice.message.content };
                        }
                    }
                }
                
                // Se a resposta contém operationId ou similar, retornar
                if (responseData.operationId || responseData.operation || responseData.id || responseData.name) {
                    const operationId = responseData.operationId || responseData.operation || responseData.id || responseData.name;
                    
                    // Armazenar operação
                    const laozhangOperation = {
                        userId,
                        operation: responseData,
                        useAdminApi: false,
                        adminApi: null,
                        createdAt: new Date(),
                        status: 'processing',
                        useLaozhang: true,
                        laozhangKey: laozhangKey
                    };
                    videoOperations.set(operationId, laozhangOperation);
                    await cacheVideoOperationMetadata(operationId, userId, {
                        apiKeySource: 'laozhang',
                        useLaozhang: true
                    });
                    
                    return res.json({
                        operationId: operationId,
                        status: 'processing',
                        message: 'Geração de vídeo iniciada. Use o operationId para verificar o status.'
                    });
                }
                
                // Se a resposta contém vídeo diretamente
                if (responseData.video || responseData.uri || responseData.url) {
                    const videoUri = responseData.video?.uri || responseData.uri || responseData.url;
                    // Frontend espera: { status: 'completed', videoUri: '...' }
                    return res.json({
                        status: 'completed',
                        videoUri: videoUri,
                        message: 'Vídeo gerado com sucesso.'
                    });
                }
                
                // Retornar resposta como está
                return res.json({
                    status: 'processing',
                    data: responseData,
                    message: 'Geração de vídeo iniciada.'
                });
                
            } catch (laozhangError) {
                console.error('[Veo Laozhang] Erro ao chamar Laozhang.ai:', laozhangError);
                return res.status(500).json({ 
                    message: 'Erro ao gerar vídeo: ' + (laozhangError.message || 'Erro desconhecido'),
                    details: laozhangError.details || laozhangError.error || 'Erro ao processar requisição'
                });
            }
        }

        // Validar formato da API key (deve começar com AIza ou similar)
        if (!apiKey.startsWith('AIza') && apiKey.length < 20) {
            console.warn('[Veo] ⚠️ API Key pode estar em formato inválido. Esperado formato Google API key.');
        }

        console.log('[Veo] ✅ API Key configurada:', apiKey.substring(0, 10) + '...' + apiKey.substring(apiKey.length - 4));
        console.log('[Veo] - Tamanho da chave:', apiKey.length, 'caracteres');
        console.log('[Veo] - Usando API do admin:', useAdminApi);

        // Construir payload para a API Veo
        const config = {
            numberOfVideos: 1,
            resolution: resolution
        };

        if (mode !== 'extend-video') {
            config.aspectRatio = aspectRatio;
        }

        // Construir payload base
        const generateVideoPayload = {
            model: model,
            config: config
        };

        // Adicionar prompt se fornecido (obrigatório para text-to-video)
        // Para extend-video, o prompt deve enfatizar continuar o vídeo existente
        if (mode === 'extend-video') {
            // Instruções muito específicas para garantir que o vídeo seja estendido, não recriado
            let extendPrompt = `VIDEO EXTENSION REQUEST:

You have been provided with a video. Your task is to EXTEND this video, creating a seamless continuation.

CRITICAL REQUIREMENTS:
1. This is NOT a new video - it is an EXTENSION of the existing video
2. The extended video must start EXACTLY where the provided video ends
3. Maintain IDENTICAL scene, characters, camera angle, lighting, colors, and visual style
4. Create a smooth, natural continuation - it should feel like ONE continuous video
5. The transition between the original and extension must be seamless
6. Do NOT change the scene, location, or context
7. Do NOT introduce new characters or elements that weren't in the original
8. The final output should be a SINGLE continuous video that combines the original 8 seconds with approximately 7 more seconds of extension, totaling around 15 seconds

${prompt && prompt.trim() ? `Additional continuation direction: ${prompt.trim()}` : 'Continue the video naturally, maintaining the exact same visual style and narrative flow.'}

Remember: The goal is to create ONE unified video, not two separate videos. The extension must connect seamlessly.`;
            
            generateVideoPayload.prompt = extendPrompt;
            console.log('[Veo] Prompt para extend-video:', extendPrompt.substring(0, 300));
        } else if (prompt && prompt.trim()) {
            generateVideoPayload.prompt = prompt.trim();
        }

        // Modo: Frames to Video
        if (mode === 'frames-to-video') {
            if (startFrame && startFrame.base64) {
                generateVideoPayload.image = {
                    imageBytes: startFrame.base64,
                    mimeType: startFrame.mimeType || 'image/jpeg'
                };
            }

            const finalEndFrame = isLooping ? startFrame : endFrame;
            if (finalEndFrame && finalEndFrame.base64) {
                generateVideoPayload.config.lastFrame = {
                    imageBytes: finalEndFrame.base64,
                    mimeType: finalEndFrame.mimeType || 'image/jpeg'
                };
            }
        }
        // Modo: References to Video
        else if (mode === 'references-to-video') {
            const referenceImagesPayload = [];

            for (const img of referenceImages) {
                if (img.base64) {
                    referenceImagesPayload.push({
                        image: {
                            imageBytes: img.base64,
                            mimeType: img.mimeType || 'image/jpeg'
                        },
                        referenceType: 'ASSET'
                    });
                }
            }

            if (styleImage && styleImage.base64) {
                referenceImagesPayload.push({
                    image: {
                        imageBytes: styleImage.base64,
                        mimeType: styleImage.mimeType || 'image/jpeg'
                    },
                    referenceType: 'STYLE'
                });
            }

            if (referenceImagesPayload.length > 0) {
                generateVideoPayload.config.referenceImages = referenceImagesPayload;
            }
        }
        // Modo: Extend Video
        else if (mode === 'extend-video') {
            // Para estender, precisamos do URI do vídeo gerado anteriormente
            // ESTRATÉGIA: Extrair o último frame e usar como imagem inicial
            if (!inputVideo) {
                return res.status(400).json({ message: 'Vídeo de entrada é obrigatório para estender.' });
            }
            
            try {
                let videoUri = null;
                if (inputVideo.uri) {
                    videoUri = inputVideo.uri;
                } else if (inputVideo.base64) {
                    const mimeType = inputVideo.mimeType || 'video/mp4';
                    videoUri = `data:${mimeType};base64,${inputVideo.base64}`;
                }
                
                if (videoUri && videoUri.startsWith('http')) {
                    // Baixar vídeo e extrair último frame usando FFmpeg
                    const tempVideoPath = path.join(__dirname, 'temp', `extend_${Date.now()}.mp4`);
                    const tempFramePath = path.join(__dirname, 'temp', `last_frame_${Date.now()}.jpg`);
                    
                    // Criar diretório temp se não existir
                    await fse.ensureDir(path.dirname(tempVideoPath));
                    
                    // Baixar vídeo
                    console.log('[Veo] Baixando vídeo para extrair último frame...');
                    const videoResponse = await axios({
                        url: videoUri,
                        method: 'GET',
                        responseType: 'stream',
                        timeout: 30000,
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (compatible; VideoGeneratorBot/1.0; +https://lacasa.ai)',
                            'Referer': videoUri
                        }
                    });
                    
                    const videoStream = fs.createWriteStream(tempVideoPath);
                    await new Promise((resolve, reject) => {
                        videoResponse.data.pipe(videoStream);
                        videoStream.on('finish', resolve);
                        videoStream.on('error', reject);
                    });
                    
                    // Extrair último frame usando FFmpeg
                    console.log('[Veo] Extraindo último frame com FFmpeg...');
                    await new Promise((resolve, reject) => {
                        ffmpeg(tempVideoPath)
                            .screenshots({
                                timestamps: ['99%'], // Pegar frame em 99% do vídeo
                                filename: path.basename(tempFramePath),
                                folder: path.dirname(tempFramePath),
                                size: '1280x720' // Manter resolução alta
                            })
                            .on('end', () => {
                                console.log('[Veo] ✅ Último frame extraído com sucesso');
                                resolve();
                            })
                            .on('error', (err) => {
                                console.error('[Veo] ❌ Erro ao extrair frame:', err.message);
                                reject(err);
                            });
                    });
                    
                    // Ler frame como base64
                    const frameBuffer = await fs.readFile(tempFramePath);
                    const frameBase64 = frameBuffer.toString('base64');
                    
                    // Limpar arquivos temporários
                    try {
                        await fs.unlink(tempVideoPath);
                        await fs.unlink(tempFramePath);
                    } catch (cleanupErr) {
                        console.warn('[Veo] Aviso ao limpar arquivos temporários:', cleanupErr.message);
                    }
                    
                    // Usar frame como imagem inicial (modo frames-to-video)
                    generateVideoPayload.image = {
                        imageBytes: frameBase64,
                        mimeType: 'image/jpeg'
                    };
                    
                    // Atualizar prompt para enfatizar continuação
                    if (generateVideoPayload.prompt) {
                        generateVideoPayload.prompt = `VIDEO EXTENSION: The image above is the LAST FRAME of an 8-second video. Generate a continuation that starts EXACTLY from this frame, maintains the SAME scene, characters, camera angle, lighting, and visual style, and creates approximately 7 more seconds of video, resulting in a TOTAL of 15 seconds (8s original + 7s extension). The continuation must be SEAMLESS and feel like ONE continuous video. ${generateVideoPayload.prompt}`;
                    }
                    
                    console.log('[Veo] Último frame extraído e configurado como imagem inicial para continuação');
                } else if (inputVideo.uri) {
                    // Fallback: usar URI diretamente se não for HTTP
                    generateVideoPayload.video = {
                        uri: inputVideo.uri
                    };
                } else {
                    return res.status(400).json({ message: 'Para estender um vídeo, você precisa usar um vídeo gerado anteriormente pelo Veo (que possui URI).' });
                }
            } catch (extractError) {
                console.error('[Veo] Erro ao extrair último frame:', extractError.message);
                // Fallback: tentar usar URI diretamente
                if (inputVideo.uri) {
                    generateVideoPayload.video = {
                        uri: inputVideo.uri
                    };
                } else {
                    return res.status(400).json({ message: `Erro ao processar vídeo para extensão: ${extractError.message}` });
                }
            }
        }

        console.log('[Veo] Prompt recebido:', prompt ? `"${prompt.substring(0, 100)}..."` : 'VAZIO');
        console.log('[Veo] Payload completo:', JSON.stringify(generateVideoPayload, null, 2));

        // Usar SDK do Google GenAI para Veo
        // Garantir que a API key está limpa (sem espaços)
        const cleanApiKey = apiKey.trim();
        
        if (!cleanApiKey || cleanApiKey.length === 0) {
            console.error('[Veo] ❌ API Key está vazia após limpeza!');
            return res.status(400).json({ 
                message: 'Chave de API inválida. Verifique se a chave do Gemini está correta e tem billing habilitado para usar o Veo.' 
            });
        }
        
        console.log('[Veo] Inicializando SDK do Google GenAI...');
        console.log('[Veo] - Modelo:', model);
        console.log('[Veo] - API Key (primeiros 10 chars):', cleanApiKey.substring(0, 10));
        
        const ai = new GoogleGenAI({ apiKey: cleanApiKey });
        
        // Garantir que o prompt está presente se necessário
        if (mode === 'text-to-video' && (!prompt || !prompt.trim())) {
            return res.status(400).json({ message: 'Prompt é obrigatório para geração de vídeo a partir de texto.' });
        }

        // O SDK espera o formato exato: model, config, e opcionalmente prompt, image, video, etc.
        // Construir payload exatamente como no exemplo do VETA
        const sdkPayload = {
            model: model,
            config: generateVideoPayload.config
        };

        // Adicionar prompt se existir (obrigatório para text-to-video)
        if (generateVideoPayload.prompt) {
            sdkPayload.prompt = generateVideoPayload.prompt;
            console.log('[Veo] Prompt adicionado ao SDK payload:', sdkPayload.prompt.substring(0, 100));
        } else {
            console.warn('[Veo] ATENÇÃO: Prompt não encontrado no generateVideoPayload!');
            // Se for text-to-video e não tiver prompt, adicionar do parâmetro original
            if (mode === 'text-to-video' && prompt && prompt.trim()) {
                sdkPayload.prompt = prompt.trim();
                console.log('[Veo] Prompt adicionado do parâmetro original:', sdkPayload.prompt.substring(0, 100));
            }
        }

        // Adicionar image se existir (frames-to-video)
        if (generateVideoPayload.image) {
            sdkPayload.image = generateVideoPayload.image;
        }

        // Adicionar video se existir (extend-video)
        if (generateVideoPayload.video) {
            sdkPayload.video = generateVideoPayload.video;
        }

        // referenceImages já está em config.referenceImages, não precisa adicionar separadamente

        console.log('[Veo] Payload completo para SDK:', JSON.stringify(sdkPayload, null, 2).substring(0, 1000));
        console.log('[Veo] Chamando SDK generateVideos com modelo:', model);
        
        // Validar que o modelo está correto
        const validModels = ['veo-3.1-fast-generate-preview', 'veo-3.1-generate-preview'];
        if (!validModels.includes(model)) {
            console.warn(`[Veo] Modelo "${model}" não está na lista de modelos válidos. Usando modelo padrão.`);
            sdkPayload.model = 'veo-3.1-fast-generate-preview';
        }
        
        // Chamar SDK - passar o payload diretamente como no exemplo do VETA
        let operation;
        try {
            operation = await ai.models.generateVideos(sdkPayload);
        } catch (sdkError) {
            console.error('[Veo] Erro ao chamar SDK generateVideos:', sdkError);
            
            // Tratar erros específicos da API
            if (sdkError.status === 400 && sdkError.message?.includes('API key')) {
                return res.status(400).json({ 
                    message: 'Chave de API inválida. Verifique se a chave do Gemini está correta e tem billing habilitado para usar o Veo.',
                    details: 'A chave de API precisa ter acesso ao Veo e billing habilitado no Google Cloud.'
                });
            }
            
            // Re-enviar erro genérico
            return res.status(sdkError.status || 500).json({ 
                message: sdkError.message || 'Erro ao gerar vídeo com Veo.',
                details: sdkError.details || sdkError.error || 'Erro desconhecido'
            });
        }
        
        console.log('[Veo] Operação criada:', operation.name || 'Sem nome');

        // Usar o nome completo da operação como ID (pode conter barras)
        const operationId = operation.name || `operation-${Date.now()}-${crypto.randomBytes(4).toString('hex')}`;
        
        console.log('[Veo] OperationId salvo:', operationId);

        // Armazenar operação usando o operationId completo
        const operationData = {
            userId,
            operation,
            prompt: prompt,
            model: model,
            aspectRatio: aspectRatio,
            resolution: resolution,
            useAdminApi,
            adminApi,
            createdAt: new Date(),
            status: 'processing'
        };
        videoOperations.set(operationId, operationData);
        await cacheVideoOperationMetadata(operationId, userId, {
            apiKeySource: apiKeySource || (useLaozhang ? 'laozhang' : 'unknown'),
            userKeyId: userGeminiKeyRow?.id || null,
            adminApiId: adminApi?.id || null,
            useLaozhang
        });
        
        console.log('[Veo] Operação armazenada. Total de operações:', videoOperations.size);

        // Se usou API do admin, debitar créditos (estimado)
        if (useAdminApi && adminApi) {
            try {
                // Estimar créditos baseado na resolução e modo
                const estimatedCredits = resolution === '1080p' ? 50 : 25;
                const creditResult = await checkAndDebitCredits(
                    userId,
                    adminApi.id,
                    estimatedCredits,
                    'api_video_generation',
                    JSON.stringify({ model, mode, resolution, aspectRatio })
                );
                console.log(`💳 [CRÉDITOS] ${creditResult.creditsUsed.toFixed(2)} créditos debitados. Saldo restante: ${creditResult.newBalance.toFixed(2)}`);
            } catch (creditError) {
                console.error('❌ [CRÉDITOS] Erro ao debitar créditos:', creditError);
            }
        }

        // Iniciar polling em background (usar cleanApiKey)
        pollVideoOperation(operationId, cleanApiKey);

        res.json({
            operationId: operationId,
            status: 'processing',
            message: 'Geração de vídeo iniciada. Use o operationId para verificar o status.'
        });

    } catch (error) {
        console.error('[Veo] Erro ao gerar vídeo:', error);
        if (error.response) {
            console.error('[Veo] Status:', error.response.status);
            console.error('[Veo] Data:', error.response.data);
        }
        
        // Tratar erros específicos
        let errorMessage = 'Erro ao gerar vídeo';
        let statusCode = 500;
        
        if (error.message?.includes('API key') || error.message?.includes('INVALID_ARGUMENT') || 
            error.response?.data?.error?.message?.includes('API key') ||
            error.response?.data?.error?.status === 'INVALID_ARGUMENT') {
            errorMessage = 'Chave de API inválida ou não configurada. Verifique se a chave do Gemini está correta e tem billing habilitado para usar o Veo.';
            statusCode = 400;
        } else if (error.message?.includes('PERMISSION_DENIED') || error.response?.data?.error?.status === 'PERMISSION_DENIED') {
            errorMessage = 'Permissão negada. Verifique se a chave de API tem acesso ao Veo e se o billing está habilitado.';
            statusCode = 403;
        } else if (error.response?.data?.error?.message) {
            errorMessage = error.response.data.error.message;
            statusCode = error.response.status || 500;
        } else if (error.message) {
            errorMessage = error.message;
        }

        res.status(statusCode).json({ 
            message: errorMessage,
            error: error.message || 'Erro desconhecido',
            details: error.response?.data?.error || error.details || null
        });
    }
});

// Função para fazer polling da operação
async function pollVideoOperation(operationId, apiKey) {
    const maxAttempts = 60; // 10 minutos máximo (10s * 60)
    let attempts = 0;

    while (attempts < maxAttempts) {
        try {
            const operationData = videoOperations.get(operationId);
            if (!operationData) {
                console.log(`[Veo] Operação ${operationId} não encontrada`);
                break;
            }

            const operation = operationData.operation;
            if (!operation.name) {
                console.log(`[Veo] Operação ${operationId} sem nome`);
                break;
            }

            // Usar SDK para verificar status
            const ai = new GoogleGenAI({ apiKey: apiKey });
            
            // Obter operação atualizada do SDK (precisa do nome da operação)
            const updatedOperation = await ai.operations.getVideosOperation({ name: operationId });
            
            console.log(`[Veo] Status da operação ${operationId}:`, updatedOperation.done ? 'Concluída' : 'Processando');

            if (updatedOperation.done) {
                // Operação concluída
                if (updatedOperation.response && updatedOperation.response.generatedVideos) {
                    const videos = updatedOperation.response.generatedVideos;
                    if (videos.length > 0 && videos[0].video && videos[0].video.uri) {
                        const videoUri = videos[0].video.uri;
                        
                        console.log(`[Veo] Vídeo gerado. URI: ${videoUri}`);
                        
                        try {
                            // Baixar vídeo - o URI já contém a URL completa
                            let videoUrl = videoUri;
                            if (!videoUrl.includes('key=')) {
                                videoUrl = `${videoUri}${videoUri.includes('?') ? '&' : '?'}key=${apiKey}`;
                            }
                            
                            console.log(`[Veo] Baixando vídeo de: ${videoUrl.substring(0, 100)}...`);
                            
                            const videoResponse = await axios.get(videoUrl, {
                                responseType: 'arraybuffer',
                                timeout: 120000
                            });

                            const videoBuffer = Buffer.from(videoResponse.data);
                            const videoBase64 = videoBuffer.toString('base64');

                            // Atualizar operação
                            videoOperations.set(operationId, {
                                ...operationData,
                                status: 'completed',
                                videoUri: videoUri,
                                videoBase64: videoBase64,
                                videoMimeType: 'video/mp4'
                            });

                            console.log(`[Veo] Vídeo gerado com sucesso: ${operationId} (${videoBuffer.length} bytes)`);
                            await removeVideoOperationCache(operationId);
                            return;
                        } catch (downloadError) {
                            console.error(`[Veo] Erro ao baixar vídeo:`, downloadError.message);
                            // Mesmo com erro no download, retornar o URI para o frontend tentar baixar
                            videoOperations.set(operationId, {
                                ...operationData,
                                status: 'completed',
                                videoUri: videoUri,
                                videoBase64: null,
                                videoMimeType: 'video/mp4',
                                downloadError: downloadError.message
                            });
                            await removeVideoOperationCache(operationId);
                            return;
                        }
                    }
                }

                // Verificar se há erro na operação
                if (updatedOperation.error) {
                    videoOperations.set(operationId, {
                        ...operationData,
                        status: 'error',
                        error: updatedOperation.error.message || 'Erro na geração do vídeo'
                    });
                    await removeVideoOperationCache(operationId);
                } else {
                    videoOperations.set(operationId, {
                        ...operationData,
                        status: 'error',
                        error: 'Nenhum vídeo foi gerado na resposta'
                    });
                    await removeVideoOperationCache(operationId);
                }
                break;
            }

            // Atualizar operação no storage
            videoOperations.set(operationId, {
                ...operationData,
                operation: updatedOperation
            });

            // Ainda processando
            attempts++;
            await new Promise(resolve => setTimeout(resolve, 10000)); // Aguardar 10 segundos

        } catch (error) {
            console.error(`[Veo] Erro ao verificar status da operação ${operationId}:`, error.message);
            videoOperations.set(operationId, {
                ...videoOperations.get(operationId),
                status: 'error',
                error: error.message
            });
            await removeVideoOperationCache(operationId);
            break;
        }
    }

    if (attempts >= maxAttempts) {
        videoOperations.set(operationId, {
            ...videoOperations.get(operationId),
            status: 'timeout',
            error: 'Timeout aguardando conclusão da geração'
        });
        await removeVideoOperationCache(operationId);
    }
}

// GET /api/video/status/:operationId - Verificar status da geração
app.get('/api/video/status/:operationId', authenticateToken, async (req, res) => {
    // Decodificar o operationId (pode conter barras e caracteres especiais)
    let operationId = decodeURIComponent(req.params.operationId);
    const userId = req.user.id;

    console.log('[Veo] Verificando status para operationId:', operationId);
    console.log('[Veo] Operações disponíveis:', Array.from(videoOperations.keys()));

    try {
        const operationData = videoOperations.get(operationId);
        
        if (!operationData) {
            console.warn('[Veo] Operação não encontrada no Map. Tentando reidratar a partir do banco...');
            const cached = await db.get('SELECT * FROM video_operations_cache WHERE operation_id = ?', [operationId]);
            if (cached) {
                const apiKey = await resolveCachedVideoApiKey(cached);
                if (apiKey) {
                    const restoredOperation = {
                        userId: cached.user_id,
                        operation: { name: operationId },
                        status: 'processing',
                        useAdminApi: cached.api_key_source === 'admin_provider',
                        adminApi: cached.admin_api_id ? await db.get('SELECT * FROM api_providers WHERE id = ?', [cached.admin_api_id]) : null,
                        useLaozhang: cached.use_laozhang === 1
                    };
                    videoOperations.set(operationId, restoredOperation);
                    pollVideoOperation(operationId, apiKey);
                    return res.json({ status: 'processing', restored: true, progress: 0, progressMessage: 'Processando...' });
                }
            }
            
            console.error('[Veo] Operação não encontrada nem no cache. OperationId procurado:', operationId);
            console.error('[Veo] Chaves disponíveis:', Array.from(videoOperations.keys()));
            return res.status(404).json({ message: 'Operação não encontrada' });
        }

        if (operationData.userId !== userId) {
            return res.status(403).json({ message: 'Acesso negado' });
        }

        // Extrair progresso atual se disponível
        let currentProgress = operationData.progress || 0;
        let progressMessage = operationData.progressMessage || 'Processando...';
        
        // Se não tem progresso armazenado mas tem conteúdo, tentar extrair
        if (currentProgress === 0 && (operationData.operation?.content || operationData.rawContent)) {
            const content = operationData.operation?.content || operationData.rawContent || '';
            const progressMatch = content.match(/(?:进度|Progress)[：:]\s*(\d+\.?\d*)%/gi);
            if (progressMatch && progressMatch.length > 0) {
                const lastMatch = progressMatch[progressMatch.length - 1];
                const percentMatch = lastMatch.match(/(\d+\.?\d*)%/);
                if (percentMatch && percentMatch[1]) {
                    currentProgress = parseFloat(percentMatch[1]);
                    progressMessage = `Gerando vídeo... ${currentProgress.toFixed(1)}%`;
                    // Atualizar operação com progresso extraído
                    operationData.progress = currentProgress;
                    operationData.progressMessage = progressMessage;
                    videoOperations.set(operationId, operationData);
                }
            }
        }
        
        // Se for Laozhang.ai e tiver conteúdo, processar para extrair vídeo URI
        if (operationData.useLaozhang && (operationData.operation?.content || operationData.rawContent) && !operationData.videoUri) {
            try {
                let content = operationData.operation?.content || operationData.rawContent || '';
                console.log('[Veo Laozhang] Processando conteúdo para extrair vídeo URI (', content.length, 'chars)');
                
                if (!content || content.trim().length === 0) {
                    console.warn('[Veo Laozhang] ⚠️ Conteúdo vazio, não é possível extrair vídeo URI');
                } else {
                    console.log('[Veo Laozhang] Primeiros 500 chars do conteúdo:', content.substring(0, 500));
                    
                    // Limpar o conteúdo (pode ter markdown code blocks)
                    let cleanContent = content.trim();
                    cleanContent = cleanContent.replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/```\s*$/i, '');
                    
                    // Tentar parsear como JSON
                    let contentData = null;
                    try {
                        contentData = JSON.parse(cleanContent);
                        console.log('[Veo Laozhang] ✅ Conteúdo parseado como JSON');
                    } catch (parseError) {
                        // Se não for JSON válido, tentar extrair JSON do texto
                        console.log('[Veo Laozhang] Conteúdo não é JSON puro, tentando extrair JSON...');
                        const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            try {
                                contentData = JSON.parse(jsonMatch[0]);
                                console.log('[Veo Laozhang] ✅ JSON extraído do texto');
                            } catch (e) {
                                console.warn('[Veo Laozhang] Não foi possível parsear JSON extraído');
                            }
                        }
                    }
                    
                    // Se conseguiu parsear como JSON
                    if (contentData) {
                        // Procurar vídeo URI em diferentes formatos
                        const videoUri = contentData.video?.uri || 
                                      contentData.video?.url ||
                                      contentData.uri || 
                                      contentData.url ||
                                      contentData.videoUri ||
                                      contentData.video_url ||
                                      contentData.result?.video?.uri ||
                                      contentData.result?.uri;
                        
                        if (videoUri) {
                            console.log('[Veo Laozhang] ✅ Vídeo URI encontrado no JSON:', videoUri);
                            // Atualizar operação com vídeo URI
                            videoOperations.set(operationId, {
                                ...operationData,
                                videoUri: videoUri,
                                status: 'completed'
                            });
                            
                            return res.json({
                                status: 'completed',
                                videoUri: videoUri,
                                videoBase64: null,
                                videoMimeType: 'video/mp4',
                                error: null,
                                downloadError: null
                            });
                        }
                    }
                    
                    // Se não encontrou no JSON, tentar extrair URI do texto (regex)
                    console.log('[Veo Laozhang] Tentando extrair URI do texto com regex...');
                    const uriPatterns = [
                        /https?:\/\/[^\s"',<>]+/g,  // URLs completas
                        /uri["\s:]+["']?([^"'\s]+)["']?/i,  // uri: "url"
                        /url["\s:]+["']?([^"'\s]+)["']?/i   // url: "url"
                    ];
                    
                    for (const pattern of uriPatterns) {
                        const matches = cleanContent.match(pattern);
                        if (matches && matches.length > 0) {
                            // Pegar a primeira URL que parece ser de vídeo
                            let videoUri = matches.find(url => 
                                url.includes('googleapis.com') || 
                                url.includes('storage.googleapis.com') ||
                                url.includes('aliyuncs.com') ||  // Laozhang.ai usa Aliyun CDN
                                url.includes('mycdn') ||
                                url.includes('video') ||
                                url.match(/https?:\/\/[^\s"']+\.mp4/i)
                            ) || matches[0];
                            
                            if (videoUri) {
                                // Limpar a URL: remover parênteses, colchetes, aspas e outros caracteres inválidos no final
                                videoUri = videoUri.replace(/[\)\]\}"']+$/, '').trim();
                                
                                // Verificar se é uma URL válida
                                try {
                                    new URL(videoUri);
                                    console.log('[Veo Laozhang] ✅ Vídeo URI extraído e limpo:', videoUri);
                                    // Atualizar operação com vídeo URI
                                    videoOperations.set(operationId, {
                                        ...operationData,
                                        videoUri: videoUri,
                                        status: 'completed'
                                    });
                                    
                                    return res.json({
                                        status: 'completed',
                                        videoUri: videoUri,
                                        videoBase64: null,
                                        videoMimeType: 'video/mp4',
                                        error: null,
                                        downloadError: null
                                    });
                                } catch (urlError) {
                                    console.warn('[Veo Laozhang] ⚠️ URL extraída não é válida:', videoUri);
                                }
                            }
                        }
                    }
                    
                    console.warn('[Veo Laozhang] ⚠️ Não foi possível extrair vídeo URI do conteúdo');
                }
            } catch (error) {
                console.error('[Veo Laozhang] Erro ao processar conteúdo:', error);
            }
        }
        
        // Se o vídeo foi concluído, salvar no banco de dados
        if (operationData.status === 'completed' && operationData.videoUri) {
            try {
                // Verificar se já existe a tabela
                await db.exec(`
                    CREATE TABLE IF NOT EXISTS generated_videos (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        operation_id TEXT UNIQUE NOT NULL,
                        video_uri TEXT NOT NULL,
                        prompt TEXT,
                        model TEXT,
                        aspect_ratio TEXT,
                        resolution TEXT,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                    )
                `);
                
                // Verificar se já existe
                const existing = await db.get(
                    'SELECT id FROM generated_videos WHERE operation_id = ?',
                    [operationId]
                );
                
                if (!existing) {
                    // Salvar vídeo gerado
                    await db.run(`
                        INSERT INTO generated_videos (
                            user_id, operation_id, video_uri, prompt, model, aspect_ratio, resolution
                        ) VALUES (?, ?, ?, ?, ?, ?, ?)
                    `, [
                        userId,
                        operationId,
                        operationData.videoUri,
                        operationData.prompt || null,
                        operationData.model || null,
                        operationData.aspectRatio || null,
                        operationData.resolution || null
                    ]);
                    console.log('[Video History] ✅ Vídeo salvo no histórico:', operationId);
                }
            } catch (error) {
                console.error('[Video History] Erro ao salvar vídeo no histórico:', error);
            }
        }
        
        res.json({
            status: operationData.status,
            videoUri: operationData.videoUri || null,
            videoBase64: operationData.videoBase64 || null,
            videoMimeType: operationData.videoMimeType || null,
            error: operationData.error || null,
            downloadError: operationData.downloadError || null,
            progress: currentProgress,
            progressMessage: progressMessage
        });

    } catch (error) {
        console.error('[Veo] Erro ao verificar status:', error);
        res.status(500).json({ message: 'Erro ao verificar status' });
    }
});

// GET /api/video/download/:operationId - Baixar vídeo gerado
app.get('/api/video/download/:operationId', authenticateToken, async (req, res) => {
    // Decodificar o operationId
    let operationId = decodeURIComponent(req.params.operationId);
    const userId = req.user.id;

    try {
        const operationData = videoOperations.get(operationId);
        
        if (!operationData) {
            return res.status(404).json({ message: 'Operação não encontrada' });
        }

        if (operationData.userId !== userId) {
            return res.status(403).json({ message: 'Acesso negado' });
        }

        if (operationData.status !== 'completed') {
            return res.status(400).json({ message: 'Vídeo ainda não está pronto' });
        }

        // Se tiver base64, retornar diretamente
        if (operationData.videoBase64) {
            const videoBuffer = Buffer.from(operationData.videoBase64, 'base64');
            res.setHeader('Content-Type', operationData.videoMimeType || 'video/mp4');
            res.setHeader('Content-Disposition', `attachment; filename="video-${Date.now()}.mp4"`);
            res.setHeader('Content-Length', videoBuffer.length);
            return res.send(videoBuffer);
        }

        // Se não tiver base64 mas tiver URI, baixar do Google e servir
        if (operationData.videoUri) {
            // Buscar API key
            const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            let apiKey = null;
            
            if (geminiKeyData) {
                apiKey = decrypt(geminiKeyData.api_key);
            } else if (operationData.useAdminApi && operationData.adminApi) {
                apiKey = operationData.adminApi.api_key;
            }

            if (!apiKey) {
                return res.status(500).json({ message: 'Chave de API não encontrada' });
            }

            // Adicionar key ao URI se não tiver
            let videoUrl = operationData.videoUri;
            if (!videoUrl.includes('key=')) {
                videoUrl = `${operationData.videoUri}${operationData.videoUri.includes('?') ? '&' : '?'}key=${apiKey}`;
            }

            // Baixar vídeo do Google
            const videoResponse = await axios.get(videoUrl, {
                responseType: 'arraybuffer',
                timeout: 120000
            });

            const videoBuffer = Buffer.from(videoResponse.data);
            res.setHeader('Content-Type', operationData.videoMimeType || 'video/mp4');
            res.setHeader('Content-Disposition', `attachment; filename="video-${Date.now()}.mp4"`);
            res.setHeader('Content-Length', videoBuffer.length);
            return res.send(videoBuffer);
        }

        return res.status(404).json({ message: 'Vídeo não disponível' });

    } catch (error) {
        console.error('[Veo] Erro ao baixar vídeo:', error);
        res.status(500).json({ message: 'Erro ao baixar vídeo' });
    }
});

// Agendar publicação de vídeo (mantido para compatibilidade, mas agora com suporte a auto-metadata)
app.post('/api/youtube/schedule', authenticateToken, async (req, res) => {
    const { youtubeIntegrationId, videoFilePath, title, description, tags, thumbnailUrl, scheduledTime, autoGenerateMetadata } = req.body;
    const userId = req.user.id;

    if (!title || !scheduledTime) {
        return res.status(400).json({ msg: 'Título e horário agendado são obrigatórios.' });
    }

    try {
        let finalDescription = description;
        let finalTags = tags;

        // Se autoGenerateMetadata estiver ativado, gerar automaticamente
        if (autoGenerateMetadata) {
            try {
                // Buscar niche/subniche do usuário ou do vídeo
                const userChannel = await db.get('SELECT niche, subniche FROM user_channels WHERE user_id = ? LIMIT 1', [userId]);
                const metadata = await fetch(`${req.protocol}://${req.get('host')}/api/youtube/generate-metadata`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': req.headers['authorization']
                    },
                    body: JSON.stringify({
                        title: title,
                        niche: userChannel?.niche || null,
                        subniche: userChannel?.subniche || null
                    })
                });

                if (metadata.ok) {
                    const metadataData = await metadata.json();
                    finalDescription = metadataData.description || description;
                    finalTags = metadataData.tags || tags;
                    console.log('[Agendamento] Metadata gerada automaticamente');
                }
            } catch (metaErr) {
                console.warn('[Agendamento] Falha ao gerar metadata automática, usando valores fornecidos:', metaErr.message);
            }
        }

        const result = await db.run(
            `INSERT INTO scheduled_posts (user_id, youtube_integration_id, video_file_path, title, description, tags, thumbnail_url, scheduled_time)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, youtubeIntegrationId || null, videoFilePath || null, title, finalDescription || null, finalTags ? JSON.stringify(finalTags) : null, thumbnailUrl || null, scheduledTime]
        );
        res.status(201).json({ id: result.lastID, msg: 'Publicação agendada com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/schedule]:', err);
        res.status(500).json({ msg: 'Erro ao agendar publicação.' });
    }
});

// Listar todos os canais conectados do YouTube
app.get('/api/youtube/channels', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const integrations = await db.all(
            'SELECT id, channel_id, channel_name, token_expires_at, created_at, is_active FROM youtube_integrations WHERE user_id = ? AND is_active = 1 ORDER BY created_at DESC',
            [userId]
        );

        const channels = integrations.map(integration => {
            const isExpired = integration.token_expires_at 
                ? new Date(integration.token_expires_at) < new Date()
                : false;
            
            return {
                id: integration.id,
                channelId: integration.channel_id,
                channelName: integration.channel_name,
                niche: integration.niche || null,
                subniche: integration.subniche || null,
                isExpired: isExpired,
                createdAt: integration.created_at
            };
        });

        return res.status(200).json({
            channels: channels,
            count: channels.length,
            maxChannels: 10
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/channels]:', err);
        return res.status(500).json({ msg: 'Erro ao listar canais.' });
    }
});

// Verificar status da integração do YouTube (mantido para compatibilidade)
app.get('/api/youtube/status', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const integrations = await db.all(
            'SELECT * FROM youtube_integrations WHERE user_id = ? AND is_active = 1 ORDER BY created_at DESC',
            [userId]
        );

        if (!integrations || integrations.length === 0) {
            return res.status(200).json({ 
                connected: false, 
                message: 'Nenhuma integração configurada.',
                channels: []
            });
        }

        // Retornar o canal mais recente para compatibilidade
        const latestIntegration = integrations[0];
        const isExpired = latestIntegration.token_expires_at 
            ? new Date(latestIntegration.token_expires_at) < new Date()
            : false;

        return res.status(200).json({
            connected: true,
            channelId: latestIntegration.channel_id,
            channelName: latestIntegration.channel_name,
            isExpired: isExpired,
            createdAt: latestIntegration.created_at,
            totalChannels: integrations.length,
            channels: integrations.map(i => ({
                id: i.id,
                channelId: i.channel_id,
                channelName: i.channel_name,
                isExpired: i.token_expires_at ? new Date(i.token_expires_at) < new Date() : false
            }))
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/status]:', err);
        return res.status(500).json({ msg: 'Erro ao verificar status da integração.' });
    }
});

// Processar seleção de canais após OAuth (rota interna, chamada pela página de seleção)
// NOTA: Esta rota é chamada pela página de seleção após OAuth válido
app.post('/api/youtube/oauth/connect-channels', async (req, res) => {
    const { userId, channelIds, accessToken, refreshToken, expiresAt } = req.body;

    if (!userId || !channelIds || !Array.isArray(channelIds) || channelIds.length === 0) {
        return res.status(400).json({ msg: 'Dados inválidos.' });
    }

    if (!accessToken) {
        return res.status(400).json({ msg: 'Token de acesso não fornecido.' });
    }

    // Validar que userId é um número válido
    const userIdNum = parseInt(userId);
    if (isNaN(userIdNum) || userIdNum <= 0) {
        return res.status(400).json({ msg: 'ID de usuário inválido.' });
    }

    try {
        // Buscar informações dos canais selecionados
        const channelIdsParam = channelIds.join(',');
        const channelsInfoResponse = await fetch(
            `https://www.googleapis.com/youtube/v3/channels?part=snippet&id=${channelIdsParam}`,
            {
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                },
            }
        );

        if (!channelsInfoResponse.ok) {
            throw new Error('Falha ao buscar informações dos canais');
        }

        const channelsInfo = await channelsInfoResponse.json();
        if (!channelsInfo.items || channelsInfo.items.length === 0) {
            throw new Error('Nenhum canal encontrado');
        }

        // Verificar limite antes de conectar
        const existingChannelsCount = await db.get(
            'SELECT COUNT(*) as count FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
            [userIdNum]
        );
        const currentCount = existingChannelsCount?.count || 0;
        const maxChannels = 10;
        const remainingSlots = maxChannels - currentCount;

        if (channelIds.length > remainingSlots) {
            return res.status(400).json({ 
                msg: `Você só pode adicionar mais ${remainingSlots} canal(is). Você selecionou ${channelIds.length}.` 
            });
        }

        // Verificar quais canais já estão conectados
        const existingChannels = await db.all(
            'SELECT channel_id FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
            [userId]
        );
        const existingChannelIds = new Set(existingChannels.map(c => c.channel_id));

        let connectedCount = 0;
        let updatedCount = 0;

        // Conectar cada canal selecionado
        for (const channelItem of channelsInfo.items) {
            const channelId = channelItem.id;
            const channelName = channelItem.snippet?.title || 'Canal do YouTube';

            // Pular se já está conectado
            if (existingChannelIds.has(channelId)) {
                continue;
            }

            // Verificar se já existe (mas inativo)
            const existingIntegration = await db.get(
                'SELECT id FROM youtube_integrations WHERE user_id = ? AND channel_id = ?',
                [userIdNum, channelId]
            );

            // Conectar o canal primeiro (sem bloquear na análise)
            let integrationId;
            if (existingIntegration) {
                // Atualizar integração existente
                await db.run(
                    `UPDATE youtube_integrations 
                     SET access_token = ?, refresh_token = ?, token_expires_at = ?, 
                         channel_name = ?, is_active = 1, updated_at = CURRENT_TIMESTAMP 
                     WHERE id = ?`,
                    [accessToken, refreshToken || null, expiresAt, channelName, existingIntegration.id]
                );
                integrationId = existingIntegration.id;
                updatedCount++;
            } else {
                // Criar nova integração
                const result = await db.run(
                    `INSERT INTO youtube_integrations (user_id, channel_id, channel_name, access_token, refresh_token, token_expires_at, is_active)
                     VALUES (?, ?, ?, ?, ?, ?, 1)`,
                    [userIdNum, channelId, channelName, accessToken, refreshToken || null, expiresAt]
                );
                integrationId = result.lastID;
                connectedCount++;
            }

            // Analisar canal em background (não bloqueia a resposta)
            analyzeChannelNiche(channelId, channelName, accessToken, userIdNum)
                .then(nicheAnalysis => {
                    if (nicheAnalysis.niche || nicheAnalysis.subniche) {
                        console.log(`[YouTube OAuth] Nicho detectado para ${channelName}: ${nicheAnalysis.niche} / ${nicheAnalysis.subniche}`);
                        // Atualizar o canal com o nicho detectado
                        db.run(
                            `UPDATE youtube_integrations 
                             SET niche = ?, subniche = ?, updated_at = CURRENT_TIMESTAMP 
                             WHERE id = ?`,
                            [nicheAnalysis.niche, nicheAnalysis.subniche, integrationId]
                        ).catch(err => {
                            console.error(`[YouTube OAuth] Erro ao salvar nicho detectado:`, err.message);
                        });
                    }
                })
                .catch(nicheErr => {
                    console.warn(`[YouTube OAuth] Erro ao analisar nicho do canal ${channelId}:`, nicheErr.message);
                    // Não fazer nada, o canal já está conectado
                });
        }

        console.log(`[YouTube OAuth] Canais conectados: ${connectedCount} novos, ${updatedCount} atualizados para userId: ${userIdNum}`);

        return res.status(200).json({
            msg: 'Canais conectados com sucesso!',
            connected: connectedCount + updatedCount,
            new: connectedCount,
            updated: updatedCount
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/oauth/connect-channels]:', err);
        return res.status(500).json({ msg: `Erro ao conectar canais: ${err.message}` });
    }
});

// Desconectar/remover um canal
app.delete('/api/youtube/channels/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const integrationId = parseInt(req.params.id);

    try {
        // Verificar se a integração pertence ao usuário
        const integration = await db.get(
            'SELECT id FROM youtube_integrations WHERE id = ? AND user_id = ?',
            [integrationId, userId]
        );

        if (!integration) {
            return res.status(404).json({ msg: 'Canal não encontrado.' });
        }

        // Desativar a integração (soft delete)
        await db.run(
            'UPDATE youtube_integrations SET is_active = 0, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
            [integrationId]
        );

        console.log(`[YouTube] Canal desconectado: userId=${userId}, integrationId=${integrationId}`);
        return res.status(200).json({ msg: 'Canal desconectado com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/channels/:id DELETE]:', err);
        return res.status(500).json({ msg: 'Erro ao desconectar canal.' });
    }
});

// Listar publicações agendadas
app.get('/api/youtube/scheduled', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    console.log(`[YouTube Scheduled] Requisição recebida para userId: ${userId}`);

    try {
        if (!db) {
            console.error('[YouTube Scheduled] Banco de dados não está disponível');
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        let scheduled = [];
        try {
            scheduled = await db.all(
                'SELECT * FROM scheduled_posts WHERE user_id = ? ORDER BY scheduled_time ASC',
                [userId]
            );
            console.log(`[YouTube Scheduled] Publicações encontradas:`, scheduled.length);
        } catch (dbErr) {
            console.error('[YouTube Scheduled] Erro ao buscar publicações:', dbErr);
            scheduled = [];
        }

        res.status(200).json(scheduled || []);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/scheduled]:', err);
        // Retornar array vazio se a tabela não existir
        res.status(200).json([]);
    }
});

// === PARTE 2.B: MONITORAMENTO AUTOMÁTICO ===

// B.1 - Alertas de Vídeos Virais: Verificar e notificar sobre vídeos virais de competidores
app.get('/api/youtube/viral-alerts', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        console.log(`[Viral Alerts] Buscando alertas para userId: ${userId}`);
        const alerts = await db.all(
            `SELECT * FROM viral_alerts 
             WHERE user_id = ? AND (notified = 0 OR notified IS NULL)
             ORDER BY detected_at DESC 
             LIMIT 50`,
            [userId]
        );

        console.log(`[Viral Alerts] ${alerts?.length || 0} alertas encontrados para userId: ${userId}`);
        res.status(200).json({ alerts: alerts || [] });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/viral-alerts]:', err);
        res.status(500).json({ msg: `Erro ao buscar alertas virais: ${err.message}` });
    }
});

// B.2 - Análise Automática de Tendências: Escanear YouTube por novos vídeos virais
app.post('/api/youtube/scan-trends', authenticateToken, async (req, res) => {
    const { 
        niche, 
        subniche, 
        maxResults = 10,
        minViews = 0,
        minViewsPerDay = 0,
        language = 'pt',
        publishedAfter = 7, // dias
        orderBy = 'viewCount', // viewCount, date, rating, relevance
        videoDuration = 'any', // any, short, medium, long
        videoDefinition = 'any' // any, high, standard
    } = req.body;
    const userId = req.user.id;

    if (!niche) {
        return res.status(400).json({ msg: 'Nicho é obrigatório para escanear tendências.' });
    }

    try {
        // Buscar chave do YouTube ou Gemini (necessária para YouTube API)
        // IMPORTANTE: A chave do Gemini pode ser usada para YouTube API, mas é melhor usar uma chave específica do YouTube
        // Tentar primeiro buscar chave do YouTube, depois Gemini como fallback
        let youtubeApiKey = null;
        
        // Tentar buscar chave do YouTube especificamente
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
        }
        
        // Se não tiver chave do YouTube, tentar Gemini
        if (!youtubeApiKey) {
            const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ 
                msg: 'Chave de API do YouTube ou Gemini é necessária para escanear tendências. Configure uma chave de API do YouTube Data API v3 nas Configurações.' 
            });
        }

        // Mapear idioma para código do YouTube
        const languageMap = {
            'pt': 'pt',
            'pt-BR': 'pt',
            'en': 'en',
            'es': 'es',
            'fr': 'fr',
            'de': 'de',
            'it': 'it',
            'ja': 'ja',
            'ko': 'ko',
            'zh': 'zh',
            'ru': 'ru'
        };
        const videoLanguage = languageMap[language] || 'pt';
        
        // Mapear duração do vídeo
        const durationMap = {
            'short': 'short', // menos de 4 minutos
            'medium': 'medium', // 4-20 minutos
            'long': 'long' // mais de 20 minutos
        };
        const videoDurationParam = durationMap[videoDuration] || 'any';
        
        // Mapear ordenação
        const orderMap = {
            'viewCount': 'viewCount',
            'date': 'date',
            'rating': 'rating',
            'relevance': 'relevance'
        };
        const orderParam = orderMap[orderBy] || 'viewCount';
        
        // Calcular data de publicação
        const publishedAfterDate = new Date(Date.now() - publishedAfter * 24 * 60 * 60 * 1000).toISOString();
        
        // Buscar vídeos virais recentes usando YouTube Data API
        const searchQuery = `${niche} ${subniche || ''}`.trim();
        
        // Construir URL com parâmetros
        let searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(searchQuery)}&type=video&order=${orderParam}&maxResults=${Math.min(maxResults, 50)}&publishedAfter=${publishedAfterDate}&relevanceLanguage=${videoLanguage}&key=${youtubeApiKey}`;
        
        // Adicionar filtro de duração se especificado
        if (videoDurationParam !== 'any') {
            searchUrl += `&videoDuration=${videoDurationParam}`;
        }
        
        // Adicionar filtro de definição se especificado
        if (videoDefinition !== 'any') {
            searchUrl += `&videoDefinition=${videoDefinition}`;
        }
        
        console.log(`[Scan Trends] Buscando tendências para: "${searchQuery}"`);
        console.log(`[Scan Trends] Filtros: minViews=${minViews}, minViewsPerDay=${minViewsPerDay}, language=${videoLanguage}, publishedAfter=${publishedAfter} dias, orderBy=${orderParam}, duration=${videoDurationParam}`);
        const searchResponse = await fetch(searchUrl);
        const searchData = await searchResponse.json();
        
        if (!searchResponse.ok) {
            console.error('[Scan Trends] Erro da API do YouTube:', JSON.stringify(searchData, null, 2));
            let errorMsg = 'Falha ao buscar vídeos do YouTube.';
            
            if (searchData.error) {
                if (searchData.error.message && searchData.error.message.includes('API key not valid')) {
                    errorMsg = 'A chave de API do YouTube não é válida. Verifique se a chave está correta e se a API do YouTube Data API v3 está habilitada no Google Cloud Console.';
                } else {
                    errorMsg = searchData.error.message || errorMsg;
                }
            }
            
            return res.status(400).json({ msg: errorMsg, trends: [] });
        }
        
        if (!searchData.items || searchData.items.length === 0) {
            return res.status(200).json({ trends: [], count: 0, msg: 'Nenhum vídeo encontrado para este nicho.' });
        }

        const videoIds = searchData.items.map(item => item.id.videoId).filter(Boolean).join(',');
        
        if (!videoIds) {
            return res.status(200).json({ trends: [], count: 0, msg: 'Nenhum vídeo válido encontrado.' });
        }

        // Buscar detalhes dos vídeos
        const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoIds}&key=${youtubeApiKey}`;
        const detailsResponse = await fetch(detailsUrl);
        const detailsData = await detailsResponse.json();
        
        if (!detailsResponse.ok) {
            console.error('[Scan Trends] Erro ao buscar detalhes:', detailsData);
            const errorMsg = detailsData.error?.message || 'Falha ao buscar detalhes dos vídeos.';
            return res.status(400).json({ msg: errorMsg, trends: [] });
        }

        const trends = [];
        const allVideos = [];
        
        for (const video of detailsData.items || []) {
            const views = parseInt(video.statistics.viewCount || 0);
            const publishedAt = new Date(video.snippet.publishedAt);
            const daysSince = Math.round((new Date() - publishedAt) / (1000 * 60 * 60 * 24));
            const viewsPerDay = daysSince > 0 ? views / daysSince : views;

            const videoData = {
                videoId: video.id,
                title: video.snippet.title,
                url: `https://www.youtube.com/watch?v=${video.id}`,
                channelId: video.snippet.channelId,
                channelName: video.snippet.channelTitle,
                views: views,
                viewsPerDay: Math.round(viewsPerDay),
                daysSince: daysSince,
                thumbnailUrl: video.snippet.thumbnails.high?.url || video.snippet.thumbnails.default?.url,
                isViral: isViralVideo(views, daysSince, viewsPerDay)
            };

            allVideos.push(videoData);

            // Verificar se é viral
            if (videoData.isViral) {
                // Salvar na tabela de tendências (ou atualizar se já existir)
                try {
                    await db.run(
                        `INSERT OR REPLACE INTO trend_analysis (user_id, niche, subniche, video_id, video_title, video_url, channel_id, channel_name, views, views_per_day, analyzed, detected_at)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)`,
                        [userId, niche, subniche || null, video.id, video.snippet.title, videoData.url, video.snippet.channelId, video.snippet.channelTitle, views, viewsPerDay]
                    );
                } catch (dbErr) {
                    console.error('[Scan Trends] Erro ao salvar tendência:', dbErr.message);
                }

                trends.push(videoData);
            }
        }

        console.log(`[Scan Trends] Total de vídeos encontrados: ${allVideos.length}, Vídeos virais: ${trends.length}`);
        
        // Se não encontrou vídeos virais, retornar os top vídeos encontrados mesmo assim
        const finalTrends = trends.length > 0 ? trends : allVideos.slice(0, Math.min(5, allVideos.length));
        
        res.status(200).json({ 
            trends: finalTrends,
            count: finalTrends.length,
            msg: finalTrends.length > 0 
                ? `${finalTrends.length} vídeo(s) ${trends.length > 0 ? 'viral(is)' : 'relevante(s)'} encontrado(s) no nicho ${niche}.`
                : `Nenhum vídeo encontrado para o nicho ${niche}.`
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/scan-trends]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao escanear tendências.' });
    }
});
// B.3 - Auto-análise de Canais Competidores: Adicionar canal para monitoramento automático
app.post('/api/youtube/monitor-competitor', authenticateToken, async (req, res) => {
    const { competitorChannelId, competitorChannelName, niche, subniche, autoAnalyze = true, checkFrequency = 'daily' } = req.body;
    const userId = req.user.id;

    if (!competitorChannelId) {
        return res.status(400).json({ msg: 'ID do canal competidor é obrigatório.' });
    }

    try {
        // Verificar se já está sendo monitorado
        const existing = await db.get(
            'SELECT * FROM competitor_monitoring WHERE user_id = ? AND competitor_channel_id = ?',
            [userId, competitorChannelId]
        );

        if (existing) {
            // Atualizar configurações
            await db.run(
                `UPDATE competitor_monitoring 
                 SET competitor_channel_name = ?, niche = ?, subniche = ?, auto_analyze = ?, check_frequency = ?
                 WHERE id = ?`,
                [competitorChannelName || existing.competitor_channel_name, niche || null, subniche || null, autoAnalyze ? 1 : 0, checkFrequency, existing.id]
            );
            return res.status(200).json({ id: existing.id, msg: 'Configurações de monitoramento atualizadas.' });
        } else {
            // Criar novo monitoramento
            const result = await db.run(
                `INSERT INTO competitor_monitoring (user_id, competitor_channel_id, competitor_channel_name, niche, subniche, auto_analyze, check_frequency)
                 VALUES (?, ?, ?, ?, ?, ?, ?)`,
                [userId, competitorChannelId, competitorChannelName || null, niche || null, subniche || null, autoAnalyze ? 1 : 0, checkFrequency]
            );
            return res.status(201).json({ id: result.lastID, msg: 'Canal adicionado para monitoramento automático.' });
        }
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/monitor-competitor]:', err);
        res.status(500).json({ msg: 'Erro ao configurar monitoramento.' });
    }
});

// Listar canais monitorados
app.get('/api/youtube/monitored-competitors', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const competitors = await db.all(
            'SELECT * FROM competitor_monitoring WHERE user_id = ? ORDER BY created_at DESC',
            [userId]
        );

        res.status(200).json({ competitors: competitors || [] });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/monitored-competitors]:', err);
        res.status(500).json({ msg: 'Erro ao listar canais monitorados.' });
    }
});

// Remover canal do monitoramento
app.delete('/api/youtube/monitor-competitor/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;

    try {
        const result = await db.run(
            'DELETE FROM competitor_monitoring WHERE id = ? AND user_id = ?',
            [id, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Monitoramento não encontrado.' });
        }

        res.status(200).json({ msg: 'Monitoramento removido com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/monitor-competitor DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao remover monitoramento.' });
    }
});

// B.4 - Sugestões Automáticas: IA sugere novos vídeos baseado em tendências
app.get('/api/youtube/ai-suggestions', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { limit = 10 } = req.query;

    try {
        const suggestions = await db.all(
            `SELECT * FROM ai_suggestions 
             WHERE user_id = ? AND viewed = 0 
             ORDER BY priority DESC, created_at DESC 
             LIMIT ?`,
            [userId, parseInt(limit)]
        );

        res.status(200).json({ suggestions: suggestions || [] });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/ai-suggestions]:', err);
        res.status(500).json({ msg: 'Erro ao buscar sugestões.' });
    }
});

// Gerar sugestões automáticas baseadas em tendências
app.post('/api/youtube/generate-suggestions', authenticateToken, async (req, res) => {
    const { niche, subniche } = req.body;
    const userId = req.user.id;

    if (!niche) {
        return res.status(400).json({ msg: 'Nicho é obrigatório para gerar sugestões.' });
    }

    try {
        console.log(`[Generate Suggestions] Iniciando para nicho: ${niche}, subniche: ${subniche}`);
        
        // Buscar tendências recentes do usuário (não analisadas ainda)
        const recentTrends = await db.all(
            `SELECT * FROM trend_analysis 
             WHERE user_id = ? AND niche = ? AND (analyzed = 0 OR analyzed IS NULL)
             ORDER BY detected_at DESC LIMIT 5`,
            [userId, niche]
        );
        
        console.log(`[Generate Suggestions] Tendências encontradas para nicho "${niche}": ${recentTrends.length}`);

        // Se não houver tendências salvas, buscar tendências em tempo real
        let trendsToUse = recentTrends;
        if (recentTrends.length === 0) {
            console.log(`[Generate Suggestions] Nenhuma tendência salva encontrada. Buscando tendências em tempo real...`);
            
            try {
                // Buscar chave do YouTube ou Gemini
                let youtubeApiKey = null;
                const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
                if (youtubeKeyData) {
                    youtubeApiKey = decrypt(youtubeKeyData.api_key);
                }
                if (!youtubeApiKey) {
                    const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
                    if (geminiKeyData) {
                        youtubeApiKey = decrypt(geminiKeyData.api_key);
                    }
                }
                
                if (youtubeApiKey) {
                    // Buscar vídeos recentes do nicho
                    const searchQuery = `${niche} ${subniche || ''}`.trim();
                    const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(searchQuery)}&type=video&order=viewCount&maxResults=5&publishedAfter=${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()}&relevanceLanguage=pt&key=${youtubeApiKey}`;
                    
                    const searchResponse = await fetch(searchUrl);
                    if (searchResponse.ok) {
                        const searchData = await searchResponse.json();
                        if (searchData.items && searchData.items.length > 0) {
                            const videoIds = searchData.items.map(item => item.id.videoId).filter(Boolean).join(',');
                            if (videoIds) {
                                const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoIds}&key=${youtubeApiKey}`;
                                const detailsResponse = await fetch(detailsUrl);
                                if (detailsResponse.ok) {
                                    const detailsData = await detailsResponse.json();
                                    // Criar objetos de tendência temporários
                                    trendsToUse = (detailsData.items || []).map(video => ({
                                        video_title: video.snippet.title,
                                        views: parseInt(video.statistics.viewCount || 0),
                                        views_per_day: Math.round((parseInt(video.statistics.viewCount || 0)) / Math.max(1, Math.round((new Date() - new Date(video.snippet.publishedAt)) / (1000 * 60 * 60 * 24)))),
                                        video_url: `https://www.youtube.com/watch?v=${video.id}`,
                                        channel_name: video.snippet.channelTitle
                                    }));
                                    console.log(`[Generate Suggestions] ${trendsToUse.length} tendências encontradas em tempo real`);
                                }
                            }
                        }
                    }
                }
            } catch (trendsErr) {
                console.warn(`[Generate Suggestions] Erro ao buscar tendências em tempo real:`, trendsErr.message);
            }
        }

        // Se ainda não houver tendências, usar o nicho diretamente
        if (trendsToUse.length === 0) {
            console.log(`[Generate Suggestions] Nenhuma tendência disponível. Gerando sugestões baseadas apenas no nicho "${niche}"`);
        }

        // Verificar se deve usar créditos (laozhang.ai) ou API própria
        // REGRA: Usa créditos se usuário marcou preferência OU não tem API própria configurada
        const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
        
        console.log(`[Generate Suggestions] shouldUseCredits: ${creditsCheck.shouldUse}, reason: ${creditsCheck.reason}`);
        
        let suggestions = [];
        
        // Se deve usar créditos, usar laozhang.ai primeiro
        if (creditsCheck.shouldUse) {
            console.log('[Generate Suggestions] Verificando chave laozhang.ai...');
            const laozhangKey = await getLaozhangApiKey();
            console.log('[Generate Suggestions] Chave laozhang.ai encontrada:', laozhangKey ? 'Sim' : 'Não');
            if (laozhangKey) {
                try {
                    let trendsSummary = '';
                    if (trendsToUse.length > 0) {
                        trendsSummary = trendsToUse.map(t => `- "${t.video_title}" (${t.views} views${t.views_per_day ? ` em ${t.views_per_day} views/dia` : ''})`).join('\n');
                    }

                    const prompt = `Você é um ESPECIALISTA EM CRIAÇÃO DE CONTEÚDO VIRAL PARA YOUTUBE com conhecimento profundo sobre tendências, algoritmos e o que faz um vídeo viralizar.

${trendsToUse.length > 0 ? `Analise as seguintes tendências virais no nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''}:

${trendsSummary}

Com base nessas tendências virais, sugira 5 NOVOS vídeos que o criador poderia fazer para aproveitar essas tendências e potencialmente viralizar também.` : `O criador está interessado no nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''}.

Com base nas tendências atuais deste nicho no YouTube, sugira 5 NOVOS vídeos com alto potencial viral que o criador poderia fazer.`}

Para cada sugestão, forneça:
1. Um título viral e chamativo
2. Uma breve descrição do conceito do vídeo
3. O motivo pelo qual esta ideia tem potencial de viralizar

Responda APENAS com um JSON válido no formato:
{
  "suggestions": [
    {
      "title": "Título viral sugerido",
      "description": "Descrição do conceito do vídeo",
      "reason": "Por que esta ideia tem potencial de viralizar",
      "priority": 8 (1-10, sendo 10 o maior potencial)
    },
    ...
  ]
}

IMPORTANTE: 
- Os títulos devem ser em português (Brasil)
- Foque em ideias que aproveitem os padrões das tendências analisadas
- Seja específico e criativo
- Priorize ideias com alto potencial de engajamento

Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await callLaozhangAPI(prompt, laozhangKey, 'gpt-4o', null, userId, 'api_call', JSON.stringify({ endpoint: '/api/youtube/generate-suggestions' }));
                    // callLaozhangAPI retorna uma string diretamente, não um objeto
                    const responseText = typeof response === 'string' ? response : (response?.titles || response?.text || response?.content || JSON.stringify(response) || '');
                    
                    console.log(`[Sugestões IA] Resposta recebida (${responseText.length} caracteres)`);
                    console.log(`[Sugestões IA] Primeiros 500 caracteres:`, responseText.substring(0, 500));
                    
                    // Tentar extrair JSON da resposta - usar regex mais robusto para pegar JSON completo
                    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    // Se não encontrar, tentar remover markdown code blocks
                    if (!jsonMatch) {
                        const cleaned = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                        jsonMatch = cleaned.match(/\{[\s\S]*\}/);
                    }
                    
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.suggestions && Array.isArray(parsed.suggestions)) {
                                // Salvar sugestões no banco
                                for (const suggestion of parsed.suggestions) {
                                    try {
                                        await db.run(
                                            `INSERT INTO ai_suggestions (user_id, suggestion_type, title, description, niche, subniche, reason, priority, viewed, created_at)
                                             VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)`,
                                            [userId, 'trend_based', suggestion.title || 'Sugestão sem título', suggestion.description || 'Sem descrição', niche, subniche || null, suggestion.reason || 'Baseado em tendências virais', suggestion.priority || 5]
                                        );
                                        console.log(`[Sugestões IA] Sugestão salva: "${suggestion.title || 'Sem título'}"`);
                                    } catch (dbErr) {
                                        console.error(`[Sugestões IA] Erro ao salvar sugestão:`, dbErr.message);
                                    }
                                }
                                suggestions = parsed.suggestions;
                                console.log(`[Sugestões IA] ✅ ${suggestions.length} sugestões geradas usando API configurada como padrão`);
                            } else {
                                console.warn(`[Sugestões IA] Resposta não tem formato esperado (sem array 'suggestions')`);
                                console.warn(`[Sugestões IA] Estrutura recebida:`, Object.keys(parsed));
                            }
                        } catch (e) {
                            console.warn(`[Sugestões IA] Falha ao parsear JSON:`, e.message);
                            console.warn(`[Sugestões IA] JSON encontrado:`, jsonMatch[0].substring(0, 500));
                        }
                    } else {
                        console.warn(`[Sugestões IA] Nenhum JSON encontrado na resposta`);
                        console.warn(`[Sugestões IA] Resposta completa:`, responseText.substring(0, 1000));
                    }
                } catch (serviceErr) {
                    console.error(`[Sugestões IA] Erro ao usar API configurada como padrão:`, serviceErr.message);
                    // Se deve usar créditos e laozhang falhou, não tentar APIs próprias
                    if (creditsCheck.shouldUse) {
                        return res.status(500).json({ 
                            suggestions: [],
                            count: 0,
                            msg: 'Erro ao gerar sugestões usando sistema de créditos. Verifique se a chave está configurada corretamente no painel admin.' 
                        });
                    }
                }
            } else if (creditsCheck.shouldUse) {
                // Se deve usar créditos mas não tem chave
                return res.status(400).json({ 
                    suggestions: [],
                    count: 0,
                    msg: 'API configurada como padrão não está configurada. Configure a chave no painel admin ou desmarque a opção de usar créditos.' 
                });
            }
        }
        
        // Se não usar créditos ou se laozhang falhou (e não é obrigatório), usar APIs próprias
        if (suggestions.length === 0 && !creditsCheck.shouldUse) {
            // Tentar usar IA para gerar sugestões baseadas nas tendências
            const services = ['gemini', 'claude', 'openai'];

            for (const service of services) {
                try {
                    const serviceKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                    if (!serviceKeyData) continue;

                    const decryptedKey = decrypt(serviceKeyData.api_key);
                    if (!decryptedKey) continue;

                    let apiCallFunction;
                    let model;
                    if (service === 'gemini') {
                        apiCallFunction = callGeminiAPI;
                        model = 'gemini-2.0-flash';
                    } else if (service === 'claude') {
                        apiCallFunction = callClaudeAPI;
                        model = 'claude-3-5-haiku-20241022';
                    } else {
                        apiCallFunction = callOpenAIAPI;
                        model = 'gpt-4o'; // Usar GPT-4o como padrão
                    }

                    const trendsSummary = trendsToUse.length > 0 
                        ? trendsToUse.map(t => `- "${t.video_title}" (${t.views} views${t.views_per_day ? ` em ${t.views_per_day} views/dia` : ''})`).join('\n')
                        : '';

                    const prompt = trendsToUse.length > 0 
                        ? `Você é um ESPECIALISTA EM CRIAÇÃO DE CONTEÚDO VIRAL PARA YOUTUBE com conhecimento profundo sobre tendências, algoritmos e o que faz um vídeo viralizar.

Analise as seguintes tendências virais no nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''}:

${trendsSummary}

Com base nessas tendências virais, sugira 5 NOVOS vídeos que o criador poderia fazer para aproveitar essas tendências e potencialmente viralizar também.`
                        : `Você é um ESPECIALISTA EM CRIAÇÃO DE CONTEÚDO VIRAL PARA YOUTUBE com conhecimento profundo sobre tendências, algoritmos e o que faz um vídeo viralizar.

O criador está interessado no nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''}.

Com base nas tendências atuais deste nicho no YouTube, sugira 5 NOVOS vídeos com alto potencial viral que o criador poderia fazer.

Para cada sugestão, forneça:
1. Um título viral e chamativo
2. Uma breve descrição do conceito do vídeo
3. O motivo pelo qual esta ideia tem potencial de viralizar

Responda APENAS com um JSON válido no formato:
{
  "suggestions": [
    {
      "title": "Título viral sugerido",
      "description": "Descrição do conceito do vídeo",
      "reason": "Por que esta ideia tem potencial de viralizar",
      "priority": 8 (1-10, sendo 10 o maior potencial)
    },
    ...
  ]
}

IMPORTANTE: 
- Os títulos devem ser em português (Brasil)
- Foque em ideias que aproveitem os padrões das tendências analisadas
- Seja específico e criativo
- Priorize ideias com alto potencial de engajamento

Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await apiCallFunction(prompt, decryptedKey, model);
                    // A resposta pode ser string direta ou objeto
                    const responseText = typeof response === 'string' ? response : (response?.titles || response?.text || response?.content || JSON.stringify(response) || '');
                    
                    console.log(`[Sugestões IA] Resposta de ${service} (${responseText.length} caracteres)`);
                    
                    // Tentar extrair JSON da resposta - usar regex mais robusto para pegar JSON completo
                    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    // Se não encontrar, tentar remover markdown code blocks
                    if (!jsonMatch) {
                        const cleaned = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                        jsonMatch = cleaned.match(/\{[\s\S]*\}/);
                    }
                    
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.suggestions && Array.isArray(parsed.suggestions)) {
                                // Salvar sugestões no banco
                                for (const suggestion of parsed.suggestions) {
                                    try {
                                        await db.run(
                                            `INSERT INTO ai_suggestions (user_id, suggestion_type, title, description, niche, subniche, reason, priority, viewed, created_at)
                                             VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)`,
                                            [userId, 'trend_based', suggestion.title || 'Sugestão sem título', suggestion.description || 'Sem descrição', niche, subniche || null, suggestion.reason || 'Baseado em tendências virais', suggestion.priority || 5]
                                        );
                                        console.log(`[Sugestões IA] Sugestão salva: "${suggestion.title || 'Sem título'}"`);
                                    } catch (dbErr) {
                                        console.error(`[Sugestões IA] Erro ao salvar sugestão:`, dbErr.message);
                                    }
                                }
                                suggestions = parsed.suggestions;
                                console.log(`[Sugestões IA] ✅ ${suggestions.length} sugestões geradas e salvas usando ${service}`);
                                break;
                            } else {
                                console.warn(`[Sugestões IA] Resposta de ${service} não tem formato esperado (sem array 'suggestions')`);
                            }
                        } catch (e) {
                            console.warn(`[Sugestões IA] Falha ao parsear JSON de ${service}:`, e.message);
                            console.warn(`[Sugestões IA] JSON encontrado:`, jsonMatch[0].substring(0, 500));
                        }
                    } else {
                        console.warn(`[Sugestões IA] Nenhum JSON encontrado na resposta de ${service}`);
                    }
                } catch (serviceErr) {
                    console.warn(`[Sugestões IA] Falha com ${service}:`, serviceErr.message);
                    continue;
                }
            }
        }

        // Fallback: gerar sugestões básicas baseadas nos títulos das tendências
        if (suggestions.length === 0 && recentTrends.length > 0) {
            console.log(`[Sugestões IA] Gerando sugestões básicas baseadas em ${recentTrends.length} tendências`);
            for (const trend of recentTrends.slice(0, 3)) {
                try {
                    await db.run(
                        `INSERT INTO ai_suggestions (user_id, suggestion_type, title, description, niche, subniche, reason, priority, viewed, created_at)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)`,
                        [userId, 'trend_based', `Versão adaptada: ${trend.video_title}`, `Crie uma versão adaptada deste vídeo viral para seu canal`, niche, subniche || null, `Baseado no vídeo viral "${trend.video_title}" com ${trend.views} views`, 7]
                    );
                } catch (dbErr) {
                    console.error(`[Sugestões IA] Erro ao salvar sugestão básica:`, dbErr.message);
                }
            }
            suggestions = recentTrends.slice(0, 3).map(t => ({
                title: `Versão adaptada: ${t.video_title}`,
                description: `Crie uma versão adaptada deste vídeo viral para seu canal`,
                reason: `Baseado no vídeo viral com ${t.views} views`,
                priority: 7
            }));
            console.log(`[Sugestões IA] ✅ ${suggestions.length} sugestões básicas geradas`);
        }

        res.status(200).json({ 
            suggestions: suggestions,
            count: suggestions.length,
            msg: `${suggestions.length} sugestão(ões) gerada(s) com sucesso.`
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/generate-suggestions]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar sugestões.' });
    }
});

// Marcar sugestão como visualizada
app.put('/api/youtube/ai-suggestions/:id/viewed', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;

    try {
        await db.run(
            'UPDATE ai_suggestions SET viewed = 1 WHERE id = ? AND user_id = ?',
            [id, userId]
        );

        res.status(200).json({ msg: 'Sugestão marcada como visualizada.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/ai-suggestions PUT]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar sugestão.' });
    }
});

// === ROTAS DE GERENCIAMENTO DE CANAIS DO USUÁRIO ===

// Criar/Atualizar canal do usuário
app.post('/api/channels', authenticateToken, async (req, res) => {
    const { channelName, channelUrl, channelId, niche, language, country } = req.body;
    const userId = req.user.id;

    if (!channelName) {
        return res.status(400).json({ msg: 'Nome do canal é obrigatório.' });
    }

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        // Verificar limite de 10 canais por usuário
        const channelCount = await db.get('SELECT COUNT(*) as count FROM user_channels WHERE user_id = ?', [userId]);
        if (channelCount && channelCount.count >= 10) {
            return res.status(400).json({ msg: 'Limite de 10 canais atingido. Exclua um canal antes de adicionar outro.' });
        }

        // Verificar se já existe um canal com o mesmo nome para este usuário
        const existing = await db.get('SELECT id FROM user_channels WHERE user_id = ? AND channel_name = ?', [userId, channelName]);
        
        if (existing) {
            // Atualizar canal existente
            await db.run(
                `UPDATE user_channels 
                 SET channel_url = ?, channel_id = ?, niche = ?, language = ?, country = ?, updated_at = CURRENT_TIMESTAMP 
                 WHERE id = ? AND user_id = ?`,
                [channelUrl || null, channelId || null, niche || null, language || 'pt-BR', country || 'BR', existing.id, userId]
            );
            console.log(`[Canais] Canal ${existing.id} atualizado pelo usuário ${userId}`);
            res.status(200).json({ id: existing.id, msg: 'Canal atualizado com sucesso.' });
        } else {
            // Criar novo canal
            const result = await db.run(
                `INSERT INTO user_channels (user_id, channel_name, channel_url, channel_id, niche, language, country) 
                 VALUES (?, ?, ?, ?, ?, ?, ?)`,
                [userId, channelName, channelUrl || null, channelId || null, niche || null, language || 'pt-BR', country || 'BR']
            );
            console.log(`[Canais] Canal ${result.lastID} criado pelo usuário ${userId}`);
            res.status(201).json({ id: result.lastID, msg: 'Canal criado com sucesso.' });
        }
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels POST]:', err);
        if (err.message.includes('UNIQUE constraint failed')) {
            return res.status(400).json({ msg: 'Já existe um canal com este nome.' });
        }
        res.status(500).json({ msg: 'Erro ao criar/atualizar canal.' });
    }
});

// Listar canais do usuário
app.get('/api/channels', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const channels = await db.all(
            'SELECT * FROM user_channels WHERE user_id = ? ORDER BY created_at DESC',
            [userId]
        );
        res.status(200).json(channels || []);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels GET]:', err);
        res.status(500).json({ msg: 'Erro ao listar canais.' });
    }
});

// Excluir canal do usuário
app.delete('/api/channels/:id', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const result = await db.run('DELETE FROM user_channels WHERE id = ? AND user_id = ?', [id, userId]);
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Canal não encontrado ou não pertence a este usuário.' });
        }

        console.log(`[Canais] Canal ${id} excluído pelo usuário ${userId}`);
        res.status(200).json({ msg: 'Canal excluído com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir canal.' });
    }
});

// Atualizar status do canal (ativar/desativar)
app.put('/api/channels/:id/status', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const { isActive } = req.body;
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const result = await db.run(
            'UPDATE user_channels SET is_active = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ? AND user_id = ?',
            [isActive ? 1 : 0, id, userId]
        );
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Canal não encontrado ou não pertence a este usuário.' });
        }

        console.log(`[Canais] Status do canal ${id} atualizado para ${isActive ? 'ativo' : 'inativo'} pelo usuário ${userId}`);
        res.status(200).json({ msg: 'Status do canal atualizado com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/:id/status PUT]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar status do canal.' });
    }
});

// Buscar informações do canal a partir da URL
app.post('/api/channels/fetch-info', authenticateToken, async (req, res) => {
    const { channelUrl } = req.body;
    const userId = req.user.id;

    if (!channelUrl) {
        return res.status(400).json({ msg: 'URL do canal é obrigatória.' });
    }

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados não está disponível.' });
        }

        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        if (!geminiKeyData) {
            return res.status(400).json({ msg: 'Chave de API do Gemini é necessária.' });
        }
        const geminiApiKey = decrypt(geminiKeyData.api_key);
        if (!geminiApiKey) {
            return res.status(500).json({ msg: 'Falha ao desencriptar a chave do Gemini.' });
        }

        // Extrair ID do canal da URL
        const match = channelUrl.match(/youtube\.com\/(?:@([\w.-]+)|channel\/([\w-]+)|c\/([\w-]+)|user\/([\w-]+))/);
        if (!match) {
            return res.status(400).json({ msg: 'Formato de URL do canal não suportado.' });
        }

        let ytChannelId;
        const handle = match[1];
        const legacyId = match[2] || match[3] || match[4];

        if (handle) {
            const searchApiUrl = `https://www.googleapis.com/youtube/v3/search?part=id&q=${encodeURIComponent(handle)}&type=channel&maxResults=1&key=${geminiApiKey}`;
            const searchResponse = await fetch(searchApiUrl);
            const searchData = await searchResponse.json();
            if (searchResponse.ok && searchData.items && searchData.items.length > 0) {
                ytChannelId = searchData.items[0].id.channelId;
            }
        } else if (legacyId) {
            ytChannelId = legacyId;
        }

        if (!ytChannelId) {
            return res.status(400).json({ msg: 'Não foi possível determinar o ID do canal.' });
        }

        // Buscar informações do canal
        const channelUrl_api = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${ytChannelId}&key=${geminiApiKey}`;
        const channelResponse = await fetch(channelUrl_api);
        const channelData = await channelResponse.json();

        if (!channelResponse.ok || !channelData.items || channelData.items.length === 0) {
            return res.status(400).json({ msg: 'Canal não encontrado.' });
        }

        const channel = channelData.items[0];
        const channelName = channel.snippet.title;
        const channelDescription = channel.snippet.description || '';
        const country = channel.snippet.country || 'BR';
        
        // Detectar idioma baseado no país ou descrição
        let language = 'pt-BR';
        if (country === 'US' || country === 'GB' || country === 'CA' || country === 'AU') {
            language = 'en-US';
        } else if (country === 'ES' || country === 'MX' || country === 'AR' || country === 'CO') {
            language = 'es-ES';
        } else if (country === 'FR') {
            language = 'fr-FR';
        } else if (country === 'DE') {
            language = 'de-DE';
        } else if (country === 'IT') {
            language = 'it-IT';
        } else if (country === 'JP') {
            language = 'ja-JP';
        } else if (country === 'KR') {
            language = 'ko-KR';
        } else if (country === 'CN') {
            language = 'zh-CN';
        }

        // Usar IA para detectar nicho (obrigatório)
        let niche = '';
        try {
            const nichePrompt = `Analise este canal do YouTube e identifique o nicho principal em uma palavra ou frase curta (máximo 3 palavras). Seja específico e preciso.
Nome do Canal: ${channelName}
Descrição: ${channelDescription.substring(0, 500)}

IMPORTANTE: Responda APENAS com o nicho, sem explicações adicionais, sem pontos, sem aspas, sem nada além do nicho.
Exemplos válidos: Tecnologia, Educação Financeira, Gaming, Culinária, Fitness, Entretenimento, História, Ciência, Viagens.

Nicho identificado:`;
            
            console.log('[Canais] Detectando nicho do canal:', channelName);
            const nicheResponse = await callGeminiAPI(nichePrompt, geminiApiKey, 'gemini-2.0-flash-exp');
            if (nicheResponse && nicheResponse.titles) {
                niche = nicheResponse.titles.trim()
                    .split('\n')[0]
                    .replace(/^["']|["']$/g, '') // Remove aspas
                    .replace(/^\.+/, '') // Remove pontos no início
                    .substring(0, 50)
                    .trim();
                console.log('[Canais] Nicho detectado:', niche);
            }
            if (!niche || niche.length < 2) {
                console.warn('[Canais] Nicho não detectado ou muito curto, usando fallback');
                // Fallback: usar primeira palavra da descrição ou nome do canal
                niche = channelDescription.split(' ').slice(0, 2).join(' ').substring(0, 30) || channelName.split(' ').slice(0, 2).join(' ').substring(0, 30) || 'Entretenimento';
            }
        } catch (nicheErr) {
            console.warn('[Canais] Erro ao detectar nicho:', nicheErr.message);
            // Fallback: usar primeira palavra do nome do canal
            niche = channelName.split(' ').slice(0, 2).join(' ').substring(0, 30) || 'Entretenimento';
        }

        // Garantir que sempre há um nicho
        if (!niche || niche.length < 2) {
            niche = 'Entretenimento';
        }

        const responseData = {
            channelName,
            channelId: ytChannelId,
            niche: niche,
            language,
            country
        };
        
        console.log('[Canais] Retornando dados do canal:', responseData);
        res.status(200).json(responseData);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/fetch-info]:', err);
        res.status(500).json({ msg: 'Erro ao buscar informações do canal.' });
    }
});

// ============================================
// INICIAR SERVIDOR (DEPOIS DE TODAS AS ROTAS)
// ============================================
// Variável para garantir que o servidor só inicie UMA vez (proteção contra race condition)
let serverStarted = false;
let startServerInterval = null;
let startServerTimeout = null;

// Função única para iniciar o servidor (garante que só inicie uma vez)
function startServer() {
    // Verificação dupla: flag + app.listening para garantir que não inicie duas vezes
    if (serverStarted) {
        return;
    }
    
    // Marcar como iniciado ANTES de tentar iniciar (previne race condition)
    serverStarted = true;
    
    // Limpar intervalos e timeouts para evitar múltiplas tentativas
    if (startServerInterval) {
        clearInterval(startServerInterval);
        startServerInterval = null;
    }
    if (startServerTimeout) {
        clearTimeout(startServerTimeout);
        startServerTimeout = null;
    }
    
    // Iniciar servidor
    try {
        const server = app.listen(PORT, async () => {
            // Restaurar loops ativos após o servidor iniciar
            setTimeout(() => {
                restoreActiveLoops();
            }, 2000); // Aguardar 2 segundos para garantir que o banco está pronto
            console.log(`🚀 Servidor "La Casa Dark Core" a rodar na porta ${PORT}`);
            if (!db) {
                console.log(`⚠️  Banco de dados ainda não está pronto. Algumas funcionalidades podem não estar disponíveis.`);
            } else {
                console.log(`✅ Todas as rotas registradas e funcionando!`);
            }
        });
        
        // Tratamento de erro para porta em uso
        server.on('error', (err) => {
            if (err.code === 'EADDRINUSE') {
                console.error(`❌ Erro: A porta ${PORT} já está em uso.`);
                console.error(`   Por favor, encerre o processo que está usando a porta ${PORT} e tente novamente.`);
                console.error(`   Comando: netstat -ano | findstr :${PORT}`);
            } else {
                console.error('❌ Erro ao iniciar servidor:', err.message);
            }
            // Resetar flag em caso de erro para permitir nova tentativa
            serverStarted = false;
        });
    } catch (err) {
        console.error('❌ Erro ao iniciar servidor:', err.message);
        serverStarted = false;
    }
}

// === SERVIÇO DE TRADUÇÃO ONLINE (Gratuito) ===

/**
 * Traduz texto usando múltiplas APIs gratuitas com fallback
 * Ordem de prioridade:
 * 1. MyMemory Translation API (gratuito, 500 requisições/dia)
 * 2. LibreTranslate (open-source, sem limite se self-hosted)
 * 3. Google Translate via scraping (fallback)
 */
async function translateText(text, fromLang = 'auto', toLang = 'pt') {
    if (!text || text.trim().length === 0) {
        return text;
    }

    // MÉTODO 1: MyMemory Translation API (GRATUITO - 500 req/dia)
    try {
        console.log(`[Tradução] Tentando MyMemory API: ${fromLang} → ${toLang}`);
        const mymemoryUrl = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${fromLang}|${toLang}`;
        const response = await fetch(mymemoryUrl);
        const data = await response.json();
        
        if (response.ok && data.responseData && data.responseData.translatedText) {
            console.log(`[Tradução] ✅ Sucesso com MyMemory API`);
            return data.responseData.translatedText;
        }
    } catch (err) {
        console.warn(`[Tradução] MyMemory falhou:`, err.message);
    }

    // MÉTODO 2: LibreTranslate API (GRATUITO - public instance)
    try {
        console.log(`[Tradução] Tentando LibreTranslate API`);
        const libreTranslateUrl = 'https://libretranslate.de/translate';
        const response = await fetch(libreTranslateUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                q: text,
                source: fromLang === 'auto' ? 'en' : fromLang,
                target: toLang,
                format: 'text'
            })
        });
        const data = await response.json();
        
        if (response.ok && data.translatedText) {
            console.log(`[Tradução] ✅ Sucesso com LibreTranslate API`);
            return data.translatedText;
        }
    } catch (err) {
        console.warn(`[Tradução] LibreTranslate falhou:`, err.message);
    }

    // MÉTODO 3: Usar Gemini AI como fallback (se disponível)
    try {
        console.log(`[Tradução] Tentando fallback com IA interna`);
        // Se o usuário tiver Gemini configurado, podemos usar para tradução
        return text; // Por enquanto retorna o original se todos falharem
    } catch (err) {
        console.warn(`[Tradução] Todos os métodos falharam`);
    }

    return text; // Retorna texto original se todas as traduções falharem
}

// Variável para armazenar os intervalos de notificações
const notificationLoops = {
    purchase: null,
    user: null
};

// Função para iniciar um loop de notificações
async function startNotificationLoop(loopType, intervalSeconds) {
    // Parar loop existente se houver
    if (notificationLoops[loopType]) {
        clearInterval(notificationLoops[loopType]);
        notificationLoops[loopType] = null;
    }
    
    console.log(`[NOTIFICATIONS] Iniciando loop ${loopType} com intervalo de ${intervalSeconds} segundos`);
    
    // Executar imediatamente na primeira vez
    await processNotificationLoop(loopType);
    
    // Configurar intervalo
    notificationLoops[loopType] = setInterval(async () => {
        await processNotificationLoop(loopType);
    }, intervalSeconds * 1000);
}

// Função para processar um loop de notificações
async function processNotificationLoop(loopType) {
    try {
        // Verificar se o loop ainda está ativo
        const loopStatus = await db.get('SELECT is_active FROM active_loops WHERE loop_type = ?', [loopType]);
        if (!loopStatus || loopStatus.is_active !== 1) {
            console.log(`[NOTIFICATIONS] Loop ${loopType} não está mais ativo, parando...`);
            if (notificationLoops[loopType]) {
                clearInterval(notificationLoops[loopType]);
                notificationLoops[loopType] = null;
            }
            return;
        }
        
        // Obter configurações
        const configs = await db.all('SELECT key, value FROM notification_config');
        const config = {};
        configs.forEach(c => { config[c.key] = c.value; });
        
        const enabled = config[`${loopType}_enabled`] === 'true';
        if (!enabled) {
            return; // Loop desabilitado
        }
        
        const interval = parseInt(config[`${loopType}_interval`]) || 5;
        const message = config[`${loopType}_message`] || '';
        
        // Buscar usuários fictícios ativos do tipo correto
        const fakeUsers = await db.all(
            'SELECT * FROM fake_users WHERE type = ? AND is_active = 1 ORDER BY RANDOM() LIMIT 1',
            [loopType]
        );
        
        if (fakeUsers.length === 0) {
            console.log(`[NOTIFICATIONS] Nenhum usuário fictício ${loopType} disponível`);
            return;
        }
        
        const fakeUser = fakeUsers[0];
        
        // Criar mensagem personalizada
        let notificationMessage = message;
        notificationMessage = notificationMessage.replace(/{name}/g, fakeUser.name);
        if (loopType === 'purchase' && fakeUser.plan_name) {
            notificationMessage = notificationMessage.replace(/{plan}/g, fakeUser.plan_name);
        }
        
        // Criar notificação global (user_id = null para todos verem)
        await db.run(
            'INSERT INTO notifications (user_id, title, message, type, is_read, created_at) VALUES (?, ?, ?, ?, 0, CURRENT_TIMESTAMP)',
            [null, loopType === 'purchase' ? 'Nova Compra' : 'Novo Usuário', notificationMessage, loopType]
        );
        
        console.log(`[NOTIFICATIONS] Notificação ${loopType} criada: ${notificationMessage}`);
    } catch (error) {
        console.error(`[NOTIFICATIONS] Erro ao processar loop ${loopType}:`, error);
    }
}

// Função para restaurar loops ativos ao iniciar o servidor
async function restoreActiveLoops() {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS active_loops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    loop_type TEXT NOT NULL UNIQUE,
                    is_active BOOLEAN DEFAULT 0,
                    interval_seconds INTEGER DEFAULT 5,
                    started_at DATETIME,
                    stopped_at DATETIME,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela já existe, continuar
        }
        
        const activeLoops = await db.all('SELECT * FROM active_loops WHERE is_active = 1');
        
        if (activeLoops.length === 0) {
            console.log('[NOTIFICATIONS] Nenhum loop ativo para restaurar');
            return;
        }
        
        console.log(`[NOTIFICATIONS] Restaurando ${activeLoops.length} loop(s) ativo(s)...`);
        
        // Iniciar loops ativos
        for (const loop of activeLoops) {
            if (loop.is_active === 1) {
                console.log(`[NOTIFICATIONS] Iniciando loop ${loop.loop_type} (intervalo: ${loop.interval_seconds}s)`);
                startNotificationLoop(loop.loop_type, loop.interval_seconds);
            }
        }
        
        console.log('[NOTIFICATIONS] Loops ativos restaurados e em execução.');
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao restaurar loops:', error);
    }
}

// Rota de tradução
app.post('/api/translate', authenticateToken, async (req, res) => {
    const { text, from = 'auto', to = 'pt' } = req.body;

    if (!text || typeof text !== 'string') {
        return res.status(400).json({ msg: 'Texto para tradução é obrigatório.' });
    }

    try {
        const translatedText = await translateText(text, from, to);
        res.status(200).json({
            original: text,
            translated: translatedText,
            from,
            to
        });
    } catch (err) {
        console.error('[ERRO /api/translate]:', err);
        res.status(500).json({ msg: 'Erro ao traduzir texto.' });
    }
});

// Rota de tradução em lote (para múltiplos textos)
app.post('/api/translate/batch', authenticateToken, async (req, res) => {
    const { texts, from = 'auto', to = 'pt' } = req.body;

    if (!Array.isArray(texts) || texts.length === 0) {
        return res.status(400).json({ msg: 'Array de textos é obrigatório.' });
    }

    try {
        const translations = await Promise.all(
            texts.map(text => translateText(text, from, to))
        );

        res.status(200).json({
            translations,
            from,
            to,
            count: translations.length
        });
    } catch (err) {
        console.error('[ERRO /api/translate/batch]:', err);
        res.status(500).json({ msg: 'Erro ao traduzir textos.' });
    }
});

console.log('✅ Serviço de Tradução Online configurado (MyMemory + LibreTranslate)');


// Aguardar a inicialização do banco de dados antes de iniciar o servidor
startServerInterval = setInterval(() => {
    if (global.dbReady && db) {
        startServer();
    }
}, 100);

// Timeout de segurança: iniciar servidor após 3 segundos mesmo se o banco não estiver pronto
startServerTimeout = setTimeout(() => {
    if (!serverStarted) {
        startServer();
    }
}, 3000);