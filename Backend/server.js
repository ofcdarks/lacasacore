// --- IMPORTS ---
const express = require('express');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const sqlite = require('sqlite');
const sqlite3 = require('sqlite3');
const path = require('path');
const crypto = require('crypto');
const fs = require('fs'); // Importando o m√≥dulo File System
require('dotenv').config(); // Carrega as vari√°veis do ficheiro .env

// Usar @distube/ytdl-core diretamente do GitHub (master branch) - vers√£o mais atualizada
const ytdl = require('@distube/ytdl-core');
console.log('[Sistema] Usando @distube/ytdl-core do GitHub (master branch) - vers√£o mais recente');
const { YoutubeTranscript } = require('youtube-transcript');
const { fetch } = require('undici');
const { ImageFX, AspectRatio, Model, AccountError, ImageFXError } = require('./imagefx.js');
const ffmpeg = require('fluent-ffmpeg');
const ffmpegInstaller = require('@ffmpeg-installer/ffmpeg');
const ffprobeInstaller = require('@ffprobe-installer/ffprobe');
const { OpenAI } = require('openai');
const fse = require('fs-extra');
const axios = require('axios');
const { exec, execSync } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);
const ScriptOptimizer = require('./scriptOptimizer.js');
const AIScriptValidator = require('./aiScriptValidator.js');
const ViralFormulaReplicator = require('./viralFormulaReplicator.js');
const { GoogleGenAI } = require('@google/genai');
const Stripe = require('stripe');
const nodemailer = require('nodemailer');
const LAOZHANG_CHAT_ENDPOINT = process.env.LAOZHANG_CHAT_ENDPOINT || 'https://api.laozhang.ai/v1/chat/completions';
const puppeteer = require('puppeteer');

const PROVIDER_NAME_PATTERNS = [
    { pattern: /laozhang(\.ai)?/gi, replacement: 'provedor externo' },
    { pattern: /lao\s*zhang/gi, replacement: 'provedor externo' },
    { pattern: /voz\s*premium/gi, replacement: 'provedor externo' },
    { pattern: /voice\s*premium/gi, replacement: 'provedor externo' },
    { pattern: /genaipro/gi, replacement: 'provedor externo' }
];

const sanitizeUserFacingText = (text, fallback = 'Opera√ß√£o') => {
    if (!text || typeof text !== 'string') {
        return fallback;
    }
    let sanitized = text;
    for (const { pattern, replacement } of PROVIDER_NAME_PATTERNS) {
        sanitized = sanitized.replace(pattern, replacement);
    }
    sanitized = sanitized.replace(/\s{2,}/g, ' ').trim();''
    return sanitized || fallback;
};

// Configurar caminho do FFmpeg e FFprobe automaticamente
ffmpeg.setFfmpegPath(ffmpegInstaller.path);
ffmpeg.setFfprobePath(ffprobeInstaller.path);
console.log(`[Sistema] FFmpeg configurado: ${ffmpegInstaller.path}`);
console.log(`[Sistema] FFprobe configurado: ${ffprobeInstaller.path}`);

// --- CONFIGURA√á√ÉO ---
const app = express();
const PORT = process.env.PORT || 5001;
const JWT_SECRET = process.env.JWT_SECRET || 'seu-segredo-jwt-super-secreto-trocar-em-prod';

const ENCRYPTION_SECRET = process.env.ENCRYPTION_SECRET || 'abc123def456ghi789jkl012mno345pqr'; // 32 caracteres
const ALGORITHM = 'aes-256-cbc';

async function ensureAmbientationsTable() {
    await db.run(`CREATE TABLE IF NOT EXISTS niche_ambientations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        niche TEXT,
        theme_key TEXT,
        keywords TEXT,
        ambiente TEXT,
        elementos TEXT,
        acessorios TEXT,
        subject TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);
    await db.run(`CREATE INDEX IF NOT EXISTS idx_niche_ambientations_user ON niche_ambientations(user_id)`);
    await db.run(`CREATE INDEX IF NOT EXISTS idx_niche_ambientations_user_niche ON niche_ambientations(user_id, niche)`);
    try { await db.run('ALTER TABLE niche_ambientations ADD COLUMN acessorios TEXT'); } catch (e) {}
}

async function detectAmbientationFromTitle(userId, title, niche) {
    await ensureAmbientationsTable();
    const rows = await db.all('SELECT id, niche, theme_key, keywords, ambiente, elementos, acessorios, subject FROM niche_ambientations WHERE user_id = ? AND (niche IS NULL OR niche = ?)', [userId, niche || null]);
    if (!rows || rows.length === 0) return null;
    const lower = String(title || '').toLowerCase();
    let best = null;
    let bestScore = 0;
    for (const r of rows) {
        const kw = String(r.keywords || '').toLowerCase().split(/[,;\s]+/).filter(Boolean);
        if (kw.length === 0) continue;
        let score = 0;
        for (const k of kw) { if (k && lower.includes(k)) score++; }
        if (score > bestScore) { bestScore = score; best = r; }
    }
    return bestScore > 0 ? best : null;
}

async function saveAmbientationSnapshot(userId, niche, themeKey, title, ambienteArr, elementosArr, subject, acessorios) {
    await ensureAmbientationsTable();
    const kw = Array.from(new Set(String(title || '').toLowerCase().split(/[^a-z√°√©√≠√≥√∫√£√µ√¢√™√Æ√¥√ª√ß0-9]+/i).filter(w => w && w.length > 2))).slice(0, 10).join(',');
    try {
        await db.run(
            `INSERT INTO niche_ambientations (user_id, niche, theme_key, keywords, ambiente, elementos, acessorios, subject, updated_at)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
            [userId, niche || null, themeKey || null, kw, (ambienteArr || []).join(', '), (elementosArr || []).join(', '), acessorios || null, subject || null]
        );
    } catch (e) {
        await db.run(
            `INSERT INTO niche_ambientations (user_id, niche, theme_key, keywords, ambiente, elementos, subject, updated_at)
             VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
            [userId, niche || null, themeKey || null, kw, (ambienteArr || []).join(', '), (elementosArr || []).join(', '), subject || null]
        );
    }
}

async function seedDefaultAmbientations(userId) {
    await ensureAmbientationsTable();
    const seeds = [
        { theme_key: 'egito_antigo', keywords: 'egito,fara√≥,pir√¢mide,deserto,templo', subject: 'Egyptian pharaoh with nemes headdress and gold jewelry', acessorios: 'gold necklaces and ceremonial regalia', ambiente: 'pyramids and desert storms', elementos: 'hieroglyphs, torches, soldiers' },
        { theme_key: 'neandertais', keywords: 'neandertal,pr√©-hist√≥ria,extin√ß√£o,idade da pedra', subject: 'rugged Neanderthal with thick brow ridges, deep-set eyes, and weathered skin', acessorios: 'primitive fur and animal hides, no metal or feathers', ambiente: 'icy mountains and burning forests during the Ice Age', elementos: 'tribes walking, volcanic ash, mammoth silhouettes, aurora borealis' },
        { theme_key: 'imperio_inca', keywords: 'inca,machu picchu,atahualpa,andes', subject: 'Inca leader with feathered headdress and ornate jewelry', ambiente: 'andes mountains, Inca temples, terraces', elementos: 'Machu Picchu, priests, offerings' },
        { theme_key: 'imperio_asteca', keywords: 'azteca,tenochtitlan,sacrif√≠cio,selva', subject: 'Aztec warrior with plumes and ritual paint', ambiente: 'jungle, Aztec pyramids, ritual smoke', elementos: 'temples, sculptures, sacrifices' },
        { theme_key: 'maias', keywords: 'maia,guatemala,calend√°rio,glyphs', subject: 'Mayan king with ceremonial mask', ambiente: 'dense jungle, stone temples', elementos: 'calendars, glyphs, priests' },
        { theme_key: 'vikings', keywords: 'viking,noruega,invasaÃÉo,mar', subject: 'Viking warrior with axe and thick beard', ambiente: 'stormy seas, burning ships, icy fjords', elementos: 'longships, shields, ravens' },
        { theme_key: 'grecia_antiga', keywords: 'gr√©cia,atenas,olimpio,fil√≥sofo', subject: 'Greek general or philosopher', ambiente: 'doric temples, thundered hills', elementos: 'statues, palaces, columns' },
        { theme_key: 'roma_antiga', keywords: 'romanos,imp√©rio,coliseu,roma', subject: 'Roman centurion', ambiente: 'Colosseum ruins, banners', elementos: 'gladius, shields, aqueducts' },
        { theme_key: 'medieval_cem_anos', keywords: 'medieval,cavaleiros,batalha,castelo', subject: 'Medieval knight', ambiente: 'burning castles, armored riders', elementos: 'lances, flags, catapults' },
        { theme_key: 'guerra_civil_americana', keywords: 'civil americana,gettysburg,union,confederado', subject: 'Civil War soldier', ambiente: 'battlefields, smoke and powder', elementos: 'flags, cannons, horses' },
        { theme_key: 'ww2', keywords: 'wwii,segunda guerra,d-day,na√ß√µes', subject: 'WWII realistic soldier', ambiente: 'ruined city, tanks, rubble', elementos: 'planes, smoke, squads' },
        { theme_key: 'imperio_persa', keywords: 'persa,ciro,aquem√™nida,deserto', subject: 'Persian king with royal jewels', ambiente: 'deserts, luxurious palaces', elementos: 'arches, cavalry, banners' },
        { theme_key: 'china_imperial', keywords: 'china,dinastia,muralha,imperador', subject: 'Chinese emperor', ambiente: 'great wall, temples, mist', elementos: 'dragons, warriors, pagodas' },
        { theme_key: 'japao_samurai', keywords: 'samurai,bushido,edo,katana', subject: 'Samurai in armor', ambiente: 'mountains, sakura, mist', elementos: 'katanas, buddhist temples' },
        { theme_key: 'mesopotamia', keywords: 'mesopot√¢mia,babil√¥nia,sum√©rio,zigurates', subject: 'Sumerian/Babylonian king', ambiente: 'ziggurats, deserts, smoke', elementos: 'cuneiform tablets, deities' },
        { theme_key: 'nativos_america_norte', keywords: 'nativo,√≠ndios,tribo,t√≥tens', subject: 'Native American chief', ambiente: 'forests, mountains, camps', elementos: 'totems, arrows, paintings' },
        { theme_key: 'descobrimento_conquista', keywords: 'descobrimento,columbus,navegador,astrol√°bio', subject: 'European navigator', ambiente: 'ships, storm, tropical coasts', elementos: 'maps, astrolabe' },
        { theme_key: 'revolucao_industrial', keywords: 'industrial,vapor,f√°bricas,engrenagens', subject: 'Worker/engineer', ambiente: 'factories, black smoke, machinery', elementos: 'gears, boilers' },
        { theme_key: 'renascimento_italiano', keywords: 'renascimento,floren√ßa,artista,fil√≥sofo', subject: 'Renaissance artist or philosopher', ambiente: 'Italian squares, artworks', elementos: 'paintings, statues' },
        { theme_key: 'antiguidade_classica_oriental', keywords: 'orientais,confucionismo,templos,desertos', subject: 'Eastern warrior or philosopher', ambiente: 'temples, deserts, sacred mountains', elementos: 'ancient swords, scrolls' },
    ];
    for (const s of seeds) {
        try {
            await db.run(
                `INSERT INTO niche_ambientations (user_id, niche, theme_key, keywords, ambiente, elementos, acessorios, subject, updated_at)
                 VALUES (?, NULL, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
                [userId, s.theme_key, s.keywords, s.ambiente, s.elementos, s.acessorios || null, s.subject]
            );
        } catch {
            await db.run(
                `INSERT INTO niche_ambientations (user_id, niche, theme_key, keywords, ambiente, elementos, subject, updated_at)
                 VALUES (?, NULL, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
                [userId, s.theme_key, s.keywords, s.ambiente, s.elementos, s.subject]
            );
        }
    }
}

// --- GLOBALS ---
let db;

// SSE clients para progresso em tempo real
const sseClients = new Map();

// Diret√≥rio tempor√°rio para arquivos de √°udio
const TEMP_DIR = path.join(__dirname, 'temp_audio');
if (!fs.existsSync(TEMP_DIR)) {
    fs.mkdirSync(TEMP_DIR, { recursive: true });
}

// --- MIDDLEWARES ---
app.use(cors({
  origin: '*', // Allow any origin
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'], // Explicitly allow methods
  allowedHeaders: ['Content-Type', 'Authorization'] // Explicitly allow headers
}));
app.use(express.json({ limit: '50mb' }));

// Middleware de log para requisi√ß√µes (depois do express.json para ter acesso ao body)
app.use((req, res, next) => {
    if (req.path.includes('/forgot-password') || req.path.includes('/auth')) {
        console.log(`[HTTP] ${req.method} ${req.path} - ${new Date().toISOString()}`);
        if (req.body && Object.keys(req.body).length > 0) {
            const bodyCopy = { ...req.body };
            // Ocultar senhas nos logs
            if (bodyCopy.password) bodyCopy.password = '***';
            console.log(`[HTTP] Body recebido:`, bodyCopy);
        }
    }
    next();
});

// Aumentar timeout para requisi√ß√µes longas (transcri√ß√£o pode demorar)
app.use((req, res, next) => {
    // Timeout de 15 minutos para requisi√ß√µes de transcri√ß√£o
    if (req.path.includes('/transcript')) {
        req.setTimeout(15 * 60 * 1000); // 15 minutos
        res.setTimeout(15 * 60 * 1000);
    }
    next();
}); // Aumentar limite para suportar URLs de imagens grandes
app.use(express.urlencoded({ limit: '50mb', extended: true }));

// Desabilitar cache para arquivos HTML durante desenvolvimento
app.use(express.static(__dirname, {
    setHeaders: (res, path) => {
        if (path.endsWith('.html')) {
            res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, private');
            res.setHeader('Pragma', 'no-cache');
            res.setHeader('Expires', '0');
        }
    }
}));

// Middleware para garantir que todas as respostas sejam JSON v√°lido
app.use((req, res, next) => {
    // Interceptar res.json para garantir formato v√°lido
    const originalJson = res.json;
    res.json = function(data) {
        // Garantir que sempre retorna JSON v√°lido
        if (typeof data === 'string') {
            try {
                data = JSON.parse(data);
            } catch {
                data = { msg: data };
            }
        }
        res.setHeader('Content-Type', 'application/json');
        return originalJson.call(this, data);
    };
    next();
});

// Middleware de tratamento de erros para garantir que sempre retorne JSON
app.use((err, req, res, next) => {
    console.error('Erro no middleware:', err);
    if (!res.headersSent) {
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});

// Rota para redirecionar o acesso direto ao arquivo de autentica√ß√£o
app.get('/la-casa-dark-core-auth.html', (req, res) => {
    res.redirect('/');
});

// Rota principal para servir a p√°gina de autentica√ß√£o
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'la-casa-dark-core-auth.html'));
});

// Rota para service worker (deve ser servido com tipo MIME correto)
app.get('/sw.js', (req, res) => {
    res.setHeader('Content-Type', 'application/javascript');
    res.sendFile(path.join(__dirname, 'sw.js'));
});

// Rota para manifest.json
app.get('/manifest.json', (req, res) => {
    res.setHeader('Content-Type', 'application/manifest+json');
    res.sendFile(path.join(__dirname, 'manifest.json'));
});


// --- FUN√á√ïES AUXILIARES DE ENCRIPTA√á√ÉO ---
function encrypt(text) {
    if (!ENCRYPTION_SECRET || ENCRYPTION_SECRET.length !== 32) {
        console.error("ENCRYPTION_SECRET inv√°lida. Deve ter 32 caracteres.");
        throw new Error("Configura√ß√£o de encripta√ß√£o inv√°lida.");
    }
    const iv = crypto.randomBytes(16); // Gera um novo IV para cada encripta√ß√£o
    const cipher = crypto.createCipheriv(ALGORITHM, Buffer.from(ENCRYPTION_SECRET), iv);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return `${iv.toString('hex')}:${encrypted}`;
}

function decrypt(hash) {
    if (!ENCRYPTION_SECRET || ENCRYPTION_SECRET.length !== 32) {
        console.error("ENCRYPTION_SECRET inv√°lida. Deve ter 32 caracteres.");
        throw new Error("Configura√ß√£o de encripta√ß√£o inv√°lida.");
    }
    try {
        const parts = hash.split(':');
        const decipher_iv = Buffer.from(parts.shift(), 'hex');
        const encryptedText = Buffer.from(parts.join(':'), 'hex');
        const decipher = crypto.createDecipheriv(ALGORITHM, Buffer.from(ENCRYPTION_SECRET), decipher_iv);
        let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    } catch (err) {
        console.error("Falha ao desencriptar:", err);
        return null;
    }
}


// --- FUN√á√ïES AUXILIARES DE MINERA√á√ÉO (YOUTUBE API V3) ---
async function callYouTubeDataAPI(videoId, apiKey) {
    if (!apiKey || !apiKey.trim()) {
        throw new Error('Chave de API do YouTube n√£o fornecida.');
    }
    
    // Limpar a chave de espa√ßos e caracteres inv√°lidos
    apiKey = apiKey.trim();
    
    const url = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoId}&key=${apiKey}`;
    try {
        const response = await fetch(url);
        const data = await response.json();
        
        if (!response.ok) {
            // Verificar erros espec√≠ficos da API do YouTube
            if (data.error) {
                const errorMessage = data.error.message || '';
                const errorReason = data.error.errors?.[0]?.reason || '';
                
                console.log('[YouTube API] Erro recebido:', {
                    status: response.status,
                    errorMessage: errorMessage,
                    errorReason: errorReason,
                    fullError: JSON.stringify(data.error, null, 2)
                });
                
                // Erro de API key inv√°lida
                if (errorMessage.includes('API key not valid') || 
                    errorMessage.includes('invalid API key') ||
                    errorMessage.includes('badRequest') ||
                    errorReason === 'keyInvalid' ||
                    errorReason === 'badRequest') {
                    throw new Error('A chave de API do YouTube est√° inv√°lida. Configure uma chave v√°lida nas Configura√ß√µes.');
                }
                
                // Erro de API key n√£o fornecida
                if (errorMessage.includes('API key not found') || 
                    errorReason === 'keyNotFound') {
                    throw new Error('Chave de API do YouTube n√£o configurada. Configure uma chave nas Configura√ß√µes.');
                }
                
                // Erro de quota excedida
                if (errorMessage.includes('quota') || errorReason === 'quotaExceeded') {
                    throw new Error('Cota da API do YouTube excedida. Tente novamente mais tarde.');
                }
                
                // Outros erros
                throw new Error(errorMessage || 'Erro ao buscar dados do YouTube.');
            }
            
            throw new Error('Erro desconhecido ao buscar dados do YouTube.');
        }
        
        if (!data.items || data.items.length === 0) {
            throw new Error('V√≠deo n√£o encontrado. Verifique se a URL est√° correta.');
        }
        
        const item = data.items[0];
        const snippet = item.snippet;
        const stats = item.statistics;

        return {
            title: snippet.title,
            description: snippet.description || '',
            thumbnailUrl: snippet.thumbnails.maxres?.url || snippet.thumbnails.high?.url || snippet.thumbnails.default?.url,
            views: stats.viewCount || 0,
            likes: stats.likeCount || 0,
            comments: stats.commentCount || 0,
            days: Math.round((new Date() - new Date(snippet.publishedAt)) / (1000 * 60 * 60 * 24))
        };
    } catch (err) {
        console.error("Erro ao chamar YouTube Data API v3:", err);
        // Se o erro j√° tem uma mensagem amig√°vel, manter
        if (err.message && (
            err.message.includes('chave de API') || 
            err.message.includes('API key') ||
            err.message.includes('Cota') ||
            err.message.includes('n√£o encontrado')
        )) {
            throw err;
        }
        // Caso contr√°rio, lan√ßar erro gen√©rico
        throw new Error(`Falha ao buscar dados do YouTube: ${err.message}`);
    }
}

async function getChannelVideosWithDetails(channelId, apiKey, order = 'date', maxResults = 5) {
    try {
        // Etapa 1: Buscar IDs dos v√≠deos
        const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=id&channelId=${channelId}&order=${order}&maxResults=${maxResults}&type=video&key=${apiKey}`;
        const searchResponse = await fetch(searchUrl);
        
        if (!searchResponse.ok) {
            const errorText = await searchResponse.text();
            console.error('[getChannelVideosWithDetails] Erro na busca de v√≠deos:', searchResponse.status, errorText.substring(0, 200));
            // Tentar parsear como JSON, se falhar retornar array vazio
            try {
                const errorData = JSON.parse(errorText);
                throw new Error(errorData.error?.message || `Erro ao buscar v√≠deos: ${searchResponse.status}`);
            } catch {
                throw new Error(`Erro ao buscar v√≠deos do canal: ${searchResponse.status}`);
            }
        }
        
        const searchData = await searchResponse.json();
        if (!searchData.items || !Array.isArray(searchData.items)) {
            console.warn('[getChannelVideosWithDetails] Nenhum v√≠deo encontrado ou resposta inv√°lida');
            return [];
        }
        
        const videoIds = searchData.items.map(item => item.id?.videoId).filter(id => id).join(',');
        if (!videoIds) {
            console.warn('[getChannelVideosWithDetails] Nenhum ID de v√≠deo v√°lido encontrado');
            return [];
        }

        // Etapa 2: Buscar detalhes e estat√≠sticas de todos os v√≠deos de uma vez
        const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoIds}&key=${apiKey}`;
        const detailsResponse = await fetch(detailsUrl);
        
        if (!detailsResponse.ok) {
            const errorText = await detailsResponse.text();
            console.error('[getChannelVideosWithDetails] Erro ao buscar detalhes:', detailsResponse.status, errorText.substring(0, 200));
            // Tentar parsear como JSON, se falhar retornar array vazio
            try {
                const errorData = JSON.parse(errorText);
                throw new Error(errorData.error?.message || `Erro ao buscar detalhes: ${detailsResponse.status}`);
            } catch {
                throw new Error(`Erro ao buscar detalhes dos v√≠deos: ${detailsResponse.status}`);
            }
        }
        
        const detailsData = await detailsResponse.json();
        if (!detailsData.items || !Array.isArray(detailsData.items)) {
            console.warn('[getChannelVideosWithDetails] Nenhum detalhe de v√≠deo encontrado');
            return [];
        }

        // Etapa 3: Mapear e formatar os dados (com receita e RPM estimados)
        return detailsData.items.map(item => {
            const uploadDate = new Date(item.snippet.publishedAt);
            const daysPosted = Math.round((new Date() - uploadDate) / (1000 * 60 * 60 * 24));
            const views = parseInt(item.statistics.viewCount || 0);
            // Calcular receita e RPM (usar padr√£o, pode ser melhorado buscando nicho do canal)
            const rpm = getRPMByNiche(null);
            const estimatedRevenueUSD = (views / 1000) * rpm.usd;
            const estimatedRevenueBRL = (views / 1000) * rpm.brl;
            
            return {
                videoId: item.id,
                title: item.snippet.title,
                thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default?.url || '',
                publishedAt: item.snippet.publishedAt,
                views: views,
                likes: parseInt(item.statistics.likeCount || 0),
                comments: parseInt(item.statistics.commentCount || 0),
                days: daysPosted,
                estimatedRevenueUSD: estimatedRevenueUSD,
                estimatedRevenueBRL: estimatedRevenueBRL,
                rpmUSD: rpm.usd,
                rpmBRL: rpm.brl
            };
        });
    } catch (err) {
        console.error('[getChannelVideosWithDetails] Erro geral:', err.message);
        // Sempre retornar array vazio em caso de erro, n√£o lan√ßar exce√ß√£o
        return [];
    }
}

// --- Helper para buscar imagem como Base64 ---
async function fetchImageAsBase64(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Falha ao baixar imagem: ${response.statusText}`);
        const buffer = await response.arrayBuffer();
        const base64 = Buffer.from(buffer).toString('base64');
        const mimeType = response.headers.get('content-type') || 'image/jpeg';
        return { base64, mimeType };
    } catch (err) {
        console.error(`Erro ao converter imagem para base64: ${err.message}`);
        throw err;
    }
}

// --- Helper para corrigir JSON com quebras de linha n√£o escapadas ---
function fixJsonWithUnescapedNewlines(jsonString) {
    let result = '';
    let inString = false;
    let escapeNext = false;
    
    for (let i = 0; i < jsonString.length; i++) {
        const char = jsonString[i];
        const nextChar = jsonString[i + 1];
        
        if (escapeNext) {
            result += char;
            escapeNext = false;
            continue;
        }
        
        if (char === '\\') {
            result += char;
            escapeNext = true;
            continue;
        }
        
        if (char === '"') {
            inString = !inString;
            result += char;
            continue;
        }
        
        if (inString && (char === '\n' || char === '\r')) {
            // Substituir quebras de linha dentro de strings por \n escapado
            if (char === '\r' && nextChar === '\n') {
                result += '\\n';
                i++; // Pular o \n tamb√©m
            } else {
                result += '\\n';
            }
            continue;
        }
        
        result += char;
    }
    
    return result;
}

// --- Fun√ß√£o auxiliar para extrair JSON completo contando chaves ---
function extractCompleteJson(text, startPattern = /\{/) {
    const startMatch = text.match(startPattern);
    if (!startMatch) return null;
    
    const startIndex = startMatch.index;
    let braceCount = 0;
    let inString = false;
    let escapeNext = false;
    
    for (let i = startIndex; i < text.length; i++) {
        const char = text[i];
        
        if (escapeNext) {
            escapeNext = false;
            continue;
        }
        
        if (char === '\\') {
            escapeNext = true;
            continue;
        }
        
        if (char === '"') {
            inString = !inString;
            continue;
        }
        
        if (!inString) {
            if (char === '{') {
                braceCount++;
            } else if (char === '}') {
                braceCount--;
                if (braceCount === 0) {
                    return text.substring(startIndex, i + 1);
                }
            }
        }
    }
    
    return null;
}

// --- Helper para analisar resposta JSON da IA ---
function parseAIResponse(responseText, serviceName) {
    const rawText = (typeof responseText === 'string')
        ? responseText
        : (responseText === null || responseText === undefined ? '' : String(responseText));
    try {
        // Limpar o texto removendo poss√≠veis markdown code blocks
        let cleanedText = rawText.trim();
        
        // Remover markdown code blocks se existirem
        cleanedText = cleanedText.replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/\s*```$/i, '');
        
        // Tenta encontrar um objeto JSON dentro de uma string maior (comum com Claude)
        const jsonMatch = cleanedText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
            let jsonString = jsonMatch[0];
            
            // Tentar parsear diretamente
            try {
                return JSON.parse(jsonString);
            } catch (parseError) {
                // Se falhar, tentar corrigir quebras de linha n√£o escapadas
                try {
                    const fixedJson = fixJsonWithUnescapedNewlines(jsonString);
                    return JSON.parse(fixedJson);
                } catch (secondError) {
                    // √öltima tentativa: usar uma abordagem mais robusta
                    // Extrair apenas o conte√∫do entre as primeiras chaves
                    const firstBrace = jsonString.indexOf('{');
                    const lastBrace = jsonString.lastIndexOf('}');
                    
                    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
                        let extractedJson = jsonString.substring(firstBrace, lastBrace + 1);
                        extractedJson = fixJsonWithUnescapedNewlines(extractedJson);
                        return JSON.parse(extractedJson);
                    }
                    
                    throw parseError;
                }
            }
        }
        
        // Se n√£o encontrar, tenta parsear a string inteira
        return JSON.parse(cleanedText);
    } catch (e) {
        console.error(`[An√°lise-${serviceName}] Falha ao parsear JSON da IA:`, e);
        console.error(`[An√°lise-${serviceName}] Texto recebido (primeiros 2000 caracteres):`, rawText.substring(0, 2000));
        
        // Tentar uma √∫ltima abordagem: usar regex para extrair campos espec√≠ficos
        try {
            // Regex mais robusta que lida com quebras de linha dentro de strings
            const nicheMatch = rawText.match(/"niche"\s*:\s*"((?:[^"\\]|\\.)*)"/);
            const subnicheMatch = rawText.match(/"subniche"\s*:\s*"((?:[^"\\]|\\.)*)"/);
            // Usar [\s\S] em vez de . com flag s para compatibilidade
            const motivoMatch = rawText.match(/"motivoSucesso"\s*:\s*"((?:[^"\\]|\\.|[\s\S])*?)"/);
            const formulaMatch = rawText.match(/"formulaTitulo"\s*:\s*"((?:[^"\\]|\\.|[\s\S])*?)"/);
            
            if (nicheMatch && motivoMatch) {
                console.warn(`[An√°lise-${serviceName}] Usando fallback de parsing regex devido a JSON malformado`);
                
                // Extrair t√≠tulos sugeridos usando regex (mais robusta)
                const titulosMatches = [...rawText.matchAll(/"titulo"\s*:\s*"((?:[^"\\]|\\.)*)"/g)];
                const titulos = titulosMatches.map(m => m[1]).filter(t => t.length > 0);
                
                // Limpar quebras de linha dos valores extra√≠dos
                const cleanValue = (val) => val.replace(/\r?\n/g, ' ').trim();
                
                return {
                    niche: cleanValue(nicheMatch[1]),
                    subniche: subnicheMatch ? cleanValue(subnicheMatch[1]) : 'N/A',
                    analiseOriginal: {
                        motivoSucesso: cleanValue(motivoMatch[1]),
                        formulaTitulo: formulaMatch ? cleanValue(formulaMatch[1]) : 'N/A'
                    },
                    titulosSugeridos: titulos.map((titulo, index) => ({
                        titulo: cleanValue(titulo),
                        pontuacao: 8,
                        explicacao: `T√≠tulo gerado pela IA (parsing fallback)`
                    }))
                };
            }
        } catch (fallbackError) {
            console.error(`[An√°lise-${serviceName}] Fallback tamb√©m falhou:`, fallbackError);
        }
        
        throw new Error(`A IA (${serviceName}) retornou um formato JSON inv√°lido.`);
    }
}

// --- Helper espec√≠fico para An√°lise de T√≠tulos ---
// Aceita JSON (formato antigo) OU lista numerada (1..5) conforme "PROMPT UNIVERSAL ‚Äî CLONAGEM DE T√çTULOS VIRAIS".
function parseNumberedTitles(responseText, expectedCount = 5) {
    const cleaned = String(responseText || '')
        .trim()
        .replace(/^```[a-z]*\s*/i, '')
        .replace(/\s*```$/i, '')
        .trim();

    const titles = [];
    const seen = new Set();

    const pushTitle = (t) => {
        let rawText = String(t || '').trim().replace(/^["']|["']$/g, '').trim();
        if (!rawText) return;
        
        // Extrair t√≠tulo e f√≥rmula se presente (formato: "T√çTULO | F√ìRMULA: descri√ß√£o")
        let title = rawText;
        let formula = null;
        
        const formulaMatch = rawText.match(/^(.+?)\s*\|\s*F[√ìO]RMULA\s*:\s*(.+)$/i);
        if (formulaMatch) {
            title = formulaMatch[1].trim();
            formula = formulaMatch[2].trim();
        }
        
        const key = title.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        titles.push({ title, formula });
    };

    // Normalizar alguns formatos comuns (ex: 1Ô∏è‚É£, travess√µes)
    const normalized = cleaned
        .replace(/1Ô∏è‚É£/g, '1.')
        .replace(/2Ô∏è‚É£/g, '2.')
        .replace(/3Ô∏è‚É£/g, '3.')
        .replace(/4Ô∏è‚É£/g, '4.')
        .replace(/5Ô∏è‚É£/g, '5.')
        .replace(/6Ô∏è‚É£/g, '6.')
        .replace(/7Ô∏è‚É£/g, '7.')
        .replace(/8Ô∏è‚É£/g, '8.')
        .replace(/9Ô∏è‚É£/g, '9.')
        .replace(/10Ô∏è‚É£/g, '10.')
        .replace(/[‚Äú‚Äù]/g, '"')
        .replace(/[‚Äò‚Äô]/g, "'");

    // 0) Se vier como JSON array simples, aceitar (["t1","t2",...])
    try {
        const maybeJson = JSON.parse(normalized);
        if (Array.isArray(maybeJson)) {
            maybeJson.forEach(item => {
                if (typeof item === 'string') pushTitle(item);
            });
            if (titles.length >= expectedCount) return titles.slice(0, expectedCount);
        }
    } catch {}

    // Prefer√™ncia: linhas numeradas
    const lines = normalized.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    for (const line of lines) {
        const m = line.match(/^(\d{1,2})\s*[\)\.\:\-\‚Äì\‚Äî\]\>]\s*(.+)$/);
        if (m && m[2]) pushTitle(m[2]);
    }

    // Fallback: bullets
    if (titles.length === 0) {
        for (const line of lines) {
            const m = line.match(/^(?:[-‚Ä¢*])\s*(.+)$/);
            if (m && m[1]) pushTitle(m[1]);
        }
    }

    // Fallback 2: se veio em uma linha com separadores comuns
    if (titles.length < expectedCount) {
        const chunks = normalized
            .split(/\r?\n|(?:\s*\|\s*)|(?:\s*;\s*)|(?:\s*\/\s*)/g)
            .map(s => s.trim())
            .filter(Boolean);

        // n√£o duplicar trabalho: evitar incluir linhas que j√° eram s√≥ contexto
        if (chunks.length >= expectedCount) {
            for (const c of chunks) {
                // se estiver numerado, remove o prefixo
                const m = c.match(/^(\d{1,2})\s*[\)\.\:\-\‚Äì\‚Äî\]\>]\s*(.+)$/);
                pushTitle(m && m[2] ? m[2] : c);
                if (titles.length >= expectedCount) break;
            }
        }
    }

    // Fallback 3: v√°rios t√≠tulos na mesma linha com numera√ß√£o interna (1... 2... 3...)
    if (titles.length < expectedCount) {
        const pattern = /(\d{1,2})\s*[\)\.\:\-\‚Äì\‚Äî]\s*([\s\S]*?)(?=(\d{1,2})\s*[\)\.\:\-\‚Äì\‚Äî]|$)/g;
        const matches = [...normalized.matchAll(pattern)];
        if (matches.length > 0) {
            for (const m of matches) {
                pushTitle(m[2]);
                if (titles.length >= expectedCount) break;
            }
        }
    }

    // √öltimo fallback: pegar as primeiras linhas n√£o vazias
    if (titles.length === 0) {
        for (const line of lines) pushTitle(line);
    }

    if (titles.length < expectedCount) return null;
    return titles.slice(0, expectedCount);
}

function parseTitleAnalysisResponse(responseText, serviceName, expectedCount = 5) {
    const raw = (typeof responseText === 'string')
        ? responseText
        : (responseText === null || responseText === undefined ? '' : String(responseText));
    const trimmed = raw.trim();

    // Atalho: se parece lista numerada, N√ÉO tentar JSON primeiro (evita logs/erros do parseAIResponse)
    if (/^(?:\s*(?:\d{1,2}|[1-9]Ô∏è‚É£|10Ô∏è‚É£)\s*[\)\.\:\-\‚Äì\‚Äî])/.test(trimmed)) {
        const titles = parseNumberedTitles(trimmed, expectedCount);
        if (titles) {
            return {
                niche: null,
                subniche: null,
                analiseOriginal: { motivoSucesso: 'N/A', formulaTitulo: 'N/A' },
                titulosSugeridos: titles.map(item => ({ 
                    titulo: item.title, 
                    pontuacao: 9, 
                    explicacao: '', 
                    formula: item.formula 
                }))
            };
        }
        throw new Error(`A IA (${serviceName}) retornou lista numerada inv√°lida (<${expectedCount}).`);
    }

    // 1) Tentar JSON padr√£o (compat)
    try {
        const parsed = parseAIResponse(raw, serviceName);
        // 1.a) Formato antigo completo
        if (parsed && Array.isArray(parsed.titulosSugeridos) && parsed.titulosSugeridos.length > 0) {
            return parsed;
        }
        // 1.b) JSON array simples: ["t1","t2"...]
        if (Array.isArray(parsed)) {
            const titles = parsed.filter(x => typeof x === 'string').slice(0, expectedCount);
            if (titles.length >= expectedCount) {
                return {
                    niche: null,
                    subniche: null,
                    analiseOriginal: { motivoSucesso: 'N/A', formulaTitulo: 'N/A' },
                    titulosSugeridos: titles.map(titulo => ({ titulo, pontuacao: 9, explicacao: '' }))
                };
            }
        }
        // 1.c) JSON com array em outros campos comuns
        const altArr = parsed && (
            (Array.isArray(parsed.titles) ? parsed.titles : null) ||
            (Array.isArray(parsed.titulos) ? parsed.titulos : null) ||
            (Array.isArray(parsed.result) ? parsed.result : null)
        );
        if (altArr) {
            const titles = altArr.filter(x => typeof x === 'string').slice(0, expectedCount);
            if (titles.length >= expectedCount) {
                return {
                    niche: null,
                    subniche: null,
                    analiseOriginal: { motivoSucesso: 'N/A', formulaTitulo: 'N/A' },
                    titulosSugeridos: titles.map(titulo => ({ titulo, pontuacao: 9, explicacao: '' }))
                };
            }
        }
    } catch (e) {
        // ignorar: vamos tentar lista numerada
    }

    // 2) Tentar lista numerada 1..5 (novo prompt)
    const titles = parseNumberedTitles(raw, expectedCount);
    if (titles) {
        return {
            niche: null,
            subniche: null,
            analiseOriginal: {
                motivoSucesso: 'N/A',
                formulaTitulo: 'N/A'
            },
            titulosSugeridos: titles.map(item => ({
                titulo: item.title,
                pontuacao: 9,
                explicacao: '',
                formula: item.formula
            }))
        };
    }

    throw new Error(`A IA (${serviceName}) retornou um formato inv√°lido para t√≠tulos. Esperado: JSON ou lista numerada com ${expectedCount} t√≠tulos.`);
}

// --- Score 2: Impacto Visual (0‚Äì10) ---
// N√£o avalia verdade hist√≥rica. Avalia for√ßa competitiva no feed: CAIXA ALTA, loop mental, contraste, clareza em 3s, thumb-friendly.
function computeImpactVisualScore(titleText) {
    const text = String(titleText || '').trim();
    if (!text) return 0;

    const upperMatches = text.match(/[A-Z√Å√â√ç√ì√ö√É√ï√Ç√ä√é√î√õ√á]{3,}(?:\s+[A-Z√Å√â√ç√ì√ö√É√ï√Ç√ä√é√î√õ√á]{3,})*/g) || [];
    const uniqueUpper = Array.from(new Set(upperMatches.map(s => s.trim()))).filter(Boolean);

    const letters = (text.match(/[A-Za-z√Å√â√ç√ì√ö√É√ï√Ç√ä√é√î√õ√á√°√©√≠√≥√∫√£√µ√¢√™√Æ√¥√ª√ß]/g) || []).length;
    const upperLetters = (text.match(/[A-Z√Å√â√ç√ì√ö√É√ï√Ç√ä√é√î√õ√á]/g) || []).length;
    const isMostlyAllCaps = letters > 0 && (upperLetters / letters) > 0.85;

    // 1) CAIXA ALTA (0‚Äì3)
    let scoreCaps = 0;
    if (uniqueUpper.length === 0) {
        scoreCaps = 0;
    } else if (isMostlyAllCaps) {
        // polui√ß√£o visual: tudo em caps
        scoreCaps = 0;
    } else if (uniqueUpper.length === 1) {
        scoreCaps = 1;
    } else if (uniqueUpper.length === 2) {
        scoreCaps = 2;
    } else {
        scoreCaps = 3;
    }

    // 2) Loop mental (0‚Äì2)
    // Mais alinhado ao crit√©rio: palavras de "lacuna" contam forte mesmo sem interroga√ß√£o.
    const strongLoop = /(N[√ÉA]O\s+DEVERIA|NUNCA\s+DEVERIA|NINGU[√âE]M\s+EXPLICA|N[√ÉA]O\s+CONSEGUE\s+EXPLICAR|DETALHE\s+(IGNORADO|OCULTO)|COMO\s+FOI\s+POSS[√çI]VEL|O\s+SEGREDO|MIST[√âE]RIO|VERDADE\s+(OCULTA|SOBRE)|NINGU[√âE]M\s+(CONTA|TE\s+CONTA))/i.test(text);
    const softLoop = /(\?|COMO|POR\s+QUE|O\s+QUE|QUASE\s+NINGU[√âE]M|NINGU[√âE]M|SEGREDO|DETALHE|REVELA|IMPOSS[√çI]VEL|NUNCA)/i.test(text);
    const scoreLoop = strongLoop ? 2 : (softLoop ? 1 : 0);

    // 3) Contraste / tens√£o visual (0‚Äì2)
    const hasArrow = /‚Üí|->/i.test(text);
    const hasContrastWord = /\b(MAS|POR[√âE]M|S[√ìO]\s+QUE|MESMO\s+ASSIM|AINDA\s+ASSIM|APESAR|CONTRA)\b/i.test(text);
    const hasTwoClauses = /[.!?].+/.test(text) || hasArrow || /:\s*\S+/.test(text);
    const hasTensionEnv = /\b(HOSTIL|PIOR\s+LUGAR|P[√ÇA]NTANO|LAGO|DEBAIXO\s+D['‚Äô]?[√ÅA]GUA|PROIBIDO|MORTAL)\b/i.test(text);
    let scoreContrast = 0;
    if (hasArrow) scoreContrast = 2;
    else if (hasContrastWord && hasTwoClauses) scoreContrast = 2;
    else if (hasTwoClauses || hasContrastWord || hasTensionEnv) scoreContrast = 1;

    // 4) Clareza em at√© 3s (0‚Äì2)
    const words = text.split(/\s+/).filter(Boolean);
    let scoreClarity = 0;
    // Um pouco mais permissivo (Claude/Gemini tendem a ser levemente mais longos)
    if (words.length <= 14) scoreClarity = 2;
    else if (words.length <= 18) scoreClarity = 1;
    else scoreClarity = 0;
    // Penalizar excesso de complexidade: muitas v√≠rgulas/termos t√©cnicos longos
    const commas = (text.match(/,/g) || []).length;
    if (commas >= 3 && scoreClarity > 0) scoreClarity -= 1;

    // 5) Compatibilidade com thumb (0‚Äì1)
    // Thumb-friendly quando h√° 1+ termo em caps e a leitura n√£o √© longa demais
    const scoreThumb = (scoreCaps > 0 && words.length <= 18) ? 1 : 0;

    const total = scoreCaps + scoreLoop + scoreContrast + scoreClarity + scoreThumb;
    return Math.max(0, Math.min(10, Math.round(total)));
}

function enforceImpactGate(titles, { minImpact = 7, expectedCount = 5 } = {}) {
    const normalized = Array.isArray(titles) ? titles : [];
    const withScore = normalized.map(t => ({
        ...t,
        impact_score: typeof t.impact_score === 'number' ? t.impact_score : computeImpactVisualScore(t.titulo)
    }));
    const passing = withScore
        .filter(t => Number(t.impact_score || 0) >= minImpact)
        .sort((a, b) => Number(b.impact_score || 0) - Number(a.impact_score || 0));
    return { passing: passing.slice(0, expectedCount), withScore };
}

function buildTitleRefinePrompt({
    originalTitle,
    translatedTitle,
    performanceContext,
    descriptionStart,
    transcriptStart,
    languageInstruction,
    titlesRequired = 5,
    minImpact = 7,
    avoidTitles = [],
    attemptLevel = 1
}) {
    const avoidBlock = avoidTitles && avoidTitles.length
        ? `\nT√çTULOS J√Å ACEITOS (N√ÉO REPETIR IDEIA/NEM FRASE):\n${avoidTitles.map(t => `- ${t}`).join('\n')}\n`
        : '';
    const level = Number(attemptLevel || 1);
    const attemptBlock = () => {
        if (level <= 1) return '';
        if (level === 2) {
            return `\nAUTO-FALLBACK (2¬™ tentativa ‚Äî relaxar 1 regra)\n- CAIXA ALTA pode ser apenas 1 palavra (a mais forte)\n- Contraste pode ser sutil (n√£o precisa ser extremo)\n`;
        }
        return `\nAUTO-FALLBACK (3¬™ tentativa ‚Äî generalizar cen√°rio)\n- Se houver risco factual, GENERALIZE cen√°rio/povo/local (ex: ‚Äúuma CIVILIZA√á√ÉO ANTIGA‚Äù, ‚Äúuma cidade improv√°vel‚Äù, ‚Äúum AMBIENTE HOSTIL‚Äù)\n`;
    };
    return `PROMPT FINAL ‚Äî GERA√á√ÉO DE T√çTULOS VIRAIS (‚â• ${minImpact} COM AUTO-FALLBACK)

Voc√™ receber√° o t√≠tulo de um v√≠deo que J√Å VIRALIZOU, comprovadamente com alto CTR e reten√ß√£o.

OBJETIVO CENTRAL (REGRA ABSOLUTA)

Gerar ${titlesRequired} t√≠tulos ALTAMENTE COMPETITIVOS, focados em:
- CTR alto
- Reten√ß√£o inicial
- Impacto visual no feed

üëâ Somente t√≠tulos com IMPACTO VISUAL ESTIMADO ‚â• ${minImpact}/10 podem ser entregues ao frontend.

PRINC√çPIO-CHAVE

O t√≠tulo original j√° venceu o algoritmo.
Sua fun√ß√£o √© clonar a f√≥rmula psicol√≥gica vencedora, intensificando impacto,
variando o cen√°rio, sem quebrar fidelidade tem√°tica.

REGRAS OBRIGAT√ìRIAS DE IMPACTO

Cada t√≠tulo precisa conter:

1Ô∏è‚É£ GATILHOS EM CAIXA ALTA (OBRIGAT√ìRIO)

Use 1 a 3 termos em CAIXA ALTA

Priorize gatilhos fortes:

IMPOSS√çVEL
NUNCA
SEGREDO
NINGU√âM
VERDADE
GENIALIDADE
OBRA IMPOSS√çVEL
N√ÉO DEVERIA EXISTIR

Sem CAIXA ALTA estrat√©gica ‚Üí impacto insuficiente.

2Ô∏è‚É£ LOOP MENTAL INCOMPLETO

O t√≠tulo n√£o pode explicar tudo.
Deve criar expectativa clara de revela√ß√£o ap√≥s o clique.

Exemplos v√°lidos:

‚ÄúNUNCA DEVERIA TER FUNCIONADO‚Äù
‚ÄúNINGU√âM EXPLICA ISSO‚Äù
‚ÄúO DETALHE IGNORADO‚Äù

3Ô∏è‚É£ CONTRASTE OU TENS√ÉO

Cada t√≠tulo deve conter ao menos um contraste:

ambiente hostil √ó sucesso
imposs√≠vel √ó realizado
esquecido √ó grandioso
antigo √ó avan√ßado

4Ô∏è‚É£ VARIA√á√ÉO OBRIGAT√ìRIA DE CEN√ÅRIO

Entre os ${titlesRequired} t√≠tulos:

NO M√çNIMO 3 DEVEM trocar explicitamente:

local
povo / civiliza√ß√£o
cen√°rio ambiental ou contextual

Se houver risco factual, GENERALIZE:

‚Äúuma CIVILIZA√á√ÉO ANTIGA‚Äù
‚Äúuma CIDADE ESQUECIDA‚Äù
‚Äúum AMBIENTE HOSTIL‚Äù

5Ô∏è‚É£ LEITURA EM AT√â 3 SEGUNDOS

Frases curtas
Estrutura simples
Impacto imediato

6Ô∏è‚É£ VARIA√á√ÉO CONTEXTUAL UNIVERSAL (OBRIGAT√ìRIA)

Entre os ${titlesRequired} t√≠tulos gerados, voc√™ DEVE variar explicitamente os ELEMENTOS CONTEXTUAIS,
independentemente do nicho.

Distribua os t√≠tulos para que cada um enfatize um eixo diferente:

1. Um t√≠tulo com foco no ATOR (quem fez / quem viveu)
2. Um t√≠tulo com foco no AMBIENTE ou CONTEXTO (onde / em que situa√ß√£o)
3. Um t√≠tulo com foco no DESAFIO ou LIMITA√á√ÉO (o que tornava dif√≠cil)
4. Um t√≠tulo com foco na SOLU√á√ÉO ou A√á√ÉO (o que foi feito)
5. Um t√≠tulo com foco no RESULTADO ou IMPACTO (o que mudou)

N√£o reutilize o mesmo elemento contextual como foco principal em mais de um t√≠tulo.
Se houver risco de imprecis√£o, generalize (ex: "algu√©m", "um grupo", "uma situa√ß√£o extrema").

Execute silenciosamente.

7Ô∏è‚É£ VARIA√á√ÉO DE ATOR (OBRIGAT√ìRIA)

Entre os ${titlesRequired} t√≠tulos gerados, voc√™ DEVE variar explicitamente o ATOR principal.
O ATOR √© quem executa a a√ß√£o central do t√≠tulo.

Cada t√≠tulo deve usar um ATOR DIFERENTE, escolhendo entre:

- um povo
- uma civiliza√ß√£o
- um grupo
- uma sociedade
- uma organiza√ß√£o
- um ator gen√©rico (ex: "um povo esquecido", "uma civiliza√ß√£o perdida", "um grupo improv√°vel")

√â PROIBIDO que mais de dois t√≠tulos usem o mesmo ATOR impl√≠cito ou expl√≠cito.
Se detectar repeti√ß√£o do mesmo ATOR (mesmo que sem nome), voc√™ DEVE reescrever antes de entregar.

Se houver risco factual, use ATOR gen√©rico, mas DIFERENTE do anterior.

Execute silenciosamente.

AUTO-REFINO OBRIGAT√ìRIO (CR√çTICO)

Antes de entregar os t√≠tulos:

Avalie mentalmente o IMPACTO VISUAL (0‚Äì10) de cada t√≠tulo

Se algum t√≠tulo ficar < ${minImpact}, voc√™ DEVE:

reescrev√™-lo imediatamente
refor√ßar CAIXA ALTA, contraste ou loop mental

Repita esse processo internamente at√© que:

todos os ${titlesRequired} t√≠tulos estejam com impacto ‚â• ${minImpact}

‚ö†Ô∏è Nunca entregue t√≠tulos < ${minImpact}.
    ‚ö†Ô∏è N√£o explique o processo. Apenas entregue o resultado final.
${attemptBlock()}

IDIOMA
- Todos os t√≠tulos devem estar ${languageInstruction}.

CONTEXTO DO V√çDEO (para fidelidade ‚Äî n√£o copie texto literalmente)
${performanceContext ? performanceContext : ''}
- T√≠tulo original (idioma original): "${originalTitle}"
- T√≠tulo traduzido (PT-BR): "${translatedTitle || originalTitle}"
- Descri√ß√£o (in√≠cio): ${descriptionStart || 'N/A'}...
- Transcri√ß√£o (in√≠cio): ${transcriptStart || 'N/A'}...
${avoidBlock}
FORMATO DE SA√çDA (OBRIGAT√ìRIO)

Retorne EXATAMENTE ${titlesRequired} t√≠tulos, numerados de 1 a ${titlesRequired}.

Cada linha deve seguir este formato:
N√öMERO. T√çTULO | F√ìRMULA: [descri√ß√£o breve da estrutura usada]

A F√ìRMULA deve identificar:
- Qual ATOR foi usado (ex: "povo esquecido", "civiliza√ß√£o antiga", "grupo improv√°vel")
- Qual EIXO CONTEXTUAL foi enfatizado (ATOR/AMBIENTE/DESAFIO/SOLU√á√ÉO/IMPACTO)
- Qual GATILHO PSICOL√ìGICO dominante (MIST√âRIO/CONTRASTE/IMPOSS√çVEL/SEGREDO/REVELA√á√ÉO)

Exemplo de formato v√°lido:
1. A GENIALIDADE que criou uma CIDADE no NADA | F√ìRMULA: Civiliza√ß√£o antiga + DESAFIO + Contraste imposs√≠vel
2. O SEGREDO por tr√°s de uma OBRA PROIBIDA | F√ìRMULA: Grupo desconhecido + SOLU√á√ÉO + Mist√©rio oculto

Sem explica√ß√µes adicionais.
Sem emojis.
SEM JSON.`;
}

function deriveNicheAndSubnicheFromContext({ originalTitle, translatedTitle, descriptionStart, transcriptStart }) {
    const hay = `${originalTitle || ''}\n${translatedTitle || ''}\n${descriptionStart || ''}\n${transcriptStart || ''}`.toLowerCase();
    // Heur√≠stica simples (fallback) ‚Äî evita "N/A" na UI
    if (/(hist[o√≥]ria|civiliza|imp[e√©]rio|antigo|antiga|aztec|astec|tenocht|maia|inca|roma|egito|eg[ip√≠]cio)/i.test(hay)) {
        return { niche: 'Hist√≥ria', subniche: 'Civiliza√ß√µes Antigas' };
    }
    if (/(finan|dinheiro|invest|renda|bitcoin|cripto|a[c√ß][a√£]o|bolsa)/i.test(hay)) {
        return { niche: 'Finan√ßas', subniche: 'Investimentos' };
    }
    if (/(sa[u√∫]de|fitness|treino|dieta|emagrec|ansiedade|depress)/i.test(hay)) {
        return { niche: 'Sa√∫de', subniche: 'Bem-estar' };
    }
    return { niche: 'Entretenimento', subniche: 'N/A' };
}

function deriveTitleAnalysis({ originalTitle, translatedTitle, views, days }) {
    const t = String(translatedTitle || originalTitle || '').trim();
    const lower = t.toLowerCase();
    const isList = /\b(\d+)\b/.test(lower) || /(pilares|raz[√µo]es|fundamentos|segredos|passos)/i.test(lower);
    const hasHow = /(como|how)/i.test(lower);
    const hasWhy = /(por que|porque|why)/i.test(lower);
    const hasBigWord = /(genial|imposs[i√≠]vel|segredo|mist[e√©]rio|verdade|ningu[e√©]m|nunca)/i.test(lower);
    const vpd = days ? Math.round((views || 0) / Math.max(days, 1)) : null;

    const motivoSucesso = [
        vpd ? `Ganhou tra√ß√£o por consist√™ncia de interesse (‚âà${vpd.toLocaleString()} views/dia).` : 'Ganhou tra√ß√£o por consist√™ncia de interesse.',
        isList ? 'Promessa clara de estrutura (lista) ajuda clique e reten√ß√£o.' : 'Promessa clara do tema ajuda clique.',
        hasHow || hasWhy ? '√Çngulo de curiosidade (‚Äúcomo/por que‚Äù) aumenta expectativa inicial.' : (hasBigWord ? 'Palavra de impacto aumenta o stop-scroll.' : 'Tema forte sustenta o clique.')
    ].join(' ');

    const formulaTitulo = [
        isList ? 'Estrutura de lista + promessa de clareza' : 'Promessa central + benef√≠cio',
        hasHow ? '+ gancho ‚ÄúCOMO FOI POSS√çVEL‚Äù' : '',
        hasWhy ? '+ gancho ‚ÄúPOR QUE‚Äù' : '',
        '+ 1‚Äì3 termos em CAIXA ALTA (gatilho principal)',
        '+ loop mental (o detalhe/segredo/verdade) sem inventar fatos',
        '+ contraste leve (antes vs depois / hostil vs feito) quando aplic√°vel'
    ].filter(Boolean).join(' ');

    return { motivoSucesso, formulaTitulo };
}

async function generatePassingTitlesWithRefine({
    apiFunc,
    apiKey,
    model,
    serviceName,
    basePromptBuilder,
    buildArgs,
    titlesRequired = 5,
    minImpact = 7,
    maxRefines = 3
}) {
    let accepted = [];
    for (let attempt = 0; attempt <= maxRefines; attempt++) {
        const prompt = basePromptBuilder({
            ...buildArgs,
            titlesRequired,
            minImpact,
            avoidTitles: accepted.map(t => t.titulo),
            attemptLevel: Math.min(3, attempt + 1) // 1¬™, 2¬™, 3¬™ (fallback)
        });
        const resp = await apiFunc(prompt, apiKey, model);
        const text = typeof resp === 'string' ? resp : (resp?.titles || '');
        const parsed = parseTitleAnalysisResponse(text, serviceName, titlesRequired);
        const merged = [...accepted, ...parsed.titulosSugeridos];
        accepted = enforceImpactGate(merged, { minImpact, expectedCount: titlesRequired }).passing;
        if (accepted.length >= titlesRequired) break;
    }
    return accepted;
}


// --- FUN√á√ïES AUXILIARES DE API (O DISTRIBUIDOR) ---

async function callGeminiAPI(prompt, apiKey, model, imageUrl = null, additionalImages = []) {
    if (!apiKey) throw new Error("Chave de API do Utilizador (Gemini) n√£o configurada.");
    
    const modelName = model; // Usar o nome do modelo diretamente do frontend

    const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
    
    const parts = [];
    
    // Adicionar imagem principal se fornecida
    if (imageUrl) {
        const { base64, mimeType } = await fetchImageAsBase64(imageUrl);
        parts.push({
            inlineData: {
                mimeType: mimeType,
                data: base64
            }
        });
    }
    
    // Adicionar imagens adicionais (thumbnails de refer√™ncia)
    if (Array.isArray(additionalImages) && additionalImages.length > 0) {
        for (const img of additionalImages) {
            let base64, mimeType;
            if (typeof img === 'string') {
                // Se for base64 string direto
                if (img.startsWith('data:image/')) {
                    const imgParts = img.split(',');
                    base64 = imgParts[1];
                    // Extrair mimeType completo
                    const mimeMatch = imgParts[0].match(/data:image\/([^;]+)/);
                    if (mimeMatch && mimeMatch[1]) {
                        const mimePart = mimeMatch[1].toLowerCase();
                        // Normalizar para os tipos aceitos
                        if (mimePart === 'jpeg' || mimePart === 'jpg') {
                            mimeType = 'image/jpeg';
                        } else if (mimePart === 'png') {
                            mimeType = 'image/png';
                        } else if (mimePart === 'gif') {
                            mimeType = 'image/gif';
                        } else if (mimePart === 'webp') {
                            mimeType = 'image/webp';
                        } else {
                            mimeType = 'image/jpeg';
                        }
                    } else {
                        mimeType = 'image/jpeg';
                    }
                } else {
                    // Assumir que √© base64 puro
                    base64 = img;
                    mimeType = 'image/jpeg';
                }
            } else if (img.base64) {
                base64 = img.base64.startsWith('data:image/') ? img.base64.split(',')[1] : img.base64;
                // Normalizar mimeType se fornecido
                if (img.mimeType) {
                    const mimeLower = img.mimeType.toLowerCase();
                    if (mimeLower === 'jpeg' || mimeLower === 'jpg' || mimeLower === 'image/jpeg') {
                        mimeType = 'image/jpeg';
                    } else if (mimeLower === 'png' || mimeLower === 'image/png') {
                        mimeType = 'image/png';
                    } else if (mimeLower === 'gif' || mimeLower === 'image/gif') {
                        mimeType = 'image/gif';
                    } else if (mimeLower === 'webp' || mimeLower === 'image/webp') {
                        mimeType = 'image/webp';
                    } else {
                        mimeType = 'image/jpeg';
                    }
                } else {
                    mimeType = 'image/jpeg';
                }
            }
            
            if (base64 && mimeType) {
                parts.push({
                    inlineData: {
                        mimeType: mimeType,
                        data: base64
                    }
                });
            }
        }
    }
    
    // Sempre adicionar o texto por √∫ltimo
    parts.push({ text: prompt });

    // Detectar se √© pedido de roteiro (texto puro) ou JSON
    const isScriptRequest = typeof prompt === 'string' && (
        prompt.includes('RESPOSTA FINAL - CR√çTICO') ||
        prompt.includes('roteiro em TEXTO SIMPLES') ||
        prompt.includes('N√ÉO use JSON') ||
        prompt.includes('Escreva APENAS o texto') ||
        prompt.includes('SEM JSON')
    );

    const generationConfig = {
            temperature: 0.7, 
            topK: 1, 
            topP: 1, 
            maxOutputTokens: 32000  // Aumentar para permitir gerar muitas cenas (31 cenas x ~1000 chars = ~31000 tokens)
    };
    
    // CR√çTICO: S√≥ adicionar responseMimeType se N√ÉO for pedido de roteiro
    if (!isScriptRequest) {
        generationConfig.responseMimeType = "application/json";
    }

    const payload = {
        contents: [{ parts: parts }],
        generationConfig: generationConfig,
    };

    // Retry logic com backoff exponencial para erro 429 (Resource exhausted)
    const maxRetries = 3;
    const baseDelay = 2000; // 2 segundos base
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
            const response = await fetch(GEMINI_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();

            if (!response.ok) {
                console.error('[La Casa Dark Core] Erro da API:', result);
                
                // Tratar erro de autentica√ß√£o
                if (response.status === 400 && result.error?.message.includes('API key not valid')) {
                    throw new Error(`A sua Chave de API do Gemini √© inv√°lida.`);
                }
                
                // Tratar erro 429 (Resource exhausted) com retry
                if (response.status === 429 || (result.error?.message && result.error.message.includes('Resource exhausted'))) {
                    if (attempt < maxRetries) {
                        const delay = baseDelay * Math.pow(2, attempt); // Backoff exponencial: 2s, 4s, 8s
                        console.warn(`[La Casa Dark Core] Limite de requisi√ß√µes atingido (429). Tentativa ${attempt + 1}/${maxRetries + 1}. Aguardando ${delay}ms antes de tentar novamente...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue; // Tentar novamente
                    } else {
                        // Todas as tentativas falharam
                        throw new Error(`Limite de requisi√ß√µes atingido para a API Gemini. Aguarde alguns minutos ou use outro modelo de IA (Claude ou OpenAI). Detalhes: ${result.error?.message || response.statusText}`);
                    }
                }
                
                // Outros erros n√£o relacionados a rate limit
                throw new Error(`Erro da API Gemini: ${result.error?.message || response.statusText}`);
            }
            
            // Sucesso - processar resposta
            if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0].text) {
                const content = result.candidates[0].content.parts[0].text;
                
                // Se for pedido de roteiro, retornar texto direto
                if (isScriptRequest) {
                    console.log('[La Casa Dark Core] Retornando texto puro de script');
                    return content; // Retorna string diretamente
                } else {
                    // Para JSON, manter comportamento antigo
                    return { titles: content, model: model };
                }
            } else {
                console.error('[La Casa Dark Core] Resposta inesperada da API:', result);
                throw new Error('A resposta da IA foi bloqueada ou retornou vazia.');
            }
        } catch (error) {
            // Se for erro de rate limit e ainda temos tentativas, continuar o loop
            if (error.message.includes('Resource exhausted') || error.message.includes('Limite de requisi√ß√µes')) {
                if (attempt < maxRetries) {
                    const delay = baseDelay * Math.pow(2, attempt);
                    console.warn(`[La Casa Dark Core] Erro detectado. Tentativa ${attempt + 1}/${maxRetries + 1}. Aguardando ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    continue;
                }
            }
            
            // Se n√£o for erro de rate limit ou se esgotaram as tentativas, lan√ßar erro
            console.error('[La Casa Dark Core] Falha ao chamar a API:', error);
            throw error;
        }
    }
}
async function callOpenAIAPI(prompt, apiKey, model, imageUrl = null, additionalImages = []) {
    if (!apiKey) throw new Error("Chave de API do Utilizador (OpenAI) n√£o configurada.");
    
    const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
    
    const modelName = model; // Usar o nome do modelo diretamente do frontend

    const content = [];
    
    // Adicionar imagem principal se fornecida
    if (imageUrl) {
        content.push({
            type: "image_url",
            image_url: { "url": imageUrl, "detail": "high" }
        });
    }
    
    // Adicionar imagens adicionais (thumbnails de refer√™ncia)
    if (Array.isArray(additionalImages) && additionalImages.length > 0) {
        for (const img of additionalImages) {
            let imgUrl;
            if (typeof img === 'string') {
                // Se for base64 string, usar diretamente
                imgUrl = img.startsWith('data:image/') ? img : `data:image/jpeg;base64,${img}`;
            } else if (img.base64) {
                imgUrl = img.base64.startsWith('data:image/') ? img.base64 : `data:image/jpeg;base64,${img.base64}`;
            }
            
            if (imgUrl) {
                content.push({
                    type: "image_url",
                    image_url: { "url": imgUrl, "detail": "high" }
                });
            }
        }
    }
    
    // Sempre adicionar o texto por √∫ltimo
    content.push({ type: "text", text: prompt });

    // Detectar se √© pedido de roteiro (texto puro) ou JSON
    const isScriptRequest = typeof prompt === 'string' && (
        prompt.includes('RESPOSTA FINAL - CR√çTICO') ||
        prompt.includes('roteiro em TEXTO SIMPLES') ||
        prompt.includes('N√ÉO use JSON') ||
        prompt.includes('Escreva APENAS o texto') ||
        prompt.includes('SEM JSON')
    );

    // Determinar max_tokens baseado no modelo
    // GPT-4o suporta no m√°ximo 16384 tokens de completion
    // Outros modelos podem ter limites diferentes
    let maxTokens = 16384; // Padr√£o seguro para GPT-4o
    if (modelName && typeof modelName === 'string') {
        const modelLower = modelName.toLowerCase();
        if (modelLower.includes('gpt-4o')) {
            maxTokens = 16384; // Limite do GPT-4o
        } else if (modelLower.includes('gpt-4-turbo') || modelLower.includes('gpt-4-1106')) {
            maxTokens = 4096; // Limite de modelos GPT-4 Turbo mais antigos
        } else if (modelLower.includes('gpt-3.5')) {
            maxTokens = 4096; // Limite do GPT-3.5
        } else {
            // Para outros modelos, usar 16384 como padr√£o seguro
            maxTokens = 16384;
        }
    }

    const payload = {
        model: modelName,
        messages: [
            { 
                role: "system", 
                content: isScriptRequest 
                    ? "You are a professional scriptwriter. Respond ONLY with the script text in plain text format. Do NOT use JSON, objects, or special formatting. Write natural, flowing text."
                    : "You are a helpful assistant designed to output JSON."
            },
            { role: "user", content: content }
        ],
        temperature: 0.7,
        max_tokens: maxTokens,
    };
    
    // CR√çTICO: S√≥ adicionar response_format se N√ÉO for pedido de roteiro
    if (!isScriptRequest) {
        payload.response_format = { type: "json_object" };
    }

    try {
        const response = await fetch(OPENAI_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify(payload)
        });
        const result = await response.json();

        if (!response.ok) {
            console.error('[La Casa Dark Core] Erro da API:', result);
            if (result.error?.code === 'invalid_api_key') {
                 throw new Error(`A sua Chave de API do OpenAI √© inv√°lida.`);
            }
            throw new Error(`Erro da API OpenAI: ${result.error?.message || response.statusText}`);
        }
        if (result.choices && result.choices[0].message && result.choices[0].message.content) {
            const content = result.choices[0].message.content;
            
            // Se for pedido de roteiro, retornar texto direto sem envolver em "titles"
            if (isScriptRequest) {
                console.log('[La Casa Dark Core] Retornando texto puro de script');
                return content; // Retorna string diretamente
            } else {
                // Para JSON, manter comportamento antigo
                return { titles: content, model: model };
            }
        } else {
            throw new Error('A resposta da IA (OpenAI) retornou vazia.');
        }
    } catch (error) {
        console.error('[La Casa Dark Core] Falha ao chamar a API:', error);
        throw error;
    }
}

async function callClaudeAPI(prompt, apiKey, model, imageUrl = null, customTimeout = null, additionalImages = []) {
    if (!apiKey) throw new Error("Chave de API do Utilizador (Claude) n√£o configurada.");
    
    const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';
    
    // Mapeamento de nomes amig√°veis para nomes corretos da API da Anthropic
    // MODELOS V√ÅLIDOS CONFIRMADOS (Novembro 2025 - Anthropic API):
    // - claude-3-7-sonnet-20250219 (Sonnet mais recente)
    // - claude-sonnet-4-20250514 (Sonnet 4)
    // - claude-opus-4-20250514 (Opus 4)
    const modelAliases = {
        'claude-3-5-sonnet-20241022': 'claude-3-7-sonnet-20250219',
        'claude-3-5-sonnet-20240620': 'claude-3-7-sonnet-20250219',
        'claude-3-5-sonnet-latest': 'claude-3-7-sonnet-20250219',
        'claude-3-sonnet-20240229': 'claude-3-7-sonnet-20250219',
        'claude-3.5-sonnet-20241022': 'claude-3-7-sonnet-20250219',
        'claude-3.5-sonnet-20240620': 'claude-3-7-sonnet-20250219',
        'claude-3-haiku-20240307': 'claude-3-7-sonnet-20250219',
        'claude-3.5-haiku-20241022': 'claude-3-7-sonnet-20250219',
        'claude-3-5-haiku-20241022': 'claude-3-7-sonnet-20250219',
        'claude-3-5-haiku-latest': 'claude-3-7-sonnet-20250219',
        'claude-3-opus-20240229': 'claude-opus-4-20250514'
    };
    
    const supportedModels = new Set([
        'claude-3-7-sonnet-20250219',  // Modelo mais recente
        'claude-sonnet-4-20250514',    // Sonnet 4
        'claude-opus-4-20250514'       // Opus 4
    ]);
    
    let modelName = modelAliases[model] || model;
    
    if (!supportedModels.has(modelName)) {
        if (model && model.toLowerCase().includes('opus')) {
            modelName = 'claude-opus-4-20250514';
        } else if (model && (model.toLowerCase().includes('sonnet') || model.toLowerCase().includes('4'))) {
            modelName = 'claude-sonnet-4-20250514';
        } else {
            modelName = 'claude-3-7-sonnet-20250219';
        }
        console.warn(`[Claude API] Modelo ${model} n√£o reconhecido. Usando ${modelName} como padr√£o.`);
    }
    
    const validModels = ['claude-3-7-sonnet-20250219', 'claude-sonnet-4-20250514', 'claude-opus-4-20250514'];
    
    console.log(`[Claude API] Modelo original: ${model}, Modelo mapeado: ${modelName}`);

    const content = [];
    
    // Adicionar imagem principal se fornecida
    if (imageUrl) {
        const { base64, mimeType } = await fetchImageAsBase64(imageUrl);
        content.push({
            type: "image",
            source: {
                type: "base64",
                media_type: mimeType,
                data: base64
            }
        });
    }
    
    // Adicionar imagens adicionais (thumbnails de refer√™ncia)
    if (Array.isArray(additionalImages) && additionalImages.length > 0) {
        for (const img of additionalImages) {
            let base64, mimeType;
            if (typeof img === 'string') {
                // Se for base64 string direto
                if (img.startsWith('data:image/')) {
                    const parts = img.split(',');
                    base64 = parts[1];
                    // Extrair mimeType completo (data:image/jpeg ou data:image/png, etc)
                    const mimeMatch = parts[0].match(/data:image\/([^;]+)/);
                    if (mimeMatch && mimeMatch[1]) {
                        const mimePart = mimeMatch[1].toLowerCase();
                        // Normalizar para os tipos aceitos pelo Claude API
                        if (mimePart === 'jpeg' || mimePart === 'jpg') {
                            mimeType = 'image/jpeg';
                        } else if (mimePart === 'png') {
                            mimeType = 'image/png';
                        } else if (mimePart === 'gif') {
                            mimeType = 'image/gif';
                        } else if (mimePart === 'webp') {
                            mimeType = 'image/webp';
                        } else {
                            // Default para jpeg se n√£o reconhecer
                            mimeType = 'image/jpeg';
                        }
                    } else {
                        mimeType = 'image/jpeg';
                    }
                } else {
                    // Assumir que √© base64 puro
                    base64 = img;
                    mimeType = 'image/jpeg';
                }
            } else if (img.base64) {
                base64 = img.base64.startsWith('data:image/') ? img.base64.split(',')[1] : img.base64;
                // Normalizar mimeType se fornecido
                if (img.mimeType) {
                    const mimeLower = img.mimeType.toLowerCase();
                    if (mimeLower === 'jpeg' || mimeLower === 'jpg' || mimeLower === 'image/jpeg') {
                        mimeType = 'image/jpeg';
                    } else if (mimeLower === 'png' || mimeLower === 'image/png') {
                        mimeType = 'image/png';
                    } else if (mimeLower === 'gif' || mimeLower === 'image/gif') {
                        mimeType = 'image/gif';
                    } else if (mimeLower === 'webp' || mimeLower === 'image/webp') {
                        mimeType = 'image/webp';
                    } else {
                        mimeType = 'image/jpeg';
                    }
                } else {
                    mimeType = 'image/jpeg';
                }
            }
            
            if (base64 && mimeType) {
                content.push({
                    type: "image",
                    source: {
                        type: "base64",
                        media_type: mimeType,
                        data: base64
                    }
                });
            }
        }
    }
    
    // Sempre adicionar o texto por √∫ltimo
    content.push({ type: "text", text: prompt });

    // Detectar se √© pedido de roteiro (texto puro) ou JSON
    const isScriptRequest = typeof prompt === 'string' && (
        prompt.includes('RESPOSTA FINAL - CR√çTICO') ||
        prompt.includes('roteiro em TEXTO SIMPLES') ||
        prompt.includes('N√ÉO use JSON')
    );

    const payload = {
        model: modelName,
        system: isScriptRequest 
            ? "Voc√™ √© um roteirista profissional. Responda APENAS com o texto do roteiro, sem usar JSON, objetos ou formata√ß√µes especiais. Escreva texto corrido e natural."
            : "Responda APENAS com o objeto JSON solicitado, come√ßando com { e terminando com }.",
        messages: [{ role: "user", content: content }],
        temperature: 0.7,
        max_tokens: 32000,  // Aumentar para permitir gerar muitas cenas (31 cenas x ~1000 chars = ~31000 tokens)
    };

    try {
        // Timeout de 120 segundos para evitar travamentos
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 120000);

        const response = await fetch(CLAUDE_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify(payload),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        const result = await response.json();
        
        // Log para debug (s√≥ primeiros 500 caracteres)
        if (isScriptRequest && result.content) {
            console.log('[Claude API] Resposta para roteiro (preview):', JSON.stringify(result).substring(0, 500));
        }

        if (!response.ok) {
            console.error('Erro da API Claude:', result);
            console.error(`[Claude API] Modelo tentado: ${modelName} (original: ${model})`);
            if (result.error?.type === 'authentication_error') {
                 throw new Error(`A sua Chave de API do Claude √© inv√°lvida.`);
            }
            // Mensagem de erro mais detalhada
            const errorMsg = result.error?.message || response.statusText;
            if (errorMsg.includes('model') || errorMsg.includes('invalid') || errorMsg.includes('not found') || errorMsg.includes('does not exist')) {
                // Tentar fallback autom√°tico com os modelos v√°lidos mais recentes
    const validModels = ['claude-3-7-sonnet-20250219', 'claude-sonnet-4-20250514', 'claude-opus-4-20250514'];
                
                // Tentar outros modelos v√°lidos se o atual falhou
                for (const altModel of validModels) {
                    if (altModel === modelName) continue; // Pular o modelo que j√° falhou
                    
                    try {
                        console.log(`[Claude API] Tentando modelo alternativo: ${altModel}`);
                        const fallbackPayload = { ...payload, model: altModel };
                        const fallbackResponse = await fetch(CLAUDE_API_URL, {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json',
                                'x-api-key': apiKey,
                                'anthropic-version': '2023-06-01'
                            },
                            body: JSON.stringify(fallbackPayload)
                        });
                        const fallbackResult = await fallbackResponse.json();
                        
                        if (fallbackResponse.ok && fallbackResult.content && fallbackResult.content[0] && fallbackResult.content[0].text) {
                            console.log(`[Claude API] Sucesso com modelo alternativo: ${altModel}`);
                            return { titles: fallbackResult.content[0].text, model: model };
                        }
                    } catch (fallbackErr) {
                        console.warn(`[Claude API] Fallback ${altModel} falhou:`, fallbackErr.message);
                        continue;
                    }
                }
                
                // Se todos os modelos v√°lidos falharem, mostrar erro
                throw new Error(`Modelo Claude inv√°lido ou n√£o dispon√≠vel: ${modelName}. Use um destes modelos v√°lidos: ${validModels.join(', ')}. Erro da API: ${errorMsg}`);
            }
            throw new Error(`Erro da API Claude: ${errorMsg}`);
        }
        if (result.content && result.content[0] && result.content[0].text) {
            return { titles: result.content[0].text, model: model };
        } else {
            throw new Error('A resposta da IA (Claude) retornou vazia.');
        }
    } catch (error) {
        // Tratamento espec√≠fico para timeout
        if (error.name === 'AbortError') {
            const timeoutSeconds = (customTimeout || 120000) / 1000;
            console.error(`[Claude API] ‚è∞ Timeout ap√≥s ${timeoutSeconds} segundos`);
            throw new Error(`A API do Claude demorou muito para responder (timeout ap√≥s ${timeoutSeconds}s). Tente novamente com um roteiro mais curto ou use outro modelo.`);
        }
        console.error('Falha ao chamar a API do Claude:', error);
        throw error;
    }
}

// Fun√ß√£o para remover repeti√ß√µes de frases/par√°grafos
function removeRepetitions(text) {
    if (!text) return text;
    
    const sentences = text.split(/[.!?]\s+/);
    const uniqueSentences = [];
    const seenSentences = new Set();
    
    for (const sentence of sentences) {
        const normalized = sentence.trim().toLowerCase().replace(/\s+/g, ' ');
        if (normalized.length > 20 && !seenSentences.has(normalized)) {
            uniqueSentences.push(sentence.trim());
            seenSentences.add(normalized);
        } else if (normalized.length <= 20) {
            uniqueSentences.push(sentence.trim());
        }
    }
    
    return uniqueSentences.join('. ') + '.';
}

/**
 * Remove marca√ß√µes de roteiro (m√∫sica, visual, narrador, etc.) deixando apenas texto para voice over
 * @param {string} script - Texto do roteiro com marca√ß√µes
 * @returns {string} - Roteiro limpo apenas com texto para narra√ß√£o
 */
function cleanScriptForVoiceOver(script) {
    if (!script || typeof script !== 'string') return script;
    
    let cleaned = script;
    
    // Remover marca√ß√µes de PARTE X com intervalos de tempo (mais agressivo)
    cleaned = cleaned.replace(/PARTE\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gi, ''); // Remove linha inteira com "PARTE 1 0:00 - 3:00"
    cleaned = cleaned.replace(/Parte\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gi, ''); // Remove linha inteira com "Parte 1 0:00 - 3:00"
    cleaned = cleaned.replace(/PARTE\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}/gi, ''); // Remove "PARTE 1 0:00 - 3:00" (sem quebra de linha)
    cleaned = cleaned.replace(/Parte\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}/gi, ''); // Remove "Parte 1 0:00 - 3:00" (sem quebra de linha)
    cleaned = cleaned.replace(/PARTE\s+\d+.*?(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})/gi, ''); // Remove "PARTE 1 0:00 - 3:00" (qualquer varia√ß√£o)
    cleaned = cleaned.replace(/Parte\s+\d+.*?(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})/gi, ''); // Remove "Parte 1 0:00 - 3:00" (qualquer varia√ß√£o)
    cleaned = cleaned.replace(/^\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gmi, ''); // Remove linha que come√ßa com "0:00 - 3:00"
    cleaned = cleaned.replace(/^\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}\s*/gmi, ''); // Remove "0:00 - 3:00" no in√≠cio da linha (sem quebra)
    cleaned = cleaned.replace(/PARTE\s+\d+\s*$/gmi, ''); // Remove "PARTE 1" sozinho no final da linha
    cleaned = cleaned.replace(/Parte\s+\d+\s*$/gmi, ''); // Remove "Parte 1" sozinho no final da linha
    
    // Remover marca√ß√µes de m√∫sica e sons entre par√™nteses
    cleaned = cleaned.replace(/\([^)]*[Mm]√∫sica[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([^)]*[Ss]om[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([^)]*[Aa]udio[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([^)]*[Tt]ela[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([^)]*[Cc]√¢mera[^)]*\)/gi, '');
    
    // Remover marca√ß√µes de visual entre par√™nteses
    cleaned = cleaned.replace(/\([Vv]isual[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Vv]isualiza√ß√£o[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Ii]magem[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Aa]nima√ß√£o[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Cc]ena[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Mm]apa[^)]*\)/gi, '');
    cleaned = cleaned.replace(/\([Rr]eencena√ß√£o[^)]*\)/gi, '');
    
    // Remover marca√ß√µes gen√©ricas entre par√™nteses que come√ßam com mai√∫scula (geralmente s√£o dire√ß√µes)
    cleaned = cleaned.replace(/\([A-Z][^)]*\)/g, '');
    
    // Remover prefixos de narrador/personagem
    cleaned = cleaned.replace(/^NARRADOR:\s*/gmi, '');
    cleaned = cleaned.replace(/^NARRATOR:\s*/gmi, '');
    cleaned = cleaned.replace(/^VOZ:\s*/gmi, '');
    cleaned = cleaned.replace(/^VOICE:\s*/gmi, '');
    cleaned = cleaned.replace(/^[A-Z√Å√â√ç√ì√ö√Ä√à√å√í√ô√Ç√ä√é√î√õ√É√ï√á]+:\s*/gm, ''); // Remove qualquer palavra em mai√∫sculas seguida de dois pontos no in√≠cio da linha
    
    // Remover linhas que s√£o apenas dire√ß√µes ou marca√ß√µes
    cleaned = cleaned.split('\n')
        .map(line => {
            const trimmed = line.trim();
            // Remover linhas que s√£o apenas par√™nteses vazios ou com conte√∫do de dire√ß√£o
            if (trimmed.match(/^\([^)]*\)\s*$/)) return '';
            // Remover linhas muito curtas que s√£o provavelmente marca√ß√µes
            if (trimmed.length < 3 && trimmed.match(/^[A-Z\s]+$/)) return '';
            return line;
        })
        .filter(line => line.trim().length > 0)
        .join('\n');
    
    // Limpar m√∫ltiplas quebras de linha
    cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
    
    // Limpar espa√ßos extras
    cleaned = cleaned.replace(/[ \t]+/g, ' ');
    cleaned = cleaned.replace(/\s+\n/g, '\n');
    cleaned = cleaned.replace(/\n\s+/g, '\n');
    
    // Remover espa√ßos no in√≠cio e fim
    cleaned = cleaned.trim();
    
    return cleaned;
}

function extractTextFromAIResponse(response) {
    if (response === null || response === undefined) {
        console.warn('[extractTextFromAIResponse] Response is null or undefined');
        return '';
    }
    
    // Se for string, retornar diretamente
    if (typeof response === 'string') {
        return response;
    }
    
    // Se for array, processar recursivamente
    if (Array.isArray(response)) {
        return response
            .map(item => extractTextFromAIResponse(item))
            .filter(Boolean)
            .join('\n');
    }
    
    // Se for objeto, tentar extrair de v√°rias formas
    if (typeof response === 'object') {
        // PRIORIDADE 1: Claude retorna content como array de objetos com text
        if (response.content && Array.isArray(response.content)) {
            const extracted = response.content
                .map(item => {
                    if (typeof item === 'string') return item;
                    if (typeof item.text === 'string') return item.text;
                    if (typeof item.content === 'string') return item.content;
                    return '';
                })
                .filter(Boolean)
                .join('\n');
            
            if (extracted.trim().length > 0) {
                console.log('[extractTextFromAIResponse] ‚úÖ Extracted from content array (Claude format)');
                return extracted;
            }
        }
        
        // PRIORIDADE 2: Campos espec√≠ficos de roteiro (evitar "titles")
        const scriptFields = [
            'script',      // Roteiros
            'roteiro',     // Roteiro em PT
            'text',        // Campo gen√©rico de texto
            'output_text', // Sa√≠da de texto
            'message',     // Mensagem
            'response',    // Resposta gen√©rica
            'result'       // Resultado
        ];
        
        for (const field of scriptFields) {
            if (typeof response[field] === 'string' && response[field].trim().length > 0) {
                console.log(`[extractTextFromAIResponse] ‚úÖ Extracted from field: ${field}`);
                return response[field];
            }
        }
        
        // PRIORIDADE 3: Campo "content" como string (Gemini)
        if (typeof response.content === 'string' && response.content.trim().length > 0) {
            console.log('[extractTextFromAIResponse] ‚úÖ Extracted from content string');
            return response.content;
        }
        
        // √öLTIMO RECURSO: "titles" (s√≥ se nada mais funcionar e tiver conte√∫do real)
        if (typeof response.titles === 'string') {
            const trimmedTitles = response.titles.trim();
            // Verificar se tem conte√∫do real (n√£o apenas espa√ßos/tabs/newlines)
            const hasRealContent = trimmedTitles.length > 50 && /[a-zA-Z0-9]{10,}/.test(trimmedTitles);
            if (hasRealContent) {
                console.warn('[extractTextFromAIResponse] ‚ö†Ô∏è Using "titles" field as fallback - this might be wrong for scripts!');
                return trimmedTitles;
            } else if (trimmedTitles.length > 0) {
                console.error(`[extractTextFromAIResponse] ‚ùå "titles" field has only whitespace (${trimmedTitles.length} chars): "${trimmedTitles.substring(0, 100)}"`);
            }
        }
        
        // Log completo do objeto para debug
        console.error('[extractTextFromAIResponse] ‚ùå N√£o encontrou texto em nenhum campo conhecido!');
        console.error('[extractTextFromAIResponse] Campos dispon√≠veis:', Object.keys(response));
        console.error('[extractTextFromAIResponse] Objeto completo (primeiros 500 chars):', JSON.stringify(response).substring(0, 500));
        
        // Tentar JSON.stringify como √∫ltimo recurso (provavelmente vai falhar)
        try {
            const stringified = JSON.stringify(response);
            console.warn('[extractTextFromAIResponse] ‚ö†Ô∏è Had to stringify entire object:', stringified.substring(0, 200) + '...');
            return stringified;
        } catch {
            console.error('[extractTextFromAIResponse] ‚ùå Failed to stringify object');
            return String(response);
        }
    }
    
    console.warn('[extractTextFromAIResponse] ‚ö†Ô∏è Falling back to String conversion');
    return String(response);
}

function parseScenePromptsResponse(response) {
    let rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);

    if (!rawResponse || rawResponse.length === 0) {
        throw new Error('A resposta da IA veio vazia.');
    }

    console.log('[Scene Prompts Parser] Pr√©-processando resposta...');
    rawResponse = rawResponse
        .replace(/^```json\s*/i, '')
        .replace(/^```\s*/i, '')
        .replace(/\s*```\s*$/i, '')
        .trim();

    const sanitizeSceneArray = (scenes) => {
        if (!Array.isArray(scenes)) return [];
        return scenes
            .filter(scene => scene && (scene.prompt_text || scene.prompt || scene.text))
            .map((scene, index) => ({
                scene_number: scene.scene_number || scene.number || index + 1,
                scene_description: scene.scene_description || scene.description || `Cena ${scene.scene_number || scene.number || index + 1}`,
                prompt_text: scene.prompt_text || scene.prompt || scene.text || ''
            }));
    };

    const tryParseJson = (text) => {
        try {
            return JSON.parse(text);
        } catch {
            return null;
        }
    };

    let parsed = tryParseJson(rawResponse);
    if (parsed && parsed.scenes) {
        const scenes = sanitizeSceneArray(parsed.scenes);
        if (scenes.length > 0) return scenes;
    } else if (parsed && Array.isArray(parsed)) {
        const scenes = sanitizeSceneArray(parsed);
        if (scenes.length > 0) return scenes;
    }

    const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
        const cleaned = jsonMatch[0]
            .replace(/```json\s*/gi, '')
            .replace(/```\s*/g, '')
            .replace(/^[^{]*/, '')
            .replace(/[^}]*$/, '');

        parsed = tryParseJson(cleaned);
        if (parsed && parsed.scenes) {
            const scenes = sanitizeSceneArray(parsed.scenes);
            if (scenes.length > 0) return scenes;
        }
    }

    const scenesArrayMatch = rawResponse.match(/"scenes"\s*:\s*\[([\s\S]*?)\]/);
    if (scenesArrayMatch) {
        let scenesArrayStr = scenesArrayMatch[1];
        if (!scenesArrayStr.trim().endsWith('}')) {
            const sceneObjects = scenesArrayStr.match(/\{[^{}]*\}/g);
            if (sceneObjects && sceneObjects.length > 0) {
                scenesArrayStr = sceneObjects.join(',\n');
            }
        }

        const fallbackJson = tryParseJson(`{"scenes":[${scenesArrayStr}]}`);
        if (fallbackJson && fallbackJson.scenes) {
            const scenes = sanitizeSceneArray(fallbackJson.scenes);
            if (scenes.length > 0) return scenes;
        }
    }

    const scenePattern = /\{\s*"scene_number"\s*:\s*(\d+)[\s\S]*?"scene_description"\s*:\s*"([^"]*)"[\s\S]*?"prompt_text"\s*:\s*"([^"]*)"[\s\S]*?\}/g;
    const regexScenes = [];
    let match;
    while ((match = scenePattern.exec(rawResponse)) !== null) {
        regexScenes.push({
            scene_number: parseInt(match[1]),
            scene_description: match[2],
            prompt_text: match[3]
        });
    }
    if (regexScenes.length > 0) {
        console.log(`[Scene Prompts Parser] ‚úÖ Extra√≠das ${regexScenes.length} cenas via regex padr√£o!`);
        return regexScenes;
    }

    const simpleScenePattern = /\{\s*"scene_number"\s*:\s*\d+[\s\S]*?\}/g;
    const simpleMatches = rawResponse.match(simpleScenePattern);
    if (simpleMatches && simpleMatches.length > 0) {
        const parsedScenes = [];
        simpleMatches.forEach((sceneStr, index) => {
            const sceneObject = tryParseJson(sceneStr);
            if (sceneObject && (sceneObject.prompt_text || sceneObject.prompt || sceneObject.text)) {
                parsedScenes.push({
                    scene_number: sceneObject.scene_number || sceneObject.number || index + 1,
                    scene_description: sceneObject.scene_description || sceneObject.description || `Cena ${sceneObject.scene_number || sceneObject.number || index + 1}`,
                    prompt_text: sceneObject.prompt_text || sceneObject.prompt || sceneObject.text || ''
                });
            }
        });
        if (parsedScenes.length > 0) {
            console.log(`[Scene Prompts Parser] ‚úÖ Extra√≠das ${parsedScenes.length} cenas via fallback simples!`);
            return parsedScenes;
        }
    }

    throw new Error(`N√£o foi poss√≠vel interpretar a resposta da IA como JSON v√°lido. Conte√∫do analisado (primeiros 500 chars): ${rawResponse.substring(0, 500)}`);
}

function buildScenePromptText({
    script,
    targetScenes,
    minScenes,
    maxScenes,
    wordCount,
    styleInstruction = '',
    imageModelInstruction = '',
    charactersInstruction = '',
    startSceneNumber = 1,
    isContinuation = false,
    previousScenes = []
}) {
    const previousSummary = previousScenes && previousScenes.length > 0
        ? `CENAS J√Å GERADAS (n√£o repita):\n${previousScenes.slice(-5).map(scene => `- Cena ${scene.scene_number}: ${scene.scene_description}`).join('\n')}\n\n`
        : '';

    const continuationInstruction = isContinuation
        ? `Voc√™ j√° gerou ${startSceneNumber - 1} cenas. Continue a numera√ß√£o a partir da cena ${startSceneNumber} e gere EXATAMENTE ${targetScenes} novas cenas sem repetir ou alterar as anteriores.\n`
        : `Divida o roteiro em aproximadamente ${targetScenes} cenas (entre ${minScenes} e ${maxScenes} cenas, se necess√°rio).\n`;

    return `Voc√™ √© um especialista em cria√ß√£o de prompts para gera√ß√£o de imagens usando IA.

${previousSummary}${continuationInstruction}
REGRAS IMPORTANTES:
1. Cada prompt deve ter entre 600-1200 caracteres.
2. Cada prompt deve ser em INGL√äS e otimizado para gera√ß√£o de imagens.
3. Seja espec√≠fico e detalhado: descreva composi√ß√£o, ilumina√ß√£o, cores, atmosfera, personagens, cen√°rio.
4. Use termos t√©cnicos de fotografia/cinematografia quando apropriado.${styleInstruction}${imageModelInstruction}${charactersInstruction ? `\n${charactersInstruction}` : ''}
5. Os prompts devem ser fotoreal√≠sticos e cinematogr√°ficos, a menos que especificado outro estilo.
6. Se j√° existem cenas anteriores, continue a hist√≥ria sem repetir.

ROTEIRO:
"""
${script}
"""

FORMATO DE RESPOSTA (JSON):
{
  "scenes": [
    {
      "scene_number": ${startSceneNumber},
      "scene_description": "Breve descri√ß√£o da cena em portugu√™s",
      "prompt_text": "Prompt detalhado em ingl√™s para gera√ß√£o de imagem"
    },
    ...
  ]
}

IMPORTANTE:
- Retorne APENAS o JSON, sem texto adicional.
- Gere EXATAMENTE ${targetScenes} novas cenas come√ßando em ${startSceneNumber}.
- Continue a hist√≥ria exatamente do ponto onde parou, sem reiniciar a narrativa.
- N√£o repita cenas anteriores.`;
}

async function generateScenesWithRetries({
    apiFunc,
    apiKey,
    model,
    script,
    styleInstruction,
    imageModelInstruction,
    charactersInstruction,
    estimatedScenes,
    minScenes,
    maxScenes,
    wordCount,
    serviceLabel = 'AI',
    maxAttempts = 4
}) {
    let allScenes = [];
    let attempt = 0;
    let startSceneNumber = 1;
    let remainingScenes = estimatedScenes;

    while (remainingScenes > 0 && attempt < maxAttempts) {
        const targetScenes = remainingScenes;
        const prompt = buildScenePromptText({
            script,
            targetScenes,
            minScenes: Math.max(1, Math.min(minScenes, targetScenes)),
            maxScenes: Math.max(targetScenes, Math.min(maxScenes, targetScenes + 2)),
            wordCount,
            styleInstruction,
            imageModelInstruction,
            charactersInstruction,
            startSceneNumber,
            isContinuation: attempt > 0,
            previousScenes: allScenes
        });

        console.log(`[Scene Prompts][${serviceLabel}] Tentativa ${attempt + 1}: solicitando ${targetScenes} cenas (iniciando na cena ${startSceneNumber})`);

        const response = await apiFunc(prompt, apiKey, model);
        const parsedScenes = parseScenePromptsResponse(response);

        if (!parsedScenes || parsedScenes.length === 0) {
            console.warn(`[Scene Prompts][${serviceLabel}] Nenhuma cena retornada nesta tentativa.`);
            attempt++;
            continue;
        }

        const normalizedScenes = parsedScenes
            .map((scene, idx) => {
                const promptText = scene.prompt_text || scene.prompt || scene.text || '';
                if (!promptText.trim()) return null;
                return {
                    scene_number: startSceneNumber + idx,
                    scene_description: scene.scene_description || scene.description || `Cena ${startSceneNumber + idx}`,
                    prompt_text: promptText
                };
            })
            .filter(Boolean);

        if (normalizedScenes.length === 0) {
            console.warn(`[Scene Prompts][${serviceLabel}] As cenas retornadas estavam vazias.`);
            attempt++;
            continue;
        }

        allScenes = allScenes.concat(normalizedScenes);
        if (allScenes.length > estimatedScenes) {
            allScenes = allScenes.slice(0, estimatedScenes);
        }

        remainingScenes = estimatedScenes - allScenes.length;
        startSceneNumber = allScenes.length + 1;
        attempt++;
    }

    return allScenes;
}

function parseJSONFromString(text) {
    if (!text) return null;
    let cleaned = text.trim();
    cleaned = cleaned.replace(/^```json/i, '').replace(/^```/, '').replace(/```$/g, '').trim();
    
    try {
        return JSON.parse(cleaned);
    } catch (err) {
        const match = cleaned.match(/\{[\s\S]*\}/);
        if (match) {
            try {
                return JSON.parse(match[0]);
            } catch (innerErr) {
                return null;
            }
        }
        return null;
    }
}

/**
 * Chama a API do provedor externo
 */
async function callLaozhangAPI(prompt, apiKey, model = null, imageUrl = null, userId = null, operationType = 'api_call', details = null) {
    if (!apiKey) throw new Error("Chave de API do provedor externo n√£o configurada.");
    
    // Endpoint oficial documentado (compat√≠vel com OpenAI)
    const possibleEndpoints = [LAOZHANG_CHAT_ENDPOINT];
    
    // Detectar se √© pedido de roteiro (texto puro) ou JSON
    const isScriptRequest = typeof prompt === 'string' && (
        prompt.includes('RESPOSTA FINAL - CR√çTICO') ||
        prompt.includes('roteiro em TEXTO SIMPLES') ||
        prompt.includes('N√ÉO use JSON')
    );
    
    // Calcular tokens aproximados (input + output estimado)
    const promptTokens = Math.ceil((typeof prompt === 'string' ? prompt.length : JSON.stringify(prompt).length) / 4);
    // Para roteiros longos, estimar mais tokens de sa√≠da baseado no n√∫mero de partes
    let estimatedOutputTokens = 2000; // Estimativa conservadora padr√£o
    if (isScriptRequest) {
        if (prompt.includes('partes')) {
            const partsMatch = prompt.match(/dividido em.*?(\d+).*?partes/i) || prompt.match(/EXATAMENTE (\d+) PARTES/i);
            const numParts = partsMatch ? parseInt(partsMatch[1]) : 1;
            // Estimativa: ~450 palavras por parte √ó 1.3 tokens por palavra √ó n√∫mero de partes
            estimatedOutputTokens = Math.min(12000, Math.ceil(450 * 1.3 * numParts)); // M√°ximo 12000 tokens
            console.log(`[API] Estimativa de tokens de sa√≠da para ${numParts} partes: ${estimatedOutputTokens}`);
        } else if (operationType && operationType.includes('viral_agent')) {
            // Para agentes virais, estimar tokens baseado no max_tokens (geralmente 8192)
            // Usar 80% do max_tokens como estimativa conservadora
            estimatedOutputTokens = 6554; // ~80% de 8192
            console.log(`[API] Estimativa de tokens para agente viral: ${estimatedOutputTokens}`);
        }
    }
    const totalTokens = promptTokens + estimatedOutputTokens;
    
    // Debitar cr√©ditos ANTES da chamada se userId fornecido
    // IMPORTANTE: Esta fun√ß√£o s√≥ deve ser chamada quando realmente deve usar cr√©ditos
    // A verifica√ß√£o de prefer√™ncia j√° foi feita em getPreferredAIProvider
    let creditDebitResult = null;
    if (userId) {
        try {
            // Verificar novamente se realmente deve usar cr√©ditos (double-check)
            const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
            if (!creditsCheck.shouldUse) {
                console.warn('[callLaozhangAPI] ‚ö†Ô∏è Esta fun√ß√£o foi chamada mas usu√°rio n√£o deve usar cr√©ditos. Verifique a l√≥gica em getPreferredAIProvider.');
                throw new Error('Usu√°rio n√£o deve usar cr√©ditos. Use API pr√≥pria.');
            }
            
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (laozhangProviderId) {
                creditDebitResult = await checkAndDebitCredits(
                    userId,
                    laozhangProviderId,
                    totalTokens,
                    operationType,
                    details || JSON.stringify({ model: modelToUse || model || 'gpt-4o', service: 'laozhang' })
                );
                console.log(`[API] üí∞ Cr√©ditos debitados: ${creditDebitResult.creditsUsed.toFixed(4)}, Novo saldo: ${creditDebitResult.newBalance.toFixed(4)}`);
            }
        } catch (creditError) {
            console.error('[API] ‚ùå Erro ao debitar cr√©ditos:', creditError.message);
            // Se n√£o tiver cr√©ditos suficientes, lan√ßar erro
            if (creditError.message.includes('Cr√©ditos insuficientes')) {
                throw creditError;
            }
            // Se for outro erro, continuar mas logar
        }
    }
    
    // Se modelo n√£o fornecido, usar 'gpt-4o' apenas como √∫ltimo recurso
    // Mas preferir extrair do details se dispon√≠vel
    let modelToUse = model;
    if (!modelToUse && details) {
        try {
            const detailsObj = typeof details === 'string' ? JSON.parse(details) : details;
            modelToUse = detailsObj?.model || detailsObj?.selectedModel;
        } catch (e) {
            // Ignorar erro de parsing
        }
    }
    // √öltimo fallback: usar 'gpt-4o' apenas se realmente n√£o houver modelo
    modelToUse = modelToUse || 'gpt-4o';
    
    // Log do modelo que ser√° usado na API
    console.log(`[callLaozhangAPI] üéØ Enviando requisi√ß√£o para API com modelo: "${modelToUse}"`);
    
    const payload = {
        model: modelToUse,
        messages: [
            {
                role: 'system',
                content: isScriptRequest 
                    ? "Voc√™ √© um roteirista profissional. Responda APENAS com o texto do roteiro, sem usar JSON, objetos ou formata√ß√µes especiais. Escreva texto corrido e natural."
                    : "Responda APENAS com o objeto JSON solicitado, come√ßando com { e terminando com }."
            },
            {
                role: 'user',
                content: prompt
            }
        ],
        temperature: 0.7,
        max_tokens: isScriptRequest ? 16384 : 16384  // Usar 16384 tokens (limite seguro da API Laozhang)
    };
    
    // Tentar diferentes endpoints at√© encontrar um que funcione
    let lastError = null;
    for (const endpoint of possibleEndpoints) {
        try {
            console.log(`[API] Tentando endpoint: ${endpoint}`);
            const controller = new AbortController();
            // Timeout din√¢mico baseado no tipo de requisi√ß√£o: roteiros longos precisam de mais tempo
            // Para roteiros: 10 minutos base + 1 minuto por parte (m√≠nimo 5 minutos, m√°ximo 20 minutos)
            const isLongScript = isScriptRequest && prompt.includes('partes');
            // Aumentar timeout padr√£o para 5 minutos (300000ms) para dar mais tempo √† API
            let timeoutDuration = 300000; // 5 minutos padr√£o (aumentado de 3 minutos)
            
            // Detectar se √© requisi√ß√£o de scene prompts ou outras opera√ß√µes que podem demorar
            const isScenePrompts = operationType && operationType.includes('scene-prompts');
            const isViralAgent = operationType && operationType.includes('viral_agent');
            
            if (isLongScript) {
                // Tentar extrair n√∫mero de partes do prompt
                const partsMatch = prompt.match(/dividido em.*?(\d+).*?partes/i) || prompt.match(/EXATAMENTE (\d+) PARTES/i);
                const numParts = partsMatch ? parseInt(partsMatch[1]) : 1;
                timeoutDuration = Math.min(1200000, Math.max(300000, 600000 + (numParts * 60000))); // 5-20 minutos
                console.log(`[API] Timeout ajustado para ${timeoutDuration / 1000 / 60} minutos (${numParts} partes)`);
            } else if (isScenePrompts || isViralAgent || isScriptRequest) {
                // Para scene prompts, tentar extrair n√∫mero de cenas do metadata (details)
                let timeoutForScenes = 480000; // 8 minutos padr√£o
                const operationMetadata = details; // Usar details como operationMetadata
                if (isScenePrompts && operationMetadata) {
                    try {
                        const metadata = typeof operationMetadata === 'string' ? JSON.parse(operationMetadata) : operationMetadata;
                        if (metadata.estimatedScenes || metadata.timeout) {
                            // Se o metadata j√° tem timeout calculado, usar ele
                            timeoutForScenes = metadata.timeout || timeoutForScenes;
                            // Ou calcular baseado no n√∫mero de cenas
                            if (metadata.estimatedScenes && !metadata.timeout) {
                                const baseTimeout = 300000; // 5 minutos
                                const timeoutPerScene = 2000; // 2 segundos por cena
                                const baseScenes = 20;
                                const calculatedTimeout = baseTimeout + (Math.max(0, metadata.estimatedScenes - baseScenes) * timeoutPerScene);
                                timeoutForScenes = Math.min(1200000, Math.max(300000, calculatedTimeout));
                            }
                            console.log(`[API] Timeout calculado dinamicamente: ${timeoutForScenes/1000}s para ${metadata.estimatedScenes || 'N/A'} cenas`);
                        }
                    } catch (e) {
                        console.warn(`[API] Erro ao parsear metadata: ${e.message}`);
                        // Se n√£o conseguir parsear, usar padr√£o
                    }
                }
                timeoutDuration = timeoutForScenes;
                console.log(`[API] Timeout ajustado para ${timeoutDuration / 1000 / 60} minutos (${isScenePrompts ? 'scene prompts' : isViralAgent ? 'agente viral' : 'roteiro'})`);
            }
            const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);
            
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'Accept': 'application/json'
                },
                body: JSON.stringify(payload),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                const errorText = await response.text().catch(() => response.statusText);
                console.warn(`[API] Endpoint ${endpoint} retornou erro ${response.status}:`, errorText.substring(0, 500));
                
                // Tentar parsear o erro JSON para mais detalhes
                let errorDetails = errorText;
                try {
                    const errorJson = JSON.parse(errorText);
                    if (errorJson.error) {
                        errorDetails = JSON.stringify(errorJson.error);
                        console.error(`[API] Detalhes do erro:`, errorJson.error);
                    }
                } catch (e) {
                    // N√£o √© JSON, usar texto direto
                }
                
                lastError = new Error(`Erro ${response.status}: ${errorDetails.substring(0, 200)}`);
                continue; // Tentar pr√≥ximo endpoint
            }
            
            const result = await response.json();
            console.log(`[API] ‚úÖ Sucesso com endpoint: ${endpoint}`);
            console.log('[API] Estrutura da resposta:', JSON.stringify(result).substring(0, 300));
            
            // Se tiver informa√ß√µes de uso de tokens na resposta, ajustar cr√©ditos
            if (userId && creditDebitResult && result.usage) {
                const actualTokens = (result.usage.prompt_tokens || promptTokens) + (result.usage.completion_tokens || estimatedOutputTokens);
                const actualCredits = (actualTokens / 1000) * (creditDebitResult.creditsUsed / (totalTokens / 1000));
                const difference = actualCredits - creditDebitResult.creditsUsed;
                
                if (Math.abs(difference) > 0.01) { // Ajustar apenas se diferen√ßa > 0.01 cr√©ditos
                    try {
                        const laozhangProviderId = await getLaozhangApiProviderId();
                        if (laozhangProviderId) {
                            // Ajustar saldo do usu√°rio
                            await db.run(`
                                UPDATE user_credits 
                                SET balance = balance + ?, updated_at = CURRENT_TIMESTAMP 
                                WHERE user_id = ?
                            `, [creditDebitResult.creditsUsed - actualCredits, userId]);
                            
                            // Atualizar registro de uso
                            await db.run(`
                                UPDATE credit_usage 
                                SET credits_used = ?, units_consumed = ?
                                WHERE id = (SELECT id FROM credit_usage WHERE user_id = ? AND api_provider_id = ? ORDER BY id DESC LIMIT 1)
                            `, [actualCredits, actualTokens, userId, laozhangProviderId]);
                            
                            console.log(`[API] üí∞ Cr√©ditos ajustados: ${difference > 0 ? '+' : ''}${difference.toFixed(4)}`);
                        }
                    } catch (adjustError) {
                        console.error('[API] ‚ö†Ô∏è Erro ao ajustar cr√©ditos:', adjustError.message);
                    }
                }
            }
            
            if (result.choices && result.choices[0] && result.choices[0].message) {
                const content = result.choices[0].message.content;
                
                console.log('[API] Resposta recebida (primeiros 200 chars):', content.substring(0, 200));
                
                if (isScriptRequest) {
                    console.log('[API] Retornando texto puro de script');
                    return content; // Retorna string diretamente
                } else {
                    // Para requisi√ß√µes JSON, retornar o conte√∫do diretamente
                    return content;
                }
            } else if (result.content) {
                // Algumas APIs retornam content diretamente
                const content = typeof result.content === 'string' ? result.content : JSON.stringify(result.content);
                console.log('[API] Resposta recebida (formato alternativo)');
                return content;
            } else {
                console.warn(`[API] Estrutura de resposta inesperada em ${endpoint}:`, JSON.stringify(result).substring(0, 500));
                lastError = new Error('Estrutura de resposta inesperada');
                continue; // Tentar pr√≥ximo endpoint
            }
        } catch (error) {
            // Se a chamada falhou e j√° debitamos cr√©ditos, reembolsar
            if (userId && creditDebitResult) {
                try {
                    await refundCredits(userId, creditDebitResult.creditsUsed, 'Erro ao processar solicita√ß√£o');
                    console.log(`[API] üí∞ Cr√©ditos reembolsados: ${creditDebitResult.creditsUsed.toFixed(4)}`);
                } catch (refundError) {
                    console.error('[API] ‚ö†Ô∏è Erro ao reembolsar cr√©ditos:', refundError.message);
                }
            }
            
            // Tratar erros de abort (timeout)
            if (error.name === 'AbortError') {
                console.error(`[API] ‚è±Ô∏è Timeout ap√≥s ${timeoutDuration / 1000 / 60} minutos ao tentar endpoint ${endpoint}`);
                lastError = new Error(`Timeout: A requisi√ß√£o demorou mais de ${timeoutDuration / 1000 / 60} minutos. Tente novamente ou use uma requisi√ß√£o menor.`);
                // Se n√£o for o √∫ltimo endpoint, tentar pr√≥ximo
                if (endpoint !== possibleEndpoints[possibleEndpoints.length - 1]) {
                    console.warn(`[API] Tentando pr√≥ximo endpoint...`);
                    continue;
                }
                break; // Se for o √∫ltimo endpoint, sair do loop
            }
            
            // Tratar outros erros
            console.warn(`[API] Erro ao tentar endpoint ${endpoint}:`, error.message);
            lastError = error;
            // Se n√£o for o √∫ltimo endpoint, tentar pr√≥ximo
            if (endpoint !== possibleEndpoints[possibleEndpoints.length - 1]) {
                continue; // Tentar pr√≥ximo endpoint
            }
        }
    }
    
    // Se chegou aqui, nenhum endpoint funcionou
    console.error('[API] ‚ùå Todos os endpoints falharam');
    throw lastError || new Error('Falha ao chamar a API: nenhum endpoint funcionou');
}

async function getPreferredAIProvider(userId, preferenceOrder = ['claude', 'openai', 'gemini']) {
    const defaultModels = {
        claude: 'claude-3-7-sonnet-20250219',  // Claude 3.7 Sonnet (Fev/2025)
        openai: 'gpt-4o',                       // GPT-4o (2025)
        gemini: 'gemini-2.5-pro',               // Gemini 2.5 Pro (2025)
        laozhang: 'gpt-4o'                      // Laozhang.ai (usa GPT-4o como padr√£o)
    };

    // PRIMEIRO: Verificar se laozhang.ai est√° configurada como padr√£o no admin
    try {
        const laozhangDefaultSetting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
        console.log('[AI Provider] Verificando configura√ß√£o padr√£o:', laozhangDefaultSetting);
        
        let laozhangUseAsDefault = false;
        if (laozhangDefaultSetting) {
            try {
                const parsedValue = JSON.parse(laozhangDefaultSetting.value);
                laozhangUseAsDefault = parsedValue === true || parsedValue === 'true' || parsedValue === 1;
            } catch (e) {
                // Se n√£o for JSON, verificar como string
                laozhangUseAsDefault = laozhangDefaultSetting.value === 'true' || laozhangDefaultSetting.value === '1';
            }
        }
        
        console.log('[AI Provider] laozhangUseAsDefault:', laozhangUseAsDefault);
        
        if (laozhangUseAsDefault) {
            const laozhangKey = await getLaozhangApiKey();
            console.log('[AI Provider] Chave de API encontrada:', laozhangKey ? 'Sim' : 'N√£o');
            if (laozhangKey) {
                console.log('[AI Provider] ‚úÖ Usando API configurada como padr√£o (configura√ß√£o do admin)');
                return {
                    service: 'laozhang',
                    apiKey: laozhangKey,
                    model: defaultModels.laozhang
                };
            } else {
                console.warn('[AI Provider] ‚ö†Ô∏è API configurada como padr√£o mas chave n√£o encontrada');
            }
        } else {
            console.log('[AI Provider] Laozhang.ai n√£o est√° configurada como padr√£o');
        }
    } catch (err) {
        console.error('[AI Provider] ‚ùå Erro ao verificar configura√ß√£o padr√£o Laozhang.ai:', err.message);
    }

    // SEGUNDO: Verificar se deve usar cr√©ditos (laozhang.ai)
    // REGRA: Usa cr√©ditos SOMENTE se usu√°rio marcou prefer√™ncia OU n√£o tem plano que permite API pr√≥pria OU n√£o tem API pr√≥pria configurada
    // REGRA CR√çTICA: Se prefer√™ncia N√ÉO est√° marcada E usu√°rio tem plano que permite E tem API pr√≥pria ‚Üí usar API pr√≥pria SEM verificar cr√©ditos
    try {
        // Primeiro, verificar a prefer√™ncia do usu√°rio
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
        const hasPreference = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // Se a prefer√™ncia N√ÉO est√° marcada, verificar se pode usar API pr√≥pria diretamente
        if (!hasPreference) {
            // Verificar se usu√°rio tem plano que permite usar API pr√≥pria
            let hasPlanPermission = false;
            try {
                const userData = await db.get('SELECT plan, subscription_plan, isAdmin FROM users WHERE id = ?', [userId]);
                if (userData) {
                    // Admin sempre tem permiss√£o
                    if (userData.isAdmin === 1 || userData.isAdmin === true || String(userData.isAdmin) === '1') {
                        hasPlanPermission = true;
                    } else {
                        const planName = userData.subscription_plan || userData.plan || 'plan-free';
                        const permission = await db.get(
                            'SELECT is_allowed FROM plan_permissions WHERE plan_name = ? AND feature_name = ?',
                            [planName, 'api_propria']
                        );
                        hasPlanPermission = permission && permission.is_allowed === 1;
                    }
                }
            } catch (err) {
                console.warn('[AI Provider] Erro ao verificar permiss√£o do plano:', err.message);
            }
            
            // Se tem plano que permite, verificar se tem API pr√≥pria configurada
            if (hasPlanPermission) {
                for (const service of preferenceOrder) {
                    try {
                        const keyData = await db.get(
                            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                            [userId, service]
                        );
                        if (keyData && keyData.api_key) {
                            const decryptedKey = decrypt(keyData.api_key);
                            if (decryptedKey && decryptedKey.trim().length > 0) {
                                console.log(`[AI Provider] ‚úÖ Usando API pr√≥pria (prefer√™ncia n√£o marcada, tem plano e API configurada)`);
                                return {
                                    service,
                                    apiKey: decryptedKey,
                                    model: defaultModels[service] || 'gemini-2.0-flash'
                                };
                            }
                        }
                    } catch (err) {
                        console.warn(`[AI Provider] Erro ao buscar chave ${service}:`, err.message);
                    }
                }
            }
        }
        
        // Se chegou aqui, verificar se deve usar cr√©ditos (prefer√™ncia marcada OU n√£o tem plano OU n√£o tem API)
        const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
        
        if (creditsCheck.shouldUse) {
            // Se deve usar cr√©ditos, usar laozhang.ai
            const laozhangKey = await getLaozhangApiKey();
            if (laozhangKey) {
                console.log(`[AI Provider] ‚úÖ Usando Laozhang.ai (${creditsCheck.reason})`);
                return {
                    service: 'laozhang',
                    apiKey: laozhangKey,
                    model: defaultModels.laozhang
                };
            } else {
                console.warn('[AI Provider] ‚ö†Ô∏è Laozhang.ai n√£o configurada, tentando usar APIs pr√≥prias do usu√°rio');
            }
        } else {
            console.log(`[AI Provider] ‚úÖ Usando API pr√≥pria (${creditsCheck.reason})`);
        }
    } catch (err) {
        console.warn('[AI Provider] Erro ao verificar uso de cr√©ditos:', err.message);
    }

    // TERCEIRO: Se n√£o usar laozhang.ai, usar APIs pr√≥prias do usu√°rio
    for (const service of preferenceOrder) {
        try {
            const keyData = await db.get(
                'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                [userId, service]
            );
            if (keyData) {
                const decryptedKey = decrypt(keyData.api_key);
                if (decryptedKey) {
                    return {
                        service,
                        apiKey: decryptedKey,
                        model: defaultModels[service] || 'gemini-2.0-flash'
                    };
                }
            }
        } catch (err) {
            console.warn(`[AI Provider] Erro ao buscar chave ${service}:`, err.message);
        }
    }
    return null;
}

async function analyzeTranscriptForVirality({ userId, transcript, videoTitle, niche, subniche }) {
    const provider = await getPreferredAIProvider(userId, ['claude', 'openai', 'gemini']);
    if (!provider) {
        throw new Error('Configure uma chave do Claude, OpenAI ou Gemini para gerar a an√°lise do roteiro.');
    }

    const sanitizedTranscript = transcript.trim();
    const truncatedTranscript = sanitizedTranscript.length > 20000
        ? `${sanitizedTranscript.substring(0, 20000)}\n[... conte√∫do truncado para an√°lise ...]`
        : sanitizedTranscript;

    const analysisPrompt = `
Voc√™ √© um ESPECIALISTA EM CRIA√á√ÉO DE CONTE√öDO VIRAL para YouTube, com expertise em an√°lise profunda de roteiros que alcan√ßaram milh√µes de visualiza√ß√µes. Sua miss√£o √© DISSECAR este roteiro viral e criar uma F√ìRMULA COMPLETA que permita gerar roteiros AINDA MAIS VIRAIS que o original, com ALTO PODER DE RETEN√á√ÉO e VIRALIZA√á√ÉO.

OBJETIVO: Entregar uma f√≥rmula viral detalhada que permita ao agente de roteiro criar conte√∫dos 10/10, superando o original em:
- Reten√ß√£o de audi√™ncia (watch time)
- Taxa de engajamento (likes, coment√°rios, compartilhamentos)
- Potencial de viraliza√ß√£o
- Conex√£o emocional com o p√∫blico
- Elementos de suspense e curiosidade

Retorne APENAS um JSON v√°lido no formato:
{
  "resumo": "S√≠ntese detalhada em 3-4 frases explicando a ess√™ncia viral do roteiro",
  "motivosVirais": [
    "Motivo 1 com explica√ß√£o detalhada",
    "Motivo 2 com explica√ß√£o detalhada",
    "..."
  ],
  "gatilhosEmocionais": [
    {
      "gatilho": "Nome do gatilho emocional",
      "intensidade": "alta/m√©dia/baixa",
      "momentoAplicado": "Em qual parte do roteiro aparece",
      "comoIntensificar": "Como tornar ainda mais impactante"
    }
  ],
  "estruturaNarrativa": [
    {
      "etapa": "Nome da etapa",
      "descricao": "Descri√ß√£o detalhada do que acontece",
      "tempoAproximado": "0:00-0:45",
      "elementosVirais": ["elemento 1", "elemento 2"],
      "pontoRetencao": "O que mant√©m o espectador assistindo nesta parte",
      "melhoriasSugeridas": "Como melhorar esta etapa para aumentar reten√ß√£o"
    }
  ],
  "formulaChecklist": [
    {
      "item": "Elemento espec√≠fico da f√≥rmula viral",
      "status": "aplicado" ou "melhorar",
      "porqueFunciona": "Explica√ß√£o cient√≠fica/psicol√≥gica detalhada de POR QUE funciona",
      "comoAplicarNoMeuConteudo": "Diretriz pr√°tica e espec√≠fica para replicar",
      "upgradeSugerido": "Ajuste espec√≠fico para ficar 10/10 e SUPERAR o original",
      "exemploConcreto": "Exemplo pr√°tico de como aplicar"
    }
  ],
  "elementosRetencao": [
    {
      "elemento": "Nome do elemento de reten√ß√£o",
      "comoFunciona": "Explica√ß√£o detalhada",
      "momentoIdeal": "Quando aplicar no roteiro",
      "intensificacao": "Como intensificar para aumentar watch time"
    }
  ],
  "tecnicasViralizacao": [
    {
      "tecnica": "Nome da t√©cnica",
      "descricao": "Como funciona",
      "aplicacao": "Como aplicar no roteiro",
      "potencialViral": "Por que tem potencial de viralizar"
    }
  ],
  "pontosClimaticos": [
    {
      "momento": "Descri√ß√£o do momento clim√°tico",
      "tempoAproximado": "Quando acontece",
      "impactoEmocional": "Qual emo√ß√£o desperta",
      "comoAmplificar": "Como tornar ainda mais impactante"
    }
  ],
  "diferencialProposto": "Diferencial espec√≠fico e acion√°vel para deixar o roteiro AINDA MELHOR que o original, com foco em reten√ß√£o e viraliza√ß√£o",
  "formulaViralCompleta": {
    "introducao": {
      "elementos": ["elemento 1", "elemento 2"],
      "tempoIdeal": "0:00-0:XX",
      "objetivo": "O que deve alcan√ßar",
      "formula": "F√≥rmula espec√≠fica para criar introdu√ß√£o virais"
    },
    "desenvolvimento": {
      "ritmo": "Ritmo ideal (lento/m√©dio/r√°pido)",
      "elementos": ["elemento 1", "elemento 2"],
      "tecnicas": ["t√©cnica 1", "t√©cnica 2"],
      "formula": "F√≥rmula espec√≠fica para manter engajamento"
    },
    "climax": {
      "elementos": ["elemento 1", "elemento 2"],
      "intensidade": "N√≠vel de intensidade necess√°rio",
      "formula": "F√≥rmula espec√≠fica para criar cl√≠max virais"
    },
    "fechamento": {
      "elementos": ["elemento 1", "elemento 2"],
      "cta": "Como fazer CTA eficaz",
      "formula": "F√≥rmula espec√≠fica para fechamento que gera compartilhamentos"
    }
  },
  "sugestoesAplicacao": [
    "A√ß√£o espec√≠fica 1 com detalhes",
    "A√ß√£o espec√≠fica 2 com detalhes",
    "..."
  ],
  "roteiro10por10": {
    "caracteristicas": ["caracter√≠stica 1", "caracter√≠stica 2"],
    "diferenciais": ["diferencial 1", "diferencial 2"],
    "formula": "F√≥rmula completa para criar roteiros 10/10",
    "checklist": ["item 1", "item 2", "item 3"]
  },
  "alertas": [
    "Poss√≠veis riscos ou pontos de aten√ß√£o espec√≠ficos",
    "..."
  ]
}

REGRAS CR√çTICAS:
- Idioma: portugu√™s do Brasil.
- Seja EXTREMAMENTE DETALHADO e ESPEC√çFICO em todas as respostas.
- N√£o copie trechos do roteiro; ANALISE e EXTRAIA os princ√≠pios virais.
- Foque em ENTREGAR uma f√≥rmula que permita CRIAR roteiros SUPERIORES ao original.
- Cada elemento deve ter explica√ß√£o do POR QU√ä funciona (base cient√≠fica/psicol√≥gica quando poss√≠vel).
- Forne√ßa EXEMPLOS CONCRETOS e ACION√ÅVEIS.
- A f√≥rmula deve ser clara o suficiente para um agente de IA replicar e melhorar.
- Priorize elementos que aumentem RETEN√á√ÉO (watch time) e VIRALIZA√á√ÉO (compartilhamentos).

CONTEXTO DO V√çDEO:
- T√≠tulo: ${videoTitle || 'N/A'}
- Nicho: ${niche || 'N/A'}
- Subnicho: ${subniche || 'N/A'}

ROTEIRO COMPLETO PARA AN√ÅLISE:
"""${truncatedTranscript}"""

ANALISE ESTE ROTEIRO E ENTREGUE UMA F√ìRMULA VIRAL COMPLETA QUE PERMITA CRIAR ROTEIROS 10/10, COM ALTO PODER DE RETEN√á√ÉO E VIRALIZA√á√ÉO, SUPERANDO O ORIGINAL.`;

    let aiResponse;
        if (provider.service === 'laozhang') {
            aiResponse = await callLaozhangAPI(
                analysisPrompt, 
                provider.apiKey, 
                provider.model, 
                null, 
                userId, 
                'api_call', 
                JSON.stringify({ endpoint: '/api/scripts/generate', model: provider.model })
            );
        // callLaozhangAPI retorna string diretamente
        const responseText = typeof aiResponse === 'string' ? aiResponse : JSON.stringify(aiResponse);
        const parsed = parseJSONFromString(responseText);
        if (!parsed) {
            throw new Error('A IA retornou um formato inv√°lido na an√°lise do roteiro.');
        }
        return { analysis: parsed, provider: provider.service };
    } else if (provider.service === 'claude') {
        aiResponse = await callClaudeAPI(analysisPrompt, provider.apiKey, provider.model);
    } else if (provider.service === 'openai') {
        aiResponse = await callOpenAIAPI(analysisPrompt, provider.apiKey, provider.model);
    } else {
        aiResponse = await callGeminiAPI(analysisPrompt, provider.apiKey, provider.model);
    }

    const parsed = parseJSONFromString(extractTextFromAIResponse(aiResponse));
    if (!parsed) {
        throw new Error('A IA retornou um formato inv√°lido na an√°lise do roteiro.');
    }

    return { analysis: parsed, provider: provider.service };
}

/**
 * Fun√ß√£o para gerar agente autom√°tico ap√≥s an√°lise da transcri√ß√£o
 * Usa os prompts espec√≠ficos fornecidos pelo usu√°rio
 */
async function generateAgentFromTranscript({ userId, transcript, videoTitle, niche, subniche, analysis }) {
    const provider = await getPreferredAIProvider(userId, ['claude', 'openai', 'gemini']);
    if (!provider) {
        throw new Error('Configure uma chave do Claude, OpenAI ou Gemini para gerar o agente.');
    }

    const sanitizedTranscript = transcript.trim();
    const truncatedTranscript = sanitizedTranscript.length > 50000
        ? `${sanitizedTranscript.substring(0, 50000)}\n[... conte√∫do truncado ...]`
        : sanitizedTranscript;

    // Construir o prompt completo com os 4 passos
    const agentPrompt = `
PASSO 1 - CRIAR ROTEIRO BASE:
Preciso que voc√™ me ajude a criar um agente de cria√ß√£o de roteiros em forma de documento no nicho de ${niche || 'N/A'} subnichado em ${subniche || 'N/A'}. 

Vou te mandar uma transcri√ß√£o de um roteiro e quero que o agente crie roteiros com a mesma estrutura da TRANSCRI√á√ÉO. O agente deve criar os roteiros com par√°grafos longos, cheios, sem quebras de linha excessivas e deve evitar termos t√©cnicos como "capitulo x" ou "parte tal" deve seguir apenas com o conte√∫do para facilitar que eu copie o roteiro para um documento. O agente deve produzir roteiros com em m√©dia 30 mil caracteres em ptbr. Preciso que o texto seja feito em um bloco √∫nico, sem separa√ß√£o por subt√≠tulos ou t√≥picos e que n√£o possua palavras destacadas em negrito ou algo do tipo. Esse texto vai ser narrado por uma IA, por isso pe√ßo que retire todos os travess√µes ou hifens em palavras ou frases, para que n√£o ocorra nenhum tipo de bug na hora que a IA for narrar esse texto. Corte a introdu√ß√£o da resposta do prompt e v√° direto ao texto traduzido. Mantenha a ess√™ncia de um roteiro feito para youtube, como CTA de like e inscri√ß√£o no canal.

PASSO 2 - INTRODU√á√ÉO:
Crie uma introdu√ß√£o breve e impactante para o v√≠deo com o t√≠tulo "${videoTitle || 'N/A'}" como refer√™ncia no agente. A introdu√ß√£o deve ser envolvente, criar conex√£o com o p√∫blico, gerar identifica√ß√£o imediata, tocar diretamente na dor que o espectador sente e apresentar a promessa de uma solu√ß√£o real e acess√≠vel. Use linguagem emocional, simples e direta, como se estivesse falando com algu√©m que sofre com esse problema h√° muito tempo. Utilize riqueza de detalhes e storytelling para o p√∫blico se identificar.

PASSO 3 - CTA DE INSCRI√á√ÉO:
Crie um CTA de inscri√ß√£o envolvente e humanizado para um canal desse nicho e subnicho espec√≠fico voltado ao p√∫blico que sofre com essa dor espec√≠fica. O CTA deve incentivar a inscri√ß√£o de forma acolhedora, sem press√£o, destacando os benef√≠cios de acompanhar o canal. Use linguagem simples, direta e emocional. O tom deve transmitir cuidado, confian√ßa e autoridade.

PASSO 4 - CTA DE COMENT√ÅRIO:
Crie um CTA envolvente, localizado por volta de 1/3 do v√≠deo, que provoque o espectador a comentar. O trecho deve usar uma pergunta direta, gerar identifica√ß√£o com a dor ou dificuldade da audi√™ncia, e ativar emocionalmente a pessoa ‚Äî como se ela estivesse sendo ouvida pela primeira vez. O texto deve induzir o coment√°rio com uma frase pronta para copiar e colar, e fazer o espectador sentir que sua participa√ß√£o ajuda outras pessoas. Use um tom emp√°tico, acolhedor e de conversa √≠ntima, como se estivesse falando com um amigo que sofre em sil√™ncio.

CONTEXTO:
- T√≠tulo do v√≠deo: ${videoTitle || 'N/A'}
- Nicho: ${niche || 'N/A'}
- Subnicho: ${subniche || 'N/A'}
- An√°lise da f√≥rmula viral: ${JSON.stringify(analysis, null, 2)}

TRANSCRI√á√ÉO DE REFER√äNCIA:
"""${truncatedTranscript}"""

INSTRU√á√ïES PARA O AGENTE:
Com base na transcri√ß√£o acima e na an√°lise da f√≥rmula viral, crie um agente que:
1. Gere roteiros seguindo a mesma estrutura e estilo da transcri√ß√£o
2. Use a introdu√ß√£o, CTA de inscri√ß√£o e CTA de coment√°rio criados acima
3. Mantenha o tom, estilo narrativo e elementos virais identificados na an√°lise
4. Produza roteiros completos de aproximadamente 30.000 caracteres
5. Formate o texto como um bloco √∫nico, sem quebras excessivas ou formata√ß√£o especial
6. Remova todos os travess√µes e hifens que possam causar problemas na narra√ß√£o por IA

Retorne APENAS um JSON v√°lido no formato:
{
  "agentName": "Nome do agente baseado no nicho/subnicho",
  "agentDescription": "Descri√ß√£o do agente",
  "agentInstructions": "Instru√ß√µes completas para o agente seguir ao criar roteiros",
  "introduction": "Introdu√ß√£o criada no PASSO 2",
  "subscriptionCTA": "CTA de inscri√ß√£o criado no PASSO 3",
  "commentCTA": "CTA de coment√°rio criado no PASSO 4",
  "exampleScript": "Exemplo de roteiro completo seguindo a estrutura da transcri√ß√£o (aprox. 2000 caracteres como exemplo)"
}`;

    let aiResponse;
    if (provider.service === 'laozhang') {
        aiResponse = await callLaozhangAPI(
            agentPrompt, 
            provider.apiKey, 
            provider.model, 
            null, 
            userId, 
            'api_call', 
            JSON.stringify({ endpoint: '/api/scripts/generate', model: provider.model })
        );
        const responseText = typeof aiResponse === 'string' ? aiResponse : JSON.stringify(aiResponse);
        const parsed = parseJSONFromString(responseText);
        if (!parsed) {
            throw new Error('A IA retornou um formato inv√°lido na gera√ß√£o do agente.');
        }
        return { agent: parsed, provider: provider.service };
    } else if (provider.service === 'claude') {
        aiResponse = await callClaudeAPI(agentPrompt, provider.apiKey, provider.model);
    } else if (provider.service === 'openai') {
        aiResponse = await callOpenAIAPI(agentPrompt, provider.apiKey, provider.model);
    } else {
        aiResponse = await callGeminiAPI(agentPrompt, provider.apiKey, provider.model);
    }

    const parsed = parseJSONFromString(extractTextFromAIResponse(aiResponse));
    if (!parsed) {
        throw new Error('A IA retornou um formato inv√°lido na gera√ß√£o do agente.');
    }

    return { agent: parsed, provider: provider.service };
}


// --- FUN√á√ïES AUXILIARES DE VALIDA√á√ÉO DE CHAVE ---

async function validateGeminiKey(apiKey) {
    try {
        // Valida√ß√£o de formato b√°sica
        if (!apiKey || typeof apiKey !== 'string' || apiKey.trim().length < 20) {
            return { success: false, error: 'Chave de API inv√°lida: formato incorreto ou muito curta.' };
        }

        // Tentar primeiro com API do Gemini (generativelanguage.googleapis.com)
        // Para chaves de API do Gemini diretas
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // Timeout de 10 segundos
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${encodeURIComponent(apiKey)}`, {
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (response.status === 200) {
                const data = await response.json();
                if (data.models && data.models.length > 0) {
                    return { success: true, type: 'gemini-api', message: 'Chave de API do Gemini v√°lida e funcional.' };
                }
            }
            const error = await response.json().catch(() => ({}));
            // Se der erro espec√≠fico sobre API keys n√£o suportadas, tentar Vertex AI
            if (error.error?.message && error.error.message.includes('API keys are not supported')) {
                console.log('[Valida√ß√£o Gemini] Chave √© do Google Cloud (Vertex AI), n√£o API key direta');
                // Continuar para validar como Google Cloud
            } else {
                return { success: false, error: error.error?.message || 'Chave inv√°lida ou sem modelos acess√≠veis.' };
            }
        } catch (geminiErr) {
            if (geminiErr.name === 'AbortError') {
                return { success: false, error: 'Timeout: A valida√ß√£o demorou muito. Verifique sua conex√£o.' };
            }
            console.log('[Valida√ß√£o Gemini] Erro ao validar como API direta, tentando Google Cloud...', geminiErr.message);
        }
        
        // Tentar validar como chave do Google Cloud
        // Chaves do Google Cloud podem ser usadas para:
        // 1. Google Cloud Text-to-Speech (j√° implementado)
        // 2. Outros servi√ßos do Google Cloud
        // Nota: Vertex AI geralmente requer OAuth2, mas a chave pode ser v√°lida para outros servi√ßos
        try {
            // Validar usando Google Cloud Text-to-Speech API (que j√° estamos usando)
            // Se a chave funcionar para TTS, ela √© v√°lida para servi√ßos do Google Cloud
            const ttsController = new AbortController();
            const ttsTimeoutId = setTimeout(() => ttsController.abort(), 10000);
            const ttsResponse = await fetch(`https://texttospeech.googleapis.com/v1/voices?key=${encodeURIComponent(apiKey)}&languageCode=pt-BR`, {
                signal: ttsController.signal
            });
            clearTimeout(ttsTimeoutId);
            
            if (ttsResponse.status === 200) {
                const ttsData = await ttsResponse.json();
                if (ttsData.voices && ttsData.voices.length > 0) {
                    return { 
                        success: true, 
                        type: 'google-cloud', 
                        message: 'Chave do Google Cloud v√°lida. Pode ser usada para Text-to-Speech e outros servi√ßos do Google Cloud.'
                    };
                }
            } else if (ttsResponse.status === 401 || ttsResponse.status === 403) {
                const ttsError = await ttsResponse.json().catch(() => ({}));
                // Se a mensagem menciona que a API n√£o est√° habilitada, a chave √© v√°lida mas precisa habilitar a API
                if (ttsError.error?.message && ttsError.error.message.includes('API has not been used')) {
                    return { 
                        success: true, 
                        type: 'google-cloud', 
                        message: 'Chave do Google Cloud v√°lida. Habilite a API Text-to-Speech no Google Cloud Console para usar TTS.',
                        warning: 'A API Text-to-Speech precisa ser habilitada no Google Cloud Console.'
                    };
                }
                return { success: false, error: ttsError.error?.message || 'Chave inv√°lida ou sem permiss√£o para Text-to-Speech.' };
            } else {
                const ttsError = await ttsResponse.json().catch(() => ({}));
                return { success: false, error: ttsError.error?.message || 'Erro ao validar chave do Google Cloud.' };
            }
        } catch (cloudErr) {
            // Se ambos falharem, mas a chave parece ser do Google Cloud (baseado no erro original)
            // Retornar como v√°lida mas com aviso
            console.log('[Valida√ß√£o Gemini] Erro ao validar Google Cloud:', cloudErr.message);
            return { 
                success: true, 
                type: 'google-cloud', 
                message: 'Chave do Google Cloud detectada. Pode ser usada para servi√ßos do Google Cloud.',
                warning: 'Valida√ß√£o completa n√£o foi poss√≠vel. Certifique-se de que as APIs necess√°rias est√£o habilitadas no Google Cloud Console.'
            };
        }
    } catch (err) {
        return { success: false, error: err.message };
    }
}

async function validateOpenAIKey(apiKey) {
    try {
        // Valida√ß√£o de formato b√°sica - OpenAI keys geralmente come√ßam com sk-
        if (!apiKey || typeof apiKey !== 'string' || apiKey.trim().length < 20) {
            return { success: false, error: 'Chave de API inv√°lida: formato incorreto ou muito curta.' };
        }
        
        if (!apiKey.trim().startsWith('sk-')) {
            return { success: false, error: 'Formato inv√°lido: chaves OpenAI devem come√ßar com "sk-".' };
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // Timeout de 10 segundos
        const response = await fetch('https://api.openai.com/v1/models', {
            headers: { 'Authorization': `Bearer ${apiKey}` },
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        
        if (response.status === 200) {
            const data = await response.json();
            if (data.data && Array.isArray(data.data) && data.data.length > 0) {
                return { success: true, message: 'Chave OpenAI v√°lida e funcional.' };
            }
            return { success: true, message: 'Chave OpenAI v√°lida.' };
        }
        
        const error = await response.json().catch(() => ({}));
        if (response.status === 401 || response.status === 403) {
            return { success: false, error: error.error?.message || 'Chave inv√°lida ou sem permiss√£o.' };
        }
        return { success: false, error: error.error?.message || `Erro na valida√ß√£o (status ${response.status})` };
    } catch (err) {
        if (err.name === 'AbortError') {
            return { success: false, error: 'Timeout: A valida√ß√£o demorou muito. Verifique sua conex√£o.' };
        }
        return { success: false, error: err.message || 'Erro ao conectar com a API OpenAI.' };
    }
}

async function validateClaudeKey(apiKey) {
    try {
        // Valida√ß√£o de formato b√°sica - Claude keys geralmente come√ßam com sk-ant-
        if (!apiKey || typeof apiKey !== 'string' || apiKey.trim().length < 20) {
            return { success: false, error: 'Chave de API inv√°lida: formato incorreto ou muito curta.' };
        }
        
        if (!apiKey.trim().startsWith('sk-ant-')) {
            return { success: false, error: 'Formato inv√°lido: chaves Claude devem come√ßar com "sk-ant-".' };
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // Timeout de 10 segundos
        const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: { 
                'x-api-key': apiKey, 
                'anthropic-version': '2023-06-01',
                'content-type': 'application/json'
            },
            body: JSON.stringify({
                model: "claude-3-5-haiku-20241022", // Usar um modelo v√°lido mais recente para valida√ß√£o
                max_tokens: 10,
                messages: [{ role: "user", content: "Test" }]
            }),
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        
        const data = await response.json();

        if (response.status === 200) {
            return { success: true, message: 'Chave Claude v√°lida e funcional.' };
        } 
        else if (response.status === 401 || response.status === 403) {
            return { success: false, error: data.error?.message || data.error?.type || 'Chave inv√°lida ou sem permiss√£o.' };
        } 
        else if (response.status === 400 && data.error?.type === 'invalid_request_error') {
            // Claude pode retornar 400 para 'invalid_request_error' mesmo com chave v√°lida se o prompt for muito curto,
            // mas a chave em si √© v√°lida. Consideramos sucesso para valida√ß√£o da chave.
            return { success: true, message: 'Chave Claude v√°lida.' }; 
        }
        else {
            return { success: false, error: data.error?.message || data.error?.type || `Erro na valida√ß√£o (status ${response.status})` };
        }
    } catch (err) {
        if (err.name === 'AbortError') {
            return { success: false, error: 'Timeout: A valida√ß√£o demorou muito. Verifique sua conex√£o.' };
        }
        return { success: false, error: err.message || 'Erro ao conectar com a API Claude.' };
    }
}

async function validateYouTubeKey(apiKey) {
    try {
        // Valida√ß√£o de formato b√°sica - YouTube API keys geralmente come√ßam com AIza
        if (!apiKey || typeof apiKey !== 'string' || apiKey.trim().length < 20) {
            return { success: false, error: 'Chave de API inv√°lida: formato incorreto ou muito curta.' };
        }
        
        if (!apiKey.trim().startsWith('AIza')) {
            return { success: false, error: 'Formato inv√°lido: chaves YouTube Data API devem come√ßar com "AIza".' };
        }

        // Testar a chave fazendo uma requisi√ß√£o simples de busca
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // Timeout de 10 segundos
        const response = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=1&q=test&type=video&key=${encodeURIComponent(apiKey)}`, {
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        
        if (response.status === 200) {
            const data = await response.json();
            if (data.items || data.pageInfo) {
                return { success: true, message: 'Chave YouTube Data API v√°lida e funcional.' };
            }
            return { success: true, message: 'Chave YouTube Data API v√°lida.' };
        }
        
        // Verificar erros espec√≠ficos
        const data = await response.json();
        
        if (response.status === 400 && data.error?.errors?.[0]?.reason === 'keyInvalid') {
            return { success: false, error: 'Chave de API inv√°lida ou malformada.' };
        }
        
        if (response.status === 403) {
            const reason = data.error?.errors?.[0]?.reason;
            if (reason === 'quotaExceeded') {
                // Se a cota foi excedida, a chave √© v√°lida mas sem cr√©ditos
                return { success: true, message: 'Chave v√°lida, mas cota excedida.', warning: 'A cota di√°ria da API foi excedida.' };
            } else if (reason === 'accessNotConfigured') {
                return { success: false, error: 'YouTube Data API v3 n√£o est√° habilitada no Google Cloud Console.' };
            } else if (reason === 'forbidden') {
                return { success: false, error: 'Chave sem permiss√£o para acessar a API YouTube.' };
            }
        }
        
        return { success: false, error: data.error?.message || data.error?.errors?.[0]?.message || 'Chave inv√°lida ou com problemas de acesso.' };
    } catch (err) {
        if (err.name === 'AbortError') {
            return { success: false, error: 'Timeout: A valida√ß√£o demorou muito. Verifique sua conex√£o.' };
        }
        return { success: false, error: err.message || 'Erro ao conectar com a API YouTube.' };
    }
}


// --- MIDDLEWARE DE AUTENTICA√á√ÉO ---
const authenticateToken = (req, res, next) => {
    // Verificar se o banco de dados est√° inicializado
    if (!db) {
        return res.status(503).json({ msg: 'Servidor ainda n√£o est√° pronto. Aguarde alguns instantes e tente novamente.' });
    }
    
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token == null) {
        return res.status(401).json({ msg: 'Token n√£o fornecido.' });
    }

    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).json({ msg: 'Token inv√°lido ou expirado.' });
        }
        req.user = user;
        next();
    });
};

const isAdmin = (req, res, next) => {
    if (!req.user || !req.user.isAdmin) {
        return res.status(403).json({ msg: 'Acesso negado. Requer privil√©gios de administrador.' });
    }
    next();
};

// ================================================
// SISTEMA DE CR√âDITOS - FUN√á√ïES PRINCIPAIS
// ================================================

/**
 * Obt√©m a API padr√£o do admin (para uso com cr√©ditos)
 */
const getDefaultAdminApi = async () => {
    try {
        // Buscar API padr√£o ativa
        let api = await db.get(`
            SELECT * FROM api_providers 
            WHERE is_active = 1 AND is_default = 1
            LIMIT 1
        `);
        
        if (api) {
            return api;
        }
        
        // Se n√£o tem padr√£o, buscar primeira API ativa
        api = await db.get(`
            SELECT * FROM api_providers 
            WHERE is_active = 1
            ORDER BY id ASC
            LIMIT 1
        `);
        
        return api || null;
    } catch (error) {
        console.error('‚ùå Erro ao buscar API padr√£o do admin:', error);
        return null;
    }
};

// Fun√ß√£o para buscar chave de voz configurada no admin
const getAdminVoiceApiKey = async () => {
    try {
        const setting = await db.get(`
            SELECT value FROM app_settings 
            WHERE key = 'voice_api_key'
        `);
        
        if (setting && setting.value) {
            let apiKey = setting.value;
            
            // Tentar parsear como JSON (caso tenha sido salvo como JSON)
            try {
                const parsed = JSON.parse(setting.value);
                // Se o resultado do parse for uma string, usar ela
                if (typeof parsed === 'string') {
                    apiKey = parsed;
                }
            } catch (parseError) {
                // Se n√£o for JSON, usar diretamente (j√° √© string)
                apiKey = setting.value;
            }
            
            // Remover aspas extras se houver (caso tenha sido salvo como JSON string)
            if (apiKey.startsWith('"') && apiKey.endsWith('"')) {
                apiKey = apiKey.slice(1, -1);
            }
            
            // Validar se n√£o est√° vazia
            if (apiKey && apiKey.trim().length > 0) {
                console.log('[getAdminVoiceApiKey] ‚úÖ Chave encontrada (tamanho:', apiKey.length, 'caracteres)');
                return apiKey.trim();
            } else {
                console.log('[getAdminVoiceApiKey] ‚ö†Ô∏è Chave encontrada mas est√° vazia');
                return null;
            }
        }
        
        console.log('[getAdminVoiceApiKey] ‚ùå Nenhuma chave de voz encontrada no admin');
        return null;
    } catch (error) {
        console.error('Erro ao buscar chave de voz do admin:', error);
        return null;
    }
};

const normalizeAppSettingKey = (value) => {
    if (value === null || value === undefined) return null;
    let key = String(value);
    if (key.startsWith('"') && key.endsWith('"')) {
        key = key.slice(1, -1);
    }
    key = key.trim();
    return key.length >= 10 ? key : null;
};

const getAdminOpenAiVoiceApiKey = async () => {
    try {
        const setting = await db.get("SELECT value FROM app_settings WHERE key = 'openai_voice_api_key'");
        if (setting && setting.value) {
            let apiKey = setting.value;
            try {
                const parsed = JSON.parse(setting.value);
                if (typeof parsed === 'string') apiKey = parsed;
            } catch {
                apiKey = setting.value;
            }
            apiKey = normalizeAppSettingKey(apiKey);
            if (apiKey) {
                console.log('[getAdminOpenAiVoiceApiKey] ‚úÖ Chave encontrada no admin');
                return apiKey;
            }
        }
        return null;
    } catch (error) {
        console.error('[getAdminOpenAiVoiceApiKey] ‚ùå Erro ao buscar chave OpenAI:', error);
        return null;
    }
};

const getAdminVideoApiKey = async () => {
    try {
        const setting = await db.get("SELECT value FROM app_settings WHERE key = 'video_api_key'");
        if (setting && setting.value) {
            let apiKey = setting.value;
            try {
                const parsed = JSON.parse(setting.value);
                if (typeof parsed === 'string') apiKey = parsed;
            } catch {
                apiKey = setting.value;
            }
            apiKey = normalizeAppSettingKey(apiKey);
            if (apiKey) {
                console.log('[getAdminVideoApiKey] ‚úÖ Chave de v√≠deo encontrada no admin');
                return apiKey;
            }
        }
        return null;
    } catch (error) {
        console.error('[getAdminVideoApiKey] ‚ùå Erro ao buscar chave de v√≠deo:', error);
        return null;
    }
};

const cacheVideoOperationMetadata = async (operationId, userId, meta = {}) => {
    try {
        await db.run(`
            INSERT OR REPLACE INTO video_operations_cache (
                operation_id,
                user_id,
                api_key_source,
                user_key_id,
                admin_api_id,
                use_laozhang
            ) VALUES (?, ?, ?, ?, ?, ?)
        `, [
            operationId,
            userId,
            meta.apiKeySource || 'unknown',
            meta.userKeyId || null,
            meta.adminApiId || null,
            meta.useLaozhang ? 1 : 0
        ]);
        console.log('[VideoCache] Opera√ß√£o registrada:', operationId, meta.apiKeySource);
    } catch (error) {
        console.error('[VideoCache] Erro ao salvar opera√ß√£o:', error.message);
    }
};

const removeVideoOperationCache = async (operationId) => {
    try {
        await db.run('DELETE FROM video_operations_cache WHERE operation_id = ?', [operationId]);
    } catch (error) {
        console.error('[VideoCache] Erro ao remover opera√ß√£o:', error.message);
    }
};

const resolveCachedVideoApiKey = async (cacheRow) => {
    try {
        switch (cacheRow.api_key_source) {
            case 'panel_video':
                return await getAdminVideoApiKey();
            case 'user_gemini':
                if (!cacheRow.user_key_id) return null;
                const userKey = await db.get('SELECT api_key FROM user_api_keys WHERE id = ?', [cacheRow.user_key_id]);
                if (!userKey || !userKey.api_key) return null;
                if (userKey.api_key.includes(':')) {
                    try {
                        return decrypt(userKey.api_key);
                    } catch (err) {
                        console.warn('[VideoCache] Erro ao descriptografar chave do usu√°rio:', err.message);
                        return userKey.api_key;
                    }
                }
                return userKey.api_key;
            case 'admin_provider':
                if (!cacheRow.admin_api_id) return null;
                const adminProvider = await db.get('SELECT * FROM api_providers WHERE id = ?', [cacheRow.admin_api_id]);
                if (!adminProvider || !adminProvider.api_key) return null;
                if (adminProvider.api_key.includes(':')) {
                    try {
                        return decrypt(adminProvider.api_key);
                    } catch (err) {
                        console.warn('[VideoCache] Erro ao descriptografar chave do admin provider:', err.message);
                        return adminProvider.api_key;
                    }
                }
                return adminProvider.api_key;
            case 'laozhang':
                return await getLaozhangApiKey();
            default:
                return null;
        }
    } catch (error) {
        console.error('[VideoCache] Erro ao resolver chave para opera√ß√£o:', cacheRow.operation_id, error.message);
        return null;
    }
};

const rehydratePendingVideoOperations = async () => {
    try {
        const pending = await db.all('SELECT * FROM video_operations_cache');
        if (!pending || pending.length === 0) {
            console.log('[VideoCache] Nenhuma opera√ß√£o pendente para reidratar.');
            return;
        }
        
        console.log(`[VideoCache] Reidratando ${pending.length} opera√ß√£o(√µes) de v√≠deo pendentes...`);
        for (const row of pending) {
            const apiKey = await resolveCachedVideoApiKey(row);
            if (!apiKey) {
                console.warn('[VideoCache] N√£o foi poss√≠vel recuperar chave para opera√ß√£o:', row.operation_id);
                continue;
            }
            
            const operationData = {
                userId: row.user_id,
                operation: { name: row.operation_id },
                status: 'processing',
                useAdminApi: row.api_key_source === 'admin_provider',
                adminApi: null,
                useLaozhang: row.use_laozhang === 1
            };
            
            if (row.admin_api_id) {
                operationData.adminApi = await db.get('SELECT * FROM api_providers WHERE id = ?', [row.admin_api_id]);
            }
            
            videoOperations.set(row.operation_id, operationData);
            pollVideoOperation(row.operation_id, apiKey);
        }
    } catch (error) {
        console.error('[VideoCache] Erro ao reidratar opera√ß√µes pendentes:', error.message);
    }
};

/**
 * Obt√©m a chave da API Laozhang.ai das configura√ß√µes da aplica√ß√£o
 */
const getLaozhangApiKey = async () => {
    try {
        const setting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_api_key'");
        if (setting && setting.value) {
            try {
                const parsed = JSON.parse(setting.value);
                // Se for objeto, extrair api_key se existir, sen√£o retornar o objeto
                if (typeof parsed === 'object' && parsed !== null) {
                    if (parsed.api_key) {
                        return parsed.api_key;
                    } else if (parsed.key) {
                        return parsed.key;
                    } else {
                        // Se for objeto sem api_key, tentar converter para string
                        return JSON.stringify(parsed);
                    }
                }
                return parsed;
            } catch (e) {
                // Se n√£o for JSON, retornar como string
                const value = String(setting.value).trim();
                if (value && value.length > 10) {
                    return value;
                }
                return null;
            }
        }
        return null;
    } catch (error) {
        console.error('‚ùå Erro ao buscar chave Laozhang.ai:', error);
        return null;
    }
};

/**
 * Obt√©m o ID do provider Laozhang.ai da tabela api_providers
 */
const getLaozhangApiProviderId = async () => {
    try {
        const provider = await db.get("SELECT id FROM api_providers WHERE provider = 'laozhang' AND is_active = 1 LIMIT 1");
        if (provider) {
            return provider.id;
        }
        // Se n√£o existir, criar um provider padr√£o para Laozhang
        const result = await db.run(`
            INSERT INTO api_providers (
                name, provider, model, api_key, unit_type, unit_size,
                real_cost_per_unit, credits_per_unit, markup, is_premium,
                is_active, is_default
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
            'Laozhang.ai', 'laozhang', 'gpt-4o', '', 'tokens', 1000,
            0.0, 1.0, 1.0, 0, 1, 0
        ]);
        return result.lastID;
    } catch (error) {
        console.error('‚ùå Erro ao buscar/criar provider Laozhang.ai:', error);
        return null;
    }
};

/**
 * Determina se deve usar cr√©ditos (laozhang.ai) ou API pr√≥pria
 * REGRA: Usa cr√©ditos se:
 * 1. Usu√°rio marcou prefer√™ncia para usar cr√©ditos, OU
 * 2. Usu√°rio N√ÉO tem plano que permite API pr√≥pria, OU
 * 3. Usu√°rio tem plano que permite mas N√ÉO tem API pr√≥pria configurada
 * 
 * REGRA CR√çTICA: Se prefer√™ncia N√ÉO estiver marcada E usu√°rio tem plano que permite API pr√≥pria E tem API pr√≥pria configurada ‚Üí usar API pr√≥pria
 * 
 * @param {number} userId - ID do usu√°rio
 * @param {string[]} services - Lista de servi√ßos para verificar (ex: ['claude', 'openai', 'gemini'])
 * @returns {Promise<{shouldUse: boolean, reason: string, hasOwnApi: boolean, hasPreference: boolean, hasPlanPermission: boolean}>}
 */
async function shouldUseCredits(userId, services = ['claude', 'openai', 'gemini']) {
    try {
        // Verificar prefer√™ncia do usu√°rio PRIMEIRO
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
        const hasPreference = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // REGRA CR√çTICA: Se prefer√™ncia N√ÉO est√° marcada, verificar se pode usar API pr√≥pria
        // Se pode usar API pr√≥pria, N√ÉO deve usar cr√©ditos (n√£o precisa nem verificar saldo)
        if (!hasPreference) {
            // Verificar se usu√°rio tem plano que permite usar API pr√≥pria
            let hasPlanPermission = false;
            try {
                const userData = await db.get('SELECT plan, subscription_plan, isAdmin FROM users WHERE id = ?', [userId]);
                if (userData) {
                    // Admin sempre tem permiss√£o
                    if (userData.isAdmin === 1 || userData.isAdmin === true || String(userData.isAdmin) === '1') {
                        hasPlanPermission = true;
                    } else {
                        const planName = userData.subscription_plan || userData.plan || 'plan-free';
                        const permission = await db.get(
                            'SELECT is_allowed FROM plan_permissions WHERE plan_name = ? AND feature_name = ?',
                            [planName, 'api_propria']
                        );
                        hasPlanPermission = permission && permission.is_allowed === 1;
                    }
                }
            } catch (err) {
                console.warn('[shouldUseCredits] Erro ao verificar permiss√£o do plano:', err.message);
            }
            
            // Se tem plano que permite, verificar se tem API pr√≥pria configurada
            if (hasPlanPermission) {
                let hasOwnApi = false;
                for (const service of services) {
                    try {
                        const keyData = await db.get(
                            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                            [userId, service]
                        );
                        if (keyData && keyData.api_key) {
                            const decryptedKey = decrypt(keyData.api_key);
                            if (decryptedKey && decryptedKey.trim().length > 0) {
                                hasOwnApi = true;
                                break;
                            }
                        }
                    } catch (err) {
                        // Ignorar erros individuais
                    }
                }
                
                // Se tem plano E tem API pr√≥pria ‚Üí N√ÉO usar cr√©ditos (retornar imediatamente)
                if (hasOwnApi) {
                    console.log(`[shouldUseCredits] userId: ${userId}, shouldUse: false, reason: Prefer√™ncia n√£o marcada, tem plano e API pr√≥pria - N√ÉO usar cr√©ditos`);
                    return {
                        shouldUse: false,
                        reason: 'Prefer√™ncia n√£o marcada, usu√°rio tem plano que permite API pr√≥pria e tem API pr√≥pria configurada',
                        hasOwnApi: true,
                        hasPreference: false,
                        hasPlanPermission: true
                    };
                }
            }
        }
        
        // Se prefer√™ncia estiver marcada, SEMPRE usar cr√©ditos
        if (hasPreference) {
            console.log(`[shouldUseCredits] userId: ${userId}, shouldUse: true, reason: Prefer√™ncia do usu√°rio marcada para usar cr√©ditos`);
            return {
                shouldUse: true,
                reason: 'Prefer√™ncia do usu√°rio marcada para usar cr√©ditos',
                hasOwnApi: false,
                hasPreference: true,
                hasPlanPermission: false
            };
        }
        
        // Se chegou aqui, n√£o tem prefer√™ncia marcada mas tamb√©m n√£o tem plano/permiss√£o ou n√£o tem API pr√≥pria
        // Verificar se usu√°rio tem plano que permite usar API pr√≥pria
        let hasPlanPermission = false;
        try {
            const userData = await db.get('SELECT plan, subscription_plan, isAdmin FROM users WHERE id = ?', [userId]);
            if (userData) {
                // Admin sempre tem permiss√£o
                if (userData.isAdmin === 1 || userData.isAdmin === true || String(userData.isAdmin) === '1') {
                    hasPlanPermission = true;
                } else {
                    const planName = userData.subscription_plan || userData.plan || 'plan-free';
                    const permission = await db.get(
                        'SELECT is_allowed FROM plan_permissions WHERE plan_name = ? AND feature_name = ?',
                        [planName, 'api_propria']
                    );
                    hasPlanPermission = permission && permission.is_allowed === 1;
                }
            }
        } catch (err) {
            console.warn('[shouldUseCredits] Erro ao verificar permiss√£o do plano:', err.message);
        }
        
        // Se n√£o tem plano que permite API pr√≥pria, usar cr√©ditos
        if (!hasPlanPermission) {
            console.log(`[shouldUseCredits] userId: ${userId}, shouldUse: true, reason: Usu√°rio n√£o tem plano que permite usar API pr√≥pria`);
            return {
                shouldUse: true,
                reason: 'Usu√°rio n√£o tem plano que permite usar API pr√≥pria',
                hasOwnApi: false,
                hasPreference: false,
                hasPlanPermission: false
            };
        }
        
        // Se tem plano mas n√£o tem API pr√≥pria configurada, usar cr√©ditos
        console.log(`[shouldUseCredits] userId: ${userId}, shouldUse: true, reason: Usu√°rio tem plano mas n√£o tem API pr√≥pria configurada`);
        return {
            shouldUse: true,
            reason: 'Usu√°rio tem plano que permite API pr√≥pria mas n√£o tem API pr√≥pria configurada',
            hasOwnApi: false,
            hasPreference: false,
            hasPlanPermission: true
        };
    } catch (error) {
        console.error('[shouldUseCredits] Erro:', error);
        // Em caso de erro, por padr√£o usar cr√©ditos (mais seguro)
        return {
            shouldUse: true,
            reason: 'Erro ao verificar configura√ß√µes, usando cr√©ditos por padr√£o',
            hasOwnApi: false,
            hasPreference: false,
            hasPlanPermission: false
        };
    }
}

/**
 * Verifica e debita cr√©ditos do usu√°rio
 */
const checkAndDebitCredits = async (userId, apiProviderId, unitsConsumed, operationType = 'api_call', details = null) => {
    try {
        // Obter informa√ß√µes da API
        const apiProvider = await db.get(`
            SELECT credits_per_unit, unit_type, unit_size, name 
            FROM api_providers 
            WHERE id = ? AND is_active = 1
        `, [apiProviderId]);

        if (!apiProvider) {
            throw new Error('API provider n√£o encontrada ou inativa');
        }

        // Aplicar multiplicador TTS se for opera√ß√£o de TTS
        let creditsPerUnit = apiProvider.credits_per_unit;
        if (operationType && (operationType.includes('tts') || operationType.includes('TTS') || operationType === 'api_tts_generation' || operationType === 'api_tts_preview')) {
            const ttsMultiplierSetting = await db.get("SELECT value FROM app_settings WHERE key = 'tts_credits_multiplier'");
            const ttsMultiplier = ttsMultiplierSetting ? parseFloat(ttsMultiplierSetting.value) : 1.0;
            
            if (ttsMultiplier > 0 && ttsMultiplier !== 1.0) {
                creditsPerUnit = apiProvider.credits_per_unit * ttsMultiplier;
                console.log(`üîä [TTS] Aplicando multiplicador de ${ttsMultiplier}x ao custo de cr√©ditos para TTS. Custo base: ${apiProvider.credits_per_unit}, Custo final: ${creditsPerUnit.toFixed(4)}`);
            }
        }

        // Calcular cr√©ditos necess√°rios
        const creditsNeeded = (unitsConsumed / apiProvider.unit_size) * creditsPerUnit;

        // Verificar saldo
        let userCredits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [userId]);
        
        if (!userCredits) {
            // Criar registro se n√£o existir
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [userId]);
            userCredits = { balance: 0 };
        }

        if (userCredits.balance < creditsNeeded) {
            throw new Error(`Cr√©ditos insuficientes. Necess√°rio: ${creditsNeeded.toFixed(2)}, Dispon√≠vel: ${userCredits.balance.toFixed(2)}`);
        }

        // Debitar cr√©ditos
        const newBalance = userCredits.balance - creditsNeeded;
        await db.run(`
            UPDATE user_credits 
            SET balance = ?, updated_at = CURRENT_TIMESTAMP 
            WHERE user_id = ?
        `, [newBalance, userId]);

        // Registrar uso
        await db.run(`
            INSERT INTO credit_usage (
                user_id, api_provider_id, credits_used, 
                units_consumed, operation_type, details
            ) VALUES (?, ?, ?, ?, ?, ?)
        `, [userId, apiProviderId, creditsNeeded, unitsConsumed, operationType, details || JSON.stringify({ model: operationType })]);
        
        // Mapear operationType e endpoints para nomes amig√°veis de ferramentas
        // IMPORTANTE: NUNCA incluir nome do fornecedor de API (Laozhang.ai, etc)
        const toolNames = {
            // ===== GERADOR DE ROTEIRO =====
            'api_script_agents_generate': 'Gerador de Roteiro',
            '/api/generate': 'Gerador de Roteiro',
            '/api/scripts': 'Gerador de Roteiro',
            '/api/scripts/generate': 'Gerador de Roteiro',
            '/api/script-agents/:agentId/generate': 'Gerador de Roteiro',
            '/api/script-agents/:agentId/generate/laozhang': 'Gerador de Roteiro',
            'viral_agent_chat': 'Agente Viral',
            'viral_agent': 'Agente Viral',
            
            // ===== GERADOR DE V√çDEO =====
            'api_video_generation': 'Gerador de V√≠deo',
            
            // ===== GERA√á√ÉO DE VOZ (TTS) =====
            'api_tts_generation': 'Gera√ß√£o de Voz',
            'api_tts_preview': 'Preview de Voz',
            
            // ===== GERA√á√ÉO DE IMAGEM =====
            'api_image_generation': 'Gera√ß√£o de Imagem',
            
            // ===== GERADOR DE THUMBNAIL =====
            'api_analyze_thumbnail': 'Gerador de Thumbnail',
            '/api/analyze/thumbnail': 'Gerador de Thumbnail',
            '/api/analyze/thumbnail/laozhang': 'Gerador de Thumbnail',
            
            // ===== GERADOR DE CENAS =====
            '/api/generate/scene-prompts': 'Gerador de Cenas',
            '/api/generate/scene-prompts/laozhang': 'Gerador de Cenas',
            
            // ===== AN√ÅLISE DE T√çTULOS =====
            '/api/analyze/titles': 'An√°lise de T√≠tulos',
            '/api/analyze/titles/laozhang': 'An√°lise de T√≠tulos',
            
            // ===== DETEC√á√ÉO DE PERSONAGENS =====
            'api_detect_characters': 'Detec√ß√£o de Personagens',
            '/api/detect/characters': 'Detec√ß√£o de Personagens',
            '/api/detect/characters/laozhang': 'Detec√ß√£o de Personagens',
            
            // ===== BUSCA DE SUBNICHO =====
            'api_niche_find_subniche': 'Busca de Subnicho',
            '/api/niche/find-subniche': 'Busca de Subnicho',
            '/api/niche/find-subniche/laozhang': 'Busca de Subnicho',
            
            // ===== AN√ÅLISE DE COMPETIDOR =====
            'api_niche_analyze_competitor': 'An√°lise de Competidor',
            '/api/niche/analyze-competitor': 'An√°lise de Competidor',
            '/api/niche/analyze-competitor/laozhang': 'An√°lise de Competidor',
            
            // ===== CRIA√á√ÉO DE AGENTE =====
            '/api/script-agents/create': 'Cria√ß√£o de Agente',
            '/api/script-agents/create/laozhang': 'Cria√ß√£o de Agente',
            
            // ===== REESCREVER PROMPT =====
            'api_rewrite_prompt': 'Reescrever Prompt',
            '/api/rewrite/blocked-prompt': 'Reescrever Prompt',
            '/api/rewrite/blocked-prompt/laozhang': 'Reescrever Prompt',
            
            // ===== AN√ÅLISE DE TRANSCRI√á√ÉO =====
            'api_transcript_analyze': 'An√°lise de Transcri√ß√£o',
            '/api/video/transcript/analyze': 'An√°lise de Transcri√ß√£o',
            '/api/video/transcript/analyze/laozhang': 'An√°lise de Transcri√ß√£o',
            
            // ===== GERADOR DE METADADOS YOUTUBE =====
            '/api/youtube/generate-metadata': 'Gerador de Metadados YouTube',
            
            // ===== GEN√âRICOS (fallback) =====
            'api_generation': 'Gera√ß√£o de Conte√∫do',
            'api_call': 'Ferramenta'
        };
        
        const detailsObj = typeof details === 'string' ? JSON.parse(details) : (details || {});
        
        // Determinar nome da ferramenta - tentar m√∫ltiplas fontes
        let toolName = toolNames[operationType];
        
        // Se n√£o encontrou pelo operationType, tentar pelo endpoint nos details
        if (!toolName && detailsObj?.endpoint) {
            // Tentar match parcial do endpoint
            for (const [key, value] of Object.entries(toolNames)) {
                if (detailsObj.endpoint.includes(key) || key.includes(detailsObj.endpoint)) {
                    toolName = value;
                    break;
                }
            }
        }
        
        // Se ainda n√£o encontrou, tentar inferir pelo operationType ou endpoint
        if (!toolName) {
            const searchKey = operationType || detailsObj?.endpoint || '';
            
            // Buscar por palavras-chave no operationType ou endpoint
            if (searchKey.includes('script') || searchKey.includes('roteiro') || searchKey.includes('agent')) {
                toolName = 'Gerador de Roteiro';
            } else if (searchKey.includes('video') || searchKey.includes('v√≠deo')) {
                toolName = 'Gerador de V√≠deo';
            } else if (searchKey.includes('tts') || searchKey.includes('voz') || searchKey.includes('voice')) {
                toolName = 'Gera√ß√£o de Voz';
            } else if (searchKey.includes('image') || searchKey.includes('imagem')) {
                toolName = 'Gera√ß√£o de Imagem';
            } else if (searchKey.includes('thumbnail') || searchKey.includes('thumb')) {
                toolName = 'Gerador de Thumbnail';
            } else if (searchKey.includes('scene') || searchKey.includes('cena')) {
                toolName = 'Gerador de Cenas';
            } else if (searchKey.includes('title') || searchKey.includes('t√≠tulo')) {
                toolName = 'An√°lise de T√≠tulos';
            } else if (searchKey.includes('character') || searchKey.includes('personagem')) {
                toolName = 'Detec√ß√£o de Personagens';
            } else if (searchKey.includes('subniche') || searchKey.includes('sub-nicho')) {
                toolName = 'Busca de Subnicho';
            } else if (searchKey.includes('competitor') || searchKey.includes('competidor')) {
                toolName = 'An√°lise de Competidor';
            } else if (searchKey.includes('transcript') || searchKey.includes('transcri√ß√£o')) {
                toolName = 'An√°lise de Transcri√ß√£o';
            } else if (searchKey.includes('rewrite') || searchKey.includes('reescrever')) {
                toolName = 'Reescrever Prompt';
            } else {
                // √öltimo fallback: usar o operationType formatado (sem "api_" ou "laozhang")
                toolName = (operationType || 'Ferramenta')
                    .replace(/^api_/, '')
                    .replace(/laozhang/gi, '')
                    .replace(/_/g, ' ')
                    .replace(/\s+/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase())
                    .trim() || 'Ferramenta';
            }
        }
        
        // Extrair modelo dos details - verificar m√∫ltiplas fontes
        let modelName = detailsObj?.model || detailsObj?.selectedModel || null;
        
        // Se n√£o encontrou nos details, tentar extrair do operationType ou endpoint
        if (!modelName && detailsObj?.endpoint) {
            // Alguns endpoints podem ter o modelo no nome
            const endpointModelMatch = detailsObj.endpoint.match(/(gpt-4o|claude-3-7-sonnet|gemini-2\.5-pro)/i);
            if (endpointModelMatch) {
                modelName = endpointModelMatch[1];
            }
        }
        
        // Formatar nome do modelo para exibi√ß√£o amig√°vel
        // IMPORTANTE: Remover qualquer refer√™ncia a fornecedores de API
        if (modelName) {
            // Remover refer√™ncias a fornecedores de API ANTES de formatar
            modelName = modelName
                .replace(/genaipro/gi, 'Voz Premium')
                .replace(/laozhang/gi, 'Provedor Externo')
                .replace(/openai/gi, '')
                .replace(/claude/gi, '')
                .replace(/gemini/gi, '')
                .replace(/anthropic/gi, '')
                .replace(/google/gi, '')
                .trim();
            // V√≠deo - Veo
            // Veo models - verificar modelos landscape primeiro
            if (modelName.includes('veo-3.1-landscape-fast-fl') || modelName === 'veo-3.1-landscape-fast-fl') {
                modelName = 'Veo 3.1 Landscape Fast';
            } else if (modelName.includes('veo-3.1-landscape-fast') || modelName === 'veo-3.1-landscape-fast') {
                modelName = 'Veo 3.1 Landscape Fast';
            } else if (modelName.includes('veo-3.1-landscape-fl') || modelName === 'veo-3.1-landscape-fl') {
                modelName = 'Veo 3.1 Landscape';
            } else if (modelName.includes('veo-3.1-landscape') || modelName === 'veo-3.1-landscape') {
                modelName = 'Veo 3.1 Landscape';
            } else if (modelName.includes('veo-3.1-fast-fl') || modelName === 'veo-3.1-fast-fl') {
                modelName = 'Veo 3.1 Fast';
            } else if (modelName.includes('veo-3.1-fast') || modelName === 'veo-3.1-fast-generate-preview' || modelName === 'veo-3.1-fast') {
                modelName = 'Veo 3.1 Fast';
            } else if (modelName.includes('veo-3.1-fl') || modelName === 'veo-3.1-fl') {
                modelName = 'Veo 3.1';
            } else if (modelName.includes('veo-3.1-generate') || modelName === 'veo-3.1-generate-preview' || modelName === 'veo-3.1') {
                modelName = 'Veo 3.1';
            } else if (modelName.includes('veo-3.1')) {
                modelName = 'Veo 3.1';
            } else if (modelName.includes('veo')) {
                modelName = modelName.replace('veo-', 'Veo ').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            // Claude
            else if (modelName.includes('claude-3-7-sonnet') || modelName === 'claude-3-7-sonnet-20250219') {
                modelName = 'Claude 3.7 Sonnet';
            } else if (modelName.includes('claude-3-5')) {
                modelName = 'Claude 3.5';
            } else if (modelName.includes('claude')) {
                modelName = modelName.replace('claude-', 'Claude ').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            // GPT
            else if (modelName === 'gpt-4o' || modelName.includes('gpt-4o')) {
                modelName = 'GPT-4o';
            } else if (modelName.includes('gpt-4')) {
                modelName = 'GPT-4';
            } else if (modelName.includes('gpt')) {
                modelName = modelName.replace('gpt-', 'GPT-').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            // Gemini
            else if (modelName.includes('gemini-2.5-pro') || modelName === 'gemini-2.5-pro') {
                modelName = 'Gemini 2.5 Pro';
            } else if (modelName.includes('gemini-2.0')) {
                modelName = 'Gemini 2.0';
            } else if (modelName.includes('gemini')) {
                modelName = modelName.replace('gemini-', 'Gemini ').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            // Outros - limpar formato t√©cnico
            else {
                // Remover sufixos de data e vers√£o
                modelName = modelName
                    .replace(/-\d{8}$/, '') // Remove datas como -20250219
                    .replace(/-\d{4}$/, '') // Remove anos como -2025
                    .replace(/-preview$/, '')
                    .replace(/-generate$/, '')
                    .replace(/-latest$/, '')
                    .replace(/-exp$/, '')
                    .replace(/-experimental$/, '')
                    .replace(/-default$/, '') // Remover "-default"
                    .replace(/voz-premium/gi, 'Voz Premium') // Formatar nome gen√©rico
                    .replace(/-/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
            }
            
            // Limpeza final: garantir que n√£o h√° refer√™ncias a fornecedores
            modelName = modelName
                .replace(/genaipro/gi, 'Voz Premium')
                .replace(/laozhang/gi, 'Provedor Externo')
                .replace(/openai/gi, '')
                .replace(/anthropic/gi, '')
                .replace(/google/gi, '')
                .replace(/\s+/g, ' ')
                .trim();
        }
        
        // Criar descri√ß√£o apenas com nome da ferramenta e modelo (sem fornecedor de API)
        let description = toolName;
        if (modelName) {
            description += ` - ${modelName}`;
        }
        
        // Limpeza final: garantir que n√£o h√° refer√™ncias a fornecedores na descri√ß√£o
        description = description
            .replace(/genaipro/gi, 'Voz Premium')
            .replace(/laozhang/gi, 'Provedor Externo')
            .replace(/laozhang\.ai/gi, 'Provedor Externo')
            .replace(/openai/gi, '')
            .replace(/anthropic/gi, '')
            .replace(/google/gi, '')
            .replace(/\s+/g, ' ')
            .trim();
        
        // Se a descri√ß√£o ficou vazia ou s√≥ com espa√ßos, usar apenas o nome da ferramenta
        if (!description || description.trim() === '' || description.trim() === '-') {
            description = toolName || 'Ferramenta';
        }
        
        // Registrar transa√ß√£o para hist√≥rico do usu√°rio
        const sanitizedDescription = sanitizeUserFacingText(description, toolName || 'Opera√ß√£o');
        await db.run(`
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description, admin_id)
            VALUES (?, ?, 'debit', ?, NULL)
        `, [userId, -creditsNeeded, sanitizedDescription]);

        return {
            success: true,
            creditsUsed: creditsNeeded,
            newBalance: newBalance
        };
    } catch (error) {
        console.error('‚ùå Erro ao verificar/debitar cr√©ditos:', error);
        throw error;
    }
};

/**
 * Reembolsa cr√©ditos ao usu√°rio em caso de erro
 */
const refundCredits = async (userId, creditsAmount, reason = 'Erro na opera√ß√£o') => {
    try {
        if (!creditsAmount || creditsAmount <= 0) {
            return { success: false, message: 'Valor inv√°lido' };
        }

        let userCredits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [userId]);
        
        if (!userCredits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [userId]);
            userCredits = { balance: 0 };
        }

        const newBalance = userCredits.balance + creditsAmount;
        await db.run(`
            UPDATE user_credits 
            SET balance = ?, updated_at = CURRENT_TIMESTAMP 
            WHERE user_id = ?
        `, [newBalance, userId]);

        // Registrar transa√ß√£o de reembolso
        const sanitizedReason = sanitizeUserFacingText(reason || 'Cr√©ditos reembolsados', 'Cr√©ditos reembolsados');
        await db.run(`
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description)
            VALUES (?, ?, 'refund', ?)
        `, [userId, creditsAmount, sanitizedReason]);

        return {
            success: true,
            creditsRefunded: creditsAmount,
            newBalance: newBalance
        };
    } catch (error) {
        console.error('‚ùå Erro ao reembolsar cr√©ditos:', error);
        throw error;
    }
};

// ================================================
// SISTEMA DE TTS (TEXT-TO-SPEECH) - FUN√á√ïES
// ================================================

// Armazenamento de jobs TTS em mem√≥ria
const ttsJobs = {};

// Limpar jobs antigos (mais de 1 hora)
setInterval(() => {
    const oneHourAgo = Date.now() - 3600000;
    for (const [jobId, job] of Object.entries(ttsJobs)) {
        if (job.createdAt && new Date(job.createdAt).getTime() < oneHourAgo) {
            delete ttsJobs[jobId];
        }
    }
}, 600000); // A cada 10 minutos

// Diret√≥rio tempor√°rio para √°udio
const TEMP_AUDIO_DIR = path.join(__dirname, 'temp_audio');
if (!fs.existsSync(TEMP_AUDIO_DIR)) {
    fs.mkdirSync(TEMP_AUDIO_DIR, { recursive: true });
}

// Modelos TTS v√°lidos
const VALID_TTS_MODELS = [
    'gemini-2.5-pro-preview-tts',
    'gemini-2.5-flash-preview-tts',
    'tts-1',
    'tts-1-hd',
    'voz-premium', // Nome gen√©rico para Voz Premium (n√£o expor fornecedor)
    'genaipro-default' // Mantido para compatibilidade, mas ser√° substitu√≠do por 'voz-premium'
];
const DEFAULT_TTS_MODEL = 'gemini-2.5-pro-preview-tts';
const FALLBACK_TTS_VOICE = 'zephyr';
const DEFAULT_TTS_SAMPLE_TEXT = 'LaCasa Dark A ferramenta de elite para canais dark.';

const validateTtsModel = (model) => {
    if (!model || !VALID_TTS_MODELS.includes(model)) {
        // Se for genaipro-default, converter para voz-premium
        if (model && (model.includes('genaipro') || model === 'genaipro-default')) {
            return 'voz-premium';
        }
        return DEFAULT_TTS_MODEL;
    }
    // Se for genaipro-default, converter para voz-premium
    if (model === 'genaipro-default') {
        return 'voz-premium';
    }
    return model;
};

// Fun√ß√£o auxiliar para dividir texto tipo CapCut (m√°x 500 chars por bloco, respeitando frases)
function splitLikeCapcut(text, maxLen = 500) {
    const sentences = text.split(/(?<=[.!?])\s+/);
    const blocks = [];
    let current = "";

    for (const sentence of sentences) {
        if (sentence.length > maxLen) {
            // Se uma frase sozinha ultrapassa o limite, divide por palavras
            const words = sentence.split(" ");
            let tempCurrent = "";
            for (const word of words) {
                if ((tempCurrent + " " + word).trim().length <= maxLen) {
                    tempCurrent += " " + word;
                } else {
                    if (tempCurrent.trim().length > 0) {
                        blocks.push(tempCurrent.trim());
                    }
                    tempCurrent = word;
                }
            }
            if (tempCurrent.trim().length > 0) {
                current = tempCurrent.trim();
            }
        } else {
            if ((current + " " + sentence).trim().length <= maxLen) {
                current += " " + sentence;
            } else {
                if (current.trim().length > 0) {
                    blocks.push(current.trim());
                }
                current = sentence;
            }
        }
    }
    if (current.trim().length > 0) {
        blocks.push(current.trim());
    }
    return blocks;
}

// Fun√ß√£o completa de divis√£o de texto do DARKSCRIPT (com prioridades de quebra)
function splitTextIntoChunks(text, charLimit) {
    const chunks = [];
    let remainingText = text.trim();

    while (remainingText.length > 0) {
        if (remainingText.length <= charLimit) {
            chunks.push(remainingText);
            break;
        }

        // Tenta usar 95% do limite para deixar margem e evitar cortes no meio de palavras
        const safeLimit = Math.floor(charLimit * 0.95);
        let chunk = remainingText.substring(0, safeLimit);
        let lastSentenceEnd = -1;
        let bestBreakPoint = -1;

        // PRIORIDADE 1: Procura por finais de par√°grafo (quebra de linha dupla)
        const doubleLineBreak = chunk.lastIndexOf('\n\n');
        if (doubleLineBreak > charLimit * 0.7) { // Se est√° nos √∫ltimos 30% do chunk
            bestBreakPoint = doubleLineBreak + 2;
        }

        // PRIORIDADE 2: Procura por finais de frase (ponto, exclama√ß√£o, interroga√ß√£o seguidos de espa√ßo)
        if (bestBreakPoint === -1) {
            const sentenceEnders = ['.', '!', '?'];
            for (const ender of sentenceEnders) {
                // Procura pelo padr√£o: "encerrador + espa√ßo" ou "encerrador + quebra de linha"
                const pattern1 = `${ender} `;
                const pattern2 = `${ender}\n`;
                const index1 = chunk.lastIndexOf(pattern1);
                const index2 = chunk.lastIndexOf(pattern2);
                const index = Math.max(index1, index2);
                
                if (index > lastSentenceEnd && index > charLimit * 0.7) {
                    lastSentenceEnd = index + (index === index1 ? pattern1.length : pattern2.length);
                    bestBreakPoint = lastSentenceEnd;
                }
            }
        }

        // PRIORIDADE 3: Procura por v√≠rgulas ou ponto-e-v√≠rgula (em posi√ß√µes adequadas)
        if (bestBreakPoint === -1) {
            const commaBreak = chunk.lastIndexOf(', ');
            const semicolonBreak = chunk.lastIndexOf('; ');
            const breakPoint = Math.max(commaBreak, semicolonBreak);
            
            if (breakPoint > charLimit * 0.8) { // Se est√° nos √∫ltimos 20% do chunk
                bestBreakPoint = breakPoint + 2;
            }
        }

        // PRIORIDADE 4: Se n√£o encontrou ponto de quebra natural, quebra na √∫ltima palavra
        if (bestBreakPoint === -1) {
            const lastSpace = chunk.lastIndexOf(' ');
            if (lastSpace !== -1 && lastSpace > charLimit * 0.5) {
                bestBreakPoint = lastSpace + 1;
            } else {
                // √öltimo recurso: quebra no limite exato (pode cortar palavra, mas √© raro)
                bestBreakPoint = safeLimit;
            }
        }

        // Se encontrou um ponto de quebra adequado, usa ele
        if (bestBreakPoint > 0 && bestBreakPoint <= safeLimit) {
            chunk = remainingText.substring(0, bestBreakPoint).trim();
        } else {
            // Fallback: usa o chunk at√© o limite seguro
            chunk = chunk.trim();
        }
        
        chunks.push(chunk);
        remainingText = remainingText.substring(chunk.length).trim();
    }

    return chunks.filter(Boolean); // Remove chunks vazios
}

// Fun√ß√£o para gerar √°udio usando OpenAI TTS
const generateOpenAiTtsAudio = async ({ apiKey, textInput, voiceName }) => {
    const MAX_RETRIES = 3;
    const RETRY_DELAY = 3000;
    
    const validOpenAiVoices = ['alloy', 'echo', 'fable', 'onyx', 'nova', 'shimmer'];
    
    // Mapeamento de vozes Gemini para OpenAI
    const voiceMapping = {
        'Zephyr': 'nova',
        'Puck': 'shimmer',
        'Charon': 'onyx',
        'Kore': 'nova',
        'Fenrir': 'echo',
        'Leda': 'alloy',
        'Orus': 'onyx',
        'Aoede': 'shimmer',
        'Callirrhoe': 'alloy',
        'Autonoe': 'nova',
        'Enceladus': 'shimmer',
        'Iapetus': 'echo',
        'Umbriel': 'alloy',
        'Algieba': 'onyx',
        'Despina': 'nova',
        'Erinome': 'shimmer',
        'Algenib': 'onyx',
        'Rasalgethi': 'echo',
        'Laomedeia': 'shimmer',
        'Achernar': 'nova',
        'Alnilam': 'onyx',
        'Schedar': 'echo',
        'Gacrux': 'onyx',
        'Pulcherrima': 'nova',
        'Achird': 'alloy',
        'Zubenelgenubi': 'alloy',
        'Vindemiatrix': 'shimmer',
        'Sadachbia': 'shimmer',
        'Sadaltager': 'onyx',
        'Sulafat': 'nova'
    };
    
    let openAiVoice = voiceMapping[voiceName] || 'alloy';
    if (validOpenAiVoices.includes(voiceName?.toLowerCase())) {
        openAiVoice = voiceName.toLowerCase();
    }
    
    const cleanText = textInput.trim().replace(/[\x00-\x1F\x7F]/g, '');
    if (cleanText.length === 0) {
        throw new Error('Texto de entrada est√° vazio ap√≥s limpeza');
    }
    
    if (cleanText.length > 4096) {
        throw new Error(`Texto muito longo (${cleanText.length} chars). Limite da API OpenAI √© 4096 caracteres.`);
    }
    
    const responseFormat = 'mp3';
    
    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
        try {
            const response = await axios.post(
                'https://api.openai.com/v1/audio/speech',
                {
                    model: 'tts-1-hd',
                    input: cleanText,
                    voice: openAiVoice,
                    response_format: responseFormat,
                    speed: 1.0
                },
                {
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    responseType: 'arraybuffer',
                    timeout: 300000
                }
            );
            
            if (!response.data || response.data.length === 0) {
                throw new Error('A API retornou uma resposta vazia');
            }
            
            const audioBuffer = Buffer.from(response.data);
            const audioBase64 = audioBuffer.toString('base64');
            
            return {
                audioBase64: audioBase64,
                usage: null,
                format: 'mp3'
            };
        } catch (error) {
            if (attempt < MAX_RETRIES - 1) {
                const delay = RETRY_DELAY * (attempt + 1);
                await new Promise(resolve => setTimeout(resolve, delay));
            } else {
                throw error;
            }
        }
    }
};

// Fun√ß√£o para gerar √°udio usando Voz Premium API (GenAIPro)
// Sistema ass√≠ncrono: cria task e consulta status
// Documenta√ß√£o: https://genaipro.vn/docs-api
const generateVoicePremiumTtsAudio = async ({ apiKey, textInput, voiceName }) => {
    const MAX_WAIT_TIME = 300000; // 5 minutos m√°ximo (algumas tasks podem demorar)
    const POLL_INTERVAL = 1500; // Verificar a cada 1.5 segundos (mais r√°pido para preview)
    
    // API Voz Premium (GenAIPro) conforme documenta√ß√£o
    // Base URL: https://genaipro.vn/api/v1
    const API_BASE = 'https://genaipro.vn/api/v1';
    
    const cleanText = textInput.trim();
    if (cleanText.length === 0) {
        throw new Error('Texto de entrada est√° vazio');
    }
    
    // Validar voice_id - se n√£o foi fornecido, usar um padr√£o
    if (!voiceName || voiceName.trim() === '' || voiceName === 'default') {
        console.warn('[La Casa Dark Core] Voice ID n√£o fornecido ou inv√°lido, tentando buscar vozes dispon√≠veis...');
        // Tentar buscar uma voz padr√£o
        try {
            const voicesResponse = await axios.get(`${API_BASE}/max/voices`, {
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                params: {
                    page: 1,
                    page_size: 1,
                    language: 'Portuguese'
                },
                timeout: 10000
            });
            
            if (voicesResponse?.data?.voice_list && voicesResponse.data.voice_list.length > 0) {
                voiceName = voicesResponse.data.voice_list[0].voice_id;
                console.log(`[La Casa Dark Core] Usando voz padr√£o: ${voiceName}`);
            } else {
                throw new Error('Nenhuma voz dispon√≠vel encontrada');
            }
        } catch (voiceError) {
            console.error('[La Casa Dark Core] Erro ao buscar voz padr√£o:', voiceError.message);
            throw new Error('Voice ID √© obrigat√≥rio. Configure uma voz premium no painel.');
        }
    }
    
    try {
        // Detectar tipo de voz: Labs (alfanum√©rica) ou Max (num√©rica)
        const isLabsVoice = voiceName && !/^\d+$/.test(voiceName);
        const voiceType = isLabsVoice ? 'Labs' : 'Max';
        
        console.log(`[La Casa Dark Core] Criando task TTS com voz: ${voiceName} (tipo: ${voiceType})`);
        console.log(`[La Casa Dark Core] Texto (primeiros 100 chars): ${cleanText.substring(0, 100)}...`);
        
        let taskResponse;
        let audioResult = null;
        
        // Headers de autentica√ß√£o conforme documenta√ß√£o GenAIPro
        const authHeaders = {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
        };
        
        // =========================================================
        // Se for voz LABS, usar endpoint Labs PRIMEIRO
        // =========================================================
        if (isLabsVoice) {
            console.log('[La Casa Dark Core] Voz Labs detectada, tentando POST /labs/task...');
            try {
                console.log(`[La Casa Dark Core] Tamanho do texto para Labs: ${cleanText.length} caracteres`);
                
                // Verificar se o texto n√£o est√° muito grande (algumas APIs t√™m limite)
                if (cleanText.length > 5000) {
                    console.warn(`[La Casa Dark Core] ‚ö†Ô∏è Texto muito grande (${cleanText.length} chars). A API Labs pode ter limites.`);
                }
                
                const labsTaskResponse = await axios.post(
                    `${API_BASE}/labs/task`,
                    {
                        input: cleanText,  // Labs usa "input" n√£o "text"
                        voice_id: voiceName,
                        model_id: 'eleven_multilingual_v2',
                        speed: 1.0  // Speed deve estar entre 0.7 e 1.2 (conforme API)
                    },
                    {
                        headers: authHeaders,
                        timeout: 60000, // Aumentar timeout para 60s para textos maiores
                        validateStatus: (status) => true
                    }
                );
                
                console.log('[La Casa Dark Core] Resposta /labs/task status:', labsTaskResponse.status);
                console.log('[La Casa Dark Core] Resposta /labs/task data:', JSON.stringify(labsTaskResponse.data).substring(0, 500));
                
                // Verificar se est√° em manuten√ß√£o
                if (labsTaskResponse.status === 503) {
                    const responseText = typeof labsTaskResponse.data === 'string' ? labsTaskResponse.data : '';
                    if (responseText.includes('Maintenance') || responseText.includes('B·∫£o Tr√¨') || responseText.includes('<!DOCTYPE')) {
                        console.log('[La Casa Dark Core] ‚ö†Ô∏è API Labs est√° em manuten√ß√£o');
                        throw new Error('O servi√ßo de voz est√° temporariamente em manuten√ß√£o. Por favor, tente novamente em alguns minutos.');
                    }
                }
                
                // Tratar erros HTTP antes de processar resposta
                if (labsTaskResponse.status === 400) {
                    const errorData = labsTaskResponse.data;
                    const errorMsg = errorData?.error || errorData?.message || errorData?.detail || 'Par√¢metros inv√°lidos';
                    console.error('[La Casa Dark Core] ‚ùå Labs retornou 400 (Bad Request):', errorMsg);
                    console.error('[La Casa Dark Core] ‚ùå Dados completos do erro:', JSON.stringify(errorData));
                    throw new Error(`Erro ao gerar √°udio: ${errorMsg}. Verifique se a voz e os par√¢metros est√£o corretos.`);
                }
                
                if (labsTaskResponse.status === 401 || labsTaskResponse.status === 403) {
                    const errorData = labsTaskResponse.data;
                    const errorMsg = errorData?.error || errorData?.message || 'N√£o autorizado';
                    console.error('[La Casa Dark Core] ‚ùå Labs retornou erro de autentica√ß√£o:', errorMsg);
                    throw new Error(`Erro de autentica√ß√£o: ${errorMsg}. Verifique sua chave de API.`);
                }
                
                if (labsTaskResponse.status >= 500 && labsTaskResponse.status !== 503) {
                    const errorData = labsTaskResponse.data;
                    const errorMsg = errorData?.error || errorData?.message || 'Erro interno do servidor';
                    console.error('[La Casa Dark Core] ‚ùå Labs retornou erro do servidor:', errorMsg);
                    throw new Error(`Erro no servidor da API: ${errorMsg}. Tente novamente em alguns instantes.`);
                }
                
                if (labsTaskResponse.status === 200 || labsTaskResponse.status === 201) {
                    const data = labsTaskResponse.data;
                    
                    console.log('[La Casa Dark Core] Resposta Labs completa:', JSON.stringify(data).substring(0, 500));
                    
                    // Verificar se j√° tem resultado direto (m√∫ltiplos formatos poss√≠veis)
                    const audioUrl = data.result || data.audio_url || data.url || data.output_url || data.file_url;
                    const status = (data.status || '').toLowerCase();
                    const successStatuses = ['completed', 'done', 'success', 'finished'];
                    
                    if (audioUrl) {
                        console.log('[La Casa Dark Core] ‚úÖ Task Labs j√° tem √°udio dispon√≠vel:', audioUrl);
                        
                        // Se for URL relativa, adicionar base URL
                        let fullAudioUrl = audioUrl;
                        if (audioUrl.startsWith('/')) {
                            fullAudioUrl = `https://genaipro.vn${audioUrl}`;
                        } else if (!audioUrl.startsWith('http')) {
                            fullAudioUrl = `${API_BASE.replace('/api/v1', '')}${audioUrl}`;
                        }
                        
                        const audioDownload = await axios.get(fullAudioUrl, {
                            responseType: 'arraybuffer',
                            timeout: 60000
                        });
                        return {
                            audioBase64: Buffer.from(audioDownload.data).toString('base64'),
                            usage: null,
                            format: 'mp3'
                        };
                    }
                    
                    // Se retornou task_id, fazer polling
                    if (data.task_id || data.id) {
                        const taskId = data.task_id || data.id;
                        console.log('[La Casa Dark Core] Labs Task criada:', taskId, '- Aguardando...');
                        
                        // Verifica√ß√£o imediata ap√≥s criar a task (algumas APIs retornam resultado s√≠ncrono)
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Aguardar 1s antes do primeiro poll
                        
                        const startTime = Date.now();
                        let pollCount = 0;
                        let lastStatus = null;
                        let statusChangeCount = 0;
                        let consecutiveProcessingCount = 0; // Contador de polls consecutivos em "processing"
                        
                        while (Date.now() - startTime < MAX_WAIT_TIME) {
                            pollCount++;
                            const elapsed = Math.floor((Date.now() - startTime) / 1000);
                            
                            // Log apenas a cada 5 polls para n√£o poluir muito
                            if (pollCount % 5 === 1 || elapsed > 30) {
                                console.log(`[La Casa Dark Core] Polling Labs #${pollCount} (${elapsed}s decorridos)...`);
                            }
                            
                            try {
                                const statusResponse = await axios.get(
                                    `${API_BASE}/labs/task/${taskId}`,
                                    { headers: authHeaders, timeout: 8000 } // Timeout reduzido para 8s
                                );
                                
                                if (statusResponse.data) {
                                    const taskData = statusResponse.data;
                                    const status = (taskData.status || taskData.state || '').toLowerCase();
                                    
                                    // Verificar se h√° erro mesmo quando status √© processing
                                    if (taskData.error && typeof taskData.error === 'string' && taskData.error.length > 0) {
                                        console.error('[La Casa Dark Core] ‚ùå Erro na task Labs:', taskData.error);
                                        throw new Error(taskData.error);
                                    }
                                    
                                    // PRIORIDADE 1: Verificar se tem resultado dispon√≠vel (mesmo que status ainda seja processing)
                                    // Algumas APIs retornam o resultado antes de mudar o status para "completed"
                                    // Verificar m√∫ltiplos campos poss√≠veis onde o resultado pode estar
                                    const audioUrl = taskData.result || taskData.audio_url || taskData.url || taskData.output_url || taskData.file_url;
                                    
                                    if (audioUrl && typeof audioUrl === 'string' && audioUrl.length > 0) {
                                        console.log('[La Casa Dark Core] ‚úÖ Resultado encontrado! Baixando √°udio (status:', status, ', URL:', audioUrl.substring(0, 100), ')');
                                        
                                        let fullAudioUrl = audioUrl.trim();
                                        if (!fullAudioUrl.startsWith('http')) {
                                            fullAudioUrl = `https://${fullAudioUrl}`;
                                        }
                                        
                                        try {
                                            const audioDownload = await axios.get(fullAudioUrl, {
                                                responseType: 'arraybuffer',
                                                timeout: 60000,
                                                validateStatus: (status) => status === 200
                                            });
                                            
                                            console.log('[La Casa Dark Core] ‚úÖ √Åudio baixado com sucesso (tamanho:', audioDownload.data.length, 'bytes)');
                                            
                                            return {
                                                audioBase64: Buffer.from(audioDownload.data).toString('base64'),
                                                usage: null,
                                                format: 'mp3'
                                            };
                                        } catch (downloadError) {
                                            // Se falhar o download, continuar polling
                                            console.log('[La Casa Dark Core] ‚è≥ URL ainda n√£o acess√≠vel (erro:', downloadError.message, '), continuando polling...');
                                        }
                                    } else if (pollCount % 20 === 0) {
                                        // A cada 20 polls, logar estrutura completa para debug
                                        console.log('[La Casa Dark Core] üîç Estrutura completa da resposta:', JSON.stringify(taskData).substring(0, 800));
                                    }
                                    
                                    // Detectar se status mudou
                                    if (lastStatus !== status) {
                                        lastStatus = status;
                                        statusChangeCount++;
                                        consecutiveProcessingCount = 0; // Reset contador
                                        console.log(`[La Casa Dark Core] Status mudou para: "${status}" (mudan√ßa #${statusChangeCount})`);
                                    } else if (status === 'processing') {
                                        consecutiveProcessingCount++;
                                    }
                                    
                                    // Log detalhado apenas quando necess√°rio
                                    const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                                    if (pollCount % 10 === 0 || elapsedSeconds > 30) {
                                        // Log completo da resposta para debug
                                        console.log(`[La Casa Dark Core] Labs Task ${taskId}:`, {
                                            status: status,
                                            hasResult: !!taskData.result,
                                            resultPreview: taskData.result ? taskData.result.substring(0, 100) : 'n√£o dispon√≠vel',
                                            elapsed: `${elapsedSeconds}s`,
                                            polls: pollCount,
                                            fullResponse: JSON.stringify(taskData).substring(0, 500)
                                        });
                                    }
                                    
                                    // Conforme documenta√ß√£o: quando status √© "completed", o campo "result" cont√©m a URL
                                    if (status === 'completed') {
                                        // Se chegou aqui e n√£o tem result, aguardar mais um pouco
                                        if (!audioUrl) {
                                            console.log('[La Casa Dark Core] ‚è≥ Status completed mas sem result ainda, aguardando...');
                                            await new Promise(resolve => setTimeout(resolve, 2000)); // Aguardar 2s e verificar novamente
                                            continue;
                                        }
                                    } else if (status === 'failed' || status === 'error' || status === 'failure') {
                                        const errorMsg = taskData.error || taskData.message || 'Task Labs falhou';
                                        console.error('[La Casa Dark Core] ‚ùå Task Labs falhou:', errorMsg);
                                        throw new Error(errorMsg);
                                    } else if (status === 'processing' || status === 'pending' || status === 'queued') {
                                        // Ainda processando, continuar aguardando
                                    } else {
                                        // Status desconhecido
                                        console.log(`[La Casa Dark Core] ‚ö†Ô∏è Status desconhecido: "${status}", continuando polling...`);
                                    }
                                }
                            } catch (pollError) {
                                // Se for erro de rede/timeout, continuar tentando
                                if (pollError.code === 'ECONNABORTED' || pollError.code === 'ETIMEDOUT') {
                                    console.log('[La Casa Dark Core] Timeout no polling, continuando...');
                                } else if (pollError.message && !pollError.message.includes('Task Labs falhou')) {
                                    console.log('[La Casa Dark Core] Erro no polling Labs:', pollError.message);
                                } else {
                                    // Se for erro de task falhada, propagar
                                    throw pollError;
                                }
                            }
                            
                            // Aguardar antes do pr√≥ximo poll (intervalo din√¢mico)
                            // Se est√° em processing h√° muito tempo, aumentar intervalo para n√£o sobrecarregar
                            const waitTime = consecutiveProcessingCount > 10 ? POLL_INTERVAL * 2 : POLL_INTERVAL;
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                        }
                        
                        // Timeout - task n√£o completou no tempo esperado
                        const totalSeconds = Math.floor((Date.now() - startTime) / 1000);
                        console.error(`[La Casa Dark Core] ‚ùå Timeout ap√≥s ${totalSeconds}s (${pollCount} tentativas). Task pode ainda estar processando.`);
                        throw new Error(`A gera√ß√£o de √°udio est√° demorando mais que o esperado (${totalSeconds}s). A task pode ainda estar processando. Tente novamente em alguns instantes.`);
                    }
                }
            } catch (labsError) {
                console.log('[La Casa Dark Core] Erro Labs:', labsError.message);
                throw labsError;
            }
        }
        
        // =========================================================
        // M√âTODO MAX: POST /max/tasks (para vozes Max/num√©ricas)
        // =========================================================
        console.log('[La Casa Dark Core] Tentando POST /max/tasks...');
        console.log(`[La Casa Dark Core] Tamanho do texto: ${cleanText.length} caracteres`);
        
        // Verificar se o texto n√£o est√° muito grande (algumas APIs t√™m limite)
        if (cleanText.length > 5000) {
            console.warn(`[La Casa Dark Core] ‚ö†Ô∏è Texto muito grande (${cleanText.length} chars). A API pode ter limites.`);
        }
        
        try {
            const maxTaskResponse = await axios.post(
                `${API_BASE}/max/tasks`,
                {
                    text: cleanText,
                    voice_id: voiceName,
                    model_id: 'speech-2.5-hd-preview',
                    speed: 1.0,
                    pitch: 0,
                    volume: 1.0,
                    language: 'Auto'
                },
                {
                    headers: authHeaders,
                    timeout: 60000, // Aumentar timeout para 60s para textos maiores
                    validateStatus: (status) => true // Aceitar qualquer status para tratar manualmente
                }
            );
            
            // Verificar se est√° em manuten√ß√£o (503)
            if (maxTaskResponse.status === 503) {
                const responseText = typeof maxTaskResponse.data === 'string' ? maxTaskResponse.data : '';
                if (responseText.includes('Maintenance') || responseText.includes('B·∫£o Tr√¨')) {
                    console.log('[La Casa Dark Core] ‚ö†Ô∏è API Max est√° em manuten√ß√£o');
                    throw new Error('O servi√ßo de Voz Premium est√° temporariamente em manuten√ß√£o. Por favor, tente novamente em alguns minutos.');
                }
            }
            
            console.log('[La Casa Dark Core] Resposta /max/tasks status:', maxTaskResponse.status);
            console.log('[La Casa Dark Core] Resposta /max/tasks data:', JSON.stringify(maxTaskResponse.data).substring(0, 500));
            
            // Tratar erros HTTP antes de processar resposta
            if (maxTaskResponse.status === 400) {
                const errorData = maxTaskResponse.data;
                const errorMsg = errorData?.error || errorData?.message || errorData?.detail || 'Par√¢metros inv√°lidos';
                console.error('[La Casa Dark Core] ‚ùå Erro 400 (Bad Request):', errorMsg);
                throw new Error(`Erro ao gerar √°udio: ${errorMsg}. Verifique se a voz e os par√¢metros est√£o corretos.`);
            }
            
            if (maxTaskResponse.status === 401 || maxTaskResponse.status === 403) {
                const errorData = maxTaskResponse.data;
                const errorMsg = errorData?.error || errorData?.message || 'N√£o autorizado';
                console.error('[La Casa Dark Core] ‚ùå Erro de autentica√ß√£o:', errorMsg);
                throw new Error(`Erro de autentica√ß√£o: ${errorMsg}. Verifique sua chave de API.`);
            }
            
            if (maxTaskResponse.status >= 500 && maxTaskResponse.status !== 503) {
                const errorData = maxTaskResponse.data;
                const errorMsg = errorData?.error || errorData?.message || 'Erro interno do servidor';
                console.error('[La Casa Dark Core] ‚ùå Erro do servidor:', errorMsg);
                throw new Error(`Erro no servidor da API: ${errorMsg}. Tente novamente em alguns instantes.`);
            }
            
            if (maxTaskResponse.status === 200 || maxTaskResponse.status === 201) {
                const data = maxTaskResponse.data;
                
                // Se j√° tem resultado direto
                if (data.result && data.status === 'completed') {
                    console.log('[La Casa Dark Core] ‚úÖ Task j√° completa, baixando √°udio...');
                    const audioDownload = await axios.get(data.result, {
                        responseType: 'arraybuffer',
                        timeout: 60000
                    });
                    return {
                        audioBase64: Buffer.from(audioDownload.data).toString('base64'),
                        usage: null,
                        format: 'mp3'
                    };
                }
                
                // Se retornou task_id, fazer polling
                if (data.id) {
                    const taskId = data.id;
                    console.log('[La Casa Dark Core] Task criada:', taskId, '- Aguardando processamento...');
                    
                    const startTime = Date.now();
                    while (Date.now() - startTime < MAX_WAIT_TIME) {
                        await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));
                        
                        try {
                            const statusResponse = await axios.get(
                                `${API_BASE}/max/tasks/${taskId}`,
                                { headers: authHeaders, timeout: 10000 }
                            );
                            
                            if (statusResponse.data) {
                                const taskData = statusResponse.data;
                                const status = taskData.status;
                                const percentage = taskData.process_percentage || 0;
                                
                                console.log(`[La Casa Dark Core] Task ${taskId}: ${status} (${percentage}%)`);
                                
                                if (status === 'completed') {
                                    if (taskData.result) {
                                        console.log('[La Casa Dark Core] ‚úÖ √Åudio pronto:', taskData.result);
                                        const audioDownload = await axios.get(taskData.result, {
                                            responseType: 'arraybuffer',
                                            timeout: 60000
                                        });
                                        return {
                                            audioBase64: Buffer.from(audioDownload.data).toString('base64'),
                                            usage: null,
                                            format: 'mp3'
                                        };
                                    }
                                } else if (status === 'failed' || status === 'error') {
                                    throw new Error(taskData.error || 'Task falhou');
                                }
                                // processing, pending - continuar polling
                            }
                        } catch (pollError) {
                            console.log('[La Casa Dark Core] Erro no polling:', pollError.message);
                        }
                    }
                    throw new Error('Timeout aguardando conclus√£o da task');
                }
            }
        } catch (maxTaskError) {
            console.log('[La Casa Dark Core] Erro /max/tasks:', maxTaskError.message);
            
            // Se for erro de manuten√ß√£o, propagar diretamente
            if (maxTaskError.message && maxTaskError.message.includes('manuten√ß√£o')) {
                throw maxTaskError;
            }
            
            if (maxTaskError.response) {
                console.log('[La Casa Dark Core] Status:', maxTaskError.response.status);
                console.log('[La Casa Dark Core] Data:', JSON.stringify(maxTaskError.response.data).substring(0, 300));
            }
        }
        
        // Se chegou aqui (vozes Max que falharam), nenhum m√©todo funcionou
        console.error('[La Casa Dark Core] Nenhum m√©todo de TTS funcionou');
        throw new Error('O servi√ßo de Voz Premium est√° temporariamente indispon√≠vel. Por favor, tente novamente em alguns minutos ou selecione uma voz online.');
        
    } catch (error) {
        console.error('[La Casa Dark Core] Erro ao gerar TTS:', error.message);
        
        // N√£o verificar mais status 503 aqui, deixar a mensagem de erro original passar
        if (error.response) {
            console.error('[La Casa Dark Core] Status:', error.response.status);
            console.error('[La Casa Dark Core] Data:', JSON.stringify(error.response.data).substring(0, 500));
        }
        
        // Se o erro j√° tem uma mensagem amig√°vel do catch anterior, manter
        if (error.message && !error.message.includes('AxiosError')) {
            throw error;
        }
        
        // Erro gen√©rico
        throw new Error('Erro ao gerar √°udio com Voz Premium. Verifique sua chave de API e tente novamente.');
    }
};

const generateLaozhangTtsAudio = async ({ apiKey, textInput, voiceName = 'alloy', speed = 1.0, model = 'tts-1' }) => {
    const cleanText = textInput.trim();
    if (!cleanText) {
        throw new Error('Texto de entrada vazio para gera√ß√£o de voz.');
    }

    const payload = {
        model: model,
        voice: voiceName || 'alloy',
        input: cleanText,
        speed: Math.min(Math.max(speed || 1.0, 0.25), 4.0)
    };

    try {
        console.log(`[DarkVoz TTS] Gerando √°udio com voz "${voiceName}" (speed ${payload.speed})`);
        const response = await axios.post(
            'https://api.laozhang.ai/v1/audio/speech',
            payload,
            {
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'Accept': 'audio/mpeg'
                },
                responseType: 'arraybuffer',
                timeout: 120000
            }
        );

        if (!response || !response.data) {
            throw new Error('Resposta vazia da API do provedor de voz ao gerar √°udio.');
        }

        const audioBuffer = Buffer.from(response.data);
        console.log(`[DarkVoz TTS] √Åudio gerado (${audioBuffer.length} bytes)`);
        return {
            audioBase64: audioBuffer.toString('base64'),
            mimeType: 'audio/mp3'
        };
    } catch (error) {
        console.error('[DarkVoz TTS] Erro ao gerar √°udio:', error.message);
        console.error('[DarkVoz TTS] Voz usada:', voiceName);
        if (error.response) {
            console.error('[DarkVoz TTS] Status:', error.response.status);
            const errorData = typeof error.response.data === 'string' ? error.response.data : JSON.stringify(error.response.data);
            console.error('[DarkVoz TTS] Data:', errorData.substring(0, 500));
            
            if (error.response.status === 401) {
                throw new Error('Chave do DarkVoz inv√°lida ou expirada. Atualize a chave no painel admin.');
            }
            if (error.response.status === 403) {
                throw new Error('Acesso negado pela API do DarkVoz. Verifique se a chave possui permiss√µes para TTS.');
            }
            if (error.response.status === 400) {
                // Erro 400 geralmente indica voz inv√°lida ou par√¢metros incorretos
                const errorMsg = errorData.toLowerCase();
                if (errorMsg.includes('voice') || errorMsg.includes('voz')) {
                    throw new Error(`Voz "${voiceName}" n√£o est√° dispon√≠vel ou √© inv√°lida. Verifique se a voz existe no DarkVoz e tente outra voz.`);
                }
                throw new Error(`Erro na requisi√ß√£o: ${errorData.substring(0, 200)}`);
            }
            if (error.response.status === 503) {
                throw new Error('O DarkVoz est√° temporariamente indispon√≠vel. Tente novamente em alguns minutos.');
            }
        }
        if (error.code === 'ECONNABORTED') {
            throw new Error('Timeout ao conectar com a API do DarkVoz. Tente novamente em instantes.');
        }
        throw new Error(error.message || 'Erro ao gerar √°udio com o DarkVoz.');
    }
};

// Fun√ß√£o principal para gerar TTS
const generateTtsAudio = async ({ apiKey, model, textInput, speakerVoiceMap, provider = 'gemini', speed = 1.0 }, retryCount = 0) => {
    // Se o provedor for OpenAI, usa a fun√ß√£o espec√≠fica
    if (provider === 'openai') {
        const voiceName = Array.from(speakerVoiceMap.values())[0] || 'alloy';
        return await generateOpenAiTtsAudio({ apiKey, textInput, voiceName });
    }
    
    // Se o provedor for Voz Premium (GenAIPro)
    if (provider === 'voice_premium' || provider === 'genaipro') {
        const voiceName = Array.from(speakerVoiceMap.values())[0] || 'default';
        return await generateVoicePremiumTtsAudio({ apiKey, textInput, voiceName });
    }
    
    // Gemini TTS - usar API oficial do Google Gemini
    if (provider === 'gemini') {
        return await generateGeminiTtsAudio({ apiKey, textInput });
    }

    if (provider === 'laozhang') {
        const voiceName = Array.from(speakerVoiceMap.values())[0] || 'alloy';
        return await generateLaozhangTtsAudio({ apiKey, textInput, voiceName, speed, model });
    }
    
    throw new Error(`Provedor TTS "${provider}" n√£o suportado. Use OpenAI, Voz Premium, Gemini ou DarkVoz.`);
};

// Fun√ß√£o para gerar TTS usando a API oficial do Google Cloud Text-to-Speech
// Nota: O Google Gemini n√£o tem TTS nativo, ent√£o usamos o Google Cloud Text-to-Speech API
// que pode usar a mesma chave de API do Google Cloud
const generateGeminiTtsAudio = async ({ apiKey, textInput }) => {
    const cleanText = textInput.trim();
    if (cleanText.length === 0) {
        throw new Error('Texto de entrada est√° vazia');
    }
    
    try {
        console.log('[La Casa Dark Core TTS] Gerando √°udio usando Text-to-Speech');
        
        // Usar Google Cloud Text-to-Speech API
        // Endpoint: https://texttospeech.googleapis.com/v1/text:synthesize
        // A chave do Google Cloud pode ser usada diretamente aqui
        const response = await axios.post(
            `https://texttospeech.googleapis.com/v1/text:synthesize?key=${encodeURIComponent(apiKey)}`,
            {
                input: {
                    text: cleanText
                },
                voice: {
                    languageCode: 'pt-BR',
                    name: 'pt-BR-Neural2-C', // Voz neural em portugu√™s brasileiro
                    ssmlGender: 'FEMALE' // NEUTRAL n√£o √© suportado, usar FEMALE ou MALE
                },
                audioConfig: {
                    audioEncoding: 'MP3',
                    speakingRate: 1.0,
                    pitch: 0.0,
                    volumeGainDb: 0.0
                }
            },
            {
                headers: {
                    'Content-Type': 'application/json'
                },
                timeout: 60000
            }
        );
        
        if (response.data && response.data.audioContent) {
            // O audioContent j√° vem em base64
            const audioBase64 = response.data.audioContent;
            
            console.log('[La Casa Dark Core TTS] √Åudio gerado com sucesso');
            return {
                audioBase64: audioBase64,
                mimeType: 'audio/mp3'
            };
        } else {
            throw new Error('Resposta da API n√£o cont√©m √°udio');
        }
    } catch (error) {
        console.error('[La Casa Dark Core TTS] Erro ao gerar √°udio:', error.message);
        
        if (error.response) {
            const status = error.response.status;
            const errorData = error.response.data;
            
            console.error('[La Casa Dark Core TTS] Status:', status);
            console.error('[La Casa Dark Core TTS] Error Data:', JSON.stringify(errorData).substring(0, 500));
            
            if (status === 401 || status === 403) {
                throw new Error('Chave de API do Google inv√°lida ou expirada. Verifique suas configura√ß√µes. A chave precisa ter a API Text-to-Speech habilitada.');
            }
            
            if (status === 429) {
                throw new Error('Limite de requisi√ß√µes excedido. Aguarde alguns instantes e tente novamente.');
            }
            
            let errorMessage = 'Erro ao gerar √°udio com Google Cloud Text-to-Speech';
            if (typeof errorData === 'object' && errorData.error) {
                errorMessage = errorData.error.message || errorData.error || errorMessage;
            } else if (typeof errorData === 'string') {
                errorMessage = errorData;
            }
            
            throw new Error(errorMessage);
        }
        
        if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {
            throw new Error('Timeout ao conectar com a API do Google. Tente novamente.');
        }
        
        throw error;
    }
};

// --- INICIALIZA√á√ÉO DO BANCO DE DADOS ---
(async () => {
    try {
        // Define o caminho do banco de dados, usando a vari√°vel de ambiente ou um padr√£o.
        const dbPath = process.env.DB_PATH || path.join(__dirname, 'data', 'lacasacorebd.db');
        
        // Garante que o diret√≥rio do banco de dados exista
        const dbDir = path.dirname(dbPath);
        if (!fs.existsSync(dbDir)) {
            fs.mkdirSync(dbDir, { recursive: true });
        }

        // Configurar SQLite para melhor performance
        db = await sqlite.open({
            filename: dbPath, // Usa o caminho definido
            driver: sqlite3.Database
        });

        // Otimiza√ß√µes de performance do SQLite
        await db.exec('PRAGMA journal_mode = WAL;'); // Write-Ahead Logging para melhor performance
        await db.exec('PRAGMA synchronous = NORMAL;'); // Balance entre seguran√ßa e performance
        await db.exec('PRAGMA cache_size = -64000;'); // 64MB de cache
        await db.exec('PRAGMA foreign_keys = ON;'); // Garantir integridade referencial
        await db.exec('PRAGMA temp_store = MEMORY;'); // Usar mem√≥ria para tempor√°rios

        console.log(`‚úÖ Conectado ao banco de dados em: ${dbPath}`);

        // --- CRIA√á√ÉO DAS TABELAS ---

        await db.exec(`
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                email TEXT NOT NULL UNIQUE,
                whatsapp TEXT,
                password_hash TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                isAdmin BOOLEAN NOT NULL DEFAULT 0,
                isBlocked BOOLEAN NOT NULL DEFAULT 0,
                isApproved BOOLEAN NOT NULL DEFAULT 0,
                last_login_at DATETIME,
                plan TEXT DEFAULT 'plan-free',
                subscription_plan TEXT DEFAULT 'plan-free'
            );
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS password_reset_tokens (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                token TEXT NOT NULL UNIQUE,
                expires_at DATETIME NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                used BOOLEAN NOT NULL DEFAULT 0,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            );
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS analysis_folders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS monitored_channels (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                channel_name TEXT NOT NULL,
                channel_url TEXT NOT NULL,
                last_checked DATETIME,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                UNIQUE(user_id, channel_url)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS analyzed_videos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                folder_id INTEGER,
                
                youtube_video_id TEXT NOT NULL,
                video_url TEXT,
                original_title TEXT,
                translated_title TEXT,
                original_views INTEGER,
                original_comments INTEGER,
                original_days INTEGER,
                original_thumbnail_url TEXT,
                
                detected_niche TEXT,
                detected_subniche TEXT,
                
                analysis_data_json TEXT, -- JSON com a 'analiseOriginal'
                
                analyzed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                FOREIGN KEY (folder_id) REFERENCES analysis_folders (id) ON DELETE SET NULL
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS generated_titles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                video_analysis_id INTEGER NOT NULL,
                title_text TEXT NOT NULL,
                model_used TEXT,
                pontuacao INTEGER DEFAULT 0,
                impact_score INTEGER DEFAULT NULL,
                explicacao TEXT,
                formula TEXT DEFAULT NULL,
                is_checked BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (video_analysis_id) REFERENCES analyzed_videos (id) ON DELETE CASCADE
            );
        `);

        // Migra√ß√£o: adicionar impact_score se n√£o existir (SCORE 2 - Impacto Visual)
        try {
            const tableInfo = await db.all("PRAGMA table_info(generated_titles)");
            const existingColumns = tableInfo.map(col => col.name);
            if (!existingColumns.includes('impact_score')) {
                await db.run('ALTER TABLE generated_titles ADD COLUMN impact_score INTEGER DEFAULT NULL');
                console.log('[MIGRATION] Adicionado campo impact_score em generated_titles');
            }
            if (!existingColumns.includes('formula')) {
                await db.run('ALTER TABLE generated_titles ADD COLUMN formula TEXT DEFAULT NULL');
                console.log('[MIGRATION] Adicionado campo formula em generated_titles');
            }
        } catch (migrationErr) {
            console.warn('[MIGRATION] Falha ao migrar generated_titles:', migrationErr.message);
        }
        
        // Tabelas para an√°lise de canais virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS channel_viral_analysis (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                channel_id TEXT NOT NULL,
                channel_name TEXT NOT NULL,
                channel_url TEXT NOT NULL,
                channel_handle TEXT,
                subscriber_count INTEGER,
                total_videos INTEGER,
                total_views INTEGER,
                channel_age_days INTEGER,
                channel_age_years REAL,
                avg_rpm_usd REAL,
                avg_rpm_brl REAL,
                niche TEXT,
                folder_id INTEGER,
                analysis_data_json TEXT,
                viral_insights_json TEXT,
                new_channel_insights_json TEXT,
                analyzed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                FOREIGN KEY (folder_id) REFERENCES analysis_folders (id) ON DELETE SET NULL,
                UNIQUE(user_id, channel_id)
            );
        `);
        
        // Migra√ß√£o: Adicionar campos novos se n√£o existirem
        try {
            const tableInfo = await db.all("PRAGMA table_info(channel_viral_analysis)");
            const existingColumns = tableInfo.map(col => col.name);
            
            if (!existingColumns.includes('channel_age_days')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN channel_age_days INTEGER');
                console.log('[MIGRATION] Adicionado campo channel_age_days');
            }
            if (!existingColumns.includes('channel_age_years')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN channel_age_years REAL');
                console.log('[MIGRATION] Adicionado campo channel_age_years');
            }
            if (!existingColumns.includes('avg_rpm_usd')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN avg_rpm_usd REAL');
                console.log('[MIGRATION] Adicionado campo avg_rpm_usd');
            }
            if (!existingColumns.includes('avg_rpm_brl')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN avg_rpm_brl REAL');
                console.log('[MIGRATION] Adicionado campo avg_rpm_brl');
            }
            if (!existingColumns.includes('niche')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN niche TEXT');
                console.log('[MIGRATION] Adicionado campo niche');
            }
            if (!existingColumns.includes('folder_id')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN folder_id INTEGER');
                console.log('[MIGRATION] Adicionado campo folder_id');
            }
            if (!existingColumns.includes('new_channel_insights_json')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN new_channel_insights_json TEXT');
                console.log('[MIGRATION] Adicionado campo new_channel_insights_json');
            }
            if (!existingColumns.includes('subniche')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN subniche TEXT');
                console.log('[MIGRATION] Adicionado campo subniche');
            }
            if (!existingColumns.includes('total_revenue_usd')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN total_revenue_usd REAL');
                console.log('[MIGRATION] Adicionado campo total_revenue_usd');
            }
            if (!existingColumns.includes('total_revenue_brl')) {
                await db.run('ALTER TABLE channel_viral_analysis ADD COLUMN total_revenue_brl REAL');
                console.log('[MIGRATION] Adicionado campo total_revenue_brl');
            }
        } catch (migrationErr) {
            console.error('[MIGRATION] Erro ao adicionar campos:', migrationErr);
            // N√£o bloquear se a migra√ß√£o falhar, os campos podem j√° existir
        }

        await db.exec(`
            CREATE TABLE IF NOT EXISTS channel_viral_videos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                analysis_id INTEGER NOT NULL,
                video_id TEXT NOT NULL,
                video_url TEXT NOT NULL,
                title TEXT NOT NULL,
                description TEXT,
                thumbnail_url TEXT,
                view_count INTEGER,
                like_count INTEGER,
                comment_count INTEGER,
                published_at DATETIME,
                duration TEXT,
                tags_json TEXT,
                category_id INTEGER,
                viral_score REAL,
                analysis_notes TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (analysis_id) REFERENCES channel_viral_analysis (id) ON DELETE CASCADE,
                UNIQUE(analysis_id, video_id)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS channel_viral_comments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                video_id INTEGER NOT NULL,
                comment_id TEXT NOT NULL,
                author_name TEXT,
                author_channel_id TEXT,
                text TEXT NOT NULL,
                like_count INTEGER DEFAULT 0,
                published_at DATETIME,
                sentiment TEXT,
                keywords_json TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (video_id) REFERENCES channel_viral_videos (id) ON DELETE CASCADE,
                UNIQUE(video_id, comment_id)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS channel_viral_insights (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                analysis_id INTEGER NOT NULL,
                insight_type TEXT NOT NULL,
                insight_title TEXT NOT NULL,
                insight_content TEXT NOT NULL,
                supporting_data_json TEXT,
                priority INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (analysis_id) REFERENCES channel_viral_analysis (id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS generated_thumbnails (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                video_analysis_id INTEGER NOT NULL,
                base_title TEXT, 
                description TEXT,
                hook_phrases_json TEXT,
                generated_image_base64 TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (video_analysis_id) REFERENCES analyzed_videos (id) ON DELETE CASCADE
            );
            
            CREATE TABLE IF NOT EXISTS thumbnail_references (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                thumbnail_base64 TEXT NOT NULL,
                folder_id INTEGER,
                channel_name TEXT,
                niche TEXT,
                subniche TEXT,
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                FOREIGN KEY (folder_id) REFERENCES analysis_folders (id) ON DELETE SET NULL
            );
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS thumbnail_style_prompts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                niche TEXT,
                subniche TEXT,
                folder_id INTEGER,
                standard_prompt TEXT NOT NULL,
                analyzed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                FOREIGN KEY (folder_id) REFERENCES analysis_folders (id) ON DELETE SET NULL
            );
            
            -- Criar √≠ndice para melhorar performance nas buscas
            CREATE INDEX IF NOT EXISTS idx_thumbnail_style_prompts_user_niche ON thumbnail_style_prompts(user_id, niche, subniche, folder_id);
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS generated_videos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                operation_id TEXT UNIQUE NOT NULL,
                video_uri TEXT NOT NULL,
                prompt TEXT,
                model TEXT,
                aspect_ratio TEXT,
                resolution TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            );
        `);
        
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_api_keys (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                service_name TEXT NOT NULL, 
                api_key TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                UNIQUE(user_id, service_name)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS pinned_videos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                monitored_channel_id INTEGER NOT NULL,
                youtube_video_id TEXT NOT NULL,
                title TEXT,
                thumbnail_url TEXT,
                pinned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                FOREIGN KEY (monitored_channel_id) REFERENCES monitored_channels (id) ON DELETE CASCADE,
                UNIQUE(user_id, monitored_channel_id, youtube_video_id)
            );
        `);

        // --- CORRE√á√ÉO DO BANCO DE DADOS (MINI-MIGRA√á√ÉO) ---
        const usersInfo = await db.all("PRAGMA table_info(users)");
        if (!usersInfo.some(c => c.name === 'isApproved')) {
            console.log('MIGRATION: Adding column "isApproved" to "users"...');
            await db.exec('ALTER TABLE users ADD COLUMN isApproved BOOLEAN NOT NULL DEFAULT 0');
        }
        if (!usersInfo.some(c => c.name === 'last_login_at')) {
            console.log('MIGRATION: Adding column "last_login_at" to "users"...');
            await db.exec('ALTER TABLE users ADD COLUMN last_login_at DATETIME');
        }
        if (!usersInfo.some(c => c.name === 'plan')) {
            console.log('MIGRATION: Adding column "plan" to "users"...');
            await db.exec('ALTER TABLE users ADD COLUMN plan TEXT DEFAULT "plan-free"');
        }
        if (!usersInfo.some(c => c.name === 'subscription_plan')) {
            console.log('MIGRATION: Adding column "subscription_plan" to "users"...');
            await db.exec('ALTER TABLE users ADD COLUMN subscription_plan TEXT DEFAULT "plan-free"');
        }

        const analyzedVideosInfo = await db.all("PRAGMA table_info(analyzed_videos)");
        const analyzedVideosColumns = {
            video_url: 'TEXT',
            folder_id: 'INTEGER REFERENCES analysis_folders(id) ON DELETE SET NULL',
            translated_title: 'TEXT',
            original_views: 'INTEGER',
            original_comments: 'INTEGER',
            original_days: 'INTEGER',
            original_thumbnail_url: 'TEXT',
            analysis_data_json: 'TEXT'
        };
        for (const [col, type] of Object.entries(analyzedVideosColumns)) {
            if (!analyzedVideosInfo.some(c => c.name === col)) {
                console.log(`MIGRATION: Adding column "${col}" to "analyzed_videos"...`);
                await db.exec(`ALTER TABLE analyzed_videos ADD COLUMN ${col} ${type}`);
            }
        }

        const generatedTitlesInfo = await db.all("PRAGMA table_info(generated_titles)");
        const generatedTitlesColumns = {
            pontuacao: 'INTEGER DEFAULT 0',
            explicacao: 'TEXT',
            is_checked: 'BOOLEAN DEFAULT 0'
        };
        for (const [col, type] of Object.entries(generatedTitlesColumns)) {
            if (!generatedTitlesInfo.some(c => c.name === col)) {
                console.log(`MIGRATION: Adding column "${col}" to "generated_titles"...`);
                await db.exec(`ALTER TABLE generated_titles ADD COLUMN ${col} ${type}`);
            }
        }
        
        // Criar tabela de limites customizados de armazenamento
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_storage_limits (
                user_id INTEGER PRIMARY KEY,
                custom_limit INTEGER NOT NULL,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            )
        `);
        
        // Criar tabela para rastrear armazenamento por usu√°rio
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_storage (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                file_path TEXT NOT NULL,
                file_size INTEGER NOT NULL,
                file_type TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            )
        `);
        
        // Criar √≠ndice para melhor performance
        await db.exec(`
            CREATE INDEX IF NOT EXISTS idx_user_storage_user_id ON user_storage(user_id)
        `);
        
        // Migra√ß√£o: adicionar coluna updated_at se n√£o existir
        try {
            const userStorageInfo = await db.all("PRAGMA table_info(user_storage)");
            if (!userStorageInfo.some(c => c.name === 'updated_at')) {
                console.log('MIGRATION: Adicionando coluna "updated_at" √† tabela "user_storage"...');
                await db.exec('ALTER TABLE user_storage ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP');
            }
        } catch (err) {
            // Ignorar se j√° existe
            if (!/duplicate column name/i.test(err.message)) {
                console.error('[MIGRATION] Erro ao adicionar coluna updated_at:', err);
            }
        }
        
        // Migra√ß√£o: adicionar colunas para 3 prompts no thumbnail_style_prompts
        try {
            const thumbnailStylePromptsInfo = await db.all("PRAGMA table_info(thumbnail_style_prompts)");
            const thumbnailStylePromptsColumns = {
                prompt_1: 'TEXT',
                prompt_2: 'TEXT',
                prompt_3: 'TEXT',
                prompt_selected: 'INTEGER DEFAULT 1'
            };
            for (const [col, type] of Object.entries(thumbnailStylePromptsColumns)) {
                if (!thumbnailStylePromptsInfo.some(c => c.name === col)) {
                    console.log(`MIGRATION: Adicionando coluna "${col}" √† tabela "thumbnail_style_prompts"...`);
                    await db.exec(`ALTER TABLE thumbnail_style_prompts ADD COLUMN ${col} ${type}`);
                }
            }
            // Migrar dados existentes: se standard_prompt existe mas prompt_1 n√£o, copiar
            const hasPrompt1 = thumbnailStylePromptsInfo.some(c => c.name === 'prompt_1');
            const hasStandardPrompt = thumbnailStylePromptsInfo.some(c => c.name === 'standard_prompt');
            if (!hasPrompt1 && hasStandardPrompt) {
                console.log('MIGRATION: Migrando dados de standard_prompt para prompt_1...');
                await db.exec(`UPDATE thumbnail_style_prompts SET prompt_1 = standard_prompt, prompt_selected = 1 WHERE prompt_1 IS NULL`);
            }
        } catch (err) {
            if (!/duplicate column name/i.test(err.message)) {
                console.error('[MIGRATION] Erro ao adicionar colunas de prompts:', err);
            }
        }
        
        // Criar tabela de cr√©ditos por plano
        await db.exec(`
            CREATE TABLE IF NOT EXISTS plan_credits (
                plan_name TEXT PRIMARY KEY,
                monthly_credits INTEGER NOT NULL DEFAULT 0,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Inicializar cr√©ditos padr√£o dos planos
        const defaultPlanCredits = {
            'plan-free': 100,
            'plan-start': 1000,
            'plan-turbo': 2500,
            'plan-master': 5000,
            'plan-start-annual': 1000, // Mensal (12.000/12)
            'plan-turbo-annual': 2500, // Mensal (30.000/12)
            'plan-master-annual': 5000 // Mensal (60.000/12)
        };
        
        for (const [plan, credits] of Object.entries(defaultPlanCredits)) {
            await db.run(`
                INSERT OR IGNORE INTO plan_credits (plan_name, monthly_credits)
                VALUES (?, ?)
            `, [plan, credits]);
        }
        
        // Criar tabela de renova√ß√£o de cr√©ditos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS credit_renewals (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                plan_name TEXT NOT NULL,
                credits_added INTEGER NOT NULL,
                renewal_date DATETIME NOT NULL,
                next_renewal_date DATETIME,
                is_annual BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            )
        `);
        
        // Criar tabela de permiss√µes de planos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS plan_permissions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                plan_name TEXT NOT NULL,
                feature_name TEXT NOT NULL,
                is_allowed BOOLEAN DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(plan_name, feature_name)
            )
        `);
        
        // Criar tabela de notifica√ß√µes
        await db.exec(`
            CREATE TABLE IF NOT EXISTS notifications (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                title TEXT NOT NULL,
                message TEXT NOT NULL,
                type TEXT DEFAULT 'info',
                is_read BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
            )
        `);
        
        // Criar tabela de usu√°rios fict√≠cios
        await db.exec(`
            CREATE TABLE IF NOT EXISTS fake_users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                email TEXT NOT NULL,
                type TEXT DEFAULT 'purchase',
                plan_name TEXT DEFAULT NULL,
                is_active BOOLEAN DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Migra√ß√£o: adicionar coluna plan_name se n√£o existir
        try {
            const fakeUsersInfo = await db.all("PRAGMA table_info(fake_users)");
            if (!fakeUsersInfo.some(c => c.name === 'plan_name')) {
                console.log('MIGRATION: Adding column "plan_name" to "fake_users"...');
                await db.exec('ALTER TABLE fake_users ADD COLUMN plan_name TEXT DEFAULT NULL');
            }
        } catch (err) {
            // Ignorar se j√° existe
        }
        
        // Criar tabela de configura√ß√µes de notifica√ß√µes
        await db.exec(`
            CREATE TABLE IF NOT EXISTS notification_config (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Criar tabela de loops ativos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS active_loops (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                loop_type TEXT NOT NULL UNIQUE,
                is_active BOOLEAN DEFAULT 0,
                interval_seconds INTEGER DEFAULT 5,
                started_at DATETIME,
                stopped_at DATETIME,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Inicializar permiss√µes padr√£o
        const defaultFeatures = [
            'video_analyzer',
            'niche_explorer',
            'script_generator',
            'voice_generator',
            'image_generator',
            'video_generator',
            'youtube_integration',
            'api_propria',
            'batch_images',
            'analytics',
            'viral_library'
        ];
        
        const defaultPermissions = {
            'plan-free': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': false,
                'image_generator': false,
                'video_generator': false,
                'youtube_integration': false,
                'api_propria': false,
                'batch_images': false,
                'analytics': true,
                'viral_library': true
            },
            'plan-start': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': false,
                'api_propria': false,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-turbo': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': false,
                'api_propria': false,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-master': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': true,
                'api_propria': true,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-start-annual': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': true,
                'api_propria': true,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-turbo-annual': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': true,
                'api_propria': true,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            },
            'plan-master-annual': {
                'video_analyzer': true,
                'niche_explorer': true,
                'script_generator': true,
                'voice_generator': true,
                'image_generator': true,
                'video_generator': true,
                'youtube_integration': true,
                'api_propria': true,
                'batch_images': true,
                'analytics': true,
                'viral_library': true
            }
        };
        
        for (const [plan, features] of Object.entries(defaultPermissions)) {
            for (const [feature, allowed] of Object.entries(features)) {
                await db.run(`
                    INSERT OR IGNORE INTO plan_permissions (plan_name, feature_name, is_allowed)
                    VALUES (?, ?, ?)
                `, [plan, feature, allowed ? 1 : 0]);
            }
        }
        // Migra√ß√£o: Corrigir constraint UNIQUE em monitored_channels (permitir m√∫ltiplos canais por usu√°rio)
        try {
            const monitoredChannelsInfo = await db.all("PRAGMA table_info(monitored_channels)");
            const tableExists = monitoredChannelsInfo.length > 0;
            
            if (tableExists) {
                // Verificar schema atual da tabela
                const tableSchema = await db.get("SELECT sql FROM sqlite_master WHERE type='table' AND name='monitored_channels'");
                const schemaSql = (tableSchema?.sql || '').toUpperCase();
                
                console.log('[MIGRATION] Schema atual de monitored_channels:', schemaSql.substring(0, 200));
                
                // Se a constraint UNIQUE est√° apenas em channel_url (sem user_id), precisamos recriar
                if (schemaSql.includes('CHANNEL_URL') && schemaSql.includes('UNIQUE') && !schemaSql.includes('UNIQUE(USER_ID, CHANNEL_URL)')) {
                    console.log('[MIGRATION] Detectada constraint UNIQUE incorreta. Recriando tabela com UNIQUE(user_id, channel_url)...');
                    try {
                        // Criar nova tabela com constraint correta
                        await db.exec(`CREATE TABLE monitored_channels_new (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            user_id INTEGER NOT NULL,
                            channel_name TEXT NOT NULL,
                            channel_url TEXT NOT NULL,
                            last_checked DATETIME,
                            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                            FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                            UNIQUE(user_id, channel_url)
                        )`);
                        
                        // Copiar dados existentes (ignorar duplicatas se houver)
                        try {
                            await db.exec(`INSERT INTO monitored_channels_new (id, user_id, channel_name, channel_url, last_checked, created_at) 
                                         SELECT id, user_id, channel_name, channel_url, last_checked, created_at 
                                         FROM monitored_channels`);
                            console.log('[MIGRATION] Dados copiados com sucesso.');
                        } catch (copyErr) {
                            console.warn('[MIGRATION] Alguns dados podem ter duplicatas, tentando inserir apenas √∫nicos...', copyErr.message);
                            // Tentar inserir apenas registros √∫nicos
                            const existingChannels = await db.all('SELECT DISTINCT user_id, channel_url, MIN(id) as id, channel_name, last_checked, created_at FROM monitored_channels GROUP BY user_id, channel_url');
                            for (const channel of existingChannels) {
                                try {
                                    await db.run('INSERT INTO monitored_channels_new (id, user_id, channel_name, channel_url, last_checked, created_at) VALUES (?, ?, ?, ?, ?, ?)',
                                        [channel.id, channel.user_id, channel.channel_name, channel.channel_url, channel.last_checked, channel.created_at]);
                                } catch (insErr) {
                                    console.warn(`[MIGRATION] Erro ao inserir canal ${channel.id}:`, insErr.message);
                                }
                            }
                        }
                        
                        // Dropar tabela antiga
                        await db.exec('DROP TABLE monitored_channels');
                        
                        // Renomear nova tabela
                        await db.exec('ALTER TABLE monitored_channels_new RENAME TO monitored_channels');
                        
                        console.log('[MIGRATION] ‚úÖ Tabela monitored_channels recriada com sucesso com constraint UNIQUE(user_id, channel_url).');
                    } catch (recreateErr) {
                        console.error('[MIGRATION] ‚ùå Erro ao recriar tabela monitored_channels:', recreateErr.message);
                        // Tentar criar √≠ndice √∫nico como fallback
                        try {
                            await db.exec('CREATE UNIQUE INDEX IF NOT EXISTS idx_monitored_channels_user_url ON monitored_channels(user_id, channel_url)');
                            console.log('[MIGRATION] ‚úÖ √çndice √∫nico criado como fallback.');
                        } catch (idxErr) {
                            console.warn('[MIGRATION] ‚ö†Ô∏è N√£o foi poss√≠vel criar √≠ndice √∫nico:', idxErr.message);
                        }
                    }
                } else {
                    // Garantir que o √≠ndice √∫nico correto existe
                    try {
                        await db.exec('CREATE UNIQUE INDEX IF NOT EXISTS idx_monitored_channels_user_url ON monitored_channels(user_id, channel_url)');
                        console.log('[MIGRATION] ‚úÖ √çndice √∫nico verificado/criado.');
                    } catch (idxErr) {
                        // √çndice j√° existe ou h√° outro problema, continuar
                        console.log('[MIGRATION] ‚ÑπÔ∏è √çndice √∫nico j√° existe ou constraint j√° est√° correta.');
                    }
                }
            }
        } catch (migErr) {
            console.error('[MIGRATION] ‚ùå Erro na migra√ß√£o de monitored_channels:', migErr.message);
        }

        const pinnedVideosInfo = await db.all("PRAGMA table_info(pinned_videos)");
        if (!pinnedVideosInfo.some(c => c.name === 'monitored_channel_id')) {
            console.log('MIGRATION: Adding column "monitored_channel_id" to "pinned_videos"...');
            // This is a simplified migration. In a real app, you'd handle existing data.
            await db.exec('DROP TABLE IF EXISTS pinned_videos');
            await db.exec(`
                CREATE TABLE pinned_videos (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    monitored_channel_id INTEGER NOT NULL,
                    youtube_video_id TEXT NOT NULL,
                    title TEXT,
                    thumbnail_url TEXT,
                    pinned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    FOREIGN KEY (monitored_channel_id) REFERENCES monitored_channels (id) ON DELETE CASCADE,
                    UNIQUE(user_id, monitored_channel_id, youtube_video_id)
                );
            `);
        }

        // --- CRIA√á√ÉO DAS NOVAS TABELAS PARA ANALYTICS, BIBLIOTECA E INTEGRA√á√ÉO ---
        
        // Sistema de Analytics e Tracking
        await db.exec(`
            CREATE TABLE IF NOT EXISTS video_tracking (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                analysis_id INTEGER,
                youtube_video_id TEXT,
                title_used TEXT,
                thumbnail_used TEXT,
                predicted_ctr REAL,
                predicted_views INTEGER,
                actual_views INTEGER DEFAULT 0,
                actual_ctr REAL DEFAULT 0,
                actual_likes INTEGER DEFAULT 0,
                actual_comments INTEGER DEFAULT 0,
                revenue_estimate REAL DEFAULT 0,
                published_at DATETIME,
                tracked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (analysis_id) REFERENCES analyzed_videos(id) ON DELETE SET NULL
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS analytics_snapshots (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                video_tracking_id INTEGER,
                views INTEGER,
                likes INTEGER,
                comments INTEGER,
                ctr REAL,
                snapshot_date DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (video_tracking_id) REFERENCES video_tracking(id) ON DELETE CASCADE
            );
        `);

        // Biblioteca de T√≠tulos Virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_titles_library (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                title TEXT NOT NULL,
                niche TEXT,
                subniche TEXT,
                original_views INTEGER,
                original_ctr REAL,
                formula_type TEXT,
                keywords TEXT,
                viral_score INTEGER,
                is_favorite INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS title_templates (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                template_name TEXT NOT NULL,
                template_pattern TEXT NOT NULL,
                niche TEXT,
                subniche TEXT,
                usage_count INTEGER DEFAULT 0,
                success_rate REAL DEFAULT 0,
                is_public INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Biblioteca de Thumbnails Virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_thumbnails_library (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                thumbnail_url TEXT,
                thumbnail_description TEXT,
                niche TEXT,
                subniche TEXT,
                original_views INTEGER,
                original_ctr REAL,
                style TEXT,
                elements TEXT,
                viral_score INTEGER,
                is_favorite INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS thumbnail_templates (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                template_name TEXT NOT NULL,
                template_description TEXT NOT NULL,
                niche TEXT,
                subniche TEXT,
                style TEXT,
                usage_count INTEGER DEFAULT 0,
                success_rate REAL DEFAULT 0,
                is_public INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Integra√ß√£o YouTube API
        await db.exec(`
            CREATE TABLE IF NOT EXISTS youtube_integrations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                channel_id TEXT,
                channel_name TEXT,
                access_token TEXT,
                refresh_token TEXT,
                token_expires_at DATETIME,
                is_active INTEGER DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
            
            -- Criar √≠ndice para melhor performance (sem UNIQUE para permitir m√∫ltiplos canais)
            CREATE INDEX IF NOT EXISTS idx_youtube_integrations_user_channel 
            ON youtube_integrations(user_id, channel_id);
        `);

        // Sistema de Cr√©ditos
        await db.exec(`
            CREATE TABLE IF NOT EXISTS api_providers (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                provider TEXT NOT NULL,
                model TEXT NOT NULL,
                api_key TEXT NOT NULL,
                unit_type TEXT NOT NULL DEFAULT 'tokens',
                unit_size INTEGER NOT NULL DEFAULT 1000,
                real_cost_per_unit REAL NOT NULL DEFAULT 0.0,
                credits_per_unit REAL NOT NULL DEFAULT 1.0,
                markup REAL NOT NULL DEFAULT 1.0,
                is_premium INTEGER NOT NULL DEFAULT 0,
                is_active INTEGER NOT NULL DEFAULT 1,
                is_default INTEGER NOT NULL DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_credits (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL UNIQUE,
                balance REAL NOT NULL DEFAULT 0.0,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS credit_transactions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                amount REAL NOT NULL,
                transaction_type TEXT NOT NULL,
                description TEXT,
                admin_id INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (admin_id) REFERENCES users(id)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS credit_usage (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                api_provider_id INTEGER NOT NULL,
                credits_used REAL NOT NULL,
                units_consumed REAL NOT NULL,
                operation_type TEXT NOT NULL,
                details TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (api_provider_id) REFERENCES api_providers(id)
            );
        `);

        // Tabela de configura√ß√µes da aplica√ß√£o
        await db.exec(`
            CREATE TABLE IF NOT EXISTS app_settings (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        `);

        // Tabela de prefer√™ncias do usu√°rio
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_preferences (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL UNIQUE,
                use_credits_instead_of_own_api INTEGER NOT NULL DEFAULT 0,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Inicializar configura√ß√µes padr√£o
        try {
            const initialBonus = await db.get("SELECT value FROM app_settings WHERE key = 'initial_bonus_credits'");
            if (!initialBonus) {
                await db.run("INSERT INTO app_settings (key, value) VALUES ('initial_bonus_credits', '0')");
            }
            
            const ttsMultiplier = await db.get("SELECT value FROM app_settings WHERE key = 'tts_credits_multiplier'");
            if (!ttsMultiplier) {
                await db.run("INSERT INTO app_settings (key, value) VALUES ('tts_credits_multiplier', '1.0')");
            }
            
            const laozhangUseAsDefault = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
            if (!laozhangUseAsDefault) {
                await db.run("INSERT INTO app_settings (key, value) VALUES ('laozhang_use_as_default', 'false')");
            }
        } catch (e) {
            console.log('Configura√ß√µes j√° inicializadas ou erro:', e);
        }

        // Criar √≠ndices para melhor performance
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_user_credits_user_id ON user_credits(user_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_id ON credit_transactions(user_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_user_preferences_user_id ON user_preferences(user_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_transactions_created_at ON credit_transactions(created_at);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_usage_user_id ON credit_usage(user_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_usage_api_provider_id ON credit_usage(api_provider_id);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_credit_usage_created_at ON credit_usage(created_at);`);
        await db.exec(`CREATE INDEX IF NOT EXISTS idx_api_providers_is_active ON api_providers(is_active);`);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS scheduled_posts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                youtube_integration_id INTEGER,
                video_file_path TEXT,
                title TEXT NOT NULL,
                description TEXT,
                tags TEXT,
                thumbnail_url TEXT,
                scheduled_time DATETIME NOT NULL,
                status TEXT DEFAULT 'pending',
                published_video_id TEXT,
                error_message TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (youtube_integration_id) REFERENCES youtube_integrations(id) ON DELETE CASCADE
            );
        `);

        // === PARTE 2: TABELAS PARA MONITORAMENTO AUTOM√ÅTICO ===
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_alerts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                competitor_channel_id TEXT,
                competitor_channel_name TEXT,
                video_id TEXT NOT NULL,
                video_title TEXT,
                video_url TEXT,
                views INTEGER,
                views_per_day REAL,
                detected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                notified INTEGER DEFAULT 0,
                notified_at DATETIME,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS trend_analysis (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                niche TEXT,
                subniche TEXT,
                video_id TEXT NOT NULL,
                video_title TEXT,
                video_url TEXT,
                channel_id TEXT,
                channel_name TEXT,
                views INTEGER,
                views_per_day REAL,
                detected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                analyzed INTEGER DEFAULT 0,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS competitor_monitoring (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                competitor_channel_id TEXT NOT NULL,
                competitor_channel_name TEXT,
                niche TEXT,
                subniche TEXT,
                auto_analyze INTEGER DEFAULT 1,
                last_checked DATETIME,
                check_frequency TEXT DEFAULT 'daily',
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                UNIQUE(user_id, competitor_channel_id)
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS ai_suggestions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                suggestion_type TEXT NOT NULL,
                title TEXT,
                description TEXT,
                niche TEXT,
                subniche TEXT,
                reason TEXT,
                priority INTEGER DEFAULT 5,
                viewed INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Tabela para agentes de roteiro
        await db.exec(`
            CREATE TABLE IF NOT EXISTS script_agents (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                agent_name TEXT NOT NULL,
                niche TEXT,
                subniche TEXT,
                source_video_id TEXT,
                source_video_url TEXT,
                source_video_title TEXT,
                full_transcript TEXT,
                agent_prompt TEXT,
                agent_instructions TEXT,
                viral_formula_json TEXT,
                usage_count INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Garantir que a coluna viral_formula_json exista (migra√ß√£o suave)
        try {
            await db.run(`ALTER TABLE script_agents ADD COLUMN viral_formula_json TEXT`);
            console.log('[DB] Coluna viral_formula_json adicionada √† tabela script_agents.');
        } catch (columnErr) {
            if (!/duplicate column name/i.test(columnErr.message)) {
                throw columnErr;
            }
        }

        // Tabela para roteiros gerados
        await db.exec(`
            CREATE TABLE IF NOT EXISTS generated_scripts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                script_agent_id INTEGER,
                title TEXT NOT NULL,
                script_content TEXT NOT NULL,
                model_used TEXT,
                niche TEXT,
                subniche TEXT,
                optimization_score REAL,
                optimization_report TEXT,
                retention_score REAL,
                authenticity_score REAL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (script_agent_id) REFERENCES script_agents(id) ON DELETE SET NULL
            );
        `);

        // Tabela para Agentes Virais (seguindo modelo Claude AI)
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_agents (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                description TEXT,
                memory TEXT,
                instructions TEXT,
                model TEXT DEFAULT 'gpt-4o',
                is_favorite BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        // Adicionar coluna model se n√£o existir (migra√ß√£o)
        try {
            await db.run(`ALTER TABLE viral_agents ADD COLUMN model TEXT DEFAULT 'gpt-4o'`);
            console.log('[DB] Coluna model adicionada √† tabela viral_agents.');
        } catch (columnErr) {
            if (!/duplicate column name/i.test(columnErr.message)) {
                throw columnErr;
            }
        }

        // Tabela para arquivos dos agentes virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_agent_files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                agent_id INTEGER NOT NULL,
                file_name TEXT NOT NULL,
                file_content TEXT,
                file_type TEXT,
                file_size INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (agent_id) REFERENCES viral_agents(id) ON DELETE CASCADE
            );
        `);

        // Tabela para conversas com agentes virais
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_agent_conversations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                agent_id INTEGER NOT NULL,
                user_id INTEGER NOT NULL,
                title TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (agent_id) REFERENCES viral_agents(id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        // Tabela para mensagens das conversas
        await db.exec(`
            CREATE TABLE IF NOT EXISTS viral_agent_messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                conversation_id INTEGER NOT NULL,
                role TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (conversation_id) REFERENCES viral_agent_conversations(id) ON DELETE CASCADE
            );
        `);

        // Tabela para hist√≥rico de prompts de cena
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);

        await db.exec(`
            CREATE TABLE IF NOT EXISTS video_operations_cache (
                operation_id TEXT PRIMARY KEY,
                user_id INTEGER NOT NULL,
                api_key_source TEXT NOT NULL,
                user_key_id INTEGER,
                admin_api_id INTEGER,
                use_laozhang INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        console.log('‚úÖ Novas tabelas criadas: Analytics, Biblioteca, Integra√ß√£o YouTube, Agentes de Roteiro e Hist√≥rico de Prompts de Cena');
        
        // === MIGRA√á√ÉO: Remover constraint UNIQUE de youtube_integrations (permitir m√∫ltiplos canais) ===
        try {
            const tableInfo = await db.all("PRAGMA table_info(youtube_integrations)");
            const indexes = await db.all("PRAGMA index_list(youtube_integrations)");
            
            // Verificar se existe constraint UNIQUE (atrav√©s de √≠ndices √∫nicos)
            const uniqueIndexes = indexes.filter(idx => idx.unique === 1);
            if (uniqueIndexes.length > 0) {
                console.log('MIGRATION: Removendo constraint UNIQUE de youtube_integrations para permitir m√∫ltiplos canais...');
                
                // Recriar tabela sem UNIQUE
                await db.exec(`
                    CREATE TABLE IF NOT EXISTS youtube_integrations_new (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        channel_id TEXT,
                        channel_name TEXT,
                        access_token TEXT,
                        refresh_token TEXT,
                        token_expires_at DATETIME,
                        is_active INTEGER DEFAULT 1,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                    );
                `);
                
                await db.exec(`INSERT INTO youtube_integrations_new SELECT * FROM youtube_integrations;`);
                await db.exec(`DROP TABLE youtube_integrations;`);
                await db.exec(`ALTER TABLE youtube_integrations_new RENAME TO youtube_integrations;`);
                
                // Criar √≠ndice n√£o-√∫nico para performance
                await db.exec(`
                    CREATE INDEX IF NOT EXISTS idx_youtube_integrations_user_channel 
                    ON youtube_integrations(user_id, channel_id);
                `);
                
                console.log('‚úÖ Migra√ß√£o conclu√≠da: m√∫ltiplos canais agora s√£o permitidos');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migra√ß√£o de youtube_integrations:', migrationErr.message);
        }

        // === MIGRA√á√ÉO: Adicionar campos niche e subniche em youtube_integrations ===
        try {
            const youtubeIntegrationsInfo = await db.all("PRAGMA table_info(youtube_integrations)");
            const hasNiche = youtubeIntegrationsInfo.some(c => c.name === 'niche');
            const hasSubniche = youtubeIntegrationsInfo.some(c => c.name === 'subniche');
            
            if (!hasNiche) {
                console.log('MIGRATION: Adicionando coluna "niche" em youtube_integrations...');
                await db.exec(`ALTER TABLE youtube_integrations ADD COLUMN niche TEXT`);
            }
            if (!hasSubniche) {
                console.log('MIGRATION: Adicionando coluna "subniche" em youtube_integrations...');
                await db.exec(`ALTER TABLE youtube_integrations ADD COLUMN subniche TEXT`);
            }
            if (!hasNiche || !hasSubniche) {
                console.log('‚úÖ Migra√ß√£o conclu√≠da: campos niche e subniche adicionados em youtube_integrations');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migra√ß√£o de youtube_integrations (niche/subniche):', migrationErr.message);
        }
        
        // === MIGRA√á√ÉO: Adicionar colunas de otimiza√ß√£o em generated_scripts ===
        try {
            const scriptsInfo = await db.all("PRAGMA table_info(generated_scripts)");
            const hasOptimizationScore = scriptsInfo.some(c => c.name === 'optimization_score');
            const hasOptimizationReport = scriptsInfo.some(c => c.name === 'optimization_report');
            const hasRetentionScore = scriptsInfo.some(c => c.name === 'retention_score');
            const hasAuthenticityScore = scriptsInfo.some(c => c.name === 'authenticity_score');
            
            if (!hasOptimizationScore) {
                console.log('MIGRATION: Adicionando coluna "optimization_score" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN optimization_score REAL`);
            }
            if (!hasOptimizationReport) {
                console.log('MIGRATION: Adicionando coluna "optimization_report" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN optimization_report TEXT`);
            }
            if (!hasRetentionScore) {
                console.log('MIGRATION: Adicionando coluna "retention_score" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN retention_score REAL`);
            }
            if (!hasAuthenticityScore) {
                console.log('MIGRATION: Adicionando coluna "authenticity_score" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN authenticity_score REAL`);
            }
            if (!hasOptimizationScore || !hasOptimizationReport || !hasRetentionScore || !hasAuthenticityScore) {
                console.log('‚úÖ Migra√ß√£o conclu√≠da: campos de otimiza√ß√£o adicionados em generated_scripts');
            }
            
            // Verificar e adicionar colunas duration_minutes e language se n√£o existirem
            const hasDurationMinutes = scriptsInfo.some(col => col.name === 'duration_minutes');
            const hasLanguage = scriptsInfo.some(col => col.name === 'language');
            
            if (!hasDurationMinutes) {
                console.log('MIGRATION: Adicionando coluna "duration_minutes" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN duration_minutes INTEGER`);
            }
            if (!hasLanguage) {
                console.log('MIGRATION: Adicionando coluna "language" em generated_scripts...');
                await db.exec(`ALTER TABLE generated_scripts ADD COLUMN language TEXT`);
            }
            if (!hasDurationMinutes || !hasLanguage) {
                console.log('‚úÖ Migra√ß√£o conclu√≠da: campos duration_minutes e language adicionados em generated_scripts');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migra√ß√£o de generated_scripts (optimization):', migrationErr.message);
        }
        
        // === MIGRA√á√ÉO: Corrigir tabela viral_thumbnails_library ===
        try {
            const thumbnailsInfo = await db.all("PRAGMA table_info(viral_thumbnails_library)");
            const thumbnailUrlColumn = thumbnailsInfo.find(c => c.name === 'thumbnail_url');
            if (thumbnailUrlColumn && thumbnailUrlColumn.notnull === 1) {
                console.log('MIGRATION: Corrigindo constraint NOT NULL em viral_thumbnails_library.thumbnail_url...');
                // SQLite n√£o suporta ALTER TABLE para remover NOT NULL diretamente
                // Vamos recriar a tabela sem o NOT NULL
                await db.exec(`
                    CREATE TABLE IF NOT EXISTS viral_thumbnails_library_new (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER,
                        thumbnail_url TEXT,
                        thumbnail_description TEXT,
                        niche TEXT,
                        subniche TEXT,
                        original_views INTEGER,
                        original_ctr REAL,
                        style TEXT,
                        elements TEXT,
                        viral_score INTEGER,
                        is_favorite INTEGER DEFAULT 0,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                    );
                `);
                await db.exec(`INSERT INTO viral_thumbnails_library_new SELECT * FROM viral_thumbnails_library;`);
                await db.exec(`DROP TABLE viral_thumbnails_library;`);
                await db.exec(`ALTER TABLE viral_thumbnails_library_new RENAME TO viral_thumbnails_library;`);
                console.log('‚úÖ Migra√ß√£o conclu√≠da: thumbnail_url agora √© opcional');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migra√ß√£o de viral_thumbnails_library:', migrationErr.message);
        }

        // === TABELA DE CANAIS DO USU√ÅRIO ===
        await db.exec(`
            CREATE TABLE IF NOT EXISTS user_channels (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                channel_name TEXT NOT NULL,
                channel_url TEXT,
                channel_id TEXT,
                niche TEXT,
                language TEXT DEFAULT 'pt-BR',
                country TEXT DEFAULT 'BR',
                is_active INTEGER DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                UNIQUE(user_id, channel_name)
            );
        `);

        // Adicionar coluna channel_id na tabela video_tracking se n√£o existir
        try {
            const trackingInfo = await db.all("PRAGMA table_info(video_tracking)");
            if (!trackingInfo.some(c => c.name === 'channel_id')) {
                console.log('MIGRATION: Adicionando coluna channel_id em video_tracking...');
                await db.exec('ALTER TABLE video_tracking ADD COLUMN channel_id INTEGER REFERENCES user_channels(id) ON DELETE SET NULL');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migra√ß√£o de video_tracking:', migrationErr.message);
        }
        // Adicionar coluna full_transcript na tabela analyzed_videos se n√£o existir
        try {
            const analyzedVideosInfo = await db.all("PRAGMA table_info(analyzed_videos)");
            if (!analyzedVideosInfo.some(c => c.name === 'full_transcript')) {
                console.log('MIGRATION: Adicionando coluna full_transcript em analyzed_videos...');
                await db.exec('ALTER TABLE analyzed_videos ADD COLUMN full_transcript TEXT');
            }
        } catch (migrationErr) {
            console.warn('Aviso na migra√ß√£o de analyzed_videos (full_transcript):', migrationErr.message);
        }
        
        console.log('Tabelas e colunas sincronizadas.');

        // --- CRIA√á√ÉO DO ADMIN ---
        const adminEmail = 'rudysilvaads@gmail.com';
        const adminPassword = '253031';
        
        const adminExists = await db.get('SELECT * FROM users WHERE email = ?', [adminEmail]);
        
        if (!adminExists) {
            console.log('Criando utilizador administrador...');
            const salt = await bcrypt.genSalt(10);
            const admin_pass_hash = await bcrypt.hash(adminPassword, salt);
            
            await db.run(
                'INSERT INTO users (name, email, whatsapp, password_hash, isAdmin, isApproved) VALUES (?, ?, ?, ?, ?, ?)',
                ['Admin Core', adminEmail, '(00) 00000-0000', admin_pass_hash, 1, 1]
            );
            console.log('Utilizador administrador criado com sucesso!');
        } else {
            await db.run('UPDATE users SET isAdmin = 1, isBlocked = 0, isApproved = 1 WHERE email = ?', [adminEmail]);
            console.log('Utilizador administrador j√° existe. Status verificado.');
        }

        console.log('‚úÖ Banco de dados inicializado com sucesso!');
        
        // Sinalizar que o banco est√° pronto ANTES de opera√ß√µes pesadas
        global.dbReady = true;
        
        // Executar rehydrate em background (n√£o bloqueia o servidor)
        rehydratePendingVideoOperations().catch(err => {
            console.error('[VideoCache] Erro ao reidratar opera√ß√µes (n√£o cr√≠tico):', err.message);
        });
        
    } catch (err) {
        console.error('‚ùå Erro ao conectar ou inicializar o banco de dados:', err);
        global.dbReady = false;
    }
})();


// --- ROTAS DE API ---
// ================================================
// ROTAS DE NOTIFICA√á√ïES
// ================================================

// GET /api/notifications/pending - Obter notifica√ß√µes pendentes do usu√°rio
app.get('/api/notifications/pending', authenticateToken, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS notifications (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    title TEXT NOT NULL,
                    message TEXT NOT NULL,
                    type TEXT DEFAULT 'info',
                    is_read BOOLEAN DEFAULT 0,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                )
            `);
        } catch (err) {
            // Tabela j√° existe, continuar
        }
        
        const notifications = await db.all(
            'SELECT * FROM notifications WHERE (user_id IS NULL OR user_id = ?) AND is_read = 0 ORDER BY created_at DESC LIMIT 10',
            [req.user.id]
        );
        res.json(notifications);
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao buscar notifica√ß√µes:', error);
        res.status(500).json({ message: 'Erro ao buscar notifica√ß√µes: ' + error.message });
    }
});

// POST /api/notifications/:id/read - Marcar notifica√ß√£o como lida
app.post('/api/notifications/:id/read', authenticateToken, async (req, res) => {
    try {
        await db.run('UPDATE notifications SET is_read = 1 WHERE id = ?', [req.params.id]);
        res.json({ success: true });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao marcar notifica√ß√£o como lida:', error);
        res.status(500).json({ message: 'Erro ao marcar notifica√ß√£o como lida' });
    }
});

// POST /api/admin/notifications/create - Criar notifica√ß√£o (admin)
app.post('/api/admin/notifications/create', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { title, message, type = 'info', user_id = null } = req.body;
        
        if (!title || !message) {
            return res.status(400).json({ message: 'T√≠tulo e mensagem s√£o obrigat√≥rios' });
        }
        
        await db.run(
            'INSERT INTO notifications (user_id, title, message, type) VALUES (?, ?, ?, ?)',
            [user_id, title, message, type]
        );
        
        res.json({ success: true, message: 'Notifica√ß√£o criada com sucesso' });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao criar notifica√ß√£o:', error);
        res.status(500).json({ message: 'Erro ao criar notifica√ß√£o' });
    }
});

// GET /api/admin/notifications/config - Obter configura√ß√µes de notifica√ß√µes
app.get('/api/admin/notifications/config', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS notification_config (
                    key TEXT PRIMARY KEY,
                    value TEXT NOT NULL,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela j√° existe, continuar
        }
        
        const configs = await db.all('SELECT * FROM notification_config');
        const config = {};
        configs.forEach(c => {
            config[c.key] = c.value;
        });
        
        // Valores padr√£o
        res.json({
            purchase_enabled: config.purchase_enabled === 'true',
            purchase_interval: parseInt(config.purchase_interval) || 5,
            purchase_message: config.purchase_message || 'üéâ {name} acabou de comprar o plano {plan}!',
            user_enabled: config.user_enabled === 'true',
            user_interval: parseInt(config.user_interval) || 5,
            user_message: config.user_message || 'üëã {name} acabou de se cadastrar na plataforma!'
        });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao buscar configura√ß√µes:', error);
        res.status(500).json({ message: 'Erro ao buscar configura√ß√µes: ' + error.message });
    }
});

// POST /api/admin/notifications/config - Salvar configura√ß√µes de notifica√ß√µes
app.post('/api/admin/notifications/config', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS notification_config (
                    key TEXT PRIMARY KEY,
                    value TEXT NOT NULL,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela j√° existe, continuar
        }
        
        const { purchase_enabled, purchase_interval, purchase_message, user_enabled, user_interval, user_message } = req.body;
        
        const configs = [
            { key: 'purchase_enabled', value: String(purchase_enabled || false) },
            { key: 'purchase_interval', value: String(purchase_interval || 5) },
            { key: 'purchase_message', value: purchase_message || 'üéâ {name} acabou de comprar o plano {plan}!' },
            { key: 'user_enabled', value: String(user_enabled || false) },
            { key: 'user_interval', value: String(user_interval || 5) },
            { key: 'user_message', value: user_message || 'üëã {name} acabou de se cadastrar na plataforma!' }
        ];
        
        for (const config of configs) {
            await db.run(
                'INSERT OR REPLACE INTO notification_config (key, value, updated_at) VALUES (?, ?, CURRENT_TIMESTAMP)',
                [config.key, config.value]
            );
        }
        
        res.json({ success: true, message: 'Configura√ß√µes salvas com sucesso' });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao salvar configura√ß√µes:', error);
        res.status(500).json({ message: 'Erro ao salvar configura√ß√µes: ' + error.message });
    }
});

// GET /api/admin/notifications/fake-users - Listar usu√°rios fict√≠cios
app.get('/api/admin/notifications/fake-users', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS fake_users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    email TEXT NOT NULL,
                    type TEXT DEFAULT 'purchase',
                    is_active BOOLEAN DEFAULT 1,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela j√° existe, continuar
        }
        
        const users = await db.all('SELECT * FROM fake_users ORDER BY created_at DESC');
        res.json(users);
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao listar usu√°rios fict√≠cios:', error);
        res.status(500).json({ message: 'Erro ao listar usu√°rios fict√≠cios: ' + error.message });
    }
});

// POST /api/admin/notifications/fake-users - Criar usu√°rio fict√≠cio
app.post('/api/admin/notifications/fake-users', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS fake_users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    email TEXT NOT NULL,
                    type TEXT DEFAULT 'purchase',
                    plan_name TEXT DEFAULT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela j√° existe, continuar
        }
        
        const { name, email, type = 'purchase', plan_name = null, bulk = false } = req.body;
        
        if (bulk && Array.isArray(req.body.users)) {
            // Criar m√∫ltiplos usu√°rios
            const results = [];
            for (const user of req.body.users) {
                try {
                    const result = await db.run(
                        'INSERT INTO fake_users (name, email, type, plan_name) VALUES (?, ?, ?, ?)',
                        [user.name, user.email, user.type, user.plan_name || null]
                    );
                    results.push({ id: result.lastID, email: user.email });
                } catch (err) {
                    console.error(`[NOTIFICATIONS] Erro ao criar usu√°rio ${user.email}:`, err);
                }
            }
            res.json({ success: true, created: results.length, message: `${results.length} usu√°rios fict√≠cios criados com sucesso` });
        } else {
            if (!name || !email) {
                return res.status(400).json({ message: 'Nome e email s√£o obrigat√≥rios' });
            }
            
            const result = await db.run(
                'INSERT INTO fake_users (name, email, type, plan_name) VALUES (?, ?, ?, ?)',
                [name, email, type, plan_name]
            );
            
            res.json({ success: true, id: result.lastID, message: 'Usu√°rio fict√≠cio criado com sucesso' });
        }
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao criar usu√°rio fict√≠cio:', error);
        res.status(500).json({ message: 'Erro ao criar usu√°rio fict√≠cio: ' + error.message });
    }
});

// DELETE /api/admin/notifications/fake-users/:id - Deletar usu√°rio fict√≠cio
app.delete('/api/admin/notifications/fake-users/:id', authenticateToken, isAdmin, async (req, res) => {
    try {
        await db.run('DELETE FROM fake_users WHERE id = ?', [req.params.id]);
        res.json({ success: true, message: 'Usu√°rio fict√≠cio deletado com sucesso' });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao deletar usu√°rio fict√≠cio:', error);
        res.status(500).json({ message: 'Erro ao deletar usu√°rio fict√≠cio' });
    }
});

// POST /api/admin/notifications/loop/start - Iniciar loop de notifica√ß√µes
app.post('/api/admin/notifications/loop/start', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { loop_type, interval_seconds } = req.body;
        
        if (!loop_type || (loop_type !== 'purchase' && loop_type !== 'user')) {
            return res.status(400).json({ message: 'Tipo de loop inv√°lido. Use "purchase" ou "user"' });
        }
        
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS active_loops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    loop_type TEXT NOT NULL UNIQUE,
                    is_active BOOLEAN DEFAULT 0,
                    interval_seconds INTEGER DEFAULT 5,
                    started_at DATETIME,
                    stopped_at DATETIME,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela j√° existe, continuar
        }
        
        await db.run(
            'INSERT OR REPLACE INTO active_loops (loop_type, is_active, interval_seconds, started_at, updated_at) VALUES (?, 1, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)',
            [loop_type, interval_seconds || 5]
        );
        
        console.log(`[NOTIFICATIONS] Loop ${loop_type} iniciado e salvo no banco de dados`);
        res.json({ success: true, message: `Loop ${loop_type} iniciado com sucesso` });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao iniciar loop:', error);
        res.status(500).json({ message: 'Erro ao iniciar loop: ' + error.message });
    }
});

// POST /api/admin/notifications/loop/stop - Parar loop de notifica√ß√µes
app.post('/api/admin/notifications/loop/stop', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { loop_type } = req.body;
        
        if (!loop_type || (loop_type !== 'purchase' && loop_type !== 'user')) {
            return res.status(400).json({ message: 'Tipo de loop inv√°lido. Use "purchase" ou "user"' });
        }
        
        await db.run(
            'UPDATE active_loops SET is_active = 0, stopped_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP WHERE loop_type = ?',
            [loop_type]
        );
        
        // Parar o loop imediatamente
        if (notificationLoops[loop_type]) {
            clearInterval(notificationLoops[loop_type]);
            notificationLoops[loop_type] = null;
        }
        
        console.log(`[NOTIFICATIONS] Loop ${loop_type} parado e salvo no banco de dados`);
        res.json({ success: true, message: `Loop ${loop_type} parado com sucesso` });
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao parar loop:', error);
        res.status(500).json({ message: 'Erro ao parar loop: ' + error.message });
    }
});

// GET /api/admin/notifications/loop/status - Verificar status dos loops
app.get('/api/admin/notifications/loop/status', authenticateToken, isAdmin, async (req, res) => {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS active_loops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    loop_type TEXT NOT NULL UNIQUE,
                    is_active BOOLEAN DEFAULT 0,
                    interval_seconds INTEGER DEFAULT 5,
                    started_at DATETIME,
                    stopped_at DATETIME,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela j√° existe, continuar
        }
        
        const loops = await db.all('SELECT * FROM active_loops');
        const status = {
            purchase: { is_active: false, interval_seconds: 5 },
            user: { is_active: false, interval_seconds: 5 }
        };
        
        loops.forEach(loop => {
            if (loop.loop_type === 'purchase' || loop.loop_type === 'user') {
                status[loop.loop_type] = {
                    is_active: loop.is_active === 1,
                    interval_seconds: loop.interval_seconds,
                    started_at: loop.started_at,
                    stopped_at: loop.stopped_at
                };
            }
        });
        
        res.json(status);
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao verificar status dos loops:', error);
        res.status(500).json({ message: 'Erro ao verificar status dos loops: ' + error.message });
    }
});

// ================================================
// SISTEMA DE PERMISS√ïES DE PLANOS
// ================================================

// Middleware para verificar permiss√£o de funcionalidade
function checkPlanPermission(featureName) {
    return async (req, res, next) => {
        try {
            const userId = req.user.id;
            
            // Admin sempre tem acesso
            const user = await db.get('SELECT isAdmin FROM users WHERE id = ?', [userId]);
            if (user && (user.isAdmin === 1 || user.isAdmin === true || String(user.isAdmin) === '1')) {
                return next();
            }
            
            // Obter plano do usu√°rio
            const userData = await db.get('SELECT plan, subscription_plan FROM users WHERE id = ?', [userId]);
            if (!userData) {
                return res.status(403).json({ message: 'Usu√°rio n√£o encontrado' });
            }
            
            const planName = userData.subscription_plan || userData.plan || 'plan-free';
            
            // Verificar permiss√£o
            const permission = await db.get(
                'SELECT is_allowed FROM plan_permissions WHERE plan_name = ? AND feature_name = ?',
                [planName, featureName]
            );
            
            if (!permission || permission.is_allowed === 0) {
                return res.status(403).json({ 
                    message: `Esta funcionalidade n√£o est√° dispon√≠vel no seu plano atual.`,
                    feature: featureName,
                    plan: planName
                });
            }
            
            next();
        } catch (error) {
            console.error('[PERMISSIONS] Erro ao verificar permiss√£o:', error);
            res.status(500).json({ message: 'Erro ao verificar permiss√£o' });
        }
    };
}

// GET /api/admin/plan-permissions - Listar todas as permiss√µes
app.get('/api/admin/plan-permissions', authenticateToken, isAdmin, async (req, res) => {
    try {
        const permissions = await db.all(`
            SELECT pp.*, pc.monthly_credits
            FROM plan_permissions pp
            LEFT JOIN plan_credits pc ON pp.plan_name = pc.plan_name
            ORDER BY pp.plan_name, pp.feature_name
        `);
        
        // Organizar por plano
        const organized = {};
        permissions.forEach(p => {
            if (!organized[p.plan_name]) {
                organized[p.plan_name] = {
                    plan_name: p.plan_name,
                    monthly_credits: p.monthly_credits || 0,
                    features: {}
                };
            }
            organized[p.plan_name].features[p.feature_name] = p.is_allowed === 1;
        });
        
        res.json(organized);
    } catch (error) {
        console.error('[PERMISSIONS] Erro ao listar permiss√µes:', error);
        res.status(500).json({ message: 'Erro ao listar permiss√µes' });
    }
});

// PUT /api/admin/plan-permissions/:planName/:featureName - Atualizar permiss√£o
app.put('/api/admin/plan-permissions/:planName/:featureName', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { planName, featureName } = req.params;
        const { is_allowed } = req.body;
        
        await db.run(`
            INSERT OR REPLACE INTO plan_permissions (plan_name, feature_name, is_allowed, updated_at)
            VALUES (?, ?, ?, CURRENT_TIMESTAMP)
        `, [planName, featureName, is_allowed ? 1 : 0]);
        
        res.json({ success: true, message: 'Permiss√£o atualizada com sucesso' });
    } catch (error) {
        console.error('[PERMISSIONS] Erro ao atualizar permiss√£o:', error);
        res.status(500).json({ message: 'Erro ao atualizar permiss√£o' });
    }
});

// PUT /api/admin/plan-credits/:planName - Atualizar cr√©ditos do plano
app.put('/api/admin/plan-credits/:planName', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { planName } = req.params;
        const { monthly_credits } = req.body;
        
        if (!monthly_credits || monthly_credits < 0) {
            return res.status(400).json({ message: 'Cr√©ditos mensais inv√°lidos' });
        }
        
        await db.run(`
            INSERT OR REPLACE INTO plan_credits (plan_name, monthly_credits, updated_at)
            VALUES (?, ?, CURRENT_TIMESTAMP)
        `, [planName, monthly_credits]);
        
        res.json({ success: true, message: 'Cr√©ditos do plano atualizados com sucesso' });
    } catch (error) {
        console.error('[PLAN CREDITS] Erro ao atualizar cr√©ditos:', error);
        res.status(500).json({ message: 'Erro ao atualizar cr√©ditos' });
    }
});

// GET /api/user/permissions - Obter permiss√µes do usu√°rio atual
app.get('/api/user/permissions', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        
        // Admin sempre tem todas as permiss√µes
        const user = await db.get('SELECT isAdmin FROM users WHERE id = ?', [userId]);
        if (user && (user.isAdmin === 1 || user.isAdmin === true || String(user.isAdmin) === '1')) {
            const allFeatures = ['video_analyzer', 'niche_explorer', 'script_generator', 'voice_generator', 
                               'image_generator', 'video_generator', 'youtube_integration', 'api_propria', 
                               'batch_images', 'analytics', 'viral_library'];
            const permissions = {};
            allFeatures.forEach(f => permissions[f] = true);
            return res.json({ permissions, plan: 'admin' });
        }
        
        // Obter plano do usu√°rio
        const userData = await db.get('SELECT plan, subscription_plan FROM users WHERE id = ?', [userId]);
        const planName = userData?.subscription_plan || userData?.plan || 'plan-free';
        
        // Obter permiss√µes
        const perms = await db.all(
            'SELECT feature_name, is_allowed FROM plan_permissions WHERE plan_name = ?',
            [planName]
        );
        
        const permissions = {};
        perms.forEach(p => {
            permissions[p.feature_name] = p.is_allowed === 1;
        });
        
        res.json({ permissions, plan: planName });
    } catch (error) {
        console.error('[PERMISSIONS] Erro ao obter permiss√µes:', error);
        res.status(500).json({ message: 'Erro ao obter permiss√µes' });
    }
});

// NOTA: Todas as rotas devem ser definidas ANTES do app.listen() para funcionarem corretamente

// === ROTAS DE AUTENTICA√á√ÉO ===

app.post('/api/auth/register', async (req, res) => {
    const { name, email, whatsapp, password } = req.body;

    if (!name || !email || !password) {
        return res.status(400).json({ msg: 'Por favor, preencha todos os campos obrigat√≥rios.' });
    }

    try {
        const userExists = await db.get('SELECT * FROM users WHERE email = ?', [email]);
        if (userExists) {
            return res.status(400).json({ msg: 'Este e-mail j√° est√° registado.' });
        }

        const salt = await bcrypt.genSalt(10);
        const password_hash = await bcrypt.hash(password, salt);

        const result = await db.run(
            'INSERT INTO users (name, email, whatsapp, password_hash) VALUES (?, ?, ?, ?)',
            [name, email, whatsapp, password_hash]
        );
        
        const userId = result.lastID;
        
        // Inicializar saldo de cr√©ditos para novo usu√°rio com b√¥nus inicial
        try {
            const bonusSetting = await db.get("SELECT value FROM app_settings WHERE key = 'initial_bonus_credits'");
            const bonusAmount = bonusSetting ? parseFloat(bonusSetting.value) : 0;

            if (bonusAmount > 0) {
                await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, ?)', [userId, bonusAmount]);
                await db.run(
                    'INSERT INTO credit_transactions (user_id, amount, transaction_type, description, admin_id) VALUES (?, ?, ?, ?, NULL)',
                    [userId, bonusAmount, 'credit', 'B√¥nus de boas-vindas']
                );
                console.log(`‚úÖ Cr√©ditos b√¥nus iniciais (${bonusAmount}) adicionados para novo usu√°rio ${email}`);
            } else {
                await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [userId]);
            }
        } catch (creditError) {
            console.error('‚ö†Ô∏è Erro ao inicializar cr√©ditos para novo usu√°rio:', creditError);
        }

        // Enviar email de boas-vindas
        try {
            // Priorizar vari√°vel de ambiente, depois header, depois req.get('host')
            const baseUrl = process.env.BASE_URL || process.env.APP_URL || process.env.PUBLIC_URL;
            let loginUrl;
            
            if (baseUrl) {
                loginUrl = `${baseUrl.replace(/\/$/, '')}/la-casa-dark-core-auth.html`;
            } else {
                const protocol = req.protocol || (req.get('x-forwarded-proto') || 'http');
                const host = req.get('x-forwarded-host') || req.get('host') || 'localhost:5001';
                loginUrl = `${protocol}://${host}/la-casa-dark-core-auth.html`;
            }
            
            await sendTemplateEmail('register', email, {
                nome: name,
                email: email,
                creditos_iniciais: bonusAmount || 0,
                link_acesso: loginUrl
            });
        } catch (emailError) {
            console.error('[EMAIL] Erro ao enviar email de boas-vindas:', emailError.message);
            // N√£o falhar o registro se o email falhar
        }

        res.status(201).json({ msg: 'Utilizador registado com sucesso! A aguardar aprova√ß√£o.', userId: userId });

    } catch (err) {
        console.error('Erro no registo:', err);
        res.status(500).json({ msg: 'Erro no servidor ao tentar registar.' });
    }
});

app.post('/api/auth/login', async (req, res) => {
    // Verificar se o banco de dados est√° inicializado
    if (!db) {
        return res.status(503).json({ msg: 'Servidor ainda n√£o est√° pronto. Aguarde alguns instantes e tente novamente.' });
    }

    const { email, password } = req.body;

    if (!email || !password) {
        return res.status(400).json({ msg: 'Por favor, forne√ßa e-mail e senha.' });
    }

    try {
        const user = await db.get('SELECT * FROM users WHERE email = ?', [email]);
        if (!user) {
            return res.status(400).json({ msg: 'Credenciais inv√°lidas.' });
        }

        if (user.isBlocked) {
            return res.status(403).json({ msg: 'Esta conta est√° bloqueada. Entre em contacto com o suporte.' });
        }

        if (!user.isApproved && !user.isAdmin) {
            return res.status(403).json({ msg: 'A sua conta est√° pendente de aprova√ß√£o.' });
        }

        const isMatch = await bcrypt.compare(password, user.password_hash);
        if (!isMatch) {
            return res.status(400).json({ msg: 'Credenciais inv√°lidas.' });
        }

        await db.run('UPDATE users SET last_login_at = CURRENT_TIMESTAMP WHERE id = ?', [user.id]);

        const token = jwt.sign(
            { id: user.id, email: user.email, isAdmin: user.isAdmin },
            JWT_SECRET,
            { expiresIn: '8h' }
        );

        res.json({
            msg: 'Login feito com sucesso!',
            token,
            isAdmin: user.isAdmin
        });

    } catch (err) {
        console.error('Erro no login:', err);
        res.status(500).json({ msg: 'Erro no servidor durante o login.' });
    }
});

app.get('/api/auth/me', authenticateToken, async (req, res) => {
    try {
        const user = await db.get('SELECT id, name, email, whatsapp, isAdmin, isBlocked, plan, subscription_plan FROM users WHERE id = ?', [req.user.id]);
        
        if (!user) {
            return res.status(404).json({ msg: 'Utilizador n√£o encontrado.' });
        }
        
        if (user.isBlocked) {
             return res.status(403).json({ msg: 'A sua conta foi bloqueada.' });
        }
        
        res.json(user);

    } catch (err) {
        console.error('Erro ao buscar dados do utilizador (/me):', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Rota para solicitar reset de senha
app.post('/api/auth/forgot-password', async (req, res) => {
    console.log('[AUTH] ========== SOLICITA√á√ÉO DE RESET DE SENHA ==========');
    console.log('[AUTH] Recebida requisi√ß√£o POST /api/auth/forgot-password');
    console.log('[AUTH] Body recebido:', JSON.stringify(req.body));
    
    const { email } = req.body;

    if (!email) {
        console.log('[AUTH] ‚ùå Email n√£o fornecido');
        return res.status(400).json({ msg: 'Por favor, forne√ßa um email.' });
    }

    console.log(`[AUTH] üìß Processando reset de senha para: ${email}`);

    try {
        // Verificar se o usu√°rio existe
        console.log('[AUTH] üîç Buscando usu√°rio no banco de dados...');
        const user = await db.get('SELECT id, name, email FROM users WHERE email = ?', [email]);
        
        // Sempre retornar sucesso (por seguran√ßa, n√£o revelar se o email existe ou n√£o)
        const successMessage = 'Se este email estiver cadastrado, um link de reset ser√° enviado!';
        
        if (user) {
            console.log(`[AUTH] ‚úÖ Usu√°rio encontrado: ${user.name} (ID: ${user.id})`);
            
            // Gerar token de reset (v√°lido por 1 hora)
            console.log('[AUTH] üîë Gerando token de reset...');
            const resetToken = jwt.sign(
                { userId: user.id, type: 'password_reset' },
                JWT_SECRET,
                { expiresIn: '1h' }
            );
            console.log('[AUTH] ‚úÖ Token gerado com sucesso');
            
            // Salvar token no banco de dados
            console.log('[AUTH] üíæ Salvando token no banco de dados...');
            await db.run(
                'INSERT OR REPLACE INTO password_reset_tokens (user_id, token, expires_at) VALUES (?, ?, datetime("now", "+1 hour"))',
                [user.id, resetToken]
            );
            console.log('[AUTH] ‚úÖ Token salvo no banco de dados');
            
            // Construir URL de reset
            // Priorizar vari√°vel de ambiente, depois header X-Forwarded-Host, depois req.get('host')
            const baseUrl = process.env.BASE_URL || process.env.APP_URL || process.env.PUBLIC_URL;
            let resetUrl;
            
            if (baseUrl) {
                // Usar URL base configurada
                resetUrl = `${baseUrl.replace(/\/$/, '')}/la-casa-dark-core-auth.html?reset_token=${resetToken}`;
                console.log(`[AUTH] üîó Usando URL base configurada: ${baseUrl}`);
            } else {
                // Tentar detectar automaticamente
                const protocol = req.protocol || (req.get('x-forwarded-proto') || 'http');
                let host = req.get('x-forwarded-host') || req.get('host');
                
                // Se n√£o tiver host, tentar usar o hostname da requisi√ß√£o
                if (!host) {
                    host = req.hostname || 'localhost:5001';
                    // Adicionar porta se n√£o estiver no hostname
                    if (!host.includes(':') && req.socket && req.socket.localPort) {
                        host = `${host}:${req.socket.localPort}`;
                    } else if (!host.includes(':')) {
                        host = `${host}:5001`;
                    }
                }
                
                resetUrl = `${protocol}://${host}/la-casa-dark-core-auth.html?reset_token=${resetToken}`;
            }
            
            console.log(`[AUTH] üîó URL de reset gerada: ${resetUrl}`);
            console.log(`[AUTH] üìç Servidor rodando na porta: ${PORT}`);
            console.log(`[AUTH] üåê Host detectado: ${req.get('host') || 'N/A'}`);
            console.log(`[AUTH] üîí Protocolo: ${req.protocol || 'http'}`);
            
            // Enviar email de reset
            console.log('[AUTH] üì® Tentando enviar email de reset...');
            try {
                const emailResult = await sendTemplateEmail('password_reset', user.email, {
                    nome: user.name,
                    email: user.email,
                    senha_provisoria: null, // N√£o usamos senha provis√≥ria aqui
                    link_acesso: resetUrl
                });
                
                if (emailResult.success) {
                    console.log(`[AUTH] ‚úÖ Email de reset de senha enviado com sucesso para: ${user.email}`);
                    console.log(`[AUTH] üìß Message ID: ${emailResult.messageId || 'N/A'}`);
                    if (emailResult.accepted && emailResult.accepted.length > 0) {
                        console.log(`[AUTH] ‚úÖ Email aceito para entrega: ${emailResult.accepted.join(', ')}`);
                    }
                    if (emailResult.rejected && emailResult.rejected.length > 0) {
                        console.error(`[AUTH] ‚ùå Email rejeitado: ${emailResult.rejected.join(', ')}`);
                    }
                    console.log(`[AUTH] üí° Dica: Verifique a pasta de SPAM/Lixo Eletr√¥nico se o email n√£o chegar em alguns minutos.`);
                } else {
                    console.error(`[AUTH] ‚ö†Ô∏è Falha ao enviar email: ${emailResult.message || emailResult.error}`);
                }
            } catch (emailError) {
                console.error('[AUTH] ‚ùå Erro ao enviar email de reset:', emailError.message);
                console.error('[AUTH] Stack trace:', emailError.stack);
                // Continuar mesmo se o email falhar
            }
        } else {
            console.log(`[AUTH] ‚ö†Ô∏è Usu√°rio n√£o encontrado para o email: ${email}`);
            console.log('[AUTH] ‚ÑπÔ∏è Retornando mensagem gen√©rica por seguran√ßa');
        }
        
        // Sempre retornar a mesma mensagem (por seguran√ßa)
        console.log('[AUTH] ‚úÖ Retornando resposta de sucesso');
        console.log('[AUTH] ============================================');
        res.json({ msg: successMessage });
        
    } catch (err) {
        console.error('[AUTH] ‚ùå Erro ao processar solicita√ß√£o de reset de senha:', err);
        console.error('[AUTH] Stack trace:', err.stack);
        // Retornar sucesso mesmo em caso de erro (por seguran√ßa)
        res.json({ msg: 'Se este email estiver cadastrado, um link de reset ser√° enviado!' });
    }
});

// ================================================
// ROTAS DO SISTEMA DE CR√âDITOS
// ================================================

// Fun√ß√£o auxiliar para obter limite de armazenamento baseado no plano
async function getStorageLimit(planName, isAdmin = false, userId = null) {
    // Verificar se h√° limite customizado para o usu√°rio
    if (userId) {
        try {
            const customLimit = await db.get('SELECT custom_limit FROM user_storage_limits WHERE user_id = ?', [userId]);
            if (customLimit) {
                return customLimit.custom_limit;
            }
        } catch (err) {
            // Tabela pode n√£o existir ainda, continuar com limite padr√£o
        }
    }
    
    // Admin tem 100 GB de armazenamento e acesso ilimitado
    if (isAdmin) {
        return 100 * 1024 * 1024 * 1024; // 100 GB
    }
    
    const storageLimits = {
        'plan-free': 10 * 1024 * 1024, // 10 MB
        'plan-start': 150 * 1024 * 1024, // 150 MB
        'plan-turbo': 250 * 1024 * 1024, // 250 MB
        'plan-master': 500 * 1024 * 1024, // 500 MB
        'plan-start-annual': 1024 * 1024 * 1024, // 1 GB
        'plan-turbo-annual': 1024 * 1024 * 1024, // 1 GB
        'plan-master-annual': 1024 * 1024 * 1024 // 1 GB
    };
    return storageLimits[planName] || storageLimits['plan-free'];
}

// Fun√ß√£o auxiliar para verificar se o usu√°rio pode usar mais armazenamento
// Retorna true se pode usar, false se excedeu o limite
async function checkStorageLimit(userId, additionalSize = 0, isAdmin = false) {
    // Admin sempre tem acesso ilimitado
    if (isAdmin) {
        return true;
    }
    
    try {
        const storageUsed = await calculateUserStorage(userId);
        // Obter plano do usu√°rio
        let userPlan = 'plan-free';
        try {
            const user = await db.get('SELECT plan, subscription_plan FROM users WHERE id = ?', [userId]);
            if (user) {
                userPlan = user.subscription_plan || user.plan || 'plan-free';
            }
        } catch (err) {
            // Usar padr√£o
        }
        
        const storageLimit = await getStorageLimit(userPlan, isAdmin, userId);
        return (storageUsed + additionalSize) <= storageLimit;
    } catch (error) {
        console.error('[STORAGE] Erro ao verificar limite de armazenamento:', error);
        return false; // Em caso de erro, bloquear por seguran√ßa
    }
}

// Fun√ß√£o auxiliar para calcular tamanho de string/texto em bytes
function calculateTextSize(text) {
    if (!text) return 0;
    return Buffer.byteLength(String(text), 'utf8');
}

// Fun√ß√£o para calcular e atualizar armazenamento usado por dados nas tabelas
async function calculateAndUpdateDatabaseStorage(userId) {
    try {
        let totalSize = 0;
        
        // 1. PASTAS E HIST√ìRICOS
        // analysis_folders (apenas name, n√£o tem description)
        try {
            const folders = await db.all('SELECT name FROM analysis_folders WHERE user_id = ?', [userId]);
            for (const folder of folders) {
                totalSize += calculateTextSize(folder.name);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de analysis_folders:', err.message);
        }
        
        // generated_scripts (roteiros)
        try {
            const scripts = await db.all(
                'SELECT title, script_content, optimization_report FROM generated_scripts WHERE user_id = ?', 
                [userId]
            );
            for (const script of scripts) {
                totalSize += calculateTextSize(script.title);
                totalSize += calculateTextSize(script.script_content);
                totalSize += calculateTextSize(script.optimization_report);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de generated_scripts:', err.message);
        }
        
        // analyzed_videos (usar colunas corretas: original_title, translated_title, analysis_data_json)
        try {
            const videos = await db.all(
                'SELECT original_title, translated_title, analysis_data_json FROM analyzed_videos WHERE user_id = ?', 
                [userId]
            );
            for (const video of videos) {
                totalSize += calculateTextSize(video.original_title);
                totalSize += calculateTextSize(video.translated_title);
                totalSize += calculateTextSize(video.analysis_data_json);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de analyzed_videos:', err.message);
        }
        
        // 2. CANAIS MONITORADOS
        // monitored_channels
        try {
            const channels = await db.all(
                'SELECT channel_name, channel_url FROM monitored_channels WHERE user_id = ?', 
                [userId]
            );
            for (const channel of channels) {
                totalSize += calculateTextSize(channel.channel_name);
                totalSize += calculateTextSize(channel.channel_url);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de monitored_channels:', err.message);
        }
        
        // youtube_integrations
        try {
            const integrations = await db.all(
                'SELECT channel_id, channel_name, access_token, refresh_token FROM youtube_integrations WHERE user_id = ?', 
                [userId]
            );
            for (const integration of integrations) {
                totalSize += calculateTextSize(integration.channel_id);
                totalSize += calculateTextSize(integration.channel_name);
                totalSize += calculateTextSize(integration.access_token);
                totalSize += calculateTextSize(integration.refresh_token);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de youtube_integrations:', err.message);
        }
        
        // pinned_videos
        try {
            const pinnedVideos = await db.all(
                'SELECT youtube_video_id, title FROM pinned_videos WHERE user_id = ?', 
                [userId]
            );
            for (const pinned of pinnedVideos) {
                totalSize += calculateTextSize(pinned.youtube_video_id);
                totalSize += calculateTextSize(pinned.title || '');
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de pinned_videos:', err.message);
        }
        
        // 3. BIBLIOTECA DE T√çTULOS E THUMBNAILS
        // generated_titles (atrav√©s de analyzed_videos)
        try {
            const titles = await db.all(`
                SELECT gt.title_text, gt.explicacao 
                FROM generated_titles gt
                INNER JOIN analyzed_videos av ON gt.video_analysis_id = av.id
                WHERE av.user_id = ?
            `, [userId]);
            for (const title of titles) {
                totalSize += calculateTextSize(title.title_text);
                totalSize += calculateTextSize(title.explicacao);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de generated_titles:', err.message);
        }
        
        // generated_thumbnails (imagens em base64 - muito pesado)
        try {
            const thumbnails = await db.all(`
                SELECT gt.base_title, gt.description, gt.hook_phrases_json, gt.generated_image_base64
                FROM generated_thumbnails gt
                INNER JOIN analyzed_videos av ON gt.video_analysis_id = av.id
                WHERE av.user_id = ?
            `, [userId]);
            for (const thumb of thumbnails) {
                totalSize += calculateTextSize(thumb.base_title);
                totalSize += calculateTextSize(thumb.description);
                totalSize += calculateTextSize(thumb.hook_phrases_json);
                // Base64 de imagem √© muito pesado
                totalSize += calculateTextSize(thumb.generated_image_base64);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de generated_thumbnails:', err.message);
        }
        
        // viral_thumbnails_library
        try {
            const viralThumbnails = await db.all(
                'SELECT thumbnail_url, thumbnail_description, niche, subniche, style, elements FROM viral_thumbnails_library WHERE user_id = ?', 
                [userId]
            );
            for (const thumb of viralThumbnails) {
                totalSize += calculateTextSize(thumb.thumbnail_url);
                totalSize += calculateTextSize(thumb.thumbnail_description);
                totalSize += calculateTextSize(thumb.niche);
                totalSize += calculateTextSize(thumb.subniche);
                totalSize += calculateTextSize(thumb.style);
                totalSize += calculateTextSize(thumb.elements);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de viral_thumbnails_library:', err.message);
        }
        
        // 4. AGENTES VIRAIS
        // viral_agents
        try {
            const viralAgents = await db.all(
                'SELECT name, description, memory, instructions FROM viral_agents WHERE user_id = ?', 
                [userId]
            );
            for (const agent of viralAgents) {
                totalSize += calculateTextSize(agent.name);
                totalSize += calculateTextSize(agent.description);
                totalSize += calculateTextSize(agent.memory);
                totalSize += calculateTextSize(agent.instructions);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de viral_agents:', err.message);
        }
        
        // viral_agent_files
        try {
            const agentFiles = await db.all(`
                SELECT vaf.file_name, vaf.file_content, vaf.file_type, vaf.file_size
                FROM viral_agent_files vaf
                INNER JOIN viral_agents va ON vaf.agent_id = va.id
                WHERE va.user_id = ?
            `, [userId]);
            for (const file of agentFiles) {
                totalSize += calculateTextSize(file.file_name);
                totalSize += calculateTextSize(file.file_content);
                totalSize += calculateTextSize(file.file_type);
                // Se file_size estiver dispon√≠vel, usar ele (mais preciso)
                if (file.file_size) {
                    totalSize += file.file_size;
                }
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de viral_agent_files:', err.message);
        }
        
        // viral_agent_messages
        try {
            const agentMessages = await db.all(`
                SELECT vam.content
                FROM viral_agent_messages vam
                INNER JOIN viral_agent_conversations vac ON vam.conversation_id = vac.id
                WHERE vac.user_id = ?
            `, [userId]);
            for (const msg of agentMessages) {
                totalSize += calculateTextSize(msg.content);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de viral_agent_messages:', err.message);
        }
        
        // script_agents
        try {
            const scriptAgents = await db.all(
                'SELECT name, description, system_prompt, niche, subniche FROM script_agents WHERE user_id = ?', 
                [userId]
            );
            for (const agent of scriptAgents) {
                totalSize += calculateTextSize(agent.name);
                totalSize += calculateTextSize(agent.description);
                totalSize += calculateTextSize(agent.system_prompt);
                totalSize += calculateTextSize(agent.niche);
                totalSize += calculateTextSize(agent.subniche);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de script_agents:', err.message);
        }
        
        // 5. PROMPTS E IMAGENS
        // scene_prompts_history
        try {
            const scenePrompts = await db.all(
                'SELECT title, script, scenes_json FROM scene_prompts_history WHERE user_id = ?', 
                [userId]
            );
            for (const prompt of scenePrompts) {
                totalSize += calculateTextSize(prompt.title);
                totalSize += calculateTextSize(prompt.script);
                totalSize += calculateTextSize(prompt.scenes_json);
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao calcular armazenamento de scene_prompts_history:', err.message);
        }
        
        // Registrar o total calculado na tabela user_storage com um identificador √∫nico
        const storageKey = `database_data_${userId}`;
        const existing = await db.get(
            'SELECT id FROM user_storage WHERE user_id = ? AND file_path = ?',
            [userId, storageKey]
        );
        
        if (existing) {
            // Atualizar
            try {
                await db.run(
                    'UPDATE user_storage SET file_size = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
                    [totalSize, existing.id]
                );
            } catch (err) {
                // Se a coluna updated_at n√£o existir, atualizar sem ela
                if (err.message && err.message.includes('updated_at')) {
                    await db.run(
                        'UPDATE user_storage SET file_size = ? WHERE id = ?',
                        [totalSize, existing.id]
                    );
                } else {
                    throw err;
                }
            }
        } else {
            // Inserir
            await db.run(
                'INSERT INTO user_storage (user_id, file_path, file_size, file_type) VALUES (?, ?, ?, ?)',
                [userId, storageKey, totalSize, 'database']
            );
        }
        
        console.log(`[STORAGE] Armazenamento de dados do banco calculado para usu√°rio ${userId}: ${(totalSize / (1024 * 1024)).toFixed(2)} MB`);
        
        return totalSize;
    } catch (error) {
        console.error('[STORAGE] Erro ao calcular armazenamento do banco de dados:', error);
        return 0;
    }
}

// Fun√ß√£o para recalcular armazenamento de forma ass√≠ncrona (n√£o bloqueia)
function recalculateStorageAsync(userId) {
    // Executar de forma ass√≠ncrona sem bloquear
    setImmediate(async () => {
        try {
            await calculateAndUpdateDatabaseStorage(userId);
        } catch (error) {
            console.error(`[STORAGE] Erro ao recalcular armazenamento ass√≠ncrono para usu√°rio ${userId}:`, error);
        }
    });
}

// Fun√ß√£o auxiliar para calcular armazenamento usado pelo usu√°rio
// Calcula baseado na tabela user_storage (arquivos + dados do banco)
async function calculateUserStorage(userId, forceRecalculate = false) {
    try {
        // Se for√ßar rec√°lculo ou se n√£o houver registro de dados do banco, recalcular
        const storageKey = `database_data_${userId}`;
        let existing = null;
        try {
            existing = await db.get(
                'SELECT id, updated_at FROM user_storage WHERE user_id = ? AND file_path = ?',
                [userId, storageKey]
            );
        } catch (err) {
            // Se a coluna updated_at n√£o existir, buscar apenas id
            if (err.message && err.message.includes('updated_at')) {
                existing = await db.get(
                    'SELECT id FROM user_storage WHERE user_id = ? AND file_path = ?',
                    [userId, storageKey]
                );
            } else {
                throw err;
            }
        }
        
        // Recalcular se for√ßado ou se n√£o existir registro ou se o registro for muito antigo (> 1 hora)
        const shouldRecalculate = forceRecalculate || !existing || 
            (existing && existing.updated_at && (Date.now() - new Date(existing.updated_at).getTime() > 3600000));
        
        if (shouldRecalculate) {
            await calculateAndUpdateDatabaseStorage(userId);
        }
        
        // Depois, somar tudo da tabela user_storage
        const result = await db.get(
            'SELECT COALESCE(SUM(file_size), 0) as total_size FROM user_storage WHERE user_id = ?', 
            [userId]
        );
        
        const totalSize = result?.total_size || 0;
        
        console.log(`[STORAGE] Armazenamento total calculado para usu√°rio ${userId}: ${(totalSize / (1024 * 1024)).toFixed(2)} MB`);
        
        return totalSize;
    } catch (error) {
        console.error('[STORAGE] Erro ao calcular armazenamento:', error);
        return 0;
    }
}

// Fun√ß√£o auxiliar para registrar um arquivo no armazenamento do usu√°rio
async function registerUserStorage(userId, filePath, fileSize, fileType = null) {
    try {
        // Normalizar o caminho do arquivo (relativo ao diret√≥rio do servidor)
        const path = require('path');
        const normalizedPath = path.isAbsolute(filePath) 
            ? path.relative(__dirname, filePath) 
            : filePath;
        
        // Verificar se o arquivo j√° est√° registrado
        const existing = await db.get(
            'SELECT id FROM user_storage WHERE user_id = ? AND file_path = ?',
            [userId, normalizedPath]
        );
        
        if (existing) {
            // Atualizar tamanho se mudou
            try {
                await db.run(
                    'UPDATE user_storage SET file_size = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
                    [fileSize, existing.id]
                );
            } catch (err) {
                // Se a coluna updated_at n√£o existir, atualizar sem ela
                if (err.message && err.message.includes('updated_at')) {
                    await db.run(
                        'UPDATE user_storage SET file_size = ? WHERE id = ?',
                        [fileSize, existing.id]
                    );
                } else {
                    throw err;
                }
            }
        } else {
            // Registrar novo arquivo
            await db.run(
                'INSERT INTO user_storage (user_id, file_path, file_size, file_type) VALUES (?, ?, ?, ?)',
                [userId, normalizedPath, fileSize, fileType]
            );
        }
        
        console.log(`[STORAGE] Arquivo registrado para usu√°rio ${userId}: ${normalizedPath} (${(fileSize / 1024 / 1024).toFixed(2)} MB)`);
    } catch (error) {
        console.error('[STORAGE] Erro ao registrar armazenamento:', error);
    }
}

// Fun√ß√£o auxiliar para remover registro de arquivo do armazenamento
async function unregisterUserStorage(userId, filePath) {
    try {
        const path = require('path');
        const normalizedPath = path.isAbsolute(filePath) 
            ? path.relative(__dirname, filePath) 
            : filePath;
        
        await db.run(
            'DELETE FROM user_storage WHERE user_id = ? AND file_path = ?',
            [userId, normalizedPath]
        );
        
        console.log(`[STORAGE] Arquivo removido do registro para usu√°rio ${userId}: ${normalizedPath}`);
    } catch (error) {
        console.error('[STORAGE] Erro ao remover registro de armazenamento:', error);
    }
}

// GET /api/credits/balance - Usu√°rio consulta seu pr√≥prio saldo
app.get('/api/credits/balance', authenticateToken, async (req, res) => {
    try {
        console.log('[CR√âDITOS API] Consultando saldo para usu√°rio:', req.user.id);
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [req.user.id]);
        if (!credits) {
            console.log('[CR√âDITOS API] Criando registro de cr√©ditos para usu√°rio:', req.user.id);
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [req.user.id]);
            credits = { balance: 0 };
        }
        
        // Obter plano do usu√°rio e verificar se √© admin
        let userPlan = 'plan-free'; // Padr√£o
        let isAdmin = false;
        
        // Primeiro verificar se req.user j√° tem isAdmin (do token)
        if (req.user && req.user.isAdmin !== undefined) {
            isAdmin = req.user.isAdmin === 1 || req.user.isAdmin === true || req.user.isAdmin === '1';
        }
        
        try {
            // Buscar dados completos do usu√°rio incluindo plano
            const user = await db.get('SELECT id, isAdmin, email, plan, subscription_plan FROM users WHERE id = ?', [req.user.id]);
            if (user) {
                // Obter plano do usu√°rio
                userPlan = user.subscription_plan || user.plan || 'plan-free';
                
                // Verifica√ß√£o robusta de isAdmin (SQLite retorna como INTEGER)
                const adminValue = user.isAdmin;
                // Verificar todas as possibilidades
                isAdmin = adminValue === 1 || 
                         adminValue === true || 
                         adminValue === '1' || 
                         String(adminValue) === '1' ||
                         Number(adminValue) === 1;
                
                console.log('[CR√âDITOS API] Usu√°rio:', user.email, 'ID:', user.id);
                console.log('[CR√âDITOS API] isAdmin valor bruto:', adminValue, 'tipo:', typeof adminValue);
                console.log('[CR√âDITOS API] isAdmin resultado:', isAdmin);
                console.log('[CR√âDITOS API] userPlan:', userPlan);
            } else {
                console.log('[CR√âDITOS API] Usu√°rio n√£o encontrado no banco de dados para ID:', req.user.id);
            }
        } catch (err) {
            console.error('[CR√âDITOS API] Erro ao buscar usu√°rio:', err);
        }
        
        console.log('[CR√âDITOS API] Verifica√ß√£o final - isAdmin:', isAdmin, 'userPlan:', userPlan);
        
        // Calcular armazenamento
        const storageUsed = await calculateUserStorage(req.user.id);
        const storageLimit = await getStorageLimit(userPlan, isAdmin, req.user.id);
        
        console.log('[CR√âDITOS API] Saldo encontrado:', credits.balance);
        console.log('[CR√âDITOS API] Armazenamento - Usado:', (storageUsed / (1024*1024)).toFixed(2), 'MB, Limite:', (storageLimit / (1024*1024*1024)).toFixed(2), 'GB, isAdmin:', isAdmin);
        res.json({ 
            balance: credits.balance,
            storageUsed: storageUsed,
            storageLimit: storageLimit,
            plan: userPlan,
            isAdmin: isAdmin // Incluir isAdmin na resposta para debug
        });
    } catch (error) {
        console.error('[CR√âDITOS API] Erro ao consultar saldo:', error);
        res.status(500).json({ message: 'Erro ao consultar saldo' });
    }
});

// GET /api/user/credits - Alias para /api/credits/balance (compatibilidade)
app.get('/api/user/credits', authenticateToken, async (req, res) => {
    try {
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [req.user.id]);
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [req.user.id]);
            credits = { balance: 0 };
        }
        
        // Obter plano e armazenamento
        let userPlan = 'plan-free';
        let isAdmin = false;
        
        // Primeiro verificar se req.user j√° tem isAdmin (do token)
        if (req.user && req.user.isAdmin !== undefined) {
            isAdmin = req.user.isAdmin === 1 || req.user.isAdmin === true || req.user.isAdmin === '1';
        }
        
        try {
            // Buscar dados completos do usu√°rio incluindo plano
            const user = await db.get('SELECT id, isAdmin, email, plan, subscription_plan FROM users WHERE id = ?', [req.user.id]);
            if (user) {
                // Obter plano do usu√°rio
                userPlan = user.subscription_plan || user.plan || 'plan-free';
                
                // Verifica√ß√£o robusta de isAdmin (SQLite retorna como INTEGER)
                const adminValue = user.isAdmin;
                isAdmin = adminValue === 1 || 
                         adminValue === true || 
                         adminValue === '1' || 
                         String(adminValue) === '1' ||
                         Number(adminValue) === 1;
            }
        } catch (err) {
            console.error('[CR√âDITOS API] Erro ao buscar usu√°rio:', err);
        }
        
        const storageUsed = await calculateUserStorage(req.user.id);
        const storageLimit = await getStorageLimit(userPlan, isAdmin, req.user.id);
        
        res.json({ 
            balance: credits.balance,
            storageUsed: storageUsed,
            storageLimit: storageLimit,
            plan: userPlan,
            isAdmin: isAdmin
        });
    } catch (error) {
        console.error('Erro ao consultar saldo:', error);
        res.status(500).json({ message: 'Erro ao consultar saldo' });
    }
});

// GET /api/user/preferences - Buscar prefer√™ncias do usu√°rio
app.get('/api/user/preferences', authenticateToken, async (req, res) => {
    try {
        let preferences = await db.get('SELECT * FROM user_preferences WHERE user_id = ?', [req.user.id]);
        if (!preferences) {
            // Criar prefer√™ncias padr√£o
            await db.run('INSERT INTO user_preferences (user_id, use_credits_instead_of_own_api) VALUES (?, 0)', [req.user.id]);
            preferences = { use_credits_instead_of_own_api: 0 };
        }
        res.json({ 
            use_credits_instead_of_own_api: preferences.use_credits_instead_of_own_api === 1 
        });
    } catch (error) {
        console.error('Erro ao buscar prefer√™ncias:', error);
        res.status(500).json({ message: 'Erro ao buscar prefer√™ncias' });
    }
});

// POST /api/user/preferences - Salvar prefer√™ncias do usu√°rio
app.post('/api/user/preferences', authenticateToken, async (req, res) => {
    try {
        const { use_credits_instead_of_own_api } = req.body;
        
        // Verificar se j√° existe
        const existing = await db.get('SELECT id FROM user_preferences WHERE user_id = ?', [req.user.id]);
        
        if (existing) {
            await db.run(
                'UPDATE user_preferences SET use_credits_instead_of_own_api = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?',
                [use_credits_instead_of_own_api ? 1 : 0, req.user.id]
            );
        } else {
            await db.run(
                'INSERT INTO user_preferences (user_id, use_credits_instead_of_own_api) VALUES (?, ?)',
                [req.user.id, use_credits_instead_of_own_api ? 1 : 0]
            );
        }
        
        res.json({ 
            message: 'Prefer√™ncias salvas com sucesso',
            use_credits_instead_of_own_api: use_credits_instead_of_own_api 
        });
    } catch (error) {
        console.error('Erro ao salvar prefer√™ncias:', error);
        res.status(500).json({ message: 'Erro ao salvar prefer√™ncias' });
    }
});

// POST /api/storage/recalculate - For√ßar rec√°lculo do armazenamento
app.post('/api/storage/recalculate', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        
        // For√ßar rec√°lculo completo
        await calculateUserStorage(userId, true);
        
        // Obter o resultado atualizado
        const result = await db.get(
            'SELECT COALESCE(SUM(file_size), 0) as total_size FROM user_storage WHERE user_id = ?', 
            [userId]
        );
        
        const totalSize = result?.total_size || 0;
        
        res.json({ 
            success: true, 
            message: 'Armazenamento recalculado com sucesso',
            storageUsed: totalSize,
            storageUsedMB: (totalSize / (1024 * 1024)).toFixed(2)
        });
    } catch (error) {
        console.error('[STORAGE] Erro ao recalcular armazenamento:', error);
        res.status(500).json({ message: 'Erro ao recalcular armazenamento', error: error.message });
    }
});

// GET /api/credits/transactions - Usu√°rio consulta suas transa√ß√µes com detalhes
app.get('/api/credits/transactions', authenticateToken, async (req, res) => {
    try {
        // Buscar transa√ß√µes com JOIN para obter detalhes de uso
        const transactions = await db.all(`
            SELECT 
                ct.id,
                ct.amount,
                ct.transaction_type,
                ct.description,
                ct.created_at,
                cu.operation_type,
                cu.details,
                cu.units_consumed,
                ap.name as api_name,
                ap.provider as api_provider,
                ap.model as api_model
            FROM credit_transactions ct
            LEFT JOIN credit_usage cu ON ct.user_id = cu.user_id 
                AND ABS(ct.amount) = cu.credits_used 
                AND DATE(ct.created_at) = DATE(cu.created_at)
                AND ct.transaction_type = 'debit'
            LEFT JOIN api_providers ap ON cu.api_provider_id = ap.id
            WHERE ct.user_id = ?
            ORDER BY ct.created_at DESC
            LIMIT 100
        `, [req.user.id]);
        
        // Processar transa√ß√µes para adicionar informa√ß√µes detalhadas
        const processedTransactions = transactions.map(t => {
            let details = null;
            let operationInfo = null;
            
            if (t.details) {
                try {
                    details = typeof t.details === 'string' ? JSON.parse(t.details) : t.details;
                } catch (e) {
                    details = { raw: t.details };
                }
            }
            
            // Montar informa√ß√£o detalhada sobre a opera√ß√£o
            if (t.operation_type) {
                const operationTypes = {
                    // Roteiros
                    'api_script_agents_generate': 'Gerador de Roteiro',
                    '/api/generate': 'Gerador de Roteiro',
                    '/api/scripts': 'Gerador de Roteiro',
                    '/api/scripts/generate': 'Gerador de Roteiro',
                    '/api/script-agents/:agentId/generate': 'Gerador de Roteiro',
                    '/api/script-agents/:agentId/generate/laozhang': 'Gerador de Roteiro',
                    // V√≠deos
                    'api_video_generation': 'Gerador de V√≠deo',
                    // Voz
                    'api_tts_generation': 'Gera√ß√£o de Voz',
                    'api_tts_preview': 'Preview de Voz',
                    // Imagens
                    'api_image_generation': 'Gera√ß√£o de Imagem',
                    // Thumbnails
                    'api_analyze_thumbnail': 'Gerador de Thumbnail',
                    '/api/analyze/thumbnail': 'Gerador de Thumbnail',
                    '/api/analyze/thumbnail/laozhang': 'Gerador de Thumbnail',
                    // Cenas
                    '/api/generate/scene-prompts': 'Gerador de Cenas',
                    '/api/generate/scene-prompts/laozhang': 'Gerador de Cenas',
                    // An√°lise de T√≠tulos
                    '/api/analyze/titles': 'An√°lise de T√≠tulos',
                    '/api/analyze/titles/laozhang': 'An√°lise de T√≠tulos',
                    // Detec√ß√£o de Personagens
                    'api_detect_characters': 'Detec√ß√£o de Personagens',
                    '/api/detect/characters': 'Detec√ß√£o de Personagens',
                    '/api/detect/characters/laozhang': 'Detec√ß√£o de Personagens',
                    // Busca de Subnicho
                    'api_niche_find_subniche': 'Busca de Subnicho',
                    '/api/niche/find-subniche': 'Busca de Subnicho',
                    '/api/niche/find-subniche/laozhang': 'Busca de Subnicho',
                    // An√°lise de Competidor
                    'api_niche_analyze_competitor': 'An√°lise de Competidor',
                    '/api/niche/analyze-competitor': 'An√°lise de Competidor',
                    '/api/niche/analyze-competitor/laozhang': 'An√°lise de Competidor',
                    // Cria√ß√£o de Agente
                    '/api/script-agents/create': 'Cria√ß√£o de Agente',
                    '/api/script-agents/create/laozhang': 'Cria√ß√£o de Agente',
                    // Reescrever Prompt
                    'api_rewrite_prompt': 'Reescrever Prompt',
                    '/api/rewrite/blocked-prompt': 'Reescrever Prompt',
                    '/api/rewrite/blocked-prompt/laozhang': 'Reescrever Prompt',
                    // An√°lise de Transcri√ß√£o
                    'api_transcript_analyze': 'An√°lise de Transcri√ß√£o',
                    '/api/video/transcript/analyze': 'An√°lise de Transcri√ß√£o',
                    '/api/video/transcript/analyze/laozhang': 'An√°lise de Transcri√ß√£o',
                    // Gen√©ricos
                    'api_generation': 'Gera√ß√£o de Conte√∫do',
                    'api_call': 'Ferramenta'
                };
                
                // Tentar extrair nome da ferramenta da descri√ß√£o se ela contiver "Ferramenta - Laozhang.ai"
                let toolName = operationTypes[t.operation_type];
                
                // Se n√£o encontrou pelo operationType, tentar pelo endpoint nos details
                if (!toolName && details?.endpoint) {
                    for (const [key, value] of Object.entries(operationTypes)) {
                        if (details.endpoint.includes(key) || key.includes(details.endpoint)) {
                            toolName = value;
                            break;
                        }
                    }
                }
                
                // Se ainda n√£o encontrou, usar fallback
                if (!toolName) {
                    toolName = operationTypes[t.operation_type] || t.operation_type;
                }
                
                // Priorizar modelo dos details (modelo real usado), depois api_model (modelo do provider), depois descri√ß√£o
                let modelName = details?.model || t.api_model || 'N/A';
                
                // Se a descri√ß√£o cont√©m "Ferramenta - Laozhang.ai", tentar extrair informa√ß√µes
                if ((!modelName || modelName === 'N/A') && t.description && t.description.includes('Ferramenta - Laozhang.ai')) {
                    // Tentar extrair o modelo da descri√ß√£o
                    const modelMatch = t.description.match(/\(([^)]+)\)/);
                    if (modelMatch && modelMatch[1]) {
                        modelName = modelMatch[1];
                    }
                }
                
                // Se ainda n√£o tem modelo, tentar extrair da descri√ß√£o atual
                if ((!modelName || modelName === 'N/A') && t.description && t.description.includes(' - ')) {
                    const parts = t.description.split(' - ');
                    if (parts.length > 1) {
                        const possibleModel = parts[parts.length - 1];
                        // Verificar se parece um modelo (n√£o √© apenas o nome da ferramenta)
                        if (possibleModel && !possibleModel.includes('Gerador') && !possibleModel.includes('Ferramenta')) {
                            modelName = possibleModel;
                        }
                    }
                }
                
                // Formatar modelo se necess√°rio
                if (modelName && modelName !== 'N/A') {
                    if (modelName.includes('claude-3-7-sonnet') || modelName === 'claude-3-7-sonnet-20250219') {
                        modelName = 'Claude 3.7 Sonnet';
                    } else if (modelName.includes('gemini-2.5-pro') || modelName === 'gemini-2.5-pro') {
                        modelName = 'Gemini 2.5 Pro';
                    } else if (modelName === 'gpt-4o' || modelName.includes('gpt-4o')) {
                        modelName = 'GPT-4o';
                    } else if (modelName.includes('veo-3.1-landscape-fast-fl') || modelName === 'veo-3.1-landscape-fast-fl') {
                        modelName = 'Veo 3.1 Landscape Fast';
                    } else if (modelName.includes('veo-3.1-landscape-fast') || modelName === 'veo-3.1-landscape-fast') {
                        modelName = 'Veo 3.1 Landscape Fast';
                    } else if (modelName.includes('veo-3.1-landscape-fl') || modelName === 'veo-3.1-landscape-fl') {
                        modelName = 'Veo 3.1 Landscape';
                    } else if (modelName.includes('veo-3.1-landscape') || modelName === 'veo-3.1-landscape') {
                        modelName = 'Veo 3.1 Landscape';
                    } else if (modelName.includes('veo-3.1-fast-fl') || modelName === 'veo-3.1-fast-fl') {
                        modelName = 'Veo 3.1 Fast';
                    } else if (modelName.includes('veo-3.1-fast') || modelName === 'veo-3.1-fast-generate-preview' || modelName === 'veo-3.1-fast') {
                        modelName = 'Veo 3.1 Fast';
                    } else if (modelName.includes('veo-3.1-fl') || modelName === 'veo-3.1-fl') {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('veo-3.1-generate') || modelName === 'veo-3.1-generate-preview' || modelName === 'veo-3.1') {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('veo-3.1')) {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('voz-premium') || modelName.includes('genaipro')) {
                        modelName = 'Voz Premium';
                    }
                    
                    // Limpeza final: remover qualquer refer√™ncia a fornecedores
                    modelName = modelName
                        .replace(/genaipro/gi, 'Voz Premium')
                        .replace(/laozhang/gi, 'Provedor Externo')
                        .replace(/laozhang\.ai/gi, 'Provedor Externo')
                        .replace(/openai/gi, '')
                        .replace(/anthropic/gi, '')
                        .replace(/google/gi, '')
                        .replace(/\s+/g, ' ')
                        .trim();
                }
                
                operationInfo = {
                    type: t.operation_type,
                    typeName: toolName,
                    model: modelName !== 'N/A' ? modelName : null,
                    units: t.units_consumed || null,
                    endpoint: details?.endpoint || null,
                    details: details
                };
            }
            
            // Se a descri√ß√£o cont√©m "Ferramenta - Laozhang.ai", substituir pela descri√ß√£o correta baseada no operationInfo
            let finalDescription = t.description;
            if (finalDescription && finalDescription.includes('Ferramenta - Laozhang.ai')) {
                if (operationInfo && operationInfo.typeName) {
                    finalDescription = operationInfo.typeName;
                    if (operationInfo.model) {
                        finalDescription += ` - ${operationInfo.model}`;
                    }
                }
            }
            
            // Limpeza final da descri√ß√£o: remover refer√™ncias a fornecedores
            finalDescription = finalDescription
                .replace(/genaipro/gi, 'Voz Premium')
                .replace(/laozhang/gi, 'Provedor Externo')
                .replace(/laozhang\.ai/gi, 'Provedor Externo')
                .replace(/openai/gi, '')
                .replace(/anthropic/gi, '')
                .replace(/google/gi, '')
                .replace(/\s+/g, ' ')
                .trim();
            
            finalDescription = sanitizeUserFacingText(
                finalDescription || (operationInfo?.typeName || 'Opera√ß√£o'),
                operationInfo?.typeName || 'Opera√ß√£o'
            );
            
            return {
                id: t.id,
                amount: t.amount,
                transaction_type: t.transaction_type,
                description: finalDescription,
                created_at: t.created_at,
                operation: operationInfo,
                isCredit: t.transaction_type === 'credit'
            };
        });
        
        res.json({ data: processedTransactions });
    } catch (error) {
        console.error('Erro ao listar transa√ß√µes:', error);
        res.status(500).json({ message: 'Erro ao listar transa√ß√µes' });
    }
});

// === ROTAS ADMINISTRATIVAS DE CR√âDITOS ===

// GET /api/admin/credits/balance/:userId - Consulta saldo de um usu√°rio espec√≠fico
app.get('/api/admin/credits/balance/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId);
        if (!userId) {
            return res.status(400).json({ message: 'ID do usu√°rio inv√°lido' });
        }
        
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [userId]);
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [userId]);
            credits = { balance: 0 };
        }
        res.json({ balance: credits.balance });
    } catch (error) {
        console.error('Erro ao consultar saldo:', error);
        res.status(500).json({ message: 'Erro ao consultar saldo' });
    }
});

// POST /api/admin/credits/add - Adiciona cr√©ditos a um usu√°rio
app.post('/api/admin/credits/add', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { user_id, amount, description } = req.body;
        if (!user_id || !amount || amount <= 0) {
            return res.status(400).json({ message: 'user_id e amount s√£o obrigat√≥rios e amount deve ser positivo' });
        }
        
        const user = await db.get('SELECT id FROM users WHERE id = ?', [user_id]);
        if (!user) return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });
        
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [user_id]);
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [user_id]);
            credits = { balance: 0 };
        }
        
        const newBalance = credits.balance + parseFloat(amount);
        await db.run('UPDATE user_credits SET balance = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?', [newBalance, user_id]);
        await db.run(`
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description, admin_id)
            VALUES (?, ?, 'credit', ?, ?)
        `, [user_id, amount, description || 'Cr√©ditos adicionados pelo administrador', req.user.id]);
        
        res.json({ message: 'Cr√©ditos adicionados com sucesso', new_balance: newBalance });
    } catch (error) {
        console.error('Erro ao adicionar cr√©ditos:', error);
        res.status(500).json({ message: 'Erro ao adicionar cr√©ditos' });
    }
});

// ================================================
// ROTAS DE ADMINISTRA√á√ÉO - ARMAZENAMENTO
// ================================================

// GET /api/admin/storage/stats - Obter estat√≠sticas de armazenamento do servidor
app.get('/api/admin/storage/stats', authenticateToken, isAdmin, async (req, res) => {
    try {
        const fs = require('fs');
        const path = require('path');
        const os = require('os');
        const { execSync } = require('child_process');
        
        // Calcular espa√ßo total do disco (n√£o RAM)
        let totalSpace = 0;
        try {
            // Tentar usar comando do sistema para obter espa√ßo em disco
            if (process.platform === 'win32') {
                // Windows: usar wmic
                const output = execSync('wmic logicaldisk get size,freespace,caption', { encoding: 'utf-8' });
                const lines = output.split('\n').filter(line => line.trim() && !line.includes('Caption'));
                let total = 0;
                for (const line of lines) {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        const size = parseInt(parts[parts.length - 1]);
                        if (!isNaN(size)) {
                            total += size;
                        }
                    }
                }
                totalSpace = total;
            } else {
                // Linux/Unix: usar df
                const output = execSync('df -B1 /', { encoding: 'utf-8' });
                const lines = output.split('\n');
                if (lines.length > 1) {
                    const parts = lines[1].trim().split(/\s+/);
                    if (parts.length >= 2) {
                        totalSpace = parseInt(parts[1]); // Tamanho total em bytes
                    }
                }
            }
        } catch (err) {
            console.warn('[STORAGE] Erro ao obter espa√ßo em disco, usando fallback:', err.message);
            // Fallback: tentar usar fs.statfs se dispon√≠vel (Node.js 18+)
            try {
                const stats = fs.statfsSync ? fs.statfsSync('/') : null;
                if (stats && stats.blocks && stats.bsize) {
                    totalSpace = stats.blocks * stats.bsize;
                } else {
                    // √öltimo fallback: usar espa√ßo do diret√≥rio atual
                    const stats = fs.statSync(__dirname);
                    // N√£o temos como saber o tamanho total, ent√£o vamos usar um valor padr√£o ou calcular do diret√≥rio
                    totalSpace = 200 * 1024 * 1024 * 1024; // 200 GB como padr√£o se n√£o conseguir detectar
                }
            } catch (fallbackErr) {
                console.warn('[STORAGE] Fallback tamb√©m falhou, usando valor padr√£o');
                totalSpace = 200 * 1024 * 1024 * 1024; // 200 GB como padr√£o
            }
        }
        
        // Buscar todos os usu√°rios
        const users = await db.all('SELECT id, email, name, isAdmin FROM users');
        
        // Calcular espa√ßo usado por usu√°rio (usando a tabela user_storage)
        const usersStorage = [];
        let totalUsersStorage = 0;
        
        for (const user of users) {
            const userStorage = await calculateUserStorage(user.id);
            totalUsersStorage += userStorage;
            
            // Obter limite do usu√°rio
            let userPlan = 'plan-free';
            let isUserAdmin = false;
            try {
                const userData = await db.get('SELECT plan, subscription_plan, isAdmin FROM users WHERE id = ?', [user.id]);
                if (userData) {
                    userPlan = userData.subscription_plan || userData.plan || 'plan-free';
                    isUserAdmin = userData.isAdmin === 1 || userData.isAdmin === true || String(userData.isAdmin) === '1';
                }
            } catch (err) {
                // Ignorar
            }
            
            const storageLimit = await getStorageLimit(userPlan, isUserAdmin, user.id);
            
            usersStorage.push({
                userId: user.id,
                email: user.email,
                name: user.name,
                isAdmin: isUserAdmin,
                plan: userPlan,
                storageUsed: userStorage,
                storageLimit: storageLimit,
                percentage: storageLimit > 0 ? (userStorage / storageLimit * 100) : 0
            });
        }
        
        // Calcular espa√ßo usado em temp_audio (arquivos n√£o associados a usu√°rios)
        const tempAudioDir = path.join(__dirname, 'temp_audio');
        let tempAudioSize = 0;
        if (fs.existsSync(tempAudioDir)) {
            const files = fs.readdirSync(tempAudioDir);
            for (const file of files) {
                try {
                    const filePath = path.join(tempAudioDir, file);
                    const stats = fs.statSync(filePath);
                    if (stats.isFile()) {
                        tempAudioSize += stats.size;
                    }
                } catch (err) {
                    // Ignorar erros
                }
            }
        }
        
        res.json({
            serverTotalSpace: totalSpace,
            tempAudioSize: tempAudioSize,
            totalUsersStorage: totalUsersStorage,
            users: usersStorage,
            totalUsers: usersStorage.length
        });
    } catch (error) {
        console.error('[ADMIN STORAGE] Erro ao obter estat√≠sticas:', error);
        res.status(500).json({ message: 'Erro ao obter estat√≠sticas de armazenamento' });
    }
});

// POST /api/admin/storage/sync - Sincronizar armazenamento de todos os usu√°rios
app.post('/api/admin/storage/sync', authenticateToken, isAdmin, async (req, res) => {
    try {
        const fs = require('fs');
        const path = require('path');
        
        console.log('[STORAGE SYNC] Iniciando sincroniza√ß√£o de armazenamento...');
        
        // Buscar todos os usu√°rios
        const users = await db.all('SELECT id FROM users');
        let syncedCount = 0;
        let totalFiles = 0;
        
        for (const user of users) {
            const userId = user.id;
            
            // Verificar arquivos em temp_audio que pertencem a este usu√°rio
            const tempAudioDir = path.join(__dirname, 'temp_audio');
            if (fs.existsSync(tempAudioDir)) {
                const files = fs.readdirSync(tempAudioDir);
                const userIdStr = String(userId);
                
                for (const file of files) {
                    // Verificar se o arquivo pertence a este usu√°rio
                    if (file.includes(userIdStr) || file.startsWith(`${userIdStr}_`) || file.includes(`_${userIdStr}_`)) {
                        const filePath = path.join(tempAudioDir, file);
                        try {
                            const stats = fs.statSync(filePath);
                            if (stats.isFile()) {
                                const relativePath = path.relative(__dirname, filePath);
                                await registerUserStorage(userId, relativePath, stats.size, 'audio');
                                totalFiles++;
                            }
                        } catch (err) {
                            console.error(`[STORAGE SYNC] Erro ao processar arquivo ${file}:`, err);
                        }
                    }
                }
            }
            
            syncedCount++;
        }
        
        console.log(`[STORAGE SYNC] Sincroniza√ß√£o conclu√≠da: ${syncedCount} usu√°rios, ${totalFiles} arquivos registrados`);
        
        res.json({ 
            message: 'Sincroniza√ß√£o conclu√≠da com sucesso',
            usersSynced: syncedCount,
            filesRegistered: totalFiles
        });
    } catch (error) {
        console.error('[STORAGE SYNC] Erro ao sincronizar armazenamento:', error);
        res.status(500).json({ message: 'Erro ao sincronizar armazenamento', error: error.message });
    }
});

// PUT /api/admin/storage/reset/:userId - Zerar armazenamento de um usu√°rio
app.put('/api/admin/storage/reset/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId);
        const fs = require('fs');
        const path = require('path');
        
        // Deletar registros de armazenamento do usu√°rio
        try {
            await db.run('DELETE FROM user_storage WHERE user_id = ?', [userId]);
            console.log(`[STORAGE] Registros de armazenamento deletados para usu√°rio ${userId}`);
        } catch (err) {
            console.error('[STORAGE] Erro ao deletar registros de armazenamento:', err);
        }
        
        // Deletar arquivos em temp_audio do usu√°rio (arquivos que cont√™m o userId ou s√£o do usu√°rio)
        const tempAudioDir = path.join(__dirname, 'temp_audio');
        let deletedFiles = 0;
        let freedSpace = 0;
        
        if (fs.existsSync(tempAudioDir)) {
            const files = fs.readdirSync(tempAudioDir);
            for (const file of files) {
                try {
                    // Verificar se o arquivo pertence ao usu√°rio (pode conter userId no nome ou timestamp)
                    // Por seguran√ßa, vamos listar todos e verificar propriedades
                    const filePath = path.join(tempAudioDir, file);
                    const stats = fs.statSync(filePath);
                    
                    // Deletar arquivo (por enquanto deletamos todos os arquivos tempor√°rios)
                    // Em produ√ß√£o, voc√™ pode querer associar arquivos a usu√°rios em uma tabela
                    fs.unlinkSync(filePath);
                    deletedFiles++;
                    freedSpace += stats.size;
                } catch (err) {
                    console.error(`[ADMIN STORAGE] Erro ao deletar arquivo ${file}:`, err);
                }
            }
        }
        
        // Deletar arquivos associados ao usu√°rio em user_files (se a tabela existir)
        try {
            const userFiles = await db.all('SELECT file_path FROM user_files WHERE user_id = ?', [userId]);
            for (const file of userFiles) {
                try {
                    if (file.file_path) {
                        const filePath = path.join(__dirname, file.file_path);
                        if (fs.existsSync(filePath)) {
                            const stats = fs.statSync(filePath);
                            fs.unlinkSync(filePath);
                            freedSpace += stats.size;
                        }
                    }
                } catch (err) {
                    // Ignorar erros
                }
            }
            await db.run('DELETE FROM user_files WHERE user_id = ?', [userId]);
        } catch (err) {
            // Tabela pode n√£o existir, ignorar
        }
        
        res.json({
            success: true,
            message: `Armazenamento zerado para o usu√°rio ${userId}`,
            deletedFiles: deletedFiles,
            freedSpace: freedSpace
        });
    } catch (error) {
        console.error('[ADMIN STORAGE] Erro ao zerar armazenamento:', error);
        res.status(500).json({ message: 'Erro ao zerar armazenamento' });
    }
});

// PUT /api/admin/storage/limit/:userId - Alterar limite de armazenamento de um usu√°rio
app.put('/api/admin/storage/limit/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId);
        const { storageLimit } = req.body;
        
        if (!storageLimit || storageLimit < 0) {
            return res.status(400).json({ message: 'Limite de armazenamento inv√°lido' });
        }
        
        // Converter para bytes se necess√°rio
        let limitInBytes = storageLimit;
        if (typeof storageLimit === 'string') {
            // Se vier como "100GB", "500MB", etc
            const match = storageLimit.match(/^(\d+(?:\.\d+)?)\s*(GB|MB|KB|B)$/i);
            if (match) {
                const value = parseFloat(match[1]);
                const unit = match[2].toUpperCase();
                if (unit === 'GB') limitInBytes = value * 1024 * 1024 * 1024;
                else if (unit === 'MB') limitInBytes = value * 1024 * 1024;
                else if (unit === 'KB') limitInBytes = value * 1024;
                else limitInBytes = value;
            } else {
                limitInBytes = parseInt(storageLimit);
            }
        }
        
        // Criar ou atualizar limite customizado na tabela user_storage_limits (se n√£o existir, criar)
        try {
            await db.run(`
                CREATE TABLE IF NOT EXISTS user_storage_limits (
                    user_id INTEGER PRIMARY KEY,
                    custom_limit INTEGER NOT NULL,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                )
            `);
            
            await db.run(`
                INSERT OR REPLACE INTO user_storage_limits (user_id, custom_limit, updated_at)
                VALUES (?, ?, CURRENT_TIMESTAMP)
            `, [userId, limitInBytes]);
        } catch (err) {
            console.error('[ADMIN STORAGE] Erro ao salvar limite customizado:', err);
            return res.status(500).json({ message: 'Erro ao salvar limite de armazenamento' });
        }
        
        res.json({
            success: true,
            message: `Limite de armazenamento atualizado para ${(limitInBytes / (1024 * 1024 * 1024)).toFixed(2)} GB`,
            storageLimit: limitInBytes
        });
    } catch (error) {
        console.error('[ADMIN STORAGE] Erro ao alterar limite:', error);
        res.status(500).json({ message: 'Erro ao alterar limite de armazenamento' });
    }
});

// GET /api/admin/storage/limit/:userId - Obter limite customizado de um usu√°rio
app.get('/api/admin/storage/limit/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId);
        
        try {
            const customLimit = await db.get('SELECT custom_limit FROM user_storage_limits WHERE user_id = ?', [userId]);
            if (customLimit) {
                return res.json({ hasCustomLimit: true, storageLimit: customLimit.custom_limit });
            }
        } catch (err) {
            // Tabela pode n√£o existir ainda
        }
        
        res.json({ hasCustomLimit: false });
    } catch (error) {
        console.error('[ADMIN STORAGE] Erro ao obter limite:', error);
        res.status(500).json({ message: 'Erro ao obter limite de armazenamento' });
    }
});

// PUT /api/admin/credits/reset - Zerar cr√©ditos de um usu√°rio
app.put('/api/admin/credits/reset', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { user_id } = req.body;
        if (!user_id) {
            return res.status(400).json({ message: 'user_id √© obrigat√≥rio' });
        }
        
        const user = await db.get('SELECT id, email FROM users WHERE id = ?', [user_id]);
        if (!user) return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });
        
        // Obter saldo atual antes de zerar
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [user_id]);
        const oldBalance = credits ? credits.balance : 0;
        
        // Zerar saldo
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [user_id]);
        } else {
            await db.run('UPDATE user_credits SET balance = 0, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?', [user_id]);
        }
        
        // Registrar transa√ß√£o
        if (oldBalance > 0) {
            await db.run(`
                INSERT INTO credit_transactions (user_id, amount, transaction_type, description, admin_id)
                VALUES (?, ?, 'debit', ?, ?)
            `, [user_id, -oldBalance, `Cr√©ditos zerados pelo administrador (saldo anterior: ${oldBalance.toFixed(2)})`, req.user.id]);
        }
        
        res.json({ message: 'Cr√©ditos zerados com sucesso', old_balance: oldBalance, new_balance: 0 });
    } catch (error) {
        console.error('Erro ao zerar cr√©ditos:', error);
        res.status(500).json({ message: 'Erro ao zerar cr√©ditos' });
    }
});

// ================================================
// ROTAS ADMINISTRATIVAS DE APIs
// ================================================

// GET /api/admin/api-providers - Listar todas as APIs
app.get('/api/admin/api-providers', authenticateToken, isAdmin, async (req, res) => {
    try {
        const apis = await db.all('SELECT * FROM api_providers ORDER BY created_at DESC');
        // Descriptografar chaves de API para exibi√ß√£o (apenas para admin)
        const apisWithDecryptedKeys = apis.map(api => {
            if (api.api_key) {
                try {
                    const decrypted = decrypt(api.api_key);
                    if (decrypted) {
                        return { ...api, api_key: decrypted };
                    }
                } catch (err) {
                    // Se falhar ao descriptografar, pode n√£o estar criptografada
                    return api;
                }
            }
            return api;
        });
        res.json(apisWithDecryptedKeys);
    } catch (error) {
        console.error('Erro ao listar APIs:', error);
        res.status(500).json({ message: 'Erro ao listar APIs' });
    }
});

// POST /api/admin/api-providers - Criar nova API
app.post('/api/admin/api-providers', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { name, provider, model, api_key, unit_type, unit_size, real_cost_per_unit, credits_per_unit, markup, is_premium, is_active, is_default } = req.body;
        
        if (!name || !provider || !model || !api_key) {
            return res.status(400).json({ message: 'Nome, provedor, modelo e chave de API s√£o obrigat√≥rios' });
        }
        
        // Se marcar como padr√£o, desmarcar outras
        if (is_default) {
            await db.run('UPDATE api_providers SET is_default = 0');
        }
        
        const result = await db.run(`
            INSERT INTO api_providers (
                name, provider, model, api_key, unit_type, unit_size,
                real_cost_per_unit, credits_per_unit, markup, is_premium,
                is_active, is_default
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
            name, provider, model, api_key, unit_type || 'tokens', unit_size || 1000,
            real_cost_per_unit || 0.0, credits_per_unit || 1.0, markup || 1.0,
            is_premium || 0, is_active !== undefined ? is_active : 1, is_default || 0
        ]);
        
        res.json({ message: 'API criada com sucesso', id: result.lastID });
    } catch (error) {
        console.error('Erro ao criar API:', error);
        res.status(500).json({ message: 'Erro ao criar API' });
    }
});

// PUT /api/admin/api-providers/:id - Editar API
app.put('/api/admin/api-providers/:id', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { id } = req.params;
        const { name, provider, model, api_key, unit_type, unit_size, real_cost_per_unit, credits_per_unit, markup, is_premium, is_active, is_default } = req.body;
        
        // Se marcar como padr√£o, desmarcar outras
        if (is_default) {
            await db.run('UPDATE api_providers SET is_default = 0 WHERE id != ?', [id]);
        }
        
        await db.run(`
            UPDATE api_providers SET
                name = ?, provider = ?, model = ?, api_key = ?,
                unit_type = ?, unit_size = ?, real_cost_per_unit = ?,
                credits_per_unit = ?, markup = ?, is_premium = ?,
                is_active = ?, is_default = ?, updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        `, [
            name, provider, model, api_key, unit_type, unit_size,
            real_cost_per_unit, credits_per_unit, markup, is_premium,
            is_active, is_default, id
        ]);
        
        res.json({ message: 'API atualizada com sucesso' });
    } catch (error) {
        console.error('Erro ao atualizar API:', error);
        res.status(500).json({ message: 'Erro ao atualizar API' });
    }
});

// DELETE /api/admin/api-providers/:id - Deletar API
app.delete('/api/admin/api-providers/:id', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { id } = req.params;
        await db.run('DELETE FROM api_providers WHERE id = ?', [id]);
        res.json({ message: 'API exclu√≠da com sucesso' });
    } catch (error) {
        console.error('Erro ao excluir API:', error);
        res.status(500).json({ message: 'Erro ao excluir API' });
    }
});

// GET /api/admin/credits/statistics - Estat√≠sticas de cr√©ditos (completo)
app.get('/api/admin/credits/statistics', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { startDate, endDate, userId, tool } = req.query;
        
        let dateFilter = '';
        let params = [];
        
        if (startDate && endDate) {
            dateFilter = 'AND DATE(cu.created_at) BETWEEN DATE(?) AND DATE(?)';
            params.push(startDate, endDate);
        } else if (startDate) {
            dateFilter = 'AND DATE(cu.created_at) >= DATE(?)';
            params.push(startDate);
        } else if (endDate) {
            dateFilter = 'AND DATE(cu.created_at) <= DATE(?)';
            params.push(endDate);
        } else {
            // Padr√£o: √∫ltimos 30 dias
            dateFilter = 'AND DATE(cu.created_at) >= DATE("now", "-30 days")';
        }
        
        if (userId) {
            dateFilter += ' AND cu.user_id = ?';
            params.push(userId);
        }
        
        // Estat√≠sticas gerais
        const totalStats = await db.get(`
            SELECT 
                COUNT(*) as total_operations,
                SUM(cu.credits_used) as total_credits,
                AVG(cu.credits_used) as avg_credits_per_operation,
                MIN(cu.credits_used) as min_credits,
                MAX(cu.credits_used) as max_credits,
                COUNT(DISTINCT cu.user_id) as unique_users,
                COUNT(DISTINCT DATE(cu.created_at)) as days_with_usage
            FROM credit_usage cu
            WHERE 1=1 ${dateFilter}
        `, params);
        
        // Estat√≠sticas por dia
        const dailyStats = await db.all(`
            SELECT 
                DATE(cu.created_at) as date,
                COUNT(*) as operations,
                SUM(cu.credits_used) as total_credits,
                COUNT(DISTINCT cu.user_id) as unique_users
            FROM credit_usage cu
            WHERE 1=1 ${dateFilter}
            GROUP BY DATE(cu.created_at)
            ORDER BY date DESC
            LIMIT 90
        `, params);
        
        // Estat√≠sticas por ferramenta
        let toolFilter = '';
        let toolParams = [...params];
        if (tool) {
            toolFilter = 'AND ct.description = ?';
            toolParams.push(tool);
        }
        
        let ctDateFilter = '';
        if (startDate && endDate) {
            ctDateFilter = 'AND DATE(ct.created_at) BETWEEN DATE(?) AND DATE(?)';
        } else if (startDate) {
            ctDateFilter = 'AND DATE(ct.created_at) >= DATE(?)';
        } else if (endDate) {
            ctDateFilter = 'AND DATE(ct.created_at) <= DATE(?)';
        } else {
            ctDateFilter = 'AND DATE(ct.created_at) >= DATE("now", "-30 days")';
        }
        
        const toolStats = await db.all(`
            SELECT 
                ct.description as tool_name,
                COUNT(*) as operations,
                SUM(ABS(ct.amount)) as total_credits,
                AVG(ABS(ct.amount)) as avg_credits,
                COUNT(DISTINCT ct.user_id) as unique_users
            FROM credit_transactions ct
            WHERE ct.transaction_type = 'debit' ${ctDateFilter} ${toolFilter}
            GROUP BY ct.description
            ORDER BY total_credits DESC
        `, toolParams);
        
        // Estat√≠sticas por usu√°rio (top 20)
        const userStats = await db.all(`
            SELECT 
                u.id,
                u.email,
                u.whatsapp,
                COUNT(cu.id) as operations,
                SUM(cu.credits_used) as total_credits,
                AVG(cu.credits_used) as avg_credits
            FROM credit_usage cu
            JOIN users u ON cu.user_id = u.id
            WHERE 1=1 ${dateFilter}
            GROUP BY u.id, u.email, u.whatsapp
            ORDER BY total_credits DESC
            LIMIT 20
        `, params);
        
        // Estat√≠sticas por API Provider
        const apiStats = await db.all(`
            SELECT 
                ap.id,
                ap.name,
                ap.provider,
                ap.model,
                COUNT(cu.id) as operations,
                SUM(cu.credits_used) as total_credits,
                SUM(cu.units_consumed) as total_units
            FROM credit_usage cu
            JOIN api_providers ap ON cu.api_provider_id = ap.id
            WHERE 1=1 ${dateFilter}
            GROUP BY ap.id, ap.name, ap.provider, ap.model
            ORDER BY total_credits DESC
        `, params);
        
        // Total distribu√≠do (cr√©ditos adicionados)
        const totalDistributed = await db.get(`
            SELECT SUM(amount) as total FROM credit_transactions WHERE transaction_type = 'credit'
        `);
        
        // Usu√°rios com cr√©ditos
        const usersWithCredits = await db.get(`
            SELECT COUNT(*) as count FROM user_credits WHERE balance > 0
        `);
        
        res.json({
            summary: totalStats,
            daily: dailyStats,
            byTool: toolStats,
            byUser: userStats,
            byApi: apiStats,
            totalDistributed: totalDistributed?.total || 0,
            usersWithCredits: usersWithCredits?.count || 0,
            creditsUsed30Days: totalStats?.total_credits || 0
        });
    } catch (error) {
        console.error('Erro ao buscar estat√≠sticas de cr√©ditos:', error);
        res.status(500).json({ message: 'Erro ao buscar estat√≠sticas', details: error.message });
    }
});

// GET /api/admin/credits/export - Exportar dados de cr√©ditos (CSV)
app.get('/api/admin/credits/export', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { startDate, endDate, format = 'csv' } = req.query;
        
        let dateFilter = '';
        let params = [];
        
        if (startDate && endDate) {
            dateFilter = 'WHERE DATE(cu.created_at) BETWEEN DATE(?) AND DATE(?)';
            params.push(startDate, endDate);
        } else if (startDate) {
            dateFilter = 'WHERE DATE(cu.created_at) >= DATE(?)';
            params.push(startDate);
        } else if (endDate) {
            dateFilter = 'WHERE DATE(cu.created_at) <= DATE(?)';
            params.push(endDate);
        }
        
        const data = await db.all(`
            SELECT 
                cu.created_at as data,
                u.email,
                u.whatsapp,
                ap.name as api_name,
                ap.provider,
                ap.model,
                cu.operation_type as tipo_operacao,
                cu.credits_used as creditos_usados,
                cu.units_consumed as unidades_consumidas
            FROM credit_usage cu
            JOIN users u ON cu.user_id = u.id
            JOIN api_providers ap ON cu.api_provider_id = ap.id
            ${dateFilter}
            ORDER BY cu.created_at DESC
        `, params);
        
        if (format === 'json') {
            res.json({ data });
        } else {
            // CSV
            const headers = ['Data', 'Email', 'WhatsApp', 'API', 'Provider', 'Modelo', 'Tipo Opera√ß√£o', 'Cr√©ditos Usados', 'Unidades Consumidas'];
            const csvRows = [
                headers.join(','),
                ...data.map(row => [
                    row.data || '',
                    `"${(row.email || '').replace(/"/g, '""')}"`,
                    `"${(row.whatsapp || '').replace(/"/g, '""')}"`,
                    `"${(row.api_name || '').replace(/"/g, '""')}"`,
                    `"${(row.provider || '').replace(/"/g, '""')}"`,
                    `"${(row.model || '').replace(/"/g, '""')}"`,
                    `"${(row.tipo_operacao || '').replace(/"/g, '""')}"`,
                    row.creditos_usados || 0,
                    row.unidades_consumidas || 0
                ].join(','))
            ];
            
            res.setHeader('Content-Type', 'text/csv; charset=utf-8');
            res.setHeader('Content-Disposition', `attachment; filename="creditos_${Date.now()}.csv"`);
            res.send('\ufeff' + csvRows.join('\n')); // BOM para Excel
        }
    } catch (error) {
        console.error('Erro ao exportar cr√©ditos:', error);
        res.status(500).json({ message: 'Erro ao exportar cr√©ditos' });
    }
});

// GET /api/admin/credits/transactions/:userId - Hist√≥rico de transa√ß√µes de um usu√°rio com detalhes
app.get('/api/admin/credits/transactions/:userId', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { userId } = req.params;
        
        // Buscar transa√ß√µes com JOIN para obter detalhes de uso
        const transactions = await db.all(`
            SELECT 
                ct.id,
                ct.amount,
                ct.transaction_type,
                ct.description,
                ct.created_at,
                cu.operation_type,
                cu.details,
                cu.units_consumed,
                ap.name as api_name,
                ap.provider as api_provider,
                ap.model as api_model
            FROM credit_transactions ct
            LEFT JOIN credit_usage cu ON ct.user_id = cu.user_id 
                AND ABS(ct.amount) = cu.credits_used 
                AND DATE(ct.created_at) = DATE(cu.created_at)
                AND ct.transaction_type = 'debit'
            LEFT JOIN api_providers ap ON cu.api_provider_id = ap.id
            WHERE ct.user_id = ?
            ORDER BY ct.created_at DESC
            LIMIT 100
        `, [userId]);
        
        // Processar transa√ß√µes para adicionar informa√ß√µes detalhadas
        const processedTransactions = transactions.map(t => {
            let details = null;
            let operationInfo = null;
            
            if (t.details) {
                try {
                    details = typeof t.details === 'string' ? JSON.parse(t.details) : t.details;
                } catch (e) {
                    details = { raw: t.details };
                }
            }
            
            // Montar informa√ß√£o detalhada sobre a opera√ß√£o
            if (t.operation_type) {
                const operationTypes = {
                    // Roteiros
                    'api_script_agents_generate': 'Gerador de Roteiro',
                    '/api/generate': 'Gerador de Roteiro',
                    '/api/scripts': 'Gerador de Roteiro',
                    '/api/scripts/generate': 'Gerador de Roteiro',
                    '/api/script-agents/:agentId/generate': 'Gerador de Roteiro',
                    '/api/script-agents/:agentId/generate/laozhang': 'Gerador de Roteiro',
                    // V√≠deos
                    'api_video_generation': 'Gerador de V√≠deo',
                    // Voz
                    'api_tts_generation': 'Gera√ß√£o de Voz',
                    'api_tts_preview': 'Preview de Voz',
                    // Imagens
                    'api_image_generation': 'Gera√ß√£o de Imagem',
                    // Thumbnails
                    'api_analyze_thumbnail': 'Gerador de Thumbnail',
                    '/api/analyze/thumbnail': 'Gerador de Thumbnail',
                    '/api/analyze/thumbnail/laozhang': 'Gerador de Thumbnail',
                    // Cenas
                    '/api/generate/scene-prompts': 'Gerador de Cenas',
                    '/api/generate/scene-prompts/laozhang': 'Gerador de Cenas',
                    // An√°lise de T√≠tulos
                    '/api/analyze/titles': 'An√°lise de T√≠tulos',
                    '/api/analyze/titles/laozhang': 'An√°lise de T√≠tulos',
                    // Detec√ß√£o de Personagens
                    'api_detect_characters': 'Detec√ß√£o de Personagens',
                    '/api/detect/characters': 'Detec√ß√£o de Personagens',
                    '/api/detect/characters/laozhang': 'Detec√ß√£o de Personagens',
                    // Busca de Subnicho
                    'api_niche_find_subniche': 'Busca de Subnicho',
                    '/api/niche/find-subniche': 'Busca de Subnicho',
                    '/api/niche/find-subniche/laozhang': 'Busca de Subnicho',
                    // An√°lise de Competidor
                    'api_niche_analyze_competitor': 'An√°lise de Competidor',
                    '/api/niche/analyze-competitor': 'An√°lise de Competidor',
                    '/api/niche/analyze-competitor/laozhang': 'An√°lise de Competidor',
                    // Cria√ß√£o de Agente
                    '/api/script-agents/create': 'Cria√ß√£o de Agente',
                    '/api/script-agents/create/laozhang': 'Cria√ß√£o de Agente',
                    // Reescrever Prompt
                    'api_rewrite_prompt': 'Reescrever Prompt',
                    '/api/rewrite/blocked-prompt': 'Reescrever Prompt',
                    '/api/rewrite/blocked-prompt/laozhang': 'Reescrever Prompt',
                    // An√°lise de Transcri√ß√£o
                    'api_transcript_analyze': 'An√°lise de Transcri√ß√£o',
                    '/api/video/transcript/analyze': 'An√°lise de Transcri√ß√£o',
                    '/api/video/transcript/analyze/laozhang': 'An√°lise de Transcri√ß√£o',
                    // Gen√©ricos
                    'api_generation': 'Gera√ß√£o de Conte√∫do',
                    'api_call': 'Ferramenta'
                };
                
                // Tentar extrair nome da ferramenta da descri√ß√£o se ela contiver "Ferramenta - Laozhang.ai"
                let toolName = operationTypes[t.operation_type];
                
                // Se n√£o encontrou pelo operationType, tentar pelo endpoint nos details
                if (!toolName && details?.endpoint) {
                    for (const [key, value] of Object.entries(operationTypes)) {
                        if (details.endpoint.includes(key) || key.includes(details.endpoint)) {
                            toolName = value;
                            break;
                        }
                    }
                }
                
                // Se ainda n√£o encontrou, usar fallback
                if (!toolName) {
                    toolName = operationTypes[t.operation_type] || t.operation_type;
                }
                
                // Priorizar modelo dos details (modelo real usado), depois api_model (modelo do provider), depois descri√ß√£o
                let modelName = details?.model || t.api_model || 'N/A';
                
                // Se a descri√ß√£o cont√©m "Ferramenta - Laozhang.ai", tentar extrair informa√ß√µes
                if ((!modelName || modelName === 'N/A') && t.description && t.description.includes('Ferramenta - Laozhang.ai')) {
                    // Tentar extrair o modelo da descri√ß√£o
                    const modelMatch = t.description.match(/\(([^)]+)\)/);
                    if (modelMatch && modelMatch[1]) {
                        modelName = modelMatch[1];
                    }
                }
                
                // Se ainda n√£o tem modelo, tentar extrair da descri√ß√£o atual
                if ((!modelName || modelName === 'N/A') && t.description && t.description.includes(' - ')) {
                    const parts = t.description.split(' - ');
                    if (parts.length > 1) {
                        const possibleModel = parts[parts.length - 1];
                        // Verificar se parece um modelo (n√£o √© apenas o nome da ferramenta)
                        if (possibleModel && !possibleModel.includes('Gerador') && !possibleModel.includes('Ferramenta')) {
                            modelName = possibleModel;
                        }
                    }
                }
                
                // Formatar modelo se necess√°rio
                if (modelName && modelName !== 'N/A') {
                    if (modelName.includes('claude-3-7-sonnet') || modelName === 'claude-3-7-sonnet-20250219') {
                        modelName = 'Claude 3.7 Sonnet';
                    } else if (modelName.includes('gemini-2.5-pro') || modelName === 'gemini-2.5-pro') {
                        modelName = 'Gemini 2.5 Pro';
                    } else if (modelName === 'gpt-4o' || modelName.includes('gpt-4o')) {
                        modelName = 'GPT-4o';
                    } else if (modelName.includes('veo-3.1-landscape-fast-fl') || modelName === 'veo-3.1-landscape-fast-fl') {
                        modelName = 'Veo 3.1 Landscape Fast';
                    } else if (modelName.includes('veo-3.1-landscape-fast') || modelName === 'veo-3.1-landscape-fast') {
                        modelName = 'Veo 3.1 Landscape Fast';
                    } else if (modelName.includes('veo-3.1-landscape-fl') || modelName === 'veo-3.1-landscape-fl') {
                        modelName = 'Veo 3.1 Landscape';
                    } else if (modelName.includes('veo-3.1-landscape') || modelName === 'veo-3.1-landscape') {
                        modelName = 'Veo 3.1 Landscape';
                    } else if (modelName.includes('veo-3.1-fast-fl') || modelName === 'veo-3.1-fast-fl') {
                        modelName = 'Veo 3.1 Fast';
                    } else if (modelName.includes('veo-3.1-fast') || modelName === 'veo-3.1-fast-generate-preview' || modelName === 'veo-3.1-fast') {
                        modelName = 'Veo 3.1 Fast';
                    } else if (modelName.includes('veo-3.1-fl') || modelName === 'veo-3.1-fl') {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('veo-3.1-generate') || modelName === 'veo-3.1-generate-preview' || modelName === 'veo-3.1') {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('veo-3.1')) {
                        modelName = 'Veo 3.1';
                    } else if (modelName.includes('voz-premium') || modelName.includes('genaipro')) {
                        modelName = 'Voz Premium';
                    }
                    
                    // Limpeza final: remover qualquer refer√™ncia a fornecedores
                    modelName = modelName
                        .replace(/genaipro/gi, 'Voz Premium')
                        .replace(/laozhang/gi, 'Provedor Externo')
                        .replace(/laozhang\.ai/gi, 'Provedor Externo')
                        .replace(/openai/gi, '')
                        .replace(/anthropic/gi, '')
                        .replace(/google/gi, '')
                        .replace(/\s+/g, ' ')
                        .trim();
                }
                
                operationInfo = {
                    type: t.operation_type,
                    typeName: toolName,
                    model: modelName !== 'N/A' ? modelName : null,
                    units: t.units_consumed || null,
                    endpoint: details?.endpoint || null,
                    details: details
                };
            }
            
            // Se a descri√ß√£o cont√©m "Ferramenta - Laozhang.ai", substituir pela descri√ß√£o correta baseada no operationInfo
            let finalDescription = t.description;
            if (finalDescription && finalDescription.includes('Ferramenta - Laozhang.ai')) {
                if (operationInfo && operationInfo.typeName) {
                    finalDescription = operationInfo.typeName;
                    if (operationInfo.model) {
                        finalDescription += ` - ${operationInfo.model}`;
                    }
                }
            }
            
            // Limpeza final da descri√ß√£o: remover refer√™ncias a fornecedores
            finalDescription = finalDescription
                .replace(/genaipro/gi, 'Voz Premium')
                .replace(/laozhang/gi, 'Provedor Externo')
                .replace(/laozhang\.ai/gi, 'Provedor Externo')
                .replace(/openai/gi, '')
                .replace(/anthropic/gi, '')
                .replace(/google/gi, '')
                .replace(/\s+/g, ' ')
                .trim();
            
            return {
                id: t.id,
                amount: t.amount,
                transaction_type: t.transaction_type,
                description: finalDescription,
                created_at: t.created_at,
                operation: operationInfo,
                isCredit: t.transaction_type === 'credit'
            };
        });
        
        res.json({ data: processedTransactions });
    } catch (error) {
        console.error('Erro ao buscar transa√ß√µes:', error);
        res.status(500).json({ message: 'Erro ao buscar transa√ß√µes' });
    }
});

// DELETE /api/admin/credits/transactions/:userId/clear - Zerar hist√≥rico de transa√ß√µes de um usu√°rio
app.delete('/api/admin/credits/transactions/:userId/clear', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { userId } = req.params;
        const userIdInt = parseInt(userId);
        
        if (!userIdInt || isNaN(userIdInt)) {
            return res.status(400).json({ message: 'ID do usu√°rio inv√°lido' });
        }
        
        // Verificar se o usu√°rio existe
        const user = await db.get('SELECT id, email FROM users WHERE id = ?', [userIdInt]);
        if (!user) {
            return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });
        }
        
        // Deletar todas as transa√ß√µes do usu√°rio
        const deleteResult = await db.run(
            'DELETE FROM credit_transactions WHERE user_id = ?',
            [userIdInt]
        );
        
        // Deletar tamb√©m os registros de uso de cr√©ditos relacionados
        await db.run(
            'DELETE FROM credit_usage WHERE user_id = ?',
            [userIdInt]
        );
        
        console.log(`[Admin] Hist√≥rico de transa√ß√µes zerado para usu√°rio ${userIdInt} (${user.email}) por admin ${req.user.id}`);
        
        res.json({ 
            success: true, 
            message: 'Hist√≥rico de transa√ß√µes zerado com sucesso',
            deletedTransactions: deleteResult.changes || 0
        });
    } catch (error) {
        console.error('Erro ao zerar hist√≥rico de transa√ß√µes:', error);
        res.status(500).json({ message: 'Erro ao zerar hist√≥rico de transa√ß√µes' });
    }
});

// GET /api/admin/credits/users-with-balance - Lista usu√°rios com saldo (com pagina√ß√£o e busca)
app.get('/api/admin/credits/users-with-balance', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { min_balance = 0, limit = 100, offset = 0, search = '' } = req.query;
        
        // Construir cl√°usula WHERE com busca opcional
        let whereClause = 'WHERE COALESCE(uc.balance, 0) >= ?';
        let queryParams = [parseFloat(min_balance)];
        
        if (search && search.trim()) {
            const searchTerm = `%${search.trim()}%`;
            whereClause += ` AND (
                LOWER(u.email) LIKE LOWER(?) 
                OR LOWER(COALESCE(u.whatsapp, '')) LIKE LOWER(?)
                OR LOWER(COALESCE(u.name, '')) LIKE LOWER(?)
            )`;
            queryParams.push(searchTerm, searchTerm, searchTerm);
        }
        
        const users = await db.all(`
            SELECT 
                u.id,
                u.email,
                u.whatsapp,
                u.name,
                COALESCE(uc.balance, 0) as balance,
                uc.updated_at as last_updated
            FROM users u
            LEFT JOIN user_credits uc ON u.id = uc.user_id
            ${whereClause}
            ORDER BY uc.balance DESC, u.email ASC
            LIMIT ? OFFSET ?
        `, [...queryParams, parseInt(limit), parseInt(offset)]);
        
        // Query para total com mesma busca
        let totalWhereClause = 'WHERE COALESCE(uc.balance, 0) >= ?';
        let totalParams = [parseFloat(min_balance)];
        if (search && search.trim()) {
            const searchTerm = `%${search.trim()}%`;
            totalWhereClause += ` AND (
                LOWER(u.email) LIKE LOWER(?) 
                OR LOWER(COALESCE(u.whatsapp, '')) LIKE LOWER(?)
                OR LOWER(COALESCE(u.name, '')) LIKE LOWER(?)
            )`;
            totalParams.push(searchTerm, searchTerm, searchTerm);
        }
        
        const total = await db.get(`
            SELECT COUNT(*) as count
            FROM users u
            LEFT JOIN user_credits uc ON u.id = uc.user_id
            ${totalWhereClause}
        `, totalParams);
        
        res.json({ 
            users: users.map(u => ({
                id: u.id,
                email: u.email,
                whatsapp: u.whatsapp || null,
                name: u.name || null,
                balance: parseFloat(u.balance || 0),
                last_updated: u.last_updated
            })),
            total: total.count,
            limit: parseInt(limit),
            offset: parseInt(offset)
        });
    } catch (error) {
        console.error('Erro ao buscar usu√°rios com cr√©ditos:', error);
        res.status(500).json({ message: 'Erro ao buscar usu√°rios' });
    }
});

// POST /api/admin/credits/balance - Consulta saldo por email, WhatsApp ou nome
app.post('/api/admin/credits/balance', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { identifier } = req.body;
        if (!identifier) return res.status(400).json({ message: 'Identificador √© obrigat√≥rio' });
        
        // Buscar por email, whatsapp ou nome (busca parcial, case-insensitive)
        const searchTerm = `%${identifier}%`;
        const user = await db.get(`
            SELECT id, email, whatsapp, name 
            FROM users 
            WHERE LOWER(email) LIKE LOWER(?) 
               OR LOWER(COALESCE(whatsapp, '')) LIKE LOWER(?)
               OR LOWER(COALESCE(name, '')) LIKE LOWER(?)
            LIMIT 1
        `, [searchTerm, searchTerm, searchTerm]);
        
        if (!user) return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });
        
        let credits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [user.id]);
        if (!credits) {
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, 0)', [user.id]);
            credits = { balance: 0 };
        }
        
        res.json({ user: { id: user.id, email: user.email, whatsapp: user.whatsapp, name: user.name }, balance: credits.balance });
    } catch (error) {
        console.error('Erro ao consultar saldo:', error);
        res.status(500).json({ message: 'Erro ao consultar saldo' });
    }
});

// GET /api/app-settings/laozhang-status - Verificar se laozhang.ai est√° ativa (p√∫blico para usu√°rios autenticados)
app.get('/api/app-settings/laozhang-status', authenticateToken, async (req, res) => {
    try {
        const laozhangDefaultSetting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
        let laozhangUseAsDefault = false;
        if (laozhangDefaultSetting) {
            try {
                const parsedValue = JSON.parse(laozhangDefaultSetting.value);
                laozhangUseAsDefault = parsedValue === true || parsedValue === 'true' || parsedValue === 1;
            } catch (e) {
                laozhangUseAsDefault = laozhangDefaultSetting.value === 'true' || laozhangDefaultSetting.value === '1';
            }
        }
        res.json({ laozhang_use_as_default: laozhangUseAsDefault });
    } catch (err) {
        console.error("Erro ao verificar status laozhang.ai:", err.message);
        res.json({ laozhang_use_as_default: false });
    }
});

// GET /api/admin/app-settings - Buscar configura√ß√µes da aplica√ß√£o
app.get('/api/admin/app-settings', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings");
        const settings = rows.reduce((acc, row) => {
            try {
                acc[row.key] = JSON.parse(row.value);
            } catch (e) {
                acc[row.key] = row.value; // fallback for non-json values
            }
            return acc;
        }, {});
        
        // Garantir que initial_bonus_credits existe (padr√£o: 0)
        if (settings.initial_bonus_credits === undefined) {
            settings.initial_bonus_credits = 0;
        }
        
        // Garantir que tts_credits_multiplier existe (padr√£o: 1.0)
        if (settings.tts_credits_multiplier === undefined) {
            settings.tts_credits_multiplier = 1.0;
        }
        
        // Garantir que laozhang_use_as_default existe (padr√£o: false)
        if (settings.laozhang_use_as_default === undefined) {
            settings.laozhang_use_as_default = false;
        }
        
        res.json(settings);
    } catch (err) {
        console.error("Erro ao buscar app settings:", err.message);
        res.status(500).json({ message: "Erro ao buscar configura√ß√µes." });
    }
});

// POST /api/admin/app-settings - Salvar configura√ß√µes da aplica√ß√£o
app.post('/api/admin/app-settings', authenticateToken, isAdmin, async (req, res) => {
    const { settings } = req.body;
    try {
        for (const [key, value] of Object.entries(settings)) {
            // Para voice_api_key, salvar como string simples (n√£o JSON)
            if (key === 'voice_api_key' && typeof value === 'string') {
                await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [key, value]);
            } else {
                await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [key, JSON.stringify(value)]);
            }
        }
        res.json({ message: 'Configura√ß√µes da aplica√ß√£o salvas.' });
    } catch (err) {
        console.error("Erro ao salvar app settings:", err.message);
        res.status(500).json({ message: "Erro ao salvar configura√ß√µes." });
    }
});

// GET /api/admin/whatsapp-config - Obter configura√ß√µes do WhatsApp
app.get('/api/admin/whatsapp-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key IN ('whatsapp_token', 'whatsapp_number_id')");
        const config = {};
        rows.forEach(row => {
            try {
                config[row.key] = JSON.parse(row.value);
            } catch (e) {
                config[row.key] = row.value;
            }
        });
        res.json(config);
    } catch (err) {
        console.error("Erro ao buscar configura√ß√µes do WhatsApp:", err.message);
        res.status(500).json({ message: "Erro ao buscar configura√ß√µes do WhatsApp." });
    }
});

// POST /api/admin/whatsapp-config - Salvar configura√ß√µes do WhatsApp
app.post('/api/admin/whatsapp-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { token, number_id } = req.body;
        
        if (token !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['whatsapp_token', JSON.stringify(token)]);
        }
        
        if (number_id !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['whatsapp_number_id', JSON.stringify(number_id)]);
        }
        
        res.json({ message: 'Configura√ß√µes do WhatsApp salvas com sucesso.' });
    } catch (err) {
        console.error("Erro ao salvar configura√ß√µes do WhatsApp:", err.message);
        res.status(500).json({ message: "Erro ao salvar configura√ß√µes do WhatsApp." });
    }
});

// GET /api/admin/email-templates - Obter templates de email
app.get('/api/admin/email-templates', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key LIKE 'email_template_%'");
        const templates = {};
        rows.forEach(row => {
            try {
                const templateType = row.key.replace('email_template_', '').replace('_subject', '').replace('_body', '');
                if (!templates[templateType]) templates[templateType] = {};
                if (row.key.includes('_subject')) {
                    templates[templateType].subject = JSON.parse(row.value);
                } else if (row.key.includes('_body')) {
                    templates[templateType].body = JSON.parse(row.value);
                }
            } catch (e) {
                // Ignorar erros de parse
            }
        });
        res.json(templates);
    } catch (err) {
        console.error("Erro ao buscar templates de email:", err.message);
        res.status(500).json({ message: "Erro ao buscar templates de email." });
    }
});

// POST /api/admin/email-templates - Salvar template de email
app.post('/api/admin/email-templates', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { template_type, subject, body } = req.body;
        
        if (!template_type || !subject || !body) {
            return res.status(400).json({ message: 'template_type, subject e body s√£o obrigat√≥rios' });
        }
        
        await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [`email_template_${template_type}_subject`, JSON.stringify(subject)]);
        await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [`email_template_${template_type}_body`, JSON.stringify(body)]);
        
        res.json({ message: 'Template de email salvo com sucesso.' });
    } catch (err) {
        console.error("Erro ao salvar template de email:", err.message);
        res.status(500).json({ message: "Erro ao salvar template de email." });
    }
});

// POST /api/admin/email-templates/test - Testar envio de template de email
app.post('/api/admin/email-templates/test', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { template_type, test_email } = req.body;
        
        if (!template_type) {
            return res.status(400).json({ message: "Tipo de template √© obrigat√≥rio." });
        }
        
        if (!test_email) {
            return res.status(400).json({ message: "Email de teste √© obrigat√≥rio." });
        }
        
        // Validar formato de email
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(test_email)) {
            return res.status(400).json({ message: "Email inv√°lido." });
        }
        
        // Vari√°veis de exemplo para cada tipo de template
        const exampleVariables = {
            register: {
                nome: 'Jo√£o Silva',
                email: test_email,
                creditos_iniciais: '100',
                link_acesso: 'https://lacasadarkcore.com/login'
            },
            cancel: {
                nome: 'Jo√£o Silva',
                email: test_email,
                plano: 'MASTER PRO Mensal',
                data_cancelamento: new Date().toLocaleDateString('pt-BR'),
                data_fim_acesso: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR')
            },
            payment: {
                nome: 'Jo√£o Silva',
                email: test_email,
                plano: 'MASTER PRO Mensal',
                valor: 'R$ 297,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR')
            },
            package: {
                nome: 'Jo√£o Silva',
                email: test_email,
                pacote: 'Pacote Premium',
                creditos: '500',
                valor: 'R$ 99,90',
                data_compra: new Date().toLocaleDateString('pt-BR'),
                saldo_atual: '600'
            },
            password_reset: {
                nome: 'Jo√£o Silva',
                email: test_email,
                senha_provisoria: 'TempPass123!',
                link_acesso: 'https://lacasadarkcore.com/login'
            },
            'subscription_plan-start': {
                nome: 'Jo√£o Silva',
                email: test_email,
                plano: 'START CREATOR Mensal',
                valor: 'R$ 79,90',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '100'
            },
            'subscription_plan-turbo': {
                nome: 'Jo√£o Silva',
                email: test_email,
                plano: 'TURBO MAKER Mensal',
                valor: 'R$ 197,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '500'
            },
            'subscription_plan-master': {
                nome: 'Jo√£o Silva',
                email: test_email,
                plano: 'MASTER PRO Mensal',
                valor: 'R$ 297,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '1000'
            },
            'subscription_plan-start-annual': {
                nome: 'Jo√£o Silva',
                email: test_email,
                plano: 'START CREATOR Anual',
                valor: 'R$ 799,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '1200'
            },
            'subscription_plan-turbo-annual': {
                nome: 'Jo√£o Silva',
                email: test_email,
                plano: 'TURBO MAKER Anual',
                valor: 'R$ 1.970,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '6000'
            },
            'subscription_plan-master-annual': {
                nome: 'Jo√£o Silva',
                email: test_email,
                plano: 'MASTER PRO Anual',
                valor: 'R$ 2.970,00',
                data_pagamento: new Date().toLocaleDateString('pt-BR'),
                proxima_cobranca: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR'),
                creditos: '12000'
            }
        };
        
        const variables = exampleVariables[template_type] || {
            nome: 'Jo√£o Silva',
            email: test_email
        };
        
        console.log(`[EMAIL TEST] Enviando email de teste para template: ${template_type}`);
        console.log(`[EMAIL TEST] Email de destino: ${test_email}`);
        
        const result = await sendTemplateEmail(template_type, test_email, variables);
        
        if (result.success) {
            res.status(200).json({ 
                message: `Email de teste enviado com sucesso para ${test_email}`,
                messageId: result.messageId,
                accepted: result.accepted
            });
        } else {
            res.status(500).json({ 
                message: `Erro ao enviar email de teste: ${result.error || result.message}`,
                error: result.error
            });
        }
    } catch (err) {
        console.error("[EMAIL TEST] Erro ao testar template de email:", err.message);
        res.status(500).json({ message: "Erro ao testar template de email.", error: err.message });
    }
});

// GET /api/admin/smtp-config - Obter configura√ß√µes SMTP
app.get('/api/admin/smtp-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key LIKE 'smtp_%'");
        const config = {};
        rows.forEach(row => {
                const key = row.key.replace('smtp_', '');
            // Valores j√° s√£o strings simples, n√£o precisam de JSON.parse
            let value = row.value;
            
            // Remover aspas duplas se existirem (corrigir dados antigos salvos incorretamente)
            if (typeof value === 'string') {
                value = value.replace(/^["']|["']$/g, '').trim();
            }
            
            // Se for senha, descriptografar
            if (key === 'password') {
                try {
                    // Verificar se est√° no formato criptografado (IV:encrypted)
                    if (value && value.includes(':') && !value.startsWith('"')) {
                        value = decrypt(value);
                        if (!value) {
                            // Se decrypt retornar null, usar o valor original (senha antiga n√£o criptografada)
                            value = row.value.replace(/^["']|["']$/g, '').trim();
                        }
                    }
                    // Se n√£o tiver ':', √© senha antiga n√£o criptografada, manter como est√°
            } catch (e) {
                    // Se falhar ao descriptografar, usar o valor original (senha antiga n√£o criptografada)
                    console.warn('[SMTP Config] Senha n√£o est√° criptografada ou erro ao descriptografar, usando valor original');
                    value = row.value.replace(/^["']|["']$/g, '').trim();
                }
            }
            
            // Converter secure para boolean
            if (key === 'secure') {
                value = value === 'true' || value === true;
            }
            
            // Converter port para n√∫mero
            if (key === 'port') {
                value = parseInt(value) || 587;
            }
            
            config[key] = value;
        });
        console.log('[SMTP Config] Configura√ß√µes carregadas:', Object.keys(config));
        res.json(config);
    } catch (err) {
        console.error("[SMTP Config] Erro ao buscar configura√ß√µes SMTP:", err.message);
        res.status(500).json({ message: "Erro ao buscar configura√ß√µes SMTP: " + err.message });
    }
});

// POST /api/admin/smtp-config - Salvar configura√ß√µes SMTP
app.post('/api/admin/smtp-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { host, port, email, password, secure } = req.body;
        
        console.log('[SMTP Config] Salvando configura√ß√µes:', { host, port, email, hasPassword: !!password, secure });
        
        // Remover aspas duplas dos valores antes de salvar
        const cleanHost = host ? String(host).replace(/^["']|["']$/g, '').trim() : null;
        const cleanEmail = email ? String(email).replace(/^["']|["']$/g, '').trim() : null;
        
        if (cleanHost && cleanHost !== '') {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_host', cleanHost]);
            console.log('[SMTP Config] Host salvo:', cleanHost);
        }
        if (port !== undefined && port !== null) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_port', String(port)]);
            console.log('[SMTP Config] Porta salva:', port);
        }
        if (cleanEmail && cleanEmail !== '') {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_email', cleanEmail]);
            console.log('[SMTP Config] Email salvo:', cleanEmail);
        }
        if (password !== undefined && password !== null && password !== '') {
            // Criptografar a senha antes de salvar
            const encryptedPassword = encrypt(password);
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_password', encryptedPassword]);
            console.log('[SMTP Config] Senha salva (criptografada)');
        }
        if (secure !== undefined && secure !== null) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['smtp_secure', String(secure)]);
            console.log('[SMTP Config] Secure salvo:', secure);
        }
        
        res.json({ message: 'Configura√ß√µes SMTP salvas com sucesso.' });
    } catch (err) {
        console.error("[SMTP Config] Erro ao salvar configura√ß√µes SMTP:", err.message);
        res.status(500).json({ message: "Erro ao salvar configura√ß√µes SMTP: " + err.message });
    }
});

// POST /api/admin/smtp-config/test - Testar configura√ß√£o SMTP enviando email de teste
app.post('/api/admin/smtp-config/test', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { testEmail } = req.body;
        
        if (!testEmail) {
            return res.status(400).json({ message: 'Email de teste n√£o fornecido.' });
        }

        console.log('[SMTP Test] Iniciando teste de configura√ß√£o SMTP...');
        console.log('[SMTP Test] Email de destino:', testEmail);

        // Obter configura√ß√£o SMTP atual
        const smtpConfig = await getSMTPConfig();
        
        if (!smtpConfig || !smtpConfig.host || !smtpConfig.email || !smtpConfig.password) {
            return res.status(400).json({ 
                message: 'Configura√ß√£o SMTP incompleta. Configure o servidor, email e senha antes de testar.' 
            });
        }

        // Limpar host e email de poss√≠veis aspas (corrigir dados antigos)
        const cleanHost = smtpConfig.host ? String(smtpConfig.host).replace(/^["']|["']$/g, '').trim() : null;
        const cleanEmail = smtpConfig.email ? String(smtpConfig.email).replace(/^["']|["']$/g, '').trim() : null;
        
        console.log('[SMTP Test] Configura√ß√£o SMTP encontrada:', {
            host: cleanHost,
            port: smtpConfig.port,
            email: cleanEmail,
            hasPassword: !!smtpConfig.password,
            secure: smtpConfig.secure
        });
        
        if (!cleanHost) {
            return res.status(400).json({ 
                message: 'Host SMTP inv√°lido. Verifique as configura√ß√µes.' 
            });
        }

        // Criar transporter com valores limpos
        const transporter = nodemailer.createTransport({
            host: cleanHost,
            port: parseInt(smtpConfig.port) || 587,
            secure: smtpConfig.secure === true || smtpConfig.secure === 'true',
            // Aceitar certificados autoassinados (comum em servidores SMTP privados)
            tls: {
                rejectUnauthorized: false,
                ciphers: 'SSLv3'
            },
            auth: {
                user: cleanEmail,
                pass: smtpConfig.password
            },
            // Timeout aumentado para conex√µes mais lentas
            connectionTimeout: 10000,
            greetingTimeout: 10000,
            socketTimeout: 10000
        });

        console.log('[SMTP Test] Verificando conex√£o SMTP...');
        
        // Verificar conex√£o
        await transporter.verify();
        console.log('[SMTP Test] ‚úÖ Conex√£o SMTP verificada com sucesso');

        // Enviar email de teste
        const testSubject = 'Teste de Configura√ß√£o SMTP - La Casa Dark Core';
        const testBody = `
            <html>
                <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
                    <div style="max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f9f9f9; border-radius: 8px;">
                        <h2 style="color: #f59e0b;">‚úÖ Teste de Configura√ß√£o SMTP</h2>
                        <p>Este √© um email de teste para validar as configura√ß√µes SMTP do La Casa Dark Core.</p>
                        <p><strong>Se voc√™ recebeu este email, significa que suas configura√ß√µes SMTP est√£o funcionando corretamente!</strong></p>
                        <hr style="border: none; border-top: 1px solid #ddd; margin: 20px 0;">
                        <p style="color: #666; font-size: 12px;">
                            <strong>Detalhes da configura√ß√£o:</strong><br>
                            Servidor: ${cleanHost}<br>
                            Porta: ${smtpConfig.port}<br>
                            Email de envio: ${cleanEmail}<br>
                            TLS/SSL: ${smtpConfig.secure ? 'Sim' : 'N√£o'}<br>
                            Data/Hora: ${new Date().toLocaleString('pt-BR')}
                        </p>
                    </div>
                </body>
            </html>
        `;

        console.log('[SMTP Test] Enviando email de teste...');
        
        const mailOptions = {
            from: `"La Casa Dark Core" <${cleanEmail}>`,
            to: testEmail,
            subject: testSubject,
            html: testBody,
            text: 'Este √© um email de teste para validar as configura√ß√µes SMTP do La Casa Dark Core. Se voc√™ recebeu este email, significa que suas configura√ß√µes SMTP est√£o funcionando corretamente!'
        };

        const info = await transporter.sendMail(mailOptions);
        
        console.log('[SMTP Test] ‚úÖ Email de teste enviado com sucesso!');
        console.log('[SMTP Test] Message ID:', info.messageId);

        res.json({ 
            message: `Email de teste enviado com sucesso para ${testEmail}! Verifique sua caixa de entrada.`,
            messageId: info.messageId
        });

    } catch (err) {
        console.error('[SMTP Test] ‚ùå Erro ao testar configura√ß√£o SMTP:', err.message);
        console.error('[SMTP Test] Stack trace:', err.stack);
        
        let errorMessage = 'Erro ao enviar email de teste.';
        
        if (err.code === 'EAUTH') {
            errorMessage = 'Erro de autentica√ß√£o. Verifique o email e senha do SMTP.';
        } else if (err.code === 'ECONNECTION' || err.code === 'ETIMEDOUT' || err.message.includes('Connection closed')) {
            errorMessage = 'Erro de conex√£o. Verifique o servidor SMTP, porta e se o TLS/SSL est√° configurado corretamente. Alguns servidores requerem STARTTLS na porta 587.';
        } else if (err.code === 'EENVELOPE') {
            errorMessage = 'Erro no endere√ßo de email. Verifique o email de destino.';
        } else if (err.message.includes('self-signed certificate') || err.message.includes('certificate')) {
            errorMessage = 'Erro de certificado SSL. O servidor SMTP est√° usando um certificado autoassinado. Tente desmarcar "Usar TLS/SSL" ou verifique as configura√ß√µes do servidor.';
        } else if (err.message) {
            errorMessage = `Erro: ${err.message}`;
        }
        
        res.status(500).json({ message: errorMessage });
    }
});

// ============================================
// SISTEMA DE ENVIO DE EMAILS
// ============================================

// Fun√ß√£o para obter configura√ß√£o SMTP
async function getSMTPConfig() {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key LIKE 'smtp_%'");
        const config = {};
        rows.forEach(row => {
                const key = row.key.replace('smtp_', '');
            let value = row.value;
            
            // Se for senha, descriptografar
            if (key === 'password') {
                try {
                    // Verificar se est√° no formato criptografado (IV:encrypted)
                    if (value && value.includes(':')) {
                        value = decrypt(value);
                        if (!value) {
                            // Se decrypt retornar null, usar o valor original (senha antiga n√£o criptografada)
                            value = row.value;
                        }
                    }
                    // Se n√£o tiver ':', √© senha antiga n√£o criptografada, manter como est√°
            } catch (e) {
                    // Se falhar ao descriptografar, usar o valor original (senha antiga n√£o criptografada)
                    console.warn('[EMAIL] Senha SMTP n√£o est√° criptografada ou erro ao descriptografar, usando valor original');
                    value = row.value;
            }
            }
            
            // Converter secure para boolean
            if (key === 'secure') {
                value = value === 'true' || value === true;
            }
            
            // Converter port para n√∫mero
            if (key === 'port') {
                value = parseInt(value) || 587;
            }
            
            config[key] = value;
        });
        return config;
    } catch (error) {
        console.error('[EMAIL] Erro ao buscar configura√ß√£o SMTP:', error.message);
        return null;
    }
}

// Fun√ß√£o para criar transporter do nodemailer
async function createEmailTransporter() {
    const smtpConfig = await getSMTPConfig();
    
    if (!smtpConfig || !smtpConfig.host || !smtpConfig.email || !smtpConfig.password) {
        console.warn('[EMAIL] SMTP n√£o configurado. Emails n√£o ser√£o enviados.');
        return null;
    }
    
    try {
        // Limpar host e email de poss√≠veis aspas
        const cleanHost = smtpConfig.host ? String(smtpConfig.host).replace(/^["']|["']$/g, '').trim() : null;
        const cleanEmail = smtpConfig.email ? String(smtpConfig.email).replace(/^["']|["']$/g, '').trim() : null;
        
        const transporter = nodemailer.createTransport({
            host: cleanHost,
            port: parseInt(smtpConfig.port) || 587,
            secure: smtpConfig.secure === true || smtpConfig.secure === 'true',
            // Aceitar certificados autoassinados (comum em servidores SMTP privados)
            tls: {
                rejectUnauthorized: false,
                ciphers: 'SSLv3'
            },
            auth: {
                user: cleanEmail,
                pass: smtpConfig.password
            },
            // Timeout aumentado para conex√µes mais lentas
            connectionTimeout: 10000,
            greetingTimeout: 10000,
            socketTimeout: 10000
        });
        
        // Verificar conex√£o
        await transporter.verify();
        console.log('[EMAIL] SMTP configurado e verificado com sucesso');
        return transporter;
    } catch (error) {
        console.error('[EMAIL] Erro ao criar transporter:', error.message);
        return null;
    }
}

// Templates padr√£o para fallback
const defaultEmailTemplates = {
    password_reset: {
        subject: 'Reset de Senha - La Casa Dark Core',
        body: `
            <html>
                <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
                    <div style="background-color: #f9f9f9; border-radius: 8px; padding: 30px; border: 1px solid #ddd;">
                        <h2 style="color: #f59e0b; margin-top: 0;">üîê Reset de Senha</h2>
                        <p>Ol√° <strong>{{nome}}</strong>,</p>
                        <p>Voc√™ solicitou a redefini√ß√£o de senha para sua conta no La Casa Dark Core.</p>
                        <p>Clique no link abaixo para redefinir sua senha:</p>
                        <div style="text-align: center; margin: 30px 0;">
                            <a href="{{link_acesso}}" style="background-color: #f59e0b; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;">Redefinir Senha</a>
                        </div>
                        <p style="color: #666; font-size: 12px;">Ou copie e cole este link no seu navegador:</p>
                        <p style="color: #666; font-size: 12px; word-break: break-all;">{{link_acesso}}</p>
                        <p style="color: #999; font-size: 11px; margin-top: 30px; border-top: 1px solid #ddd; padding-top: 20px;">
                            Este link expira em 1 hora. Se voc√™ n√£o solicitou esta redefini√ß√£o, ignore este email.
                        </p>
                        <p style="color: #999; font-size: 11px;">
                            Equipe La Casa Dark Core
                        </p>
                    </div>
                </body>
            </html>
        `
    },
    register: {
        subject: 'Bem-vindo √† La Casa Dark Core!',
        body: `
            <html>
                <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
                    <p>Ol√° {{nome}},</p>
                    <p>Bem-vindo √† La Casa Dark Core! Sua conta foi criada com sucesso.</p>
                    <p>Cr√©ditos iniciais: {{creditos_iniciais}}</p>
                    <p><a href="{{link_acesso}}">Acessar minha conta</a></p>
                </body>
            </html>
        `
    }
};

// Fun√ß√£o para obter template de email
async function getEmailTemplate(templateType) {
    try {
        const subjectRow = await db.get("SELECT value FROM app_settings WHERE key = ?", [`email_template_${templateType}_subject`]);
        const bodyRow = await db.get("SELECT value FROM app_settings WHERE key = ?", [`email_template_${templateType}_body`]);
        
        // Se n√£o encontrar no banco, usar template padr√£o
        if (!subjectRow || !bodyRow) {
            if (defaultEmailTemplates[templateType]) {
                console.log(`[EMAIL] Usando template padr√£o para ${templateType}`);
                return defaultEmailTemplates[templateType];
            }
            return null;
        }
        
        let subject, body;
        try {
            subject = JSON.parse(subjectRow.value);
            body = JSON.parse(bodyRow.value);
        } catch {
            subject = subjectRow.value;
            body = bodyRow.value;
        }
        
        return { subject, body };
    } catch (error) {
        console.error(`[EMAIL] Erro ao buscar template ${templateType}:`, error.message);
        // Tentar usar template padr√£o em caso de erro
        if (defaultEmailTemplates[templateType]) {
            console.log(`[EMAIL] Usando template padr√£o para ${templateType} devido a erro`);
            return defaultEmailTemplates[templateType];
        }
        return null;
    }
}

// Fun√ß√£o para substituir vari√°veis no template
function replaceTemplateVariables(template, variables) {
    if (!template) return '';
    
    let result = template;
    for (const [key, value] of Object.entries(variables)) {
        const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        result = result.replace(regex, value || '');
    }
    return result;
}

// Fun√ß√£o para enviar email
async function sendEmail(to, subject, htmlBody, textBody = null) {
    try {
        const transporter = await createEmailTransporter();
        if (!transporter) {
            console.warn('[EMAIL] Transporter n√£o dispon√≠vel, email n√£o enviado');
            return { success: false, message: 'SMTP n√£o configurado' };
        }
        
        const smtpConfig = await getSMTPConfig();
        // Limpar email de poss√≠veis aspas
        const fromEmail = smtpConfig && smtpConfig.email ? String(smtpConfig.email).replace(/^["']|["']$/g, '').trim() : 'noreply@lacasadarkcore.com';
        
        const mailOptions = {
            from: `"La Casa Dark Core" <${fromEmail}>`,
            to: to,
            subject: subject,
            html: htmlBody,
            text: textBody || htmlBody.replace(/<[^>]*>/g, ''), // Remover HTML se n√£o houver texto
            // Adicionar headers para melhorar a entrega
            headers: {
                'X-Priority': '1',
                'X-MSMail-Priority': 'High',
                'Importance': 'high',
                'List-Unsubscribe': `<mailto:${fromEmail}?subject=unsubscribe>`,
                'X-Mailer': 'La Casa Dark Core'
            },
            // Adicionar informa√ß√µes de reply-to
            replyTo: fromEmail
        };
        
        console.log(`[EMAIL] Enviando email para: ${to}`);
        console.log(`[EMAIL] De: ${mailOptions.from}`);
        console.log(`[EMAIL] Assunto: ${mailOptions.subject}`);
        
        const info = await transporter.sendMail(mailOptions);
        
        console.log(`[EMAIL] ‚úÖ Email aceito pelo servidor SMTP`);
        console.log(`[EMAIL] Message ID: ${info.messageId}`);
        console.log(`[EMAIL] Response: ${info.response || 'N/A'}`);
        console.log(`[EMAIL] Envelope:`, JSON.stringify(info.envelope || {}));
        
        // Verificar se o servidor SMTP realmente aceitou o email
        if (info.accepted && info.accepted.length > 0) {
            console.log(`[EMAIL] ‚úÖ Email aceito para entrega: ${info.accepted.join(', ')}`);
        }
        if (info.rejected && info.rejected.length > 0) {
            console.error(`[EMAIL] ‚ùå Email rejeitado: ${info.rejected.join(', ')}`);
        }
        if (info.pending && info.pending.length > 0) {
            console.warn(`[EMAIL] ‚ö†Ô∏è Email pendente: ${info.pending.join(', ')}`);
        }
        
        return { success: true, messageId: info.messageId, response: info.response, accepted: info.accepted, rejected: info.rejected };
    } catch (error) {
        console.error('[EMAIL] ‚ùå Erro ao enviar email:', error.message);
        console.error('[EMAIL] Stack trace:', error.stack);
        if (error.response) {
            console.error('[EMAIL] Response do servidor:', error.response);
        }
        return { success: false, error: error.message };
    }
}

// Fun√ß√£o para enviar email usando template
async function sendTemplateEmail(templateType, to, variables = {}) {
    try {
        const template = await getEmailTemplate(templateType);
        if (!template) {
            console.warn(`[EMAIL] Template ${templateType} n√£o encontrado`);
            return { success: false, message: 'Template n√£o encontrado' };
        }
        
        const subject = replaceTemplateVariables(template.subject, variables);
        const body = replaceTemplateVariables(template.body, variables);
        
        console.log(`[EMAIL] Preparando email ${templateType} para: ${to}`);
        console.log(`[EMAIL] Assunto: ${subject.substring(0, 50)}...`);
        
        const result = await sendEmail(to, subject, body);
        
        // Log adicional sobre o resultado
        if (result.success) {
            console.log(`[EMAIL] ‚úÖ Email ${templateType} processado com sucesso`);
            if (result.accepted && result.accepted.length > 0) {
                console.log(`[EMAIL] üì¨ Destinat√°rios aceitos: ${result.accepted.join(', ')}`);
            }
            if (result.rejected && result.rejected.length > 0) {
                console.error(`[EMAIL] ‚ùå Destinat√°rios rejeitados: ${result.rejected.join(', ')}`);
            }
        } else {
            console.error(`[EMAIL] ‚ùå Falha ao enviar email ${templateType}: ${result.error || result.message}`);
        }
        
        return result;
    } catch (error) {
        console.error(`[EMAIL] Erro ao enviar email com template ${templateType}:`, error.message);
        console.error(`[EMAIL] Stack trace:`, error.stack);
        return { success: false, error: error.message };
    }
}

// GET /api/admin/pixel-config - Obter configura√ß√µes de Pixel/Ads
app.get('/api/admin/pixel-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key IN ('facebook_pixel_id', 'google_ads_id')");
        const config = {};
        rows.forEach(row => {
            try {
                config[row.key] = JSON.parse(row.value);
            } catch (e) {
                config[row.key] = row.value;
            }
        });
        res.json(config);
    } catch (err) {
        console.error("Erro ao buscar configura√ß√µes de Pixel:", err.message);
        res.status(500).json({ message: "Erro ao buscar configura√ß√µes de Pixel." });
    }
});

// POST /api/admin/pixel-config - Salvar configura√ß√µes de Pixel/Ads
app.post('/api/admin/pixel-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { facebook_pixel_id, google_ads_id } = req.body;
        
        if (facebook_pixel_id !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['facebook_pixel_id', JSON.stringify(facebook_pixel_id)]);
        }
        
        if (google_ads_id !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['google_ads_id', JSON.stringify(google_ads_id)]);
        }
        
        res.json({ message: 'Configura√ß√µes de Pixel salvas com sucesso.' });
    } catch (err) {
        console.error("Erro ao salvar configura√ß√µes de Pixel:", err.message);
        res.status(500).json({ message: "Erro ao salvar configura√ß√µes de Pixel." });
    }
});

// GET /api/admin/stripe-config - Obter configura√ß√µes do Stripe
app.get('/api/admin/stripe-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const rows = await db.all("SELECT key, value FROM app_settings WHERE key LIKE 'stripe_%'");
        const config = {};
        rows.forEach(row => {
            try {
                config[row.key.replace('stripe_', '')] = JSON.parse(row.value);
            } catch (e) {
                config[row.key.replace('stripe_', '')] = row.value;
            }
        });
        
        // Retornar em formato mais amig√°vel
        res.json({
            publishable_key: config.publishable_key || null,
            secret_key: config.secret_key || null,
            webhook_secret: config.webhook_secret || null,
            plans: {
                'plan-free': config['plan-free'] || null,
                'plan-start': config['plan-start'] || null,
                'plan-turbo': config['plan-turbo'] || null,
                'plan-master': config['plan-master'] || null,
                'plan-start-annual': config['plan-start-annual'] || null,
                'plan-turbo-annual': config['plan-turbo-annual'] || null,
                'plan-master-annual': config['plan-master-annual'] || null,
                'package-1000': config['package-1000'] || null,
                'package-2500': config['package-2500'] || null,
                'package-5000': config['package-5000'] || null,
                'package-10000': config['package-10000'] || null,
                'package-20000': config['package-20000'] || null
            }
        });
    } catch (err) {
        console.error("Erro ao buscar configura√ß√µes do Stripe:", err.message);
        res.status(500).json({ message: "Erro ao buscar configura√ß√µes do Stripe." });
    }
});

// GET /api/admin/subscriptions - Obter dados de assinaturas
app.get('/api/admin/subscriptions', authenticateToken, isAdmin, async (req, res) => {
    try {
        const period = parseInt(req.query.period) || 30;
        const status = req.query.status || 'all';
        
        // Calcular datas
        const endDate = new Date();
        const startDate = new Date();
        if (period !== 0) {
            startDate.setDate(startDate.getDate() - period);
        } else {
            startDate.setFullYear(2000); // Para "all"
        }
        
        // Por enquanto, vamos criar uma estrutura de dados mockada
        // Quando voc√™ integrar com Stripe, substitua por dados reais
        const subscriptions = [];
        
        // Buscar assinaturas do banco (assumindo que voc√™ tem uma tabela de assinaturas)
        // Por enquanto, vamos retornar dados de exemplo
        const kpis = {
            mrr: 0,
            arr: 0,
            active_subscribers: 0,
            churn_rate: 0,
            mrr_change: 0,
            arr_change: 0,
            active_subscribers_change: 0,
            churn_rate_change: 0,
            new_subscribers: 0,
            cancellations: 0,
            ltv: 0,
            avg_duration: 0,
            // Novos campos
            total_revenue: 0,
            monthly_revenue: 0,
            total_subscriptions: 0,
            conversion_rate: 0,
            monthly_new: 0,
            monthly_canceled: 0,
            monthly_growth: 0,
            revenue_30d: 0,
            revenue_90d: 0,
            revenue_year: 0,
            avg_ticket: 0,
            total_canceled: 0,
            retention_rate: 0
        };
        
        const charts = {
            mrr: { labels: [], data: [] },
            subscribers: { labels: [], data: [] },
            plans_distribution: { labels: [], data: [] },
            churn: { labels: [], data: [] }
        };
        
        const insights = [
            {
                type: 'info',
                icon: 'info',
                title: 'Sistema de Assinaturas',
                message: 'Configure o Stripe e comece a receber assinaturas para ver dados reais aqui.'
            }
        ];
        
        // Tentar buscar dados reais se existir tabela de assinaturas
        try {
            // Verificar se existe tabela de assinaturas
            const tableExists = await db.get(`
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='subscriptions'
            `);
            
            if (tableExists) {
                // Verificar quais colunas existem na tabela
                const tableInfo = await db.all(`PRAGMA table_info(subscriptions)`);
                const columns = tableInfo.map(col => col.name);
                
                // Construir query dinamicamente baseado nas colunas dispon√≠veis
                const hasMonthlyAmount = columns.includes('monthly_amount');
                const hasTotalPaid = columns.includes('total_paid');
                const hasDurationDays = columns.includes('duration_days');
                const hasPlanName = columns.includes('plan_name');
                const hasNextBilling = columns.includes('next_billing_date');
                const hasUpdatedAt = columns.includes('updated_at');
                const hasCanceledAt = columns.includes('canceled_at');
                
                // Buscar assinaturas
                let query = `
                    SELECT s.*, u.email as user_email, u.name as user_name
                    FROM subscriptions s
                    LEFT JOIN users u ON s.user_id = u.id
                    WHERE s.created_at >= ? AND s.created_at <= ?
                `;
                const params = [startDate.toISOString(), endDate.toISOString()];
                
                if (status !== 'all') {
                    query += ' AND s.status = ?';
                    params.push(status);
                }
                
                query += ' ORDER BY s.created_at DESC';
                
                const subs = await db.all(query, params);
                
                // Calcular KPIs
                let totalMRR = 0;
                let activeCount = 0;
                let newCount = 0;
                let cancelCount = 0;
                let totalPaid = 0;
                let totalDuration = 0;
                
                const planDistribution = {};
                
                subs.forEach(sub => {
                    if (sub.status === 'active') {
                        if (hasMonthlyAmount) {
                            totalMRR += parseFloat(sub.monthly_amount || 0);
                        }
                        activeCount++;
                    }
                    if (sub.status === 'canceled') {
                        cancelCount++;
                    }
                    if (new Date(sub.created_at) >= startDate) {
                        newCount++;
                    }
                    if (hasTotalPaid) {
                        totalPaid += parseFloat(sub.total_paid || 0);
                    }
                    if (hasDurationDays) {
                        totalDuration += parseInt(sub.duration_days || 0);
                    }
                    
                    const planName = (hasPlanName && sub.plan_name) ? sub.plan_name : 'Desconhecido';
                    planDistribution[planName] = (planDistribution[planName] || 0) + 1;
                });
                
                kpis.mrr = totalMRR;
                kpis.arr = totalMRR * 12;
                kpis.active_subscribers = activeCount;
                kpis.new_subscribers = newCount;
                kpis.cancellations = cancelCount;
                kpis.ltv = activeCount > 0 ? totalPaid / activeCount : 0;
                kpis.avg_duration = subs.length > 0 ? totalDuration / subs.length : 0;
                
                // Calcular receitas
                kpis.total_revenue = totalPaid;
                kpis.monthly_revenue = totalMRR;
                
                // Calcular receitas por per√≠odo
                const now = new Date();
                const date30d = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                const date90d = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                const yearStart = new Date(now.getFullYear(), 0, 1);
                
                if (hasTotalPaid) {
                    const revenue30dQuery = `SELECT SUM(total_paid) as revenue FROM subscriptions WHERE created_at >= ?`;
                    const revenue30dResult = await db.get(revenue30dQuery, [date30d.toISOString()]);
                    kpis.revenue_30d = parseFloat(revenue30dResult?.revenue || 0);
                    
                    const revenue90dQuery = `SELECT SUM(total_paid) as revenue FROM subscriptions WHERE created_at >= ?`;
                    const revenue90dResult = await db.get(revenue90dQuery, [date90d.toISOString()]);
                    kpis.revenue_90d = parseFloat(revenue90dResult?.revenue || 0);
                    
                    const revenueYearQuery = `SELECT SUM(total_paid) as revenue FROM subscriptions WHERE created_at >= ?`;
                    const revenueYearResult = await db.get(revenueYearQuery, [yearStart.toISOString()]);
                    kpis.revenue_year = parseFloat(revenueYearResult?.revenue || 0);
                }
                
                // Calcular m√©tricas mensais
                const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
                const monthlyNewQuery = `SELECT COUNT(*) as count FROM subscriptions WHERE created_at >= ?`;
                const monthlyNewResult = await db.get(monthlyNewQuery, [monthStart.toISOString()]);
                kpis.monthly_new = parseInt(monthlyNewResult?.count || 0);
                
                const monthlyCanceledQuery = `SELECT COUNT(*) as count FROM subscriptions WHERE status = 'canceled' AND updated_at >= ?`;
                const monthlyCanceledResult = await db.get(monthlyCanceledQuery, [monthStart.toISOString()]);
                kpis.monthly_canceled = parseInt(monthlyCanceledResult?.count || 0);
                
                // Calcular crescimento mensal
                const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
                const lastMonthNewQuery = `SELECT COUNT(*) as count FROM subscriptions WHERE created_at >= ? AND created_at <= ?`;
                const lastMonthNewResult = await db.get(lastMonthNewQuery, [lastMonthStart.toISOString(), lastMonthEnd.toISOString()]);
                const lastMonthNew = parseInt(lastMonthNewResult?.count || 0);
                kpis.monthly_growth = lastMonthNew > 0 ? ((kpis.monthly_new - lastMonthNew) / lastMonthNew) * 100 : 0;
                
                // Total de assinaturas
                const totalSubsQuery = `SELECT COUNT(*) as count FROM subscriptions`;
                const totalSubsResult = await db.get(totalSubsQuery);
                kpis.total_subscriptions = parseInt(totalSubsResult?.count || 0);
                
                // Total canceladas
                const totalCanceledQuery = `SELECT COUNT(*) as count FROM subscriptions WHERE status = 'canceled'`;
                const totalCanceledResult = await db.get(totalCanceledQuery);
                kpis.total_canceled = parseInt(totalCanceledResult?.count || 0);
                
                // Taxa de reten√ß√£o
                const totalActive = kpis.active_subscribers;
                kpis.retention_rate = kpis.total_subscriptions > 0 ? (totalActive / kpis.total_subscriptions) * 100 : 0;
                
                // Ticket m√©dio
                kpis.avg_ticket = subs.length > 0 ? totalPaid / subs.length : 0;
                
                // Taxa de convers√£o (assumindo que voc√™ tem dados de visitantes/usu√°rios)
                // Por enquanto, vamos calcular baseado em novos assinantes vs total de usu√°rios
                const totalUsersQuery = `SELECT COUNT(*) as count FROM users`;
                const totalUsersResult = await db.get(totalUsersQuery);
                const totalUsers = parseInt(totalUsersResult?.count || 1);
                kpis.conversion_rate = totalUsers > 0 ? (kpis.total_subscriptions / totalUsers) * 100 : 0;
                
                // Calcular churn rate (√∫ltimos 30 dias)
                if (hasUpdatedAt) {
                    const churnStartDate = new Date();
                    churnStartDate.setDate(churnStartDate.getDate() - 30);
                    const churnQuery = `
                        SELECT COUNT(*) as canceled_count
                        FROM subscriptions
                        WHERE status = 'canceled' AND updated_at >= ?
                    `;
                    const churnResult = await db.get(churnQuery, [churnStartDate.toISOString()]);
                    const canceledCount = churnResult?.canceled_count || 0;
                    const totalActive30DaysAgo = activeCount + canceledCount;
                    kpis.churn_rate = totalActive30DaysAgo > 0 ? (canceledCount / totalActive30DaysAgo) * 100 : 0;
                }
                
                // Preparar dados para gr√°ficos (apenas se tiver colunas necess√°rias)
                if (hasMonthlyAmount) {
                    // MRR ao longo do tempo (√∫ltimos 12 meses)
                    for (let i = 11; i >= 0; i--) {
                        const date = new Date();
                        date.setMonth(date.getMonth() - i);
                        const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
                        const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                        
                        let mrrQuery = `
                            SELECT SUM(monthly_amount) as mrr
                            FROM subscriptions
                            WHERE status = 'active' AND created_at <= ?
                        `;
                        if (hasCanceledAt) {
                            mrrQuery += ' AND (status != \'canceled\' OR canceled_at > ?)';
                            const mrrResult = await db.get(mrrQuery, [monthEnd.toISOString(), monthEnd.toISOString()]);
                            charts.mrr.labels.push(monthStart.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                            charts.mrr.data.push(parseFloat(mrrResult?.mrr || 0));
                        } else {
                            const mrrResult = await db.get(mrrQuery, [monthEnd.toISOString()]);
                            charts.mrr.labels.push(monthStart.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                            charts.mrr.data.push(parseFloat(mrrResult?.mrr || 0));
                        }
                    }
                }
                
                // Assinantes ao longo do tempo
                for (let i = 11; i >= 0; i--) {
                    const date = new Date();
                    date.setMonth(date.getMonth() - i);
                    const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                    
                    let subsQuery = `
                        SELECT COUNT(*) as count
                        FROM subscriptions
                        WHERE status = 'active' AND created_at <= ?
                    `;
                    if (hasCanceledAt) {
                        subsQuery += ' AND (status != \'canceled\' OR canceled_at > ?)';
                        const subsResult = await db.get(subsQuery, [monthEnd.toISOString(), monthEnd.toISOString()]);
                        charts.subscribers.labels.push(date.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                        charts.subscribers.data.push(parseInt(subsResult?.count || 0));
                    } else {
                        const subsResult = await db.get(subsQuery, [monthEnd.toISOString()]);
                        charts.subscribers.labels.push(date.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                        charts.subscribers.data.push(parseInt(subsResult?.count || 0));
                    }
                }
                
                // Distribui√ß√£o por plano
                charts.plans_distribution.labels = Object.keys(planDistribution);
                charts.plans_distribution.data = Object.values(planDistribution);
                
                // Churn mensal
                if (hasUpdatedAt) {
                    for (let i = 11; i >= 0; i--) {
                        const date = new Date();
                        date.setMonth(date.getMonth() - i);
                        const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
                        const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                        
                        const churnQuery = `
                            SELECT 
                                COUNT(CASE WHEN status = 'canceled' AND updated_at >= ? AND updated_at <= ? THEN 1 END) as canceled,
                                COUNT(CASE WHEN status = 'active' AND created_at <= ? THEN 1 END) as active
                            FROM subscriptions
                            WHERE created_at <= ?
                        `;
                        const churnResult = await db.get(churnQuery, [
                            monthStart.toISOString(), 
                            monthEnd.toISOString(),
                            monthEnd.toISOString(),
                            monthEnd.toISOString()
                        ]);
                        const canceled = churnResult?.canceled || 0;
                        const active = churnResult?.active || 1;
                        const churnRate = (canceled / active) * 100;
                        
                        charts.churn.labels.push(date.toLocaleDateString('pt-BR', { month: 'short', year: 'numeric' }));
                        charts.churn.data.push(churnRate);
                    }
                }
                
                // Preparar lista de assinaturas
                subscriptions.push(...subs.map(sub => ({
                    user_email: sub.user_email || 'N/A',
                    plan_name: (hasPlanName && sub.plan_name) ? sub.plan_name : 'N/A',
                    status: sub.status || 'unknown',
                    monthly_amount: hasMonthlyAmount ? parseFloat(sub.monthly_amount || 0) : 0,
                    start_date: sub.created_at,
                    next_billing_date: (hasNextBilling && sub.next_billing_date) ? sub.next_billing_date : null,
                    duration_days: hasDurationDays ? parseInt(sub.duration_days || 0) : 0,
                    total_paid: hasTotalPaid ? parseFloat(sub.total_paid || 0) : 0
                })));
                
                // Gerar insights
                insights.length = 0; // Limpar insights padr√£o
                
                if (kpis.mrr > 0) {
                    insights.push({
                        type: 'positive',
                        icon: 'trending-up',
                        title: 'MRR Crescente',
                        message: `Seu MRR atual √© de ${kpis.mrr.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}. Continue focado em crescimento!`
                    });
                }
                
                if (kpis.churn_rate > 5) {
                    insights.push({
                        type: 'warning',
                        icon: 'alert-triangle',
                        title: 'Churn Rate Alto',
                        message: `Seu churn rate est√° em ${kpis.churn_rate.toFixed(2)}%. Considere melhorar a reten√ß√£o de clientes.`
                    });
                }
                
                if (kpis.new_subscribers > 0) {
                    insights.push({
                        type: 'positive',
                        icon: 'user-plus',
                        title: 'Novos Assinantes',
                        message: `${kpis.new_subscribers} novos assinantes no per√≠odo selecionado.`
                    });
                }
            }
        } catch (err) {
            console.log('Tabela de assinaturas n√£o encontrada ou erro ao buscar:', err.message);
        }
        
        res.json({
            kpis,
            charts,
            subscriptions,
            insights
        });
    } catch (err) {
        console.error('Erro ao buscar assinaturas:', err);
        res.status(500).json({ message: 'Erro ao buscar dados de assinaturas' });
    }
});

// GET /api/admin/subscriptions/report/revenue - Relat√≥rio de receitas
app.get('/api/admin/subscriptions/report/revenue', authenticateToken, isAdmin, async (req, res) => {
    try {
        const tableExists = await db.get(`
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='subscriptions'
        `);
        
        if (!tableExists) {
            return res.status(404).json({ message: 'Tabela de assinaturas n√£o encontrada' });
        }
        
        const tableInfo = await db.all(`PRAGMA table_info(subscriptions)`);
        const columns = tableInfo.map(col => col.name);
        const hasTotalPaid = columns.includes('total_paid');
        const hasMonthlyAmount = columns.includes('monthly_amount');
        
        const now = new Date();
        const date30d = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const date90d = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
        const yearStart = new Date(now.getFullYear(), 0, 1);
        
        let csv = 'M√©trica,Valor\n';
        const totalRevenue = hasTotalPaid ? (await db.get('SELECT SUM(total_paid) as total FROM subscriptions')).total || 0 : 0;
        const revenue30d = hasTotalPaid ? (await db.get('SELECT SUM(total_paid) as total FROM subscriptions WHERE created_at >= ?', [date30d.toISOString()])).total || 0 : 0;
        const revenue90d = hasTotalPaid ? (await db.get('SELECT SUM(total_paid) as total FROM subscriptions WHERE created_at >= ?', [date90d.toISOString()])).total || 0 : 0;
        const revenueYear = hasTotalPaid ? (await db.get('SELECT SUM(total_paid) as total FROM subscriptions WHERE created_at >= ?', [yearStart.toISOString()])).total || 0 : 0;
        const mrr = hasMonthlyAmount ? (await db.get('SELECT SUM(monthly_amount) as mrr FROM subscriptions WHERE status = ?', ['active'])).mrr || 0 : 0;
        const arr = mrr * 12;
        
        csv += `Receita Total,${totalRevenue}\n`;
        csv += `Receita √öltimos 30 Dias,${revenue30d}\n`;
        csv += `Receita √öltimos 90 Dias,${revenue90d}\n`;
        csv += `Receita do Ano,${revenueYear}\n`;
        csv += `MRR,${mrr}\n`;
        csv += `ARR,${arr}\n`;
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=relatorio_receitas_${Date.now()}.csv`);
        res.send(csv);
    } catch (err) {
        console.error('Erro ao exportar relat√≥rio de receitas:', err);
        res.status(500).json({ message: 'Erro ao exportar relat√≥rio' });
    }
});

// GET /api/admin/subscriptions/report/subscriptions - Relat√≥rio de assinaturas
app.get('/api/admin/subscriptions/report/subscriptions', authenticateToken, isAdmin, async (req, res) => {
    try {
        const tableExists = await db.get(`
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='subscriptions'
        `);
        
        if (!tableExists) {
            return res.status(404).json({ message: 'Tabela de assinaturas n√£o encontrada' });
        }
        
        const totalSubs = await db.get('SELECT COUNT(*) as count FROM subscriptions');
        const activeSubs = await db.get('SELECT COUNT(*) as count FROM subscriptions WHERE status = ?', ['active']);
        const canceledSubs = await db.get('SELECT COUNT(*) as count FROM subscriptions WHERE status = ?', ['canceled']);
        
        const now = new Date();
        const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
        const monthlyNew = await db.get('SELECT COUNT(*) as count FROM subscriptions WHERE created_at >= ?', [monthStart.toISOString()]);
        const monthlyCanceled = await db.get('SELECT COUNT(*) as count FROM subscriptions WHERE status = ? AND updated_at >= ?', ['canceled', monthStart.toISOString()]);
        
        let csv = 'M√©trica,Valor\n';
        csv += `Total de Assinaturas,${totalSubs?.count || 0}\n`;
        csv += `Assinaturas Ativas,${activeSubs?.count || 0}\n`;
        csv += `Assinaturas Canceladas,${canceledSubs?.count || 0}\n`;
        csv += `Novos Este M√™s,${monthlyNew?.count || 0}\n`;
        csv += `Cancelados Este M√™s,${monthlyCanceled?.count || 0}\n`;
        const retentionRate = totalSubs?.count > 0 ? ((activeSubs?.count || 0) / totalSubs.count * 100).toFixed(2) : 0;
        csv += `Taxa de Reten√ß√£o,${retentionRate}%\n`;
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=relatorio_assinaturas_${Date.now()}.csv`);
        res.send(csv);
    } catch (err) {
        console.error('Erro ao exportar relat√≥rio de assinaturas:', err);
        res.status(500).json({ message: 'Erro ao exportar relat√≥rio' });
    }
});

// GET /api/admin/subscriptions/export - Exportar assinaturas
app.get('/api/admin/subscriptions/export', authenticateToken, isAdmin, async (req, res) => {
    try {
        const period = parseInt(req.query.period) || 30;
        const status = req.query.status || 'all';
        
        const endDate = new Date();
        const startDate = new Date();
        if (period !== 0) {
            startDate.setDate(startDate.getDate() - period);
        }
        
        let query = `
            SELECT s.*, u.email as user_email, u.name as user_name
            FROM subscriptions s
            LEFT JOIN users u ON s.user_id = u.id
            WHERE s.created_at >= ? AND s.created_at <= ?
        `;
        const params = [startDate.toISOString(), endDate.toISOString()];
        
        if (status !== 'all') {
            query += ' AND s.status = ?';
            params.push(status);
        }
        
        query += ' ORDER BY s.created_at DESC';
        
        const subscriptions = await db.all(query, params);
        
        // Gerar CSV
        const csvHeader = 'Email,Plano,Status,Valor Mensal,In√≠cio,Pr√≥xima Cobran√ßa,Dura√ß√£o (dias),Total Pago\n';
        const csvRows = subscriptions.map(sub => {
            return [
                sub.user_email || '',
                sub.plan_name || '',
                sub.status || '',
                parseFloat(sub.monthly_amount || 0).toFixed(2),
                sub.created_at || '',
                sub.next_billing_date || '',
                sub.duration_days || 0,
                parseFloat(sub.total_paid || 0).toFixed(2)
            ].join(',');
        }).join('\n');
        
        const csv = csvHeader + csvRows;
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=assinaturas_${Date.now()}.csv`);
        res.send(csv);
    } catch (err) {
        console.error('Erro ao exportar assinaturas:', err);
        res.status(500).json({ message: 'Erro ao exportar assinaturas' });
    }
});

// POST /api/admin/stripe-config - Salvar configura√ß√µes do Stripe
app.post('/api/admin/stripe-config', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { publishable_key, secret_key, webhook_secret, plans } = req.body;
        
        if (publishable_key !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['stripe_publishable_key', JSON.stringify(publishable_key)]);
        }
        
        if (secret_key !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['stripe_secret_key', JSON.stringify(secret_key)]);
        }
        
        if (webhook_secret !== undefined) {
            await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", ['stripe_webhook_secret', JSON.stringify(webhook_secret)]);
        }
        
        if (plans && typeof plans === 'object') {
            for (const [planKey, planValue] of Object.entries(plans)) {
                if (planValue !== undefined && planValue !== null && planValue !== '') {
                    await db.run("REPLACE INTO app_settings (key, value) VALUES (?, ?)", [`stripe_${planKey}`, JSON.stringify(planValue)]);
                }
            }
        }
        
        res.json({ message: 'Configura√ß√µes do Stripe salvas com sucesso.' });
    } catch (err) {
        console.error("Erro ao salvar configura√ß√µes do Stripe:", err.message);
        res.status(500).json({ message: "Erro ao salvar configura√ß√µes do Stripe." });
    }
});

// Fun√ß√£o auxiliar para obter inst√¢ncia do Stripe
async function getStripeInstance() {
    try {
        const secretKeyRow = await db.get("SELECT value FROM app_settings WHERE key = 'stripe_secret_key'");
        if (!secretKeyRow || !secretKeyRow.value) {
            throw new Error('Chave secreta do Stripe n√£o configurada');
        }
        const secretKey = JSON.parse(secretKeyRow.value);
        if (!secretKey || secretKey.trim() === '') {
            throw new Error('Chave secreta do Stripe inv√°lida');
        }
        return new Stripe(secretKey);
    } catch (error) {
        console.error('[STRIPE] Erro ao criar inst√¢ncia:', error.message);
        throw error;
    }
}

// GET /api/stripe/plans - Obter IDs dos planos do Stripe
app.get('/api/stripe/plans', authenticateToken, async (req, res) => {
    try {
        const planKeys = [
            'plan-free',
            'plan-start',
            'plan-turbo',
            'plan-master',
            'plan-start-annual',
            'plan-turbo-annual',
            'plan-master-annual',
            'package-1000',
            'package-2500',
            'package-5000',
            'package-10000',
            'package-20000'
        ];
        
        const plans = {};
        for (const key of planKeys) {
            const row = await db.get("SELECT value FROM app_settings WHERE key = ?", [`stripe_${key}`]);
            if (row && row.value) {
                try {
                    plans[key] = JSON.parse(row.value);
                } catch {
                    plans[key] = row.value;
                }
            }
        }
        
        res.json({ success: true, plans });
    } catch (error) {
        console.error('[STRIPE] Erro ao buscar planos:', error.message);
        res.status(500).json({ success: false, message: 'Erro ao buscar planos do Stripe' });
    }
});

// POST /api/stripe/create-checkout - Criar sess√£o de checkout
app.post('/api/stripe/create-checkout', authenticateToken, async (req, res) => {
    try {
        const { planKey, planType } = req.body; // planType: 'subscription' ou 'one-time'
        
        if (!planKey) {
            return res.status(400).json({ success: false, message: 'ID do plano √© obrigat√≥rio' });
        }
        
        // Buscar o Price ID do Stripe
        const row = await db.get("SELECT value FROM app_settings WHERE key = ?", [`stripe_${planKey}`]);
        if (!row || !row.value) {
            return res.status(404).json({ success: false, message: 'Plano n√£o encontrado ou n√£o configurado no Stripe' });
        }
        
        let priceId;
        try {
            priceId = JSON.parse(row.value);
        } catch {
            priceId = row.value;
        }
        
        if (!priceId || priceId.trim() === '') {
            return res.status(404).json({ success: false, message: 'Price ID do Stripe n√£o configurado para este plano' });
        }
        
        // Validar se √© um Price ID v√°lido (deve come√ßar com 'price_')
        if (!priceId.startsWith('price_')) {
            return res.status(400).json({ 
                success: false, 
                message: `ID inv√°lido para o plano ${planKey}. Voc√™ configurou "${priceId}", mas precisa usar um Price ID (que come√ßa com "price_"). Product IDs (que come√ßam com "prod_") n√£o funcionam.`,
                error: 'Invalid Price ID format',
                hint: 'No Stripe, voc√™ precisa usar o Price ID (price_...), n√£o o Product ID (prod_...). Acesse o produto no Stripe e copie o Price ID correto.'
            });
        }
        
        // Obter dados do usu√°rio
        const userId = req.user.id;
        const userData = await db.get("SELECT email FROM users WHERE id = ?", [userId]);
        if (!userData) {
            return res.status(404).json({ success: false, message: 'Usu√°rio n√£o encontrado' });
        }
        
        // Mapear planKey para nome do plano (ANTES de criar URLs)
        const planNames = {
            'plan-free': 'FREE',
            'plan-start': 'START CREATOR',
            'plan-turbo': 'TURBO MAKER',
            'plan-master': 'MASTER PRO',
            'plan-start-annual': 'START CREATOR Anual',
            'plan-turbo-annual': 'TURBO MAKER Anual',
            'plan-master-annual': 'MASTER PRO Anual',
            'package-1000': 'Pacote 1.000 Cr√©ditos',
            'package-2500': 'Pacote 2.500 Cr√©ditos',
            'package-5000': 'Pacote 5.000 Cr√©ditos',
            'package-10000': 'Pacote 10.000 Cr√©ditos',
            'package-20000': 'Pacote 20.000 Cr√©ditos'
        };
        
        const planName = planNames[planKey] || planKey;
        
        // Obter inst√¢ncia do Stripe
        let stripe;
        try {
            stripe = await getStripeInstance();
        } catch (error) {
            console.error('[STRIPE] Erro ao obter inst√¢ncia do Stripe:', error.message);
            return res.status(500).json({ 
                success: false, 
                message: 'Stripe n√£o est√° configurado. Configure as chaves do Stripe no painel administrativo.',
                error: error.message
            });
        }
        
        // Configurar URLs de sucesso e cancelamento
        const protocol = req.protocol;
        const host = req.get('host');
        // URL de sucesso vai para p√°gina de agradecimento com informa√ß√µes do plano
        const successUrl = `${protocol}://${host}/thank-you.html?session_id={CHECKOUT_SESSION_ID}&planKey=${encodeURIComponent(planKey)}&planName=${encodeURIComponent(planName)}&success=true`;
        const cancelUrl = `${protocol}://${host}/plans.html?canceled=true`;
        
        console.log(`[STRIPE] Criando checkout para plano: ${planKey}, tipo: ${planType || 'subscription'}, priceId: ${priceId}`);
        
        // Criar sess√£o de checkout
        const sessionParams = {
            payment_method_types: ['card'],
            customer_email: userData.email,
            metadata: {
                userId: userId.toString(),
                planKey: planKey,
                planType: planType || 'subscription'
            },
            success_url: successUrl,
            cancel_url: cancelUrl
        };
        
        // Se for assinatura recorrente
        if (planType === 'subscription' || !planType) {
            sessionParams.mode = 'subscription';
            sessionParams.line_items = [{
                price: priceId,
                quantity: 1
            }];
        } else {
            // Se for pagamento √∫nico (pacotes avulsos)
            sessionParams.mode = 'payment';
            sessionParams.line_items = [{
                price: priceId,
                quantity: 1
            }];
        }
        
        let session;
        try {
            session = await stripe.checkout.sessions.create(sessionParams);
            console.log(`[STRIPE] Sess√£o criada com sucesso: ${session.id}`);
        } catch (stripeError) {
            console.error('[STRIPE] Erro ao criar sess√£o no Stripe:', stripeError.message);
            console.error('[STRIPE] Detalhes do erro:', stripeError);
            return res.status(500).json({ 
                success: false, 
                message: `Erro ao criar sess√£o no Stripe: ${stripeError.message}`,
                error: stripeError.message,
                details: stripeError.type || 'unknown'
            });
        }
        
        res.json({ 
            success: true, 
            sessionId: session.id,
            url: session.url
        });
    } catch (error) {
        console.error('[STRIPE] Erro geral ao criar checkout:', error.message);
        console.error('[STRIPE] Stack trace:', error.stack);
        res.status(500).json({ 
            success: false, 
            message: 'Erro ao criar sess√£o de checkout',
            error: error.message
        });
    }
});

// POST /api/stripe/webhook - Webhook do Stripe (n√£o requer autentica√ß√£o)
app.post('/api/stripe/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
    const sig = req.headers['stripe-signature'];
    
    try {
        // Obter webhook secret
        const webhookSecretRow = await db.get("SELECT value FROM app_settings WHERE key = 'stripe_webhook_secret'");
        if (!webhookSecretRow || !webhookSecretRow.value) {
            console.error('[STRIPE WEBHOOK] Webhook secret n√£o configurado');
            return res.status(400).send('Webhook secret n√£o configurado');
        }
        
        let webhookSecret;
        try {
            webhookSecret = JSON.parse(webhookSecretRow.value);
        } catch {
            webhookSecret = webhookSecretRow.value;
        }
        
        // Obter inst√¢ncia do Stripe
        const stripe = await getStripeInstance();
        
        // Verificar assinatura do webhook
        const event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
        
        // Processar eventos
        if (event.type === 'checkout.session.completed') {
            const session = event.data.object;
            const userId = session.metadata?.userId;
            const planKey = session.metadata?.planKey;
            
            if (userId && planKey) {
                // Obter dados do usu√°rio
                const userData = await db.get("SELECT name, email, credits FROM users WHERE id = ?", [userId]);
                if (!userData) {
                    console.error(`[STRIPE WEBHOOK] Usu√°rio ${userId} n√£o encontrado`);
                    return res.json({ received: true });
                }
                
                // Mapear planKey para nome do plano no sistema
                const planMapping = {
                    'plan-free': 'plan-free',
                    'plan-start': 'plan-start',
                    'plan-turbo': 'plan-turbo',
                    'plan-master': 'plan-master',
                    'plan-start-annual': 'plan-start-annual',
                    'plan-turbo-annual': 'plan-turbo-annual',
                    'plan-master-annual': 'plan-master-annual',
                    'package-1000': 'plan-start', // Pacotes podem adicionar cr√©ditos
                    'package-2500': 'plan-turbo',
                    'package-5000': 'plan-master',
                    'package-10000': 'plan-master',
                    'package-20000': 'plan-master'
                };
                
                const systemPlan = planMapping[planKey] || planKey;
                
                // Nomes dos planos para email
                const planNames = {
                    'plan-start': 'START CREATOR',
                    'plan-turbo': 'TURBO MAKER',
                    'plan-master': 'MASTER PRO',
                    'plan-start-annual': 'START CREATOR Anual',
                    'plan-turbo-annual': 'TURBO MAKER Anual',
                    'plan-master-annual': 'MASTER PRO Anual',
                    'package-1000': 'Pacote 1.000 Cr√©ditos',
                    'package-2500': 'Pacote 2.500 Cr√©ditos',
                    'package-5000': 'Pacote 5.000 Cr√©ditos',
                    'package-10000': 'Pacote 10.000 Cr√©ditos',
                    'package-20000': 'Pacote 20.000 Cr√©ditos'
                };
                
                const planName = planNames[planKey] || planKey;
                const amount = session.amount_total ? (session.amount_total / 100).toFixed(2) : '0.00';
                const currency = session.currency?.toUpperCase() || 'BRL';
                const paymentDate = new Date().toLocaleDateString('pt-BR');
                
                // Atualizar plano do usu√°rio
                if (session.mode === 'subscription') {
                    // Assinatura recorrente
                    await db.run(
                        "UPDATE users SET subscription_plan = ?, plan = ? WHERE id = ?",
                        [systemPlan, systemPlan, userId]
                    );
                    
                    // Recarregar cr√©ditos baseado no plano
                    const planCreditsRow = await db.get(
                        "SELECT monthly_credits FROM plan_credits WHERE plan_name = ?",
                        [systemPlan]
                    );
                    
                    if (planCreditsRow) {
                        await db.run(
                            "UPDATE users SET credits = ? WHERE id = ?",
                            [planCreditsRow.monthly_credits, userId]
                        );
                    }
                    
                    // Calcular pr√≥xima cobran√ßa (30 dias para mensal, 365 para anual)
                    const nextBillingDate = new Date();
                    if (planKey.includes('annual')) {
                        nextBillingDate.setFullYear(nextBillingDate.getFullYear() + 1);
                    } else {
                        nextBillingDate.setMonth(nextBillingDate.getMonth() + 1);
                    }
                    const nextBilling = nextBillingDate.toLocaleDateString('pt-BR');
                    
                    // Enviar email de assinatura (usar template espec√≠fico do plano ou gen√©rico)
                    try {
                        const templateType = `subscription_${planKey}`;
                        const template = await getEmailTemplate(templateType);
                        
                        if (template) {
                            // Template espec√≠fico do plano existe
                            await sendTemplateEmail(templateType, userData.email, {
                                nome: userData.name,
                                email: userData.email,
                                plano: planName,
                                valor: `R$ ${amount}`,
                                data_pagamento: paymentDate,
                                proxima_cobranca: nextBilling,
                                creditos: planCreditsRow?.monthly_credits || 0
                            });
                        } else {
                            // Usar template gen√©rico de pagamento
                            await sendTemplateEmail('payment', userData.email, {
                                nome: userData.name,
                                email: userData.email,
                                plano: planName,
                                valor: `R$ ${amount}`,
                                data_pagamento: paymentDate,
                                proxima_cobranca: nextBilling
                            });
                        }
                    } catch (emailError) {
                        console.error('[EMAIL] Erro ao enviar email de assinatura:', emailError.message);
                    }
                } else {
                    // Pagamento √∫nico - adicionar cr√©ditos
                    const creditAmounts = {
                        'package-1000': 1000,
                        'package-2500': 2500,
                        'package-5000': 5000,
                        'package-10000': 10000,
                        'package-20000': 20000
                    };
                    
                    const creditsToAdd = creditAmounts[planKey] || 0;
                    if (creditsToAdd > 0) {
                        await db.run(
                            "UPDATE users SET credits = credits + ? WHERE id = ?",
                            [creditsToAdd, userId]
                        );
                        
                        // Obter saldo atualizado
                        const updatedUser = await db.get("SELECT credits FROM users WHERE id = ?", [userId]);
                        
                        // Enviar email de pacote comprado
                        try {
                            await sendTemplateEmail('package', userData.email, {
                                nome: userData.name,
                                email: userData.email,
                                pacote: planName,
                                creditos: creditsToAdd,
                                valor: `R$ ${amount}`,
                                data_compra: paymentDate,
                                saldo_atual: updatedUser?.credits || 0
                            });
                        } catch (emailError) {
                            console.error('[EMAIL] Erro ao enviar email de pacote:', emailError.message);
                        }
                    }
                }
                
                console.log(`[STRIPE WEBHOOK] Usu√°rio ${userId} atualizado para plano ${systemPlan}`);
            }
        } else if (event.type === 'customer.subscription.deleted') {
            // Assinatura cancelada
            const subscription = event.data.object;
            const customerId = subscription.customer;
            
            // Buscar usu√°rio pelo customer_id ou metadata
            try {
                // Tentar encontrar usu√°rio pela subscription
                const userData = await db.get(
                    "SELECT id, name, email, subscription_plan FROM users WHERE id IN (SELECT user_id FROM subscriptions WHERE stripe_subscription_id = ?)",
                    [subscription.id]
                );
                
                if (userData) {
                    // Enviar email de cancelamento
                    const cancelDate = new Date().toLocaleDateString('pt-BR');
                    const endDate = new Date();
                    endDate.setMonth(endDate.getMonth() + 1); // Acesso at√© fim do per√≠odo pago
                    const endAccessDate = endDate.toLocaleDateString('pt-BR');
                    
                    const planNames = {
                        'plan-start': 'START CREATOR',
                        'plan-turbo': 'TURBO MAKER',
                        'plan-master': 'MASTER PRO',
                        'plan-start-annual': 'START CREATOR Anual',
                        'plan-turbo-annual': 'TURBO MAKER Anual',
                        'plan-master-annual': 'MASTER PRO Anual'
                    };
                    
                    const planName = planNames[userData.subscription_plan] || userData.subscription_plan;
                    
                    await sendTemplateEmail('cancel', userData.email, {
                        nome: userData.name,
                        email: userData.email,
                        plano: planName,
                        data_cancelamento: cancelDate,
                        data_fim_acesso: endAccessDate
                    });
                }
            } catch (emailError) {
                console.error('[EMAIL] Erro ao enviar email de cancelamento:', emailError.message);
            }
            
            console.log(`[STRIPE WEBHOOK] Assinatura ${subscription.id} cancelada`);
        }
        
        res.json({ received: true });
    } catch (err) {
        console.error('[STRIPE WEBHOOK] Erro:', err.message);
        res.status(400).send(`Webhook Error: ${err.message}`);
    }
});

// POST /api/admin/voice-api-key/validate - Validar chave de voz do admin
app.post('/api/admin/voice-api-key/validate', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API √© obrigat√≥ria' });
        }
        
        // Primeiro, tentar validar como chave do Google Cloud Text-to-Speech (que √© o que vamos usar)
        try {
            const ttsResponse = await fetch(`https://texttospeech.googleapis.com/v1/voices?key=${encodeURIComponent(api_key)}&languageCode=pt-BR`);
            
            if (ttsResponse.status === 200) {
                const ttsData = await ttsResponse.json();
                if (ttsData.voices && ttsData.voices.length > 0) {
                    return res.json({ 
                        success: true, 
                        message: 'Chave do Google Cloud v√°lida! Pode ser usada para Text-to-Speech.',
                        type: 'google-cloud',
                        details: `Encontradas ${ttsData.voices.length} vozes dispon√≠veis para portugu√™s brasileiro.`
                    });
                }
            } else if (ttsResponse.status === 401 || ttsResponse.status === 403) {
                const ttsError = await ttsResponse.json().catch(() => ({}));
                // Se a mensagem menciona que a API n√£o est√° habilitada, a chave √© v√°lida mas precisa habilitar a API
                if (ttsError.error?.message && ttsError.error.message.includes('API has not been used')) {
                    return res.json({ 
                        success: true, 
                        message: 'Chave do Google Cloud v√°lida. Habilite a API Text-to-Speech no Google Cloud Console.',
                        type: 'google-cloud',
                        warning: 'A API Text-to-Speech precisa ser habilitada no Google Cloud Console para usar TTS.'
                    });
                }
                return res.status(400).json({ 
                    success: false, 
                    message: ttsError.error?.message || 'Chave inv√°lida ou sem permiss√£o para Text-to-Speech.',
                    error: ttsError.error?.message
                });
            } else {
                const ttsError = await ttsResponse.json().catch(() => ({}));
                // Se der erro sobre API keys n√£o suportadas, √© chave do Google Cloud (n√£o Gemini direto)
                if (ttsError.error?.message && ttsError.error.message.includes('API keys are not supported')) {
                    return res.json({ 
                        success: true, 
                        message: 'Chave do Google Cloud detectada. Esta chave funciona para Text-to-Speech e outros servi√ßos do Google Cloud.',
                        type: 'google-cloud',
                        warning: 'Esta chave n√£o funciona diretamente com a API do Gemini, mas funciona perfeitamente para Text-to-Speech (TTS).'
                    });
                }
                return res.status(400).json({ 
                    success: false, 
                    message: ttsError.error?.message || 'Erro ao validar chave do Google Cloud.',
                    error: ttsError.error?.message
                });
            }
        } catch (ttsErr) {
            console.log('[Valida√ß√£o] Erro ao validar via TTS, tentando valida√ß√£o Gemini...', ttsErr.message);
        }
        
        // Fallback: tentar valida√ß√£o Gemini (para chaves diretas do Gemini)
        const validationResult = await validateGeminiKey(api_key);
        
        if (validationResult.success) {
            res.json({ 
                success: true, 
                message: validationResult.message || 'Chave v√°lida!',
                type: validationResult.type || 'gemini-api',
                warning: validationResult.warning || null
            });
        } else {
            // Se falhou, mas a mensagem indica que √© chave do Google Cloud, considerar v√°lida
            if (validationResult.error && validationResult.error.includes('API keys are not supported')) {
                return res.json({ 
                    success: true, 
                    message: 'Chave do Google Cloud detectada. Esta chave funciona para Text-to-Speech.',
                    type: 'google-cloud',
                    warning: 'Esta chave n√£o funciona diretamente com a API do Gemini, mas funciona perfeitamente para Text-to-Speech (TTS).'
                });
            }
            
            res.status(400).json({ 
                success: false, 
                message: validationResult.error || 'Chave inv√°lida',
                error: validationResult.error
            });
        }
    } catch (error) {
        console.error('Erro ao validar chave de voz:', error);
        res.status(500).json({ success: false, message: 'Erro ao validar chave', details: error.message });
    }
});

// POST /api/admin/openai-voice/validate - Validar chave de voz OpenAI
app.post('/api/admin/openai-voice/validate', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API √© obrigat√≥ria' });
        }
        
        const validationResult = await validateOpenAIKey(api_key);
        if (validationResult.success) {
            return res.json({
                success: true,
                message: 'Chave OpenAI v√°lida!',
                type: 'openai'
            });
        }
        
        return res.status(400).json({
            success: false,
            message: validationResult.error || 'Chave inv√°lida',
            error: validationResult.error
        });
    } catch (error) {
        console.error('Erro ao validar chave OpenAI:', error);
        res.status(500).json({ success: false, message: 'Erro ao validar chave OpenAI', details: error.message });
    }
});

// POST /api/admin/video-api/validate - Validar chave de v√≠deo (Gemini/Veo)
app.post('/api/admin/video-api/validate', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API √© obrigat√≥ria' });
        }
        
        const validationResult = await validateGeminiKey(api_key);
        if (validationResult.success) {
            return res.json({
                success: true,
                message: validationResult.message || 'Chave Gemini v√°lida!',
                type: validationResult.type || 'gemini'
            });
        }
        
        return res.status(400).json({
            success: false,
            message: validationResult.error || 'Chave inv√°lida',
            error: validationResult.error
        });
    } catch (error) {
        console.error('Erro ao validar chave de v√≠deo:', error);
        res.status(500).json({ success: false, message: 'Erro ao validar chave de v√≠deo', details: error.message });
    }
});

// POST /api/admin/voice-premium/check-balance - Verificar saldo da API Voz Premium
app.post('/api/admin/voice-premium/check-balance', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ message: 'Chave de API √© obrigat√≥ria' });
        }
        
        // Verificar saldo na API GenAIPro conforme documenta√ß√£o oficial
        // Base URL: https://genaipro.vn/api/v1
        // Endpoint: GET /me - retorna informa√ß√µes do usu√°rio incluindo balance
        try {
            const response = await axios.get('https://genaipro.vn/api/v1/me', {
                headers: {
                    'Authorization': `Bearer ${api_key}`,
                    'Content-Type': 'application/json'
                },
                timeout: 15000
            });
            
            if (response && response.data) {
                console.log('[La Casa Dark Core] Resposta do endpoint /me:', JSON.stringify(response.data).substring(0, 300));
                
                // Conforme documenta√ß√£o: { "balance": 1000, ... }
                const balance = response.data.balance;
                
                if (balance !== null && balance !== undefined) {
                    console.log(`[La Casa Dark Core] Saldo encontrado: ${balance}`);
                    res.json({ 
                        success: true, 
                        balance: parseFloat(balance),
                        message: 'Saldo verificado com sucesso'
                    });
                    return;
                }
            }
            
            // Se n√£o encontrou balance, retornar sucesso mas sem saldo
            res.json({ 
                success: true, 
                balance: null,
                message: 'Chave v√°lida, mas saldo n√£o dispon√≠vel na resposta'
            });
            
        } catch (apiError) {
            console.error('[La Casa Dark Core] Erro ao verificar saldo:', apiError.message);
            if (apiError.response) {
                console.error('[La Casa Dark Core] Status:', apiError.response.status);
                console.error('[La Casa Dark Core] Data:', apiError.response.data);
                
                // Se for erro 401, a chave √© inv√°lida
                if (apiError.response.status === 401) {
                    return res.status(401).json({ 
                        success: false,
                        message: 'Chave de API inv√°lida ou expirada',
                        balance: null
                    });
                }
            }
            
            // Outros erros - retornar erro
            res.status(500).json({ 
                success: false,
                message: `Erro ao verificar saldo: ${apiError.message}`,
                balance: null
            });
        }
    } catch (error) {
        console.error('Erro ao verificar saldo:', error);
        res.status(500).json({ 
            success: false,
            message: 'Erro ao verificar saldo', 
            details: error.message,
            balance: null
        });
    }
});

// POST /api/admin/voice-premium/save - Salvar chave da API Voz Premium
app.post('/api/admin/voice-premium/save', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key, name = 'Voz Premium' } = req.body;
        if (!api_key) {
            return res.status(400).json({ message: 'Chave de API √© obrigat√≥ria' });
        }
        
        // Verificar se j√° existe uma API Voz Premium
        let existingApi = await db.get(`
            SELECT * FROM api_providers 
            WHERE provider = 'genaipro' OR provider = 'voice_premium'
            LIMIT 1
        `);
        
        if (existingApi) {
            // Atualizar existente
            await db.run(`
                UPDATE api_providers SET
                    api_key = ?,
                    name = ?,
                    is_active = 1,
                    is_default = 1,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            `, [api_key, name, existingApi.id]);
            
            // Desmarcar outras como padr√£o
            await db.run('UPDATE api_providers SET is_default = 0 WHERE id != ?', [existingApi.id]);
            
            res.json({ message: 'Chave de API Voz Premium atualizada com sucesso', id: existingApi.id });
        } else {
            // Criar nova
            const result = await db.run(`
                INSERT INTO api_providers (
                    name, provider, model, api_key, unit_type, unit_size,
                    real_cost_per_unit, credits_per_unit, markup, is_premium,
                    is_active, is_default
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                name, 'genaipro', 'voice-premium-default', api_key, 'tokens', 1000,
                0.0, 1.0, 1.0, 1, 1, 1
            ]);
            
            // Desmarcar outras como padr√£o
            await db.run('UPDATE api_providers SET is_default = 0 WHERE id != ?', [result.lastID]);
            
            res.json({ message: 'Chave de API Voz Premium salva com sucesso', id: result.lastID });
        }
    } catch (error) {
        console.error('Erro ao salvar chave:', error);
        res.status(500).json({ message: 'Erro ao salvar chave', details: error.message });
    }
});

// POST /api/admin/laozhang/verify - Verificar chave da API Laozhang.ai
app.post('/api/admin/laozhang/verify', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API √© obrigat√≥ria' });
        }
        
        // Verificar chave fazendo uma requisi√ß√£o simples para a API da laozhang.ai
        // Tentamos alguns endpoints comuns para verificar a chave
        const endpointsToTry = [
            'https://api.laozhang.ai/v1/status',
            'https://api.laozhang.ai/api/status',
            'https://api.laozhang.ai/status',
            'https://api.laozhang.ai/'
        ];
        
        let lastError = null;
        
        for (const endpoint of endpointsToTry) {
            try {
                const response = await axios.get(endpoint, {
                    headers: {
                        'Authorization': `Bearer ${api_key}`,
                        'Content-Type': 'application/json'
                    },
                    timeout: 5000,
                    validateStatus: (status) => status < 500 // N√£o lan√ßar erro para 4xx
                });
                
                // Se a resposta for bem-sucedida (status 200-299), a chave √© v√°lida
                if (response.status >= 200 && response.status < 300) {
                    res.json({ 
                        success: true, 
                        message: 'Chave de API v√°lida'
                    });
                    return;
                }
                
                // Se for erro 401/403, a chave √© inv√°lida
                if (response.status === 401 || response.status === 403) {
                    res.json({ 
                        success: false, 
                        message: 'Chave de API inv√°lida ou expirada'
                    });
                    return;
                }
                
            } catch (apiError) {
                console.error(`[La Casa Dark Core] Erro ao verificar endpoint ${endpoint}:`, apiError.message);
                lastError = apiError;
                
                // Se for erro 401/403, a chave √© inv√°lida
                if (apiError.response && (apiError.response.status === 401 || apiError.response.status === 403)) {
                    res.json({ 
                        success: false, 
                        message: 'Chave de API inv√°lida ou expirada'
                    });
                    return;
                }
                
                // Continuar tentando outros endpoints
                continue;
            }
        }
        
        // Se chegou aqui, nenhum endpoint funcionou, mas n√£o foi erro de autentica√ß√£o
        // Vamos considerar a chave como v√°lida (pode ser que a API n√£o tenha endpoint de verifica√ß√£o)
        // O importante √© que n√£o foi rejeitada por autentica√ß√£o
        res.json({ 
            success: true, 
            message: 'Chave de API aceita (n√£o foi poss√≠vel verificar endpoint, mas n√£o h√° erro de autentica√ß√£o)'
        });
    } catch (error) {
        console.error('Erro ao verificar chave Laozhang.ai:', error);
        res.status(500).json({ 
            success: false,
            message: 'Erro ao verificar chave', 
            details: error.message
        });
    }
});

// POST /api/admin/downsub/verify - Verificar chave da API DownSub
app.post('/api/admin/downsub/verify', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ success: false, message: 'Chave de API √© obrigat√≥ria' });
        }
        
        try {
            // Verificar chave fazendo uma requisi√ß√£o para o endpoint de status
            const response = await axios.get('https://api.downsub.com/status', {
                headers: {
                    'Authorization': `Bearer ${api_key}`,
                    'Content-Type': 'application/json'
                },
                timeout: 10000,
                validateStatus: (status) => status < 500 // N√£o lan√ßar erro para 4xx
            });
            
            if (response.status === 200 && response.data && response.data.status === 'success') {
                res.json({ 
                    success: true, 
                    message: 'Chave de API v√°lida',
                    credits: response.data.data || {}
                });
                return;
            }
            
            // Se for erro 401/403, a chave √© inv√°lida
            if (response.status === 401 || response.status === 403) {
                res.json({ 
                    success: false, 
                    message: 'Chave de API inv√°lida ou expirada'
                });
                return;
            }
            
            // Outros erros
            res.json({ 
                success: false, 
                message: 'Erro ao verificar chave: ' + (response.data?.message || 'Erro desconhecido')
            });
        } catch (apiErr) {
            if (apiErr.response) {
                if (apiErr.response.status === 401 || apiErr.response.status === 403) {
                    res.json({ 
                        success: false, 
                        message: 'Chave de API inv√°lida ou expirada'
                    });
                } else {
                    res.json({ 
                        success: false, 
                        message: 'Erro ao verificar chave: ' + (apiErr.response.data?.message || 'Erro desconhecido')
                    });
                }
            } else {
                throw apiErr;
            }
        }
    } catch (error) {
        console.error('[Admin] Erro ao verificar chave DownSub:', error);
        res.status(500).json({ 
            success: false,
            message: 'Erro ao verificar chave', 
            details: error.message
        });
    }
});

// POST /api/admin/downsub/save - Salvar chave da API DownSub
app.post('/api/admin/downsub/save', authenticateToken, isAdmin, async (req, res) => {
    try {
        const { api_key } = req.body;
        if (!api_key) {
            return res.status(400).json({ message: 'Chave de API √© obrigat√≥ria' });
        }
        
        // Verificar se j√° existe uma API DownSub
        let existingApi = await db.get(`
            SELECT * FROM api_providers 
            WHERE provider = 'downsub'
            LIMIT 1
        `);
        
        if (existingApi) {
            // Atualizar existente
            await db.run(`
                UPDATE api_providers SET
                    api_key = ?,
                    name = 'DownSub API',
                    is_active = 1,
                    is_default = 1,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            `, [encrypt(api_key), existingApi.id]);
            
            res.json({ message: 'Chave de API DownSub atualizada com sucesso', id: existingApi.id });
        } else {
            // Criar nova
            const result = await db.run(`
                INSERT INTO api_providers (
                    name, provider, model, api_key, unit_type, unit_size,
                    real_cost_per_unit, credits_per_unit, markup, is_premium,
                    is_active, is_default
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                'DownSub API', 'downsub', 'downsub-default', encrypt(api_key), 'calls', 1,
                0.0, 1.0, 1.0, 0, 1, 1
            ]);
            
            res.json({ message: 'Chave de API DownSub salva com sucesso', id: result.lastID });
        }
    } catch (error) {
        console.error('Erro ao salvar chave DownSub:', error);
        res.status(500).json({ message: 'Erro ao salvar chave', details: error.message });
    }
});

// Fun√ß√£o para obter transcri√ß√£o usando API DownSub
async function getTranscriptFromDownSub(videoUrl, apiKey) {
    try {
        console.log('[DownSub] Tentando obter transcri√ß√£o para:', videoUrl);
        
        const response = await axios.post('https://api.downsub.com/download', 
            { url: videoUrl },
            {
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                timeout: 60000 // 60 segundos
            }
        );
        
        if (response.data && response.data.status === 'success' && response.data.data) {
            const data = response.data.data;
            
            // Verificar se h√° legendas dispon√≠veis
            if (data.subtitles && Array.isArray(data.subtitles) && data.subtitles.length > 0) {
                // Tentar obter legenda em portugu√™s primeiro, depois ingl√™s, depois a primeira dispon√≠vel
                let selectedSubtitle = null;
                
                // Procurar portugu√™s
                selectedSubtitle = data.subtitles.find(s => 
                    s.language && (s.language.toLowerCase().includes('portuguese') || 
                                   s.language.toLowerCase().includes('portugu√™s') ||
                                   s.language.toLowerCase().includes('pt'))
                );
                
                // Se n√£o encontrar portugu√™s, procurar ingl√™s
                if (!selectedSubtitle) {
                    selectedSubtitle = data.subtitles.find(s => 
                        s.language && (s.language.toLowerCase().includes('english') || 
                                       s.language.toLowerCase().includes('en'))
                    );
                }
                
                // Se n√£o encontrar, usar a primeira dispon√≠vel
                if (!selectedSubtitle) {
                    selectedSubtitle = data.subtitles[0];
                }
                
                // Tentar obter o formato TXT primeiro, depois SRT
                let transcriptUrl = null;
                if (selectedSubtitle.formats && Array.isArray(selectedSubtitle.formats)) {
                    const txtFormat = selectedSubtitle.formats.find(f => f.format === 'txt');
                    const srtFormat = selectedSubtitle.formats.find(f => f.format === 'srt');
                    
                    transcriptUrl = txtFormat ? txtFormat.url : (srtFormat ? srtFormat.url : null);
                }
                
                if (transcriptUrl) {
                    console.log('[DownSub] Baixando transcri√ß√£o de:', transcriptUrl);
                    const transcriptResponse = await axios.get(transcriptUrl, {
                        timeout: 30000,
                        responseType: 'text'
                    });
                    
                    if (transcriptResponse.data) {
                        // Limpar o texto (remover timestamps se for SRT, etc)
                        let transcript = transcriptResponse.data;
                        
                        // Se for formato SRT, remover timestamps
                        if (transcript.includes('-->')) {
                            transcript = transcript
                                .replace(/\d+\n/g, '') // Remove n√∫meros de sequ√™ncia
                                .replace(/\d{2}:\d{2}:\d{2},\d{3} --> \d{2}:\d{2}:\d{2},\d{3}\n/g, '') // Remove timestamps
                                .replace(/\n{3,}/g, '\n\n') // Remove m√∫ltiplas linhas vazias
                                .trim();
                        }
                        
                        console.log('[DownSub] ‚úì Transcri√ß√£o obtida com sucesso!');
                        return transcript;
                    }
                }
            }
            
            throw new Error('Nenhuma legenda dispon√≠vel para este v√≠deo');
        } else {
            throw new Error('Resposta inv√°lida da API DownSub');
        }
    } catch (error) {
        if (error.response) {
            if (error.response.status === 401 || error.response.status === 403) {
                throw new Error('Chave de API DownSub inv√°lida ou expirada');
            } else if (error.response.status === 403) {
                throw new Error('Limite de cr√©ditos da API DownSub excedido');
            } else if (error.response.status === 404) {
                throw new Error('V√≠deo n√£o encontrado ou sem legendas dispon√≠veis');
            } else {
                throw new Error(`Erro da API DownSub: ${error.response.status} - ${error.response.data?.message || 'Erro desconhecido'}`);
            }
        } else if (error.request) {
            throw new Error('Erro de conex√£o com a API DownSub');
        } else {
            throw error;
        }
    }
}

// ================================================
// ROTAS DO SISTEMA DE TTS (TEXT-TO-SPEECH)
// ================================================

// GET /api/tts/voices - Lista vozes dispon√≠veis (Voz Premium)
app.get('/api/tts/voices', authenticateToken, async (req, res) => {
    try {
        const { provider = 'laozhang' } = req.query;
        
        console.log(`[TTS Voices] Requisi√ß√£o recebida - Provider: "${provider}"`);
        
        // Se provider for voice_premium ou genaipro, SEMPRE buscar vozes premium
        if (provider === 'voice_premium' || provider === 'genaipro') {
            console.log('[TTS Voices] Buscando vozes premium...');
            // Buscar API key do Voz Premium do usu√°rio ou admin
            const userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'genaipro']);
            
            let apiKey = null;
            if (userApiKey) {
                // Descriptografar a chave
                apiKey = decrypt(userApiKey.api_key);
                if (!apiKey) {
                    console.error('[La Casa Dark Core] Erro ao descriptografar chave do usu√°rio');
                }
            }
            
            // Se n√£o tem chave do usu√°rio ou falhou ao descriptografar, tentar usar API do admin
            if (!apiKey) {
                // Buscar especificamente a API Voz Premium do admin (n√£o a API padr√£o gen√©rica)
                const adminVoicePremiumApi = await db.get(`
                    SELECT * FROM api_providers 
                    WHERE (provider = 'genaipro' OR provider = 'voice_premium')
                    AND is_active = 1
                    LIMIT 1
                `);
                
                console.log('[La Casa Dark Core] Buscando API Voz Premium do admin:', adminVoicePremiumApi ? 'Encontrada' : 'N√£o encontrada');
                
                if (adminVoicePremiumApi && adminVoicePremiumApi.api_key) {
                    // Tentar descriptografar a chave do admin
                    // Se a chave cont√©m ':' provavelmente est√° criptografada
                    if (adminVoicePremiumApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminVoicePremiumApi.api_key);
                        } catch (decryptError) {
                            console.warn('[La Casa Dark Core] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                            // Se falhar, tentar usar diretamente (pode n√£o estar criptografada)
                            apiKey = adminVoicePremiumApi.api_key;
                        }
                    } else {
                        // Chave n√£o parece estar criptografada, usar diretamente
                        apiKey = adminVoicePremiumApi.api_key;
                    }
                    console.log('[La Casa Dark Core] Usando API Voz Premium do admin');
                }
            }
            
            if (!apiKey) {
                console.error('[La Casa Dark Core] Nenhuma chave de API Voz Premium encontrada (nem do usu√°rio nem do admin)');
                return res.status(400).json({ message: 'Chave de API Voz Premium n√£o configurada. Configure no painel admin ou nas suas configura√ß√µes.' });
            }
            
            console.log('[La Casa Dark Core] Buscando vozes com chave de API dispon√≠vel');
            
            // Buscar vozes de AMBOS os endpoints (Max e Labs) e indicar status
            // Base URL: https://genaipro.vn/api/v1
            try {
                let allVoices = [];
                let maxStatus = 'online'; // Status do servi√ßo Max
                let labsStatus = 'online'; // Status do servi√ßo Labs
                
                // ============================================
                // BUSCAR VOZES LABS (ElevenLabs) - Geralmente mais est√°veis
                // ============================================
                console.log('[La Casa Dark Core] Buscando vozes Labs...');
                
                // Primeiro, verificar se o servi√ßo de TTS Labs est√° dispon√≠vel
                try {
                    console.log('[La Casa Dark Core] Verificando status do servi√ßo Labs TTS...');
                    const labsTtsCheck = await axios.post('https://genaipro.vn/api/v1/labs/task', 
                        { input: 'test', voice_id: 'test' },
                        {
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            timeout: 10000,
                            validateStatus: (status) => true
                        }
                    );
                    
                    // Se retornar 503 ou HTML de manuten√ß√£o, marcar como em manuten√ß√£o
                    if (labsTtsCheck.status === 503) {
                        labsStatus = 'maintenance';
                        console.log('[La Casa Dark Core] ‚ö†Ô∏è Servi√ßo Labs TTS em manuten√ß√£o (503)');
                    } else if (typeof labsTtsCheck.data === 'string' && 
                              (labsTtsCheck.data.includes('Maintenance') || labsTtsCheck.data.includes('B·∫£o Tr√¨') || labsTtsCheck.data.includes('<!DOCTYPE'))) {
                        labsStatus = 'maintenance';
                        console.log('[La Casa Dark Core] ‚ö†Ô∏è Servi√ßo Labs TTS em manuten√ß√£o (HTML)');
                    } else {
                        console.log('[La Casa Dark Core] ‚úÖ Servi√ßo Labs TTS dispon√≠vel (status:', labsTtsCheck.status, ')');
                    }
                } catch (labsCheckError) {
                    console.log('[La Casa Dark Core] Erro ao verificar status Labs:', labsCheckError.message);
                }
                
                try {
                    // Buscar TODAS as vozes Labs (sem filtro de idioma restritivo)
                    const labsResponse = await axios.get('https://genaipro.vn/api/v1/labs/voices', {
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        params: {
                            page: 1,
                            page_size: 100
                            // Removido filtro de idioma para buscar todas as vozes
                        },
                        timeout: 15000,
                        validateStatus: (status) => true
                    });
                    
                    console.log('[La Casa Dark Core] Labs voices response status:', labsResponse.status);
                    if (labsResponse.data) {
                        console.log('[La Casa Dark Core] Labs voices data keys:', Object.keys(labsResponse.data));
                    }
                    
                    // Verificar se est√° em manuten√ß√£o
                    if (labsResponse.status === 503) {
                        const responseText = typeof labsResponse.data === 'string' ? labsResponse.data : '';
                        if (responseText.includes('Maintenance') || responseText.includes('B·∫£o Tr√¨')) {
                            labsStatus = 'maintenance';
                            console.log('[La Casa Dark Core] ‚ö†Ô∏è Servi√ßo Labs em manuten√ß√£o');
                        }
                    } else if (labsResponse.status === 200 && labsResponse.data) {
                        console.log('[La Casa Dark Core] Labs data sample:', JSON.stringify(labsResponse.data).substring(0, 500));
                        
                        // Tentar diferentes formatos de resposta
                        let voiceList = [];
                        if (labsResponse.data.voices) {
                            voiceList = labsResponse.data.voices;
                            console.log('[La Casa Dark Core] Labs usando campo "voices"');
                        } else if (labsResponse.data.voice_list) {
                            voiceList = labsResponse.data.voice_list;
                            console.log('[La Casa Dark Core] Labs usando campo "voice_list"');
                        } else if (labsResponse.data.data) {
                            voiceList = labsResponse.data.data;
                            console.log('[La Casa Dark Core] Labs usando campo "data"');
                        } else if (Array.isArray(labsResponse.data)) {
                            voiceList = labsResponse.data;
                            console.log('[La Casa Dark Core] Labs resposta √© array direto');
                        }
                        
                        if (Array.isArray(voiceList) && voiceList.length > 0) {
                            console.log(`[La Casa Dark Core] Labs: ${voiceList.length} vozes encontradas`);
                            
                            const labsVoices = voiceList.map(voice => {
                                let friendlyName = voice.name || 'Voz Labs';
                                
                                if (voice.labels) {
                                    const gender = voice.labels.gender || '';
                                    const description = voice.labels.description || '';
                                    
                                    if (gender) {
                                        const genderPt = gender === 'male' ? 'Masculina' : gender === 'female' ? 'Feminina' : '';
                                        if (genderPt) {
                                            friendlyName = `Voz ${genderPt}`;
                                            if (description) {
                                                friendlyName += ` - ${description}`;
                                            }
                                        }
                                    }
                                }
                                
                                return {
                                    id: voice.voice_id || voice.id || voice.name,
                                    name: voice.voice_id || voice.id || voice.name,
                                    label: `‚úÖ ${friendlyName}`, // Indicar que est√° online
                                    language: voice.labels?.accent || 'pt-BR',
                                    gender: voice.labels?.gender || null,
                                    description: voice.labels?.description || null,
                                    category: voice.category,
                                    original_name: voice.name,
                                    api_type: 'labs',
                                    status: 'online'
                                };
                            });
                            
                            allVoices.push(...labsVoices);
                        }
                    }
                } catch (labsError) {
                    console.log('[La Casa Dark Core] Erro ao buscar vozes Labs:', labsError.message);
                    labsStatus = 'error';
                }
                
                // ============================================
                // BUSCAR VOZES MAX - Melhor para portugu√™s
                // ============================================
                console.log('[La Casa Dark Core] Buscando vozes Max...');
                
                // Primeiro, verificar se o servi√ßo de TTS Max est√° dispon√≠vel
                try {
                    console.log('[La Casa Dark Core] Verificando status do servi√ßo Max TTS...');
                    const maxTtsCheck = await axios.post('https://genaipro.vn/api/v1/max/tasks', 
                        { text: 'test', voice_id: 'test' },
                        {
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            timeout: 10000,
                            validateStatus: (status) => true
                        }
                    );
                    
                    // Se retornar 503 ou HTML de manuten√ß√£o, marcar como em manuten√ß√£o
                    if (maxTtsCheck.status === 503) {
                        maxStatus = 'maintenance';
                        console.log('[La Casa Dark Core] ‚ö†Ô∏è Servi√ßo Max TTS em manuten√ß√£o (503)');
                    } else if (typeof maxTtsCheck.data === 'string' && 
                              (maxTtsCheck.data.includes('Maintenance') || maxTtsCheck.data.includes('B·∫£o Tr√¨') || maxTtsCheck.data.includes('<!DOCTYPE'))) {
                        maxStatus = 'maintenance';
                        console.log('[La Casa Dark Core] ‚ö†Ô∏è Servi√ßo Max TTS em manuten√ß√£o (HTML)');
                    } else {
                        console.log('[La Casa Dark Core] ‚úÖ Servi√ßo Max TTS dispon√≠vel');
                    }
                } catch (maxCheckError) {
                    console.log('[La Casa Dark Core] Erro ao verificar status Max:', maxCheckError.message);
                }
                
                try {
                    const maxResponse = await axios.get('https://genaipro.vn/api/v1/max/voices', {
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        params: {
                            page: 1,
                            page_size: 100,
                            language: 'Portuguese'
                        },
                        timeout: 15000,
                        validateStatus: (status) => true
                    });
                    
                    // Verificar se est√° em manuten√ß√£o
                    if (maxResponse.status === 503) {
                        const responseText = typeof maxResponse.data === 'string' ? maxResponse.data : '';
                        if (responseText.includes('Maintenance') || responseText.includes('B·∫£o Tr√¨')) {
                            maxStatus = 'maintenance';
                            console.log('[La Casa Dark Core] ‚ö†Ô∏è Servi√ßo Max em manuten√ß√£o');
                        }
                    } else if (maxResponse.status === 200 && maxResponse.data) {
                        const voiceList = maxResponse.data.voice_list || maxResponse.data.voices || maxResponse.data.data || [];
                        
                        if (Array.isArray(voiceList) && voiceList.length > 0) {
                            console.log(`[La Casa Dark Core] Max: ${voiceList.length} vozes encontradas`);
                            
                            const maxVoices = voiceList.map(voice => {
                                let friendlyName = voice.voice_name || voice.name || 'Voz Max';
                                
                                const tagList = voice.tag_list || voice.tags || [];
                                const gender = tagList.find(tag => tag === 'Male' || tag === 'Female') || '';
                                const age = tagList.find(tag => ['Youth', 'Young Adult', 'Adult', 'Middle Aged', 'Senior'].includes(tag)) || '';
                                
                                if (gender && age) {
                                    const genderPt = gender === 'Male' ? 'Masculina' : 'Feminina';
                                    const agePt = age === 'Youth' ? 'Jovem' : 
                                                 age === 'Young Adult' ? 'Jovem Adulta' :
                                                 age === 'Adult' ? 'Adulto' :
                                                 age === 'Middle Aged' ? 'Meia Idade' : 'S√™nior';
                                    friendlyName = `Voz ${genderPt} ${agePt}`;
                                } else if (gender) {
                                    const genderPt = gender === 'Male' ? 'Masculina' : 'Feminina';
                                    friendlyName = `Voz ${genderPt}`;
                                }
                                
                                // Indicador de status no label
                                const statusIndicator = maxStatus === 'maintenance' ? 'üîß ' : '‚úÖ ';
                                const statusSuffix = maxStatus === 'maintenance' ? ' (Manuten√ß√£o)' : '';
                                
                                return {
                                    id: voice.voice_id || voice.id || voice.voice_name || voice.name,
                                    name: voice.voice_id || voice.id || voice.voice_name || voice.name,
                                    label: `${statusIndicator}${friendlyName}${statusSuffix}`,
                                    language: 'Portuguese',
                                    gender: gender || null,
                                    description: voice.description || null,
                                    tags: tagList,
                                    original_name: voice.voice_name || voice.name,
                                    api_type: 'max',
                                    status: maxStatus
                                };
                            });
                            
                            allVoices.push(...maxVoices);
                        }
                    }
                } catch (maxError) {
                    console.log('[La Casa Dark Core] Erro ao buscar vozes Max:', maxError.message);
                    maxStatus = 'error';
                }
                
                // Ordenar vozes: online primeiro, depois manuten√ß√£o
                allVoices.sort((a, b) => {
                    if (a.status === 'online' && b.status !== 'online') return -1;
                    if (a.status !== 'online' && b.status === 'online') return 1;
                    return 0;
                });
                
                if (allVoices.length > 0) {
                    const onlineCount = allVoices.filter(v => v.status === 'online').length;
                    const maintenanceCount = allVoices.filter(v => v.status === 'maintenance').length;
                    
                    console.log(`[La Casa Dark Core] ‚úÖ Total: ${allVoices.length} vozes (${onlineCount} online, ${maintenanceCount} em manuten√ß√£o)`);
                    
                    return res.json({ 
                        data: allVoices,
                        provider: 'voice_premium',
                        message: `${allVoices.length} vozes dispon√≠veis (${onlineCount} online${maintenanceCount > 0 ? `, ${maintenanceCount} em manuten√ß√£o` : ''})`,
                        status: {
                            labs: labsStatus,
                            max: maxStatus
                        }
                    });
                } else {
                    console.warn('[La Casa Dark Core] ‚ö†Ô∏è Nenhuma voz encontrada');
                    return res.status(404).json({ 
                        message: 'Nenhuma voz encontrada. Verifique se sua chave de API tem acesso √†s vozes premium.',
                        data: [],
                        status: {
                            labs: labsStatus,
                            max: maxStatus
                        }
                    });
                }
            } catch (apiError) {
                console.error('[La Casa Dark Core] Erro ao buscar vozes:', apiError.message);
                if (apiError.response) {
                    console.error('[La Casa Dark Core] Status:', apiError.response.status);
                    console.error('[La Casa Dark Core] Data:', JSON.stringify(apiError.response.data).substring(0, 500));
                    
                    if (apiError.response.status === 401 || apiError.response.status === 403) {
                        return res.status(401).json({ 
                            message: 'Chave de API inv√°lida ou expirada. Verifique suas configura√ß√µes.',
                            data: []
                        });
                    }
                }
                return res.status(500).json({ 
                    message: `Erro ao buscar vozes: ${apiError.message}`,
                    data: []
                });
            }
        }
        
        // Verificar prefer√™ncia do usu√°rio
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // Se provider for laozhang ou se useCredits estiver marcado, retornar vozes DarkVoz
        if (provider === 'laozhang' || useCredits) {
            console.log('[TTS Voices] Retornando vozes DarkVoz');
            
            // Verificar se tem chave de API configurada
            const laozhangKey = await getLaozhangApiKey();
            if (!laozhangKey) {
                return res.status(400).json({ 
                    message: 'Chave de API DarkVoz n√£o configurada. Configure no painel admin.' 
                });
            }
            
            // Retornar todas as vozes dispon√≠veis do DarkVoz
            const laozhangVoices = [
                {
                    id: 'alloy',
                    name: 'alloy',
                    voice_id: 'alloy',
                    label: 'Alloy - Neutra, clara e natural',
                    description: 'Voz neutra, clara e natural',
                    gender: 'neutral',
                    language: 'pt-BR'
                },
                {
                    id: 'echo',
                    name: 'echo',
                    voice_id: 'echo',
                    label: 'Echo - Masculina, firme e forte',
                    description: 'Voz masculina, firme e forte',
                    gender: 'male',
                    language: 'pt-BR'
                },
                {
                    id: 'fable',
                    name: 'fable',
                    voice_id: 'fable',
                    label: 'Fable - Sotaque brit√¢nico, elegante',
                    description: 'Voz com sotaque brit√¢nico, elegante',
                    gender: 'neutral',
                    language: 'en-GB'
                },
                {
                    id: 'onyx',
                    name: 'onyx',
                    voice_id: 'onyx',
                    label: 'Onyx - Masculina profunda, not√≠cias/transmiss√£o',
                    description: 'Voz masculina profunda, ideal para not√≠cias e transmiss√£o',
                    gender: 'male',
                    language: 'pt-BR'
                },
                {
                    id: 'nova',
                    name: 'nova',
                    voice_id: 'nova',
                    label: 'Nova - Feminina, calorosa e amig√°vel',
                    description: 'Voz feminina, calorosa e amig√°vel',
                    gender: 'female',
                    language: 'pt-BR'
                },
                {
                    id: 'shimmer',
                    name: 'shimmer',
                    voice_id: 'shimmer',
                    label: 'Shimmer - Feminina suave, narra√ß√£o',
                    description: 'Voz feminina suave, ideal para narra√ß√£o',
                    gender: 'female',
                    language: 'pt-BR'
                }
            ];
            
            return res.status(200).json({ 
                data: laozhangVoices,
                provider: 'darkvoz',
                message: `${laozhangVoices.length} vozes dispon√≠veis`
            });
        }
        
        // Chave configurada no painel admin (sempre priorizar se existir)
        const adminVoiceApiKey = await getAdminVoiceApiKey();
        if (provider === 'gemini' && adminVoiceApiKey && adminVoiceApiKey.trim().length >= 10) {
            apiKey = adminVoiceApiKey.trim();
            console.log('[TTS Generate] ‚úÖ Usando chave de voz configurada no painel admin (Google Cloud/Gemini)');
        }
        
        if (provider === 'gemini') {
            // Vozes Gemini (hardcoded conforme voices.js)
            const geminiVoices = [
                { name: "Zephyr", label: "Brisa - Voz Brilhante", lang: "pt-BR" },
                { name: "Puck", label: "Vibe - Voz Animada", lang: "pt-BR" },
                { name: "Charon", label: "Dorio - Voz Informativa", lang: "pt-BR" },
                { name: "Kore", label: "Livia - Voz Firme", lang: "pt-BR" },
                { name: "Fenrir", label: "Rafael - Voz Excitada", lang: "pt-BR" },
                { name: "Leda", label: "Clara - Voz Juvenil", lang: "pt-BR" },
                { name: "Orus", label: "Icaro - Voz Firme", lang: "pt-BR" },
                { name: "Aoede", label: "Marina - Voz Arejada", lang: "pt-BR" },
                { name: "Callirrhoe", label: "Nina - Voz Descontraida", lang: "pt-BR" },
                { name: "Autonoe", label: "Bia - Voz Brilhante", lang: "pt-BR" },
                { name: "Enceladus", label: "Dandara - Voz Sussurrada", lang: "pt-BR" },
                { name: "Iapetus", label: "Vitor - Voz Clara", lang: "pt-BR" },
                { name: "Umbriel", label: "Otavio - Voz Descontraida", lang: "pt-BR" },
                { name: "Algieba", label: "Joao - Voz Suave", lang: "pt-BR" },
                { name: "Despina", label: "Luna - Voz Suave", lang: "pt-BR" },
                { name: "Erinome", label: "Paula - Voz Clara", lang: "pt-BR" },
                { name: "Algenib", label: "Gustavo - Voz Grave", lang: "pt-BR" },
                { name: "Rasalgethi", label: "Henrique - Voz Informativa", lang: "pt-BR" },
                { name: "Laomedeia", label: "Taina - Voz Animada", lang: "pt-BR" },
                { name: "Achernar", label: "Noa - Voz Suave", lang: "pt-BR" },
                { name: "Alnilam", label: "Edu - Voz Firme", lang: "pt-BR" },
                { name: "Schedar", label: "Rafa - Voz Constante", lang: "pt-BR" },
                { name: "Gacrux", label: "Sergio - Voz Madura", lang: "pt-BR" },
                { name: "Pulcherrima", label: "Helena - Voz Projetada", lang: "pt-BR" },
                { name: "Achird", label: "Mia - Voz Amigavel", lang: "pt-BR" },
                { name: "Zubenelgenubi", label: "Teo - Voz Casual", lang: "pt-BR" },
                { name: "Vindemiatrix", label: "Erica - Voz Gentil", lang: "pt-BR" },
                { name: "Sadachbia", label: "Duda - Voz Vivaz", lang: "pt-BR" },
                { name: "Sadaltager", label: "Marcelo - Voz Conhecedora", lang: "pt-BR" },
                { name: "Sulafat", label: "Isis - Voz Acolhedora", lang: "pt-BR" }
            ];
            res.json({ data: geminiVoices });
        } else if (provider === 'laozhang') {
            const laozhangVoices = [
                { name: 'alloy', label: 'Alloy - Neutro e claro', lang: 'pt-BR' },
                { name: 'echo', label: 'Echo - Masculino forte', lang: 'pt-BR' },
                { name: 'fable', label: 'Fable - Ingl√™s elegante', lang: 'en-US' },
                { name: 'onyx', label: 'Onyx - Grave jornal√≠stico', lang: 'pt-BR' },
                { name: 'nova', label: 'Nova - Feminino acolhedor', lang: 'pt-BR' },
                { name: 'shimmer', label: 'Shimmer - Feminino suave', lang: 'pt-BR' }
            ];
            res.json({ data: laozhangVoices });
        } else {
            res.json({ data: [] });
        }
    } catch (error) {
        console.error('Erro ao listar vozes:', error);
        res.status(500).json({ message: 'Erro ao listar vozes' });
    }
});

// POST /api/tts/preview - Gera preview de voz
app.post('/api/tts/preview', authenticateToken, async (req, res) => {
    const { voice, model, provider = 'laozhang' } = req.body || {};
    const previewVoice = typeof voice === 'string' && voice.trim() ? voice.trim() : FALLBACK_TTS_VOICE;
    const previewText = DEFAULT_TTS_SAMPLE_TEXT; // Remover prefixo "Narrador:"
    const validatedModel = validateTtsModel(model);
    
    // Declarar actualProvider fora do try para estar dispon√≠vel no catch
    let actualProvider = provider;

    try {
        // Verificar se tem API pr√≥pria ou usar API do admin (com cr√©ditos)
        let apiKey = null;
        let useAdminApi = false;
        let adminApi = null;
        
        // Verificar prefer√™ncia do usu√°rio
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // IMPORTANTE: Se o provider √© voice_premium/genaipro, SEMPRE usar a API GenAIPro, n√£o laozhang
        // A l√≥gica useCredits s√≥ se aplica a outros providers
        
        // Se useCredits estiver marcado E o provider N√ÉO √© voice_premium, usar laozhang.ai
        if (useCredits && provider !== 'voice_premium' && provider !== 'genaipro') {
            console.log(`[TTS Preview] useCredits marcado (provider: ${provider}), usando DarkVoz`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Chave do DarkVoz n√£o configurada. Configure no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            actualProvider = 'laozhang';
            console.log('[TTS Preview] ‚úÖ Usando API DarkVoz (useCredits marcado)');
        } else if (provider === 'laozhang') {
            console.log(`[TTS Preview] Provider: laozhang, Voice: ${previewVoice}`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Configure a chave do DarkVoz no painel admin para usar este provedor.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            actualProvider = 'laozhang';
            console.log('[TTS Preview] ‚úÖ Usando API DarkVoz (Laozhang.ai) do painel admin');
        } else if (provider === 'gemini') {
            // Chave configurada no painel admin (sempre priorizar se existir)
            const adminVoiceApiKey = await getAdminVoiceApiKey();
            if (adminVoiceApiKey && adminVoiceApiKey.trim().length >= 10) {
                apiKey = adminVoiceApiKey.trim();
                console.log('[TTS Preview] ‚úÖ Usando chave de voz configurada no painel admin (Google Cloud/Gemini)');
            }
            console.log(`[TTS Preview] Provider: gemini, Voice: ${previewVoice}`);
            
            // PRIORIDADE 2: Se n√£o houver chave do admin, buscar API do Gemini do usu√°rio
            if (!apiKey && !useCredits) {
                let userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'gemini']);
                console.log('[TTS Preview] DEBUG - Gemini API do usu√°rio encontrada:', !!userApiKey);
                
                if (userApiKey && userApiKey.api_key) {
                    // Descriptografar a chave do Gemini
                    if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(userApiKey.api_key);
                            console.log('[TTS Preview] Chave Gemini descriptografada (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                        } catch (decryptError) {
                            console.warn('[TTS Preview] Erro ao descriptografar chave Gemini, tentando usar diretamente:', decryptError.message);
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        apiKey = userApiKey.api_key;
                        console.log('[TTS Preview] Chave Gemini usada diretamente (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                    }
                    
                    // Validar se a chave n√£o est√° vazia
                    if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                        console.warn('[TTS Preview] ‚ö†Ô∏è Chave Gemini est√° vazia, tentando API do admin');
                        apiKey = null;
                    } else {
                        console.log('[TTS Preview] ‚úÖ Usando API Gemini do usu√°rio');
                    }
                }
            }
            
            // Se n√£o conseguiu usar API pr√≥pria, tentar admin como fallback
            if (!apiKey) {
                console.log('[TTS Preview] Tentando usar API do admin como fallback para Gemini...');
                adminApi = await getDefaultAdminApi();
                console.log('[TTS Preview] Admin API encontrada:', adminApi ? `${adminApi.provider} - ${adminApi.name}` : 'Nenhuma');
                if (adminApi && adminApi.provider === 'gemini' && adminApi.api_key) {
                    // Descriptografar se necess√°rio
                    if (adminApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminApi.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Preview] Erro ao descriptografar chave Gemini do admin, tentando usar diretamente:', decryptError.message);
                            apiKey = adminApi.api_key;
                        }
                    } else {
                        apiKey = adminApi.api_key;
                    }
                    
                    if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                        console.error('[TTS Preview] ‚ùå Chave Gemini do admin est√° vazia');
                        apiKey = null;
                    } else {
                        useAdminApi = true;
                        console.log('[TTS Preview] ‚úÖ Usando API Gemini do admin com cr√©ditos');
                    }
                } else {
                    console.warn('[TTS Preview] ‚ö†Ô∏è Admin API n√£o encontrada ou n√£o √© Gemini');
                }
                
                if (!apiKey) {
                    console.error('[TTS Preview] ‚ùå Nenhuma API Gemini dispon√≠vel');
                    return res.status(400).json({ message: 'Configure uma chave de voz (Google Cloud/Gemini) no painel admin ou use cr√©ditos.' });
                }
            }
        } else if (provider === 'voice_premium' || provider === 'genaipro') {
            console.log(`[TTS Preview] Provider: ${provider}, Voice: ${previewVoice}`);
            
            // Buscar API do usu√°rio - tentar tanto 'genaipro' quanto 'voice_premium'
            let userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'genaipro']);
            if (!userApiKey || !userApiKey.api_key) {
                // Tentar buscar como 'voice_premium' se n√£o encontrou como 'genaipro'
                userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'voice_premium']);
                if (userApiKey) {
                    console.log('[TTS Preview] API encontrada como voice_premium');
                }
            } else {
                console.log('[TTS Preview] API encontrada como genaipro');
            }
            
            console.log('[TTS Preview] DEBUG - userApiKey encontrada:', !!userApiKey);
            console.log('[TTS Preview] DEBUG - userApiKey.api_key existe:', !!(userApiKey && userApiKey.api_key));
            if (userApiKey && userApiKey.api_key) {
                console.log('[TTS Preview] DEBUG - userApiKey.api_key tamanho:', userApiKey.api_key.length);
                console.log('[TTS Preview] DEBUG - userApiKey.api_key preview:', userApiKey.api_key.substring(0, 20) + '...');
            }
            
            if (useCredits) {
                // Usu√°rio prefere usar cr√©ditos - buscar especificamente a API Voz Premium do admin
                // N√ÉO usar getDefaultAdminApi() pois pode retornar outra API
                adminApi = await db.get(`
                    SELECT * FROM api_providers 
                    WHERE (provider = 'genaipro' OR provider = 'voice_premium')
                    AND is_active = 1
                    LIMIT 1
                `);
                console.log('[TTS Preview] Buscando API Voz Premium do admin:', adminApi ? 'Encontrada' : 'N√£o encontrada');
                
                if (adminApi && adminApi.api_key) {
                    // Tentar descriptografar a chave do admin
                    if (adminApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminApi.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Preview] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                            apiKey = adminApi.api_key;
                        }
                    } else {
                        apiKey = adminApi.api_key;
                    }
                    useAdminApi = true;
                    actualProvider = 'voice_premium'; // Garantir que o provider seja correto
                    console.log('[TTS Preview] ‚úÖ Usando API Voz Premium do admin');
                } else {
                    // Fallback: usar API pr√≥pria se dispon√≠vel
                    if (userApiKey && userApiKey.api_key) {
                        console.log('[TTS Preview] Fallback: tentando usar API pr√≥pria do usu√°rio...');
                        // Descriptografar a chave do usu√°rio
                        if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                            try {
                                apiKey = decrypt(userApiKey.api_key);
                                console.log('[TTS Preview] Chave descriptografada (tamanho:', apiKey ? apiKey.length : 0, ')');
                            } catch (decryptError) {
                                console.warn('[TTS Preview] Erro ao descriptografar chave do usu√°rio, tentando usar diretamente:', decryptError.message);
                                apiKey = userApiKey.api_key;
                            }
                        } else {
                            apiKey = userApiKey.api_key;
                            console.log('[TTS Preview] Chave usada diretamente (n√£o criptografada, tamanho:', apiKey ? apiKey.length : 0, ')');
                        }
                        
                        // Validar se a chave n√£o est√° vazia
                        if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                            console.error('[TTS Preview] Chave do usu√°rio est√° vazia ou muito curta ap√≥s descriptografar');
                            return res.status(400).json({ message: 'A chave da API Voz Premium configurada est√° vazia ou inv√°lida. Verifique suas configura√ß√µes.' });
                        }
                        
                        actualProvider = 'voice_premium'; // Garantir provider correto
                        console.log('[TTS Preview] ‚úÖ Fallback: usando API pr√≥pria (admin API n√£o dispon√≠vel)');
                    } else {
                        console.error('[TTS Preview] ‚ùå API pr√≥pria n√£o encontrada e admin API Voz Premium n√£o dispon√≠vel');
                        return res.status(400).json({ message: 'Configure uma chave da API Voz Premium no painel admin ou nas suas configura√ß√µes.' });
                    }
                }
            } else {
                // Usu√°rio prefere usar API pr√≥pria quando dispon√≠vel
                console.log('[TTS Preview] Verificando API pr√≥pria do usu√°rio (prefer√™ncia: n√£o usar cr√©ditos)');
                console.log('[TTS Preview] - userApiKey encontrada:', !!userApiKey);
                console.log('[TTS Preview] - userApiKey.api_key existe:', !!(userApiKey && userApiKey.api_key));
                
                if (userApiKey && userApiKey.api_key) {
                    // Descriptografar a chave do usu√°rio
                    if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(userApiKey.api_key);
                            console.log('[TTS Preview] Chave descriptografada com sucesso (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                        } catch (decryptError) {
                            console.warn('[TTS Preview] Erro ao descriptografar chave do usu√°rio, tentando usar diretamente:', decryptError.message);
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        apiKey = userApiKey.api_key;
                        console.log('[TTS Preview] Chave usada diretamente (n√£o criptografada, tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                    }
                    
                    // Validar se a chave n√£o est√° vazia ap√≥s descriptografar
                    if (!apiKey || apiKey.trim() === '') {
                        console.warn('[TTS Preview] ‚ö†Ô∏è Chave do usu√°rio est√° vazia ap√≥s descriptografar, tentando API do admin');
                        apiKey = null; // Resetar para tentar admin
                    } else {
                        console.log('[TTS Preview] ‚úÖ API key do usu√°rio encontrada e v√°lida (tamanho:', apiKey.length, 'caracteres)');
                    }
                } else {
                    console.log('[TTS Preview] ‚ö†Ô∏è API pr√≥pria do usu√°rio n√£o encontrada ou vazia');
                }
                
                // Se n√£o conseguiu usar API pr√≥pria, tentar admin como fallback
                if (!apiKey) {
                    console.log('[TTS Preview] Tentando usar API Voz Premium do admin como fallback...');
                    // Buscar especificamente a API Voz Premium do admin
                    adminApi = await db.get(`
                        SELECT * FROM api_providers 
                        WHERE (provider = 'genaipro' OR provider = 'voice_premium')
                        AND is_active = 1
                        LIMIT 1
                    `);
                    console.log('[TTS Preview] Admin API Voz Premium encontrada:', adminApi ? 'Sim' : 'N√£o');
                    
                    if (adminApi && adminApi.api_key) {
                        // Tentar descriptografar a chave do admin
                        if (adminApi.api_key.includes(':')) {
                            try {
                                apiKey = decrypt(adminApi.api_key);
                                console.log('[TTS Preview] Chave do admin descriptografada (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                            } catch (decryptError) {
                                console.warn('[TTS Preview] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                                apiKey = adminApi.api_key;
                            }
                        } else {
                            apiKey = adminApi.api_key;
                            console.log('[TTS Preview] Chave do admin usada diretamente (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                        }
                        
                        // Validar se a chave n√£o est√° vazia
                        if (!apiKey || apiKey.trim() === '') {
                            console.error('[TTS Preview] ‚ùå Chave do admin est√° vazia ap√≥s descriptografar');
                            apiKey = null;
                        } else {
                            useAdminApi = true;
                            actualProvider = 'voice_premium'; // Garantir provider correto
                            console.log('[TTS Preview] ‚úÖ Usando API Voz Premium do admin (fallback)');
                        }
                    } else {
                        console.warn('[TTS Preview] ‚ö†Ô∏è Admin API Voz Premium n√£o encontrada');
                    }
                    
                    if (!apiKey) {
                        console.error('[TTS Preview] ‚ùå Nenhuma API Voz Premium dispon√≠vel');
                        return res.status(400).json({ message: 'Configure uma chave da API Voz Premium no painel admin ou nas suas configura√ß√µes.' });
                    }
                } else {
                    actualProvider = 'voice_premium'; // Garantir provider correto quando usando API do usu√°rio
                }
            }
        } else if (provider === 'openai') {
            // Verificar prefer√™ncia do usu√°rio
            const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
            const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
            
            const userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'openai']);
            const adminOpenAiKey = await getAdminOpenAiVoiceApiKey();
            
            if (adminOpenAiKey) {
                apiKey = adminOpenAiKey;
                console.log('[TTS Preview] ‚úÖ Usando chave de voz OpenAI do painel admin');
            }
            
            if (!apiKey && useCredits) {
                // Usu√°rio prefere usar cr√©ditos mesmo tendo API pr√≥pria
                adminApi = await getDefaultAdminApi();
                if (adminApi && adminApi.provider === 'openai') {
                    apiKey = adminApi.api_key;
                    useAdminApi = true;
                } else {
                    // Fallback: usar API pr√≥pria se dispon√≠vel
                    if (userApiKey) {
                        apiKey = userApiKey.api_key;
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API OpenAI ou use cr√©ditos.' });
                    }
                }
            }
        } else if (provider === 'laozhang') {
            console.log(`[TTS Preview] Provider: laozhang, Voice: ${previewVoice}`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Configure a chave do provedor externo no painel admin para usar este provedor.' });
            }
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (!laozhangProviderId) {
                return res.status(400).json({ message: 'Provedor externo n√£o est√° ativo no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            adminApi = { id: laozhangProviderId, provider: 'laozhang' };
            actualProvider = 'laozhang';
        }
        
        // Valida√ß√£o final: verificar se apiKey n√£o est√° vazia e tem formato v√°lido
        if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
            console.error('[TTS Preview] ‚ùå API Key est√° vazia, inv√°lida ou muito curta ap√≥s todo o processamento');
            console.error('[TTS Preview] - Provider:', provider);
            console.error('[TTS Preview] - User ID:', req.user.id);
            const userPrefsDebug = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
            console.error('[TTS Preview] - useCredits:', userPrefsDebug ? (userPrefsDebug.use_credits_instead_of_own_api === 1) : 'N/A');
            console.error('[TTS Preview] - apiKey length:', apiKey ? apiKey.length : 0);
            console.error('[TTS Preview] - apiKey preview:', apiKey ? apiKey.substring(0, 10) + '...' : 'null');
            
            // Verificar se h√° API do admin dispon√≠vel como √∫ltima tentativa
            if (provider === 'voice_premium' || provider === 'genaipro' || provider === 'gemini') {
                const lastChanceAdminApi = await getDefaultAdminApi();
                // Para Gemini, buscar API do Gemini; para outros, buscar genaipro/voice_premium
                if (provider === 'gemini') {
                    if (lastChanceAdminApi && lastChanceAdminApi.provider === 'gemini' && lastChanceAdminApi.api_key) {
                        console.log('[TTS Preview] üÜò √öltima tentativa: usando API Gemini do admin');
                        try {
                            if (lastChanceAdminApi.api_key.includes(':')) {
                                apiKey = decrypt(lastChanceAdminApi.api_key);
                            } else {
                                apiKey = lastChanceAdminApi.api_key;
                            }
                            if (apiKey && apiKey.trim() !== '' && apiKey.trim().length >= 10) {
                                useAdminApi = true;
                                console.log('[TTS Preview] ‚úÖ API Gemini do admin funcionou como √∫ltima tentativa');
                            } else {
                                apiKey = null;
                            }
                        } catch (err) {
                            console.error('[TTS Preview] Erro na √∫ltima tentativa com admin Gemini API:', err.message);
                            apiKey = null;
                        }
                    }
                } else if (lastChanceAdminApi && (lastChanceAdminApi.provider === 'genaipro' || lastChanceAdminApi.provider === 'voice_premium') && lastChanceAdminApi.api_key) {
                    console.log('[TTS Preview] üÜò √öltima tentativa: usando API do admin');
                    try {
                        if (lastChanceAdminApi.api_key.includes(':')) {
                            apiKey = decrypt(lastChanceAdminApi.api_key);
                        } else {
                            apiKey = lastChanceAdminApi.api_key;
                        }
                        if (apiKey && apiKey.trim() !== '' && apiKey.trim().length >= 10) {
                            useAdminApi = true;
                            console.log('[TTS Preview] ‚úÖ API do admin funcionou como √∫ltima tentativa');
                        } else {
                            apiKey = null;
                        }
                    } catch (err) {
                        console.error('[TTS Preview] Erro na √∫ltima tentativa com admin API:', err.message);
                        apiKey = null;
                    }
                }
            }
            
            if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                return res.status(400).json({ 
                    message: 'Nenhuma API configurada ou a chave est√° vazia/inv√°lida. Verifique suas configura√ß√µes de API. Se sua chave foi marcada como inv√°lida na valida√ß√£o, corrija-a ou use cr√©ditos.' 
                });
            }
        }
        
        console.log('[TTS Preview] ‚úÖ API Key validada com sucesso (tamanho:', apiKey.length, 'caracteres, usando admin:', useAdminApi, ')');

        const speakerVoiceMap = new Map([['Narrador', previewVoice]]);
        console.log(`[TTS Preview] Gerando √°udio com provider: ${provider}, voice: ${previewVoice}, text length: ${previewText.length}`);
        
        // Garantir que o provider seja correto para a fun√ß√£o generateTtsAudio
        // Se for Gemini, usar genaipro mas com a API do Gemini
        actualProvider = provider;
        if (provider === 'voice_premium' || provider === 'genaipro') {
            actualProvider = 'genaipro';
        } else if (provider === 'gemini') {
            // Gemini TTS: usar 'gemini' para usar a API oficial do Google Gemini
            actualProvider = 'gemini';
            console.log('[TTS Preview] Usando Gemini TTS oficial com API do Google Gemini');
        }
        
        // Obter velocidade do body se for DarkVoz
        const speed = provider === 'laozhang' ? (parseFloat(req.body.speed) || 1.0) : 1.0;
        
        const { audioBase64 } = await generateTtsAudio({
            apiKey: apiKey,
            model: validatedModel,
            textInput: previewText,
            speakerVoiceMap: speakerVoiceMap,
            provider: actualProvider,
            speed: speed
        });
        
        console.log('[TTS Preview] √Åudio gerado com sucesso');
        
        // Se usou API do admin, debitar cr√©ditos
        if (useAdminApi && adminApi) {
            try {
                // Estimar tokens (aproximadamente 1 token por caractere para TTS)
                const estimatedTokens = Math.ceil(previewText.length / 4);
                
                const creditResult = await checkAndDebitCredits(
                    req.user.id,
                    adminApi.id,
                    estimatedTokens,
                    'api_tts_preview',
                    JSON.stringify({ model: validatedModel, provider: provider, endpoint: '/api/tts/preview' })
                );
                
                console.log(`üí≥ [CR√âDITOS] ${creditResult.creditsUsed.toFixed(2)} cr√©ditos debitados. Saldo restante: ${creditResult.newBalance.toFixed(2)}`);
            } catch (creditError) {
                console.error('‚ùå [CR√âDITOS] Erro ao debitar cr√©ditos:', creditError);
            }
        }

        res.json({
            message: 'Pr√©via gerada.',
            audio: {
                mimeType: 'audio/mpeg',
                base64: audioBase64,
            }
        });
    } catch (err) {
        console.error('Erro ao gerar pr√©via de voz:', err);
        if (err.response) {
            console.error('Status:', err.response.status);
            console.error('Data:', err.response.data);
        }
        
        // Mensagem de erro mais amig√°vel
        let errorMessage = err.message || 'Erro desconhecido ao gerar pr√©via de voz';
        const status = err.response?.status;
        const responseData = err.response?.data;
        
        // Usar actualProvider se dispon√≠vel, sen√£o usar provider do body
        const currentProvider = (typeof actualProvider !== 'undefined' ? actualProvider : provider) || 'unknown';
        const isVoicePremiumProvider = currentProvider === 'genaipro' || currentProvider === 'voice_premium';
        const isGeminiProvider = currentProvider === 'gemini';
        const isLaozhangProvider = currentProvider === 'laozhang';
        
        const responseString = typeof responseData === 'string' ? responseData : '';
        const maintenanceHints = ['manuten√ß√£o', 'ƒêang B·∫£o Tr√¨', 'maintenance'];
        const messageIndicatesMaintenance = maintenanceHints.some(hint => (err.message || '').toLowerCase().includes(hint) || responseString.toLowerCase().includes(hint));
        
        if (isVoicePremiumProvider && status === 503 && messageIndicatesMaintenance) {
            errorMessage = 'A API Voz Premium informou que est√° em manuten√ß√£o. Por favor, tente novamente em alguns minutos.';
        } else if (messageIndicatesMaintenance) {
            errorMessage = err.message;
        } else if (isGeminiProvider && status === 401) {
            errorMessage = 'Chave do Google Cloud (Gemini) inv√°lida ou expirada. Verifique a chave salva no painel admin.';
        } else if (isGeminiProvider && status === 403) {
            errorMessage = 'Acesso negado pela API do Google Cloud. Verifique se a chave tem permiss√£o para usar o Text-to-Speech.';
        } else if (isLaozhangProvider && (status === 401 || status === 403)) {
            errorMessage = 'Chave do DarkVoz inv√°lida ou sem permiss√£o para TTS. Atualize a chave no painel admin.';
        } else if (isLaozhangProvider && status === 429) {
            errorMessage = 'Limite de requisi√ß√µes atingido no DarkVoz. Aguarde alguns instantes e tente novamente.';
        } else if (isLaozhangProvider && status === 503) {
            errorMessage = 'O DarkVoz est√° temporariamente indispon√≠vel. Tente novamente em alguns minutos.';
        } else if (!isGeminiProvider && !isLaozhangProvider && status === 401) {
            errorMessage = 'Chave de API inv√°lida ou expirada. Verifique suas configura√ß√µes no painel admin.';
        } else if (!isGeminiProvider && !isLaozhangProvider && status === 403) {
            errorMessage = 'Acesso negado. Verifique se sua chave de API tem permiss√µes para gerar √°udio.';
        } else if (err.message && err.message.toLowerCase().includes('timeout')) {
            errorMessage = 'Timeout ao conectar com a API. Tente novamente.';
        }
        
        res.status(err.response?.status || 500).json({ 
            message: errorMessage,
            details: err.response?.data?.message || err.message
        });
    }
});

// POST /api/tts/generate-from-script - Gera √°udio completo a partir de roteiro
app.post('/api/tts/generate-from-script', authenticateToken, async (req, res) => {
    const { ttsModel, script, voice, styleInstructions, provider = 'laozhang', speed = 1.0 } = req.body;

    // Validar par√¢metros obrigat√≥rios
    if (!script || !voice) {
        return res.status(400).json({ message: 'Roteiro e voz s√£o obrigat√≥rios.' });
    }
    
    // Se n√£o tiver modelo, usar padr√£o baseado no provider
    let finalTtsModel = ttsModel;
    if (!finalTtsModel || !finalTtsModel.trim()) {
        if (provider === 'laozhang') {
            finalTtsModel = 'tts-1'; // Modelo padr√£o para laozhang
        } else if (provider === 'openai') {
            finalTtsModel = 'tts-1-hd';
        } else if (provider === 'gemini') {
            finalTtsModel = 'gemini-2.5-pro-preview-tts';
        } else {
            finalTtsModel = 'voz-premium'; // Nome gen√©rico, n√£o expor fornecedor
        }
    }
    
    // Validar modelo
    finalTtsModel = validateTtsModel(finalTtsModel);

    try {
        // Verificar API e cr√©ditos
        let apiKey = null;
        let useAdminApi = false;
        let adminApi = null;
        
        // Verificar prefer√™ncia do usu√°rio
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        // Se useCredits estiver marcado, usar laozhang.ai
        if (useCredits) {
            console.log(`[TTS Generate] useCredits marcado, usando laozhang.ai`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Chave da laozhang.ai n√£o configurada. Configure no painel admin.' });
            }
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (!laozhangProviderId) {
                return res.status(400).json({ message: 'Provider laozhang.ai n√£o est√° ativo no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            adminApi = { id: laozhangProviderId, provider: 'laozhang' };
            // For√ßar provider para laozhang
            actualProvider = 'laozhang';
            console.log('[TTS Generate] ‚úÖ Usando API laozhang.ai (useCredits marcado)');
        } else if (provider === 'laozhang') {
            console.log(`[TTS Generate] Provider: laozhang, Voice: ${voice}`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Configure a chave do DarkVoz no painel admin para usar este provedor.' });
            }
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (!laozhangProviderId) {
                return res.status(400).json({ message: 'Provider DarkVoz n√£o est√° ativo no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            adminApi = { id: laozhangProviderId, provider: 'laozhang' };
            console.log('[TTS Generate] ‚úÖ Usando API DarkVoz (Laozhang.ai) do painel admin');
        } else if (provider === 'gemini') {
            console.log(`[TTS Generate] Provider: gemini, Voice: ${voice}`);
            
            // PRIORIDADE 2: Se n√£o houver chave do admin, buscar API do Gemini do usu√°rio
            if (!apiKey && !useCredits) {
                let userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'gemini']);
                console.log('[TTS Generate] DEBUG - Gemini API do usu√°rio encontrada:', !!userApiKey);
                
                if (userApiKey && userApiKey.api_key) {
                    // Descriptografar a chave do Gemini
                    if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(userApiKey.api_key);
                            console.log('[TTS Generate] Chave Gemini descriptografada (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                        } catch (decryptError) {
                            console.warn('[TTS Generate] Erro ao descriptografar chave Gemini, tentando usar diretamente:', decryptError.message);
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        apiKey = userApiKey.api_key;
                        console.log('[TTS Generate] Chave Gemini usada diretamente (tamanho:', apiKey ? apiKey.length : 0, 'caracteres)');
                    }
                    
                    // Validar se a chave n√£o est√° vazia
                    if (!apiKey || apiKey.trim() === '' || apiKey.trim().length < 10) {
                        console.warn('[TTS Generate] ‚ö†Ô∏è Chave Gemini est√° vazia, tentando API do admin');
                        apiKey = null;
                    } else {
                        console.log('[TTS Generate] ‚úÖ Usando API Gemini do usu√°rio');
                    }
                }
            }
            
            // Se n√£o conseguiu usar API pr√≥pria, tentar admin como fallback
            if (!apiKey) {
                console.log('[TTS Generate] Tentando usar API do admin como fallback para Gemini...');
                adminApi = await getDefaultAdminApi();
                console.log('[TTS Generate] Admin API encontrada:', adminApi ? `${adminApi.provider} - ${adminApi.name}` : 'Nenhuma');
                if (adminApi && adminApi.provider === 'gemini' && adminApi.api_key) {
                    // Descriptografar se necess√°rio
                    if (adminApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminApi.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Generate] Erro ao descriptografar chave Gemini do admin, tentando usar diretamente:', decryptError.message);
                            apiKey = adminApi.api_key;
                        }
                    } else {
                        apiKey = adminApi.api_key;
                    }
                    useAdminApi = true;
                } else {
                    return res.status(400).json({ message: 'Nenhuma API configurada ou a chave est√° vazia/inv√°lida. Verifique suas configura√ß√µes de API. Se sua chave foi marcada como inv√°lida na valida√ß√£o, corrija-a ou use cr√©ditos.' });
                }
            }
        } else if (provider === 'voice_premium' || provider === 'genaipro') {
            
            const userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'genaipro']);
            
            if (useCredits) {
                // Usu√°rio prefere usar cr√©ditos mesmo tendo API pr√≥pria
                adminApi = await getDefaultAdminApi();
                if (adminApi && (adminApi.provider === 'genaipro' || adminApi.provider === 'voice_premium')) {
                    // Tentar descriptografar a chave do admin
                    if (adminApi.api_key && adminApi.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(adminApi.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Generate] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                            apiKey = adminApi.api_key;
                        }
                    } else {
                        apiKey = adminApi.api_key;
                    }
                    useAdminApi = true;
                } else {
                    // Fallback: usar API pr√≥pria se dispon√≠vel
                    if (userApiKey) {
                        // Descriptografar a chave do usu√°rio
                        if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                            try {
                                apiKey = decrypt(userApiKey.api_key);
                            } catch (decryptError) {
                                console.warn('[TTS Generate] Erro ao descriptografar chave do usu√°rio, tentando usar diretamente:', decryptError.message);
                                apiKey = userApiKey.api_key;
                            }
                        } else {
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API Voz Premium ou use cr√©ditos.' });
                    }
                }
            } else {
                // Usu√°rio prefere usar API pr√≥pria quando dispon√≠vel
                if (userApiKey) {
                    // Descriptografar a chave do usu√°rio
                    if (userApiKey.api_key && userApiKey.api_key.includes(':')) {
                        try {
                            apiKey = decrypt(userApiKey.api_key);
                        } catch (decryptError) {
                            console.warn('[TTS Generate] Erro ao descriptografar chave do usu√°rio, tentando usar diretamente:', decryptError.message);
                            apiKey = userApiKey.api_key;
                        }
                    } else {
                        apiKey = userApiKey.api_key;
                    }
                } else {
                    adminApi = await getDefaultAdminApi();
                    if (adminApi && (adminApi.provider === 'genaipro' || adminApi.provider === 'voice_premium')) {
                        // Tentar descriptografar a chave do admin
                        if (adminApi.api_key && adminApi.api_key.includes(':')) {
                            try {
                                apiKey = decrypt(adminApi.api_key);
                            } catch (decryptError) {
                                console.warn('[TTS Generate] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                                apiKey = adminApi.api_key;
                            }
                        } else {
                            apiKey = adminApi.api_key;
                        }
                        useAdminApi = true;
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API Voz Premium ou use cr√©ditos.' });
                    }
                }
            }
        } else if (provider === 'openai') {
            // Verificar prefer√™ncia do usu√°rio
            const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [req.user.id]);
            const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
            
            const userApiKey = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [req.user.id, 'openai']);
            const adminOpenAiKey = await getAdminOpenAiVoiceApiKey();
            
            if (adminOpenAiKey) {
                apiKey = adminOpenAiKey;
                console.log('[TTS Generate] ‚úÖ Usando chave de voz OpenAI do painel admin');
            }
            
            if (!apiKey && useCredits) {
                // Usu√°rio prefere usar cr√©ditos mesmo tendo API pr√≥pria
                adminApi = await getDefaultAdminApi();
                if (adminApi && adminApi.provider === 'openai') {
                    apiKey = adminApi.api_key;
                    useAdminApi = true;
                } else {
                    // Fallback: usar API pr√≥pria se dispon√≠vel
                    if (userApiKey) {
                        apiKey = userApiKey.api_key;
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API OpenAI ou use cr√©ditos.' });
                    }
                }
            } else if (!apiKey) {
                // Usu√°rio prefere usar API pr√≥pria quando dispon√≠vel
                if (userApiKey) {
                    apiKey = userApiKey.api_key;
                } else {
                    adminApi = await getDefaultAdminApi();
                    if (adminApi && adminApi.provider === 'openai') {
                        apiKey = adminApi.api_key;
                        useAdminApi = true;
                    } else {
                        return res.status(400).json({ message: 'Configure uma chave da API OpenAI ou use cr√©ditos.' });
                    }
                }
            }
        } else if (provider === 'laozhang') {
            console.log(`[TTS Generate] Provider: laozhang, Voice: ${voice}`);
            const laozhangKey = await getLaozhangApiKey();
            let normalizedKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : null;
            if (!normalizedKey && laozhangKey && typeof laozhangKey === 'object' && laozhangKey.api_key) {
                normalizedKey = String(laozhangKey.api_key).trim();
            }
            if (!normalizedKey || normalizedKey.length < 10) {
                return res.status(400).json({ message: 'Configure a chave do DarkVoz no painel admin para usar este provedor.' });
            }
            const laozhangProviderId = await getLaozhangApiProviderId();
            if (!laozhangProviderId) {
                return res.status(400).json({ message: 'Provider DarkVoz n√£o est√° ativo no painel admin.' });
            }
            apiKey = normalizedKey;
            useAdminApi = true;
            adminApi = { id: laozhangProviderId, provider: 'laozhang' };
            console.log('[TTS Generate] ‚úÖ Usando API DarkVoz (Laozhang.ai) do painel admin');
        }
        
        if (!apiKey) {
            return res.status(400).json({ message: 'Nenhuma API configurada.' });
        }

        // Se usar API do admin, verificar cr√©ditos antes
        if (useAdminApi && adminApi) {
            // Estimar tokens necess√°rios
            const estimatedTokens = Math.ceil(script.length / 4);
            
            try {
                const creditCheck = await checkAndDebitCredits(
                    req.user.id,
                    adminApi.id,
                    estimatedTokens,
                    'api_tts_generation',
                    JSON.stringify({ model: finalTtsModel, provider: provider, endpoint: '/api/tts/generate-from-script' })
                );
                
                console.log(`üí≥ [CR√âDITOS] Pr√©-d√©bito: ${creditCheck.creditsUsed.toFixed(2)} cr√©ditos. Saldo restante: ${creditCheck.newBalance.toFixed(2)}`);
            } catch (creditError) {
                if (creditError.message.includes('Cr√©ditos insuficientes')) {
                    return res.status(402).json({ 
                        error: creditError.message,
                        code: 'INSUFFICIENT_CREDITS'
                    });
                }
                throw creditError;
            }
        }

        const jobId = `tts-script-${Date.now()}-${crypto.randomBytes(4).toString('hex')}`;
        const jobData = {
            apiKey,
            ttsModel: finalTtsModel,
            script,
            voice,
            styleInstructions,
            provider: provider,
            speed: parseFloat(speed) || 1.0,
            useAdminApi: useAdminApi,
            adminApi: adminApi,
            userId: req.user.id
        };

        ttsJobs[jobId] = {
            id: jobId,
            status: 'queued',
            progress: 0,
            total: 1,
            message: 'Na fila para processamento...',
            downloadUrl: null,
            createdAt: new Date(),
        };

        // Processar job em background (implementa√ß√£o simplificada)
        processScriptTtsJob(jobId, jobData);

        res.status(202).json({ jobId });

    } catch (error) {
        console.error("Erro ao iniciar trabalho de TTS a partir de roteiro:", error);
        res.status(500).json({ message: `N√£o foi poss√≠vel iniciar a gera√ß√£o de √°udio: ${error.message}` });
    }
});

// GET /api/tts/status/:jobId - Consulta status do job TTS
app.get('/api/tts/status/:jobId', authenticateToken, (req, res) => {
    const { jobId } = req.params;
    const job = ttsJobs[jobId];

    if (!job) {
        return res.status(404).json({ message: 'Job n√£o encontrado.' });
    }

    res.json({
        status: job.status,
        progress: job.progress,
        total: job.total,
        message: job.message,
        downloadUrl: job.downloadUrl,
        partDownloads: job.partDownloads || []
    });
});

// Fun√ß√£o para processar job TTS em background (vers√£o completa do DARKSCRIPT)
async function processScriptTtsJob(jobId, jobData) {
    const job = ttsJobs[jobId];
    
    // Garante que o job existe e reinicializa os valores
    if (!job) {
        console.error(`Job ${jobId} n√£o encontrado`);
        return;
    }
    
    // Reinicializa o progresso para garantir que comece do zero
    job.status = 'processing';
    job.progress = 0;
    job.total = 0;
    job.message = 'Dividindo o roteiro...';
    const tempFilePaths = [];

    try {
        // Define o modelo e limite baseado no provedor
        // SEMPRE usar 4000 caracteres por parte conforme DARKSCRIPT
        let validatedTtsModel;
        let charLimit = 4000; // SEMPRE 4000 caracteres por parte
        let minDelayBetweenRequests;
        
        if (jobData.provider === 'openai') {
            // OpenAI TTS: limite REAL √© 4096 caracteres por requisi√ß√£o, mas vamos usar 4000 para padronizar
            validatedTtsModel = 'tts-1-hd';
            minDelayBetweenRequests = 500; // 0.5s (OpenAI √© r√°pido)
            console.log(`üì¢ Usando OpenAI TTS para gerar √°udio (4000 chars por parte)`);
        } else if (jobData.provider === 'genaipro' || jobData.provider === 'voice_premium') {
            validatedTtsModel = 'voz-premium'; // Nome gen√©rico, n√£o expor fornecedor
            minDelayBetweenRequests = 2000; // 2s entre requisi√ß√µes
            console.log(`üì¢ Usando Voz Premium para gerar √°udio (4000 chars por parte)`);
        } else if (jobData.provider === 'laozhang') {
            // Usar modelo do jobData se fornecido, sen√£o usar padr√£o
            validatedTtsModel = jobData.ttsModel || 'tts-1';
            minDelayBetweenRequests = 1500;
            console.log(`üì¢ Usando DarkVoz TTS para gerar √°udio (4000 chars por parte, modelo: ${validatedTtsModel}, velocidade: ${jobData.speed || 1.0}x)`);
        } else {
            // Gemini TTS: aceita textos MUITO longos, mas vamos usar 4000 para padronizar
            validatedTtsModel = 'gemini-2.5-flash-preview-tts';
            minDelayBetweenRequests = 2000; // 2s entre requisi√ß√µes
            console.log(`üì¢ Usando Gemini TTS para gerar √°udio (4000 chars por parte)`);
        }
        
        // Log para monitorar processamento de √°udios longos
        const estimatedMinutes = Math.ceil((jobData.script.length / charLimit) * 0.5); // ~0.5 min por chunk
        if (estimatedMinutes > 30) {
            console.log(`Processando √°udio longo estimado em ~${estimatedMinutes} minutos (${jobData.script.length} caracteres)`);
        }

        // Usando a fun√ß√£o splitTextIntoChunks com 4000 caracteres
        const chunks = splitTextIntoChunks(jobData.script, charLimit);

        if (!chunks || chunks.length === 0) {
            throw new Error("N√£o foi poss√≠vel dividir o roteiro em partes.");
        }
        
        // Valida√ß√£o pr√©via: verifica se h√° chunks antes de processar
        console.log(`üìä Roteiro dividido em ${chunks.length} parte(s) de at√© ${charLimit} caracteres cada.`);
        console.log(`   Total de caracteres: ${jobData.script.length.toLocaleString('pt-BR')}`);
        console.log(`   Estimativa de tempo: ~${Math.ceil(chunks.length * minDelayBetweenRequests / 1000 / 60)} minutos`);

        // Atualiza o job com o total de chunks ANTES de come√ßar o processamento
        job.total = chunks.length;
        job.progress = 0;
        job.message = `üìã Roteiro dividido em ${chunks.length} partes. Preparando gera√ß√£o...`;
        
        // Verificar FFmpeg ANTES de come√ßar (para mostrar status correto)
        let ffmpegAvailable = false;
        try {
            await new Promise((resolve, reject) => {
                ffmpeg().version((err) => {
                    if (err) reject(err);
                    else resolve();
                });
            });
            ffmpegAvailable = true;
        } catch (e) {
            ffmpegAvailable = false;
        }
        
        if (ffmpegAvailable) {
            job.message = `‚úÖ FFmpeg detectado. Gerando ${chunks.length} partes de √°udio...`;
        } else {
            job.message = `‚ö†Ô∏è FFmpeg n√£o encontrado. Usando m√©todo alternativo para ${chunks.length} partes...`;
        }
        
        const audioExt = 'mp3'; // Sempre usar MP3
        const validTempFiles = [];
        
        // Processar cada chunk
        for (let i = 0; i < chunks.length; i++) {
            job.progress = i;
            job.message = `üéôÔ∏è Gerando parte ${i + 1}/${chunks.length}...`;
            
            try {
                const speakerVoiceMap = new Map([['Narrador', jobData.voice]]);
                
                // Garantir que o provider seja correto para a fun√ß√£o generateTtsAudio
                // Se for voice_premium ou genaipro, converter para genaipro
                let actualProvider = jobData.provider;
                if (actualProvider === 'voice_premium' || actualProvider === 'genaipro') {
                    actualProvider = 'genaipro';
                } else if (actualProvider === 'gemini') {
                    // Gemini TTS: usar 'gemini' para usar a API oficial do Google Gemini
                    actualProvider = 'gemini';
                }
                
                const result = await generateTtsAudio({
                    apiKey: jobData.apiKey,
                    model: validatedTtsModel,
                    textInput: chunks[i],
                    speakerVoiceMap: speakerVoiceMap,
                    provider: actualProvider,
                    speed: jobData.speed || 1.0
                });
                
                // Salvar arquivo tempor√°rio
                const tempPath = path.join(TEMP_AUDIO_DIR, `${jobId}_part_${i}.${audioExt}`);
                const audioBuffer = Buffer.from(result.audioBase64, 'base64');
                await fs.promises.writeFile(tempPath, audioBuffer);
                validTempFiles.push(tempPath);
                tempFilePaths.push(tempPath);
                
                // Registrar arquivo no banco de dados para controle de armazenamento
                if (jobData.userId) {
                    await registerUserStorage(jobData.userId, tempPath, audioBuffer.length, 'audio');
                }
                
                console.log(`‚úÖ Parte ${i + 1}/${chunks.length} gerada: ${audioBuffer.length} bytes`);
                
                // Delay entre partes
                if (i < chunks.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, minDelayBetweenRequests));
                }
            } catch (chunkError) {
                console.error(`‚ùå Erro ao gerar parte ${i + 1}/${chunks.length}:`, chunkError);
                console.error(`‚ùå Detalhes do erro:`, {
                    message: chunkError.message,
                    stack: chunkError.stack,
                    response: chunkError.response ? {
                        status: chunkError.response.status,
                        data: chunkError.response.data
                    } : null,
                    provider: actualProvider || jobData.provider,
                    voice: jobData.voice,
                    chunkLength: chunks[i].length,
                    chunkPreview: chunks[i].substring(0, 100)
                });
                
                // Se for erro cr√≠tico (n√£o de rede), parar o processamento
                const isCriticalError = chunkError.message && (
                    chunkError.message.includes('manuten√ß√£o') ||
                    chunkError.message.includes('API Key') ||
                    chunkError.message.includes('inv√°lida') ||
                    chunkError.message.includes('indispon√≠vel') ||
                    chunkError.message.includes('n√£o est√° dispon√≠vel') ||
                    chunkError.message.includes('n√£o existe') ||
                    chunkError.message.includes('voz') && chunkError.message.includes('inv√°lida') ||
                    (chunkError.response && chunkError.response.status === 400) // Erro 400 geralmente indica par√¢metros inv√°lidos
                );
                
                if (isCriticalError) {
                    // Se for primeira parte e erro cr√≠tico, parar imediatamente
                    if (i === 0) {
                        throw chunkError; // Parar processamento se for erro cr√≠tico na primeira parte
                    }
                    // Se for erro cr√≠tico em partes subsequentes, tamb√©m parar para evitar desperd√≠cio
                    throw chunkError;
                }
                // Continuar com outras partes mesmo se uma falhar (apenas para erros n√£o cr√≠ticos como timeout de rede)
            }
        }
        
        if (validTempFiles.length === 0) {
            const errorDetails = {
                totalChunks: chunks.length,
                provider: actualProvider || jobData.provider,
                scriptLength: jobData.script.length,
                voice: jobData.voice
            };
            console.error('‚ùå Nenhuma parte de √°udio foi gerada com sucesso. Detalhes:', errorDetails);
            throw new Error(`Nenhuma parte de √°udio foi gerada com sucesso. Verifique os logs do servidor para mais detalhes. Provider: ${errorDetails.provider}, Voz: ${errorDetails.voice}`);
        }
        
        // Log de sucesso parcial se nem todos os chunks foram gerados
        if (validTempFiles.length < chunks.length) {
            console.warn(`‚ö†Ô∏è Apenas ${validTempFiles.length} de ${chunks.length} partes foram geradas com sucesso. Continuando com as partes dispon√≠veis...`);
        }
        
        // CASO 1: apenas 1 arquivo ‚Üí retornar direto
        if (validTempFiles.length === 1) {
            const singleFile = await fs.promises.readFile(validTempFiles[0]);
            const singleBase64 = singleFile.toString('base64');
            job.downloadUrl = `data:audio/${audioExt};base64,${singleBase64}`;
            job.status = 'completed';
            job.progress = job.total;
            job.message = '√Åudio gerado com sucesso!';
            console.log(`üéâ TTS de roteiro conclu√≠do (sem concatena√ß√£o): ${jobId}.${audioExt}`);
            return;
        }
        
        // CASO 2: mais de 1 arquivo E FFmpeg dispon√≠vel ‚Üí concatenar com FFmpeg
        if (ffmpegAvailable) {
            job.message = `üîó Concatenando ${validTempFiles.length} partes com FFmpeg...`;
            console.log(`‚úÖ FFmpeg dispon√≠vel - concatenando ${validTempFiles.length} arquivos ${audioExt.toUpperCase()}`);
            
            const finalPath = path.join(TEMP_AUDIO_DIR, `${jobId}_final.${audioExt}`);
            const listFilePath = path.join(TEMP_AUDIO_DIR, `${jobId}_filelist.txt`);
            const fileListContent = validTempFiles
                .map(fp => `file '${fp.replace(/\\/g, '/')}'`)
                .join('\n');
            
            await fs.promises.writeFile(listFilePath, fileListContent, 'utf8');
            tempFilePaths.push(listFilePath);
            
            await new Promise((resolve, reject) => {
                ffmpeg()
                    .input(listFilePath)
                    .inputOptions(['-f', 'concat', '-safe', '0'])
                    .outputOptions(['-c', 'copy'])
                    .output(finalPath)
                    .on('start', (cmd) => {
                        console.log(`üé¨ [TTS] FFmpeg iniciado para concatena√ß√£o: ${cmd}`);
                    })
                    .on('progress', (progress) => {
                        if (progress.percent) {
                            job.message = `üîó Concatenando com FFmpeg: ${Math.round(progress.percent)}%`;
                        }
                    })
                    .on('end', async () => {
                        console.log(`‚úÖ [TTS] FFmpeg conclu√≠do: ${finalPath}`);
                        resolve();
                    })
                    .on('error', (err) => {
                        console.error(`‚ùå [TTS] Erro no FFmpeg: ${err.message}`);
                        reject(err);
                    })
                    .run();
            });
            
            // Ler arquivo final
            const finalAudio = await fs.promises.readFile(finalPath);
            const finalBase64 = finalAudio.toString('base64');
            job.downloadUrl = `data:audio/${audioExt};base64,${finalBase64}`;
            tempFilePaths.push(finalPath);
            
            // Registrar arquivo final no banco de dados para controle de armazenamento
            if (jobData.userId) {
                await registerUserStorage(jobData.userId, finalPath, finalAudio.length, 'audio');
                // Remover registros das partes individuais j√° que temos o arquivo final
                for (const partPath of validTempFiles) {
                    await unregisterUserStorage(jobData.userId, partPath);
                }
            }
        } else {
            // CASO 3: FFmpeg n√£o dispon√≠vel ‚Üí retornar partes separadas
            job.message = `‚ö†Ô∏è ${validTempFiles.length} partes geradas (FFmpeg n√£o dispon√≠vel para concatena√ß√£o)`;
            job.partDownloads = validTempFiles.map((filePath, idx) => {
                const fileBase64 = fs.readFileSync(filePath).toString('base64');
                return {
                    part: idx + 1,
                    downloadUrl: `data:audio/${audioExt};base64,${fileBase64}`,
                    filename: `parte_${idx + 1}.${audioExt}`
                };
            });
            job.status = 'partial';
        }
        
        job.status = job.status === 'partial' ? 'partial' : 'completed';
        job.progress = job.total;
        job.message = job.status === 'completed' ? '√Åudio gerado com sucesso!' : job.message;
        
    } catch (error) {
        console.error(`Erro no trabalho TTS ${jobId}:`, error);
        job.status = 'failed';
        job.message = error.message || 'Ocorreu um erro desconhecido.';
        
        // Reembolsar cr√©ditos em caso de erro
        if (jobData.useAdminApi && jobData.adminApi) {
            try {
                const estimatedTokens = Math.ceil(jobData.script.length / 4);
                await refundCredits(jobData.userId, estimatedTokens * 0.1, 'Erro na gera√ß√£o de TTS');
            } catch (refundError) {
                console.error('Erro ao reembolsar cr√©ditos:', refundError);
            }
        }
    } finally {
        // Limpar arquivos tempor√°rios e remover registros do banco de dados
        for (const filePath of tempFilePaths) {
            try {
                // Remover registro do banco de dados antes de deletar o arquivo
                if (jobData.userId) {
                    await unregisterUserStorage(jobData.userId, filePath);
                }
                await fs.promises.unlink(filePath);
            } catch (unlinkError) {
                console.warn(`N√£o foi poss√≠vel excluir o arquivo tempor√°rio ${filePath}: ${unlinkError.message}`);
            }
        }
        job.finishedAt = new Date();
    }
}


// === ROTAS DE GEST√ÉO DE API KEYS ===

app.post('/api/keys/save', authenticateToken, async (req, res) => {
    const { service_name, api_key } = req.body;
    const userId = req.user.id;

    if (!service_name || !api_key) {
        return res.status(400).json({ msg: 'Servi√ßo e Chave de API s√£o obrigat√≥rios.' });
    }

    // Verificar se √© uma API que requer plano premium (Claude, Gemini, OpenAI)
    const premiumApis = ['claude', 'gemini', 'openai'];
    if (premiumApis.includes(service_name.toLowerCase())) {
        try {
            // Verificar plano do usu√°rio
            const user = await db.get('SELECT plan, subscription_plan, isAdmin FROM users WHERE id = ?', [userId]);
            if (!user) {
                return res.status(404).json({ msg: 'Usu√°rio n√£o encontrado.' });
            }
            
            const userPlan = user.subscription_plan || user.plan || 'plan-free';
            const hasPremiumPlan = userPlan === 'plan-master' || 
                                  userPlan === 'plan-master-annual' || 
                                  userPlan === 'plan-start-annual' || 
                                  userPlan === 'plan-turbo-annual' ||
                                  (user.isAdmin === 1 || user.isAdmin === true || String(user.isAdmin) === '1');
            
            if (!hasPremiumPlan) {
                return res.status(403).json({ 
                    msg: 'Voc√™ precisa ter o plano MASTER ou um plano ANUAL para usar suas pr√≥prias chaves de API. Fa√ßa upgrade para desbloquear este recurso.',
                    requiresUpgrade: true
                });
            }
        } catch (planErr) {
            console.error('Erro ao verificar plano do usu√°rio:', planErr);
            return res.status(500).json({ msg: 'Erro ao verificar plano do usu√°rio.' });
        }
    }

    try {
        const encryptedKey = encrypt(api_key);
        
        await db.run(
            `INSERT INTO user_api_keys (user_id, service_name, api_key) 
             VALUES (?, ?, ?)
             ON CONFLICT(user_id, service_name) 
             DO UPDATE SET api_key = excluded.api_key, created_at = CURRENT_TIMESTAMP`,
            [userId, service_name, encryptedKey]
        );

        res.status(200).json({ msg: `Chave de API para ${service_name} salva com sucesso!` });
    
    } catch (err) {
        console.error('Erro ao salvar chave de API:', err);
        res.status(500).json({ msg: 'Erro no servidor ao salvar a chave.' });
    }
});

app.get('/api/keys/status', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    try {
        const keys = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
        
        // Fun√ß√£o para mascarar chave
        const maskKey = (key, serviceName) => {
            if (!key) return '';
            try {
                const decrypted = decrypt(key);
                if (!decrypted) return '';
                
                // Mostrar primeiros 4 caracteres e √∫ltimos 4 caracteres
                if (decrypted.length > 12) {
                    const prefix = decrypted.substring(0, 4);
                    const suffix = decrypted.substring(decrypted.length - 4);
                    return `${prefix}${'‚Ä¢'.repeat(Math.min(decrypted.length - 8, 20))}${suffix}`;
                }
                return '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
            } catch (err) {
                // Se falhar ao descriptografar, ainda mostrar que existe
                return '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
            }
        };
        
        const status = {};
        keys.forEach(k => {
            status[k.service_name] = {
                exists: true,
                masked: maskKey(k.api_key, k.service_name)
            };
        });
        
        // Incluir todos os servi√ßos poss√≠veis
        const allServices = ['gemini', 'openai', 'claude', 'imagefx', 'youtube'];
        allServices.forEach(service => {
            if (!status[service]) {
                status[service] = { exists: false, masked: '' };
            }
        });
        
        res.status(200).json(status);
    } catch (err) {
        console.error('Erro ao buscar status das chaves:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

app.post('/api/keys/validate-all', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    try {
        const keysData = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
        
        if (keysData.length === 0) {
            return res.status(400).json({ msg: 'Nenhuma chave de API foi salva ainda.' });
        }

        const allowedServices = new Set(['gemini', 'openai', 'claude', 'imagefx', 'youtube']);
        const filteredKeysData = keysData.filter(key => allowedServices.has(key.service_name));
        const ignoredServices = keysData.filter(key => !allowedServices.has(key.service_name));

        if (ignoredServices.length > 0) {
            console.warn(`[Valida√ß√£o de Chaves] Ignorando servi√ßos n√£o suportados: ${ignoredServices.map(s => s.service_name).join(', ')}`);
        }

        if (filteredKeysData.length === 0) {
            return res.status(400).json({ msg: 'Nenhuma chave dos servi√ßos suportados (Gemini, Claude, OpenAI, YouTube ou ImageFX) foi encontrada para valida√ß√£o.' });
        }

        const validationPromises = filteredKeysData.map(async (keyData) => {
            const decryptedKey = decrypt(keyData.api_key);
            if (!decryptedKey) {
                return { service: keyData.service_name, success: false, error: 'Falha ao desencriptar' };
            }

            switch (keyData.service_name) {
                case 'gemini':
                    const geminiResult = await validateGeminiKey(decryptedKey);
                    return { service: 'gemini', ...geminiResult };
                case 'openai':
                    const openaiResult = await validateOpenAIKey(decryptedKey);
                    return { service: 'openai', ...openaiResult };
                case 'claude':
                    const claudeResult = await validateClaudeKey(decryptedKey);
                    return { service: 'claude', ...claudeResult };
                case 'youtube':
                    const youtubeResult = await validateYouTubeKey(decryptedKey);
                    return { service: 'youtube', ...youtubeResult };
                case 'imagefx':
                    return { service: 'imagefx', success: true };
                default:
                    return { service: keyData.service_name, success: false, error: 'Servi√ßo desconhecido' };
            }
        });

        const results = await Promise.all(validationPromises);
        
        // Adicionar informa√ß√µes sobre o tipo de chave detectado
        const resultsWithDetails = results.map(result => {
            if (result.service === 'gemini' && result.success && result.type) {
                return {
                    ...result,
                    message: result.message || (result.type === 'gemini-api' ? 'Chave de API do Gemini v√°lida' : 'Chave do Google Cloud v√°lida'),
                    warning: result.warning || null
                };
            }
            return result;
        });
        
        res.status(200).json({ 
            msg: 'Valida√ß√£o conclu√≠da.',
            results: resultsWithDetails
        });

    } catch (err) {
        console.error('Erro ao validar chaves:', err);
        res.status(500).json({ msg: 'Erro no servidor durante a valida√ß√£o.' });
    }
});


// === FUN√á√ïES AUXILIARES DE AN√ÅLISE ===

// Fun√ß√£o para determinar se um v√≠deo √© realmente viral
function isViralVideo(views, days, viewsPerDay) {
    // Crit√©rios para considerar um v√≠deo como viral:
    // 1. M√≠nimo de 100.000 views totais
    // 2. M√≠nimo de 10.000 views/dia (para v√≠deos recentes)
    // 3. Ou m√≠nimo de 50.000 views/dia nos primeiros 7 dias
    // 4. Para v√≠deos mais antigos (>30 dias), m√≠nimo de 500.000 views totais
    
    if (days <= 0) {
        // Sem informa√ß√£o de dias, usar apenas views totais
        return views >= 500000; // 500k+ views sem info de tempo = provavelmente viral
    }
    
    if (days <= 7) {
        // V√≠deo muito recente: precisa de crescimento explosivo
        return viewsPerDay >= 50000 || views >= 500000;
    } else if (days <= 30) {
        // V√≠deo recente: precisa de bom crescimento
        return viewsPerDay >= 10000 || views >= 300000;
    } else {
        // V√≠deo mais antigo: precisa de views totais altas
        return views >= 1000000; // 1M+ views para v√≠deos antigos
    }
}

// === ROTAS DE AN√ÅLISE (O CORA√á√ÉO DO SAAS) ===

app.post('/api/analyze/titles', authenticateToken, async (req, res) => {
    // Log defensivo do corpo recebido
    try {
        console.log('[An√°lise] Body recebido tipo:', typeof req.body);
        console.log('[An√°lise] Campos:', {
            videoUrl: req.body?.videoUrl,
            model: req.body?.model,
            selectedModel: req.body?.selectedModel,
            folderId: req.body?.folderId
        });
    } catch {}

    const rawModel = (req.body && (req.body.model ?? req.body.selectedModel)) ?? '';
    const model = typeof rawModel === 'string' ? rawModel.trim() : '';
    const videoUrl = typeof req.body?.videoUrl === 'string' ? req.body.videoUrl.trim() : '';
    const folderId = req.body?.folderId;
    const language = req.body?.language || 'Portugu√™s'; // Idioma padr√£o: Portugu√™s
    const userId = req.user.id;

    if (!videoUrl || !model) {
        return res.status(400).json({ msg: 'URL do v√≠deo e modelo de IA s√£o obrigat√≥rios.' });
    }
    
    try {
        // Verificar se o banco de dados est√° dispon√≠vel
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel. Aguarde alguns instantes.' });
        }
        
        // --- ETAPA 1: Minera√ß√£o de Dados (YouTube) ---
        console.log(`[An√°lise] A iniciar minera√ß√£o para: ${videoUrl}`);
        let videoId;
        try {
            videoId = ytdl.getVideoID(videoUrl);
        } catch (err) {
            return res.status(400).json({ msg: 'URL do YouTube inv√°lida.' });
        }

        // Tentar usar chave espec√≠fica do YouTube primeiro, depois fallback para Gemini
        let youtubeApiKey = null;
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
            if (!youtubeApiKey && youtubeKeyData.api_key && !youtubeKeyData.api_key.includes(':')) {
                // Chave pode n√£o estar criptografada
                youtubeApiKey = youtubeKeyData.api_key;
            }
        }
        
        // Se n√£o tem chave do YouTube, tentar usar Gemini (pode funcionar se for chave do Google Cloud)
        if (!youtubeApiKey) {
            const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
                if (!youtubeApiKey && geminiKeyData.api_key && !geminiKeyData.api_key.includes(':')) {
                    youtubeApiKey = geminiKeyData.api_key;
                }
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ 
                msg: 'Nenhuma chave de API do YouTube configurada. Configure uma chave do YouTube Data API v3 nas Configura√ß√µes. A chave do Gemini n√£o funciona para a API do YouTube.' 
            });
        }

        const videoDetails = await callYouTubeDataAPI(videoId, youtubeApiKey);
        
        let transcriptText;
        let fullTranscript = null;
        try {
            const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
            fullTranscript = transcriptData.map(t => t.text).join(' ');
            transcriptText = fullTranscript.substring(0, 500); // Apenas in√≠cio para o prompt
        } catch (err) {
            console.warn(`[An√°lise] N√£o foi poss√≠vel obter transcri√ß√£o para ${videoId}. A continuar sem ela.`);
            transcriptText = "(Transcri√ß√£o n√£o dispon√≠vel)";
            fullTranscript = null;
        }
        
        console.log(`[An√°lise] V√≠deo encontrado: ${videoDetails.title}`);

        // --- ETAPA 1.5: Traduzir t√≠tulo original para portugu√™s ---
        let translatedTitle = videoDetails.title;
        try {
            const translatePrompt = `Traduza o seguinte t√≠tulo de v√≠deo do YouTube para portugu√™s brasileiro (PT-BR). Mantenha o sentido, impacto e estrutura original. Retorne APENAS a tradu√ß√£o, sem explica√ß√µes ou formata√ß√£o.
T√≠tulo original: "${videoDetails.title}"

Tradu√ß√£o em PT-BR:`;
            
            // Usar o modelo escolhido pelo usu√°rio para tradu√ß√£o
            let translateText;
            
            // Mapear modelo do frontend para servi√ßo e modelo correto
            let translateService;
            let translateModel = model;
            if (model.startsWith('gemini') || model.includes('gemini')) {
                translateService = 'gemini';
                translateModel = model.includes('2.5-pro') ? 'gemini-2.5-pro' : (model.includes('2.5-flash') ? 'gemini-2.5-flash' : 'gemini-2.0-flash');
            } else if (model.startsWith('claude') || model.includes('claude') || model.includes('sonnet')) {
                translateService = 'claude';
                translateModel = model.includes('3.7') ? 'claude-3-7-sonnet-20250219' : model;
            } else if (model.startsWith('gpt') || model.includes('gpt') || model.includes('openai')) {
                translateService = 'openai';
                translateModel = model.includes('4o') ? 'gpt-4o' : model;
            } else {
                // Fallback: tentar detectar pelo modelo
                translateService = 'gemini';
                translateModel = 'gemini-2.0-flash';
            }
            
            // Buscar chave do servi√ßo correspondente
            const translateKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, translateService]);
            if (translateKeyData) {
                const translateKey = decrypt(translateKeyData.api_key) || translateKeyData.api_key;
                
                if (translateService === 'claude') {
                    const translateResponse = await callClaudeAPI(translatePrompt, translateKey, translateModel);
                    translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
                } else if (translateService === 'openai') {
                    const translateResponse = await callOpenAIAPI(translatePrompt, translateKey, translateModel);
                    translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
                } else {
                    const translateResponse = await callGeminiAPI(translatePrompt, translateKey, translateModel);
                    translateText = translateResponse.titles.trim();
                }
            } else {
                // Fallback: usar sistema de prefer√™ncia se n√£o tiver chave do modelo escolhido
                let translateProvider = await getPreferredAIProvider(userId, ['claude', 'openai', 'gemini']);
                
                if (translateProvider && translateProvider.service === 'laozhang') {
                    const translateResponse = await callLaozhangAPI(
                        translatePrompt, 
                        translateProvider.apiKey, 
                        translateProvider.model, 
                        null, 
                        userId, 
                        '/api/analyze/titles', 
                        JSON.stringify({ endpoint: '/api/analyze/titles', operation: 'translate', model: translateProvider.model })
                    );
                    translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
                } else if (translateProvider && translateProvider.service === 'claude') {
                    const translateResponse = await callClaudeAPI(translatePrompt, translateProvider.apiKey, translateProvider.model);
                    translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
                } else if (translateProvider && translateProvider.service === 'openai') {
                    const translateResponse = await callOpenAIAPI(translatePrompt, translateProvider.apiKey, translateProvider.model);
                    translateText = typeof translateResponse === 'string' ? translateResponse.trim() : (translateResponse.titles || translateResponse).trim();
                } else {
                    // √öltimo fallback: Gemini
                    const translateResponse = await callGeminiAPI(translatePrompt, geminiApiKey, 'gemini-2.0-flash');
                    translateText = translateResponse.titles.trim();
                }
            }
            
            // Limpar a resposta (remover markdown, aspas, etc)
            translatedTitle = translateText.replace(/^["']|["']$/g, '').replace(/```json|```/g, '').trim();
            // Alguns modelos podem devolver array JSON ["..."]; normalizar para string
            if (translatedTitle.startsWith('[')) {
                try {
                    const arr = JSON.parse(translatedTitle);
                    if (Array.isArray(arr) && typeof arr[0] === 'string') {
                        translatedTitle = arr[0].trim();
                    }
                } catch {}
            }
            if (translatedTitle.length > 200) {
                translatedTitle = translatedTitle.substring(0, 200);
            }
            console.log(`[An√°lise] T√≠tulo traduzido: ${translatedTitle}`);
        } catch (err) {
            console.warn(`[An√°lise] Falha ao traduzir t√≠tulo, usando original: ${err.message}`);
            translatedTitle = videoDetails.title;
        }

        // --- ETAPA 2: IA - An√°lise de T√≠tulo e Gera√ß√£o (PROMPT REFINADO) ---
        const viewsPerDay = Math.round(videoDetails.views / Math.max(videoDetails.days, 1));
        const isViral = isViralVideo(videoDetails.views, videoDetails.days, viewsPerDay);
        
        // Contexto de performance baseado na classifica√ß√£o real
        let performanceContext;
        let viralContext;
        
        if (isViral) {
            if (videoDetails.days > 0) {
                performanceContext = `Este v√≠deo VIRALIZOU com ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias (m√©dia de ${viewsPerDay.toLocaleString()} views/dia) - um desempenho EXCEPCIONAL que indica alta viraliza√ß√£o.`;
            } else {
                performanceContext = `Este v√≠deo VIRALIZOU com ${videoDetails.views.toLocaleString()} views - um desempenho EXCEPCIONAL que indica alta viraliza√ß√£o.`;
            }
            viralContext = 'que VIRALIZOU';
        } else {
            // V√≠deo n√£o viral - ser honesto sobre a performance
            if (videoDetails.days > 0) {
                const performanceLevel = viewsPerDay < 100 
                    ? 'baixo desempenho' 
                    : viewsPerDay < 1000 
                        ? 'desempenho moderado' 
                        : 'bom desempenho';
                performanceContext = `Este v√≠deo tem ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias (m√©dia de ${viewsPerDay.toLocaleString()} views/dia) - ${performanceLevel}. Este v√≠deo N√ÉO viralizou, mas pode ser analisado para identificar elementos que podem ser melhorados para criar vers√µes com maior potencial viral.`;
            } else {
                performanceContext = `Este v√≠deo tem ${videoDetails.views.toLocaleString()} views. Este v√≠deo N√ÉO viralizou, mas pode ser analisado para identificar elementos que podem ser melhorados para criar vers√µes com maior potencial viral.`;
            }
            viralContext = 'de refer√™ncia';
        }

        // Quantidade de t√≠tulos a gerar: sempre 5 por modelo
        // No modo multimodal, cada modelo gera 5 t√≠tulos, totalizando 15 (5 x 3)
        const titlesRequired = 5;
        const languageInstruction = language === 'Portugu√™s'
            ? 'EM PORTUGU√äS BRASILEIRO (PT-BR)'
            : language === 'Ingl√™s'
                ? 'EM INGL√äS (EN)'
                : language === 'Espanhol'
                    ? 'EM ESPANHOL (ES)'
                    : 'EM PORTUGU√äS BRASILEIRO (PT-BR)';
        const languageExplanation = language === 'Portugu√™s'
            ? 'EM PORTUGU√äS BRASILEIRO'
            : language === 'Ingl√™s'
                ? 'EM INGL√äS'
                : language === 'Espanhol'
                    ? 'EM ESPANHOL'
                    : 'EM PORTUGU√äS BRASILEIRO';

        const MIN_IMPACT_SCORE = 7;
        const titlePrompt = buildTitleRefinePrompt({
            originalTitle: videoDetails.title,
            translatedTitle,
            performanceContext,
            descriptionStart: videoDetails.description ? videoDetails.description.substring(0, 300) : 'N/A',
            transcriptStart: transcriptText ? transcriptText.substring(0, 500) : '(Transcri√ß√£o n√£o dispon√≠vel)',
            languageInstruction,
            titlesRequired,
            minImpact: MIN_IMPACT_SCORE
        });
        
        let allGeneratedTitles = [];
        let modelUsedForDisplay = model;
        let finalAnalysisData;
        let finalNicheData;
        
        // --- IN√çCIO DA L√ìGICA DO DISTRIBUIDOR (SWITCHER) ---
        if (model === 'all') {
            // Compara√ß√£o multimodal SEM laozhang (usa chaves pr√≥prias)
            modelUsedForDisplay = 'Compara√ß√£o (Gemini, Claude, OpenAI)';

            const keysData = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
            const keys = {};
            keysData.forEach(k => { keys[k.service_name] = decrypt(k.api_key); });

            if (!keys.gemini || !keys.claude || !keys.openai) {
                return res.status(400).json({ msg: 'Para "Comparar", precisa de ter as chaves de Gemini, Claude E OpenAI configuradas.' });
            }

            console.log('[An√°lise-All] A chamar IA em paralelo (APIs pr√≥prias)...');
            const MIN_IMPACT_SCORE = 7;
            const serviceConfigs = [
                { name: 'Gemini', apiFunc: callGeminiAPI, apiKey: keys.gemini, model: 'gemini-2.5-pro' },
                { name: 'Claude', apiFunc: callClaudeAPI, apiKey: keys.claude, model: 'claude-3-7-sonnet-20250219' },
                { name: 'OpenAI', apiFunc: callOpenAIAPI, apiKey: keys.openai, model: 'gpt-4o' }
            ];
            // Primeiro round em paralelo
            const promises = serviceConfigs.map(cfg => cfg.apiFunc(titlePrompt, cfg.apiKey, cfg.model));
            const results = await Promise.allSettled(promises);

            let firstSuccessfulAnalysis = null;
            for (let index = 0; index < results.length; index++) {
                const result = results[index];
                const cfg = serviceConfigs[index];
                const serviceName = cfg?.name || ['Gemini', 'Claude', 'OpenAI'][index];

                // Se o 1¬∫ round falhar, n√£o derrubar a rota: apenas registrar e seguir (vamos tentar preencher com outras IAs)
                if (result.status !== 'fulfilled') {
                    console.error(`[An√°lise-All] Falha com ${serviceName}:`, result.reason?.message || result.reason);
                    continue;
                }

                // extrair texto do 1¬∫ round
                const rawText = typeof result.value === 'string'
                    ? result.value
                    : (result.value && typeof result.value.titles === 'string' ? result.value.titles : '');
                const parsedData = parseTitleAnalysisResponse(rawText, serviceName, titlesRequired);
                if (!firstSuccessfulAnalysis) firstSuccessfulAnalysis = parsedData;

                // Completar 5 aprovados com at√© 3 refinamentos por IA
                const passing = await generatePassingTitlesWithRefine({
                    apiFunc: cfg.apiFunc,
                    apiKey: cfg.apiKey,
                    model: cfg.model,
                    serviceName,
                    basePromptBuilder: buildTitleRefinePrompt,
                    buildArgs: {
                        originalTitle: videoDetails.title,
                        translatedTitle,
                        performanceContext,
                        descriptionStart: videoDetails.description ? videoDetails.description.substring(0, 300) : 'N/A',
                        transcriptStart: transcriptText ? transcriptText.substring(0, 500) : '(Transcri√ß√£o n√£o dispon√≠vel)',
                        languageInstruction
                    },
                    titlesRequired,
                    minImpact: MIN_IMPACT_SCORE,
                    maxRefines: 2
                });

                // N√£o falhar: adicionar o que passou (>=7) e seguir; depois tentamos preencher o total at√© 15.
                console.log(`[An√°lise Multimodal] ${serviceName}: ${passing.length}/${titlesRequired} t√≠tulos aprovados (Impacto >= ${MIN_IMPACT_SCORE})`);
                passing.forEach(t => allGeneratedTitles.push({ ...t, model: serviceName }));
            }
            
            if (!firstSuccessfulAnalysis) throw new Error("Todas as IAs falharam em retornar uma an√°lise v√°lida.");

            // Se alguma IA n√£o conseguiu 5, tentar preencher at√© 15 usando as IAs que funcionaram
            const targetTotal = titlesRequired * 3; // 15
            const maxFillRounds = 3; // no m√°ximo 3 rodadas extras para preencher
            let fillRound = 0;
            while (allGeneratedTitles.length < targetTotal && fillRound < maxFillRounds) {
                const remaining = targetTotal - allGeneratedTitles.length;
                // Preferir IAs que j√° responderam (mant√©m consist√™ncia)
                for (const cfg of serviceConfigs) {
                    if (allGeneratedTitles.length >= targetTotal) break;
                    const needNow = Math.min(remaining, titlesRequired);
                    const avoidAll = allGeneratedTitles.map(t => t.titulo);
                    try {
                        const more = await generatePassingTitlesWithRefine({
                            apiFunc: cfg.apiFunc,
                            apiKey: cfg.apiKey,
                            model: cfg.model,
                            serviceName: cfg.name,
                            basePromptBuilder: buildTitleRefinePrompt,
                            buildArgs: {
                                originalTitle: videoDetails.title,
                                translatedTitle,
                                performanceContext,
                                descriptionStart: videoDetails.description ? videoDetails.description.substring(0, 300) : 'N/A',
                                transcriptStart: transcriptText ? transcriptText.substring(0, 500) : '(Transcri√ß√£o n√£o dispon√≠vel)',
                                languageInstruction,
                                avoidTitles: avoidAll
                            },
                            titlesRequired: needNow,
                            minImpact: MIN_IMPACT_SCORE,
                            maxRefines: 2
                        });
                        more.forEach(t => allGeneratedTitles.push({ ...t, model: cfg.name }));
                    } catch (e) {
                        console.warn(`[An√°lise Multimodal] N√£o foi poss√≠vel preencher com ${cfg.name}:`, e.message);
                    }
                }
                fillRound++;
            }

            // Garantia: n√£o exceder 15
            if (allGeneratedTitles.length > targetTotal) {
                allGeneratedTitles = allGeneratedTitles.slice(0, targetTotal);
            }
            
            // Verificar se a an√°lise tem os dados necess√°rios
            if (!firstSuccessfulAnalysis.analiseOriginal) {
                throw new Error("A IA retornou uma an√°lise incompleta. Verifique as chaves de API e tente novamente.");
            }
            
            // Log final do total de t√≠tulos multimodal
            console.log(`[An√°lise Multimodal] ‚úÖ Total combinado: ${allGeneratedTitles.length} t√≠tulos (esperado: 15 = 5 de cada modelo)`);
            
            // Garantir que o nicho sempre existe (usar padr√£o se n√£o detectado)
            // Preencher nicho/subnicho + an√°lise do t√≠tulo original pelo backend (n√£o depender da IA)
            const derivedNiche = deriveNicheAndSubnicheFromContext({
                originalTitle: videoDetails.title,
                translatedTitle,
                descriptionStart: videoDetails.description ? videoDetails.description.substring(0, 300) : '',
                transcriptStart: transcriptText || ''
            });
            finalNicheData = derivedNiche;
            finalAnalysisData = deriveTitleAnalysis({
                originalTitle: videoDetails.title,
                translatedTitle,
                views: videoDetails.views,
                days: videoDetails.days
            });
        } else {
            // --- L√ìGICA DE MODELO √öNICO (opcionalmente laozhang) ---
            let service;
            let decryptedKey;
            let apiCallFunction;
            let useLaozhang = false;
            
            // Verificar se laozhang est√° como padr√£o
            try {
                const laozhangDefaultSetting = await db.get("SELECT value FROM app_settings WHERE key = 'laozhang_use_as_default'");
                const laozhangUseAsDefault = laozhangDefaultSetting && (
                    laozhangDefaultSetting.value === 'true' || 
                    laozhangDefaultSetting.value === '1' ||
                    JSON.parse(laozhangDefaultSetting.value) === true
                );
                
                if (laozhangUseAsDefault) {
                    const laozhangKey = await getLaozhangApiKey();
                    if (laozhangKey) {
                        service = 'laozhang';
                        decryptedKey = laozhangKey;
                        apiCallFunction = callLaozhangAPI;
                        useLaozhang = true;
                        console.log('[An√°lise-Laozhang.ai] Usando Laozhang.ai como padr√£o (configura√ß√£o do admin)');
                    }
                }
            } catch (err) {
                console.warn('[An√°lise] Erro ao verificar laozhang.ai:', err.message);
            }
            
            // Prefer√™ncia do usu√°rio por cr√©ditos -> laozhang
            if (!useLaozhang) {
                const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
                const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
                if (useCredits) {
                    const laozhangKey = await getLaozhangApiKey();
                    if (laozhangKey) {
                        service = 'laozhang';
                        decryptedKey = laozhangKey;
                        apiCallFunction = callLaozhangAPI;
                        useLaozhang = true;
                        console.log('[An√°lise-Laozhang.ai] Usando Laozhang.ai (prefer√™ncia: usar cr√©ditos)');
                    }
                }
            }
            
            // Caso contr√°rio, usar API pr√≥pria do usu√°rio
            if (!useLaozhang) {
                if (model.startsWith('gemini')) service = 'gemini';
                else if (model.startsWith('claude')) service = 'claude';
                else if (model.startsWith('gpt')) service = 'openai';
                else service = 'gemini'; // fallback
                
                const userKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                if (!userKeyData) return res.status(400).json({ msg: `Nenhuma Chave de API do ${service} configurada.` });
                
                decryptedKey = decrypt(userKeyData.api_key);
                if (!decryptedKey) return res.status(500).json({ msg: 'Falha ao desencriptar a sua chave de API.' });

                if (service === 'gemini') apiCallFunction = callGeminiAPI;
                else if (service === 'claude') apiCallFunction = callClaudeAPI;
                else apiCallFunction = callOpenAIAPI;
            }

            // --- ETAPA 2: Chamar API selecionada (√∫nico modelo) ---
            let apiResponse;
            let rawResponse;
            console.log(`[An√°lise] Chamando ${useLaozhang ? 'Laozhang.ai' : service} com modelo ${model}...`);
            
            if (service === 'laozhang') {
                apiResponse = await apiCallFunction(titlePrompt, decryptedKey, model, null, userId, '/api/analyze/titles', JSON.stringify({ endpoint: '/api/analyze/titles', model, operation: 'single' }));
                rawResponse = typeof apiResponse === 'string' ? apiResponse : (apiResponse.titles || JSON.stringify(apiResponse));
            } else {
                apiResponse = await apiCallFunction(titlePrompt, decryptedKey, model);
                rawResponse = typeof apiResponse === 'string' ? apiResponse : apiResponse.titles;
            }
            
            console.log('[An√°lise] Resposta bruta (primeiros 500 chars):', String(rawResponse || '').substring(0, 500));
            
            // --- ETAPA 2.1: Extrair dados da resposta ---
            let parsedData;
            try {
                parsedData = parseTitleAnalysisResponse(rawResponse, service === 'laozhang' ? 'Laozhang.ai' : service, titlesRequired);
            } catch (parseErr) {
                console.error('[An√°lise] Erro ao parsear resposta:', parseErr.message);
                throw new Error('A resposta da IA n√£o est√° no formato esperado.');
            }
            
            // Verificar se h√° t√≠tulos sugeridos
            if (!parsedData.titulosSugeridos || parsedData.titulosSugeridos.length === 0) {
                throw new Error('A IA n√£o retornou t√≠tulos sugeridos.');
            }
            
            // Registrar t√≠tulos (SCORE 2 por backend) + gate Impacto>=7 com at√© 3 refinamentos
            const MIN_IMPACT_SCORE = 7;
            const passing = await generatePassingTitlesWithRefine({
                apiFunc: apiCallFunction,
                apiKey: decryptedKey,
                model,
                serviceName: service === 'laozhang' ? 'Laozhang.ai' : service,
                basePromptBuilder: buildTitleRefinePrompt,
                buildArgs: {
                    originalTitle: videoDetails.title,
                    translatedTitle,
                    performanceContext,
                    descriptionStart: videoDetails.description ? videoDetails.description.substring(0, 300) : 'N/A',
                    transcriptStart: transcriptText ? transcriptText.substring(0, 500) : '(Transcri√ß√£o n√£o dispon√≠vel)',
                    languageInstruction
                },
                titlesRequired,
                minImpact: MIN_IMPACT_SCORE,
                maxRefines: 2
            });
            if (passing.length < titlesRequired) {
                throw new Error(`N√£o foi poss√≠vel gerar ${titlesRequired} t√≠tulos com üî• Impacto ‚â• ${MIN_IMPACT_SCORE}/10. Tente novamente.`);
            }

            allGeneratedTitles = passing.map(t => ({
                ...t,
                model: service === 'laozhang' ? 'Laozhang.ai' : model
            }));
            
            // Garantir que analiseOriginal existe
            if (!parsedData.analiseOriginal) {
                parsedData.analiseOriginal = {
                    motivoSucesso: 'Motivo n√£o fornecido',
                    formulaTitulo: 'F√≥rmula n√£o fornecida'
                };
            }
            
            const derivedNiche = deriveNicheAndSubnicheFromContext({
                originalTitle: videoDetails.title,
                translatedTitle,
                descriptionStart: videoDetails.description ? videoDetails.description.substring(0, 300) : '',
                transcriptStart: transcriptText || ''
            });
            finalNicheData = derivedNiche;
            finalAnalysisData = deriveTitleAnalysis({
                originalTitle: videoDetails.title,
                translatedTitle,
                views: videoDetails.views,
                days: videoDetails.days
            });
        }
        // --- FIM DA L√ìGICA DO DISTRIBUIDOR ---

        // Log final: verificar quantos t√≠tulos foram gerados no total
        console.log(`[An√°lise] ‚úÖ Total de t√≠tulos gerados: ${allGeneratedTitles.length}`);
        const titlesByModelFinal = {};
        allGeneratedTitles.forEach(t => {
            const model = t.model || 'Desconhecido';
            titlesByModelFinal[model] = (titlesByModelFinal[model] || 0) + 1;
        });
        console.log(`[An√°lise] T√≠tulos por modelo antes de salvar:`, titlesByModelFinal);
        
        console.log('[An√°lise] T√≠tulos gerados com sucesso.');

        // --- ETAPA 3: Salvar no Banco de Dados ---
        let analysisId;
        try {
             const analysisResult = await db.run(
                `INSERT INTO analyzed_videos (user_id, folder_id, youtube_video_id, video_url, original_title, translated_title, original_views, original_comments, original_days, original_thumbnail_url, detected_niche, detected_subniche, analysis_data_json, full_transcript) 
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                    userId, folderId || null, videoId, videoUrl, videoDetails.title, translatedTitle, videoDetails.views,
                    videoDetails.comments, videoDetails.days, videoDetails.thumbnailUrl,
                    finalNicheData.niche, finalNicheData.subniche, JSON.stringify(finalAnalysisData), fullTranscript
                ]
            );
            analysisId = analysisResult.lastID;

            console.log(`[An√°lise] Salvando ${allGeneratedTitles.length} t√≠tulos no banco de dados...`);
            console.log(`[An√°lise] Detalhes dos t√≠tulos a serem salvos:`, allGeneratedTitles.map(t => ({ model: t.model, titulo: t.titulo?.substring(0, 50) })));
            
            let savedCount = 0;
            for (const titleData of allGeneratedTitles) {
                try {
                    await db.run(
                        'INSERT INTO generated_titles (video_analysis_id, title_text, model_used, pontuacao, impact_score, explicacao, formula) VALUES (?, ?, ?, ?, ?, ?, ?)',
                        [analysisId, titleData.titulo, titleData.model, titleData.pontuacao, titleData.impact_score ?? null, titleData.explicacao, titleData.formula ?? null]
                    );
                    savedCount++;
                } catch (saveErr) {
                    console.error(`[An√°lise] Erro ao salvar t√≠tulo:`, saveErr.message, titleData);
                }
            }
            
            // Verificar quantos t√≠tulos foram salvos
            const savedTitles = await db.all('SELECT model_used, COUNT(*) as count FROM generated_titles WHERE video_analysis_id = ? GROUP BY model_used', [analysisId]);
            console.log(`[An√°lise] Total de t√≠tulos salvos: ${savedCount} de ${allGeneratedTitles.length}`);
            console.log(`[An√°lise] T√≠tulos salvos por modelo:`, savedTitles);
            console.log(`[An√°lise] An√°lise ${analysisId} salva no hist√≥rico (Pasta: ${folderId || 'Nenhuma'}).`);
        } catch (dbErr) {
            console.error("[An√°lise] FALHA AO SALVAR NO BANCO DE DADOS:", dbErr.message);
        }

        // --- ETAPA 4: Calcular Receita e RPM baseado no nicho ---
        let estimatedRevenueUSD = 0;
        let estimatedRevenueBRL = 0;
        let rpmUSD = 2.0;
        let rpmBRL = 11.0;
        
        try {
            // Calcular receita e RPM sempre, mesmo se o nicho n√£o foi detectado
            const nicheToUse = (finalNicheData && finalNicheData.niche) ? finalNicheData.niche : null;
            const rpm = getRPMByNiche(nicheToUse); // getRPMByNiche retorna padr√£o se niche for null
            
            // Verificar se rpm foi retornado corretamente
            if (!rpm || typeof rpm !== 'object' || typeof rpm.usd !== 'number' || typeof rpm.brl !== 'number') {
                console.warn('[An√°lise] RPM inv√°lido, usando valores padr√£o', { rpm, niche: nicheToUse });
                // Usar valores padr√£o se rpm for inv√°lido
                const defaultRPM = { usd: 2.0, brl: 11.0 };
                const views = parseInt(videoDetails.views) || 0;
                estimatedRevenueUSD = (views / 1000) * defaultRPM.usd;
                estimatedRevenueBRL = (views / 1000) * defaultRPM.brl;
                rpmUSD = defaultRPM.usd;
                rpmBRL = defaultRPM.brl;
            } else {
                const views = parseInt(videoDetails.views) || 0;
                estimatedRevenueUSD = (views / 1000) * rpm.usd;
                estimatedRevenueBRL = (views / 1000) * rpm.brl;
                rpmUSD = rpm.usd;
                rpmBRL = rpm.brl;
            }
            
            // Garantir que todas as vari√°veis est√£o definidas e s√£o n√∫meros v√°lidos
            if (typeof estimatedRevenueUSD !== 'number' || isNaN(estimatedRevenueUSD)) {
                console.warn('[An√°lise] estimatedRevenueUSD inv√°lido, recalculando', { estimatedRevenueUSD, rpm, views: videoDetails.views });
                const views = parseInt(videoDetails.views) || 0;
                estimatedRevenueUSD = (views / 1000) * rpm.usd;
                estimatedRevenueBRL = (views / 1000) * rpm.brl;
            }
            
            console.log('[An√°lise] Receita calculada:', {
                views: videoDetails.views,
                niche: nicheToUse || 'padr√£o',
                rpmUSD,
                rpmBRL,
                estimatedRevenueUSD: estimatedRevenueUSD.toFixed(2),
                estimatedRevenueBRL: estimatedRevenueBRL.toFixed(2)
            });
        } catch (revenueErr) {
            console.error('[An√°lise] Erro ao calcular receita:', revenueErr);
            // Usar valores padr√£o em caso de erro
            const views = parseInt(videoDetails.views) || 0;
            estimatedRevenueUSD = (views / 1000) * 2.0;
            estimatedRevenueBRL = (views / 1000) * 11.0;
            rpmUSD = 2.0;
            rpmBRL = 11.0;
        }

        // --- ETAPA 5: Enviar Resposta (com IDs dos t√≠tulos, receita e RPM) ---
        const finalTitlesWithIds = await db.all('SELECT id, title_text as titulo, model_used as model, pontuacao, impact_score, explicacao, formula, is_checked FROM generated_titles WHERE video_analysis_id = ?', [analysisId]);

        // N√ÉO salvar automaticamente - apenas quando o usu√°rio marcar o checkbox
        // O salvamento ser√° feito quando o usu√°rio marcar o t√≠tulo como selecionado
        console.log(`[Biblioteca] T√≠tulos gerados aguardando sele√ß√£o do usu√°rio para salvar na biblioteca`);
        
        // Garantir que todas as vari√°veis est√£o definidas antes de enviar
        // Formatar modelo para exibi√ß√£o se necess√°rio
        const formatModelForResponse = (modelName) => {
            if (!modelName) return 'GPT-4o';
            if (modelName === 'GPT-4o (2025)' || modelName === 'Claude 3.7 Sonnet (Fev/25)' || modelName === 'Gemini 2.5 Pro (2025)') {
                return modelName.replace(' (2025)', '').replace(' (Fev/25)', '');
            }
            if (modelName.includes('claude-3-7-sonnet') || modelName.includes('Claude 3.7 Sonnet')) {
                return 'Claude 3.7 Sonnet';
            } else if (modelName.includes('gemini-2.5-pro') || modelName.includes('Gemini 2.5 Pro')) {
                return 'Gemini 2.5 Pro';
            } else if (modelName.includes('gpt-4o') || modelName.includes('GPT-4o')) {
                return 'GPT-4o';
            }
            return modelName;
        };
        
        // Garantir que os t√≠tulos do banco tenham o modelo formatado corretamente
        const formattedTitles = (finalTitlesWithIds || []).map(t => ({
            ...t,
            model: formatModelForResponse(t.model || model)
        }));
        
        const responseData = {
            niche: finalNicheData?.niche || 'N/A',
            subniche: finalNicheData?.subniche || 'N/A',
            analiseOriginal: finalAnalysisData || {},
            titulosSugeridos: formattedTitles,
            modelUsed: formatModelForResponse(model) || 'GPT-4o', 
            videoDetails: { 
                ...videoDetails, 
                videoId: videoId, 
                originalTitle: videoDetails.title, // T√≠tulo original no idioma original
                translatedTitle: translatedTitle || videoDetails.title, // Tradu√ß√£o em PT-BR (sempre dispon√≠vel)
                estimatedRevenueUSD: typeof estimatedRevenueUSD === 'number' ? estimatedRevenueUSD : 0,
                estimatedRevenueBRL: typeof estimatedRevenueBRL === 'number' ? estimatedRevenueBRL : 0,
                rpmUSD: typeof rpmUSD === 'number' ? rpmUSD : 2.0,
                rpmBRL: typeof rpmBRL === 'number' ? rpmBRL : 11.0
            },
            language: language, // Idioma escolhido para os t√≠tulos gerados
            folderId: folderId || null
        };
        
        // Log para debug
        console.log('[An√°lise] Enviando resposta:', {
            hasEstimatedRevenueUSD: typeof responseData.videoDetails.estimatedRevenueUSD !== 'undefined',
            estimatedRevenueUSD: responseData.videoDetails.estimatedRevenueUSD,
            hasRpmUSD: typeof responseData.videoDetails.rpmUSD !== 'undefined',
            rpmUSD: responseData.videoDetails.rpmUSD
        });

        res.status(200).json(responseData);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/analyze/titles]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao processar a an√°lise.' });
    }
});

// Rota alternativa que SEMPRE usa Laozhang.ai para an√°lise de t√≠tulos
app.post('/api/analyze/titles/laozhang', authenticateToken, async (req, res) => {
    const { videoUrl, model: requestedModel, folderId, language } = req.body;
    const userId = req.user.id;
    const selectedLanguage = language || 'Portugu√™s'; // Idioma padr√£o: Portugu√™s
    
    // Garantir que modelToUse seja o modelo original do frontend para exibi√ß√£o
    const modelToUse = requestedModel || 'gpt-4o';

    if (!videoUrl) {
        return res.status(400).json({ msg: 'URL do v√≠deo √© obrigat√≥ria.' });
    }
    
    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel. Aguarde alguns instantes.' });
        }

        // Determinar qual modelo usar (se especificado, usar ele; sen√£o, usar gpt-4o como padr√£o)
        let modelToUse = requestedModel || 'gpt-4o';
        // Mapear modelos para os nomes corretos da laozhang.ai
        if (modelToUse === 'gpt-4o') {
            modelToUse = 'gpt-4o';
        } else if (modelToUse === 'claude-3-7-sonnet-20250219') {
            modelToUse = 'claude-3-7-sonnet-20250219';
        } else if (modelToUse === 'gemini-2.5-pro') {
            modelToUse = 'gemini-2.5-pro';
        }

        // Verificar se deve usar cr√©ditos (laozhang.ai) ou API pr√≥pria
        // REGRA: Usa cr√©ditos se usu√°rio marcou prefer√™ncia OU n√£o tem plano que permite API pr√≥pria OU n√£o tem API pr√≥pria configurada
        // REGRA CR√çTICA: Se prefer√™ncia N√ÉO est√° marcada E usu√°rio tem plano que permite E tem API pr√≥pria ‚Üí usar API pr√≥pria
        let useLaozhang = false;
        let apiKeyToUse = null;
        let serviceToUse = null;
        let apiCallFunction = null;
        
        try {
            const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
            
            if (creditsCheck.shouldUse) {
                // Se deve usar cr√©ditos, usar laozhang.ai
                const laozhangKey = await getLaozhangApiKey();
                if (laozhangKey) {
                    useLaozhang = true;
                    apiKeyToUse = laozhangKey;
                    serviceToUse = 'laozhang';
                    apiCallFunction = callLaozhangAPI;
                    console.log(`[An√°lise Laozhang] ‚úÖ Usando Laozhang.ai (${creditsCheck.reason})`);
                } else {
                    console.warn('[An√°lise Laozhang] ‚ö†Ô∏è Laozhang.ai n√£o configurada, tentando usar APIs pr√≥prias do usu√°rio');
                }
            } else {
                console.log(`[An√°lise Laozhang] ‚úÖ Usando API pr√≥pria (${creditsCheck.reason})`);
            }
        } catch (err) {
            console.warn('[An√°lise Laozhang] Erro ao verificar uso de cr√©ditos:', err.message);
        }
        
        // Se n√£o usar laozhang.ai, usar APIs pr√≥prias do usu√°rio
        if (!useLaozhang) {
            // Determinar qual servi√ßo usar baseado no modelo
            if (modelToUse.includes('claude') || modelToUse.includes('sonnet')) {
                serviceToUse = 'claude';
            } else if (modelToUse.includes('gemini')) {
                serviceToUse = 'gemini';
            } else if (modelToUse.includes('gpt') || modelToUse.includes('openai')) {
                serviceToUse = 'openai';
            } else {
                serviceToUse = 'gemini'; // fallback
            }
            
            // Buscar API key do servi√ßo apropriado
            const keyData = await db.get(
                'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                [userId, serviceToUse]
            );
            
            if (!keyData || !keyData.api_key) {
                return res.status(400).json({ 
                    msg: `API key do ${serviceToUse === 'openai' ? 'OpenAI' : serviceToUse === 'gemini' ? 'Gemini' : 'Claude'} n√£o configurada. Configure nas Configura√ß√µes.` 
                });
            }
            
            apiKeyToUse = decrypt(keyData.api_key);
            if (!apiKeyToUse) {
                return res.status(500).json({ msg: 'Erro ao descriptografar API key.' });
            }
            
            // Definir fun√ß√£o de API apropriada
            if (serviceToUse === 'gemini') {
                apiCallFunction = callGeminiAPI;
            } else if (serviceToUse === 'claude') {
                apiCallFunction = callClaudeAPI;
            } else {
                apiCallFunction = callOpenAIAPI;
            }
        }

        // Minera√ß√£o de dados (mesma l√≥gica da rota original)
        console.log(`[An√°lise Laozhang] A iniciar minera√ß√£o para: ${videoUrl}`);
        let videoId;
        try {
            videoId = ytdl.getVideoID(videoUrl);
        } catch (err) {
            return res.status(400).json({ msg: 'URL do YouTube inv√°lida.' });
        }

        // Tentar usar chave espec√≠fica do YouTube primeiro, depois fallback para Gemini
        let youtubeApiKey = null;
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
            if (!youtubeApiKey && youtubeKeyData.api_key && !youtubeKeyData.api_key.includes(':')) {
                // Chave pode n√£o estar criptografada
                youtubeApiKey = youtubeKeyData.api_key;
            }
            console.log('[An√°lise Laozhang] Usando chave do YouTube configurada');
        }
        
        // Se n√£o tem chave do YouTube, tentar usar Gemini (pode funcionar se for chave do Google Cloud)
        if (!youtubeApiKey) {
            const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
                if (!youtubeApiKey && geminiKeyData.api_key && !geminiKeyData.api_key.includes(':')) {
                    youtubeApiKey = geminiKeyData.api_key;
                }
                console.log('[An√°lise Laozhang] Usando chave do Gemini como fallback para YouTube');
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ 
                msg: 'Nenhuma chave de API do YouTube configurada. Configure uma chave do YouTube Data API v3 nas Configura√ß√µes.' 
            });
        }

        const videoDetails = await callYouTubeDataAPI(videoId, youtubeApiKey);
        
        let transcriptText;
        let fullTranscript = null;
        try {
            const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
            fullTranscript = transcriptData.map(t => t.text).join(' ');
            transcriptText = fullTranscript.substring(0, 500);
        } catch (err) {
            console.warn(`[An√°lise Laozhang] N√£o foi poss√≠vel obter transcri√ß√£o para ${videoId}.`);
            transcriptText = "(Transcri√ß√£o n√£o dispon√≠vel)";
            fullTranscript = null;
        }
        
        console.log(`[An√°lise Laozhang] V√≠deo encontrado: ${videoDetails.title}`);

        // Tradu√ß√£o: para evitar requisi√ß√µes duplicadas ao provedor, usar o t√≠tulo original diretamente
        // Se desejar tradu√ß√£o, podemos incluir no mesmo prompt de an√°lise futuramente
        let translatedTitle = videoDetails.title;

        // Criar prompt de an√°lise (mesmo da rota original, mas simplificado para laozhang)
        const viewsPerDay = Math.round(videoDetails.views / Math.max(videoDetails.days, 1));
        const isViral = isViralVideo(videoDetails.views, videoDetails.days, viewsPerDay);
        
        const languageInstruction = selectedLanguage === 'Portugu√™s' ? 'EM PORTUGU√äS BRASILEIRO (PT-BR)' : selectedLanguage === 'Ingl√™s' ? 'EM INGL√äS (EN)' : selectedLanguage === 'Espanhol' ? 'EM ESPANHOL (ES)' : 'EM PORTUGU√äS BRASILEIRO (PT-BR)';
        const titlesRequired = 5;
        const MIN_IMPACT_SCORE = 7;
        const performanceContext = `Este v√≠deo tem ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias (m√©dia de ${viewsPerDay.toLocaleString()} views/dia) e foi classificado como ${isViral ? 'VIRAL' : 'Popular'}.`;
        const titlePrompt = buildTitleRefinePrompt({
            originalTitle: videoDetails.title,
            translatedTitle,
            performanceContext,
            descriptionStart: 'N/A',
            transcriptStart: transcriptText ? transcriptText.substring(0, 500) : '(Transcri√ß√£o n√£o dispon√≠vel)',
            languageInstruction,
            titlesRequired,
            minImpact: MIN_IMPACT_SCORE
        });

        // Chamar API apropriada (Laozhang ou API pr√≥pria)
        let response;
        let responseText;
        
        if (useLaozhang) {
            console.log('[An√°lise Laozhang] A chamar Laozhang.ai...');
            response = await callLaozhangAPI(
                titlePrompt, 
                apiKeyToUse, 
                modelToUse, 
                null, 
                userId, 
                '/api/analyze/titles/laozhang', 
                JSON.stringify({ endpoint: '/api/analyze/titles/laozhang', model: modelToUse })
            );
            // callLaozhangAPI retorna string diretamente agora
            responseText = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        } else {
            console.log(`[An√°lise Laozhang] A chamar API pr√≥pria (${serviceToUse})...`);
            const apiResponse = await apiCallFunction(titlePrompt, apiKeyToUse, modelToUse);
            // APIs pr√≥prias retornam objeto com propriedade titles
            responseText = typeof apiResponse === 'string' ? apiResponse.trim() : (apiResponse.titles || JSON.stringify(apiResponse));
        }
        console.log(`[An√°lise Laozhang] Resposta recebida (primeiros 500 chars):`, responseText.substring(0, 500));
        const serviceNameForParse = useLaozhang ? 'Laozhang.ai' : (serviceToUse === 'openai' ? 'OpenAI' : serviceToUse === 'claude' ? 'Claude' : 'Gemini');
        const parsedData = parseTitleAnalysisResponse(responseText, serviceNameForParse, 5);
        const passing = await generatePassingTitlesWithRefine({
            apiFunc: apiCallFunction,
            apiKey: apiKeyToUse,
            model: modelToUse,
            serviceName: serviceNameForParse,
            basePromptBuilder: buildTitleRefinePrompt,
            buildArgs: {
                originalTitle: videoDetails.title,
                translatedTitle,
                performanceContext,
                descriptionStart: 'N/A',
                transcriptStart: transcriptText ? transcriptText.substring(0, 500) : '(Transcri√ß√£o n√£o dispon√≠vel)',
                languageInstruction
            },
            titlesRequired,
            minImpact: MIN_IMPACT_SCORE,
            maxRefines: 2
        });
        if (passing.length < titlesRequired) throw new Error(`N√£o foi poss√≠vel gerar ${titlesRequired} t√≠tulos com üî• Impacto ‚â• ${MIN_IMPACT_SCORE}/10. Tente novamente.`);
        
        if (!parsedData.analiseOriginal) {
            throw new Error("A IA retornou uma an√°lise incompleta.");
        }
        
        const finalNicheData = { 
            niche: parsedData.niche || 'Entretenimento', 
            subniche: parsedData.subniche || 'N/A' 
        };
        const finalAnalysisData = parsedData.analiseOriginal;
        // Fun√ß√£o para formatar modelo do frontend para exibi√ß√£o
        const formatModelForDisplay = (modelName) => {
            if (!modelName) return 'GPT-4o';
            // Se j√° est√° no formato de exibi√ß√£o do frontend, retornar formatado
            if (modelName === 'GPT-4o (2025)' || modelName === 'Claude 3.7 Sonnet (Fev/25)' || modelName === 'Gemini 2.5 Pro (2025)') {
                return modelName.replace(' (2025)', '').replace(' (Fev/25)', '');
            }
            // Mapear formatos t√©cnicos para nomes amig√°veis
            if (modelName.includes('claude-3-7-sonnet') || modelName.includes('Claude 3.7 Sonnet')) {
                return 'Claude 3.7 Sonnet';
            } else if (modelName.includes('gemini-2.5-pro') || modelName.includes('Gemini 2.5 Pro')) {
                return 'Gemini 2.5 Pro';
            } else if (modelName.includes('gpt-4o') || modelName.includes('GPT-4o')) {
                return 'GPT-4o';
            } else if (modelName.includes('claude')) {
                return 'Claude 3.7 Sonnet';
            } else if (modelName.includes('gemini')) {
                return 'Gemini 2.5 Pro';
            } else if (modelName.includes('gpt')) {
                return 'GPT-4o';
            }
            return modelName;
        };
        
        // Usar o modelo original do frontend (modelToUse) para exibi√ß√£o, n√£o o mapeado para API
        // modelToUse vem do req.body.model que √© o modelo selecionado no frontend
        const modelNameForDisplay = formatModelForDisplay(modelToUse);
        console.log(`[An√°lise Laozhang] Modelo para exibi√ß√£o: "${modelToUse}" -> Formatado: "${modelNameForDisplay}"`);
        const allGeneratedTitles = passing.map(t => ({
            ...t,
            impact_score: computeImpactVisualScore(t.titulo),
            model: modelNameForDisplay
        }));

        // Salvar no banco
        let analysisId;
        try {
             const analysisResult = await db.run(
                `INSERT INTO analyzed_videos (user_id, folder_id, youtube_video_id, video_url, original_title, translated_title, original_views, original_comments, original_days, original_thumbnail_url, detected_niche, detected_subniche, analysis_data_json, full_transcript) 
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                    userId, folderId || null, videoId, videoUrl, videoDetails.title, translatedTitle, videoDetails.views,
                    videoDetails.comments, videoDetails.days, videoDetails.thumbnailUrl,
                    finalNicheData.niche, finalNicheData.subniche, JSON.stringify(finalAnalysisData), fullTranscript
                ]
            );
            analysisId = analysisResult.lastID;

            for (const titleData of allGeneratedTitles) {
                await db.run(
                    'INSERT INTO generated_titles (video_analysis_id, title_text, model_used, pontuacao, impact_score, explicacao, formula) VALUES (?, ?, ?, ?, ?, ?, ?)',
                    [analysisId, titleData.titulo, titleData.model, titleData.pontuacao, titleData.impact_score ?? null, titleData.explicacao, titleData.formula ?? null]
                );
            }
            console.log(`[An√°lise Laozhang] An√°lise ${analysisId} salva no hist√≥rico.`);
        } catch (dbErr) {
            console.error("[An√°lise Laozhang] FALHA AO SALVAR NO BANCO DE DADOS:", dbErr.message);
        }

        // Calcular receita (mesma l√≥gica)
        let estimatedRevenueUSD = 0;
        let estimatedRevenueBRL = 0;
        let rpmUSD = 2.0;
        let rpmBRL = 11.0;
        
        try {
            const nicheToUse = finalNicheData.niche || null;
            const rpm = getRPMByNiche(nicheToUse);
            if (rpm && typeof rpm === 'object' && typeof rpm.usd === 'number' && typeof rpm.brl === 'number') {
                const views = parseInt(videoDetails.views) || 0;
                estimatedRevenueUSD = (views / 1000) * rpm.usd;
                estimatedRevenueBRL = (views / 1000) * rpm.brl;
                rpmUSD = rpm.usd;
                rpmBRL = rpm.brl;
            }
        } catch (err) {
            console.warn('[An√°lise Laozhang] Erro ao calcular receita:', err);
        }

        res.status(200).json({
            niche: finalNicheData.niche,
            subniche: finalNicheData.subniche,
            analiseOriginal: finalAnalysisData,
            titulosSugeridos: allGeneratedTitles,
            modelUsed: modelNameForDisplay || 'GPT-4o',
            videoDetails: {
                ...videoDetails,
                videoId: videoId,
                originalTitle: videoDetails.title, // T√≠tulo original no idioma original
                translatedTitle: translatedTitle || videoDetails.title, // Tradu√ß√£o em PT-BR (sempre dispon√≠vel)
                estimatedRevenueUSD: estimatedRevenueUSD,
                estimatedRevenueBRL: estimatedRevenueBRL,
                rpmUSD: rpmUSD,
                rpmBRL: rpmBRL
            },
            language: selectedLanguage, // Idioma escolhido para os t√≠tulos gerados
            folderId: folderId || null
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/analyze/titles/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao processar a an√°lise.' });
    }
});

app.put('/api/titles/:titleId/check', authenticateToken, async (req, res) => {
    const { titleId } = req.params;
    const { is_checked } = req.body;
    const userId = req.user.id;

    try {
        console.log(`[Biblioteca] Recebida requisi√ß√£o para atualizar t√≠tulo ${titleId}, is_checked: ${is_checked}, userId: ${userId}`);
        
        // Buscar informa√ß√µes do t√≠tulo antes de atualizar
        const titleData = await db.get(`
            SELECT gt.id, gt.title_text, gt.pontuacao, gt.impact_score, gt.video_analysis_id, av.detected_niche, av.detected_subniche, av.original_views, av.analysis_data_json
            FROM generated_titles gt
            INNER JOIN analyzed_videos av ON gt.video_analysis_id = av.id
            WHERE gt.id = ? AND av.user_id = ?
        `, [titleId, userId]);

        if (!titleData) {
            console.error(`[Biblioteca] T√≠tulo ${titleId} n√£o encontrado para usu√°rio ${userId}`);
            return res.status(404).json({ msg: 'T√≠tulo n√£o encontrado ou n√£o pertence a este utilizador.' });
        }
        
        console.log(`[Biblioteca] Dados do t√≠tulo encontrado:`, {
            id: titleData.id,
            title: titleData.title_text?.substring(0, 50),
            niche: titleData.detected_niche,
            subniche: titleData.detected_subniche,
            views: titleData.original_views,
            score: titleData.pontuacao
        });

        // Atualiza o status do t√≠tulo espec√≠fico
        const result = await db.run(
            `UPDATE generated_titles SET is_checked = ? 
             WHERE id = ? AND video_analysis_id IN (SELECT id FROM analyzed_videos WHERE user_id = ?)`,
            [is_checked, titleId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'T√≠tulo n√£o encontrado ou n√£o pertence a este utilizador.' });
        }

        // Se o t√≠tulo foi marcado (is_checked = true), salvar na biblioteca
        if (is_checked) {
            try {
                console.log(`[Biblioteca] Tentando salvar t√≠tulo marcado: ${titleId} para usu√°rio ${userId}`);
                const cleanTitle = titleData.title_text.replace(/^\[.*?\]\s*/, ''); // Remove prefixo [Gemini], [Claude], etc
                const analysisData = titleData.analysis_data_json ? JSON.parse(titleData.analysis_data_json) : null;
                
                console.log(`[Biblioteca] T√≠tulo limpo: "${cleanTitle.substring(0, 50)}..."`);
                console.log(`[Biblioteca] Dados:`, {
                    niche: titleData.detected_niche,
                    subniche: titleData.detected_subniche,
                    views: titleData.original_views,
                    score: titleData.pontuacao,
                    formula: analysisData?.formulaTitulo || null
                });
                
                // Verificar se j√° existe na biblioteca para evitar duplicatas
                const existing = await db.get(
                    'SELECT id FROM viral_titles_library WHERE user_id = ? AND title = ?',
                    [userId, cleanTitle]
                );

                if (existing) {
                    console.log(`[Biblioteca] T√≠tulo j√° existe na biblioteca (ID: ${existing.id}), pulando inser√ß√£o`);
                } else {
                    const result = await db.run(
                        `INSERT INTO viral_titles_library (user_id, title, niche, subniche, original_views, formula_type, viral_score)
                         VALUES (?, ?, ?, ?, ?, ?, ?)`,
                        [userId, cleanTitle, titleData.detected_niche, titleData.detected_subniche, titleData.original_views, analysisData?.formulaTitulo || null, titleData.pontuacao || null]
                    );
                    console.log(`[Biblioteca] ‚úÖ T√≠tulo "${cleanTitle.substring(0, 50)}..." salvo na biblioteca (ID: ${result.lastID})`);
                }
            } catch (libErr) {
                console.error('[Biblioteca] ‚ùå Erro ao salvar t√≠tulo marcado na biblioteca:', libErr);
                console.error('[Biblioteca] Stack trace:', libErr.stack);
            }
        } else {
            console.log(`[Biblioteca] T√≠tulo ${titleId} foi desmarcado, n√£o ser√° salvo na biblioteca`);
        }

        res.status(200).json({ msg: 'Status do t√≠tulo atualizado.' });
    } catch (err) {
        console.error('Erro ao atualizar status do t√≠tulo:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});
// Fun√ß√£o helper para mapear estilos de arte para prompts espec√≠ficos otimizados (mesmos estilos de prompts e imagens)
function getStyleSpecificPrompt(style, includePhrases) {
    // Mapear estilos do gerador de thumbnails para os estilos de prompts/imagens
    const styleMapping = {
        'Hiper-realista': 'photorealistic',
        'Fotografia de alta definicao (8K)': 'photorealistic',
        'Estilo cinematico (luz dramatica)': 'cinematic',
        'Foco nitido, alto detalhe': 'photorealistic',
        'Longa Exposicao': 'documentary',
        'Preto e Branco': 'documentary',
        'Fotografia Macro': 'photorealistic',
        'Diorama Cinematogr√°fico Narrativo': 'cinematic-diorama',
        'Cinematic Diorama': 'cinematic-diorama',
        'Diorama Narrativo': 'cinematic-diorama',
        'Narrativa Diorama': 'cinematic-diorama',
        'Realismo Miniaturizado': 'cinematic-diorama'
    };
    
    // Se o estilo j√° for um dos estilos de prompts/imagens, usar diretamente
    const mappedStyle = styleMapping[style] || style;
    
    // Usar os mesmos sufixos de estilo que s√£o usados em prompts/imagens
    const styleSuffixes = {
        'photorealistic': 'Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyperrealistic, ultra high definition, 8K resolution, extreme sharpness, maximum detail, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography, taken with a high-end camera like a Sony Œ±7 IV, detailed skin texture with pores visible in 8K, natural lighting, real textures with visible imperfections in ultra HD, real lighting with real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, extreme detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, National Geographic quality, BBC documentary style',
        'cinematic': 'Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, cinematic, dramatic lighting, film grain, anamorphic lens, color grading, movie still, Hollywood style, epic composition, dramatic shadows, professional color grading, cinematic composition, film noir lighting style, dramatic atmosphere',
        'documentary': 'Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, documentary style, natural lighting, authentic, candid photography, real moments, journalistic approach, raw and unfiltered',
        'cinematic-narrative': 'Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, cinematic narrative, storytelling composition, dramatic angles, emotional depth, visual storytelling, film photography',
        'anime': 'anime style, Japanese animation, vibrant colors, expressive characters, detailed backgrounds, manga-inspired, cel-shaded',
        'cartoon': 'cartoon style, animated, colorful, expressive, playful, hand-drawn aesthetic, vibrant palette',
        'cartoon-premium': 'premium cartoon style, high-quality animation, detailed character design, rich colors, professional animation studio quality',
        'fantasy': 'fantasy art, magical atmosphere, epic scale, mystical lighting, enchanted, otherworldly, detailed fantasy illustration',
        'stick-figure': 'stick figure style, minimalist line art, simple black lines on white background, clean and minimal',
        'whiteboard': 'whiteboard animation style, clean white background, hand-drawn illustrations, educational, clear and simple',
        'tech-minimalist': 'tech minimalist, clean design, modern aesthetic, geometric shapes, minimal color palette, futuristic, sleek',
        'spiritual-minimalist': 'spiritual minimalist, serene atmosphere, soft lighting, peaceful composition, meditative, zen aesthetic',
        'viral-vibrant': 'viral vibrant style, high contrast, saturated colors, bold composition, eye-catching, social media optimized, vibrant and energetic',
        'modern-documentary': 'modern documentary style, dynamic, contemporary, authentic moments, modern cinematography',
        'analog-horror': 'analog horror style, VHS quality, grainy texture, retro horror aesthetic, vintage feel',
        'dark-theater': 'dark theater style, dramatic stage lighting, intense shadows, theatrical composition',
        'naturalist-drama': 'naturalist drama style, realistic, emotional, authentic human moments',
        'spiritual-neorealism': 'spiritual neorealism style, transcendent realism, mystical atmosphere',
        'psychological-surrealism': 'psychological surrealism style, dreamlike images, abstract reality',
        'fragmented-memory': 'fragmented memory style, collage aesthetic, fragmented composition',
        'fragmented-narrative': 'fragmented narrative style, collage style, layered visual narrative',
        'dream-real': 'dream-real style, liminal space between dream and reality, ethereal atmosphere',
        'vhs-nostalgic': 'VHS nostalgic style, retro 80s/90s aesthetic, vintage quality, analog grain',
        'cinematic-diorama': 'Cinematic diorama-style scene, miniature environment designed like a handcrafted scale model, diorama-style environment, scale model aesthetic, handcrafted set. Stylized human figures with simplified, sculpted features and faceted geometry, low-detail facial features, sculpted characters, stylized human figures. Story-driven composition, dramatic cinematic lighting with practical light sources, soft volumetric shadows, low-key lighting, cinematic lighting. Shallow depth of field, tilt-shift effect, tilt-shift perspective, narrative camera angle, story-driven camera angle, diorama perspective, cinematic depth of field. Matte textures, subtle imperfections, handcrafted textures, matte surfaces, handcrafted look. Emotional storytelling atmosphere, frozen moment in time, metaphorical visual, staged scene, narrative depth, miniature scene aesthetic, maquette-style environment'
    };
    
    return styleSuffixes[mappedStyle] || styleSuffixes['photorealistic'];
}

// Fun√ß√£o helper para gerar √¢ncora visual global baseada no estilo escolhido
function getGlobalVisualAnchor(style) {
    const defaultStyle = style || 'photorealistic';
    
    // Estilos que usam a √¢ncora de diorama (estilo atual fixo)
    const dioramaStyles = ['cinematic-diorama'];
    
    // Se for diorama, usar a √¢ncora fixa atual
    if (dioramaStyles.includes(defaultStyle)) {
        return `
üß© GLOBAL VISUAL IDENTITY ‚Äî LOCKED:

The entire story exists inside a cinematic narrative diorama.
All environments are handcrafted miniature scale models,
the world feels like a physical maquette filmed up close.

All characters, including close-ups and portraits,
must appear as stylized sculpted figures,
never as real human faces.

All faces must retain a sculpted, physical miniature appearance.
No natural photographic skin softness.
Faces should look like crafted figures, not real people,
even in close-up shots.

Consistent semi-stylized realism across all scenes,
no photorealistic skin, no natural human softness.

Matte materials, handcrafted textures,
subtle imperfections, physical model feel.

Cinematic depth of field,
controlled perspective,
subtle tilt-shift to reinforce miniature scale.

Every frame must look like a frozen cinematic moment
from the same miniature world.

‚ö†Ô∏è This text NEVER changes. NEVER.
‚ö†Ô∏è If a scene looks like it could be a real photograph, it's wrong.
‚ö†Ô∏è It must look like a filmed miniature, not a filmed person.

üö´ NEGATIVE PROMPT ‚Äî √öLTIMO REFOR√áO:
photorealistic humans,
hyper-detailed skin,
real-world full scale environments,
life-size architecture,
photographic realism,
cinema movie still look,
video game graphics,
cartoon style,
anime style,
plastic or glossy materials,
stop-motion puppets,
toy-like exaggeration,
full-scale real world,
wide open real locations,
global illumination,
neutral camera angles,
real human skin texture,
natural photographic portrait,
beauty photography lighting,
hyper-smooth faces,
ultra-real close-up photography,
photographic portrait,
beauty photography,
natural skin translucency,
cinema realism close-up

‚ö†Ô∏è If any of these appear visually, the scene has failed.

WHAT CAN VARY (WITHOUT BREAKING STYLE):
‚úÖ Lighting (warm / cold)
‚úÖ Time of day
‚úÖ Emotion
‚úÖ Action
‚úÖ Narrative framing

WHAT NEVER VARIES:
‚ùå Scale
‚ùå Character type (always stylized sculpted figures)
‚ùå Material (always matte, handcrafted)
‚ùå Camera language (always story-driven)
‚ùå Realism level (always semi-stylized, never photorealistic)

SCENE VALIDATION CHECKLIST (ALL MUST BE YES):
- Does it look like a physical miniature?
- Could it fit on a table?
- Do people look like sculpted figures, not actors?
- Do close-ups look like stylized sculptures, not real faces?
- Does light look controlled, not randomly natural?
- Does it look like a frame from the same film as all others?

If any answer is NO ‚Üí regenerate the scene.

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "as if filmed inside a handcrafted scale model"
- "the environment feels like a physical miniature set"
- "miniature world with cinematic lighting"
`;
    }
    
    // Para outros estilos, usar a descri√ß√£o do estilo espec√≠fico
    const stylePrompt = getStyleSpecificPrompt(defaultStyle, true);
    
    // Criar √¢ncora visual baseada no estilo
    const styleAnchors = {
        'photorealistic': `
üì∏ GLOBAL VISUAL IDENTITY ‚Äî PHOTOREALISTIC:

All scenes must maintain photorealistic quality with ultra-high-definition detail.
Real-world photography aesthetic, professional camera quality.
Natural human features, realistic skin textures, authentic environments.
Professional photography lighting, real-world depth of field.
Every frame must look like a professional photograph.

‚ö†Ô∏è CRITICAL: Maintain photorealistic quality throughout all scenes.
‚ö†Ô∏è Use real-world proportions, natural lighting, authentic textures.

üö´ NEGATIVE PROMPT:
cartoon style, anime style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized, artistic interpretation, miniature, diorama,
toy-like, exaggerated features, non-realistic proportions

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "professional photography, ultra-high-definition"
- "real-world photography, authentic detail"
- "photorealistic quality, natural lighting"
`,
        'cinematic': `
üé¨ GLOBAL VISUAL IDENTITY ‚Äî CINEMATIC:

All scenes must maintain cinematic Hollywood-style quality.
Dramatic lighting, film-like composition, emotional depth.
Professional cinematography, movie still aesthetic.
Epic composition, dramatic shadows, controlled color palette.
Every frame must look like a frame from a Hollywood film.

‚ö†Ô∏è CRITICAL: Maintain cinematic quality throughout all scenes.
‚ö†Ô∏è Use dramatic lighting, film composition, emotional storytelling.

üö´ NEGATIVE PROMPT:
documentary style, natural lighting, flat composition, cartoon style,
anime style, illustration, drawing, artwork, digital art, render, 3D, CGI,
stylized, artistic interpretation, miniature, diorama, toy-like

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "cinematic composition, dramatic lighting"
- "Hollywood-style cinematography, film-like quality"
- "dramatic film aesthetic, emotional depth"
`,
        'documentary': `
üìπ GLOBAL VISUAL IDENTITY ‚Äî DOCUMENTARY:

All scenes must maintain documentary-style authenticity.
Natural lighting, authentic moments, journalistic approach.
Real-world photography, candid moments, authentic human experiences.
Natural color grading, realistic environments, genuine emotions.
Every frame must look like a documentary photograph.

‚ö†Ô∏è CRITICAL: Maintain documentary authenticity throughout all scenes.
‚ö†Ô∏è Use natural lighting, authentic moments, journalistic approach.

üö´ NEGATIVE PROMPT:
cinematic style, dramatic lighting, staged scenes, cartoon style,
anime style, illustration, drawing, artwork, digital art, render, 3D, CGI,
stylized, artistic interpretation, miniature, diorama, toy-like, exaggerated

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "documentary photography, authentic moment"
- "journalistic approach, natural lighting"
- "real-world authenticity, candid photography"
`,
        'anime': `
üå∏ GLOBAL VISUAL IDENTITY ‚Äî ANIME:

All scenes must maintain anime-style aesthetic.
Japanese animation style, vibrant colors, expressive characters.
Manga-inspired visuals, cel-shaded appearance, detailed backgrounds.
Anime composition, expressive character design, vibrant palette.
Every frame must look like an anime frame.

‚ö†Ô∏è CRITICAL: Maintain anime style throughout all scenes.
‚ö†Ô∏è Use vibrant colors, expressive characters, anime composition.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
cartoon style (Western), illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "anime style, Japanese animation"
- "manga-inspired, vibrant colors"
- "cel-shaded anime aesthetic, expressive characters"
`,
        'cartoon': `
üé® GLOBAL VISUAL IDENTITY ‚Äî CARTOON:

All scenes must maintain cartoon-style aesthetic.
Colorful, expressive, playful, hand-drawn aesthetic.
Vibrant palette, animated style, expressive characters.
Playful composition, colorful backgrounds, animated quality.
Every frame must look like a cartoon frame.

‚ö†Ô∏è CRITICAL: Maintain cartoon style throughout all scenes.
‚ö†Ô∏è Use vibrant colors, expressive design, playful aesthetic.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, illustration, drawing, artwork, digital art, render, 3D, CGI,
stylized realism, miniature, diorama, realistic proportions

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "cartoon style, colorful and expressive"
- "animated aesthetic, playful design"
- "hand-drawn cartoon style, vibrant palette"
`,
        'cartoon-premium': `
‚ú® GLOBAL VISUAL IDENTITY ‚Äî PREMIUM CARTOON:

All scenes must maintain premium cartoon-style aesthetic.
High-quality animation, sophisticated color palette, professional lighting.
Detailed character design, rich colors, professional animation studio quality.
Premium animation composition, sophisticated design, professional quality.
Every frame must look like a premium animation frame.

‚ö†Ô∏è CRITICAL: Maintain premium cartoon style throughout all scenes.
‚ö†Ô∏è Use sophisticated colors, professional animation quality, detailed design.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, simple cartoon, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "premium cartoon style, high-quality animation"
- "professional animation studio quality, sophisticated design"
- "premium animation aesthetic, detailed character design"
`,
        'fantasy': `
‚ú® GLOBAL VISUAL IDENTITY ‚Äî FANTASY:

All scenes must maintain fantasy-style aesthetic.
Magical atmosphere, epic scale, mystical lighting, enchanted elements.
Otherworldly visuals, detailed fantasy illustration, magical composition.
Epic fantasy composition, mystical elements, enchanted atmosphere.
Every frame must look like a fantasy illustration.

‚ö†Ô∏è CRITICAL: Maintain fantasy style throughout all scenes.
‚ö†Ô∏è Use magical elements, mystical lighting, epic scale.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, real-world

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "fantasy art, magical atmosphere"
- "epic fantasy scale, mystical lighting"
- "enchanted fantasy aesthetic, otherworldly visuals"
`,
        'stick-figure': `
üë§ GLOBAL VISUAL IDENTITY ‚Äî STICK FIGURE:

All scenes must maintain stick figure-style aesthetic.
Minimalist line art, simple black lines on white background.
Clean and minimal, simple composition, minimalist design.
Basic line art composition, minimal elements, clean aesthetic.
Every frame must look like a stick figure drawing.

‚ö†Ô∏è CRITICAL: Maintain stick figure style throughout all scenes.
‚ö†Ô∏è Use simple lines, minimal design, clean composition.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, detailed illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, complex design

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "stick figure style, minimalist line art"
- "simple black lines, clean and minimal"
- "minimalist stick figure aesthetic, simple design"
`,
        'whiteboard': `
üìù GLOBAL VISUAL IDENTITY ‚Äî WHITEBOARD:

All scenes must maintain whiteboard animation-style aesthetic.
Clean white background, hand-drawn illustrations, educational style.
Clear and simple, minimalist aesthetic, educational composition.
Whiteboard composition, hand-drawn elements, clean design.
Every frame must look like a whiteboard illustration.

‚ö†Ô∏è CRITICAL: Maintain whiteboard style throughout all scenes.
‚ö†Ô∏è Use clean white background, hand-drawn elements, simple design.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, complex backgrounds

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "whiteboard animation style, clean white background"
- "hand-drawn illustrations, educational aesthetic"
- "whiteboard style, clear and simple design"
`,
        'tech-minimalist': `
üíª GLOBAL VISUAL IDENTITY ‚Äî TECH MINIMALIST:

All scenes must maintain tech minimalist-style aesthetic.
Clean design, modern aesthetic, geometric shapes, minimal color palette.
Futuristic, sleek, minimalist design, modern composition.
Tech composition, geometric elements, minimal design.
Every frame must look like a tech minimalist design.

‚ö†Ô∏è CRITICAL: Maintain tech minimalist style throughout all scenes.
‚ö†Ô∏è Use clean design, geometric shapes, minimal palette.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, complex design

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "tech minimalist, clean design"
- "modern aesthetic, geometric shapes"
- "futuristic minimalist aesthetic, sleek design"
`,
        'spiritual-minimalist': `
üßò GLOBAL VISUAL IDENTITY ‚Äî SPIRITUAL MINIMALIST:

All scenes must maintain spiritual minimalist-style aesthetic.
Serene atmosphere, soft lighting, peaceful composition, meditative quality.
Zen aesthetic, soft illumination, peaceful design, meditative composition.
Spiritual composition, serene elements, peaceful aesthetic.
Every frame must look like a spiritual minimalist design.

‚ö†Ô∏è CRITICAL: Maintain spiritual minimalist style throughout all scenes.
‚ö†Ô∏è Use serene atmosphere, soft lighting, peaceful design.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, dramatic lighting

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "spiritual minimalist, serene atmosphere"
- "meditative aesthetic, soft lighting"
- "zen aesthetic, peaceful composition"
`,
        'viral-vibrant': `
üî• GLOBAL VISUAL IDENTITY ‚Äî VIRAL VIBRANT:

All scenes must maintain viral vibrant-style aesthetic.
High contrast, saturated colors, bold composition, eye-catching design.
Social media optimized, vibrant and energetic, bold visual impact.
Viral composition, high contrast, saturated palette, energetic design.
Every frame must look like a viral social media image.

‚ö†Ô∏è CRITICAL: Maintain viral vibrant style throughout all scenes.
‚ö†Ô∏è Use high contrast, saturated colors, bold composition.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, muted colors

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "viral vibrant style, high contrast"
- "saturated colors, bold composition"
- "social media optimized, vibrant and energetic"
`,
        'modern-documentary': `
üì∫ GLOBAL VISUAL IDENTITY ‚Äî MODERN DOCUMENTARY:

All scenes must maintain modern documentary-style aesthetic.
Dynamic contemporary lighting, authentic moments, modern color grading.
Modern cinematography, contemporary approach, authentic visual style.
Modern documentary composition, contemporary elements, authentic design.
Every frame must look like a modern documentary frame.

‚ö†Ô∏è CRITICAL: Maintain modern documentary style throughout all scenes.
‚ö†Ô∏è Use contemporary lighting, authentic moments, modern approach.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, classic documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, vintage aesthetic

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "modern documentary style, dynamic contemporary"
- "authentic moments, modern color grading"
- "contemporary cinematography, modern aesthetic"
`,
        'analog-horror': `
üëª GLOBAL VISUAL IDENTITY ‚Äî ANALOG HORROR:

All scenes must maintain analog horror-style aesthetic.
VHS quality grain, retro horror aesthetic, low-fi texture, analog degradation.
Vintage feel, retro horror composition, analog quality, vintage aesthetic.
Analog horror composition, VHS quality, retro elements, vintage design.
Every frame must look like an analog horror frame.

‚ö†Ô∏è CRITICAL: Maintain analog horror style throughout all scenes.
‚ö†Ô∏è Use VHS quality, retro aesthetic, analog degradation.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, high quality

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "analog horror style, VHS quality"
- "retro horror aesthetic, low-fi texture"
- "analog degradation, vintage feel"
`,
        'dark-theater': `
üé™ GLOBAL VISUAL IDENTITY ‚Äî DARK THEATER:

All scenes must maintain dark theater-style aesthetic.
Dramatic stage lighting, intense shadows, theatrical illumination.
Theatrical composition, dramatic lighting, stage aesthetic, intense design.
Dark theater composition, dramatic shadows, theatrical elements.
Every frame must look like a dark theater stage.

‚ö†Ô∏è CRITICAL: Maintain dark theater style throughout all scenes.
‚ö†Ô∏è Use dramatic stage lighting, intense shadows, theatrical design.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, natural lighting

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "dark theater style, dramatic stage lighting"
- "intense shadows, theatrical illumination"
- "theatrical composition, dramatic lighting"
`,
        'naturalist-drama': `
üé≠ GLOBAL VISUAL IDENTITY ‚Äî NATURALIST DRAMA:

All scenes must maintain naturalist drama-style aesthetic.
Realistic emotional lighting, authentic human moments, natural color palette.
Realistic composition, emotional depth, authentic design, natural aesthetic.
Naturalist drama composition, realistic elements, emotional design.
Every frame must look like a naturalist drama frame.

‚ö†Ô∏è CRITICAL: Maintain naturalist drama style throughout all scenes.
‚ö†Ô∏è Use realistic lighting, authentic moments, natural palette.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, dramatic lighting

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "naturalist drama style, realistic emotional"
- "authentic human moments, natural color palette"
- "realistic composition, emotional depth"
`,
        'spiritual-neorealism': `
üåü GLOBAL VISUAL IDENTITY ‚Äî SPIRITUAL NEOREALISM:

All scenes must maintain spiritual neorealism-style aesthetic.
Transcendent realistic lighting, mystical atmosphere, spiritual color grading.
Transcendent composition, mystical elements, spiritual design, transcendent aesthetic.
Spiritual neorealism composition, transcendent elements, mystical design.
Every frame must look like a spiritual neorealism frame.

‚ö†Ô∏è CRITICAL: Maintain spiritual neorealism style throughout all scenes.
‚ö†Ô∏è Use transcendent lighting, mystical atmosphere, spiritual design.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, mundane aesthetic

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "spiritual neorealism style, transcendent realistic"
- "mystical atmosphere, spiritual color grading"
- "transcendent composition, mystical elements"
`,
        'psychological-surrealism': `
üåÄ GLOBAL VISUAL IDENTITY ‚Äî PSYCHOLOGICAL SURREALISM:

All scenes must maintain psychological surrealism-style aesthetic.
Dreamlike lighting, abstract reality, surreal color palette.
Surreal composition, dreamlike elements, abstract design, surreal aesthetic.
Psychological surrealism composition, dreamlike elements, abstract design.
Every frame must look like a psychological surrealism frame.

‚ö†Ô∏è CRITICAL: Maintain psychological surrealism style throughout all scenes.
‚ö†Ô∏è Use dreamlike lighting, abstract reality, surreal design.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, realistic reality

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "psychological surrealism style, dreamlike lighting"
- "abstract reality, surreal color palette"
- "surreal composition, dreamlike elements"
`,
        'fragmented-memory': `
üß© GLOBAL VISUAL IDENTITY ‚Äî FRAGMENTED MEMORY:

All scenes must maintain fragmented memory-style aesthetic.
Collage aesthetic, fragmented composition, layered lighting.
Fragmented composition, collage elements, layered design, fragmented aesthetic.
Fragmented memory composition, collage elements, layered design.
Every frame must look like a fragmented memory frame.

‚ö†Ô∏è CRITICAL: Maintain fragmented memory style throughout all scenes.
‚ö†Ô∏è Use collage aesthetic, fragmented composition, layered design.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, unified composition

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "fragmented memory style, collage aesthetic"
- "fragmented composition, layered lighting"
- "collage elements, fragmented design"
`,
        'fragmented-narrative': `
üìñ GLOBAL VISUAL IDENTITY ‚Äî FRAGMENTED NARRATIVE:

All scenes must maintain fragmented narrative-style aesthetic.
Fragmented narrative style, collage composition, layered visual narrative.
Fragmented composition, collage elements, layered narrative, fragmented aesthetic.
Fragmented narrative composition, collage elements, layered design.
Every frame must look like a fragmented narrative frame.

‚ö†Ô∏è CRITICAL: Maintain fragmented narrative style throughout all scenes.
‚ö†Ô∏è Use fragmented composition, collage elements, layered narrative.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, unified narrative

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "fragmented narrative style, collage composition"
- "layered visual narrative, fragmented design"
- "collage elements, fragmented narrative"
`,
        'dream-real': `
üí≠ GLOBAL VISUAL IDENTITY ‚Äî DREAM-REAL:

All scenes must maintain dream-real-style aesthetic.
Liminal space lighting, ethereal atmosphere, dream-reality blend.
Liminal composition, ethereal elements, dream-reality design, liminal aesthetic.
Dream-real composition, ethereal elements, liminal design.
Every frame must look like a dream-real frame.

‚ö†Ô∏è CRITICAL: Maintain dream-real style throughout all scenes.
‚ö†Ô∏è Use liminal lighting, ethereal atmosphere, dream-reality blend.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, realistic reality

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "dream-real style, liminal space lighting"
- "ethereal atmosphere, dream-reality blend"
- "liminal composition, ethereal elements"
`,
        'vhs-nostalgic': `
üìº GLOBAL VISUAL IDENTITY ‚Äî VHS NOSTALGIC:

All scenes must maintain VHS nostalgic-style aesthetic.
Retro 80s/90s quality, vintage grain, analog texture, nostalgic aesthetic.
Vintage composition, retro elements, nostalgic design, vintage aesthetic.
VHS nostalgic composition, retro elements, vintage design.
Every frame must look like a VHS nostalgic frame.

‚ö†Ô∏è CRITICAL: Maintain VHS nostalgic style throughout all scenes.
‚ö†Ô∏è Use retro quality, vintage grain, analog texture.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, high quality

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "VHS nostalgic style, retro 80s/90s"
- "vintage grain, analog texture"
- "retro aesthetic, nostalgic design"
`,
        'cinematic-narrative': `
üé≠ GLOBAL VISUAL IDENTITY ‚Äî CINEMATIC NARRATIVE:

All scenes must maintain cinematic narrative-style aesthetic.
Story-driven lighting, emotional depth, narrative composition, dramatic shadows.
Storytelling composition, emotional elements, narrative design, storytelling aesthetic.
Cinematic narrative composition, story-driven elements, emotional design.
Every frame must look like a cinematic narrative frame.

‚ö†Ô∏è CRITICAL: Maintain cinematic narrative style throughout all scenes.
‚ö†Ô∏è Use story-driven lighting, emotional depth, narrative composition.

üö´ NEGATIVE PROMPT:
photorealistic, realistic photography, documentary style, cinematic style,
anime style, cartoon style, illustration, drawing, artwork, digital art,
render, 3D, CGI, stylized realism, miniature, diorama, flat composition

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "cinematic narrative style, story-driven lighting"
- "emotional depth, narrative composition"
- "storytelling composition, emotional elements"
`
    };
    
    // Retornar a √¢ncora espec√≠fica do estilo ou a padr√£o (photorealistic)
    return styleAnchors[defaultStyle] || styleAnchors['photorealistic'];
}

// Fun√ß√£o helper para gerar descri√ß√£o SEO otimizada com emojis
function generateOptimizedSEODescription(title, subniche, language) {
    const emojiMap = {
        'pt': {
            'Marketing Digital': 'üì±üíº',
            'YouTube': 'üé•üì∫',
            'TikTok': 'üéµüì±',
            'Instagram': 'üì∏‚ú®',
            'Neg√≥cios': 'üíºüöÄ',
            'Educa√ß√£o': 'üìöüéì',
            'Tecnologia': 'üíªüîß',
            'Sa√∫de': 'üí™üè•',
            'Fitness': 'üèãÔ∏èüí™',
            'Viagem': '‚úàÔ∏èüåç',
            'Culin√°ria': 'üç≥üë®‚Äçüç≥',
            'Entretenimento': 'üé¨üé≠'
        },
        'en': {
            'Digital Marketing': 'üì±üíº',
            'YouTube': 'üé•üì∫',
            'TikTok': 'üéµüì±',
            'Instagram': 'üì∏‚ú®',
            'Business': 'üíºüöÄ',
            'Education': 'üìöüéì',
            'Technology': 'üíªüîß',
            'Health': 'üí™üè•',
            'Fitness': 'üèãÔ∏èüí™',
            'Travel': '‚úàÔ∏èüåç',
            'Cooking': 'üç≥üë®‚Äçüç≥',
            'Entertainment': 'üé¨üé≠'
        },
        'es': {
            'Marketing Digital': 'üì±üíº',
            'YouTube': 'üé•üì∫',
            'TikTok': 'üéµüì±',
            'Instagram': 'üì∏‚ú®',
            'Negocios': 'üíºüöÄ',
            'Educaci√≥n': 'üìöüéì',
            'Tecnolog√≠a': 'üíªüîß',
            'Salud': 'üí™üè•',
            'Fitness': 'üèãÔ∏èüí™',
            'Viajes': '‚úàÔ∏èüåç',
            'Cocina': 'üç≥üë®‚Äçüç≥',
            'Entretenimiento': 'üé¨üé≠'
        }
    };
    
    const langCode = language === 'Portugu√™s' ? 'pt' : language === 'Ingl√™s' ? 'en' : 'es';
    const emojis = emojiMap[langCode] || emojiMap['pt'];
    const nicheEmoji = emojis[subniche] || 'üéØ';
    
    if (langCode === 'pt') {
        return `${nicheEmoji} ${title}

üìå Neste v√≠deo voc√™ vai descobrir:
‚úÖ Tudo sobre ${subniche}
‚úÖ Estrat√©gias comprovadas que funcionam
‚úÖ Dicas exclusivas para resultados r√°pidos

üéØ Se voc√™ quer dominar ${subniche}, este v√≠deo √© para voc√™!

üí° Deixe seu like se este conte√∫do te ajudou! üëç
üì¢ Compartilhe com quem precisa ver isso!
üîî Ative o sininho para n√£o perder nenhum conte√∫do!

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìö CONTE√öDO DO V√çDEO:
Neste v√≠deo completo, voc√™ vai aprender tudo sobre ${subniche} e como aplicar estrat√©gias eficazes para alcan√ßar seus objetivos.

üé¨ O QUE VOC√ä VAI APRENDER:
‚Ä¢ Como dominar ${subniche}
‚Ä¢ Estrat√©gias pr√°ticas e aplic√°veis
‚Ä¢ Dicas exclusivas de especialistas
‚Ä¢ Erros comuns a evitar

üíº SOBRE O CANAL:
Aqui voc√™ encontra conte√∫do de qualidade sobre ${subniche}, com dicas pr√°ticas, tutoriais e estrat√©gias que realmente funcionam.

üîó LINKS IMPORTANTES:
üì± Siga-nos nas redes sociais para mais conte√∫do exclusivo!

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

#${subniche.replace(/\s+/g, '')} #YouTube #Conte√∫do #Dicas #Tutorial`;
    } else if (langCode === 'en') {
        return `${nicheEmoji} ${title}

üìå In this video you'll discover:
‚úÖ Everything about ${subniche}
‚úÖ Proven strategies that work
‚úÖ Exclusive tips for quick results

üéØ If you want to master ${subniche}, this video is for you!

üí° Leave a like if this content helped you! üëç
üì¢ Share with those who need to see this!
üîî Turn on notifications to never miss content!

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìö VIDEO CONTENT:
In this complete video, you'll learn everything about ${subniche} and how to apply effective strategies to achieve your goals.

üé¨ WHAT YOU'LL LEARN:
‚Ä¢ How to master ${subniche}
‚Ä¢ Practical and applicable strategies
‚Ä¢ Exclusive expert tips
‚Ä¢ Common mistakes to avoid

üíº ABOUT THE CHANNEL:
Here you'll find quality content about ${subniche}, with practical tips, tutorials and strategies that really work.

üîó IMPORTANT LINKS:
üì± Follow us on social media for more exclusive content!

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

#${subniche.replace(/\s+/g, '')} #YouTube #Content #Tips #Tutorial`;
    } else {
        return `${nicheEmoji} ${title}

üìå En este video descubrir√°s:
‚úÖ Todo sobre ${subniche}
‚úÖ Estrategias probadas que funcionan
‚úÖ Consejos exclusivos para resultados r√°pidos

üéØ Si quieres dominar ${subniche}, ¬°este video es para ti!

üí° ¬°Dale like si este contenido te ayud√≥! üëç
üì¢ ¬°Comparte con quien necesita ver esto!
üîî ¬°Activa las notificaciones para no perderte contenido!

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìö CONTENIDO DEL VIDEO:
En este video completo, aprender√°s todo sobre ${subniche} y c√≥mo aplicar estrategias efectivas para alcanzar tus objetivos.

üé¨ LO QUE APRENDER√ÅS:
‚Ä¢ C√≥mo dominar ${subniche}
‚Ä¢ Estrategias pr√°cticas y aplicables
‚Ä¢ Consejos exclusivos de expertos
‚Ä¢ Errores comunes a evitar

üíº SOBRE EL CANAL:
Aqu√≠ encontrar√°s contenido de calidad sobre ${subniche}, con consejos pr√°cticos, tutoriales y estrategias que realmente funcionan.

üîó ENLACES IMPORTANTES:
üì± ¬°S√≠guenos en redes sociales para m√°s contenido exclusivo!

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

#${subniche.replace(/\s+/g, '')} #YouTube #Contenido #Consejos #Tutorial`;
    }
}

// Fun√ß√£o helper para gerar as 12 regras de thumbnail viral do YouTube
function getThumbnailViralRules(selectedRule = 'auto', selectedTitle = '') {
    const rules = {
        'rule1': {
            name: 'Regra da Clareza Imediata (1 segundo)',
            description: 'O c√©rebro precisa entender a thumbnail em menos de 1 segundo. Se houver confus√£o, o clique cai.',
            checklist: ['1 ideia principal', '1 personagem', '1 emo√ß√£o', '1 objeto-chave'],
            instructions: 'A thumbnail DEVE ser compreendida em menos de 1 segundo. Use APENAS: 1 ideia principal, 1 personagem, 1 emo√ß√£o, 1 objeto-chave. Elimine qualquer elemento que cause confus√£o ou distra√ß√£o.'
        },
        'rule2': {
            name: 'Regra do Assunto √önico',
            description: 'Nada divide a aten√ß√£o. A thumbnail boa √© sempre uma hist√≥ria em uma imagem.',
            instructions: 'Foque em UM √öNICO assunto dominante. Nada deve competir pela aten√ß√£o. A thumbnail deve contar uma hist√≥ria completa em uma √∫nica imagem, sem elementos que dividam o foco.'
        },
        'rule3': {
            name: 'Regra do Rosto Grande',
            description: 'Rostos com forte express√£o emocional aumentam CTR de 20% a 60%.',
            expressions: ['choque', 'surpresa', 'medo', 'raiva', 'felicidade extrema'],
            instructions: 'Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A express√£o facial DEVE ser EXTREMA e EMOCIONAL: choque, surpresa, medo, raiva ou felicidade extrema. O rosto deve ser o elemento dominante e a primeira coisa que o olho v√™.'
        },
        'rule4': {
            name: 'Regra do Contraste Brutal',
            description: 'Se n√£o tiver contraste, a thumbnail fica invis√≠vel.',
            contrasts: ['texto vs fundo', 'personagem vs fundo', 'cores complementares (azul/laranja, amarelo/roxo)'],
            instructions: 'Use CONTRASTE BRUTAL entre: texto e fundo, personagem e fundo, cores complementares (azul/laranja, amarelo/roxo). O contraste deve ser t√£o forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.'
        },
        'rule5': {
            name: 'Regra da Cor Estrat√©gica',
            description: 'Cada cor ativa um gatilho.',
            colors: {
                'Amarelo': 'aten√ß√£o imediata',
                'Vermelho': 'urg√™ncia / perigo',
                'Azul': 'confian√ßa',
                'Verde': 'dinheiro / solu√ß√£o',
                'Preto': 'premium / mist√©rio'
            },
            instructions: 'Use cores estrat√©gicas que ativem gatilhos mentais: Amarelo (aten√ß√£o imediata), Vermelho (urg√™ncia/perigo), Azul (confian√ßa), Verde (dinheiro/solu√ß√£o), Preto (premium/mist√©rio). Escolha a cor baseada na emo√ß√£o que o t√≠tulo transmite.'
        },
        'rule6': {
            name: 'Regra dos Ter√ßos',
            description: 'Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso d√° harmonia e aumenta o foco natural.',
            instructions: 'Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos ter√ßos (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.'
        },
        'rule7': {
            name: 'Regra do Texto Ultra Curto',
            description: 'Texto deve ter 2 a 4 palavras, nunca mais.',
            examples: ['Ele mentiu', 'Descobri isso', 'Ningu√©m viu', 'Proibido'],
            instructions: 'O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Exemplos: "Ele mentiu", "Descobri isso", "Ningu√©m viu", "Proibido". Textos longos matam o CTR. Seja brutalmente direto e impactante.'
        },
        'rule8': {
            name: 'Regra do Zoom Emocional',
            description: 'Aparece sempre um elemento gigante que amplifica a emo√ß√£o ou o conflito.',
            examples: ['uma conta banc√°ria gigante', 'uma faca gigante', 'uma lupa gigante', 'um n√∫mero gigante'],
            instructions: 'Use um elemento GIGANTE que amplifique a emo√ß√£o ou conflito: uma conta banc√°ria gigante, uma faca gigante, uma lupa gigante, um n√∫mero gigante. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.'
        },
        'rule9': {
            name: 'Regra do Mist√©rio',
            description: 'Toda thumbnail viral tem uma pergunta impl√≠cita.',
            examples: ['algo escondido atr√°s de blur', 'objeto cortado pela metade', 'pessoa olhando para fora do quadro', 'seta apontando para algo fora da tela'],
            instructions: 'Crie uma pergunta impl√≠cita na thumbnail usando: algo escondido atr√°s de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela. O espectador DEVE sentir curiosidade sobre o que est√° fora da imagem.'
        },
        'rule10': {
            name: 'Regra dos Pontos de Fuga',
            description: 'Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.',
            elements: ['setas', 'linhas diagonais', 'perspectiva'],
            instructions: 'Use linhas visuais que guiem o olhar para o foco: setas, linhas diagonais, perspectiva. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal (personagem ou objeto).'
        },
        'rule11': {
            name: 'Regra do Espa√ßo Negativo',
            description: 'Deixar √°reas vazias acentua o foco. Sem isso, a imagem vira bagun√ßa.',
            instructions: 'Deixe √°reas vazias (espa√ßo negativo) que acentuem o foco no elemento principal. O espa√ßo vazio cria respira√ß√£o visual e faz o elemento principal "pular" da imagem. Sem espa√ßo negativo, a thumbnail vira bagun√ßa visual.'
        },
        'rule12': {
            name: 'Regra da Coer√™ncia com o T√≠tulo',
            description: 'Thumbnail e t√≠tulo precisam contar a mesma hist√≥ria, mas com √¢ngulos diferentes.',
            instructions: 'A thumbnail e o t√≠tulo DEVEM contar a mesma hist√≥ria, mas com √¢ngulos diferentes: T√≠tulo = contexto, Thumbnail = emo√ß√£o. A thumbnail deve amplificar a emo√ß√£o que o t√≠tulo promete, criando uma sinergia perfeita.'
        }
    };
    
    if (selectedRule === 'auto') {
        // IA deve identificar qual regra melhor se encaixa baseado no t√≠tulo
        return {
            mode: 'auto',
            instructions: `Analise o t√≠tulo "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral melhor se encaixa. Aplique a regra identificada de forma rigorosa. Se m√∫ltiplas regras se aplicarem, priorize a que tiver maior impacto no CTR.`,
            allRules: rules
        };
    } else {
        const rule = rules[selectedRule];
        if (!rule) {
            return { mode: 'auto', instructions: 'Regra n√£o encontrada. Use modo autom√°tico.', allRules: rules };
        }
        return {
            mode: 'manual',
            rule: rule,
            instructions: rule.instructions
        };
    }
}

// === ROTAS PARA THUMBNAILS DE REFER√äNCIA ===

// Upload de thumbnail de refer√™ncia
app.post('/api/thumbnail-references/upload', authenticateToken, async (req, res) => {
    try {
        const { thumbnail_base64, folder_id, channel_name, niche, subniche, description } = req.body;
        const userId = req.user.id;

        if (!thumbnail_base64) {
            return res.status(400).json({ msg: 'Thumbnail em base64 √© obrigat√≥ria.' });
        }

        // Validar formato base64
        if (!thumbnail_base64.startsWith('data:image/')) {
            return res.status(400).json({ msg: 'Formato de imagem inv√°lido. Use base64 com data URI.' });
        }

        // Verificar se a coluna folder_id existe na tabela
        let hasFolderId = false;
        try {
            const tableInfo = await db.all("PRAGMA table_info(thumbnail_references)");
            hasFolderId = tableInfo.some(col => col.name === 'folder_id');
            
            // Se n√£o existir, criar a coluna
            if (!hasFolderId) {
                await db.run('ALTER TABLE thumbnail_references ADD COLUMN folder_id INTEGER');
                await db.run('CREATE INDEX IF NOT EXISTS idx_thumbnail_ref_folder ON thumbnail_references(folder_id)');
                hasFolderId = true;
            }
        } catch (e) {
            console.warn('[Thumbnail Ref] Erro ao verificar/criar coluna folder_id:', e.message);
        }

        // Validar se a pasta pertence ao usu√°rio (se folder_id for fornecido)
        if (folder_id && hasFolderId) {
            try {
                const folder = await db.get('SELECT id FROM analysis_folders WHERE id = ? AND user_id = ?', [folder_id, userId]);
                if (!folder) {
                    return res.status(400).json({ msg: 'Pasta n√£o encontrada ou n√£o pertence ao usu√°rio.' });
                }
            } catch (e) {
                console.warn('[Thumbnail Ref] Erro ao validar pasta:', e.message);
            }
        }

        // Inserir com ou sem folder_id dependendo da estrutura da tabela
        let result;
        if (hasFolderId) {
            result = await db.run(
                `INSERT INTO thumbnail_references (user_id, thumbnail_base64, folder_id, channel_name, niche, subniche, description)
                 VALUES (?, ?, ?, ?, ?, ?, ?)`,
                [userId, thumbnail_base64, folder_id || null, channel_name || null, niche || null, subniche || null, description || null]
            );
        } else {
            result = await db.run(
                `INSERT INTO thumbnail_references (user_id, thumbnail_base64, channel_name, niche, subniche, description)
                 VALUES (?, ?, ?, ?, ?, ?)`,
                [userId, thumbnail_base64, channel_name || null, niche || null, subniche || null, description || null]
            );
        }

        // Analisar estilo automaticamente ap√≥s upload (se tiver niche/subniche)
        let autoAnalyzeResult = null;
        if (niche || subniche) {
            try {
                // Buscar thumbnails de refer√™ncia do nicho/subnicho
                let refQuery = 'SELECT id, thumbnail_base64 FROM thumbnail_references WHERE user_id = ?';
                const refParams = [userId];
                
                if (folder_id) {
                    refQuery += ' AND (folder_id = ? OR folder_id IS NULL)';
                    refParams.push(folder_id);
                }
                if (subniche) {
                    refQuery += ' AND (subniche = ? OR subniche IS NULL)';
                    refParams.push(subniche);
                }
                if (niche) {
                    refQuery += ' AND (niche = ? OR niche IS NULL)';
                    refParams.push(niche);
                }
                
                refQuery += ' ORDER BY created_at DESC LIMIT 10';
                const thumbnailReferences = await db.all(refQuery, refParams);
                
                if (thumbnailReferences && thumbnailReferences.length >= 1) {
                    // Buscar API key automaticamente
                    let apiKey = null;
                    let service = null;
                    let modelToUse = null;
                    
                    const services = ['claude', 'openai', 'gemini'];
                    for (const svc of services) {
                        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
                        if (keyData && keyData.api_key) {
                            try {
                                apiKey = decrypt(keyData.api_key);
                                service = svc;
                                if (svc === 'claude') modelToUse = 'claude-3-7-sonnet-20250219';
                                else if (svc === 'openai') modelToUse = 'gpt-4o';
                                else modelToUse = 'gemini-2.5-pro';
                                break;
                            } catch (e) {
                                continue;
                            }
                        }
                    }
                    
                    if (apiKey) {
                        // Preparar imagens para an√°lise
                        const additionalImages = thumbnailReferences.map(ref => ref.thumbnail_base64).filter(Boolean);
                        
                        // Criar prompt para an√°lise de estilo
                        const analysisPrompt = `Voc√™ √© um ESPECIALISTA EM AN√ÅLISE DE ESTILO VISUAL DE THUMBNAILS.

Analise as ${thumbnailReferences.length} thumbnail(s) de refer√™ncia fornecidas e identifique os ELEMENTOS VISUAIS COMUNS e o ESTILO PADR√ÉO usado.

IMPORTANTE: Sua tarefa √© criar TR√äS (3) PROMPTS PADR√ïES DIFERENTES que descrevam o estilo visual destas thumbnails de forma FIEL, cada um com uma abordagem ligeiramente diferente, mas todos mantendo a identidade visual do canal/nicho.

CR√çTICO - FIDELIDADE AO ESTILO:
- Seja EXTREMAMENTE FIEL ao estilo visual das thumbnails de refer√™ncia
- Replique fielmente: composi√ß√£o, cores, tipografia, elementos visuais
- Mantenha a identidade visual do canal/nicho
- Cada prompt deve ser uma varia√ß√£o fiel, n√£o uma reinven√ß√£o completa

ANALISE OS SEGUINTES ELEMENTOS:
1. Composi√ß√£o visual (layout, enquadramento, posicionamento de elementos)
2. Paleta de cores dominante (cores principais, contrastes)
3. Estilo de tipografia (fontes, tamanhos, efeitos, posicionamento)
4. Elementos visuais recorrentes (objetos, s√≠mbolos, elementos decorativos)
5. Ilumina√ß√£o e atmosfera (clara/escura, dram√°tica/suave)
6. Estilo geral (realista/cartoon/cinematogr√°fico/minimalista)
7. Regras de design espec√≠ficas (regra dos ter√ßos, contraste, hierarquia visual)

RESPONDA APENAS COM UM OBJETO JSON:
{
  "prompt_1": "Primeiro prompt detalhado em ingl√™s que descreve o estilo visual padr√£o destas thumbnails de forma fiel, focando na composi√ß√£o e elementos principais. Seja espec√≠fico e detalhado.",
  "prompt_2": "Segundo prompt detalhado em ingl√™s que descreve o mesmo estilo visual, mas com foco diferente (ex: cores e tipografia). Mantenha a fidelidade ao estilo original.",
  "prompt_3": "Terceiro prompt detalhado em ingl√™s que descreve o mesmo estilo visual, mas com √™nfase em outros aspectos (ex: ilumina√ß√£o e atmosfera). Continue sendo fiel ao estilo original."
}

IMPORTANTE: Os 3 prompts devem ser varia√ß√µes fi√©is do mesmo estilo, n√£o estilos completamente diferentes. Todos devem manter a identidade visual do canal/nicho.`;

                        // Chamar API para an√°lise
                        let analysisResponse;
                        if (service === 'claude') {
                            analysisResponse = await callClaudeAPI(analysisPrompt, apiKey, modelToUse, null, null, additionalImages);
                        } else if (service === 'openai') {
                            analysisResponse = await callOpenAIAPI(analysisPrompt, apiKey, modelToUse, null, additionalImages);
                        } else {
                            analysisResponse = await callGeminiAPI(analysisPrompt, apiKey, modelToUse, null, additionalImages);
                        }
                        
                        const analysisText = typeof analysisResponse === 'string' ? analysisResponse : (analysisResponse.titles || JSON.stringify(analysisResponse));
                        const parsedAnalysis = parseAIResponse(analysisText, service);
                        
                        // Validar que os 3 prompts foram gerados
                        if (parsedAnalysis.prompt_1 && parsedAnalysis.prompt_2 && parsedAnalysis.prompt_3) {
                            const prompt1 = parsedAnalysis.prompt_1;
                            const prompt2 = parsedAnalysis.prompt_2;
                            const prompt3 = parsedAnalysis.prompt_3;

                            // Verificar se j√° existe um prompt padr√£o para atualizar
                            let checkQuery = 'SELECT id FROM thumbnail_style_prompts WHERE user_id = ?';
                            const checkParams = [userId];
                            
                            if (niche) {
                                checkQuery += ' AND niche = ?';
                                checkParams.push(niche);
                            } else {
                                checkQuery += ' AND niche IS NULL';
                            }
                            
                            if (subniche) {
                                checkQuery += ' AND subniche = ?';
                                checkParams.push(subniche);
                            } else {
                                checkQuery += ' AND subniche IS NULL';
                            }
                            
                            if (folder_id) {
                                checkQuery += ' AND folder_id = ?';
                                checkParams.push(folder_id);
                            } else {
                                checkQuery += ' AND folder_id IS NULL';
                            }
                            
                            const existingPrompt = await db.get(checkQuery, checkParams);
                            
                            if (existingPrompt) {
                                await db.run(
                                    `UPDATE thumbnail_style_prompts 
                                     SET prompt_1 = ?, prompt_2 = ?, prompt_3 = ?, 
                                         standard_prompt = ?, updated_at = CURRENT_TIMESTAMP
                                     WHERE id = ?`,
                                    [prompt1, prompt2, prompt3, prompt1, existingPrompt.id]
                                );
                                await db.run(
                                    `UPDATE thumbnail_style_prompts 
                                     SET prompt_selected = 1 
                                     WHERE id = ? AND (prompt_selected IS NULL OR prompt_selected = 0)`,
                                    [existingPrompt.id]
                                );
                                autoAnalyzeResult = { success: true, updated: true, id: existingPrompt.id };
                            } else {
                                const insertResult = await db.run(
                                    `INSERT INTO thumbnail_style_prompts (user_id, niche, subniche, folder_id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected, updated_at)
                                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1, CURRENT_TIMESTAMP)`,
                                    [userId, niche || null, subniche || null, folder_id || null, prompt1, prompt2, prompt3, prompt1]
                                );
                                autoAnalyzeResult = { success: true, created: true, id: insertResult.lastID };
                            }
                        }
                    }
                }
            } catch (autoErr) {
                console.warn('[Thumbnail Ref] Erro na an√°lise autom√°tica de estilo:', autoErr.message);
                // N√£o falhar o upload se a an√°lise autom√°tica falhar
            }
        }

        res.status(200).json({ 
            msg: 'Thumbnail de refer√™ncia salva com sucesso.',
            id: result.lastID,
            styleAnalyzed: autoAnalyzeResult ? true : false
        });
    } catch (err) {
        console.error('Erro ao salvar thumbnail de refer√™ncia:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Listar thumbnails de refer√™ncia
app.get('/api/thumbnail-references', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { folder_id, channel_name, niche, subniche } = req.query;

        // Verificar se a coluna folder_id existe, se n√£o, usar query sem ela
        let query = 'SELECT id, thumbnail_base64, channel_name, niche, subniche, description, created_at FROM thumbnail_references WHERE user_id = ?';
        const params = [userId];
        
        // Tentar adicionar folder_id se a coluna existir
        try {
            const tableInfo = await db.all("PRAGMA table_info(thumbnail_references)");
            const hasFolderId = tableInfo.some(col => col.name === 'folder_id');
            if (hasFolderId) {
                query = 'SELECT id, thumbnail_base64, folder_id, channel_name, niche, subniche, description, created_at FROM thumbnail_references WHERE user_id = ?';
            }
        } catch (e) {
            // Se der erro ao verificar, usar query sem folder_id
            console.warn('[Thumbnail Ref] Erro ao verificar estrutura da tabela:', e.message);
        }

        if (folder_id) {
            try {
                const tableInfo = await db.all("PRAGMA table_info(thumbnail_references)");
                const hasFolderId = tableInfo.some(col => col.name === 'folder_id');
                if (hasFolderId) {
                    query += ' AND (folder_id = ? OR folder_id IS NULL)';
                    params.push(folder_id);
                }
            } catch (e) {
                // Ignorar se coluna n√£o existir
            }
        }
        if (channel_name) {
            query += ' AND channel_name = ?';
            params.push(channel_name);
        }
        if (niche) {
            query += ' AND niche = ?';
            params.push(niche);
        }
        if (subniche) {
            query += ' AND subniche = ?';
            params.push(subniche);
        }

        query += ' ORDER BY created_at DESC';

        const references = await db.all(query, params);

        // Retornar com base64 para exibi√ß√£o na interface
        res.status(200).json({ references });
    } catch (err) {
        console.error('Erro ao listar thumbnails de refer√™ncia:', err);
        res.status(500).json({ msg: 'Erro no servidor: ' + err.message });
    }
});

// Obter thumbnail de refer√™ncia espec√≠fica (com base64)
app.get('/api/thumbnail-references/:id', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { id } = req.params;

        const reference = await db.get(
            'SELECT * FROM thumbnail_references WHERE id = ? AND user_id = ?',
            [id, userId]
        );

        if (!reference) {
            return res.status(404).json({ msg: 'Thumbnail de refer√™ncia n√£o encontrada.' });
        }

        res.status(200).json({ reference });
    } catch (err) {
        console.error('Erro ao buscar thumbnail de refer√™ncia:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Analisar thumbnails de refer√™ncia e gerar prompt padr√£o
app.post('/api/thumbnail-references/analyze-style', authenticateToken, async (req, res) => {
    try {
        const { niche, subniche, folder_id, force_reanalyze, model } = req.body;
        const userId = req.user.id;

        // Buscar thumbnails de refer√™ncia do nicho/subnicho
        let refQuery = 'SELECT id, thumbnail_base64, channel_name, niche, subniche, description FROM thumbnail_references WHERE user_id = ?';
        const refParams = [userId];
        
        if (folder_id) {
            refQuery += ' AND (folder_id = ? OR folder_id IS NULL)';
            refParams.push(folder_id);
        }
        if (subniche) {
            refQuery += ' AND (subniche = ? OR subniche IS NULL)';
            refParams.push(subniche);
        }
        if (niche) {
            refQuery += ' AND (niche = ? OR niche IS NULL)';
            refParams.push(niche);
        }
        
        refQuery += ' ORDER BY created_at DESC LIMIT 10';
        
        const thumbnailReferences = await db.all(refQuery, refParams);
        
        if (!thumbnailReferences || thumbnailReferences.length === 0) {
            return res.status(400).json({ msg: 'Nenhuma thumbnail de refer√™ncia encontrada para este nicho/subnicho.' });
        }

        // Verificar se j√° existe um prompt padr√£o e se n√£o precisa re-analisar
        if (!force_reanalyze) {
            let existingPromptQuery = 'SELECT id, standard_prompt FROM thumbnail_style_prompts WHERE user_id = ?';
            const existingPromptParams = [userId];
            
            if (folder_id) {
                existingPromptQuery += ' AND (folder_id = ? OR folder_id IS NULL)';
                existingPromptParams.push(folder_id);
            }
            if (subniche) {
                existingPromptQuery += ' AND (subniche = ? OR subniche IS NULL)';
                existingPromptParams.push(subniche);
            }
            if (niche) {
                existingPromptQuery += ' AND (niche = ? OR niche IS NULL)';
                existingPromptParams.push(niche);
            }
            
            const existingPrompt = await db.get(existingPromptQuery, existingPromptParams);
            if (existingPrompt) {
                return res.status(200).json({ 
                    prompt: existingPrompt.standard_prompt,
                    message: 'Prompt padr√£o j√° existe. Use force_reanalyze=true para re-analisar.',
                    id: existingPrompt.id
                });
            }
        }

        // Buscar API key para an√°lise - usar modelo selecionado ou escolher automaticamente
        let apiKey = null;
        let service = null;
        let modelToUse = null;
        
        if (model && model !== 'auto') {
            // Usar modelo especificado pelo usu√°rio
            if (model.includes('claude') || model === 'claude-3-7-sonnet-20250219') {
                service = 'claude';
                modelToUse = 'claude-3-7-sonnet-20250219';
            } else if (model.includes('gpt') || model === 'gpt-4o') {
                service = 'openai';
                modelToUse = 'gpt-4o';
            } else if (model.includes('gemini') || model === 'gemini-2.5-pro') {
                service = 'gemini';
                modelToUse = 'gemini-2.5-pro';
            }
            
            // Buscar API key para o servi√ßo especificado
            if (service) {
                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                if (keyData && keyData.api_key) {
                    try {
                        apiKey = decrypt(keyData.api_key);
                    } catch (e) {
                        // Se falhar, tentar autom√°tico
                        service = null;
                        modelToUse = null;
                    }
                } else {
                    // Se n√£o tiver a chave do modelo especificado, tentar autom√°tico
                    service = null;
                    modelToUse = null;
                }
            }
        }
        
        // Se n√£o especificado ou falhou, usar prioridade autom√°tica (claude > openai > gemini)
        if (!apiKey) {
            const services = ['claude', 'openai', 'gemini'];
            for (const svc of services) {
                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
                if (keyData && keyData.api_key) {
                    try {
                        apiKey = decrypt(keyData.api_key);
                        service = svc;
                        if (svc === 'claude') modelToUse = 'claude-3-7-sonnet-20250219';
                        else if (svc === 'openai') modelToUse = 'gpt-4o';
                        else modelToUse = 'gemini-2.5-pro';
                        break;
                    } catch (e) {
                        continue;
                    }
                }
            }
        }
        
        if (!apiKey) {
            return res.status(400).json({ msg: 'Nenhuma API key configurada. Configure pelo menos uma API (Claude, OpenAI ou Gemini) nas Configura√ß√µes.' });
        }

        // Preparar imagens para an√°lise
        const additionalImages = thumbnailReferences.map(ref => ref.thumbnail_base64).filter(Boolean);
        
        // Criar prompt para an√°lise de estilo - AN√ÅLISE ULTRA ANAL√çTICA E DETALHADA
        const analysisPrompt = `Voc√™ √© um ESPECIALISTA EM AN√ÅLISE DE ESTILO VISUAL DE THUMBNAILS e IDENTIDADE VISUAL DE CANAIS.

Analise as ${thumbnailReferences.length} thumbnail(s) de refer√™ncia fornecidas com EXTREMA ATEN√á√ÉO AOS DETALHES e identifique TODOS os elementos que comp√µem a IDENTIDADE VISUAL √öNICA deste canal/nicho.

IMPORTANTE: Sua tarefa √© criar TR√äS (3) PROMPTS PADR√ïES DIFERENTES que descrevam o estilo visual destas thumbnails de forma EXTREMAMENTE FIEL e DETALHADA, cada um com uma abordagem ligeiramente diferente, mas todos mantendo a identidade visual do canal/nicho.

CR√çTICO - AN√ÅLISE ANAL√çTICA PROFUNDA:
- Seja EXTREMAMENTE FIEL ao estilo visual das thumbnails de refer√™ncia
- Analise CADA DETALHE visual que comp√µe a identidade do canal
- Replique fielmente: composi√ß√£o, cores, tipografia, elementos visuais
- Mantenha a identidade visual do canal/nicho para QUALQUER nicho
- Cada prompt deve ser uma varia√ß√£o fiel, n√£o uma reinven√ß√£o completa

ANALISE DETALHADA DOS SEGUINTES ELEMENTOS (SEJA ESPEC√çFICO E DETALHADO):

1. COMPOSI√á√ÉO VISUAL (Layout e Estrutura):
   - Posicionamento exato do personagem/sujeito principal (centro, esquerda, direita, porcentagem do frame)
   - Enquadramento (close-up, m√©dio, plano geral)
   - Propor√ß√£o sujeito vs. fundo (ex: 60% sujeito, 40% fundo)
   - Regra dos ter√ßos aplicada? Como?
   - Hierarquia visual dos elementos
   - Espa√ßamento e margens
   - Simetria ou assimetria

2. PALETA DE CORES DOMINANTE (An√°lise Crom√°tica Detalhada):
   - Cores prim√°rias exatas (ex: dourado #D4AF37, azul escuro #1a1a2e)
   - Cores secund√°rias
   - Gradientes e transi√ß√µes de cor
   - Contraste de cores (alto, m√©dio, baixo)
   - Temperatura de cor (quente, fria, mista)
   - Satura√ß√£o (vibrante, desaturada, natural)
   - Distribui√ß√£o espacial das cores (onde cada cor aparece)

3. ESTILO DE TIPOGRAFIA (An√°lise Tipogr√°fica Completa):
   - Fam√≠lia de fonte (serif, sans-serif, display, script)
   - Tamanho relativo (grande, m√©dio, pequeno)
   - Peso da fonte (bold, regular, light)
   - Efeitos aplicados (sombra, brilho, gradiente, relevo, contorno)
   - Cor da tipografia (dourado, branco, preto, gradiente)
   - Posicionamento exato (inferior, superior, centro)
   - Alinhamento (centralizado, esquerda, direita)
   - Espa√ßamento entre letras (kerning)
   - Estilo de capitaliza√ß√£o (MAI√öSCULAS, min√∫sculas, Title Case)
   - Efeitos de camada (stroke, drop shadow, outer glow, bevel & emboss)

4. ELEMENTOS VISUAIS RECORRENTES (Invent√°rio Completo):
   - Objetos que aparecem consistentemente
   - S√≠mbolos e √≠cones recorrentes
   - Elementos decorativos
   - Padr√µes visuais
   - Texturas
   - Formas geom√©tricas

5. ILUMINA√á√ÉO E ATMOSFERA (An√°lise de Luz Detalhada):
   - Tipo de ilumina√ß√£o (dram√°tica, suave, natural, artificial)
   - Dire√ß√£o da luz (frontal, lateral, traseira, superior)
   - Contraste de ilumina√ß√£o (alto, m√©dio, baixo)
   - Sombras (suaves, duras, dram√°ticas)
   - Atmosfera geral (√©pica, misteriosa, dram√°tica, clara)
   - Efeitos de luz (lens flare, god rays, rim light)

6. ESTILO GERAL E QUALIDADE (Classifica√ß√£o Visual):
   - N√≠vel de realismo (foto-realista, semi-realista, estilizado)
   - Estilo art√≠stico (cinematogr√°fico, document√°rio, ilustrativo)
   - Qualidade visual (4K, HD, estilizado)
   - N√≠vel de detalhamento (ultra detalhado, detalhado, simplificado)

7. REGRAS DE DESIGN ESPEC√çFICAS (Princ√≠pios Aplicados):
   - Regra dos ter√ßos (como aplicada)
   - Contraste visual (alto, m√©dio, baixo)
   - Hierarquia visual (o que chama aten√ß√£o primeiro)
   - Equil√≠brio visual (sim√©trico, assim√©trico)
   - Profundidade (plano, m√©dio, profundo)

8. ELEMENTOS DE IDENTIDADE VISUAL √öNICA:
   - Caracter√≠sticas distintivas que tornam este estilo √∫nico
   - Padr√µes que se repetem em todas as thumbnails
   - "Assinatura visual" do canal
   - Elementos que devem SEMPRE estar presentes

RESPONDA APENAS COM UM OBJETO JSON:
{
  "prompt_1": "Primeiro prompt EXTREMAMENTE DETALHADO em ingl√™s (600-1200 palavras) que descreve o estilo visual padr√£o destas thumbnails de forma fiel, focando na composi√ß√£o, posicionamento exato, paleta de cores espec√≠fica, tipografia detalhada e elementos principais. Seja ESPEC√çFICO com medidas, porcentagens, cores exatas, posicionamento preciso.",
  "prompt_2": "Segundo prompt EXTREMAMENTE DETALHADO em ingl√™s (600-1200 palavras) que descreve o mesmo estilo visual, mas com foco em cores espec√≠ficas, tipografia detalhada (fonte, tamanho, efeitos), ilumina√ß√£o e atmosfera. Mantenha a fidelidade ao estilo original com TODOS os detalhes.",
  "prompt_3": "Terceiro prompt EXTREMAMENTE DETALHADO em ingl√™s (600-1200 palavras) que descreve o mesmo estilo visual, mas com √™nfase em elementos visuais recorrentes, regras de design espec√≠ficas, e identidade visual √∫nica. Continue sendo fiel ao estilo original com AN√ÅLISE PROFUNDA."
}

CR√çTICO: 
- Os 3 prompts devem ser varia√ß√µes fi√©is do mesmo estilo, n√£o estilos diferentes
- Todos devem manter a identidade visual do canal/nicho
- Seja ESPEC√çFICO: use medidas, porcentagens, cores exatas, posicionamento preciso
- Descreva CADA detalhe que comp√µe a identidade visual
- Os prompts devem ser aplic√°veis a QUALQUER nicho mantendo a identidade visual`;

        // Chamar API para an√°lise
        let analysisResponse;
        if (service === 'claude') {
            analysisResponse = await callClaudeAPI(analysisPrompt, apiKey, modelToUse, null, null, additionalImages);
        } else if (service === 'openai') {
            analysisResponse = await callOpenAIAPI(analysisPrompt, apiKey, modelToUse, null, additionalImages);
        } else {
            analysisResponse = await callGeminiAPI(analysisPrompt, apiKey, modelToUse, null, additionalImages);
        }
        
        const analysisText = typeof analysisResponse === 'string' ? analysisResponse : (analysisResponse.titles || JSON.stringify(analysisResponse));
        const parsedAnalysis = parseAIResponse(analysisText, service);
        
        // Validar que os 3 prompts foram gerados
        if (!parsedAnalysis.prompt_1 || !parsedAnalysis.prompt_2 || !parsedAnalysis.prompt_3) {
            // Fallback: se n√£o tiver os 3, tentar usar standard_prompt e criar varia√ß√µes
            if (parsedAnalysis.standard_prompt) {
                parsedAnalysis.prompt_1 = parsedAnalysis.standard_prompt;
                parsedAnalysis.prompt_2 = parsedAnalysis.standard_prompt;
                parsedAnalysis.prompt_3 = parsedAnalysis.standard_prompt;
            } else {
                throw new Error('A IA n√£o retornou os 3 prompts esperados.');
            }
        }
        
        const prompt1 = parsedAnalysis.prompt_1;
        const prompt2 = parsedAnalysis.prompt_2;
        const prompt3 = parsedAnalysis.prompt_3;

        // Verificar se j√° existe um prompt padr√£o para atualizar
        // Construir query que trata NULLs corretamente
        let checkQuery = 'SELECT id FROM thumbnail_style_prompts WHERE user_id = ?';
        const checkParams = [userId];
        
        if (niche) {
            checkQuery += ' AND niche = ?';
            checkParams.push(niche);
        } else {
            checkQuery += ' AND niche IS NULL';
        }
        
        if (subniche) {
            checkQuery += ' AND subniche = ?';
            checkParams.push(subniche);
        } else {
            checkQuery += ' AND subniche IS NULL';
        }
        
        if (folder_id) {
            checkQuery += ' AND folder_id = ?';
            checkParams.push(folder_id);
        } else {
            checkQuery += ' AND folder_id IS NULL';
        }
        
        const existingPrompt = await db.get(checkQuery, checkParams);
        
        let result;
        if (existingPrompt) {
            // Atualizar existente com os 3 prompts
            // Manter prompt_selected se j√° existir, caso contr√°rio usar 1
            result = await db.run(
                `UPDATE thumbnail_style_prompts 
                 SET prompt_1 = ?, prompt_2 = ?, prompt_3 = ?, 
                     standard_prompt = ?, updated_at = CURRENT_TIMESTAMP
                 WHERE id = ?`,
                [prompt1, prompt2, prompt3, prompt1, existingPrompt.id]
            );
            
            // Se prompt_selected n√£o existir ou for NULL, definir como 1
            await db.run(
                `UPDATE thumbnail_style_prompts 
                 SET prompt_selected = 1 
                 WHERE id = ? AND (prompt_selected IS NULL OR prompt_selected = 0)`,
                [existingPrompt.id]
            );
        } else {
            // Inserir novo com os 3 prompts
            result = await db.run(
                `INSERT INTO thumbnail_style_prompts (user_id, niche, subniche, folder_id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected, updated_at)
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1, CURRENT_TIMESTAMP)`,
                [userId, niche || null, subniche || null, folder_id || null, prompt1, prompt2, prompt3, prompt1]
            );
        }

        // Buscar o registro atualizado para retornar todos os dados
        const updatedRecord = await db.get('SELECT * FROM thumbnail_style_prompts WHERE id = ?', [existingPrompt ? existingPrompt.id : result.lastID]);

        res.status(200).json({ 
            msg: 'Estilo analisado e 3 prompts salvos com sucesso.',
            prompts: {
                prompt_1: updatedRecord.prompt_1 || prompt1,
                prompt_2: updatedRecord.prompt_2 || prompt2,
                prompt_3: updatedRecord.prompt_3 || prompt3
            },
            prompt_selected: updatedRecord.prompt_selected || 1,
            id: updatedRecord.id
        });
    } catch (err) {
        console.error('Erro ao analisar estilo das thumbnails:', err);
        res.status(500).json({ msg: 'Erro no servidor: ' + err.message });
    }
});

// Obter prompts padr√£o para um nicho/subnicho
app.get('/api/thumbnail-style-prompts', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { niche, subniche, folder_id } = req.query;

        let query = 'SELECT id, niche, subniche, folder_id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected, analyzed_at, updated_at FROM thumbnail_style_prompts WHERE user_id = ?';
        const params = [userId];

        if (folder_id) {
            query += ' AND (folder_id = ? OR folder_id IS NULL)';
            params.push(folder_id);
        }
        if (subniche) {
            query += ' AND (subniche = ? OR subniche IS NULL)';
            params.push(subniche);
        }
        if (niche) {
            query += ' AND (niche = ? OR niche IS NULL)';
            params.push(niche);
        }

        query += ' ORDER BY updated_at DESC LIMIT 1';

        const promptData = await db.get(query, params);

        if (!promptData) {
            // Retornar 200 com dados vazios ao inv√©s de 404 para n√£o gerar erro no frontend
            return res.status(200).json({ prompt: null, prompts: null });
        }

        // Determinar qual prompt usar (prompt_selected ou fallback para prompt_1 ou standard_prompt)
        const selectedPromptNum = promptData.prompt_selected || 1;
        let selectedPrompt = null;
        if (promptData.prompt_1 || promptData.prompt_2 || promptData.prompt_3) {
            if (selectedPromptNum === 1 && promptData.prompt_1) selectedPrompt = promptData.prompt_1;
            else if (selectedPromptNum === 2 && promptData.prompt_2) selectedPrompt = promptData.prompt_2;
            else if (selectedPromptNum === 3 && promptData.prompt_3) selectedPrompt = promptData.prompt_3;
            else selectedPrompt = promptData.prompt_1 || promptData.prompt_2 || promptData.prompt_3;
        } else {
            selectedPrompt = promptData.standard_prompt;
        }

        res.status(200).json({ 
            prompt: {
                ...promptData,
                standard_prompt: selectedPrompt
            },
            prompts: {
                prompt_1: promptData.prompt_1 || promptData.standard_prompt,
                prompt_2: promptData.prompt_2 || promptData.standard_prompt,
                prompt_3: promptData.prompt_3 || promptData.standard_prompt
            },
            prompt_selected: selectedPromptNum
        });
    } catch (err) {
        console.error('Erro ao buscar prompt padr√£o:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Selecionar qual dos 3 prompts usar como padr√£o
app.post('/api/thumbnail-style-prompts/select', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { niche, subniche, folder_id, prompt_number } = req.body;

        if (!prompt_number || (prompt_number !== 1 && prompt_number !== 2 && prompt_number !== 3)) {
            return res.status(400).json({ msg: 'prompt_number deve ser 1, 2 ou 3.' });
        }

        // Buscar o registro (mesma l√≥gica do GET)
        let query = 'SELECT id FROM thumbnail_style_prompts WHERE user_id = ?';
        const params = [userId];

        if (folder_id !== undefined && folder_id !== null && folder_id !== '') {
            query += ' AND (folder_id = ? OR folder_id IS NULL)';
            params.push(folder_id);
        }

        if (subniche) {
            query += ' AND (subniche = ? OR subniche IS NULL)';
            params.push(subniche);
        }

        if (niche) {
            query += ' AND (niche = ? OR niche IS NULL)';
            params.push(niche);
        }

        query += ' ORDER BY updated_at DESC LIMIT 1';

        const promptData = await db.get(query, params);

        if (!promptData) {
            return res.status(404).json({ msg: 'Nenhum prompt padr√£o encontrado para este nicho/subnicho.' });
        }

        // Atualizar prompt_selected
        await db.run(
            'UPDATE thumbnail_style_prompts SET prompt_selected = ? WHERE id = ?',
            [prompt_number, promptData.id]
        );

        res.status(200).json({ 
            msg: `Prompt ${prompt_number} selecionado como padr√£o.`,
            prompt_selected: prompt_number
        });
    } catch (err) {
        console.error('Erro ao selecionar prompt padr√£o:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Deletar thumbnail de refer√™ncia
app.delete('/api/thumbnail-references/:id', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { id } = req.params;

        const result = await db.run(
            'DELETE FROM thumbnail_references WHERE id = ? AND user_id = ?',
            [id, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Thumbnail de refer√™ncia n√£o encontrada.' });
        }

        res.status(200).json({ msg: 'Thumbnail de refer√™ncia deletada com sucesso.' });
    } catch (err) {
        console.error('Erro ao deletar thumbnail de refer√™ncia:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

// Endpoint unificado: Gera thumbnail completa (imagem + headline + SEO + tags) baseado no t√≠tulo e estilo de refer√™ncia
app.post('/api/generate/thumbnail/complete', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        let { title, niche, subniche, folder_id, language = 'pt-BR', style = 'photorealistic', theme_key, variations = 2, ai_model, prompt_variant } = req.body;

        if (!title || !title.trim()) {
            return res.status(400).json({ msg: 'T√≠tulo √© obrigat√≥rio.' });
        }
        
        // Normalizar folder_id: converter string vazia para null e garantir que seja n√∫mero
        if (folder_id === '' || folder_id === '0' || folder_id === 0) {
            folder_id = null;
        } else if (folder_id) {
            folder_id = parseInt(folder_id, 10);
            if (isNaN(folder_id)) folder_id = null;
        }
        
        console.log('[Thumbnail Complete] Buscando prompt para:', { userId, folder_id, niche, subniche });

        // 1. Buscar prompt padr√£o do estilo de refer√™ncia
        // Prioridade: folder_id espec√≠fico > subniche > niche > geral
        let promptData = null;
        
        // Primeiro, tentar buscar por pasta espec√≠fica (se folder_id fornecido)
        if (folder_id) {
            let query = 'SELECT id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected, folder_id, niche, subniche FROM thumbnail_style_prompts WHERE user_id = ? AND folder_id = ?';
            const params = [userId, folder_id];
            
            // Adicionar filtros opcionais de nicho/subnicho para refinar a busca
            if (subniche) {
                query += ' AND (subniche = ? OR subniche IS NULL)';
                params.push(subniche);
            }
            if (niche) {
                query += ' AND (niche = ? OR niche IS NULL)';
                params.push(niche);
            }
            query += ' ORDER BY updated_at DESC LIMIT 1';
            
            console.log('[Thumbnail Complete] Buscando por pasta espec√≠fica:', { query, params });
            promptData = await db.get(query, params);
            if (promptData) {
                console.log('[Thumbnail Complete] Prompt encontrado na pasta espec√≠fica:', { id: promptData.id, folder_id: promptData.folder_id });
            } else {
                console.log('[Thumbnail Complete] Nenhum prompt encontrado na pasta espec√≠fica:', folder_id);
            }
        }
        
        // Se n√£o encontrou na pasta espec√≠fica, tentar por subniche
        if (!promptData && subniche) {
            let query = 'SELECT id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected FROM thumbnail_style_prompts WHERE user_id = ? AND subniche = ?';
            const params = [userId, subniche];
            if (niche) {
                query += ' AND (niche = ? OR niche IS NULL)';
                params.push(niche);
            }
            query += ' ORDER BY updated_at DESC LIMIT 1';
            
            console.log('[Thumbnail Complete] Buscando por subniche:', { query, params });
            promptData = await db.get(query, params);
            if (promptData) {
                console.log('[Thumbnail Complete] Prompt encontrado por subniche:', { id: promptData.id });
            }
        }
        
        // Se n√£o encontrou, tentar por niche
        if (!promptData && niche) {
            let query = 'SELECT id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected FROM thumbnail_style_prompts WHERE user_id = ? AND niche = ?';
            const params = [userId, niche];
            query += ' ORDER BY updated_at DESC LIMIT 1';
            
            console.log('[Thumbnail Complete] Buscando por niche:', { query, params });
            promptData = await db.get(query, params);
            if (promptData) {
                console.log('[Thumbnail Complete] Prompt encontrado por niche:', { id: promptData.id });
            }
        }
        
        // Se ainda n√£o encontrou, buscar qualquer prompt do usu√°rio (fallback)
        if (!promptData) {
            let query = 'SELECT id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected FROM thumbnail_style_prompts WHERE user_id = ?';
            const params = [userId];
            query += ' ORDER BY updated_at DESC LIMIT 1';
            
            console.log('[Thumbnail Complete] Buscando qualquer prompt do usu√°rio (fallback)');
            promptData = await db.get(query, params);
            if (promptData) {
                console.log('[Thumbnail Complete] Prompt encontrado (fallback):', { id: promptData.id });
            }
        }
        
        if (!promptData) {
            return res.status(400).json({ 
                msg: folder_id 
                    ? 'Nenhum estilo de refer√™ncia encontrado para esta pasta. Fa√ßa upload de thumbnails de refer√™ncia para esta pasta primeiro.' 
                    : 'Nenhum estilo de refer√™ncia encontrado. Fa√ßa upload de thumbnails de refer√™ncia primeiro.' 
            });
        }

        // Usar prompt_variant se fornecido, sen√£o usar o prompt_selected, sen√£o usar 1
        const selectedNum = prompt_variant || promptData.prompt_selected || 1;
        let basePrompt = null;
        if (selectedNum === 1 && promptData.prompt_1) basePrompt = promptData.prompt_1;
        else if (selectedNum === 2 && promptData.prompt_2) basePrompt = promptData.prompt_2;
        else if (selectedNum === 3 && promptData.prompt_3) basePrompt = promptData.prompt_3;
        else basePrompt = promptData.standard_prompt || promptData.prompt_1 || promptData.prompt_2 || promptData.prompt_3;
        
        console.log('[Thumbnail Complete] Prompt selecionado:', {
            prompt_variant: prompt_variant,
            prompt_selected: promptData.prompt_selected,
            selectedNum,
            hasPrompt1: !!promptData.prompt_1,
            hasPrompt2: !!promptData.prompt_2,
            hasPrompt3: !!promptData.prompt_3
        });
        
        if (!basePrompt) {
            return res.status(400).json({ msg: 'Prompt padr√£o vazio.' });
        }

        // 2. Detectar tema e ambienta√ß√£o do t√≠tulo
        const titleText = title.trim();
        const theme = (() => {
            const s = titleText.toLowerCase();
            if (s.includes('fara√≥') || s.includes('egito') || s.includes('egip') || s.includes('pir√¢mide') || s.includes('piramide')) return 'egito';
            if (s.includes('neandertal') || s.includes('neanderthal') || s.includes('neandertais') || s.includes('neandertales')) return 'prehistoria';
            if (s.includes('inca') || s.includes('atahualpa') || s.includes('moctezuma') || s.includes('azteca') || s.includes('aztecas') || s.includes('mexica')) return 'america_pre_colombiana';
            if (s.includes('viking') || s.includes('vikings')) return 'viking';
            if (s.includes('roma') || s.includes('romano') || s.includes('romanos') || s.includes('roman') || s.includes('imp√©rio') || s.includes('imperio') || s.includes('b√°rbaro') || s.includes('barbaro')) return 'roma';
            if (s.includes('segunda guerra') || s.includes('world war') || s.includes('guerra mundial')) return 'ww2';
            if (s.includes('cristandade') || s.includes('crist√£o') || s.includes('cristian') || s.includes('cathedral') || s.includes('catedral')) return 'cristandade';
            return 'default';
        })();

        // 3. Buscar ambienta√ß√£o do banco de dados ou usar mapeamento padr√£o
        let dbMatch = null;
        if (theme_key) {
            await ensureAmbientationsTable();
            dbMatch = await db.get('SELECT * FROM niche_ambientations WHERE user_id = ? AND theme_key = ? LIMIT 1', [userId, theme_key]);
        }
        if (!dbMatch) {
            dbMatch = await detectAmbientationFromTitle(userId, titleText, niche);
        }

        // 4. Mapeamento de temas com personagens e elementos
        const themes = {
            egito: { 
                subject: 'ancient Egyptian figure with royal collar and nemes headdress', 
                acessorios: 'gold necklaces and ceremonial regalia', 
                ambiente: 'desert dunes, pyramids, pharaoh temples, golden sun', 
                elementos: 'hieroglyph walls, golden crown, architect tools' 
            },
            prehistoria: { 
                subject: 'rugged Neanderthal with thick brow ridges, deep-set eyes, and weathered skin', 
                acessorios: 'primitive fur and animal hides, no metal or feathers', 
                ambiente: 'icy mountains, glacial valleys, burning forests', 
                elementos: 'fur clothing, primitive tools, ice age forests, mammoth silhouettes' 
            },
            america_pre_colombiana: { 
                subject: 'Mesoamerican leader with traditional attire and ceremonial elements', 
                acessorios: 'ornate jewelry and ritual accessories', 
                ambiente: 'jungles, stepped pyramids, volcanic eruptions', 
                elementos: 'ancient temples, stone sculptures, ritual smoke' 
            },
            viking: { 
                subject: 'Viking warrior with axe and thick beard', 
                acessorios: 'fur, leather armor, iron helmet', 
                ambiente: 'stormy oceans, burning ships, icy fjords', 
                elementos: 'longships, shields, ravens' 
            },
            roma: { 
                subject: 'Roman figure with laurel wreath and toga, classical lighting', 
                acessorios: 'laurel wreath, toga, military regalia', 
                ambiente: 'colosseum, roman columns, marble statues, ancient Rome', 
                elementos: 'legion standards, roman architecture, battle scenes, barbarian silhouettes' 
            },
            ww2: { 
                subject: 'civilian silhouette amid wartime ruins', 
                acessorios: 'period clothing, military uniforms', 
                ambiente: 'ruined cities, smoke, searchlights', 
                elementos: 'tanks, helmets, barbed wire, destruction' 
            },
            cristandade: { 
                subject: 'historical figure near cathedral light', 
                acessorios: 'religious vestments, ceremonial items', 
                ambiente: 'gothic cathedrals, stained glass light, stone plazas', 
                elementos: 'crosses, incense smoke, candles' 
            },
            default: { 
                subject: 'historical figure with authentic attire matching the title theme', 
                acessorios: 'period-appropriate accessories', 
                ambiente: 'dramatic scenery matching the title', 
                elementos: 'contextual props and elements' 
            }
        };

        // 5. EXTRAIR APENAS ELEMENTOS DE ESTILO DO PROMPT PADR√ÉO
        // Remover TODOS os elementos de conte√∫do (personagens, cen√°rios, objetos espec√≠ficos)
        // Manter APENAS: composi√ß√£o, cores, tipografia, efeitos, distribui√ß√£o, transpar√™ncia, ilumina√ß√£o
        let adaptedPrompt = basePrompt;
        
        // Lista completa de remo√ß√µes - qualquer refer√™ncia a personagens, cen√°rios, objetos espec√≠ficos
        const contentRemovals = [
            // Personagens e figuras espec√≠ficas
            /(?:native american|indigenous|mexican|aztec|inca|maya|mesoamerican|pre-columbian)[^.]*?\./gi,
            /(?:leader|warrior|king|ruler|pharaoh|emperor|centurion|soldier|figure|person|character)[^,\.]*?(?:with|wearing|holding|standing|sitting)[^,\.]*?\./gi,
            /(?:atahualpa|moctezuma|malinche|cortes|conquistador|spanish|roman|egyptian|viking|neanderthal|greek|medieval)[^,\.]*?\./gi,
            /(?:feathered headdress|plumes|jaguar|eagle|serpent|snake|bird)[^,\.]*?\./gi,
            /(?:close-up portrait of|featuring|depicting|showing)[^,\.]*?(?:leader|figure|person|warrior|king)[^,\.]*?\./gi,
            
            // Cen√°rios e locais espec√≠ficos
            /(?:mesoamerican|aztec|inca|maya|pyramid|temple|ruins|tenochtitlan|machu picchu)[^,\.]*?\./gi,
            /(?:spanish ships|galleons|conquistador ships|longships|viking ships)[^,\.]*?\./gi,
            /(?:colosseum|roman columns|marble statues|ancient rome|egyptian pyramids|desert dunes)[^,\.]*?\./gi,
            /(?:jungle|selva|andes|fjords|glaciers|ice age)[^,\.]*?\./gi,
            
            // Objetos e elementos espec√≠ficos
            /(?:jade|gold jewelry|ceremonial|ritual|sacrifice|offering|hieroglyph|glyph)[^,\.]*?\./gi,
            /(?:spear|shield|sword|axe|bow|arrow|weapon|armor|helmet)[^,\.]*?\./gi,
            /(?:burning ships|warriors|battle|conflict|invasion|conquest)[^,\.]*?\./gi,
            
            // Frases completas que mencionam conte√∫do espec√≠fico
            /(?:in the background|behind|surrounding|around)[^,\.]*?(?:ships|warriors|pyramids|temples|ruins|battle)[^,\.]*?\./gi,
            /(?:faded scenes of|scenes of|showing|depicting)[^,\.]*?(?:conflict|war|invasion|conquest|ritual)[^,\.]*?\./gi
        ];
        
        // Remover todas as refer√™ncias a conte√∫do espec√≠fico
        for (const pattern of contentRemovals) {
            adaptedPrompt = adaptedPrompt.replace(pattern, '').replace(/\s{2,}/g, ' ').trim();
        }
        
        // Remover frases que come√ßam com descri√ß√µes de personagens/cen√°rios
        adaptedPrompt = adaptedPrompt.replace(/^[^,\.]*(?:featuring|depicting|showing|with|portrait of)[^,\.]*?\.\s*/gi, '');
        
        // Limpar m√∫ltiplos espa√ßos e pontos
        adaptedPrompt = adaptedPrompt.replace(/\s{2,}/g, ' ').replace(/\.\s*\./g, '.').trim();

        // 6. Obter elementos do tema detectado
        let themeData = themes[theme] || themes.default;
        if (dbMatch) {
            themeData = {
                subject: dbMatch.subject || themeData.subject,
                acessorios: dbMatch.acessorios || themeData.acessorios,
                ambiente: dbMatch.ambiente || themeData.ambiente,
                elementos: dbMatch.elementos || themeData.elementos
            };
        }

        // 7. Substituir placeholders ou adicionar elementos do tema
        const placeholders = [/\[\s*T[√çI]TULO\s*\]/gi, /\{\s*TITLE\s*\}/gi, /<\s*TITLE\s*>/gi, /\{\{\s*title\s*\}\}/gi, /\[TITLE\]/g];
        for (const rx of placeholders) {
            if (rx.test(adaptedPrompt)) {
                adaptedPrompt = adaptedPrompt.replace(rx, `"${titleText}"`);
            }
        }

        // 7. Substituir placeholders de personagem, ambiente, elementos (se existirem)
        adaptedPrompt = adaptedPrompt.replace(/\{PERSONAGEM\}/gi, themeData.subject);
        adaptedPrompt = adaptedPrompt.replace(/\{ACESSORIOS\}/gi, themeData.acessorios || '');
        adaptedPrompt = adaptedPrompt.replace(/\{AMBIENTE\}/gi, themeData.ambiente);
        adaptedPrompt = adaptedPrompt.replace(/\{ELEMENTOS_DE_FUNDO\}/gi, themeData.elementos);

        // 8. ADICIONAR DINAMICAMENTE PERSONAGEM E AMBIENTA√á√ÉO BASEADO NO T√çTULO
        // Sempre adicionar elementos din√¢micos, independente do que estava no prompt padr√£o
        
        // Verificar se o prompt j√° menciona algum personagem gen√©rico (para n√£o duplicar)
        const hasGenericSubject = /(?:featuring|depicting|showing|portrait of|subject|character|figure)\s+(?:a|an|the)?\s*(?:historical|dramatic|cinematic|central|main)[^,\.]*/gi.test(adaptedPrompt);
        
        if (!hasGenericSubject || !adaptedPrompt.toLowerCase().includes(themeData.subject.toLowerCase().split(' ')[0])) {
            // Procurar por padr√µes de descri√ß√£o de personagem gen√©rica e substituir
            const personPatterns = [
                /(?:featuring|depicting|showing|with)\s+(?:a|an|the)?\s*(?:historical|dramatic|cinematic|central|main)[^,\.]*(?:figure|person|character|subject|portrait)[^,\.]*/gi,
                /(?:subject|character|person|figure|portrait of)\s+(?:a|an|the)?\s*(?:historical|dramatic|cinematic|central)[^,\.]*/gi,
                /close-up portrait of\s+(?:a|an|the)?\s*(?:historical|dramatic|cinematic)[^,\.]*/gi
            ];
            
            let replaced = false;
            for (const pattern of personPatterns) {
                if (pattern.test(adaptedPrompt)) {
                    adaptedPrompt = adaptedPrompt.replace(pattern, (match) => {
                        // Substituir por personagem din√¢mico do t√≠tulo
                        if (match.includes('featuring')) {
                            return `featuring ${themeData.subject}`;
                        } else if (match.includes('depicting')) {
                            return `depicting ${themeData.subject}`;
                        } else if (match.includes('portrait')) {
                            return `close-up portrait of ${themeData.subject}`;
                        } else {
                            return match.replace(/[^,\.]*(?:figure|person|character|subject)[^,\.]*/i, themeData.subject);
                        }
                    });
                    replaced = true;
                    break;
                }
            }
            
            // Se n√£o encontrou padr√£o gen√©rico, adicionar personagem din√¢mico no in√≠cio
            if (!replaced) {
                // Verificar se o prompt come√ßa com instru√ß√µes de estilo ou composi√ß√£o
                const styleStarters = ['design', 'create', 'generate', 'compose', 'arrange', 'layout'];
                const startsWithStyle = styleStarters.some(starter => adaptedPrompt.toLowerCase().startsWith(starter));
                
                if (startsWithStyle) {
                    // Adicionar personagem ap√≥s o verbo de estilo
                    adaptedPrompt = adaptedPrompt.replace(/^(design|create|generate|compose|arrange|layout)\s+/i, `$1 a cinematic thumbnail featuring ${themeData.subject}, `);
                } else {
                    // Adicionar no in√≠cio com personagem din√¢mico
                    adaptedPrompt = `Generate a cinematic thumbnail featuring ${themeData.subject}, ${adaptedPrompt}`;
                }
            }
        }
        
        // 9. ADICIONAR AMBIENTA√á√ÉO DIN√ÇMICA (sempre, mesmo se j√° tiver alguma men√ß√£o)
        // Verificar se j√° menciona ambiente gen√©rico
        const ambienteWords = themeData.ambiente.toLowerCase().split(',').map(w => w.trim()).filter(w => w.length > 3);
        const hasAmbiente = ambienteWords.some(word => adaptedPrompt.toLowerCase().includes(word));
        
        if (!hasAmbiente) {
            // Adicionar ambiente din√¢mico do t√≠tulo
            adaptedPrompt += `. Background setting: ${themeData.ambiente}. Include contextual elements: ${themeData.elementos}.`;
        } else {
            // Se j√° tem ambiente, apenas adicionar elementos se n√£o estiverem presentes
            const elementosWords = themeData.elementos.toLowerCase().split(',').map(w => w.trim()).filter(w => w.length > 3);
            const hasElementos = elementosWords.some(word => adaptedPrompt.toLowerCase().includes(word));
            if (!hasElementos) {
                adaptedPrompt += ` Include elements: ${themeData.elementos}.`;
            }
        }
        
        // 10. GARANTIR ACESS√ìRIOS DIN√ÇMICOS
        if (themeData.acessorios && !adaptedPrompt.toLowerCase().includes(themeData.acessorios.toLowerCase().split(' ')[0])) {
            // Adicionar acess√≥rios se n√£o estiverem presentes
            adaptedPrompt = adaptedPrompt.replace(/(wearing|with|and)\s+[^,\.]+(?:accessories|jewelry|regalia|attire)/gi, `$1 ${themeData.acessorios}`);
            if (!adaptedPrompt.includes(themeData.acessorios)) {
                adaptedPrompt += ` Accessories: ${themeData.acessorios}.`;
            }
        }

        basePrompt = adaptedPrompt;
        
        console.log('[Thumbnail Complete] Prompt adaptado:', {
            theme,
            subject: themeData.subject,
            ambiente: themeData.ambiente,
            elementos: themeData.elementos,
            promptPreview: basePrompt.substring(0, 200) + '...'
        });

        // 4. Gerar headline de impacto e descri√ß√£o SEO usando IA
        let apiKey = null;
        let service = null;
        let modelToUse = null;
        
        // Se ai_model foi fornecido, usar o modelo especificado
        if (ai_model) {
            if (ai_model.includes('claude') || ai_model === 'claude-3-7-sonnet-20250219') {
                service = 'claude';
                modelToUse = 'claude-3-7-sonnet-20250219';
            } else if (ai_model.includes('gpt') || ai_model === 'gpt-4o') {
                service = 'openai';
                modelToUse = 'gpt-4o';
            } else if (ai_model.includes('gemini') || ai_model === 'gemini-2.5-pro') {
                service = 'gemini';
                modelToUse = 'gemini-2.5-pro';
            }
            
            // Buscar API key para o servi√ßo especificado
            if (service) {
                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                if (keyData && keyData.api_key) {
                    try {
                        apiKey = decrypt(keyData.api_key);
                    } catch (e) {
                        service = null;
                        modelToUse = null;
                    }
                } else {
                    service = null;
                    modelToUse = null;
                }
            }
        }
        
        // Se n√£o especificado ou falhou, usar prioridade autom√°tica
        if (!apiKey) {
            const services = ['claude', 'openai', 'gemini'];
            for (const svc of services) {
                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
                if (keyData && keyData.api_key) {
                    try {
                        apiKey = decrypt(keyData.api_key);
                        service = svc;
                        if (svc === 'claude') modelToUse = 'claude-3-7-sonnet-20250219';
                        else if (svc === 'openai') modelToUse = 'gpt-4o';
                        else modelToUse = 'gemini-2.5-pro';
                        break;
                    } catch (e) {
                        continue;
                    }
                }
            }
        }

        if (!apiKey) {
            return res.status(400).json({ msg: 'Nenhuma API key configurada. Configure pelo menos uma API nas Configura√ß√µes.' });
        }

        // Prompt para gerar headline e SEO
        const seoPrompt = `Com base no t√≠tulo do v√≠deo: "${titleText}"

Gere:
1. Uma HEADLINE DE IMPACTO (m√°ximo 6 palavras, chamativa, viral, que gere curiosidade)
2. Uma DESCRI√á√ÉO SEO otimizada (2-3 frases, inclua palavras-chave relevantes, seja persuasiva)
3. PRINCIPAIS TAGS (10-15 tags separadas por v√≠rgula, relevantes ao tema)

RESPONDA APENAS COM JSON:
{
  "headline": "HEADLINE DE IMPACTO AQUI",
  "seoDescription": "Descri√ß√£o SEO otimizada aqui...",
  "tags": "tag1, tag2, tag3, tag4, tag5..."
}`;

        let seoResponse;
        if (service === 'claude') {
            seoResponse = await callClaudeAPI(seoPrompt, apiKey, modelToUse);
        } else if (service === 'openai') {
            seoResponse = await callOpenAIAPI(seoPrompt, apiKey, modelToUse);
        } else {
            seoResponse = await callGeminiAPI(seoPrompt, apiKey, modelToUse);
        }

        const seoText = typeof seoResponse === 'string' ? seoResponse : (seoResponse.titles || JSON.stringify(seoResponse));
        const parsedSEO = parseAIResponse(seoText, service);
        
        const headline = parsedSEO.headline || titleText.split(':')[0].trim();
        const seoDescription = parsedSEO.seoDescription || `Descubra tudo sobre ${titleText}. Conte√∫do exclusivo e detalhado.`;
        const tags = parsedSEO.tags ? parsedSEO.tags.split(',').map(t => t.trim()).filter(Boolean) : [];

        // 5. Adaptar prompt visual com headline (APENAS HEADLINE, SEM SUBHEADLINE OU OUTROS TEXTOS)
        const headlineText = headline;
        // Instru√ß√£o clara: apenas a headline deve aparecer, sem outros textos
        const headlineLine = `Display ONLY the headline text "${headlineText}" (translate to ${language}) in large, bold, gold metallic serif font with subtle glow effect at the bottom of the image. Do NOT render the word 'Headline' or 'Subheadline' or any other labels. Do NOT add any subheadline, subtitle, or additional text. Only the headline text itself should be visible.`;
        const styleLock = 'Keep composition, subject placement, palette, typography and lighting exactly as in channel references. Do not change layout. Maintain gold title text at bottom with dramatic lighting. Do not render any literal text from these instructions.';
        // Instru√ß√µes espec√≠ficas para remover marca√ß√µes nos 4 cantos
        const negativeBlock = `CRITICAL - REMOVE ALL CORNER MARKINGS: Exclude any logos, watermarks, channel badges, branding marks, corner icons, decorative elements, or any visual elements in the four corners of the image (top-left, top-right, bottom-left, bottom-right). The image must be completely clean in all four corners. Do not render channel names, corner marks, badges, icons, symbols, text, or any decorative elements in the corners. Do NOT render any text except the headline. Do NOT add subheadlines, subtitles, or any additional text labels. The entire image area must be free of any corner markings, branding elements, or visual clutter in the corners.`;
        
        let finalPrompt = `${basePrompt}\n\n${headlineLine}\n\n${negativeBlock}\n\n${styleLock}`;

        // 6. Gerar imagens
        const images = [];
        for (let i = 0; i < Math.max(1, Math.min(variations, 4)); i++) {
            const genResp = await fetch(`http://localhost:${PORT}/api/generate/imagefx`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': req.headers['authorization'] || '' },
                body: JSON.stringify({ prompt: finalPrompt, niche, subniche, style, saveToLibrary: true })
            });
            const genData = await genResp.json();
            if (!genResp.ok) throw new Error(genData.msg || 'Erro ao gerar imagem');
            images.push({
                imageUrl: genData.imageUrl || genData.image || genData.result || null,
                savedToLibrary: !!genData.savedToLibrary,
                libraryId: genData.libraryId || null
            });
        }

        // 7. Retornar resultado completo
        res.status(200).json({
            success: true,
            title: titleText,
            headline: headline,
            seoDescription: seoDescription,
            tags: tags,
            images: images,
            promptUsed: finalPrompt
        });

    } catch (err) {
        console.error('[Thumbnail Complete] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar thumbnail completa.' });
    }
});

app.post('/api/analyze/thumbnail', authenticateToken, async (req, res) => {
    let { videoId, selectedTitle, model, niche, subniche, language, includePhrases, style, customPrompt, thumbnailRule, theme_key, folder_id } = req.body;
    const userId = req.user.id;

    if (!videoId || !selectedTitle || !model || !niche || !subniche || !language || includePhrases === undefined || !style) {
        return res.status(400).json({ msg: 'Dados insuficientes para gerar ideias de thumbnail.' });
    }
    
    console.log(`[An√°lise-Thumb] Gerando thumbnails para pasta/canal: ${folder_id || 'Nenhuma pasta selecionada'}`);
    
    // Se thumbnailRule n√£o for fornecido, usar 'auto'
    thumbnailRule = thumbnailRule || 'auto';

    try {
        // --- 1. Identificar servi√ßo e verificar prefer√™ncias ---
        let service;
        
        // Mapear modelos corretamente
        if (model === 'gpt-4o') {
            service = 'openai';
            model = 'gpt-4o';
        } else if (model === 'claude-3-7-sonnet-20250219') {
            service = 'claude';
            model = 'claude-3-7-sonnet-20250219';
        } else if (model === 'gemini-2.5-pro') {
            service = 'gemini';
            model = 'gemini-2.5-pro';
        } else if (model.startsWith('gemini')) {
            service = 'gemini';
        } else if (model.startsWith('claude')) {
            service = 'claude';
        } else if (model.startsWith('gpt')) {
            service = 'openai';
        } else {
            service = 'gemini'; // Fallback
            model = 'gemini-2.5-pro';
        }

        // Verificar se deve usar cr√©ditos (laozhang.ai) ou API pr√≥pria
        // REGRA: Usa cr√©ditos se usu√°rio marcou prefer√™ncia OU n√£o tem plano que permite API pr√≥pria OU n√£o tem API pr√≥pria configurada
        // REGRA CR√çTICA: Se prefer√™ncia N√ÉO est√° marcada E usu√°rio tem plano que permite E tem API pr√≥pria ‚Üí usar API pr√≥pria
        let useLaozhang = false;
        let decryptedKey = null;
        
        try {
            let preferenceOrder = ['claude', 'openai', 'gemini'];
            if (service === 'gemini') preferenceOrder = ['gemini', 'claude', 'openai'];
            else if (service === 'claude') preferenceOrder = ['claude', 'openai', 'gemini'];
            else if (service === 'openai') preferenceOrder = ['openai', 'claude', 'gemini'];
            
            const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
            
            if (creditsCheck.shouldUse) {
                // Se deve usar cr√©ditos, usar laozhang.ai
                const laozhangKey = await getLaozhangApiKey();
                if (laozhangKey) {
                    useLaozhang = true;
                    decryptedKey = laozhangKey;
                    console.log(`[Analyze Thumbnail] ‚úÖ Usando Laozhang.ai (${creditsCheck.reason})`);
                } else {
                    console.warn('[Analyze Thumbnail] ‚ö†Ô∏è Laozhang.ai n√£o configurada, tentando usar APIs pr√≥prias do usu√°rio');
                }
            } else {
                console.log(`[Analyze Thumbnail] ‚úÖ Usando API pr√≥pria (${creditsCheck.reason})`);
            }
        } catch (err) {
            console.warn('[Analyze Thumbnail] Erro ao verificar uso de cr√©ditos:', err.message);
        }
        
        // Se n√£o usar laozhang.ai, buscar API pr√≥pria do usu√°rio
        if (!useLaozhang) {
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (!keyData) return res.status(400).json({ msg: `Chave de API do ${service} n√£o configurada.` });
            decryptedKey = decrypt(keyData.api_key);
            if (!decryptedKey) return res.status(500).json({ msg: 'Falha ao desencriptar a sua chave de API.' });
        }
        
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        const geminiApiKey = decrypt(geminiKeyData.api_key);
        if (!geminiApiKey) return res.status(400).json({ msg: 'Chave do Gemini (necess√°ria para o YouTube) n√£o encontrada.' });

        // --- 2. Buscar dados do v√≠deo original ---
        const videoDetails = await callYouTubeDataAPI(videoId, geminiApiKey);
        
        // --- 2.5. Buscar an√°lise original para pegar a f√≥rmula do t√≠tulo ---
        let formulaTitulo = null;
        let motivoSucesso = null;
        try {
            const originalAnalysis = await db.get(
                'SELECT analysis_data_json FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                [videoId, userId]
            );
            if (originalAnalysis && originalAnalysis.analysis_data_json) {
                const analysisData = JSON.parse(originalAnalysis.analysis_data_json);
                if (analysisData.formulaTitulo) {
                    formulaTitulo = analysisData.formulaTitulo;
                }
                if (analysisData.motivoSucesso) {
                    motivoSucesso = analysisData.motivoSucesso;
                }
            }
        } catch (err) {
            console.warn(`[An√°lise-Thumb] N√£o foi poss√≠vel buscar an√°lise original: ${err.message}`);
        }
        
        // --- 2.6. Buscar thumbnails de refer√™ncia do canal/nicho ---
        let thumbnailReferences = [];
        try {
            // PRIORIDADE 1: Buscar thumbnails de refer√™ncia da PASTA/CANAL espec√≠fica primeiro
            if (folder_id) {
                const folderRefs = await db.all(
                    'SELECT id, thumbnail_base64, channel_name, niche, subniche, description, folder_id FROM thumbnail_references WHERE user_id = ? AND folder_id = ? ORDER BY created_at DESC LIMIT 5',
                    [userId, folder_id]
                );
                
                if (folderRefs && folderRefs.length > 0) {
                    thumbnailReferences = folderRefs;
                    console.log(`[An√°lise-Thumb] ‚úÖ Encontradas ${thumbnailReferences.length} thumbnail(s) de refer√™ncia para o CANAL/PASTA ID ${folder_id} (prioridade m√°xima)`);
                }
            }
            
            // PRIORIDADE 2: Se n√£o houver thumbnails da pasta, buscar por nicho/subnicho
            if (thumbnailReferences.length === 0) {
                let refQuery = 'SELECT id, thumbnail_base64, channel_name, niche, subniche, description, folder_id FROM thumbnail_references WHERE user_id = ?';
                const refParams = [userId];
                
                // Buscar por subniche, niche ou sem filtro espec√≠fico (para pegar thumbnails gerais tamb√©m)
                // Priorizar subniche, depois niche, depois qualquer thumbnail do usu√°rio
                if (subniche || niche) {
                    refQuery += ' AND (';
                    const conditions = [];
                    if (subniche) {
                        conditions.push('subniche = ?');
                        refParams.push(subniche);
                    }
                    if (niche) {
                        conditions.push('niche = ?');
                        refParams.push(niche);
                    }
                    // Tamb√©m incluir thumbnails sem filtro espec√≠fico (NULL)
                    conditions.push('(subniche IS NULL AND niche IS NULL)');
                    refQuery += conditions.join(' OR ') + ')';
                }
                
                // Excluir thumbnails que j√° t√™m uma pasta espec√≠fica (pois s√£o de outros canais)
                refQuery += ' AND folder_id IS NULL';
                refQuery += ' ORDER BY created_at DESC LIMIT 5'; // Limitar a 5 thumbnails de refer√™ncia
                
                const refs = await db.all(refQuery, refParams);
                thumbnailReferences = refs || [];
                
                if (thumbnailReferences.length > 0) {
                    console.log(`[An√°lise-Thumb] ‚úÖ Encontradas ${thumbnailReferences.length} thumbnail(s) de refer√™ncia para o nicho/subnicho (fallback)`);
                } else {
                    console.log(`[An√°lise-Thumb] ‚ö†Ô∏è Nenhuma thumbnail de refer√™ncia encontrada para esta pasta ou nicho/subnicho`);
                }
            }
        } catch (err) {
            console.warn(`[An√°lise-Thumb] Erro ao buscar thumbnails de refer√™ncia: ${err.message}`);
        }
        
        // --- 3. Criar o prompt multimodal (PROMPT REFINADO ou CUSTOMIZADO) ---
        let thumbPrompt;
        
        // Pr√©-calcular ambienta√ß√£o din√¢mica pelo t√≠tulo (ou tema manual) ANTES de construir o prompt
        const themeKeyManual = theme_key || null;
        let dbMatchLocal = null;
        if (themeKeyManual) {
            await ensureAmbientationsTable();
            dbMatchLocal = await db.get('SELECT * FROM niche_ambientations WHERE user_id = ? AND theme_key = ? LIMIT 1', [userId, themeKeyManual]);
        }
        if (!dbMatchLocal) {
            dbMatchLocal = await detectAmbientationFromTitle(userId, selectedTitle, niche);
        }
        const ambientacaoArr = dbMatchLocal ? String(dbMatchLocal.ambiente || '').split(',').map(s => s.trim()).filter(Boolean) : [];
        const elementosArr = dbMatchLocal ? String(dbMatchLocal.elementos || '').split(',').map(s => s.trim()).filter(Boolean) : [];
        const acessoriosCalc = dbMatchLocal ? String(dbMatchLocal.acessorios || '') : '';
        const personagemCalc = dbMatchLocal && dbMatchLocal.subject ? dbMatchLocal.subject : 'historical figure with authentic attire';
        const ambientacaoCalc = ambientacaoArr.length ? ambientacaoArr.join(', ') : 'landscapes and architecture matching the title theme';
        const elementosDeFundoCalc = elementosArr.length ? elementosArr.join(', ') : 'contextual historical elements';

        // --- 3.1. Se customPrompt for um prompt padr√£o, adaptar ao t√≠tulo espec√≠fico ---
        let adaptedCustomPrompt = customPrompt;
        if (customPrompt && customPrompt.trim()) {
            try {
                console.log('[Thumbnail Gen] Adaptando prompt padr√£o ao t√≠tulo espec√≠fico...');
                
                // Criar prompt para a IA adaptar o prompt padr√£o ao t√≠tulo
                const adaptationPrompt = `Voc√™ √© um especialista em adapta√ß√£o de prompts visuais para thumbnails do YouTube.

TAREFA: Adapte o prompt padr√£o abaixo para o t√≠tulo espec√≠fico do v√≠deo, mantendo EXATAMENTE a estrutura visual e estilo do prompt padr√£o, mas ajustando o conte√∫do/tema/ambienta√ß√£o para o t√≠tulo fornecido.

PROMPT PADR√ÉO (ESTRUTURA E ESTILO A MANTER):
"""
${customPrompt}
"""

T√çTULO DO V√çDEO:
"${selectedTitle}"

NICHO/SUBNICHO:
${niche} / ${subniche}

INSTRU√á√ïES:
1. Analise o prompt padr√£o e identifique:
   - Estrutura de composi√ß√£o (layout, posicionamento de elementos)
   - Estilo visual (paleta de cores, tipografia, ilumina√ß√£o)
   - Elementos t√©cnicos (resolu√ß√£o, efeitos, tratamento)
   - Padr√µes de texto/frases

2. Adapte o prompt para o t√≠tulo "${selectedTitle}":
   - MANTENHA: toda a estrutura visual, estilo, composi√ß√£o, paleta de cores, tipografia
   - AJUSTE: personagem/sujeito, ambienta√ß√£o, cen√°rio, elementos de fundo para corresponder ao tema do t√≠tulo
   - SUBSTITUA: refer√™ncias gen√©ricas por elementos espec√≠ficos do t√≠tulo
   - PRESERVE: todos os elementos t√©cnicos e de qualidade (resolu√ß√£o, efeitos, etc.)

3. O prompt adaptado deve:
   - Seguir EXATAMENTE o mesmo formato e estrutura do prompt padr√£o
   - Manter o mesmo estilo visual e composi√ß√£o
   - Aplicar o tema/contexto do t√≠tulo "${selectedTitle}"
   - Ser espec√≠fico e detalhado como o prompt padr√£o

4. Retorne APENAS o prompt adaptado, sem explica√ß√µes ou coment√°rios adicionais.

PROMPT ADAPTADO:`;

                // Chamar IA para adaptar o prompt
                let adaptedResponse;
                if (useLaozhang) {
                    adaptedResponse = await callLaozhangAPI(
                        adaptationPrompt,
                        decryptedKey,
                        'gpt-4o',
                        null,
                        userId,
                        '/api/analyze/thumbnail',
                        JSON.stringify({ endpoint: '/api/analyze/thumbnail', operation: 'adapt-prompt' })
                    );
                } else if (service === 'openai') {
                    adaptedResponse = await callOpenAIAPI(adaptationPrompt, decryptedKey, model);
                    adaptedResponse = adaptedResponse.titles || adaptedResponse;
                } else if (service === 'claude') {
                    adaptedResponse = await callClaudeAPI(adaptationPrompt, decryptedKey, model);
                    adaptedResponse = adaptedResponse.titles || adaptedResponse;
                } else if (service === 'gemini') {
                    adaptedResponse = await callGeminiAPI(adaptationPrompt, decryptedKey, model);
                    adaptedResponse = adaptedResponse.titles || adaptedResponse;
                }
                
                if (adaptedResponse && typeof adaptedResponse === 'string' && adaptedResponse.trim().length > 100) {
                    adaptedCustomPrompt = adaptedResponse.trim();
                    console.log('[Thumbnail Gen] ‚úÖ Prompt padr√£o adaptado com sucesso ao t√≠tulo');
                    console.log('[Thumbnail Gen] Prompt adaptado (preview):', adaptedCustomPrompt.substring(0, 300) + '...');
                } else {
                    console.warn('[Thumbnail Gen] ‚ö†Ô∏è Falha ao adaptar prompt, usando prompt padr√£o original');
                }
            } catch (adaptErr) {
                console.warn('[Thumbnail Gen] Erro ao adaptar prompt padr√£o:', adaptErr.message);
                console.warn('[Thumbnail Gen] Continuando com prompt padr√£o original');
            }
        }
        
        if (adaptedCustomPrompt && adaptedCustomPrompt.trim()) {
            // Se houver prompt customizado (original ou adaptado), usar ele como base
            thumbPrompt = `
            Voc√™ √© um especialista em YouTube, combinando as habilidades de um diretor de arte para thumbnails e um mestre de SEO.

            IMAGEM DE REFER√äNCIA: [A imagem da thumbnail original do v√≠deo est√° anexada]
            ${thumbnailReferences.length > 0 ? `
            üé® THUMBNAILS DE REFER√äNCIA DO CANAL/NICHO (IMPORTANTE - ESTILO DO CANAL):
            ${thumbnailReferences.map((ref, idx) => `[IMAGEM ${idx + 1} DE REFER√äNCIA DO CANAL: A thumbnail de refer√™ncia ${idx + 1} do canal est√° anexada${ref.description ? ` (Descri√ß√£o: ${ref.description})` : ''}]`).join('\n            ')}
            
            ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - USE AS THUMBNAILS DE REFER√äNCIA DO CANAL COMO ESTILO PRINCIPAL ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è:
            - Analise cuidadosamente TODAS as ${thumbnailReferences.length} thumbnail(s) de refer√™ncia do canal que est√£o anexadas acima.
            - Estas thumbnails representam o ESTILO VISUAL OFICIAL do canal/nicho "${subniche}".
            - A IDEIA 1 DEVE replicar fielmente o estilo visual dessas thumbnails de refer√™ncia do canal (composi√ß√£o, cores, tipografia, elementos visuais, posicionamento de texto, etc.).
            - Identifique os elementos comuns entre as thumbnails de refer√™ncia: tipo de composi√ß√£o, paleta de cores, estilo de texto, posicionamento de elementos, ilumina√ß√£o, etc.
            - Replique EXATAMENTE esse estilo visual na IDEIA 1, mantendo a identidade visual do canal.
            - A IDEIA 2 pode ser mais criativa, mas ainda deve respeitar a identidade visual do canal baseada nas thumbnails de refer√™ncia.
            - Se as thumbnails de refer√™ncia do canal usarem textos em dourado, composi√ß√£o dividida, close-up dram√°tico ou outros elementos espec√≠ficos, REPLIQUE-OS FIELMENTE na IDEIA 1.
            ` : ''}
            T√çTULO DO V√çDEO (para contexto): "${selectedTitle}"
            SUBNICHO (P√∫blico-Alvo): "${subniche}"
            ESTILO DE ARTE DESEJADO: "${style}"
            IDIOMA DO CONTE√öDO: "${language}"

            üé®üé®üé® PROMPT ADAPTADO DO ESTILO DO CANAL/NICHO PARA O T√çTULO "${selectedTitle}" üé®üé®üé®:
            ${adaptedCustomPrompt}
            
            üåçüåçüåç AMBIENTA√á√ÉO DETECTADA PELO T√çTULO "${selectedTitle}" (APLICAR AO CONTE√öDO) üåçüåçüåç:
            ${dbMatchLocal ? `
            - PERSONAGEM/SUJEITO: ${personagemCalc}
            - AMBIENTA√á√ÉO/CEN√ÅRIO: ${ambientacaoCalc}
            - ELEMENTOS DE FUNDO: ${elementosDeFundoCalc}
            ${acessoriosCalc ? `- ACESS√ìRIOS: ${acessoriosCalc}` : ''}
            
            ‚ö†Ô∏è CR√çTICO: Use esta ambienta√ß√£o detectada pelo t√≠tulo para definir o CONTE√öDO da thumbnail, mantendo o ESTILO VISUAL do prompt padr√£o acima.
            ` : `
            - A ambienta√ß√£o ser√° detectada automaticamente pelo t√≠tulo "${selectedTitle}".
            - Use elementos visuais relacionados ao tema do t√≠tulo, mantendo o estilo visual do prompt padr√£o.
            `}
            
            ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - O PROMPT PADR√ÉO √â APENAS ESTILO VISUAL - APLICAR AO T√çTULO "${selectedTitle}" ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è:
            - O PROMPT PADR√ÉO acima define APENAS o ESTILO VISUAL (composi√ß√£o, cores, tipografia, elementos, ilumina√ß√£o, atmosfera).
            - O CONTE√öDO das thumbnails deve ser SOBRE O T√çTULO "${selectedTitle}" que o usu√°rio escolheu.
            - N√ÉO use o conte√∫do do prompt padr√£o. Use APENAS o estilo visual dele.
            - N√ÉO crie um prompt novo. APLIQUE o estilo do prompt padr√£o ao t√≠tulo "${selectedTitle}".
            
            PROCESSO OBRIGAT√ìRIO:
            1. EXTRAIA do prompt padr√£o APENAS os elementos de ESTILO VISUAL:
               - Tipo de composi√ß√£o (ex: "close-up dram√°tico", "composi√ß√£o dividida", "cena √©pica")
               - Paleta de cores (ex: "dourado e azul escuro", "tons terrosos", "vermelho e preto")
               - Estilo de tipografia (ex: "textos dourados serifados com bevel/emboss", "fonte bold com outline preto")
               - Elementos visuais recorrentes (ex: "pir√¢mides ao fundo", "navios", "fogo", "tempestades", "silhuetas")
               - Ilumina√ß√£o e atmosfera (ex: "ilumina√ß√£o dram√°tica", "c√©u tempestuoso", "chiaroscuro", "luz dourada")
               - Estilo geral (ex: "cinematogr√°fico", "documental", "√©pico", "realista")
            
            2. IGNORE o conte√∫do/tema do prompt padr√£o. O conte√∫do deve ser sobre "${selectedTitle}".
            
            3. APLIQUE o estilo extra√≠do ao criar thumbnails sobre o t√≠tulo "${selectedTitle}":
               - Use a mesma composi√ß√£o (ex: se o estilo √© "close-up", fa√ßa close-up mas do assunto relacionado a "${selectedTitle}")
               - Use a mesma paleta de cores
               - Use o mesmo estilo de tipografia
               - Adapte os elementos visuais ao tema de "${selectedTitle}" (mantendo o estilo visual)
               - Use a mesma ilumina√ß√£o e atmosfera
               - Mantenha o estilo geral
            
            4. RESULTADO: Thumbnails sobre "${selectedTitle}" mas com o estilo visual do prompt padr√£o.
            
            EXEMPLO:
            - Se o prompt padr√£o diz "close-up de l√≠der ind√≠gena com textos dourados" mas o t√≠tulo √© sobre tecnologia inca:
              ‚Üí Use "close-up" (estilo) + "textos dourados" (estilo) + "tecnologia inca" (conte√∫do do t√≠tulo)
              ‚Üí RESULTADO: "close-up de tecnologia inca com textos dourados"
            
            ‚ö†Ô∏è N√ÉO REPLIQUE O PROMPT PADR√ÉO. APLIQUE APENAS O ESTILO AO T√çTULO ESCOLHIDO.

            ‚ö†Ô∏è ATEN√á√ÉO CR√çTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, n√£o ilustra√ß√µes, desenhos ou renderiza√ß√µes. A descri√ß√£oThumbnail deve descrever uma FOTO REAL tirada por um fot√≥grafo profissional em um local real, com pessoas reais e objetos reais.
            
            üé® IDENTIFICA√á√ÉO E REPLICA√á√ÉO DE ESTILOS √âPICOS/CINEMATOGR√ÅFICOS:
            
            Analise a IMAGEM DE REFER√äNCIA e identifique qual estilo visual ela utiliza. Se identificar algum dos estilos abaixo, REPLIQUE-O FIELMENTE na IDEIA 1, apenas melhorando a qualidade:
            
            üìê ESTILO 1: COMPOSI√á√ÉO DIVIDIDA (ESQUERDA/DIREITA):
            - Imagem dividida verticalmente em duas metades contrastantes
            - Lado esquerdo: geralmente cenas de paz/grandiosidade (cidades antigas, paisagens douradas, c√©u claro)
            - Lado direito: geralmente cenas de conflito/amea√ßa (tempestades, navios, ex√©rcitos, c√©u escuro)
            - Figura central ou pr√≥xima ao centro conectando os dois lados
            - Contraste dram√°tico entre luz (esquerda) e escurid√£o (direita)
            - Texto grande em dourado (#FFD700) na parte inferior, fonte serifada ornamentada com efeito emboss/bevel
            - Exemplos: Atahualpa (cidade dourada vs navios tempestuosos), Malinche (mapa vs batalha naval)
            
            üìê ESTILO 2: CLOSE-UP DRAM√ÅTICO COM BACKGROUND √âPICO:
            - Figura hist√≥rica em close-up ocupando 40-60% da imagem (rosto e parte superior do corpo)
            - Express√£o intensa e direta para a c√¢mera
            - Background dividido ou com elementos √©picos (pir√¢mides, navios, batalhas, fogo)
            - Ilumina√ß√£o dram√°tica com chiaroscuro (luz forte vs sombras profundas)
            - Texto grande em dourado na parte inferior
            - Exemplos: Fara√≥ com pir√¢mides ao fundo, l√≠der ind√≠gena com cidade antiga
            
            üìê ESTILO 3: CENA √âPICA COM ELEMENTOS DE DESTRUI√á√ÉO:
            - Cena de batalha ou conflito hist√≥rico
            - Elementos de fogo, fuma√ßa, tempestades
            - Navios em chamas, ex√©rcitos, destrui√ß√£o
            - C√©u tempestuoso com nuvens escuras
            - Figuras em primeiro plano com express√µes dram√°ticas
            - Texto grande em dourado/amarelo com outline preto
            - Exemplos: Batalhas navais, conquistas, segredos dos fara√≥s
            
            üìê ESTILO 4: FIGURA HIST√ìRICA COM ELEMENTOS SIMB√ìLICOS:
            - Figura hist√≥rica em destaque (fara√≥, l√≠der, conquistador)
            - Trajes elaborados e aut√™nticos (coroas, armaduras, roupas tradicionais)
            - Elementos simb√≥licos ao redor (pir√¢mides, navios, mapas, hier√≥glifos)
            - Composi√ß√£o vertical ou horizontal com figura dominante
            - Texto grande em dourado com fonte serifada ornamentada
            - Exemplos: Fara√≥ com pir√¢mides, l√≠der ind√≠gena com coroa elaborada
            
            ‚ö†Ô∏è REGRAS PARA REPLICA√á√ÉO FIEL:
            1. Se a thumbnail original usar COMPOSI√á√ÉO DIVIDIDA, mantenha EXATAMENTE essa estrutura (mesma divis√£o, mesmo contraste, mesma posi√ß√£o dos elementos)
            2. Se a thumbnail original usar CLOSE-UP DRAM√ÅTICO, mantenha o mesmo enquadramento e propor√ß√£o da figura
            3. Se a thumbnail original usar TEXTOS EM DOURADO, mantenha a mesma cor (#FFD700), fonte serifada e efeitos (emboss, bevel, glow)
            4. Se a thumbnail original usar ELEMENTOS √âPICOS (pir√¢mides, navios, fogo), mantenha os mesmos elementos na mesma posi√ß√£o
            5. Se a thumbnail original usar CONTRASTE LUZ/ESQUERID√ÉO, mantenha o mesmo esquema de ilumina√ß√£o
            6. Se a thumbnail original usar FIGURAS HIST√ìRICAS, mantenha o mesmo tipo de figura, trajes e express√£o
            7. Apenas MELHORE: nitidez 8K, contraste mais forte, cores mais saturadas, ilumina√ß√£o mais dram√°tica, texto com efeitos Photoshop mais refinados
            
            ${(() => {
                const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
                if (ruleData.mode === 'auto') {
                    return `\n            üîç MODO AUTOM√ÅTICO - AN√ÅLISE DE REGRA:\n            Analise o t√≠tulo "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPL√çCITA na descri√ß√£o da thumbnail. Se m√∫ltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.\n\n            üìã AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE (ALGORITMO OFICIAL):\n\n            1Ô∏è‚É£ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO):\n            O c√©rebro precisa entender a thumbnail em menos de 1 segundo. Se houver confus√£o, o clique cai.\n            Checklist OBRIGAT√ìRIO: 1 ideia principal, 1 personagem, 1 emo√ß√£o, 1 objeto-chave.\n            A thumbnail DEVE ser compreendida instantaneamente. Elimine qualquer elemento que cause confus√£o ou distra√ß√£o.\n\n            2Ô∏è‚É£ REGRA DO ASSUNTO √öNICO:\n            Nada divide a aten√ß√£o. A thumbnail boa √© sempre uma hist√≥ria em uma imagem.\n            Foque em UM √öNICO assunto dominante. Nada deve competir pela aten√ß√£o. A thumbnail deve contar uma hist√≥ria completa em uma √∫nica imagem, sem elementos que dividam o foco.\n\n            3Ô∏è‚É£ REGRA DO ROSTO GRANDE:\n            Rostos com forte express√£o emocional aumentam CTR de 20% a 60%.\n            Express√µes mais fortes: choque, surpresa, medo, raiva, felicidade extrema.\n            Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A express√£o facial DEVE ser EXTREMA e EMOCIONAL. O rosto deve ser o elemento dominante e a primeira coisa que o olho v√™.\n\n            4Ô∏è‚É£ REGRA DO CONTRASTE BRUTAL:\n            Se n√£o tiver contraste, a thumbnail fica invis√≠vel.\n            Use CONTRASTE BRUTAL entre: texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n            O contraste deve ser t√£o forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.\n\n            5Ô∏è‚É£ REGRA DA COR ESTRAT√âGICA:\n            Cada cor ativa um gatilho:\n            - Amarelo: aten√ß√£o imediata\n            - Vermelho: urg√™ncia / perigo\n            - Azul: confian√ßa\n            - Verde: dinheiro / solu√ß√£o\n            - Preto: premium / mist√©rio\n            Escolha a cor baseada na emo√ß√£o que o t√≠tulo transmite.\n\n            6Ô∏è‚É£ REGRA DOS TER√áOS:\n            Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso d√° harmonia e aumenta o foco natural.\n            Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos ter√ßos (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.\n\n            7Ô∏è‚É£ REGRA DO TEXTO ULTRA CURTO:\n            Texto deve ter 2 a 4 palavras, nunca mais.\n            Exemplos: "Ele mentiu", "Descobri isso", "Ningu√©m viu", "Proibido".\n            O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Textos longos matam o CTR. Seja brutalmente direto e impactante.\n\n            8Ô∏è‚É£ REGRA DO ZOOM EMOCIONAL:\n            Aparece sempre um elemento gigante que amplifica a emo√ß√£o ou o conflito.\n            Exemplos: uma conta banc√°ria gigante, uma faca gigante, uma lupa gigante, um n√∫mero gigante.\n            Use um elemento GIGANTE que amplifique a emo√ß√£o ou conflito. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.\n\n            9Ô∏è‚É£ REGRA DO MIST√âRIO:\n            Toda thumbnail viral tem uma pergunta impl√≠cita.\n            Exemplos: algo escondido atr√°s de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela.\n            Crie uma pergunta impl√≠cita na thumbnail. O espectador DEVE sentir curiosidade sobre o que est√° fora da imagem.\n\n            üîü REGRA DOS PONTOS DE FUGA:\n            Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.\n            Sinaliza√ß√µes: setas, linhas diagonais, perspectiva.\n            Use linhas visuais que guiem o olhar para o foco. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal.\n\n            1Ô∏è‚É£1Ô∏è‚É£ REGRA DO ESPA√áO NEGATIVO:\n            Deixar √°reas vazias acentua o foco. Sem isso, a imagem vira bagun√ßa.\n            Deixe √°reas vazias (espa√ßo negativo) que acentuem o foco no elemento principal. O espa√ßo vazio cria respira√ß√£o visual e faz o elemento principal "pular" da imagem.\n\n            1Ô∏è‚É£2Ô∏è‚É£ REGRA DA COER√äNCIA COM O T√çTULO:\n            Thumbnail e t√≠tulo precisam contar a mesma hist√≥ria, mas com √¢ngulos diferentes.\n            T√≠tulo = contexto, Thumbnail = emo√ß√£o.\n            A thumbnail e o t√≠tulo DEVEM contar a mesma hist√≥ria, mas com √¢ngulos diferentes. A thumbnail deve amplificar a emo√ß√£o que o t√≠tulo promete, criando uma sinergia perfeita.\n\n            ‚ö†Ô∏è CR√çTICO: Identifique qual regra melhor se encaixa no t√≠tulo "${selectedTitle}" e aplique-a de forma EXPL√çCITA e RIGOROSA na descri√ß√£o da thumbnail. Se m√∫ltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.`;
                } else {
                    return `\n            üìã REGRA SELECIONADA: ${ruleData.rule.name}\n            ${ruleData.rule.description}\n\n            ${ruleData.rule.checklist ? `‚úÖ Checklist: ${ruleData.rule.checklist.join(', ')}` : ''}\n            ${ruleData.rule.expressions ? `üòÆ Express√µes recomendadas: ${ruleData.rule.expressions.join(', ')}` : ''}\n            ${ruleData.rule.contrasts ? `üé® Contrastes: ${ruleData.rule.contrasts.join(', ')}` : ''}\n            ${ruleData.rule.colors ? `üåà Cores estrat√©gicas: ${Object.entries(ruleData.rule.colors).map(([k, v]) => `${k} (${v})`).join(', ')}` : ''}\n            ${ruleData.rule.examples ? `üí° Exemplos: ${ruleData.rule.examples.join(', ')}` : ''}\n            ${ruleData.rule.elements ? `‚û°Ô∏è Elementos: ${ruleData.rule.elements.join(', ')}` : ''}\n\n            ‚ö†Ô∏è CR√çTICO: Aplique esta regra de forma EXPL√çCITA e RIGOROSA na descri√ß√£o da thumbnail:\n            ${ruleData.instructions}`;
                }
            })()}
            
            üéØ OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando t√©cnicas de Thumbnail Designer profissional:
            - TEXTO PROFISSIONAL (COMO PHOTOSHOP): O texto DEVE parecer feito no Photoshop por um designer profissional. Use m√∫ltiplos efeitos de camada (stroke, drop shadow com valores espec√≠ficos, outer glow, bevel and emboss), tipografia profissional com kerning perfeito, renderiza√ß√£o profissional com anti-aliasing. Grande, estilizado, cores vibrantes (amarelo/vermelho/branco com outline preto), efeitos visuais profissionais com valores espec√≠ficos (dist√¢ncia, spread, tamanho, opacidade, √¢ngulo), posicionamento estrat√©gico (topo/centro), ocupando 25-35% da imagem. O texto DEVE ter qualidade de ag√™ncia de design, n√£o amador.
            - COMPOSI√á√ÉO: Regra dos ter√ßos, hierarquia visual clara, elemento principal em destaque
            - CORES: Alto contraste, cores complementares, satura√ß√£o otimizada, fundo que faz o texto "pular"
            - EMO√á√ÉO: Express√µes faciais intensas, momentos de tens√£o, curiosidade visual
            - ELEMENTOS VIRAIS: FOMO (medo de perder), surpresa, contraste dram√°tico, storytelling visual
            
            SUA TAREFA:
            Crie DUAS (2) ideias distintas para uma nova thumbnail baseadas no prompt personalizado acima.
            
            ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - ORDEM DAS IDEIAS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
            ${hasStandardPrompt ? `
            ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ATEN√á√ÉO CR√çTICA: PROMPT PADR√ÉO EST√Å ATIVO - USAR APENAS O ESTILO VISUAL ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
            - O PROMPT PADR√ÉO acima √© APENAS ESTILO VISUAL (como criar), N√ÉO √© o conte√∫do (o que criar).
            - O CONTE√öDO das thumbnails DEVE ser sobre o t√≠tulo "${selectedTitle}" que o usu√°rio escolheu.
            - Ambas as IDEIAS devem APLICAR o estilo visual do prompt padr√£o ao t√≠tulo "${selectedTitle}".
            - N√ÉO use o conte√∫do/tema do prompt padr√£o. Use APENAS os elementos de estilo (composi√ß√£o, cores, tipografia, ilumina√ß√£o, atmosfera).
            - EXTRAIA o estilo do prompt padr√£o e APLIQUE ao tema de "${selectedTitle}".

            ` : ''}
            - **IDEIA 1 (R√âPLICA E MELHORIA DA THUMBNAIL ORIGINAL DO V√çDEO):** 
              * OBRIGAT√ìRIO: Esta ideia DEVE replicar e melhorar a thumbnail ORIGINAL do v√≠deo ao qual foram feitos os t√≠tulos.
              ${hasStandardPrompt ? `* APLIQUE O ESTILO DO PROMPT PADR√ÉO: Use os elementos de estilo do prompt padr√£o (composi√ß√£o, cores, tipografia, ilumina√ß√£o) mantendo o conte√∫do relacionado ao t√≠tulo "${selectedTitle}".\n` : ''}
              * Analise cuidadosamente a IMAGEM DE REFER√äNCIA (thumbnail original do v√≠deo) que est√° anexada.
              * IDENTIFIQUE O ESTILO VISUAL ESPEC√çFICO da thumbnail original (composi√ß√£o dividida, close-up dram√°tico, cena √©pica, figura hist√≥rica, etc.) usando a se√ß√£o "üé® IDENTIFICA√á√ÉO E REPLICA√á√ÉO DE ESTILOS √âPICOS/CINEMATOGR√ÅFICOS" acima.
              ${hasStandardPrompt ? `* INTEGRE O ESTILO DO PROMPT PADR√ÉO: Mantenha a estrutura da thumbnail original, mas aplique os elementos de estilo do prompt padr√£o (cores, tipografia, ilumina√ß√£o, atmosfera).\n` : ''}
              * Replique a estrutura da thumbnail original quase 1:1: mantenha EXATAMENTE a mesma composi√ß√£o, √¢ngulo de c√¢mera, enquadramento, posi√ß√£o dos personagens/objetos, paleta de cores, quantidade de texto, posi√ß√£o do texto, elementos visuais principais e storytelling.
              * Se a thumbnail usar COMPOSI√á√ÉO DIVIDIDA: mantenha EXATAMENTE a mesma divis√£o vertical, mesmo contraste luz/escurid√£o, mesma posi√ß√£o dos elementos em cada lado.
              * Se a thumbnail usar TEXTOS EM DOURADO: mantenha a mesma cor (#FFD700), fonte serifada ornamentada, efeitos emboss/bevel, mesma posi√ß√£o e tamanho.
              * Se a thumbnail usar ELEMENTOS √âPICOS (pir√¢mides, navios, fogo, tempestades): mantenha os mesmos elementos na mesma posi√ß√£o e propor√ß√£o.
              * Se a thumbnail usar FIGURAS HIST√ìRICAS: mantenha o mesmo tipo de figura, trajes, express√£o e enquadramento.
              * PRESERVE o poder viral da thumbnail original que gerou milh√µes de views.
              * Apenas ELEVE A QUALIDADE: mais nitidez (8K), contraste refor√ßado, ilumina√ß√£o cinematogr√°fica profissional, corre√ß√µes de cor profissionais, tratamento de pele profissional, brilho nos olhos, textura realista, limpeza de ru√≠dos, adicione luzes/sombras profissionais, aplique efeitos de texto Photoshop com valores espec√≠ficos (stroke, drop shadow, outer glow, bevel & emboss).
              * N√ÉO altere o storytelling principal, apenas entregue a vers√£o definitiva com acabamento premium.
              * Resultado: praticamente igual √† thumbnail original, mas com sensa√ß√£o de upgrade premium e leitura instant√¢nea mais clara e clic√°vel.
              * IMPORTANTE: Se a thumbnail original n√£o estiver dispon√≠vel ou n√£o puder ser analisada, ainda assim mantenha o mesmo conceito visual e estrutura, apenas melhorando a qualidade.
            
            - **IDEIA 2 (THUMBNAIL MELHORADA E OTIMIZADA):** 
              * Esta √© uma vers√£o COMPLETAMENTE NOVA, melhorada e otimizada para CTR alto (30%+).
              * Crie um conceito totalmente novo com foco em CTR m√°ximo: novo enquadramento, nova composi√ß√£o, novos elementos que gerem curiosidade extrema.
              * Use gatilhos agressivos (perigo, segredo revelado, n√∫meros gigantes, setas, antes/depois, close dram√°tico) e cores super contrastantes.
              * Construa um storytelling diferente, alinhado ao t√≠tulo "${selectedTitle}", que prometa algo ainda mais irresist√≠vel que a vers√£o original.
              * O texto deve ser redesenhado para m√°xima legibilidade mobile, com layer styles profissionais e valores precisos.
              * Pode mudar cen√°rio, personagens, enquadramento e paleta, explorando um novo gancho visual com FOMO extremo, contraste m√°ximo, express√µes dram√°ticas e elementos que n√£o existem na thumb original.
              * Objetivo: criar uma thumbnail in√©dita que pare√ßa "campanha de performance", otimizada para CTR alto e reten√ß√£o visual imediata.
              * Esta vers√£o deve ser AINDA MELHOR que a original, com t√©cnicas avan√ßadas de viraliza√ß√£o.

            PARA CADA UMA DAS 2 IDEIAS, GERE:
            1.  **"seoDescription"**: Uma descri√ß√£o de v√≠deo para o YouTube, EXTREMAMENTE OTIMIZADA PARA SEO E VIRALIZA√á√ÉO, com:
               - Emojis estrat√©gicos e relevantes (use emojis que representem o nicho e subnicho)
               - Par√°grafos bem estruturados com quebras de linha
               - Chamadas para a√ß√£o (CTA) claras e persuasivas
               - Uso estrat√©gico de palavras-chave relevantes para o t√≠tulo "${selectedTitle}" e subnicho "${subniche}"
               - Formata√ß√£o profissional com separadores visuais (‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ)
               - Se√ß√µes organizadas: introdu√ß√£o, conte√∫do do v√≠deo, sobre o canal, links importantes, hashtags
               - Linguagem persuasiva e envolvente que gere curiosidade e urg√™ncia
               - A descri√ß√£o deve estar no idioma "${language}" e ter entre 300-500 palavras
               - IMPORTANTE: Use emojis de forma estrat√©gica (n√£o exagere, mas use para destacar se√ß√µes importantes)
               - Inclua hashtags relevantes no final
               - Seja espec√≠fico sobre o que o espectador vai aprender/ganhar
               
            2.  **"seoTags"**: Um array de strings com as 15-25 tags MAIS RELEVANTES E ESTRAT√âGICAS para o v√≠deo (LIMITE M√ÅXIMO: 300 caracteres no total, incluindo v√≠rgulas e espa√ßos. N√ÉO ultrapasse 300 caracteres), incluindo:
               - Tags de cauda curta (1-2 palavras): termos populares e competitivos relacionados ao t√≠tulo "${selectedTitle}" e subnicho "${subniche}"
               - Tags de cauda longa (3-5 palavras): termos mais espec√≠ficos e menos competitivos que capturam inten√ß√£o de busca
               - Tags de nicho: termos espec√≠ficos do subnicho "${subniche}"
               - Tags de tend√™ncia: termos que est√£o em alta no momento relacionados ao tema
               - Tags de formato: termos como "tutorial", "dicas", "como fazer", "guia completo", "passo a passo", etc.
               - Tags de plataforma: termos relacionados √† plataforma (YouTube, TikTok, Instagram, etc.)
               - Tags de emo√ß√£o: termos que capturam a emo√ß√£o do t√≠tulo (ex: "surpresa", "revela√ß√£o", "mist√©rio", "urg√™ncia", "choque")
               - Tags de benef√≠cio: termos que descrevem o que o espectador vai ganhar/aprender
               - Tags de palavra-chave principal: extrair as palavras-chave mais importantes do t√≠tulo "${selectedTitle}"
               - Tags de sin√¥nimos: varia√ß√µes e sin√¥nimos das palavras-chave principais
               - IMPORTANTE: As tags devem ser EXTREMAMENTE RELEVANTES ao t√≠tulo "${selectedTitle}" e ao subnicho "${subniche}"
               - Evite tags gen√©ricas que n√£o agregam valor
               - Priorize tags que tenham volume de busca mas n√£o sejam extremamente competitivas
               - Misture tags em portugu√™s/ingl√™s/espanhol conforme o idioma "${language}"
               - LIMITE M√ÅXIMO: 300 caracteres no total (incluindo v√≠rgulas e espa√ßos). N√ÉO ultrapasse 300 caracteres.
               - Cada tag deve ter entre 1-5 palavras, sendo a maioria com 2-3 palavras para otimizar o uso do espa√ßo
               - Priorize tags mais relevantes e estrat√©gicas. Se necess√°rio, reduza a quantidade de tags para n√£o ultrapassar 300 caracteres.
            3.  **"frasesDeGancho"**: Um array com 5 frases CURTAS de impacto (ganchos) para a thumbnail, OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne um array vazio [].' : `
                ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO E OBRIGAT√ìRIO - IDIOMA DAS FRASES DE GANCHO ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Portugu√™s' ? `
                ‚úÖ CORRETO (Portugu√™s): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revela√ß√£o Surpreendente"
                ‚ùå ERRADO (Ingl√™s - N√ÉO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ‚ùå ERRADO (Espanhol - N√ÉO USAR): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"
                ` : language === 'Ingl√™s' ? `
                ‚úÖ CORRETO (Ingl√™s): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ‚ùå ERRADO (Portugu√™s - N√ÉO USAR): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"
                ‚ùå ERRADO (Espanhol - N√ÉO USAR): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"
                ` : `
                ‚úÖ CORRETO (Espanhol): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante", "La Verdad", "Nunca Visto", "Descubr√≠ Todo", "Esto Cambi√≥ Todo", "Revelaci√≥n Sorprendente"
                ‚ùå ERRADO (Portugu√™s - N√ÉO USAR): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"
                ‚ùå ERRADO (Ingl√™s - N√ÉO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGAT√ìRIAS:
                1. Se "${language}" for "Portugu√™s", TODAS as 5 frases DEVEM estar em PORTUGU√äS (Brasil)
                2. Se "${language}" for "Ingl√™s", TODAS as 5 frases DEVEM estar em INGL√äS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em ingl√™s se o idioma escolhido for portugu√™s ou espanhol
                5. NUNCA, JAMAIS retorne frases em portugu√™s se o idioma escolhido for ingl√™s ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for portugu√™s ou ingl√™s
                7. Cada frase deve ter 2 a 4 palavras, no m√°ximo
                8. As frases devem ser impactantes e relacionadas ao t√≠tulo "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases est√£o no idioma "${language}"?
                - Nenhuma frase est√° em ingl√™s se "${language}" for portugu√™s ou espanhol?
                - Nenhuma frase est√° em portugu√™s se "${language}" for ingl√™s ou espanhol?
                - Nenhuma frase est√° em espanhol se "${language}" for portugu√™s ou ingl√™s?
                
                Se alguma resposta for N√ÉO, CORRIJA as frases antes de retornar o JSON.
                `}
            4.  **"descricaoThumbnail"**: Um prompt EXTREMAMENTE DETALHADO e V√çVIDO, em INGL√äS, para uma IA de gera√ß√£o de imagem. ${!includePhrases ? 'N√ÉO inclua nenhum placeholder para texto. A thumbnail deve ser APENAS imagem, sem texto ou frases de gancho.' : 'A descri√ß√£o DEVE incluir OBRIGATORIAMENTE o placeholder exato "[FRASE DE GANCHO AQUI]" em algum lugar da descri√ß√£o, onde o texto da thumbnail ser√° inserido. CR√çTICO: O placeholder "[FRASE DE GANCHO AQUI]" DEVE aparecer literalmente na descri√ß√£o. Quando mencionar o texto, descreva-o como se fosse criado no Photoshop por um designer profissional: use termos como "Professional Photoshop-quality text design displaying [FRASE DE GANCHO AQUI]", "professional layer effects", "Photoshop stroke effect", "professional drop shadow with specific values (distance, spread, size, opacity, angle)", "professional outer glow", "professional bevel and emboss", "professional typography with perfect kerning", "professional text rendering with anti-aliasing", "looks like it was designed by a professional graphic designer". O texto DEVE ter m√∫ltiplos efeitos de camada do Photoshop com valores espec√≠ficos, n√£o apenas descri√ß√µes gen√©ricas. Fonte estilizada profissional, grande e impactante, cores vibrantes e contrastantes, efeitos visuais profissionais (sombra com valores espec√≠ficos, brilho, outline, gradiente), posicionamento estrat√©gico, tamanho grande que ocupa 25-35% da imagem. IMPORTANTE: Sempre inclua o texto "[FRASE DE GANCHO AQUI]" literalmente na descri√ß√£o, por exemplo: "with professional text design displaying [FRASE DE GANCHO AQUI]" ou "featuring large bold text that says [FRASE DE GANCHO AQUI]".'}

${customPrompt && customPrompt.trim() ? `\n‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - O PROMPT PADR√ÉO √â APENAS ESTILO - APLICAR AO T√çTULO "${selectedTitle}" ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è:\nA descri√ß√£oThumbnail DEVE APLICAR APENAS O ESTILO VISUAL do prompt padr√£o acima ao t√≠tulo "${selectedTitle}".\n\nPROCESSO OBRIGAT√ìRIO:\n1. EXTRAIA do prompt padr√£o APENAS os elementos de ESTILO VISUAL (composi√ß√£o, cores, tipografia, elementos visuais, ilumina√ß√£o, atmosfera).\n2. IGNORE o conte√∫do/tema do prompt padr√£o. O conte√∫do DEVE ser sobre "${selectedTitle}".\n3. APLIQUE o estilo extra√≠do ao criar uma thumbnail sobre "${selectedTitle}".\n4. RESULTADO: Thumbnail sobre "${selectedTitle}" mas com o estilo visual do prompt padr√£o.\n\nEXEMPLO PR√ÅTICO:\n- Prompt padr√£o: "close-up dram√°tico de l√≠der ind√≠gena com textos dourados serifados"\n- T√≠tulo escolhido: "${selectedTitle}" (ex: sobre tecnologia inca)\n- RESULTADO: "close-up dram√°tico de [elementos relacionados a ${selectedTitle}] com textos dourados serifados"\n\n‚ö†Ô∏è N√ÉO USE O CONTE√öDO DO PROMPT PADR√ÉO. USE APENAS O ESTILO E APLIQUE AO T√çTULO "${selectedTitle}".\n\nüö´ OBRIGAT√ìRIO - INSTRU√á√ïES DE EXCLUS√ÉO (SEMPRE INCLUIR NA descricaoThumbnail):\nA descricaoThumbnail DEVE SEMPRE incluir estas instru√ß√µes de exclus√£o no final:\n"Exclude mesoamerican pyramids, feathered headdress, conquistadors, Spanish ships, jaguar motifs, and any aztec elements unless specifically relevant to the detected theme. Exclude any logos, watermarks, channel badges or branding marks. Do not render channel names or corner marks."\n\n‚ö†Ô∏è CR√çTICO: Estas instru√ß√µes de exclus√£o s√£o OBRIGAT√ìRIAS e devem ser inclu√≠das em TODAS as descri√ß√µes de thumbnail, independentemente do prompt padr√£o usado.\n` : ''}
            
            CR√çTICO PARA A "descricaoThumbnail" - DEVE SER FOTOGRAFIA REAL ULTRA HD 8K, N√ÉO ILUSTRA√á√ÉO:
            - OBRIGAT√ìRIO: A descri√ß√£o DEVE come√ßar EXATAMENTE com: "Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, real lighting, real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, 8K resolution, extreme sharpness, maximum detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography quality"
            
            - ENFATIZE REPETIDAMENTE E OBRIGATORIAMENTE: "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail", "every pore visible", "every texture crisp", "perfect focus", "ultra sharp", "no blur except intentional depth of field", "no artifacts", "no compression", "no pixelation", "perfect clarity", "real photograph", "shot on location", "documentary photography", "realistic textures with imperfections", "natural lighting with real shadows", "real depth of field", "real bokeh effects", "professional color grading", "high dynamic range (HDR)", "sharp focus on subject", "real camera grain", "real-world photography", "actual photograph", "photographed in real life", "real person", "real object", "real environment", "National Geographic quality", "BBC documentary style", "professional photography", "photorealistic", "hyper-realistic"
            
            - NUNCA, JAMAIS use estes termos: "illustration", "drawing", "artwork", "digital art", "render", "3D render", "CGI", "cartoon", "anime", "sketch", "painting", "stylized", "artistic", "concept art", "digital painting", "graphic design", "vector", "comic", "fantasy art", "artistic interpretation", "stylized", "artistic style", "digital illustration"
            
            - SEMPRE use APENAS estes termos: "photograph", "photo", "photography", "shot", "captured", "documentary photo", "realistic capture", "professional photography", "real-world photography", "actual photograph", "photographed", "real-life photography", "on-location photography", "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail"
            
            - IMPORTANTE: Descreva como se fosse uma FOTO REAL ULTRA HD 8K tirada por um fot√≥grafo profissional. Mencione detalhes realistas como: "real skin texture with pores and natural imperfections visible in 8K detail", "real fabric texture with visible fibers and weave patterns in ultra HD", "real stone texture with weathering, cracks, and imperfections visible in perfect 8K clarity", "real shadows cast by real light sources with perfect sharpness", "real depth of field blur with perfect bokeh", "real camera lens distortion", "real chromatic aberration", "real lens flare", "real motion blur if applicable", "every detail visible in 8K resolution", "extreme sharpness and clarity", "no compression artifacts", "perfect focus on subject"

            REGRAS IMPORTANTES:
            - A "descricaoThumbnail" √© OBRIGATORIAMENTE em INGL√äS.
            - "seoDescription", "seoTags" e "frasesDeGancho" s√£o OBRIGATORIAMENTE no idioma "${language}".
            ${!includePhrases ? '- IMPORTANTE: A "descricaoThumbnail" N√ÉO deve mencionar texto, palavras ou frases. Apenas descreva elementos visuais, composi√ß√£o, cores, ilumina√ß√£o, etc.' : ''}
            - Seja extremamente espec√≠fico e detalhado nas descri√ß√µes visuais. Use termos t√©cnicos de fotografia profissional, cinematografia e psicologia visual quando apropriado.
            - Foque em elementos que maximizem CTR: express√µes faciais intensas, momentos de tens√£o, curiosidade visual, contraste dram√°tico, composi√ß√£o impactante.
            
            EXEMPLOS DE COMO DESCREVER PARA GARANTIR REALISMO:
            - Em vez de "um guerreiro maia", escreva: "a real person dressed as a Mayan warrior, photographed on location, real skin texture with pores and natural imperfections, real fabric of the costume with visible texture and wrinkles, real feathers in the headdress with natural variations"
            - Em vez de "uma pir√¢mide antiga", escreva: "a real ancient Mayan pyramid photographed on location, real weathered stone with cracks and imperfections, real moss and vegetation growing on the stones, real shadows cast by the sun, real depth of field blur in the background"
            - Em vez de "luz m√≠stica", escreva: "real natural lighting from the sun, real shadows cast by real objects, real depth of field, real bokeh in the background, real camera lens flare if the sun is in frame"
            - SEMPRE mencione: "real", "actual", "photographed", "shot on location", "documentary style", "real-world", "actual photograph"
            
            T√âCNICAS DE THUMBNAIL VIRAL PARA O TEXTO (quando includePhrases = true) - DESIGN PROFISSIONAL COMO PHOTOSHOP - CTR ACIMA DE 25%:
            
            üìù DESCRI√á√ÉO OBRIGAT√ìRIA DO TEXTO - DEVE PARECER FEITO NO PHOTOSHOP POR UM DESIGNER PROFISSIONAL:
            O texto DEVE ser descrito como se fosse criado no Photoshop com t√©cnicas profissionais de design gr√°fico:
            
            1. TIPOGRAFIA PROFISSIONAL:
               - "Professional typography, Photoshop-quality text design"
               - "Large, bold, professionally designed text occupying 25-35% of the image height"
               - "Massive, oversized typography with professional letter spacing and kerning"
               - "Thick, chunky, professionally rendered letters"
               - "Typography that looks like it was designed by a professional graphic designer"
               - "High-end text design, magazine-quality typography"
            
            2. CORES PROFISSIONAIS E EFEITOS DE CAMADA (Layer Effects do Photoshop):
               - "Bright yellow (#FFD700) text with professional Photoshop layer effects: thick black stroke (6-8px), white drop shadow with distance 8px, spread 5px, size 12px, opacity 80%, angle 135 degrees"
               - "Pure white text with professional red stroke (6px), black drop shadow with blur radius 10px, and subtle outer glow effect in yellow"
               - "Neon orange (#FF6600) text with black stroke (7px), professional drop shadow with multiple layers, and yellow outer glow with spread 8px"
               - "Electric blue (#00FFFF) text with white stroke (6px), black shadow with distance 10px, and professional bevel and emboss effect"
               - "Bright red (#FF0000) text with yellow stroke (5px), white drop shadow, and professional gradient overlay from yellow to orange"
               - "Lime green (#00FF00) text with black stroke (8px), white glow effect, and professional inner shadow"
               - IMPORTANTE: Descreva como efeitos de camada do Photoshop (layer effects), n√£o apenas "outline" ou "shadow"
               
               üèÜ ESTILO √âPICO - TEXTOS EM DOURADO (Para thumbnails hist√≥ricas/√©picas):
               - Se a thumbnail original usar textos em dourado, DESCREVA EXATAMENTE assim:
               - "Large, bold, ornate serif font text in golden yellow (#FFD700) with professional Photoshop layer effects: thick black stroke (8-10px width, position outside), professional bevel and emboss effect (style: emboss, technique: smooth, depth 150%, size 8px, softness 3px, highlight mode: screen with opacity 75%, shadow mode: multiply with opacity 50%), white drop shadow (distance 12px, spread 6px, size 15px, opacity 85%, angle 135¬∞), subtle outer glow in golden yellow (spread 10px, size 20px, opacity 60%), positioned at the bottom center of the image, occupying 30-35% of the image height, professional ornate serif typography (Trajan Pro, Cinzel, or similar historical/regal font style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, looks like it was designed by a professional graphic designer for a historical epic movie poster"
               - "Golden embossed text with metallic finish, professional 3D effect, regal and majestic appearance, historical epic typography style"
            
            3. FONTES PROFISSIONAIS:
               - "Professional bold sans-serif font (Impact, Bebas Neue, Montserrat Black, or similar premium font)"
               - "Thick, chunky, professionally designed block letters"
               - "Modern, high-end typography with perfect letter spacing"
               - "YouTube viral thumbnail professional font style"
               - "Bold, condensed font with professional kerning and tracking"
               - "Premium typography, no serifs, maximum readability, professional design"
               - "Typography that looks like it came from a professional design agency"
            
            4. EFEITOS PROFISSIONAIS DO PHOTOSHOP (Layer Styles):
               - "Professional Photoshop stroke effect: thick black outline (6-8px width), position: outside, blend mode: normal, opacity: 100%"
               - "Professional drop shadow: distance 10px, spread 5px, size 12px, angle 135¬∞, opacity 80%, color black, blend mode: multiply"
               - "Professional outer glow effect: spread 8px, size 15px, opacity 75%, color matching text or contrasting"
               - "Professional bevel and emboss effect: style: emboss, technique: smooth, depth 100%, size 5px, softness 2px"
               - "Professional gradient overlay: linear gradient from bright color to darker shade, angle 90¬∞, opacity 80%"
               - "Professional inner shadow: distance 3px, choke 0%, size 5px, opacity 60%"
               - "Professional color overlay: solid color with blend mode overlay or soft light, opacity 50%"
               - "Text appears to pop out from the image with professional 3D effect"
               - "Professional text rendering with anti-aliasing, crisp edges, perfect clarity"
            
            5. COMPOSI√á√ÉO PROFISSIONAL:
               - "Positioned at the top center of the image with professional alignment"
               - "Bottom third of the image with professional composition and high contrast background"
               - "Centered horizontally, upper third vertically, following rule of thirds"
               - "Strategically placed to not cover important visual elements, professional layout"
               - "Text area has professional semi-transparent dark background (black overlay with 40% opacity) for better readability"
               - "Professional text box or banner behind text with gradient or solid color, rounded corners optional"
            
            6. CONTRASTE E VISIBILIDADE PROFISSIONAL:
               - "High contrast against the background, professionally optimized"
               - "Text stands out dramatically from the image with professional design techniques"
               - "Eye-catching text overlay that immediately draws attention, professional composition"
               - "Text that pops from the image with maximum visibility, professional rendering"
               - "Text is the first thing the eye is drawn to, professional visual hierarchy"
               - "Background is professionally darkened (vignette effect) or lightened behind text for maximum contrast"
               - "Professional color grading applied to background to make text stand out"
            
            7. EXEMPLO COMPLETO DE DESCRI√á√ÉO PROFISSIONAL:
               "Professional Photoshop-quality text design: Large, bold, stylized text '[FRASE DE GANCHO AQUI]' in bright yellow (#FFD700) with professional layer effects: thick black stroke (7px width, position outside), white drop shadow (distance 10px, spread 5px, size 12px, opacity 80%, angle 135¬∞), subtle outer glow in white (spread 6px, size 10px, opacity 70%), positioned at the top center of the image, occupying 30% of the image height, professional bold sans-serif font (Impact or Bebas Neue style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, high contrast viral thumbnail text style, eye-catching and attention-grabbing, text appears to pop out from the image with professional 3D effect, maximum visibility for high CTR, looks like it was designed by a professional graphic designer in Photoshop"
            
            8. REGRAS DE OURO PARA DESIGN PROFISSIONAL:
               - O texto DEVE parecer feito no Photoshop por um designer profissional
               - O texto DEVE ter m√∫ltiplos efeitos de camada (stroke, shadow, glow, bevel)
               - O texto DEVE ter valores espec√≠ficos de efeitos (dist√¢ncia, spread, tamanho, opacidade)
               - O texto DEVE ter tipografia profissional com kerning e tracking perfeitos
               - O texto DEVE ter renderiza√ß√£o profissional (anti-aliasing, crisp edges)
               - O texto DEVE ter composi√ß√£o profissional (regra dos ter√ßos, hierarquia visual)
               - O texto DEVE parecer de qualidade de ag√™ncia de design, n√£o amador

            RESPONDA APENAS COM UM OBJETO JSON V√ÅLIDO, com a seguinte estrutura:
            {
              "ideias": [
                {
                  "seoDescription": "Descri√ß√£o completa e otimizada para o YouTube aqui...",
                  "seoTags": ["tag1", "tag2", "tag3", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Portugu√™s' ? '["Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"]' : language === 'Ingl√™s' ? '["He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"]' : '["√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'A detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'A detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                },
                {
                  "seoDescription": "Outra descri√ß√£o completa e otimizada...",
                  "seoTags": ["tagA", "tagB", "tagC", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Portugu√™s' ? '["A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revela√ß√£o Surpreendente"]' : language === 'Ingl√™s' ? '["The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything", "Surprising Revelation"]' : '["La Verdad", "Nunca Visto", "Descubr√≠ Todo", "Esto Cambi√≥ Todo", "Revelaci√≥n Sorprendente"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'Another detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'Another detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                }
              ]
            }
        `;
        } else {
            // Prompt padr√£o baseado na f√≥rmula do t√≠tulo e otimizado por modelo
            const formulaContext = formulaTitulo ? `\n            F√ìRMULA DO T√çTULO VIRAL IDENTIFICADA: "${formulaTitulo}"\n            MOTIVO DO SUCESSO: "${motivoSucesso || 'An√°lise n√£o dispon√≠vel'}"\n            \n            IMPORTANTE: Use esta f√≥rmula como base para criar thumbnails que complementem e reforcem o mesmo gatilho mental e estrat√©gia que tornaram o t√≠tulo viral.` : '';
            
            // Contexto de performance do v√≠deo - usar mesma classifica√ß√£o viral
            const viewsPerDayThumb = videoDetails.views && videoDetails.days 
                ? Math.round(videoDetails.views / Math.max(videoDetails.days, 1))
                : 0;
            const isViralThumb = isViralVideo(videoDetails.views || 0, videoDetails.days || 0, viewsPerDayThumb);
            
            const videoPerformanceContext = isViralThumb
                ? (videoDetails.views && videoDetails.days 
                    ? `\n            üöÄ CONTEXTO DO V√çDEO VIRAL:\n            Esta thumbnail VIRALIZOU junto com o v√≠deo que alcan√ßou ${videoDetails.views.toLocaleString()} views em apenas ${videoDetails.days} dias (m√©dia de ${viewsPerDayThumb.toLocaleString()} views/dia). Esta thumbnail foi parte do sucesso viral e precisa ser adaptada para o seu subnicho mantendo o mesmo poder de viraliza√ß√£o.`
                    : `\n            üöÄ CONTEXTO DO V√çDEO VIRAL:\n            Esta thumbnail VIRALIZOU junto com o v√≠deo que alcan√ßou ${videoDetails.views.toLocaleString()} views. Esta thumbnail foi parte do sucesso viral e precisa ser adaptada para o seu subnicho mantendo o mesmo poder de viraliza√ß√£o.`)
                : (videoDetails.views && videoDetails.days 
                    ? `\n            üöÄ CONTEXTO DO V√çDEO DE REFER√äNCIA:\n            Esta thumbnail pertence a um v√≠deo que alcan√ßou ${videoDetails.views.toLocaleString()} views em ${videoDetails.days} dias (m√©dia de ${viewsPerDayThumb.toLocaleString()} views/dia). Este v√≠deo N√ÉO viralizou, mas a thumbnail pode ser analisada e melhorada para criar vers√µes com maior potencial viral.`
                    : `\n            üöÄ CONTEXTO DO V√çDEO DE REFER√äNCIA:\n            Esta thumbnail pertence a um v√≠deo que alcan√ßou ${videoDetails.views.toLocaleString()} views. Este v√≠deo N√ÉO viralizou, mas a thumbnail pode ser analisada e melhorada para criar vers√µes com maior potencial viral.`);
            
            // Prompts otimizados por modelo
            if (service === 'claude') {
                thumbPrompt = `
            Voc√™ √© um ESPECIALISTA EM THUMBNAILS VIRAIS NO YOUTUBE, combinando as habilidades de um diretor de arte profissional e um estrategista de viraliza√ß√£o com experi√™ncia em criar thumbnails que gerem MILH√ïES DE VIEWS e ALTO CTR (acima de 25%).
            
            ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ATEN√á√ÉO CR√çTICA - IDIOMA DAS FRASES DE GANCHO ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
            O idioma selecionado √©: "${language}"
            Se "${language}" for "Portugu√™s", TODAS as frases de gancho DEVEM estar em PORTUGU√äS.
            Se "${language}" for "Ingl√™s", TODAS as frases de gancho DEVEM estar em INGL√äS.
            Se "${language}" for "Espanhol", TODAS as frases de gancho DEVEM estar em ESPANHOL.
            NUNCA, JAMAIS retorne frases em ingl√™s se o idioma for portugu√™s ou espanhol.
            NUNCA, JAMAIS retorne frases em portugu√™s se o idioma for ingl√™s ou espanhol.
            NUNCA, JAMAIS retorne frases em espanhol se o idioma for portugu√™s ou ingl√™s.
            ANTES DE RETORNAR O JSON, VERIFIQUE SE TODAS AS 5 FRASES EST√ÉO NO IDIOMA CORRETO "${language}".${formulaContext}${videoPerformanceContext}

            üéØ PROMPT DE AN√ÅLISE DE THUMBS (DIRETO DO V√çDEO VIRAL):
            Este v√≠deo ${isViralThumb ? 'COM ESTA THUMBNAIL VIRALIZOU' : 'DE REFER√äNCIA tem esta thumbnail'}, com o t√≠tulo: "${videoDetails.title}"
            
            OBJETIVO: Criar thumbnails que gerem MILH√ïES DE VIEWS e ALTO CTR (acima de 25%) para canais milion√°rios.
            
            Quero que voc√™ me d√™ uma ADAPTA√á√ÉO para meu SUBNICHO de "${subniche}" com o t√≠tulo: "${selectedTitle}"
            
            REGRAS CR√çTICAS:
            - Mantenha o PODER VIRAL da thumbnail original que gerou milh√µes de views
            - Adapte para o meu subnicho e t√≠tulo, mas SEMPRE mantenha a capacidade de gerar alto CTR e milh√µes de views
            - Analise PROFUNDAMENTE o que tornou a thumbnail original viral (composi√ß√£o, cores, elementos visuais, express√µes, texto, contraste, psicologia visual)
            - Identifique os ELEMENTOS VIRAIS COMPROVADOS que funcionaram e mantenha-os na adapta√ß√£o
            - Melhore o que for poss√≠vel (cores mais vibrantes, contraste maior, composi√ß√£o mais impactante, ilumina√ß√£o mais dram√°tica)
            - Crie thumbnails que TENHAM POTENCIAL PARA VIRALIZAR e gerar milh√µes de views como a original

            IMAGEM DE REFER√äNCIA: [A imagem da thumbnail original do v√≠deo VIRAL est√° anexada - analise cuidadosamente o que tornou esta thumbnail viral e gerou milh√µes de views]${formulaContext}

            IMAGEM DE REFER√äNCIA: [A imagem da thumbnail original do v√≠deo est√° anexada]
            ${thumbnailReferences.length > 0 ? `
            üé® THUMBNAILS DE REFER√äNCIA DO CANAL/NICHO (IMPORTANTE - ESTILO DO CANAL):
            ${thumbnailReferences.map((ref, idx) => `[IMAGEM ${idx + 1} DE REFER√äNCIA DO CANAL: A thumbnail de refer√™ncia ${idx + 1} do canal est√° anexada${ref.description ? ` (Descri√ß√£o: ${ref.description})` : ''}]`).join('\n            ')}
            
            ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - USE AS THUMBNAILS DE REFER√äNCIA DO CANAL COMO ESTILO PRINCIPAL ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è:
            - Analise cuidadosamente TODAS as ${thumbnailReferences.length} thumbnail(s) de refer√™ncia do canal que est√£o anexadas acima.
            - Estas thumbnails representam o ESTILO VISUAL OFICIAL do canal/nicho "${subniche}".
            - A IDEIA 1 DEVE replicar fielmente o estilo visual dessas thumbnails de refer√™ncia do canal (composi√ß√£o, cores, tipografia, elementos visuais, posicionamento de texto, etc.).
            - Identifique os elementos comuns entre as thumbnails de refer√™ncia: tipo de composi√ß√£o, paleta de cores, estilo de texto, posicionamento de elementos, ilumina√ß√£o, etc.
            - Replique EXATAMENTE esse estilo visual na IDEIA 1, mantendo a identidade visual do canal.
            - A IDEIA 2 pode ser mais criativa, mas ainda deve respeitar a identidade visual do canal baseada nas thumbnails de refer√™ncia.
            - Se as thumbnails de refer√™ncia do canal usarem textos em dourado, composi√ß√£o dividida, close-up dram√°tico ou outros elementos espec√≠ficos, REPLIQUE-OS FIELMENTE na IDEIA 1.
            ` : ''}
            T√çTULO DO V√çDEO (para contexto): "${selectedTitle}"
            SUBNICHO (P√∫blico-Alvo): "${subniche}"
            ESTILO DE ARTE DESEJADO: "${style}"
            IDIOMA DO CONTE√öDO: "${language}"

            ‚ö†Ô∏è ATEN√á√ÉO CR√çTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, n√£o ilustra√ß√µes, desenhos ou renderiza√ß√µes. A descri√ß√£oThumbnail deve descrever uma FOTO REAL tirada por um fot√≥grafo profissional em um local real, com pessoas reais e objetos reais.
            
            üé® IDENTIFICA√á√ÉO E REPLICA√á√ÉO DE ESTILOS √âPICOS/CINEMATOGR√ÅFICOS:
            
            Analise a IMAGEM DE REFER√äNCIA e identifique qual estilo visual ela utiliza. Se identificar algum dos estilos abaixo, REPLIQUE-O FIELMENTE na IDEIA 1, apenas melhorando a qualidade:
            
            üìê ESTILO 1: COMPOSI√á√ÉO DIVIDIDA (ESQUERDA/DIREITA):
            - Imagem dividida verticalmente em duas metades contrastantes
            - Lado esquerdo: geralmente cenas de paz/grandiosidade (cidades antigas, paisagens douradas, c√©u claro)
            - Lado direito: geralmente cenas de conflito/amea√ßa (tempestades, navios, ex√©rcitos, c√©u escuro)
            - Figura central ou pr√≥xima ao centro conectando os dois lados
            - Contraste dram√°tico entre luz (esquerda) e escurid√£o (direita)
            - Texto grande em dourado (#FFD700) na parte inferior, fonte serifada ornamentada com efeito emboss/bevel
            - Exemplos: Atahualpa (cidade dourada vs navios tempestuosos), Malinche (mapa vs batalha naval)
            
            üìê ESTILO 2: CLOSE-UP DRAM√ÅTICO COM BACKGROUND √âPICO:
            - Figura hist√≥rica em close-up ocupando 40-60% da imagem (rosto e parte superior do corpo)
            - Express√£o intensa e direta para a c√¢mera
            - Background dividido ou com elementos √©picos (pir√¢mides, navios, batalhas, fogo)
            - Ilumina√ß√£o dram√°tica com chiaroscuro (luz forte vs sombras profundas)
            - Texto grande em dourado na parte inferior
            - Exemplos: Fara√≥ com pir√¢mides ao fundo, l√≠der ind√≠gena com cidade antiga
            
            üìê ESTILO 3: CENA √âPICA COM ELEMENTOS DE DESTRUI√á√ÉO:
            - Cena de batalha ou conflito hist√≥rico
            - Elementos de fogo, fuma√ßa, tempestades
            - Navios em chamas, ex√©rcitos, destrui√ß√£o
            - C√©u tempestuoso com nuvens escuras
            - Figuras em primeiro plano com express√µes dram√°ticas
            - Texto grande em dourado/amarelo com outline preto
            - Exemplos: Batalhas navais, conquistas, segredos dos fara√≥s
            
            üìê ESTILO 4: FIGURA HIST√ìRICA COM ELEMENTOS SIMB√ìLICOS:
            - Figura hist√≥rica em destaque (fara√≥, l√≠der, conquistador)
            - Trajes elaborados e aut√™nticos (coroas, armaduras, roupas tradicionais)
            - Elementos simb√≥licos ao redor (pir√¢mides, navios, mapas, hier√≥glifos)
            - Composi√ß√£o vertical ou horizontal com figura dominante
            - Texto grande em dourado com fonte serifada ornamentada
            - Exemplos: Fara√≥ com pir√¢mides, l√≠der ind√≠gena com coroa elaborada
            
            ‚ö†Ô∏è REGRAS PARA REPLICA√á√ÉO FIEL:
            1. Se a thumbnail original usar COMPOSI√á√ÉO DIVIDIDA, mantenha EXATAMENTE essa estrutura (mesma divis√£o, mesmo contraste, mesma posi√ß√£o dos elementos)
            2. Se a thumbnail original usar CLOSE-UP DRAM√ÅTICO, mantenha o mesmo enquadramento e propor√ß√£o da figura
            3. Se a thumbnail original usar TEXTOS EM DOURADO, mantenha a mesma cor (#FFD700), fonte serifada e efeitos (emboss, bevel, glow)
            4. Se a thumbnail original usar ELEMENTOS √âPICOS (pir√¢mides, navios, fogo), mantenha os mesmos elementos na mesma posi√ß√£o
            5. Se a thumbnail original usar CONTRASTE LUZ/ESQUERID√ÉO, mantenha o mesmo esquema de ilumina√ß√£o
            6. Se a thumbnail original usar FIGURAS HIST√ìRICAS, mantenha o mesmo tipo de figura, trajes e express√£o
            7. Apenas MELHORE: nitidez 8K, contraste mais forte, cores mais saturadas, ilumina√ß√£o mais dram√°tica, texto com efeitos Photoshop mais refinados
            
            ${(() => {
                const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
                if (ruleData.mode === 'auto') {
                    return `\n            üîç MODO AUTOM√ÅTICO - AN√ÅLISE DE REGRA:\n            Analise o t√≠tulo "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPL√çCITA na descri√ß√£o da thumbnail. Se m√∫ltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.\n\n            üìã AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE (ALGORITMO OFICIAL):\n\n            1Ô∏è‚É£ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO):\n            O c√©rebro precisa entender a thumbnail em menos de 1 segundo. Se houver confus√£o, o clique cai.\n            Checklist OBRIGAT√ìRIO: 1 ideia principal, 1 personagem, 1 emo√ß√£o, 1 objeto-chave.\n            A thumbnail DEVE ser compreendida instantaneamente. Elimine qualquer elemento que cause confus√£o ou distra√ß√£o.\n\n            2Ô∏è‚É£ REGRA DO ASSUNTO √öNICO:\n            Nada divide a aten√ß√£o. A thumbnail boa √© sempre uma hist√≥ria em uma imagem.\n            Foque em UM √öNICO assunto dominante. Nada deve competir pela aten√ß√£o. A thumbnail deve contar uma hist√≥ria completa em uma √∫nica imagem, sem elementos que dividam o foco.\n\n            3Ô∏è‚É£ REGRA DO ROSTO GRANDE:\n            Rostos com forte express√£o emocional aumentam CTR de 20% a 60%.\n            Express√µes mais fortes: choque, surpresa, medo, raiva, felicidade extrema.\n            Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A express√£o facial DEVE ser EXTREMA e EMOCIONAL. O rosto deve ser o elemento dominante e a primeira coisa que o olho v√™.\n\n            4Ô∏è‚É£ REGRA DO CONTRASTE BRUTAL:\n            Se n√£o tiver contraste, a thumbnail fica invis√≠vel.\n            Use CONTRASTE BRUTAL entre: texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n            O contraste deve ser t√£o forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.\n\n            5Ô∏è‚É£ REGRA DA COR ESTRAT√âGICA:\n            Cada cor ativa um gatilho:\n            - Amarelo: aten√ß√£o imediata\n            - Vermelho: urg√™ncia / perigo\n            - Azul: confian√ßa\n            - Verde: dinheiro / solu√ß√£o\n            - Preto: premium / mist√©rio\n            Escolha a cor baseada na emo√ß√£o que o t√≠tulo transmite.\n\n            6Ô∏è‚É£ REGRA DOS TER√áOS:\n            Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso d√° harmonia e aumenta o foco natural.\n            Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos ter√ßos (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.\n\n            7Ô∏è‚É£ REGRA DO TEXTO ULTRA CURTO:\n            Texto deve ter 2 a 4 palavras, nunca mais.\n            Exemplos: "Ele mentiu", "Descobri isso", "Ningu√©m viu", "Proibido".\n            O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Textos longos matam o CTR. Seja brutalmente direto e impactante.\n\n            8Ô∏è‚É£ REGRA DO ZOOM EMOCIONAL:\n            Aparece sempre um elemento gigante que amplifica a emo√ß√£o ou o conflito.\n            Exemplos: uma conta banc√°ria gigante, uma faca gigante, uma lupa gigante, um n√∫mero gigante.\n            Use um elemento GIGANTE que amplifique a emo√ß√£o ou conflito. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.\n\n            9Ô∏è‚É£ REGRA DO MIST√âRIO:\n            Toda thumbnail viral tem uma pergunta impl√≠cita.\n            Exemplos: algo escondido atr√°s de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela.\n            Crie uma pergunta impl√≠cita na thumbnail. O espectador DEVE sentir curiosidade sobre o que est√° fora da imagem.\n\n            üîü REGRA DOS PONTOS DE FUGA:\n            Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.\n            Sinaliza√ß√µes: setas, linhas diagonais, perspectiva.\n            Use linhas visuais que guiem o olhar para o foco. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal.\n\n            1Ô∏è‚É£1Ô∏è‚É£ REGRA DO ESPA√áO NEGATIVO:\n            Deixar √°reas vazias acentua o foco. Sem isso, a imagem vira bagun√ßa.\n            Deixe √°reas vazias (espa√ßo negativo) que acentuem o foco no elemento principal. O espa√ßo vazio cria respira√ß√£o visual e faz o elemento principal "pular" da imagem.\n\n            1Ô∏è‚É£2Ô∏è‚É£ REGRA DA COER√äNCIA COM O T√çTULO:\n            Thumbnail e t√≠tulo precisam contar a mesma hist√≥ria, mas com √¢ngulos diferentes.\n            T√≠tulo = contexto, Thumbnail = emo√ß√£o.\n            A thumbnail e o t√≠tulo DEVEM contar a mesma hist√≥ria, mas com √¢ngulos diferentes. A thumbnail deve amplificar a emo√ß√£o que o t√≠tulo promete, criando uma sinergia perfeita.\n\n            ‚ö†Ô∏è CR√çTICO: Identifique qual regra melhor se encaixa no t√≠tulo "${selectedTitle}" e aplique-a de forma EXPL√çCITA e RIGOROSA na descri√ß√£o da thumbnail. Se m√∫ltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.`;
                } else {
                    return `\n            üìã REGRA SELECIONADA: ${ruleData.rule.name}\n            ${ruleData.rule.description}\n\n            ${ruleData.rule.checklist ? `‚úÖ Checklist: ${ruleData.rule.checklist.join(', ')}` : ''}\n            ${ruleData.rule.expressions ? `üòÆ Express√µes recomendadas: ${ruleData.rule.expressions.join(', ')}` : ''}\n            ${ruleData.rule.contrasts ? `üé® Contrastes: ${ruleData.rule.contrasts.join(', ')}` : ''}\n            ${ruleData.rule.colors ? `üåà Cores estrat√©gicas: ${Object.entries(ruleData.rule.colors).map(([k, v]) => `${k} (${v})`).join(', ')}` : ''}\n            ${ruleData.rule.examples ? `üí° Exemplos: ${ruleData.rule.examples.join(', ')}` : ''}\n            ${ruleData.rule.elements ? `‚û°Ô∏è Elementos: ${ruleData.rule.elements.join(', ')}` : ''}\n\n            ‚ö†Ô∏è CR√çTICO: Aplique esta regra de forma EXPL√çCITA e RIGOROSA na descri√ß√£o da thumbnail:\n            ${ruleData.instructions}`;
                }
            })()}
            
            üéØ OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando t√©cnicas de Thumbnail Designer profissional:
            - TEXTO PROFISSIONAL (COMO PHOTOSHOP): O texto DEVE parecer feito no Photoshop por um designer profissional. Use m√∫ltiplos efeitos de camada (stroke, drop shadow com valores espec√≠ficos, outer glow, bevel and emboss), tipografia profissional com kerning perfeito, renderiza√ß√£o profissional com anti-aliasing. Grande, estilizado, cores vibrantes (amarelo/vermelho/branco com outline preto), efeitos visuais profissionais com valores espec√≠ficos (dist√¢ncia, spread, tamanho, opacidade, √¢ngulo), posicionamento estrat√©gico (topo/centro), ocupando 25-35% da imagem. O texto DEVE ter qualidade de ag√™ncia de design, n√£o amador.
            - COMPOSI√á√ÉO: Regra dos ter√ßos, hierarquia visual clara, elemento principal em destaque
            - CORES: Alto contraste, cores complementares, satura√ß√£o otimizada, fundo que faz o texto "pular"
            - EMO√á√ÉO: Express√µes faciais intensas, momentos de tens√£o, curiosidade visual
            - ELEMENTOS VIRAIS: FOMO (medo de perder), surpresa, contraste dram√°tico, storytelling visual
            
            SUA TAREFA (OTIMIZADA PARA VIRALIZA√á√ÉO - CLAUDE):
            Analise a thumbnail VIRAL de refer√™ncia e crie DUAS (2) adapta√ß√µes que mantenham o PODER VIRAL original, mas adaptadas para o subnicho "${subniche}" e o t√≠tulo "${selectedTitle}".
            
            ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - ORDEM DAS IDEIAS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
            - **IDEIA 1 (R√âPLICA APRIMORADA DA ORIGINAL):** 
              * OBRIGAT√ìRIO: Esta ideia DEVE replicar e melhorar a thumbnail ORIGINAL do v√≠deo ao qual foram feitos os t√≠tulos.
              * Analise cuidadosamente a IMAGEM DE REFER√äNCIA (thumbnail original do v√≠deo) que est√° anexada.
              * Replique a estrutura da thumbnail de refer√™ncia quase 1:1: mantenha EXATAMENTE a mesma composi√ß√£o, √¢ngulo de c√¢mera, enquadramento, posi√ß√£o dos personagens/objetos, paleta de cores, quantidade de texto, posi√ß√£o do texto, elementos visuais principais e storytelling.
              * PRESERVE o poder viral da thumbnail original que gerou milh√µes de views.
              * Apenas ELEVE A QUALIDADE: mais nitidez (8K), contraste refor√ßado, ilumina√ß√£o cinematogr√°fica profissional, corre√ß√µes de cor profissionais, tratamento de pele profissional, brilho nos olhos, textura realista, limpeza de ru√≠dos, adicione luzes/sombras profissionais, aplique efeitos de texto Photoshop com valores espec√≠ficos (stroke, drop shadow, outer glow, bevel & emboss).
              * N√ÉO altere o storytelling principal, apenas entregue a vers√£o definitiva com acabamento premium.
              * Resultado: praticamente igual √† thumbnail original, mas com sensa√ß√£o de upgrade premium e leitura instant√¢nea mais clara e clic√°vel.
              * IMPORTANTE: Se a thumbnail original n√£o estiver dispon√≠vel ou n√£o puder ser analisada, ainda assim mantenha o mesmo conceito visual e estrutura, apenas melhorando a qualidade.
            
            - **IDEIA 2 (THUMBNAIL MELHORADA E OTIMIZADA):** 
              * Esta √© uma vers√£o COMPLETAMENTE NOVA, melhorada e otimizada para CTR alto (30%+).
              * Crie um conceito totalmente novo com foco em CTR m√°ximo: novo enquadramento, nova composi√ß√£o, novos elementos que gerem curiosidade extrema.
              * Use gatilhos agressivos (perigo, segredo revelado, n√∫meros gigantes, setas, antes/depois, close dram√°tico) e cores super contrastantes.
              * Construa um storytelling diferente, alinhado ao t√≠tulo "${selectedTitle}", que prometa algo ainda mais irresist√≠vel que a vers√£o original.
              * O texto deve ser redesenhado para m√°xima legibilidade mobile, com layer styles profissionais e valores precisos.
              * Pode mudar cen√°rio, personagens, enquadramento e paleta, explorando um novo gancho visual com FOMO extremo, contraste m√°ximo, express√µes dram√°ticas e elementos que n√£o existem na thumb original.
              * Objetivo: criar uma thumbnail in√©dita que pare√ßa "campanha de performance", otimizada para CTR alto e reten√ß√£o visual imediata.
              * Esta vers√£o deve ser AINDA MELHOR que a original, com t√©cnicas avan√ßadas de viraliza√ß√£o.
              * LEMBRE-SE: Deve ser descrito como uma FOTO REAL, e o texto precisa parecer produzido no Photoshop por um designer profissional com m√∫ltiplos efeitos de camada e valores espec√≠ficos.

            PARA CADA UMA DAS 2 IDEIAS, GERE:
            1.  **"seoDescription"**: Uma descri√ß√£o de v√≠deo para o YouTube, EXTREMAMENTE OTIMIZADA PARA SEO E VIRALIZA√á√ÉO, com:
               - Emojis estrat√©gicos e relevantes (use emojis que representem o nicho e subnicho)
               - Par√°grafos bem estruturados com quebras de linha
               - Chamadas para a√ß√£o (CTA) claras e persuasivas
               - Uso estrat√©gico de palavras-chave relevantes para o t√≠tulo "${selectedTitle}" e subnicho "${subniche}"
               - Formata√ß√£o profissional com separadores visuais (‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ)
               - Se√ß√µes organizadas: introdu√ß√£o, conte√∫do do v√≠deo, sobre o canal, links importantes, hashtags
               - Linguagem persuasiva e envolvente que gere curiosidade e urg√™ncia
               - A descri√ß√£o deve estar no idioma "${language}" e ter entre 300-500 palavras
               - IMPORTANTE: Use emojis de forma estrat√©gica (n√£o exagere, mas use para destacar se√ß√µes importantes)
               - Inclua hashtags relevantes no final
               - Seja espec√≠fico sobre o que o espectador vai aprender/ganhar
               
            2.  **"seoTags"**: Um array de strings com as 15-25 tags MAIS RELEVANTES E ESTRAT√âGICAS para o v√≠deo (LIMITE M√ÅXIMO: 300 caracteres no total, incluindo v√≠rgulas e espa√ßos. N√ÉO ultrapasse 300 caracteres), incluindo:
               - Tags de cauda curta (1-2 palavras): termos populares e competitivos relacionados ao t√≠tulo "${selectedTitle}" e subnicho "${subniche}"
               - Tags de cauda longa (3-5 palavras): termos mais espec√≠ficos e menos competitivos que capturam inten√ß√£o de busca
               - Tags de nicho: termos espec√≠ficos do subnicho "${subniche}"
               - Tags de tend√™ncia: termos que est√£o em alta no momento relacionados ao tema
               - Tags de formato: termos como "tutorial", "dicas", "como fazer", "guia completo", "passo a passo", etc.
               - Tags de plataforma: termos relacionados √† plataforma (YouTube, TikTok, Instagram, etc.)
               - Tags de emo√ß√£o: termos que capturam a emo√ß√£o do t√≠tulo (ex: "surpresa", "revela√ß√£o", "mist√©rio", "urg√™ncia", "choque")
               - Tags de benef√≠cio: termos que descrevem o que o espectador vai ganhar/aprender
               - Tags de palavra-chave principal: extrair as palavras-chave mais importantes do t√≠tulo "${selectedTitle}"
               - Tags de sin√¥nimos: varia√ß√µes e sin√¥nimos das palavras-chave principais
               - IMPORTANTE: As tags devem ser EXTREMAMENTE RELEVANTES ao t√≠tulo "${selectedTitle}" e ao subnicho "${subniche}"
               - Evite tags gen√©ricas que n√£o agregam valor
               - Priorize tags que tenham volume de busca mas n√£o sejam extremamente competitivas
               - Misture tags em portugu√™s/ingl√™s/espanhol conforme o idioma "${language}"
               - LIMITE M√ÅXIMO: 300 caracteres no total (incluindo v√≠rgulas e espa√ßos). N√ÉO ultrapasse 300 caracteres.
               - Cada tag deve ter entre 1-5 palavras, sendo a maioria com 2-3 palavras para otimizar o uso do espa√ßo
               - Priorize tags mais relevantes e estrat√©gicas. Se necess√°rio, reduza a quantidade de tags para n√£o ultrapassar 300 caracteres.
            3.  **"frasesDeGancho"**: Um array com 5 frases CURTAS de impacto (ganchos) para a thumbnail, OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne um array vazio [].' : `
                ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO E OBRIGAT√ìRIO - IDIOMA DAS FRASES DE GANCHO ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Portugu√™s' ? `
                ‚úÖ CORRETO (Portugu√™s): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revela√ß√£o Surpreendente"
                ‚ùå ERRADO (Ingl√™s - N√ÉO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ‚ùå ERRADO (Espanhol - N√ÉO USAR): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"
                ` : language === 'Ingl√™s' ? `
                ‚úÖ CORRETO (Ingl√™s): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ‚ùå ERRADO (Portugu√™s - N√ÉO USAR): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"
                ‚ùå ERRADO (Espanhol - N√ÉO USAR): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"
                ` : `
                ‚úÖ CORRETO (Espanhol): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante", "La Verdad", "Nunca Visto", "Descubr√≠ Todo", "Esto Cambi√≥ Todo", "Revelaci√≥n Sorprendente"
                ‚ùå ERRADO (Portugu√™s - N√ÉO USAR): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"
                ‚ùå ERRADO (Ingl√™s - N√ÉO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGAT√ìRIAS:
                1. Se "${language}" for "Portugu√™s", TODAS as 5 frases DEVEM estar em PORTUGU√äS (Brasil)
                2. Se "${language}" for "Ingl√™s", TODAS as 5 frases DEVEM estar em INGL√äS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em ingl√™s se o idioma escolhido for portugu√™s ou espanhol
                5. NUNCA, JAMAIS retorne frases em portugu√™s se o idioma escolhido for ingl√™s ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for portugu√™s ou ingl√™s
                7. Cada frase deve ter 2 a 4 palavras, no m√°ximo
                8. As frases devem ser impactantes e relacionadas ao t√≠tulo "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases est√£o no idioma "${language}"?
                - Nenhuma frase est√° em ingl√™s se "${language}" for portugu√™s ou espanhol?
                - Nenhuma frase est√° em portugu√™s se "${language}" for ingl√™s ou espanhol?
                - Nenhuma frase est√° em espanhol se "${language}" for portugu√™s ou ingl√™s?
                
                Se alguma resposta for N√ÉO, CORRIJA as frases antes de retornar o JSON.
                `}
            4.  **"descricaoThumbnail"**: Um prompt EXTREMAMENTE DETALHADO e V√çVIDO, em INGL√äS, para uma IA de gera√ß√£o de imagem. ${!includePhrases ? 'N√ÉO inclua nenhum placeholder para texto. A thumbnail deve ser APENAS imagem, sem texto ou frases de gancho. Descreva apenas elementos visuais, composi√ß√£o, cores, ilumina√ß√£o, etc.' : 'A descri√ß√£o DEVE incluir OBRIGATORIAMENTE o placeholder exato "[FRASE DE GANCHO AQUI]" em algum lugar da descri√ß√£o, onde o texto da thumbnail ser√° inserido. CR√çTICO: O placeholder "[FRASE DE GANCHO AQUI]" DEVE aparecer literalmente na descri√ß√£o. Quando mencionar o texto, descreva-o como se fosse criado no Photoshop por um designer profissional: use termos como "Professional Photoshop-quality text design displaying [FRASE DE GANCHO AQUI]", "professional layer effects", "Photoshop stroke effect", "professional drop shadow with specific values (distance, spread, size, opacity, angle)", "professional outer glow", "professional bevel and emboss", "professional typography with perfect kerning", "professional text rendering with anti-aliasing", "looks like it was designed by a professional graphic designer". O texto DEVE ter m√∫ltiplos efeitos de camada do Photoshop com valores espec√≠ficos, n√£o apenas descri√ß√µes gen√©ricas. Fonte estilizada profissional, grande e impactante, cores vibrantes e contrastantes, efeitos visuais profissionais (sombra com valores espec√≠ficos, brilho, outline, gradiente), posicionamento estrat√©gico, tamanho grande que ocupa 25-35% da imagem. IMPORTANTE: Sempre inclua o texto "[FRASE DE GANCHO AQUI]" literalmente na descri√ß√£o, por exemplo: "with professional text design displaying [FRASE DE GANCHO AQUI]" ou "featuring large bold text that says [FRASE DE GANCHO AQUI]".'}
            
            CR√çTICO PARA A "descricaoThumbnail" - DEVE SER FOTOGRAFIA REAL ULTRA HD 8K, N√ÉO ILUSTRA√á√ÉO:
            - OBRIGAT√ìRIO: A descri√ß√£o DEVE come√ßar EXATAMENTE com: "Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, real lighting, real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, 8K resolution, extreme sharpness, maximum detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography quality"
            
            - ENFATIZE REPETIDAMENTE E OBRIGATORIAMENTE: "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail", "every pore visible", "every texture crisp", "perfect focus", "ultra sharp", "no blur except intentional depth of field", "no artifacts", "no compression", "no pixelation", "perfect clarity", "real photograph", "shot on location", "documentary photography", "realistic textures with imperfections", "natural lighting with real shadows", "real depth of field", "real bokeh effects", "professional color grading", "high dynamic range (HDR)", "sharp focus on subject", "real camera grain", "real-world photography", "actual photograph", "photographed in real life", "real person", "real object", "real environment", "National Geographic quality", "BBC documentary style", "professional photography", "photorealistic", "hyper-realistic"
            
            - NUNCA, JAMAIS use estes termos: "illustration", "drawing", "artwork", "digital art", "render", "3D render", "CGI", "cartoon", "anime", "sketch", "painting", "stylized", "artistic", "concept art", "digital painting", "graphic design", "vector", "comic", "fantasy art", "artistic interpretation", "stylized", "artistic style", "digital illustration"
            
            - SEMPRE use APENAS estes termos: "photograph", "photo", "photography", "shot", "captured", "documentary photo", "realistic capture", "professional photography", "real-world photography", "actual photograph", "photographed", "real-life photography", "on-location photography", "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail"
            
            - IMPORTANTE: Descreva como se fosse uma FOTO REAL ULTRA HD 8K tirada por um fot√≥grafo profissional. Mencione detalhes realistas como: "real skin texture with pores and natural imperfections visible in 8K detail", "real fabric texture with visible fibers and weave patterns in ultra HD", "real stone texture with weathering, cracks, and imperfections visible in perfect 8K clarity", "real shadows cast by real light sources with perfect sharpness", "real depth of field blur with perfect bokeh", "real camera lens distortion", "real chromatic aberration", "real lens flare", "real motion blur if applicable", "every detail visible in 8K resolution", "extreme sharpness and clarity", "no compression artifacts", "perfect focus on subject"

            REGRAS IMPORTANTES:
            - A "descricaoThumbnail" √© OBRIGATORIAMENTE em INGL√äS.
            - "seoDescription", "seoTags" e "frasesDeGancho" s√£o OBRIGATORIAMENTE no idioma "${language}".
            ${!includePhrases ? '- IMPORTANTE: A "descricaoThumbnail" N√ÉO deve mencionar texto, palavras ou frases. Apenas descreva elementos visuais, composi√ß√£o, cores, ilumina√ß√£o, etc.' : ''}
            - Seja extremamente espec√≠fico e detalhado nas descri√ß√µes visuais. Use termos t√©cnicos de fotografia profissional, cinematografia e psicologia visual quando apropriado.
            - Foque em elementos que maximizem CTR: express√µes faciais intensas, momentos de tens√£o, curiosidade visual, contraste dram√°tico, composi√ß√£o impactante.
            
            EXEMPLOS DE COMO DESCREVER PARA GARANTIR REALISMO:
            - Em vez de "um guerreiro maia", escreva: "a real person dressed as a Mayan warrior, photographed on location, real skin texture with pores and natural imperfections, real fabric of the costume with visible texture and wrinkles, real feathers in the headdress with natural variations"
            - Em vez de "uma pir√¢mide antiga", escreva: "a real ancient Mayan pyramid photographed on location, real weathered stone with cracks and imperfections, real moss and vegetation growing on the stones, real shadows cast by the sun, real depth of field blur in the background"
            - Em vez de "luz m√≠stica", escreva: "real natural lighting from the sun, real shadows cast by real objects, real depth of field, real bokeh in the background, real camera lens flare if the sun is in frame"
            - SEMPRE mencione: "real", "actual", "photographed", "shot on location", "documentary style", "real-world", "actual photograph"
            
            T√âCNICAS DE THUMBNAIL VIRAL PARA O TEXTO (quando includePhrases = true) - DESIGN PROFISSIONAL COMO PHOTOSHOP - CTR ACIMA DE 25%:
            
            üìù DESCRI√á√ÉO OBRIGAT√ìRIA DO TEXTO - DEVE PARECER FEITO NO PHOTOSHOP POR UM DESIGNER PROFISSIONAL:
            O texto DEVE ser descrito como se fosse criado no Photoshop com t√©cnicas profissionais de design gr√°fico:
            
            1. TIPOGRAFIA PROFISSIONAL:
               - "Professional typography, Photoshop-quality text design"
               - "Large, bold, professionally designed text occupying 25-35% of the image height"
               - "Massive, oversized typography with professional letter spacing and kerning"
               - "Thick, chunky, professionally rendered letters"
               - "Typography that looks like it was designed by a professional graphic designer"
               - "High-end text design, magazine-quality typography"
            
            2. CORES PROFISSIONAIS E EFEITOS DE CAMADA (Layer Effects do Photoshop):
               - "Bright yellow (#FFD700) text with professional Photoshop layer effects: thick black stroke (6-8px), white drop shadow with distance 8px, spread 5px, size 12px, opacity 80%, angle 135 degrees"
               - "Pure white text with professional red stroke (6px), black drop shadow with blur radius 10px, and subtle outer glow effect in yellow"
               - "Neon orange (#FF6600) text with black stroke (7px), professional drop shadow with multiple layers, and yellow outer glow with spread 8px"
               - "Electric blue (#00FFFF) text with white stroke (6px), black shadow with distance 10px, and professional bevel and emboss effect"
               - "Bright red (#FF0000) text with yellow stroke (5px), white drop shadow, and professional gradient overlay from yellow to orange"
               - "Lime green (#00FF00) text with black stroke (8px), white glow effect, and professional inner shadow"
               - IMPORTANTE: Descreva como efeitos de camada do Photoshop (layer effects), n√£o apenas "outline" ou "shadow"
               
               üèÜ ESTILO √âPICO - TEXTOS EM DOURADO (Para thumbnails hist√≥ricas/√©picas):
               - Se a thumbnail original usar textos em dourado, DESCREVA EXATAMENTE assim:
               - "Large, bold, ornate serif font text in golden yellow (#FFD700) with professional Photoshop layer effects: thick black stroke (8-10px width, position outside), professional bevel and emboss effect (style: emboss, technique: smooth, depth 150%, size 8px, softness 3px, highlight mode: screen with opacity 75%, shadow mode: multiply with opacity 50%), white drop shadow (distance 12px, spread 6px, size 15px, opacity 85%, angle 135¬∞), subtle outer glow in golden yellow (spread 10px, size 20px, opacity 60%), positioned at the bottom center of the image, occupying 30-35% of the image height, professional ornate serif typography (Trajan Pro, Cinzel, or similar historical/regal font style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, looks like it was designed by a professional graphic designer for a historical epic movie poster"
               - "Golden embossed text with metallic finish, professional 3D effect, regal and majestic appearance, historical epic typography style"
            
            3. FONTES PROFISSIONAIS:
               - "Professional bold sans-serif font (Impact, Bebas Neue, Montserrat Black, or similar premium font)"
               - "Thick, chunky, professionally designed block letters"
               - "Modern, high-end typography with perfect letter spacing"
               - "YouTube viral thumbnail professional font style"
               - "Bold, condensed font with professional kerning and tracking"
               - "Premium typography, no serifs, maximum readability, professional design"
               - "Typography that looks like it came from a professional design agency"
            
            4. EFEITOS PROFISSIONAIS DO PHOTOSHOP (Layer Styles):
               - "Professional Photoshop stroke effect: thick black outline (6-8px width), position: outside, blend mode: normal, opacity: 100%"
               - "Professional drop shadow: distance 10px, spread 5px, size 12px, angle 135¬∞, opacity 80%, color black, blend mode: multiply"
               - "Professional outer glow effect: spread 8px, size 15px, opacity 75%, color matching text or contrasting"
               - "Professional bevel and emboss effect: style: emboss, technique: smooth, depth 100%, size 5px, softness 2px"
               - "Professional gradient overlay: linear gradient from bright color to darker shade, angle 90¬∞, opacity 80%"
               - "Professional inner shadow: distance 3px, choke 0%, size 5px, opacity 60%"
               - "Professional color overlay: solid color with blend mode overlay or soft light, opacity 50%"
               - "Text appears to pop out from the image with professional 3D effect"
               - "Professional text rendering with anti-aliasing, crisp edges, perfect clarity"
            
            5. COMPOSI√á√ÉO PROFISSIONAL:
               - "Positioned at the top center of the image with professional alignment"
               - "Bottom third of the image with professional composition and high contrast background"
               - "Centered horizontally, upper third vertically, following rule of thirds"
               - "Strategically placed to not cover important visual elements, professional layout"
               - "Text area has professional semi-transparent dark background (black overlay with 40% opacity) for better readability"
               - "Professional text box or banner behind text with gradient or solid color, rounded corners optional"
            
            6. CONTRASTE E VISIBILIDADE PROFISSIONAL:
               - "High contrast against the background, professionally optimized"
               - "Text stands out dramatically from the image with professional design techniques"
               - "Eye-catching text overlay that immediately draws attention, professional composition"
               - "Text that pops from the image with maximum visibility, professional rendering"
               - "Text is the first thing the eye is drawn to, professional visual hierarchy"
               - "Background is professionally darkened (vignette effect) or lightened behind text for maximum contrast"
               - "Professional color grading applied to background to make text stand out"
            
            7. EXEMPLO COMPLETO DE DESCRI√á√ÉO PROFISSIONAL:
               "Professional Photoshop-quality text design: Large, bold, stylized text '[FRASE DE GANCHO AQUI]' in bright yellow (#FFD700) with professional layer effects: thick black stroke (7px width, position outside), white drop shadow (distance 10px, spread 5px, size 12px, opacity 80%, angle 135¬∞), subtle outer glow in white (spread 6px, size 10px, opacity 70%), positioned at the top center of the image, occupying 30% of the image height, professional bold sans-serif font (Impact or Bebas Neue style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, high contrast viral thumbnail text style, eye-catching and attention-grabbing, text appears to pop out from the image with professional 3D effect, maximum visibility for high CTR, looks like it was designed by a professional graphic designer in Photoshop"
            
            8. REGRAS DE OURO PARA DESIGN PROFISSIONAL:
               - O texto DEVE parecer feito no Photoshop por um designer profissional
               - O texto DEVE ter m√∫ltiplos efeitos de camada (stroke, shadow, glow, bevel)
               - O texto DEVE ter valores espec√≠ficos de efeitos (dist√¢ncia, spread, tamanho, opacidade)
               - O texto DEVE ter tipografia profissional com kerning e tracking perfeitos
               - O texto DEVE ter renderiza√ß√£o profissional (anti-aliasing, crisp edges)
               - O texto DEVE ter composi√ß√£o profissional (regra dos ter√ßos, hierarquia visual)
               - O texto DEVE parecer de qualidade de ag√™ncia de design, n√£o amador

            RESPONDA APENAS COM UM OBJETO JSON V√ÅLIDO, com a seguinte estrutura:
            {
              "ideias": [
                {
                  "seoDescription": "Descri√ß√£o completa e otimizada para o YouTube aqui...",
                  "seoTags": ["tag1", "tag2", "tag3", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Portugu√™s' ? '["Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"]' : language === 'Ingl√™s' ? '["He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"]' : '["√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'A detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'A detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                },
                {
                  "seoDescription": "Outra descri√ß√£o completa e otimizada...",
                  "seoTags": ["tagA", "tagB", "tagC", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Portugu√™s' ? '["A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revela√ß√£o Surpreendente"]' : language === 'Ingl√™s' ? '["The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything", "Surprising Revelation"]' : '["La Verdad", "Nunca Visto", "Descubr√≠ Todo", "Esto Cambi√≥ Todo", "Revelaci√≥n Sorprendente"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'Another detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'Another detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                }
              ]
            }
        `;
            } else if (service === 'gemini') {
                thumbPrompt = `
            Voc√™ √© um ESPECIALISTA EM THUMBNAILS VIRAIS NO YOUTUBE, combinando as habilidades de um diretor de arte profissional e um estrategista de viraliza√ß√£o com experi√™ncia em criar thumbnails que geram MILH√ïES DE VIEWS e ALTO CTR (acima de 25%).
            
            ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ATEN√á√ÉO CR√çTICA - IDIOMA DAS FRASES DE GANCHO ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
            O idioma selecionado √©: "${language}"
            Se "${language}" for "Portugu√™s", TODAS as frases de gancho DEVEM estar em PORTUGU√äS.
            Se "${language}" for "Ingl√™s", TODAS as frases de gancho DEVEM estar em INGL√äS.
            Se "${language}" for "Espanhol", TODAS as frases de gancho DEVEM estar em ESPANHOL.
            NUNCA, JAMAIS retorne frases em ingl√™s se o idioma for portugu√™s ou espanhol.
            NUNCA, JAMAIS retorne frases em portugu√™s se o idioma for ingl√™s ou espanhol.
            NUNCA, JAMAIS retorne frases em espanhol se o idioma for portugu√™s ou ingl√™s.
            ANTES DE RETORNAR O JSON, VERIFIQUE SE TODAS AS 5 FRASES EST√ÉO NO IDIOMA CORRETO "${language}".${formulaContext}${videoPerformanceContext}

            üéØ PROMPT DE AN√ÅLISE DE THUMBS (DIRETO DO V√çDEO VIRAL):
            Este v√≠deo ${isViralThumb ? 'COM ESTA THUMBNAIL VIRALIZOU' : 'DE REFER√äNCIA tem esta thumbnail'}, com o t√≠tulo: "${videoDetails.title}"
            
            OBJETIVO: Criar thumbnails que gerem MILH√ïES DE VIEWS e ALTO CTR (acima de 25%) para canais milion√°rios.
            
            Quero que voc√™ me d√™ uma ADAPTA√á√ÉO para meu SUBNICHO de "${subniche}" com o t√≠tulo: "${selectedTitle}"
            
            REGRAS CR√çTICAS:
            - Mantenha o PODER VIRAL da thumbnail original que gerou milh√µes de views
            - Adapte para o meu subnicho e t√≠tulo, mas SEMPRE mantenha a capacidade de gerar alto CTR e milh√µes de views
            - Analise PROFUNDAMENTE o que tornou a thumbnail original viral (composi√ß√£o, cores, elementos visuais, express√µes, texto, contraste, psicologia visual)
            - Identifique os ELEMENTOS VIRAIS COMPROVADOS que funcionaram e mantenha-os na adapta√ß√£o
            - Melhore o que for poss√≠vel (cores mais vibrantes, contraste maior, composi√ß√£o mais impactante, ilumina√ß√£o mais dram√°tica)
            - Crie thumbnails que TENHAM POTENCIAL PARA VIRALIZAR e gerar milh√µes de views como a original

            IMAGEM DE REFER√äNCIA: [A imagem da thumbnail original do v√≠deo VIRAL est√° anexada - analise cuidadosamente o que tornou esta thumbnail viral e gerou milh√µes de views]${formulaContext}

            IMAGEM DE REFER√äNCIA: [A imagem da thumbnail original do v√≠deo est√° anexada]
            ${thumbnailReferences.length > 0 ? `
            üé® THUMBNAILS DE REFER√äNCIA DO CANAL/NICHO (IMPORTANTE - ESTILO DO CANAL):
            ${thumbnailReferences.map((ref, idx) => `[IMAGEM ${idx + 1} DE REFER√äNCIA DO CANAL: A thumbnail de refer√™ncia ${idx + 1} do canal est√° anexada${ref.description ? ` (Descri√ß√£o: ${ref.description})` : ''}]`).join('\n            ')}
            
            ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - USE AS THUMBNAILS DE REFER√äNCIA DO CANAL COMO ESTILO PRINCIPAL ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è:
            - Analise cuidadosamente TODAS as ${thumbnailReferences.length} thumbnail(s) de refer√™ncia do canal que est√£o anexadas acima.
            - Estas thumbnails representam o ESTILO VISUAL OFICIAL do canal/nicho "${subniche}".
            - A IDEIA 1 DEVE replicar fielmente o estilo visual dessas thumbnails de refer√™ncia do canal (composi√ß√£o, cores, tipografia, elementos visuais, posicionamento de texto, etc.).
            - Identifique os elementos comuns entre as thumbnails de refer√™ncia: tipo de composi√ß√£o, paleta de cores, estilo de texto, posicionamento de elementos, ilumina√ß√£o, etc.
            - Replique EXATAMENTE esse estilo visual na IDEIA 1, mantendo a identidade visual do canal.
            - A IDEIA 2 pode ser mais criativa, mas ainda deve respeitar a identidade visual do canal baseada nas thumbnails de refer√™ncia.
            - Se as thumbnails de refer√™ncia do canal usarem textos em dourado, composi√ß√£o dividida, close-up dram√°tico ou outros elementos espec√≠ficos, REPLIQUE-OS FIELMENTE na IDEIA 1.
            ` : ''}
            T√çTULO DO V√çDEO (para contexto): "${selectedTitle}"
            SUBNICHO (P√∫blico-Alvo): "${subniche}"
            ESTILO DE ARTE DESEJADO: "${style}"
            IDIOMA DO CONTE√öDO: "${language}"

            ‚ö†Ô∏è ATEN√á√ÉO CR√çTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, n√£o ilustra√ß√µes, desenhos ou renderiza√ß√µes. A descri√ß√£oThumbnail deve descrever uma FOTO REAL tirada por um fot√≥grafo profissional em um local real, com pessoas reais e objetos reais.
            
            üé® IDENTIFICA√á√ÉO E REPLICA√á√ÉO DE ESTILOS √âPICOS/CINEMATOGR√ÅFICOS:
            
            Analise a IMAGEM DE REFER√äNCIA e identifique qual estilo visual ela utiliza. Se identificar algum dos estilos abaixo, REPLIQUE-O FIELMENTE na IDEIA 1, apenas melhorando a qualidade:
            
            üìê ESTILO 1: COMPOSI√á√ÉO DIVIDIDA (ESQUERDA/DIREITA):
            - Imagem dividida verticalmente em duas metades contrastantes
            - Lado esquerdo: geralmente cenas de paz/grandiosidade (cidades antigas, paisagens douradas, c√©u claro)
            - Lado direito: geralmente cenas de conflito/amea√ßa (tempestades, navios, ex√©rcitos, c√©u escuro)
            - Figura central ou pr√≥xima ao centro conectando os dois lados
            - Contraste dram√°tico entre luz (esquerda) e escurid√£o (direita)
            - Texto grande em dourado (#FFD700) na parte inferior, fonte serifada ornamentada com efeito emboss/bevel
            - Exemplos: Atahualpa (cidade dourada vs navios tempestuosos), Malinche (mapa vs batalha naval)
            
            üìê ESTILO 2: CLOSE-UP DRAM√ÅTICO COM BACKGROUND √âPICO:
            - Figura hist√≥rica em close-up ocupando 40-60% da imagem (rosto e parte superior do corpo)
            - Express√£o intensa e direta para a c√¢mera
            - Background dividido ou com elementos √©picos (pir√¢mides, navios, batalhas, fogo)
            - Ilumina√ß√£o dram√°tica com chiaroscuro (luz forte vs sombras profundas)
            - Texto grande em dourado na parte inferior
            - Exemplos: Fara√≥ com pir√¢mides ao fundo, l√≠der ind√≠gena com cidade antiga
            
            üìê ESTILO 3: CENA √âPICA COM ELEMENTOS DE DESTRUI√á√ÉO:
            - Cena de batalha ou conflito hist√≥rico
            - Elementos de fogo, fuma√ßa, tempestades
            - Navios em chamas, ex√©rcitos, destrui√ß√£o
            - C√©u tempestuoso com nuvens escuras
            - Figuras em primeiro plano com express√µes dram√°ticas
            - Texto grande em dourado/amarelo com outline preto
            - Exemplos: Batalhas navais, conquistas, segredos dos fara√≥s
            
            üìê ESTILO 4: FIGURA HIST√ìRICA COM ELEMENTOS SIMB√ìLICOS:
            - Figura hist√≥rica em destaque (fara√≥, l√≠der, conquistador)
            - Trajes elaborados e aut√™nticos (coroas, armaduras, roupas tradicionais)
            - Elementos simb√≥licos ao redor (pir√¢mides, navios, mapas, hier√≥glifos)
            - Composi√ß√£o vertical ou horizontal com figura dominante
            - Texto grande em dourado com fonte serifada ornamentada
            - Exemplos: Fara√≥ com pir√¢mides, l√≠der ind√≠gena com coroa elaborada
            
            ‚ö†Ô∏è REGRAS PARA REPLICA√á√ÉO FIEL:
            1. Se a thumbnail original usar COMPOSI√á√ÉO DIVIDIDA, mantenha EXATAMENTE essa estrutura (mesma divis√£o, mesmo contraste, mesma posi√ß√£o dos elementos)
            2. Se a thumbnail original usar CLOSE-UP DRAM√ÅTICO, mantenha o mesmo enquadramento e propor√ß√£o da figura
            3. Se a thumbnail original usar TEXTOS EM DOURADO, mantenha a mesma cor (#FFD700), fonte serifada e efeitos (emboss, bevel, glow)
            4. Se a thumbnail original usar ELEMENTOS √âPICOS (pir√¢mides, navios, fogo), mantenha os mesmos elementos na mesma posi√ß√£o
            5. Se a thumbnail original usar CONTRASTE LUZ/ESQUERID√ÉO, mantenha o mesmo esquema de ilumina√ß√£o
            6. Se a thumbnail original usar FIGURAS HIST√ìRICAS, mantenha o mesmo tipo de figura, trajes e express√£o
            7. Apenas MELHORE: nitidez 8K, contraste mais forte, cores mais saturadas, ilumina√ß√£o mais dram√°tica, texto com efeitos Photoshop mais refinados
            
            ${(() => {
                const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
                if (ruleData.mode === 'auto') {
                    return `\n            üîç MODO AUTOM√ÅTICO - AN√ÅLISE DE REGRA:\n            Analise o t√≠tulo "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPL√çCITA na descri√ß√£o da thumbnail. Se m√∫ltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.\n\n            üìã AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE (ALGORITMO OFICIAL):\n\n            1Ô∏è‚É£ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO):\n            O c√©rebro precisa entender a thumbnail em menos de 1 segundo. Se houver confus√£o, o clique cai.\n            Checklist OBRIGAT√ìRIO: 1 ideia principal, 1 personagem, 1 emo√ß√£o, 1 objeto-chave.\n            A thumbnail DEVE ser compreendida instantaneamente. Elimine qualquer elemento que cause confus√£o ou distra√ß√£o.\n\n            2Ô∏è‚É£ REGRA DO ASSUNTO √öNICO:\n            Nada divide a aten√ß√£o. A thumbnail boa √© sempre uma hist√≥ria em uma imagem.\n            Foque em UM √öNICO assunto dominante. Nada deve competir pela aten√ß√£o. A thumbnail deve contar uma hist√≥ria completa em uma √∫nica imagem, sem elementos que dividam o foco.\n\n            3Ô∏è‚É£ REGRA DO ROSTO GRANDE:\n            Rostos com forte express√£o emocional aumentam CTR de 20% a 60%.\n            Express√µes mais fortes: choque, surpresa, medo, raiva, felicidade extrema.\n            Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A express√£o facial DEVE ser EXTREMA e EMOCIONAL. O rosto deve ser o elemento dominante e a primeira coisa que o olho v√™.\n\n            4Ô∏è‚É£ REGRA DO CONTRASTE BRUTAL:\n            Se n√£o tiver contraste, a thumbnail fica invis√≠vel.\n            Use CONTRASTE BRUTAL entre: texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n            O contraste deve ser t√£o forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.\n\n            5Ô∏è‚É£ REGRA DA COR ESTRAT√âGICA:\n            Cada cor ativa um gatilho:\n            - Amarelo: aten√ß√£o imediata\n            - Vermelho: urg√™ncia / perigo\n            - Azul: confian√ßa\n            - Verde: dinheiro / solu√ß√£o\n            - Preto: premium / mist√©rio\n            Escolha a cor baseada na emo√ß√£o que o t√≠tulo transmite.\n\n            6Ô∏è‚É£ REGRA DOS TER√áOS:\n            Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso d√° harmonia e aumenta o foco natural.\n            Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos ter√ßos (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.\n\n            7Ô∏è‚É£ REGRA DO TEXTO ULTRA CURTO:\n            Texto deve ter 2 a 4 palavras, nunca mais.\n            Exemplos: "Ele mentiu", "Descobri isso", "Ningu√©m viu", "Proibido".\n            O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Textos longos matam o CTR. Seja brutalmente direto e impactante.\n\n            8Ô∏è‚É£ REGRA DO ZOOM EMOCIONAL:\n            Aparece sempre um elemento gigante que amplifica a emo√ß√£o ou o conflito.\n            Exemplos: uma conta banc√°ria gigante, uma faca gigante, uma lupa gigante, um n√∫mero gigante.\n            Use um elemento GIGANTE que amplifique a emo√ß√£o ou conflito. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.\n\n            9Ô∏è‚É£ REGRA DO MIST√âRIO:\n            Toda thumbnail viral tem uma pergunta impl√≠cita.\n            Exemplos: algo escondido atr√°s de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela.\n            Crie uma pergunta impl√≠cita na thumbnail. O espectador DEVE sentir curiosidade sobre o que est√° fora da imagem.\n\n            üîü REGRA DOS PONTOS DE FUGA:\n            Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.\n            Sinaliza√ß√µes: setas, linhas diagonais, perspectiva.\n            Use linhas visuais que guiem o olhar para o foco. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal.\n\n            1Ô∏è‚É£1Ô∏è‚É£ REGRA DO ESPA√áO NEGATIVO:\n            Deixar √°reas vazias acentua o foco. Sem isso, a imagem vira bagun√ßa.\n            Deixe √°reas vazias (espa√ßo negativo) que acentuem o foco no elemento principal. O espa√ßo vazio cria respira√ß√£o visual e faz o elemento principal "pular" da imagem.\n\n            1Ô∏è‚É£2Ô∏è‚É£ REGRA DA COER√äNCIA COM O T√çTULO:\n            Thumbnail e t√≠tulo precisam contar a mesma hist√≥ria, mas com √¢ngulos diferentes.\n            T√≠tulo = contexto, Thumbnail = emo√ß√£o.\n            A thumbnail e o t√≠tulo DEVEM contar a mesma hist√≥ria, mas com √¢ngulos diferentes. A thumbnail deve amplificar a emo√ß√£o que o t√≠tulo promete, criando uma sinergia perfeita.\n\n            ‚ö†Ô∏è CR√çTICO: Identifique qual regra melhor se encaixa no t√≠tulo "${selectedTitle}" e aplique-a de forma EXPL√çCITA e RIGOROSA na descri√ß√£o da thumbnail. Se m√∫ltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.`;
                } else {
                    return `\n            üìã REGRA SELECIONADA: ${ruleData.rule.name}\n            ${ruleData.rule.description}\n\n            ${ruleData.rule.checklist ? `‚úÖ Checklist: ${ruleData.rule.checklist.join(', ')}` : ''}\n            ${ruleData.rule.expressions ? `üòÆ Express√µes recomendadas: ${ruleData.rule.expressions.join(', ')}` : ''}\n            ${ruleData.rule.contrasts ? `üé® Contrastes: ${ruleData.rule.contrasts.join(', ')}` : ''}\n            ${ruleData.rule.colors ? `üåà Cores estrat√©gicas: ${Object.entries(ruleData.rule.colors).map(([k, v]) => `${k} (${v})`).join(', ')}` : ''}\n            ${ruleData.rule.examples ? `üí° Exemplos: ${ruleData.rule.examples.join(', ')}` : ''}\n            ${ruleData.rule.elements ? `‚û°Ô∏è Elementos: ${ruleData.rule.elements.join(', ')}` : ''}\n\n            ‚ö†Ô∏è CR√çTICO: Aplique esta regra de forma EXPL√çCITA e RIGOROSA na descri√ß√£o da thumbnail:\n            ${ruleData.instructions}`;
                }
            })()}
            
            üéØ OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando t√©cnicas de Thumbnail Designer profissional:
            - TEXTO PROFISSIONAL (COMO PHOTOSHOP): O texto DEVE parecer feito no Photoshop por um designer profissional. Use m√∫ltiplos efeitos de camada (stroke, drop shadow com valores espec√≠ficos, outer glow, bevel and emboss), tipografia profissional com kerning perfeito, renderiza√ß√£o profissional com anti-aliasing. Grande, estilizado, cores vibrantes (amarelo/vermelho/branco com outline preto), efeitos visuais profissionais com valores espec√≠ficos (dist√¢ncia, spread, tamanho, opacidade, √¢ngulo), posicionamento estrat√©gico (topo/centro), ocupando 25-35% da imagem. O texto DEVE ter qualidade de ag√™ncia de design, n√£o amador.
            - COMPOSI√á√ÉO: Regra dos ter√ßos, hierarquia visual clara, elemento principal em destaque
            - CORES: Alto contraste, cores complementares, satura√ß√£o otimizada, fundo que faz o texto "pular"
            - EMO√á√ÉO: Express√µes faciais intensas, momentos de tens√£o, curiosidade visual
            - ELEMENTOS VIRAIS: FOMO (medo de perder), surpresa, contraste dram√°tico, storytelling visual
            
            SUA TAREFA (OTIMIZADA PARA VIRALIZA√á√ÉO - GEMINI):
            Analise a thumbnail VIRAL de refer√™ncia e crie DUAS (2) adapta√ß√µes que mantenham o PODER VIRAL original, mas adaptadas para o subnicho "${subniche}" e o t√≠tulo "${selectedTitle}".
            
            - **IDEIA 1 (R√âPLICA APRIMORADA DA ORIGINAL):** 
              * Copie a mesma estrutura da thumbnail de refer√™ncia (√¢ngulo da c√¢mera, pose dos personagens, dire√ß√£o do olhar, escala dos elementos, posi√ß√£o do texto).
              * Mantenha a paleta de cores, quantidade de texto, √≠cones, props e o storytelling visual original.
              * Apenas eleve a execu√ß√£o: mais nitidez, contraste calibrado, recorte perfeito, tratamento de pele profissional, brilho nos olhos, texto com efeitos Photoshop refinados (stroke, drop shadow com valores espec√≠ficos, outer glow, bevel & emboss).
              * Pequenos ajustes permitidos: limpar ru√≠do visual, alinhar melhor elementos, refor√ßar a narrativa com micro detalhes, mas sem alterar a ideia central.
              * Resultado deve parecer uma vers√£o ‚Äúdirectors cut‚Äù da mesma thumbnail ‚Äì quase id√™ntica, por√©m mais moderna e com sensa√ß√£o premium.
            
            - **IDEIA 2 (TURBO CTR INOVADOR):** 
              * Desapegue da composi√ß√£o original e proponha um conceito totalmente novo voltado para CTR 30%+.
              * Use novos enquadramentos, close dram√°tico ou cena cinematogr√°fica in√©dita que amplifique o gancho do t√≠tulo "${selectedTitle}".
              * Aplique gatilhos agressivos de curiosidade e FOMO (express√µes extremas, contraste brutal, elementos inesperados).
              * Redesenhe texto, cores, objetos e ilumina√ß√£o para maximizar leitura instant√¢nea em telas pequenas.
              * Traga um storytelling visual diferente (antes/depois, contagem regressiva, perigo iminente, segredo revelado etc.) que n√£o existe na thumb original.
              * LEMBRE-SE: Deve ser descrito como uma FOTO REAL, e o texto precisa parecer produzido no Photoshop por um designer profissional com m√∫ltiplos efeitos de camada e valores espec√≠ficos.

            PARA CADA UMA DAS 2 IDEIAS, GERE:
            1.  **"seoDescription"**: Uma descri√ß√£o de v√≠deo para o YouTube, EXTREMAMENTE OTIMIZADA PARA SEO E VIRALIZA√á√ÉO, com:
               - Emojis estrat√©gicos e relevantes (use emojis que representem o nicho e subnicho)
               - Par√°grafos bem estruturados com quebras de linha
               - Chamadas para a√ß√£o (CTA) claras e persuasivas
               - Uso estrat√©gico de palavras-chave relevantes para o t√≠tulo "${selectedTitle}" e subnicho "${subniche}"
               - Formata√ß√£o profissional com separadores visuais (‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ)
               - Se√ß√µes organizadas: introdu√ß√£o, conte√∫do do v√≠deo, sobre o canal, links importantes, hashtags
               - Linguagem persuasiva e envolvente que gere curiosidade e urg√™ncia
               - A descri√ß√£o deve estar no idioma "${language}" e ter entre 300-500 palavras
               - IMPORTANTE: Use emojis de forma estrat√©gica (n√£o exagere, mas use para destacar se√ß√µes importantes)
               - Inclua hashtags relevantes no final
               - Seja espec√≠fico sobre o que o espectador vai aprender/ganhar
               
            2.  **"seoTags"**: Um array de strings com as 15-25 tags MAIS RELEVANTES E ESTRAT√âGICAS para o v√≠deo (LIMITE M√ÅXIMO: 300 caracteres no total, incluindo v√≠rgulas e espa√ßos. N√ÉO ultrapasse 300 caracteres), incluindo:
               - Tags de cauda curta (1-2 palavras): termos populares e competitivos relacionados ao t√≠tulo "${selectedTitle}" e subnicho "${subniche}"
               - Tags de cauda longa (3-5 palavras): termos mais espec√≠ficos e menos competitivos que capturam inten√ß√£o de busca
               - Tags de nicho: termos espec√≠ficos do subnicho "${subniche}"
               - Tags de tend√™ncia: termos que est√£o em alta no momento relacionados ao tema
               - Tags de formato: termos como "tutorial", "dicas", "como fazer", "guia completo", "passo a passo", etc.
               - Tags de plataforma: termos relacionados √† plataforma (YouTube, TikTok, Instagram, etc.)
               - Tags de emo√ß√£o: termos que capturam a emo√ß√£o do t√≠tulo (ex: "surpresa", "revela√ß√£o", "mist√©rio", "urg√™ncia", "choque")
               - Tags de benef√≠cio: termos que descrevem o que o espectador vai ganhar/aprender
               - Tags de palavra-chave principal: extrair as palavras-chave mais importantes do t√≠tulo "${selectedTitle}"
               - Tags de sin√¥nimos: varia√ß√µes e sin√¥nimos das palavras-chave principais
               - IMPORTANTE: As tags devem ser EXTREMAMENTE RELEVANTES ao t√≠tulo "${selectedTitle}" e ao subnicho "${subniche}"
               - Evite tags gen√©ricas que n√£o agregam valor
               - Priorize tags que tenham volume de busca mas n√£o sejam extremamente competitivas
               - Misture tags em portugu√™s/ingl√™s/espanhol conforme o idioma "${language}"
               - LIMITE M√ÅXIMO: 300 caracteres no total (incluindo v√≠rgulas e espa√ßos). N√ÉO ultrapasse 300 caracteres.
               - Cada tag deve ter entre 1-5 palavras, sendo a maioria com 2-3 palavras para otimizar o uso do espa√ßo
               - Priorize tags mais relevantes e estrat√©gicas. Se necess√°rio, reduza a quantidade de tags para n√£o ultrapassar 300 caracteres.
            3.  **"frasesDeGancho"**: Um array com 5 frases CURTAS de impacto (ganchos) para a thumbnail, OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne um array vazio [].' : `
                ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO E OBRIGAT√ìRIO - IDIOMA DAS FRASES DE GANCHO ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Portugu√™s' ? `
                ‚úÖ CORRETO (Portugu√™s): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revela√ß√£o Surpreendente"
                ‚ùå ERRADO (Ingl√™s - N√ÉO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ‚ùå ERRADO (Espanhol - N√ÉO USAR): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"
                ` : language === 'Ingl√™s' ? `
                ‚úÖ CORRETO (Ingl√™s): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ‚ùå ERRADO (Portugu√™s - N√ÉO USAR): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"
                ‚ùå ERRADO (Espanhol - N√ÉO USAR): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"
                ` : `
                ‚úÖ CORRETO (Espanhol): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante", "La Verdad", "Nunca Visto", "Descubr√≠ Todo", "Esto Cambi√≥ Todo", "Revelaci√≥n Sorprendente"
                ‚ùå ERRADO (Portugu√™s - N√ÉO USAR): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"
                ‚ùå ERRADO (Ingl√™s - N√ÉO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGAT√ìRIAS:
                1. Se "${language}" for "Portugu√™s", TODAS as 5 frases DEVEM estar em PORTUGU√äS (Brasil)
                2. Se "${language}" for "Ingl√™s", TODAS as 5 frases DEVEM estar em INGL√äS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em ingl√™s se o idioma escolhido for portugu√™s ou espanhol
                5. NUNCA, JAMAIS retorne frases em portugu√™s se o idioma escolhido for ingl√™s ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for portugu√™s ou ingl√™s
                7. Cada frase deve ter 2 a 4 palavras, no m√°ximo
                8. As frases devem ser impactantes e relacionadas ao t√≠tulo "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases est√£o no idioma "${language}"?
                - Nenhuma frase est√° em ingl√™s se "${language}" for portugu√™s ou espanhol?
                - Nenhuma frase est√° em portugu√™s se "${language}" for ingl√™s ou espanhol?
                - Nenhuma frase est√° em espanhol se "${language}" for portugu√™s ou ingl√™s?
                
                Se alguma resposta for N√ÉO, CORRIJA as frases antes de retornar o JSON.
                `}
            4.  **"descricaoThumbnail"**: Um prompt EXTREMAMENTE DETALHADO e V√çVIDO, em INGL√äS, para uma IA de gera√ß√£o de imagem. ${!includePhrases ? 'N√ÉO inclua nenhum placeholder para texto. A thumbnail deve ser APENAS imagem, sem texto ou frases de gancho. Descreva apenas elementos visuais, composi√ß√£o, cores, ilumina√ß√£o, etc.' : 'A descri√ß√£o DEVE incluir OBRIGATORIAMENTE o placeholder exato "[FRASE DE GANCHO AQUI]" em algum lugar da descri√ß√£o, onde o texto da thumbnail ser√° inserido. CR√çTICO: O placeholder "[FRASE DE GANCHO AQUI]" DEVE aparecer literalmente na descri√ß√£o. Quando mencionar o texto, descreva-o como se fosse criado no Photoshop por um designer profissional: use termos como "Professional Photoshop-quality text design displaying [FRASE DE GANCHO AQUI]", "professional layer effects", "Photoshop stroke effect", "professional drop shadow with specific values (distance, spread, size, opacity, angle)", "professional outer glow", "professional bevel and emboss", "professional typography with perfect kerning", "professional text rendering with anti-aliasing", "looks like it was designed by a professional graphic designer". O texto DEVE ter m√∫ltiplos efeitos de camada do Photoshop com valores espec√≠ficos, n√£o apenas descri√ß√µes gen√©ricas. Fonte estilizada profissional, grande e impactante, cores vibrantes e contrastantes, efeitos visuais profissionais (sombra com valores espec√≠ficos, brilho, outline, gradiente), posicionamento estrat√©gico, tamanho grande que ocupa 25-35% da imagem. IMPORTANTE: Sempre inclua o texto "[FRASE DE GANCHO AQUI]" literalmente na descri√ß√£o, por exemplo: "with professional text design displaying [FRASE DE GANCHO AQUI]" ou "featuring large bold text that says [FRASE DE GANCHO AQUI]".'}
            
            CR√çTICO PARA A "descricaoThumbnail" - DEVE SER FOTOGRAFIA REAL ULTRA HD 8K, N√ÉO ILUSTRA√á√ÉO:
            - OBRIGAT√ìRIO: A descri√ß√£o DEVE come√ßar EXATAMENTE com: "Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, real lighting, real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, 8K resolution, extreme sharpness, maximum detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography quality"
            
            - ENFATIZE REPETIDAMENTE E OBRIGATORIAMENTE: "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail", "every pore visible", "every texture crisp", "perfect focus", "ultra sharp", "no blur except intentional depth of field", "no artifacts", "no compression", "no pixelation", "perfect clarity", "real photograph", "shot on location", "documentary photography", "realistic textures with imperfections", "natural lighting with real shadows", "real depth of field", "real bokeh effects", "professional color grading", "high dynamic range (HDR)", "sharp focus on subject", "real camera grain", "real-world photography", "actual photograph", "photographed in real life", "real person", "real object", "real environment", "National Geographic quality", "BBC documentary style", "professional photography", "photorealistic", "hyper-realistic"
            
            - NUNCA, JAMAIS use estes termos: "illustration", "drawing", "artwork", "digital art", "render", "3D render", "CGI", "cartoon", "anime", "sketch", "painting", "stylized", "artistic", "concept art", "digital painting", "graphic design", "vector", "comic", "fantasy art", "artistic interpretation", "stylized", "artistic style", "digital illustration"
            
            - SEMPRE use APENAS estes termos: "photograph", "photo", "photography", "shot", "captured", "documentary photo", "realistic capture", "professional photography", "real-world photography", "actual photograph", "photographed", "real-life photography", "on-location photography", "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail"
            
            - IMPORTANTE: Descreva como se fosse uma FOTO REAL ULTRA HD 8K tirada por um fot√≥grafo profissional. Mencione detalhes realistas como: "real skin texture with pores and natural imperfections visible in 8K detail", "real fabric texture with visible fibers and weave patterns in ultra HD", "real stone texture with weathering, cracks, and imperfections visible in perfect 8K clarity", "real shadows cast by real light sources with perfect sharpness", "real depth of field blur with perfect bokeh", "real camera lens distortion", "real chromatic aberration", "real lens flare", "real motion blur if applicable", "every detail visible in 8K resolution", "extreme sharpness and clarity", "no compression artifacts", "perfect focus on subject"

            REGRAS IMPORTANTES:
            - A "descricaoThumbnail" √© OBRIGATORIAMENTE em INGL√äS.
            - "seoDescription", "seoTags" e "frasesDeGancho" s√£o OBRIGATORIAMENTE no idioma "${language}".
            ${!includePhrases ? '- IMPORTANTE: A "descricaoThumbnail" N√ÉO deve mencionar texto, palavras ou frases. Apenas descreva elementos visuais, composi√ß√£o, cores, ilumina√ß√£o, etc.' : ''}
            - Seja extremamente espec√≠fico e detalhado nas descri√ß√µes visuais. Use termos t√©cnicos de fotografia profissional, cinematografia e psicologia visual quando apropriado.
            - Foque em elementos que maximizem CTR: express√µes faciais intensas, momentos de tens√£o, curiosidade visual, contraste dram√°tico, composi√ß√£o impactante.
            
            EXEMPLOS DE COMO DESCREVER PARA GARANTIR REALISMO:
            - Em vez de "um guerreiro maia", escreva: "a real person dressed as a Mayan warrior, photographed on location, real skin texture with pores and natural imperfections, real fabric of the costume with visible texture and wrinkles, real feathers in the headdress with natural variations"
            - Em vez de "uma pir√¢mide antiga", escreva: "a real ancient Mayan pyramid photographed on location, real weathered stone with cracks and imperfections, real moss and vegetation growing on the stones, real shadows cast by the sun, real depth of field blur in the background"
            - Em vez de "luz m√≠stica", escreva: "real natural lighting from the sun, real shadows cast by real objects, real depth of field, real bokeh in the background, real camera lens flare if the sun is in frame"
            - SEMPRE mencione: "real", "actual", "photographed", "shot on location", "documentary style", "real-world", "actual photograph"
            
            T√âCNICAS DE THUMBNAIL VIRAL PARA O TEXTO (quando includePhrases = true) - DESIGN PROFISSIONAL COMO PHOTOSHOP - CTR ACIMA DE 25%:
            
            üìù DESCRI√á√ÉO OBRIGAT√ìRIA DO TEXTO - DEVE PARECER FEITO NO PHOTOSHOP POR UM DESIGNER PROFISSIONAL:
            O texto DEVE ser descrito como se fosse criado no Photoshop com t√©cnicas profissionais de design gr√°fico:
            
            1. TIPOGRAFIA PROFISSIONAL:
               - "Professional typography, Photoshop-quality text design"
               - "Large, bold, professionally designed text occupying 25-35% of the image height"
               - "Massive, oversized typography with professional letter spacing and kerning"
               - "Thick, chunky, professionally rendered letters"
               - "Typography that looks like it was designed by a professional graphic designer"
               - "High-end text design, magazine-quality typography"
            
            2. CORES PROFISSIONAIS E EFEITOS DE CAMADA (Layer Effects do Photoshop):
               - "Bright yellow (#FFD700) text with professional Photoshop layer effects: thick black stroke (6-8px), white drop shadow with distance 8px, spread 5px, size 12px, opacity 80%, angle 135 degrees"
               - "Pure white text with professional red stroke (6px), black drop shadow with blur radius 10px, and subtle outer glow effect in yellow"
               - "Neon orange (#FF6600) text with black stroke (7px), professional drop shadow with multiple layers, and yellow outer glow with spread 8px"
               - "Electric blue (#00FFFF) text with white stroke (6px), black shadow with distance 10px, and professional bevel and emboss effect"
               - "Bright red (#FF0000) text with yellow stroke (5px), white drop shadow, and professional gradient overlay from yellow to orange"
               - "Lime green (#00FF00) text with black stroke (8px), white glow effect, and professional inner shadow"
               - IMPORTANTE: Descreva como efeitos de camada do Photoshop (layer effects), n√£o apenas "outline" ou "shadow"
               
               üèÜ ESTILO √âPICO - TEXTOS EM DOURADO (Para thumbnails hist√≥ricas/√©picas):
               - Se a thumbnail original usar textos em dourado, DESCREVA EXATAMENTE assim:
               - "Large, bold, ornate serif font text in golden yellow (#FFD700) with professional Photoshop layer effects: thick black stroke (8-10px width, position outside), professional bevel and emboss effect (style: emboss, technique: smooth, depth 150%, size 8px, softness 3px, highlight mode: screen with opacity 75%, shadow mode: multiply with opacity 50%), white drop shadow (distance 12px, spread 6px, size 15px, opacity 85%, angle 135¬∞), subtle outer glow in golden yellow (spread 10px, size 20px, opacity 60%), positioned at the bottom center of the image, occupying 30-35% of the image height, professional ornate serif typography (Trajan Pro, Cinzel, or similar historical/regal font style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, looks like it was designed by a professional graphic designer for a historical epic movie poster"
               - "Golden embossed text with metallic finish, professional 3D effect, regal and majestic appearance, historical epic typography style"
            
            3. FONTES PROFISSIONAIS:
               - "Professional bold sans-serif font (Impact, Bebas Neue, Montserrat Black, or similar premium font)"
               - "Thick, chunky, professionally designed block letters"
               - "Modern, high-end typography with perfect letter spacing"
               - "YouTube viral thumbnail professional font style"
               - "Bold, condensed font with professional kerning and tracking"
               - "Premium typography, no serifs, maximum readability, professional design"
               - "Typography that looks like it came from a professional design agency"
            
            4. EFEITOS PROFISSIONAIS DO PHOTOSHOP (Layer Styles):
               - "Professional Photoshop stroke effect: thick black outline (6-8px width), position: outside, blend mode: normal, opacity: 100%"
               - "Professional drop shadow: distance 10px, spread 5px, size 12px, angle 135¬∞, opacity 80%, color black, blend mode: multiply"
               - "Professional outer glow effect: spread 8px, size 15px, opacity 75%, color matching text or contrasting"
               - "Professional bevel and emboss effect: style: emboss, technique: smooth, depth 100%, size 5px, softness 2px"
               - "Professional gradient overlay: linear gradient from bright color to darker shade, angle 90¬∞, opacity 80%"
               - "Professional inner shadow: distance 3px, choke 0%, size 5px, opacity 60%"
               - "Professional color overlay: solid color with blend mode overlay or soft light, opacity 50%"
               - "Text appears to pop out from the image with professional 3D effect"
               - "Professional text rendering with anti-aliasing, crisp edges, perfect clarity"
            
            5. COMPOSI√á√ÉO PROFISSIONAL:
               - "Positioned at the top center of the image with professional alignment"
               - "Bottom third of the image with professional composition and high contrast background"
               - "Centered horizontally, upper third vertically, following rule of thirds"
               - "Strategically placed to not cover important visual elements, professional layout"
               - "Text area has professional semi-transparent dark background (black overlay with 40% opacity) for better readability"
               - "Professional text box or banner behind text with gradient or solid color, rounded corners optional"
            
            6. CONTRASTE E VISIBILIDADE PROFISSIONAL:
               - "High contrast against the background, professionally optimized"
               - "Text stands out dramatically from the image with professional design techniques"
               - "Eye-catching text overlay that immediately draws attention, professional composition"
               - "Text that pops from the image with maximum visibility, professional rendering"
               - "Text is the first thing the eye is drawn to, professional visual hierarchy"
               - "Background is professionally darkened (vignette effect) or lightened behind text for maximum contrast"
               - "Professional color grading applied to background to make text stand out"
            
            7. EXEMPLO COMPLETO DE DESCRI√á√ÉO PROFISSIONAL:
               "Professional Photoshop-quality text design: Large, bold, stylized text '[FRASE DE GANCHO AQUI]' in bright yellow (#FFD700) with professional layer effects: thick black stroke (7px width, position outside), white drop shadow (distance 10px, spread 5px, size 12px, opacity 80%, angle 135¬∞), subtle outer glow in white (spread 6px, size 10px, opacity 70%), positioned at the top center of the image, occupying 30% of the image height, professional bold sans-serif font (Impact or Bebas Neue style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, high contrast viral thumbnail text style, eye-catching and attention-grabbing, text appears to pop out from the image with professional 3D effect, maximum visibility for high CTR, looks like it was designed by a professional graphic designer in Photoshop"
            
            8. REGRAS DE OURO PARA DESIGN PROFISSIONAL:
               - O texto DEVE parecer feito no Photoshop por um designer profissional
               - O texto DEVE ter m√∫ltiplos efeitos de camada (stroke, shadow, glow, bevel)
               - O texto DEVE ter valores espec√≠ficos de efeitos (dist√¢ncia, spread, tamanho, opacidade)
               - O texto DEVE ter tipografia profissional com kerning e tracking perfeitos
               - O texto DEVE ter renderiza√ß√£o profissional (anti-aliasing, crisp edges)
               - O texto DEVE ter composi√ß√£o profissional (regra dos ter√ßos, hierarquia visual)
               - O texto DEVE parecer de qualidade de ag√™ncia de design, n√£o amador

            RESPONDA APENAS COM UM OBJETO JSON V√ÅLIDO, com a seguinte estrutura:
            {
              "ideias": [
                {
                  "seoDescription": "Descri√ß√£o completa e otimizada para o YouTube aqui...",
                  "seoTags": ["tag1", "tag2", "tag3", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Portugu√™s' ? '["Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"]' : language === 'Ingl√™s' ? '["He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"]' : '["√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'A detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'A detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                },
                {
                  "seoDescription": "Outra descri√ß√£o completa e otimizada...",
                  "seoTags": ["tagA", "tagB", "tagC", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Portugu√™s' ? '["A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revela√ß√£o Surpreendente"]' : language === 'Ingl√™s' ? '["The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything", "Surprising Revelation"]' : '["La Verdad", "Nunca Visto", "Descubr√≠ Todo", "Esto Cambi√≥ Todo", "Revelaci√≥n Sorprendente"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'Another detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'Another detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                }
              ]
            }
        `;
            } else { // OpenAI
                thumbPrompt = `
            Voc√™ √© um especialista em YouTube, combinando as habilidades de um diretor de arte para thumbnails e um mestre de SEO.${formulaContext}

            IMAGEM DE REFER√äNCIA: [A imagem da thumbnail original do v√≠deo est√° anexada]
            T√çTULO DO V√çDEO (para contexto): "${selectedTitle}"
            SUBNICHE (P√∫blico-Alvo): "${subniche}"
            ESTILO DE ARTE DESEJADO: "${style}"
            IDIOMA DO CONTE√öDO: "${language}"

            ‚ö†Ô∏è ATEN√á√ÉO CR√çTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, n√£o ilustra√ß√µes, desenhos ou renderiza√ß√µes. A descri√ß√£oThumbnail deve descrever uma FOTO REAL tirada por um fot√≥grafo profissional em um local real, com pessoas reais e objetos reais.
            
            üé® IDENTIFICA√á√ÉO E REPLICA√á√ÉO DE ESTILOS √âPICOS/CINEMATOGR√ÅFICOS:
            
            Analise a IMAGEM DE REFER√äNCIA e identifique qual estilo visual ela utiliza. Se identificar algum dos estilos abaixo, REPLIQUE-O FIELMENTE na IDEIA 1, apenas melhorando a qualidade:
            
            üìê ESTILO 1: COMPOSI√á√ÉO DIVIDIDA (ESQUERDA/DIREITA):
            - Imagem dividida verticalmente em duas metades contrastantes
            - Lado esquerdo: geralmente cenas de paz/grandiosidade (cidades antigas, paisagens douradas, c√©u claro)
            - Lado direito: geralmente cenas de conflito/amea√ßa (tempestades, navios, ex√©rcitos, c√©u escuro)
            - Figura central ou pr√≥xima ao centro conectando os dois lados
            - Contraste dram√°tico entre luz (esquerda) e escurid√£o (direita)
            - Texto grande em dourado (#FFD700) na parte inferior, fonte serifada ornamentada com efeito emboss/bevel
            - Exemplos: Atahualpa (cidade dourada vs navios tempestuosos), Malinche (mapa vs batalha naval)
            
            üìê ESTILO 2: CLOSE-UP DRAM√ÅTICO COM BACKGROUND √âPICO:
            - Figura hist√≥rica em close-up ocupando 40-60% da imagem (rosto e parte superior do corpo)
            - Express√£o intensa e direta para a c√¢mera
            - Background dividido ou com elementos √©picos (pir√¢mides, navios, batalhas, fogo)
            - Ilumina√ß√£o dram√°tica com chiaroscuro (luz forte vs sombras profundas)
            - Texto grande em dourado na parte inferior
            - Exemplos: Fara√≥ com pir√¢mides ao fundo, l√≠der ind√≠gena com cidade antiga
            
            üìê ESTILO 3: CENA √âPICA COM ELEMENTOS DE DESTRUI√á√ÉO:
            - Cena de batalha ou conflito hist√≥rico
            - Elementos de fogo, fuma√ßa, tempestades
            - Navios em chamas, ex√©rcitos, destrui√ß√£o
            - C√©u tempestuoso com nuvens escuras
            - Figuras em primeiro plano com express√µes dram√°ticas
            - Texto grande em dourado/amarelo com outline preto
            - Exemplos: Batalhas navais, conquistas, segredos dos fara√≥s
            
            üìê ESTILO 4: FIGURA HIST√ìRICA COM ELEMENTOS SIMB√ìLICOS:
            - Figura hist√≥rica em destaque (fara√≥, l√≠der, conquistador)
            - Trajes elaborados e aut√™nticos (coroas, armaduras, roupas tradicionais)
            - Elementos simb√≥licos ao redor (pir√¢mides, navios, mapas, hier√≥glifos)
            - Composi√ß√£o vertical ou horizontal com figura dominante
            - Texto grande em dourado com fonte serifada ornamentada
            - Exemplos: Fara√≥ com pir√¢mides, l√≠der ind√≠gena com coroa elaborada
            
            ‚ö†Ô∏è REGRAS PARA REPLICA√á√ÉO FIEL:
            1. Se a thumbnail original usar COMPOSI√á√ÉO DIVIDIDA, mantenha EXATAMENTE essa estrutura (mesma divis√£o, mesmo contraste, mesma posi√ß√£o dos elementos)
            2. Se a thumbnail original usar CLOSE-UP DRAM√ÅTICO, mantenha o mesmo enquadramento e propor√ß√£o da figura
            3. Se a thumbnail original usar TEXTOS EM DOURADO, mantenha a mesma cor (#FFD700), fonte serifada e efeitos (emboss, bevel, glow)
            4. Se a thumbnail original usar ELEMENTOS √âPICOS (pir√¢mides, navios, fogo), mantenha os mesmos elementos na mesma posi√ß√£o
            5. Se a thumbnail original usar CONTRASTE LUZ/ESQUERID√ÉO, mantenha o mesmo esquema de ilumina√ß√£o
            6. Se a thumbnail original usar FIGURAS HIST√ìRICAS, mantenha o mesmo tipo de figura, trajes e express√£o
            7. Apenas MELHORE: nitidez 8K, contraste mais forte, cores mais saturadas, ilumina√ß√£o mais dram√°tica, texto com efeitos Photoshop mais refinados
            
            ${(() => {
                const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
                if (ruleData.mode === 'auto') {
                    return `\n            üîç MODO AUTOM√ÅTICO - AN√ÅLISE DE REGRA:\n            Analise o t√≠tulo "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPL√çCITA na descri√ß√£o da thumbnail. Se m√∫ltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.\n\n            üìã AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE (ALGORITMO OFICIAL):\n\n            1Ô∏è‚É£ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO):\n            O c√©rebro precisa entender a thumbnail em menos de 1 segundo. Se houver confus√£o, o clique cai.\n            Checklist OBRIGAT√ìRIO: 1 ideia principal, 1 personagem, 1 emo√ß√£o, 1 objeto-chave.\n            A thumbnail DEVE ser compreendida instantaneamente. Elimine qualquer elemento que cause confus√£o ou distra√ß√£o.\n\n            2Ô∏è‚É£ REGRA DO ASSUNTO √öNICO:\n            Nada divide a aten√ß√£o. A thumbnail boa √© sempre uma hist√≥ria em uma imagem.\n            Foque em UM √öNICO assunto dominante. Nada deve competir pela aten√ß√£o. A thumbnail deve contar uma hist√≥ria completa em uma √∫nica imagem, sem elementos que dividam o foco.\n\n            3Ô∏è‚É£ REGRA DO ROSTO GRANDE:\n            Rostos com forte express√£o emocional aumentam CTR de 20% a 60%.\n            Express√µes mais fortes: choque, surpresa, medo, raiva, felicidade extrema.\n            Use um rosto GRANDE ocupando pelo menos 40-50% da imagem. A express√£o facial DEVE ser EXTREMA e EMOCIONAL. O rosto deve ser o elemento dominante e a primeira coisa que o olho v√™.\n\n            4Ô∏è‚É£ REGRA DO CONTRASTE BRUTAL:\n            Se n√£o tiver contraste, a thumbnail fica invis√≠vel.\n            Use CONTRASTE BRUTAL entre: texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n            O contraste deve ser t√£o forte que a thumbnail "pula" da tela mesmo em tamanho pequeno.\n\n            5Ô∏è‚É£ REGRA DA COR ESTRAT√âGICA:\n            Cada cor ativa um gatilho:\n            - Amarelo: aten√ß√£o imediata\n            - Vermelho: urg√™ncia / perigo\n            - Azul: confian√ßa\n            - Verde: dinheiro / solu√ß√£o\n            - Preto: premium / mist√©rio\n            Escolha a cor baseada na emo√ß√£o que o t√≠tulo transmite.\n\n            6Ô∏è‚É£ REGRA DOS TER√áOS:\n            Posicionar o assunto nos cruzamentos dos "9 quadrantes". Isso d√° harmonia e aumenta o foco natural.\n            Posicione o elemento principal (rosto, objeto, texto) nos pontos de cruzamento da regra dos ter√ßos (onde as linhas dos 9 quadrantes se encontram). Isso cria harmonia visual e guia o olhar naturalmente para o foco.\n\n            7Ô∏è‚É£ REGRA DO TEXTO ULTRA CURTO:\n            Texto deve ter 2 a 4 palavras, nunca mais.\n            Exemplos: "Ele mentiu", "Descobri isso", "Ningu√©m viu", "Proibido".\n            O texto na thumbnail DEVE ter APENAS 2 a 4 palavras. Textos longos matam o CTR. Seja brutalmente direto e impactante.\n\n            8Ô∏è‚É£ REGRA DO ZOOM EMOCIONAL:\n            Aparece sempre um elemento gigante que amplifica a emo√ß√£o ou o conflito.\n            Exemplos: uma conta banc√°ria gigante, uma faca gigante, uma lupa gigante, um n√∫mero gigante.\n            Use um elemento GIGANTE que amplifique a emo√ß√£o ou conflito. Este elemento deve ocupar 30-40% da imagem e ser o foco emocional.\n\n            9Ô∏è‚É£ REGRA DO MIST√âRIO:\n            Toda thumbnail viral tem uma pergunta impl√≠cita.\n            Exemplos: algo escondido atr√°s de blur, objeto cortado pela metade, pessoa olhando para fora do quadro, seta apontando para algo fora da tela.\n            Crie uma pergunta impl√≠cita na thumbnail. O espectador DEVE sentir curiosidade sobre o que est√° fora da imagem.\n\n            üîü REGRA DOS PONTOS DE FUGA:\n            Linhas visuais guiam o olhar para o foco: personagem ou objeto principal.\n            Sinaliza√ß√µes: setas, linhas diagonais, perspectiva.\n            Use linhas visuais que guiem o olhar para o foco. Essas linhas devem criar um caminho visual que leve o olho diretamente para o elemento principal.\n\n            1Ô∏è‚É£1Ô∏è‚É£ REGRA DO ESPA√áO NEGATIVO:\n            Deixar √°reas vazias acentua o foco. Sem isso, a imagem vira bagun√ßa.\n            Deixe √°reas vazias (espa√ßo negativo) que acentuem o foco no elemento principal. O espa√ßo vazio cria respira√ß√£o visual e faz o elemento principal "pular" da imagem.\n\n            1Ô∏è‚É£2Ô∏è‚É£ REGRA DA COER√äNCIA COM O T√çTULO:\n            Thumbnail e t√≠tulo precisam contar a mesma hist√≥ria, mas com √¢ngulos diferentes.\n            T√≠tulo = contexto, Thumbnail = emo√ß√£o.\n            A thumbnail e o t√≠tulo DEVEM contar a mesma hist√≥ria, mas com √¢ngulos diferentes. A thumbnail deve amplificar a emo√ß√£o que o t√≠tulo promete, criando uma sinergia perfeita.\n\n            ‚ö†Ô∏è CR√çTICO: Identifique qual regra melhor se encaixa no t√≠tulo "${selectedTitle}" e aplique-a de forma EXPL√çCITA e RIGOROSA na descri√ß√£o da thumbnail. Se m√∫ltiplas regras se aplicarem, combine-as de forma harmoniosa, mas sempre priorize a que tiver maior impacto no CTR.`;
                } else {
                    return `\n            üìã REGRA SELECIONADA: ${ruleData.rule.name}\n            ${ruleData.rule.description}\n\n            ${ruleData.rule.checklist ? `‚úÖ Checklist: ${ruleData.rule.checklist.join(', ')}` : ''}\n            ${ruleData.rule.expressions ? `üòÆ Express√µes recomendadas: ${ruleData.rule.expressions.join(', ')}` : ''}\n            ${ruleData.rule.contrasts ? `üé® Contrastes: ${ruleData.rule.contrasts.join(', ')}` : ''}\n            ${ruleData.rule.colors ? `üåà Cores estrat√©gicas: ${Object.entries(ruleData.rule.colors).map(([k, v]) => `${k} (${v})`).join(', ')}` : ''}\n            ${ruleData.rule.examples ? `üí° Exemplos: ${ruleData.rule.examples.join(', ')}` : ''}\n            ${ruleData.rule.elements ? `‚û°Ô∏è Elementos: ${ruleData.rule.elements.join(', ')}` : ''}\n\n            ‚ö†Ô∏è CR√çTICO: Aplique esta regra de forma EXPL√çCITA e RIGOROSA na descri√ß√£o da thumbnail:\n            ${ruleData.instructions}`;
                }
            })()}
            
            üéØ OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando t√©cnicas de Thumbnail Designer profissional:
            - TEXTO PROFISSIONAL (COMO PHOTOSHOP): O texto DEVE parecer feito no Photoshop por um designer profissional. Use m√∫ltiplos efeitos de camada (stroke, drop shadow com valores espec√≠ficos, outer glow, bevel and emboss), tipografia profissional com kerning perfeito, renderiza√ß√£o profissional com anti-aliasing. Grande, estilizado, cores vibrantes (amarelo/vermelho/branco com outline preto), efeitos visuais profissionais com valores espec√≠ficos (dist√¢ncia, spread, tamanho, opacidade, √¢ngulo), posicionamento estrat√©gico (topo/centro), ocupando 25-35% da imagem. O texto DEVE ter qualidade de ag√™ncia de design, n√£o amador.
            - COMPOSI√á√ÉO: Regra dos ter√ßos, hierarquia visual clara, elemento principal em destaque
            - CORES: Alto contraste, cores complementares, satura√ß√£o otimizada, fundo que faz o texto "pular"
            - EMO√á√ÉO: Express√µes faciais intensas, momentos de tens√£o, curiosidade visual
            - ELEMENTOS VIRAIS: FOMO (medo de perder), surpresa, contraste dram√°tico, storytelling visual
            
            SUA TAREFA (OTIMIZADA PARA VIRALIZA√á√ÉO - GPT):
            Analise a thumbnail VIRAL de refer√™ncia (IMAGEM DE REFER√äNCIA anexada) e crie DUAS (2) adapta√ß√µes que mantenham o PODER VIRAL original, mas adaptadas para o subnicho "${subniche}" e o t√≠tulo "${selectedTitle}".
            
            ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - ORDEM DAS IDEIAS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
            - **IDEIA 1 (R√âPLICA E MELHORIA DA THUMBNAIL ORIGINAL DO V√çDEO):** 
              * OBRIGAT√ìRIO: Esta ideia DEVE replicar e melhorar a thumbnail ORIGINAL do v√≠deo ao qual foram feitos os t√≠tulos.
              * Analise cuidadosamente a IMAGEM DE REFER√äNCIA (thumbnail original do v√≠deo) que est√° anexada.
              * Replique a estrutura da thumbnail de refer√™ncia quase 1:1: mantenha EXATAMENTE √¢ngulo de c√¢mera, enquadramento, posi√ß√£o dos personagens/objetos, quantidade e posi√ß√£o do texto, paleta de cores e elementos de cen√°rio.
              * PRESERVE exatamente o storytelling visual da thumbnail original que gerou milh√µes de views, apenas elevando a qualidade (recortes perfeitos, tratamento de pele profissional, brilho nos olhos, textura realista, corre√ß√£o de cor cinematogr√°fica).
              * Ajustes permitidos: aumentar nitidez (8K), refor√ßar contraste, limpar ru√≠dos, adicionar luzes/sombras profissionais e aplicar efeitos de texto Photoshop com valores espec√≠ficos (stroke, drop shadow, outer glow, bevel & emboss).
              * Resultado: praticamente igual √† thumb original, mas com sensa√ß√£o de upgrade premium e leitura instant√¢nea mais clara e clic√°vel.
              * IMPORTANTE: Se a thumbnail original n√£o estiver dispon√≠vel ou n√£o puder ser analisada, ainda assim mantenha o mesmo conceito visual e estrutura, apenas melhorando a qualidade.
            
            - **IDEIA 2 (THUMBNAIL MELHORADA E OTIMIZADA):** 
              * Esta √© uma vers√£o COMPLETAMENTE NOVA, melhorada e otimizada para CTR alto (30%+).
              * Crie um conceito totalmente novo com foco em CTR m√°ximo: novo enquadramento, nova composi√ß√£o, novos elementos que gerem curiosidade extrema.
              * Use gatilhos agressivos (perigo, segredo revelado, n√∫meros gigantes, setas, antes/depois, close dram√°tico) e cores super contrastantes.
              * Construa um storytelling diferente, alinhado ao t√≠tulo "${selectedTitle}", que prometa algo ainda mais irresist√≠vel que a vers√£o original.
              * O texto deve ser redesenhado para m√°xima legibilidade mobile, com layer styles profissionais e valores precisos.
              * Objetivo: criar uma thumbnail in√©dita que pare√ßa "campanha de performance", otimizada para CTR alto e reten√ß√£o visual imediata.
              * Esta vers√£o deve ser AINDA MELHOR que a original, com t√©cnicas avan√ßadas de viraliza√ß√£o.

            PARA CADA UMA DAS 2 IDEIAS, GERE:
            1.  **"seoDescription"**: Uma descri√ß√£o de v√≠deo para o YouTube, EXTREMAMENTE OTIMIZADA PARA SEO E VIRALIZA√á√ÉO, com:
               - Emojis estrat√©gicos e relevantes (use emojis que representem o nicho e subnicho)
               - Par√°grafos bem estruturados com quebras de linha
               - Chamadas para a√ß√£o (CTA) claras e persuasivas
               - Uso estrat√©gico de palavras-chave relevantes para o t√≠tulo "${selectedTitle}" e subnicho "${subniche}"
               - Formata√ß√£o profissional com separadores visuais (‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ)
               - Se√ß√µes organizadas: introdu√ß√£o, conte√∫do do v√≠deo, sobre o canal, links importantes, hashtags
               - Linguagem persuasiva e envolvente que gere curiosidade e urg√™ncia
               - A descri√ß√£o deve estar no idioma "${language}" e ter entre 300-500 palavras
               - IMPORTANTE: Use emojis de forma estrat√©gica (n√£o exagere, mas use para destacar se√ß√µes importantes)
               - Inclua hashtags relevantes no final
               - Seja espec√≠fico sobre o que o espectador vai aprender/ganhar
               
            2.  **"seoTags"**: Um array de strings com as 15-25 tags MAIS RELEVANTES E ESTRAT√âGICAS para o v√≠deo (LIMITE M√ÅXIMO: 300 caracteres no total, incluindo v√≠rgulas e espa√ßos. N√ÉO ultrapasse 300 caracteres), incluindo:
               - Tags de cauda curta (1-2 palavras): termos populares e competitivos relacionados ao t√≠tulo "${selectedTitle}" e subnicho "${subniche}"
               - Tags de cauda longa (3-5 palavras): termos mais espec√≠ficos e menos competitivos que capturam inten√ß√£o de busca
               - Tags de nicho: termos espec√≠ficos do subnicho "${subniche}"
               - Tags de tend√™ncia: termos que est√£o em alta no momento relacionados ao tema
               - Tags de formato: termos como "tutorial", "dicas", "como fazer", "guia completo", "passo a passo", etc.
               - Tags de plataforma: termos relacionados √† plataforma (YouTube, TikTok, Instagram, etc.)
               - Tags de emo√ß√£o: termos que capturam a emo√ß√£o do t√≠tulo (ex: "surpresa", "revela√ß√£o", "mist√©rio", "urg√™ncia", "choque")
               - Tags de benef√≠cio: termos que descrevem o que o espectador vai ganhar/aprender
               - Tags de palavra-chave principal: extrair as palavras-chave mais importantes do t√≠tulo "${selectedTitle}"
               - Tags de sin√¥nimos: varia√ß√µes e sin√¥nimos das palavras-chave principais
               - IMPORTANTE: As tags devem ser EXTREMAMENTE RELEVANTES ao t√≠tulo "${selectedTitle}" e ao subnicho "${subniche}"
               - Evite tags gen√©ricas que n√£o agregam valor
               - Priorize tags que tenham volume de busca mas n√£o sejam extremamente competitivas
               - Misture tags em portugu√™s/ingl√™s/espanhol conforme o idioma "${language}"
               - LIMITE M√ÅXIMO: 300 caracteres no total (incluindo v√≠rgulas e espa√ßos). N√ÉO ultrapasse 300 caracteres.
               - Cada tag deve ter entre 1-5 palavras, sendo a maioria com 2-3 palavras para otimizar o uso do espa√ßo
               - Priorize tags mais relevantes e estrat√©gicas. Se necess√°rio, reduza a quantidade de tags para n√£o ultrapassar 300 caracteres.
            3.  **"frasesDeGancho"**: Um array com 5 frases CURTAS de impacto (ganchos) para a thumbnail, OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne um array vazio [].' : `
                ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO E OBRIGAT√ìRIO - IDIOMA DAS FRASES DE GANCHO ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Portugu√™s' ? `
                ‚úÖ CORRETO (Portugu√™s): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revela√ß√£o Surpreendente"
                ‚ùå ERRADO (Ingl√™s - N√ÉO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ‚ùå ERRADO (Espanhol - N√ÉO USAR): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"
                ` : language === 'Ingl√™s' ? `
                ‚úÖ CORRETO (Ingl√™s): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ‚ùå ERRADO (Portugu√™s - N√ÉO USAR): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"
                ‚ùå ERRADO (Espanhol - N√ÉO USAR): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"
                ` : `
                ‚úÖ CORRETO (Espanhol): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante", "La Verdad", "Nunca Visto", "Descubr√≠ Todo", "Esto Cambi√≥ Todo", "Revelaci√≥n Sorprendente"
                ‚ùå ERRADO (Portugu√™s - N√ÉO USAR): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"
                ‚ùå ERRADO (Ingl√™s - N√ÉO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGAT√ìRIAS:
                1. Se "${language}" for "Portugu√™s", TODAS as 5 frases DEVEM estar em PORTUGU√äS (Brasil)
                2. Se "${language}" for "Ingl√™s", TODAS as 5 frases DEVEM estar em INGL√äS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em ingl√™s se o idioma escolhido for portugu√™s ou espanhol
                5. NUNCA, JAMAIS retorne frases em portugu√™s se o idioma escolhido for ingl√™s ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for portugu√™s ou ingl√™s
                7. Cada frase deve ter 2 a 4 palavras, no m√°ximo
                8. As frases devem ser impactantes e relacionadas ao t√≠tulo "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases est√£o no idioma "${language}"?
                - Nenhuma frase est√° em ingl√™s se "${language}" for portugu√™s ou espanhol?
                - Nenhuma frase est√° em portugu√™s se "${language}" for ingl√™s ou espanhol?
                - Nenhuma frase est√° em espanhol se "${language}" for portugu√™s ou ingl√™s?
                
                Se alguma resposta for N√ÉO, CORRIJA as frases antes de retornar o JSON.
                `}
            4.  **"descricaoThumbnail"**: Um prompt EXTREMAMENTE DETALHADO e V√çVIDO, em INGL√äS, para uma IA de gera√ß√£o de imagem. ${!includePhrases ? 'N√ÉO inclua nenhum placeholder para texto. A thumbnail deve ser APENAS imagem, sem texto ou frases de gancho. Descreva apenas elementos visuais, composi√ß√£o, cores, ilumina√ß√£o, etc.' : 'A descri√ß√£o DEVE incluir OBRIGATORIAMENTE o placeholder exato "[FRASE DE GANCHO AQUI]" em algum lugar da descri√ß√£o, onde o texto da thumbnail ser√° inserido. CR√çTICO: O placeholder "[FRASE DE GANCHO AQUI]" DEVE aparecer literalmente na descri√ß√£o. Quando mencionar o texto, descreva-o como se fosse criado no Photoshop por um designer profissional: use termos como "Professional Photoshop-quality text design displaying [FRASE DE GANCHO AQUI]", "professional layer effects", "Photoshop stroke effect", "professional drop shadow with specific values (distance, spread, size, opacity, angle)", "professional outer glow", "professional bevel and emboss", "professional typography with perfect kerning", "professional text rendering with anti-aliasing", "looks like it was designed by a professional graphic designer". O texto DEVE ter m√∫ltiplos efeitos de camada do Photoshop com valores espec√≠ficos, n√£o apenas descri√ß√µes gen√©ricas. Fonte estilizada profissional, grande e impactante, cores vibrantes e contrastantes, efeitos visuais profissionais (sombra com valores espec√≠ficos, brilho, outline, gradiente), posicionamento estrat√©gico, tamanho grande que ocupa 25-35% da imagem. IMPORTANTE: Sempre inclua o texto "[FRASE DE GANCHO AQUI]" literalmente na descri√ß√£o, por exemplo: "with professional text design displaying [FRASE DE GANCHO AQUI]" ou "featuring large bold text that says [FRASE DE GANCHO AQUI]".'}
            
            CR√çTICO PARA A "descricaoThumbnail" - DEVE SER FOTOGRAFIA REAL ULTRA HD 8K, N√ÉO ILUSTRA√á√ÉO:
            - OBRIGAT√ìRIO: A descri√ß√£o DEVE come√ßar EXATAMENTE com: "Ultra-high-definition (8K) professional photograph, captured with a world-class professional camera (Arri Alexa 65, Red Komodo, or Canon EOS R5), shot on location, real-world photography, documentary photography, photorealistic, hyper-realistic, absolutely no illustration, no drawing, no cartoon, no artwork, no digital art, no render, no 3D, no CGI, no stylized, no artistic interpretation, real photograph of real people and real objects, National Geographic documentary quality, BBC documentary style, real textures, real imperfections, real lighting, real shadows, real depth of field, real bokeh, real camera grain, real color grading, real-world photography, 8K resolution, extreme sharpness, maximum detail, every pore visible, every texture crisp, professional color grading, cinematic lighting, perfect focus, ultra sharp, no blur except intentional depth of field, no artifacts, no compression, no pixelation, perfect clarity, professional photography quality"
            
            - ENFATIZE REPETIDAMENTE E OBRIGATORIAMENTE: "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail", "every pore visible", "every texture crisp", "perfect focus", "ultra sharp", "no blur except intentional depth of field", "no artifacts", "no compression", "no pixelation", "perfect clarity", "real photograph", "shot on location", "documentary photography", "realistic textures with imperfections", "natural lighting with real shadows", "real depth of field", "real bokeh effects", "professional color grading", "high dynamic range (HDR)", "sharp focus on subject", "real camera grain", "real-world photography", "actual photograph", "photographed in real life", "real person", "real object", "real environment", "National Geographic quality", "BBC documentary style", "professional photography", "photorealistic", "hyper-realistic"
            
            - NUNCA, JAMAIS use estes termos: "illustration", "drawing", "artwork", "digital art", "render", "3D render", "CGI", "cartoon", "anime", "sketch", "painting", "stylized", "artistic", "concept art", "digital painting", "graphic design", "vector", "comic", "fantasy art", "artistic interpretation", "stylized", "artistic style", "digital illustration"
            
            - SEMPRE use APENAS estes termos: "photograph", "photo", "photography", "shot", "captured", "documentary photo", "realistic capture", "professional photography", "real-world photography", "actual photograph", "photographed", "real-life photography", "on-location photography", "Ultra-high-definition 8K", "8K resolution", "extreme sharpness", "maximum detail"
            
            - IMPORTANTE: Descreva como se fosse uma FOTO REAL ULTRA HD 8K tirada por um fot√≥grafo profissional. Mencione detalhes realistas como: "real skin texture with pores and natural imperfections visible in 8K detail", "real fabric texture with visible fibers and weave patterns in ultra HD", "real stone texture with weathering, cracks, and imperfections visible in perfect 8K clarity", "real shadows cast by real light sources with perfect sharpness", "real depth of field blur with perfect bokeh", "real camera lens distortion", "real chromatic aberration", "real lens flare", "real motion blur if applicable", "every detail visible in 8K resolution", "extreme sharpness and clarity", "no compression artifacts", "perfect focus on subject"

            REGRAS IMPORTANTES:
            - A "descricaoThumbnail" √© OBRIGATORIAMENTE em INGL√äS.
            - "seoDescription", "seoTags" e "frasesDeGancho" s√£o OBRIGATORIAMENTE no idioma "${language}".
            ${!includePhrases ? '- IMPORTANTE: A "descricaoThumbnail" N√ÉO deve mencionar texto, palavras ou frases. Apenas descreva elementos visuais, composi√ß√£o, cores, ilumina√ß√£o, etc.' : ''}
            - Seja extremamente espec√≠fico e detalhado nas descri√ß√µes visuais. Use termos t√©cnicos de fotografia profissional, cinematografia e psicologia visual quando apropriado.
            - Foque em elementos que maximizem CTR: express√µes faciais intensas, momentos de tens√£o, curiosidade visual, contraste dram√°tico, composi√ß√£o impactante.
            
            EXEMPLOS DE COMO DESCREVER PARA GARANTIR REALISMO:
            - Em vez de "um guerreiro maia", escreva: "a real person dressed as a Mayan warrior, photographed on location, real skin texture with pores and natural imperfections, real fabric of the costume with visible texture and wrinkles, real feathers in the headdress with natural variations"
            - Em vez de "uma pir√¢mide antiga", escreva: "a real ancient Mayan pyramid photographed on location, real weathered stone with cracks and imperfections, real moss and vegetation growing on the stones, real shadows cast by the sun, real depth of field blur in the background"
            - Em vez de "luz m√≠stica", escreva: "real natural lighting from the sun, real shadows cast by real objects, real depth of field, real bokeh in the background, real camera lens flare if the sun is in frame"
            - SEMPRE mencione: "real", "actual", "photographed", "shot on location", "documentary style", "real-world", "actual photograph"
            
            T√âCNICAS DE THUMBNAIL VIRAL PARA O TEXTO (quando includePhrases = true) - DESIGN PROFISSIONAL COMO PHOTOSHOP - CTR ACIMA DE 25%:
            
            üìù DESCRI√á√ÉO OBRIGAT√ìRIA DO TEXTO - DEVE PARECER FEITO NO PHOTOSHOP POR UM DESIGNER PROFISSIONAL:
            O texto DEVE ser descrito como se fosse criado no Photoshop com t√©cnicas profissionais de design gr√°fico:
            
            1. TIPOGRAFIA PROFISSIONAL:
               - "Professional typography, Photoshop-quality text design"
               - "Large, bold, professionally designed text occupying 25-35% of the image height"
               - "Massive, oversized typography with professional letter spacing and kerning"
               - "Thick, chunky, professionally rendered letters"
               - "Typography that looks like it was designed by a professional graphic designer"
               - "High-end text design, magazine-quality typography"
            
            2. CORES PROFISSIONAIS E EFEITOS DE CAMADA (Layer Effects do Photoshop):
               - "Bright yellow (#FFD700) text with professional Photoshop layer effects: thick black stroke (6-8px), white drop shadow with distance 8px, spread 5px, size 12px, opacity 80%, angle 135 degrees"
               - "Pure white text with professional red stroke (6px), black drop shadow with blur radius 10px, and subtle outer glow effect in yellow"
               - "Neon orange (#FF6600) text with black stroke (7px), professional drop shadow with multiple layers, and yellow outer glow with spread 8px"
               - "Electric blue (#00FFFF) text with white stroke (6px), black shadow with distance 10px, and professional bevel and emboss effect"
               - "Bright red (#FF0000) text with yellow stroke (5px), white drop shadow, and professional gradient overlay from yellow to orange"
               - "Lime green (#00FF00) text with black stroke (8px), white glow effect, and professional inner shadow"
               - IMPORTANTE: Descreva como efeitos de camada do Photoshop (layer effects), n√£o apenas "outline" ou "shadow"
               
               üèÜ ESTILO √âPICO - TEXTOS EM DOURADO (Para thumbnails hist√≥ricas/√©picas):
               - Se a thumbnail original usar textos em dourado, DESCREVA EXATAMENTE assim:
               - "Large, bold, ornate serif font text in golden yellow (#FFD700) with professional Photoshop layer effects: thick black stroke (8-10px width, position outside), professional bevel and emboss effect (style: emboss, technique: smooth, depth 150%, size 8px, softness 3px, highlight mode: screen with opacity 75%, shadow mode: multiply with opacity 50%), white drop shadow (distance 12px, spread 6px, size 15px, opacity 85%, angle 135¬∞), subtle outer glow in golden yellow (spread 10px, size 20px, opacity 60%), positioned at the bottom center of the image, occupying 30-35% of the image height, professional ornate serif typography (Trajan Pro, Cinzel, or similar historical/regal font style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, looks like it was designed by a professional graphic designer for a historical epic movie poster"
               - "Golden embossed text with metallic finish, professional 3D effect, regal and majestic appearance, historical epic typography style"
            
            3. FONTES PROFISSIONAIS:
               - "Professional bold sans-serif font (Impact, Bebas Neue, Montserrat Black, or similar premium font)"
               - "Thick, chunky, professionally designed block letters"
               - "Modern, high-end typography with perfect letter spacing"
               - "YouTube viral thumbnail professional font style"
               - "Bold, condensed font with professional kerning and tracking"
               - "Premium typography, no serifs, maximum readability, professional design"
               - "Typography that looks like it came from a professional design agency"
            
            4. EFEITOS PROFISSIONAIS DO PHOTOSHOP (Layer Styles):
               - "Professional Photoshop stroke effect: thick black outline (6-8px width), position: outside, blend mode: normal, opacity: 100%"
               - "Professional drop shadow: distance 10px, spread 5px, size 12px, angle 135¬∞, opacity 80%, color black, blend mode: multiply"
               - "Professional outer glow effect: spread 8px, size 15px, opacity 75%, color matching text or contrasting"
               - "Professional bevel and emboss effect: style: emboss, technique: smooth, depth 100%, size 5px, softness 2px"
               - "Professional gradient overlay: linear gradient from bright color to darker shade, angle 90¬∞, opacity 80%"
               - "Professional inner shadow: distance 3px, choke 0%, size 5px, opacity 60%"
               - "Professional color overlay: solid color with blend mode overlay or soft light, opacity 50%"
               - "Text appears to pop out from the image with professional 3D effect"
               - "Professional text rendering with anti-aliasing, crisp edges, perfect clarity"
            
            5. COMPOSI√á√ÉO PROFISSIONAL:
               - "Positioned at the top center of the image with professional alignment"
               - "Bottom third of the image with professional composition and high contrast background"
               - "Centered horizontally, upper third vertically, following rule of thirds"
               - "Strategically placed to not cover important visual elements, professional layout"
               - "Text area has professional semi-transparent dark background (black overlay with 40% opacity) for better readability"
               - "Professional text box or banner behind text with gradient or solid color, rounded corners optional"
            
            6. CONTRASTE E VISIBILIDADE PROFISSIONAL:
               - "High contrast against the background, professionally optimized"
               - "Text stands out dramatically from the image with professional design techniques"
               - "Eye-catching text overlay that immediately draws attention, professional composition"
               - "Text that pops from the image with maximum visibility, professional rendering"
               - "Text is the first thing the eye is drawn to, professional visual hierarchy"
               - "Background is professionally darkened (vignette effect) or lightened behind text for maximum contrast"
               - "Professional color grading applied to background to make text stand out"
            
            7. EXEMPLO COMPLETO DE DESCRI√á√ÉO PROFISSIONAL:
               "Professional Photoshop-quality text design: Large, bold, stylized text '[FRASE DE GANCHO AQUI]' in bright yellow (#FFD700) with professional layer effects: thick black stroke (7px width, position outside), white drop shadow (distance 10px, spread 5px, size 12px, opacity 80%, angle 135¬∞), subtle outer glow in white (spread 6px, size 10px, opacity 70%), positioned at the top center of the image, occupying 30% of the image height, professional bold sans-serif font (Impact or Bebas Neue style), thick chunky letters with perfect kerning, professional text rendering with anti-aliasing and crisp edges, high contrast viral thumbnail text style, eye-catching and attention-grabbing, text appears to pop out from the image with professional 3D effect, maximum visibility for high CTR, looks like it was designed by a professional graphic designer in Photoshop"
            
            8. REGRAS DE OURO PARA DESIGN PROFISSIONAL:
               - O texto DEVE parecer feito no Photoshop por um designer profissional
               - O texto DEVE ter m√∫ltiplos efeitos de camada (stroke, shadow, glow, bevel)
               - O texto DEVE ter valores espec√≠ficos de efeitos (dist√¢ncia, spread, tamanho, opacidade)
               - O texto DEVE ter tipografia profissional com kerning e tracking perfeitos
               - O texto DEVE ter renderiza√ß√£o profissional (anti-aliasing, crisp edges)
               - O texto DEVE ter composi√ß√£o profissional (regra dos ter√ßos, hierarquia visual)
               - O texto DEVE parecer de qualidade de ag√™ncia de design, n√£o amador

            RESPONDA APENAS COM UM OBJETO JSON V√ÅLIDO, com a seguinte estrutura:
            {
              "ideias": [
                {
                  "seoDescription": "Descri√ß√£o completa e otimizada para o YouTube aqui...",
                  "seoTags": ["tag1", "tag2", "tag3", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Portugu√™s' ? '["Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"]' : language === 'Ingl√™s' ? '["He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"]' : '["√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'A detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'A detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                },
                {
                  "seoDescription": "Outra descri√ß√£o completa e otimizada...",
                  "seoTags": ["tagA", "tagB", "tagC", ...],
                  "frasesDeGancho": ${includePhrases ? (language === 'Portugu√™s' ? '["A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revela√ß√£o Surpreendente"]' : language === 'Ingl√™s' ? '["The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything", "Surprising Revelation"]' : '["La Verdad", "Nunca Visto", "Descubr√≠ Todo", "Esto Cambi√≥ Todo", "Revelaci√≥n Sorprendente"]') : '[]'},
                  "descricaoThumbnail": "${includePhrases ? 'Another detailed visual prompt in English with the placeholder [FRASE DE GANCHO AQUI]...' : 'Another detailed visual prompt in English WITHOUT any text or phrases, only visual elements...'}"
                }
              ]
            }
        `;
            }
        }
        
        // --- 4. Chamar a API Multimodal com fallback ---
        let apiCallFunction;
        if (useLaozhang) {
            apiCallFunction = callLaozhangAPI;
        } else {
            if (service === 'gemini') apiCallFunction = callGeminiAPI;
            else if (service === 'claude') apiCallFunction = callClaudeAPI;
            else if (service === 'openai') apiCallFunction = callOpenAIAPI;
        }
        
        console.log(`[An√°lise-Thumb] A chamar ${useLaozhang ? 'Laozhang.ai' : service} com o modelo ${model}...`);
        
        let response;
        let parsedData;
        let successfulService = useLaozhang ? 'laozhang' : service;
        
        try {
            if (useLaozhang) {
                response = await callLaozhangAPI(
                    thumbPrompt, 
                    decryptedKey, 
                    model, 
                    videoDetails.thumbnailUrl, 
                    userId, 
                    '/api/analyze/thumbnail', 
                    JSON.stringify({ endpoint: '/api/analyze/thumbnail', model })
                );
                // callLaozhangAPI retorna string diretamente
                response = typeof response === 'string' ? response.trim() : JSON.stringify(response);
                response = { titles: response };
            } else {
                // Preparar imagens adicionais (thumbnails de refer√™ncia)
                const additionalImages = thumbnailReferences.map(ref => ref.thumbnail_base64).filter(Boolean);
                
                // Chamar API apropriada com m√∫ltiplas imagens
                if (service === 'claude') {
                    response = await callClaudeAPI(thumbPrompt, decryptedKey, model, videoDetails.thumbnailUrl, null, additionalImages);
                } else if (service === 'openai') {
                    response = await callOpenAIAPI(thumbPrompt, decryptedKey, model, videoDetails.thumbnailUrl, additionalImages);
                } else if (service === 'gemini') {
                    response = await callGeminiAPI(thumbPrompt, decryptedKey, model, videoDetails.thumbnailUrl, additionalImages);
                } else {
                    response = await apiCallFunction(thumbPrompt, decryptedKey, model, videoDetails.thumbnailUrl);
                }
            }
            parsedData = parseAIResponse(response.titles, successfulService);
            
            if (!parsedData.ideias || !Array.isArray(parsedData.ideias) || parsedData.ideias.length === 0) {
                throw new Error("A IA n√£o retornou o array 'ideias' esperado.");
            }
        } catch (firstError) {
            console.warn(`[An√°lise-Thumb] Falha com ${service}:`, firstError.message);
            
            // Tentar fallback para outros modelos se o primeiro falhar
            const fallbackServices = service === 'gemini' 
                ? ['claude', 'openai'] 
                : service === 'claude' 
                    ? ['openai', 'gemini'] 
                    : ['gemini', 'claude'];
            
            let fallbackSuccess = false;
            
            for (const fallbackService of fallbackServices) {
                try {
                    console.log(`[An√°lise-Thumb] Tentando fallback com ${fallbackService}...`);
                    
                    const fallbackKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, fallbackService]);
                    if (!fallbackKeyData) {
                        console.warn(`[An√°lise-Thumb] Chave de API do ${fallbackService} n√£o configurada para fallback.`);
                        continue;
                    }
                    
                    const fallbackDecryptedKey = decrypt(fallbackKeyData.api_key);
                    if (!fallbackDecryptedKey) {
                        console.warn(`[An√°lise-Thumb] Falha ao desencriptar chave do ${fallbackService}.`);
                        continue;
                    }
                    
                    let fallbackModel = model;
                    if (fallbackService === 'claude') fallbackModel = 'claude-3-5-haiku-20241022';
                    else if (fallbackService === 'openai') fallbackModel = 'gpt-4o';
                    else if (fallbackService === 'gemini') fallbackModel = 'gemini-2.0-flash';
                    
                    let fallbackApiCallFunction;
                    if (fallbackService === 'gemini') fallbackApiCallFunction = callGeminiAPI;
                    else if (fallbackService === 'claude') fallbackApiCallFunction = callClaudeAPI;
                    else fallbackApiCallFunction = callOpenAIAPI;
                    
                    response = await fallbackApiCallFunction(thumbPrompt, fallbackDecryptedKey, fallbackModel, videoDetails.thumbnailUrl);
                    parsedData = parseAIResponse(response.titles, fallbackService);
                    
                    if (!parsedData.ideias || !Array.isArray(parsedData.ideias) || parsedData.ideias.length === 0) {
                        throw new Error("A IA n√£o retornou o array 'ideias' esperado.");
                    }
                    
                    successfulService = fallbackService;
                    fallbackSuccess = true;
                    console.log(`[An√°lise-Thumb] Sucesso com fallback ${fallbackService}!`);
                    break;
                } catch (fallbackError) {
                    console.warn(`[An√°lise-Thumb] Fallback ${fallbackService} tamb√©m falhou:`, fallbackError.message);
                    continue;
                }
            }
            
            if (!fallbackSuccess) {
                throw new Error(`Todas as IAs falharam. √öltimo erro: ${firstError.message}`);
            }
        }

        // --- 5. Validar e processar dados antes de enviar ---

        // Nota: A ambienta√ß√£o j√° foi calculada anteriormente (linhas 15168-15184) e as vari√°veis est√£o dispon√≠veis:
        // ambientacaoArr, elementosArr, acessoriosCalc, personagemCalc, ambientacaoCalc, elementosDeFundoCalc
        
        // Validar e corrigir tags (limite de 300 caracteres) e frases de gancho (idioma correto)
        if (parsedData.ideias && Array.isArray(parsedData.ideias)) {
            parsedData.ideias = parsedData.ideias.map((idea, index) => {
                // Validar tags - limitar a 300 caracteres
                if (idea.seoTags && Array.isArray(idea.seoTags)) {
                    let tagsString = idea.seoTags.join(', ');
                    if (tagsString.length > 300) {
                        // Reduzir tags at√© ficar dentro do limite
                        let reducedTags = [];
                        let currentLength = 0;
                        for (const tag of idea.seoTags) {
                            const tagWithComma = reducedTags.length > 0 ? ', ' + tag : tag;
                            if (currentLength + tagWithComma.length <= 300) {
                                reducedTags.push(tag);
                                currentLength += tagWithComma.length;
                            } else {
                                break;
                            }
                        }
                        idea.seoTags = reducedTags;
                        console.log(`[Thumbnail] Tags reduzidas de ${idea.seoTags.length + (idea.seoTags.length - reducedTags.length)} para ${reducedTags.length} para respeitar limite de 300 caracteres`);
                    }
                }
                
                // Validar frases de gancho - garantir que estejam no idioma correto
                if (idea.frasesDeGancho && Array.isArray(idea.frasesDeGancho) && includePhrases) {
                    // Verificar se as frases est√£o no idioma correto (an√°lise b√°sica)
                    const isPortuguese = language === 'Portugu√™s';
                    const isSpanish = language === 'Espanhol';
                    const isEnglish = language === 'Ingl√™s';
                    
                    // Palavras comuns em portugu√™s que n√£o aparecem em ingl√™s/espanhol
                    const portugueseWords = ['que', 'n√£o', 'voc√™', 'com', 'para', 'mais', 'muito', 'isso', 'aqui', 'agora', 'tamb√©m', 'sempre', 'depois', 'antes', 'ainda', 'ent√£o', 'assim', 'mesmo', 'todo', 'toda', 'todos', 'todas', 'ele', 'ela', 'eles', 'elas', 'nosso', 'nossa', 'seus', 'suas', 'desse', 'dessa', 'deles', 'delas'];
                    const spanishWords = ['que', 'no', 't√∫', 'con', 'para', 'm√°s', 'muy', 'esto', 'aqu√≠', 'ahora', 'tambi√©n', 'siempre', 'despu√©s', 'antes', 'a√∫n', 'entonces', 'as√≠', 'mismo', 'todo', 'toda', 'todos', 'todas', '√©l', 'ella', 'ellos', 'ellas', 'nuestro', 'nuestra', 'sus', 'de', 'del', 'de la'];
                    
                    idea.frasesDeGancho = idea.frasesDeGancho.map(frase => {
                        if (!frase || typeof frase !== 'string') return frase;
                        
                        const fraseLower = frase.toLowerCase();
                        let needsTranslation = false;
                        
                        if (isPortuguese) {
                            // Verificar se tem palavras em portugu√™s
                            const hasPortugueseWords = portugueseWords.some(word => fraseLower.includes(word));
                            // Se n√£o tem palavras portuguesas e tem palavras comuns em ingl√™s, provavelmente est√° em ingl√™s
                            if (!hasPortugueseWords && (fraseLower.includes('the ') || fraseLower.includes(' a ') || fraseLower.includes('this ') || fraseLower.includes('that '))) {
                                needsTranslation = true;
                            }
                        } else if (isSpanish) {
                            // Verificar se tem palavras em espanhol
                            const hasSpanishWords = spanishWords.some(word => fraseLower.includes(word));
                            // Se n√£o tem palavras espanholas e tem palavras comuns em ingl√™s, provavelmente est√° em ingl√™s
                            if (!hasSpanishWords && (fraseLower.includes('the ') || fraseLower.includes(' a ') || fraseLower.includes('this ') || fraseLower.includes('that '))) {
                                needsTranslation = true;
                            }
                        } else if (isEnglish) {
                            // Se tem palavras portuguesas/espanholas, provavelmente n√£o est√° em ingl√™s
                            if (portugueseWords.some(word => fraseLower.includes(word)) || spanishWords.some(word => fraseLower.includes(word))) {
                                needsTranslation = true;
                            }
                        }
                        
                        // Se precisa traduzir, retornar a frase original (a IA deve ter gerado corretamente, mas vamos apenas logar)
                        if (needsTranslation) {
                            console.warn(`[Thumbnail] Frase de gancho pode estar no idioma errado: "${frase}" (idioma esperado: ${language})`);
                        }
                        
                        return frase;
                    });
                }
                
                // Modularizar a descricaoThumbnail sem opera√ß√µes ass√≠ncronas dentro do map
                const baseTemplate = `Generate a historical cinematic thumbnail depicting {PERSONAGEM} wearing {ACESSORIOS} against {AMBIENTE}. Position the subject in the foreground taking up 60% of the frame with an epic background showing {ELEMENTOS_DE_FUNDO}. Use high contrast lighting with gold or cold tones depending on theme and a dramatic sky with storm clouds or environmental effects. The title should be in bold, imposing gold text with a subtle glow effect. The overall mood should be cinematic, realistic and historically significant with ultra-high detail.`;
                let built = baseTemplate
                    .replace('{PERSONAGEM}', personagemCalc)
                    .replace('{ACESSORIOS}', acessoriosCalc || 'authentic period accessories')
                    .replace('{AMBIENTE}', ambientacaoCalc)
                    .replace('{ELEMENTOS_DE_FUNDO}', elementosDeFundoCalc || 'contextual historical elements');
                if (includePhrases) {
                    built += `\nProfessional Photoshop-quality text design displaying [FRASE DE GANCHO AQUI], with multiple layer effects (stroke, drop shadow, outer glow, bevel and emboss), perfect kerning, anti-aliasing, large bold serif gold typography at bottom.`;
                }
                built += `\nExclude mesoamerican pyramids, feathered headdress, conquistadors, Spanish ships unless specifically relevant to the detected theme. CRITICAL - REMOVE ALL CORNER MARKINGS: Exclude any logos, watermarks, channel badges, branding marks, corner icons, decorative elements, or any visual elements in the four corners of the image (top-left, top-right, bottom-left, bottom-right). The image must be completely clean in all four corners.`;
                idea.descricaoThumbnail = built;
                
                // Calcular score viral baseado no algoritmo do YouTube
                const viralScore = calculateThumbnailViralScore(idea.descricaoThumbnail, index, parsedData.ideias.length);
                idea.viralScore = viralScore;
                
                return idea;
            });
        }

        // --- 6. Enviar resposta ---

        // N√ÉO salvar thumbnails automaticamente - apenas quando o usu√°rio gerar a imagem e salvar na biblioteca
        // As thumbnails ser√£o salvas apenas quando o usu√°rio gerar a imagem com ImageFX e clicar em "Salvar na Biblioteca"
        console.log(`[Biblioteca] ${parsedData.ideias.length} ideias de thumbnails geradas. Aguardando gera√ß√£o de imagem pelo usu√°rio para salvar na biblioteca.`);

        res.status(200).json(parsedData.ideias);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/analyze/thumbnail]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao gerar ideias de thumbnail.' });
    }
});

// === ROTA LAOZHANG PARA AN√ÅLISE DE THUMBNAIL ===
// Nota: Esta rota usa a mesma l√≥gica da rota original, mas sempre usa Laozhang API
// A implementa√ß√£o completa seguiria o mesmo padr√£o, mas simplificamos para usar callLaozhangAPI
app.post('/api/analyze/thumbnail/laozhang', authenticateToken, async (req, res) => {
    let { videoId, selectedTitle, model, selectedModel, niche, subniche, language, includePhrases, style, customPrompt, thumbnailRule, folder_id } = req.body;
    // Usar 'model' se 'selectedModel' n√£o estiver presente (compatibilidade)
    const modelToUse = model || selectedModel;
    const userId = req.user.id;

    if (!videoId || !selectedTitle || !niche || !subniche || !language || includePhrases === undefined || !style) {
        return res.status(400).json({ msg: 'Dados insuficientes para gerar ideias de thumbnail.' });
    }
    
    console.log(`[Thumbnail Laozhang] Gerando thumbnails para pasta/canal: ${folder_id || 'Nenhuma pasta selecionada'}`);
    
    // Se thumbnailRule n√£o for fornecido, usar 'auto'
    thumbnailRule = thumbnailRule || 'auto';

    try {
        // Verificar se deve usar cr√©ditos (laozhang.ai) ou API pr√≥pria
        // REGRA: Usa cr√©ditos se usu√°rio marcou prefer√™ncia OU n√£o tem plano que permite API pr√≥pria OU n√£o tem API pr√≥pria configurada
        // REGRA CR√çTICA: Se prefer√™ncia N√ÉO est√° marcada E usu√°rio tem plano que permite E tem API pr√≥pria ‚Üí usar API pr√≥pria
        
        // Determinar ordem de prefer√™ncia baseado no modelo
        let preferenceOrder = ['claude', 'openai', 'gemini'];
        if (modelToUse && modelToUse.includes('gemini')) preferenceOrder = ['gemini', 'claude', 'openai'];
        else if (modelToUse && modelToUse.includes('claude')) preferenceOrder = ['claude', 'openai', 'gemini'];
        else if (modelToUse && modelToUse.includes('gpt')) preferenceOrder = ['openai', 'claude', 'gemini'];
        
        const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
        
        let useLaozhang = false;
        let apiKeyToUse = null;
        let serviceToUse = null;
        let apiCallFunction = null;
        
        if (creditsCheck.shouldUse) {
            // Se deve usar cr√©ditos, usar laozhang.ai
            const laozhangKey = await getLaozhangApiKey();
            if (laozhangKey) {
                useLaozhang = true;
                apiKeyToUse = laozhangKey;
                serviceToUse = 'laozhang';
                apiCallFunction = callLaozhangAPI;
                console.log(`[Thumbnail] ‚úÖ Usando Laozhang.ai (${creditsCheck.reason})`);
            } else {
                console.warn('[Thumbnail] ‚ö†Ô∏è Laozhang.ai n√£o configurada, tentando usar APIs pr√≥prias do usu√°rio');
            }
        } else {
            console.log(`[Thumbnail] ‚úÖ Usando API pr√≥pria (${creditsCheck.reason})`);
        }
        
        // Se n√£o usar laozhang.ai, usar APIs pr√≥prias do usu√°rio
        if (!useLaozhang) {
            // Determinar servi√ßo baseado no modelo
            if (modelToUse && modelToUse.includes('gemini')) serviceToUse = 'gemini';
            else if (modelToUse && modelToUse.includes('claude')) serviceToUse = 'claude';
            else if (modelToUse && modelToUse.includes('gpt')) serviceToUse = 'openai';
            else serviceToUse = 'gemini'; // fallback
            
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, serviceToUse]);
            if (!keyData) return res.status(400).json({ msg: `Chave de API do ${serviceToUse} n√£o configurada.` });
            
            apiKeyToUse = decrypt(keyData.api_key);
            if (!apiKeyToUse) return res.status(500).json({ msg: 'Falha ao descriptografar a sua chave de API.' });
            
            if (serviceToUse === 'gemini') apiCallFunction = callGeminiAPI;
            else if (serviceToUse === 'claude') apiCallFunction = callClaudeAPI;
            else apiCallFunction = callOpenAIAPI;
        }

        if (useLaozhang) {
            // Mapear para modelo Laozhang
            if (modelToUse === 'gpt-4o' || modelToUse === 'GPT-4o (2025)') {
                modelForAPI = 'gpt-4o';
            } else if (modelToUse === 'claude-3-7-sonnet-20250219' || modelToUse === 'Claude 3.7 Sonnet (Fev/25)') {
                modelForAPI = 'claude-3-7-sonnet-20250219';
            } else if (modelToUse === 'gemini-2.5-pro' || modelToUse === 'Gemini 2.5 Pro (2025)') {
                modelForAPI = 'gemini-2.5-pro';
            } else if (modelToUse && modelToUse.includes('claude')) {
                modelForAPI = 'claude-3-7-sonnet-20250219';
            } else if (modelToUse && modelToUse.includes('gemini')) {
                modelForAPI = 'gemini-2.5-pro';
            } else if (modelToUse && modelToUse.includes('gpt')) {
                modelForAPI = 'gpt-4o';
            } else {
                console.warn(`[Thumbnail] ‚ö†Ô∏è Modelo n√£o reconhecido: "${modelToUse}", usando 'gpt-4o' como fallback`);
                modelForAPI = 'gpt-4o';
            }
        } else {
            // Usar modelo original para API pr√≥pria
            modelForAPI = modelToUse;
        }
        console.log(`[Thumbnail] Modelo recebido: "${modelToUse}" -> Mapeado para API: "${modelForAPI}" (${useLaozhang ? 'Laozhang' : serviceToUse})`);

        // Buscar chave do YouTube primeiro (prioridade)
        let videoDetails = null;
        let youtubeApiKey = null;
        
        try {
            const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
            if (youtubeKeyData && youtubeKeyData.api_key) {
                // Tentar descriptografar se estiver criptografada
                if (youtubeKeyData.api_key.includes(':')) {
                    try {
                        youtubeApiKey = decrypt(youtubeKeyData.api_key);
                    } catch (decryptErr) {
                        console.warn('[Thumbnail Laozhang] Erro ao descriptografar chave do YouTube, tentando usar diretamente:', decryptErr.message);
                        youtubeApiKey = youtubeKeyData.api_key;
                    }
                } else {
                    youtubeApiKey = youtubeKeyData.api_key;
                }
                
                if (youtubeApiKey) {
                    console.log('[Thumbnail Laozhang] Tentando usar chave do YouTube...');
                    try {
                        videoDetails = await callYouTubeDataAPI(videoId, youtubeApiKey);
                        console.log('[Thumbnail Laozhang] ‚úÖ Sucesso com chave do YouTube');
                    } catch (youtubeErr) {
                        console.warn('[Thumbnail Laozhang] Erro ao usar chave do YouTube:', youtubeErr.message);
                        videoDetails = null;
                    }
                }
            }
        } catch (err) {
            console.warn('[Thumbnail Laozhang] Erro ao buscar chave do YouTube:', err.message);
        }
        
        // Se n√£o funcionou com YouTube, tentar Gemini como fallback
        if (!videoDetails) {
            try {
                const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
                if (geminiKeyData && geminiKeyData.api_key) {
                    let geminiApiKey = null;
                    if (geminiKeyData.api_key.includes(':')) {
                        try {
                            geminiApiKey = decrypt(geminiKeyData.api_key);
                        } catch (decryptErr) {
                            console.warn('[Thumbnail Laozhang] Erro ao descriptografar chave do Gemini, tentando usar diretamente:', decryptErr.message);
                            geminiApiKey = geminiKeyData.api_key;
                        }
                    } else {
                        geminiApiKey = geminiKeyData.api_key;
                    }
                    
                    if (geminiApiKey) {
                        console.log('[Thumbnail Laozhang] Tentando usar chave do Gemini como fallback...');
                        try {
                            videoDetails = await callYouTubeDataAPI(videoId, geminiApiKey);
                            console.log('[Thumbnail Laozhang] ‚úÖ Sucesso com chave do Gemini');
                        } catch (geminiErr) {
                            console.warn('[Thumbnail Laozhang] Erro ao usar chave do Gemini:', geminiErr.message);
                        }
                    }
                }
            } catch (err) {
                console.warn('[Thumbnail Laozhang] Erro ao buscar chave do Gemini:', err.message);
            }
        }

        if (!videoDetails) {
            return res.status(400).json({ 
                msg: 'N√£o foi poss√≠vel buscar dados do v√≠deo. Verifique se a chave do YouTube Data API v3 est√° configurada corretamente nas Configura√ß√µes. A chave do Gemini pode n√£o funcionar para a API do YouTube.' 
            });
        }

        // Usar o mesmo prompt da rota original com todas as melhorias
        // Buscar an√°lise original para pegar a f√≥rmula do t√≠tulo
        let formulaTitulo = null;
        let motivoSucesso = null;
        try {
            const originalAnalysis = await db.get(
                'SELECT analysis_data_json FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                [videoId, userId]
            );
            if (originalAnalysis && originalAnalysis.analysis_data_json) {
                const analysisData = JSON.parse(originalAnalysis.analysis_data_json);
                if (analysisData.formulaTitulo) {
                    formulaTitulo = analysisData.formulaTitulo;
                }
                if (analysisData.motivoSucesso) {
                    motivoSucesso = analysisData.motivoSucesso;
                }
            }
        } catch (err) {
            console.warn(`[An√°lise-Thumb Laozhang] N√£o foi poss√≠vel buscar an√°lise original: ${err.message}`);
        }
        
        // --- Buscar thumbnails de refer√™ncia do canal/nicho ---
        let thumbnailReferences = [];
        try {
            // PRIORIDADE 1: Buscar thumbnails de refer√™ncia da PASTA/CANAL espec√≠fica primeiro
            if (folder_id) {
                const folderRefs = await db.all(
                    'SELECT id, thumbnail_base64, channel_name, niche, subniche, description, folder_id FROM thumbnail_references WHERE user_id = ? AND folder_id = ? ORDER BY created_at DESC LIMIT 5',
                    [userId, folder_id]
                );
                
                if (folderRefs && folderRefs.length > 0) {
                    thumbnailReferences = folderRefs;
                    console.log(`[Thumbnail Laozhang] ‚úÖ Encontradas ${thumbnailReferences.length} thumbnail(s) de refer√™ncia para o CANAL/PASTA ID ${folder_id} (prioridade m√°xima)`);
                }
            }
            
            // PRIORIDADE 2: Se n√£o houver thumbnails da pasta, buscar por nicho/subnicho
            if (thumbnailReferences.length === 0) {
                let refQuery = 'SELECT id, thumbnail_base64, channel_name, niche, subniche, description, folder_id FROM thumbnail_references WHERE user_id = ?';
                const refParams = [userId];
                
                // Buscar por subniche, niche ou sem filtro espec√≠fico (para pegar thumbnails gerais tamb√©m)
                if (subniche || niche) {
                    refQuery += ' AND (';
                    const conditions = [];
                    if (subniche) {
                        conditions.push('subniche = ?');
                        refParams.push(subniche);
                    }
                    if (niche) {
                        conditions.push('niche = ?');
                        refParams.push(niche);
                    }
                    // Tamb√©m incluir thumbnails sem filtro espec√≠fico (NULL)
                    conditions.push('(subniche IS NULL AND niche IS NULL)');
                    refQuery += conditions.join(' OR ') + ')';
                }
                
                // Excluir thumbnails que j√° t√™m uma pasta espec√≠fica (pois s√£o de outros canais)
                refQuery += ' AND folder_id IS NULL';
                refQuery += ' ORDER BY created_at DESC LIMIT 5'; // Limitar a 5 thumbnails de refer√™ncia
                
                const refs = await db.all(refQuery, refParams);
                thumbnailReferences = refs || [];
                
                if (thumbnailReferences.length > 0) {
                    console.log(`[Thumbnail Laozhang] ‚úÖ Encontradas ${thumbnailReferences.length} thumbnail(s) de refer√™ncia para o nicho/subnicho (fallback)`);
                } else {
                    console.log(`[Thumbnail Laozhang] ‚ö†Ô∏è Nenhuma thumbnail de refer√™ncia encontrada para esta pasta ou nicho/subnicho`);
                }
            }
        } catch (err) {
            console.warn(`[Thumbnail Laozhang] Erro ao buscar thumbnails de refer√™ncia: ${err.message}`);
        }
        
        const formulaContext = formulaTitulo ? `\n            F√ìRMULA DO T√çTULO VIRAL IDENTIFICADA: "${formulaTitulo}"\n            MOTIVO DO SUCESSO: "${motivoSucesso || 'An√°lise n√£o dispon√≠vel'}"\n            \n            IMPORTANTE: Use esta f√≥rmula como base para criar thumbnails que complementem e reforcem o mesmo gatilho mental e estrat√©gia que tornaram o t√≠tulo viral.` : '';
        
        // Pr√©-calcular ambienta√ß√£o din√¢mica pelo t√≠tulo (ou tema manual) ANTES de construir o prompt
        const themeKeyManual = req.body.theme_key || null;
        let dbMatchLocal = null;
        if (themeKeyManual) {
            await ensureAmbientationsTable();
            dbMatchLocal = await db.get('SELECT * FROM niche_ambientations WHERE user_id = ? AND theme_key = ? LIMIT 1', [userId, themeKeyManual]);
        }
        if (!dbMatchLocal) {
            dbMatchLocal = await detectAmbientationFromTitle(userId, selectedTitle, niche);
        }
        const ambientacaoArr = dbMatchLocal ? String(dbMatchLocal.ambiente || '').split(',').map(s => s.trim()).filter(Boolean) : [];
        const elementosArr = dbMatchLocal ? String(dbMatchLocal.elementos || '').split(',').map(s => s.trim()).filter(Boolean) : [];
        const acessoriosCalc = dbMatchLocal ? String(dbMatchLocal.acessorios || '') : '';
        const personagemCalc = dbMatchLocal && dbMatchLocal.subject ? dbMatchLocal.subject : 'historical figure with authentic attire';
        const ambientacaoCalc = ambientacaoArr.length ? ambientacaoArr.join(', ') : 'landscapes and architecture matching the title theme';
        const elementosDeFundoCalc = elementosArr.length ? elementosArr.join(', ') : 'contextual historical elements';
        
        // --- Adaptar prompt padr√£o ao t√≠tulo espec√≠fico ---
        let adaptedCustomPrompt = customPrompt;
        if (customPrompt && customPrompt.trim()) {
            try {
                console.log('[Thumbnail Laozhang] Adaptando prompt padr√£o ao t√≠tulo espec√≠fico...');
                
                // Criar prompt para a IA adaptar o prompt padr√£o ao t√≠tulo
                const adaptationPrompt = `Voc√™ √© um especialista em adapta√ß√£o de prompts visuais para thumbnails do YouTube.

TAREFA: Adapte o prompt padr√£o abaixo para o t√≠tulo espec√≠fico do v√≠deo, mantendo EXATAMENTE a estrutura visual e estilo do prompt padr√£o, mas ajustando o conte√∫do/tema/ambienta√ß√£o para o t√≠tulo fornecido.

PROMPT PADR√ÉO (ESTRUTURA E ESTILO A MANTER):
"""
${customPrompt}
"""

T√çTULO DO V√çDEO:
"${selectedTitle}"

NICHO/SUBNICHO:
${niche} / ${subniche}

INSTRU√á√ïES:
1. Analise o prompt padr√£o e identifique:
   - Estrutura de composi√ß√£o (layout, posicionamento de elementos)
   - Estilo visual (paleta de cores, tipografia, ilumina√ß√£o)
   - Elementos t√©cnicos (resolu√ß√£o, efeitos, tratamento)
   - Padr√µes de texto/frases

2. Adapte o prompt para o t√≠tulo "${selectedTitle}":
   - MANTENHA: toda a estrutura visual, estilo, composi√ß√£o, paleta de cores, tipografia
   - AJUSTE: personagem/sujeito, ambienta√ß√£o, cen√°rio, elementos de fundo para corresponder ao tema do t√≠tulo
   - SUBSTITUA: refer√™ncias gen√©ricas por elementos espec√≠ficos do t√≠tulo
   - PRESERVE: todos os elementos t√©cnicos e de qualidade (resolu√ß√£o, efeitos, etc.)

3. O prompt adaptado deve:
   - Seguir EXATAMENTE o mesmo formato e estrutura do prompt padr√£o
   - Manter o mesmo estilo visual e composi√ß√£o
   - Aplicar o tema/contexto do t√≠tulo "${selectedTitle}"
   - Ser espec√≠fico e detalhado como o prompt padr√£o

4. Retorne APENAS o prompt adaptado, sem explica√ß√µes ou coment√°rios adicionais.

PROMPT ADAPTADO:`;

                // Chamar IA para adaptar o prompt
                let adaptedResponse;
                if (useLaozhang) {
                    adaptedResponse = await apiCallFunction(
                        adaptationPrompt,
                        apiKeyToUse,
                        'gpt-4o',
                        null,
                        userId,
                        '/api/analyze/thumbnail/laozhang',
                        JSON.stringify({ endpoint: '/api/analyze/thumbnail/laozhang', operation: 'adapt-prompt' })
                    );
                } else if (serviceToUse === 'openai') {
                    adaptedResponse = await apiCallFunction(adaptationPrompt, apiKeyToUse, modelForAPI);
                    adaptedResponse = adaptedResponse.titles || adaptedResponse;
                } else if (serviceToUse === 'claude') {
                    adaptedResponse = await apiCallFunction(adaptationPrompt, apiKeyToUse, modelForAPI);
                    adaptedResponse = adaptedResponse.titles || adaptedResponse;
                } else if (serviceToUse === 'gemini') {
                    adaptedResponse = await apiCallFunction(adaptationPrompt, apiKeyToUse, modelForAPI);
                    adaptedResponse = adaptedResponse.titles || adaptedResponse;
                }
                
                if (adaptedResponse && typeof adaptedResponse === 'string' && adaptedResponse.trim().length > 100) {
                    adaptedCustomPrompt = adaptedResponse.trim();
                    console.log('[Thumbnail Laozhang] ‚úÖ Prompt padr√£o adaptado com sucesso ao t√≠tulo');
                    console.log('[Thumbnail Laozhang] Prompt adaptado (preview):', adaptedCustomPrompt.substring(0, 300) + '...');
                } else {
                    console.warn('[Thumbnail Laozhang] ‚ö†Ô∏è Falha ao adaptar prompt, usando prompt padr√£o original');
                }
            } catch (adaptErr) {
                console.warn('[Thumbnail Laozhang] Erro ao adaptar prompt padr√£o:', adaptErr.message);
                console.warn('[Thumbnail Laozhang] Continuando com prompt padr√£o original');
            }
        }
        
        // Se customPrompt foi fornecido (prompt padr√£o do estilo), integr√°-lo ao prompt do sistema
        // em vez de substitu√≠-lo completamente, para manter a estrutura JSON necess√°ria
        const hasStandardPrompt = adaptedCustomPrompt && adaptedCustomPrompt.trim();
        console.log(`[Thumbnail Laozhang] customPrompt adaptado recebido: ${hasStandardPrompt ? 'SIM (' + adaptedCustomPrompt.length + ' caracteres, usado APENAS como estilo visual)' : 'N√ÉO'}`);
        if (hasStandardPrompt) {
            console.log(`[Thumbnail Laozhang] Estilo visual bloqueado a partir do prompt adaptado (preview 200 chars): ${adaptedCustomPrompt.substring(0, 200)}...`);
        }
        
        const thumbPrompt = `
Voc√™ √© um ESPECIALISTA EM THUMBNAILS VIRAIS NO YOUTUBE, combinando as habilidades de um diretor de arte profissional e um estrategista de viraliza√ß√£o com experi√™ncia em criar thumbnails que gerem MILH√ïES DE VIEWS e ALTO CTR (acima de 25%).${formulaContext}

${hasStandardPrompt ? `\nüé®üé®üé® PROMPT ADAPTADO DO ESTILO DO CANAL/NICHO PARA O T√çTULO "${selectedTitle}" üé®üé®üé®:\n${adaptedCustomPrompt}\n\nüåçüåçüåç AMBIENTA√á√ÉO DETECTADA PELO T√çTULO "${selectedTitle}" (APLICAR AO CONTE√öDO) üåçüåçüåç:\n${dbMatchLocal ? `\n- PERSONAGEM/SUJEITO: ${personagemCalc}\n- AMBIENTA√á√ÉO/CEN√ÅRIO: ${ambientacaoCalc}\n- ELEMENTOS DE FUNDO: ${elementosDeFundoCalc}\n${acessoriosCalc ? `- ACESS√ìRIOS: ${acessoriosCalc}` : ''}\n\n‚ö†Ô∏è CR√çTICO: Use esta ambienta√ß√£o detectada pelo t√≠tulo para definir o CONTE√öDO da thumbnail, mantendo o ESTILO VISUAL do prompt padr√£o acima.\n` : `\n- A ambienta√ß√£o ser√° detectada automaticamente pelo t√≠tulo "${selectedTitle}".\n- Use elementos visuais relacionados ao tema do t√≠tulo, mantendo o estilo visual do prompt padr√£o.\n`}\n\n‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - O PROMPT PADR√ÉO √â APENAS ESTILO VISUAL - APLICAR AO T√çTULO "${selectedTitle}" ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è:\n- O PROMPT PADR√ÉO acima define APENAS o ESTILO VISUAL (composi√ß√£o, cores, tipografia, elementos, ilumina√ß√£o, atmosfera).\n- O CONTE√öDO das thumbnails deve ser SOBRE O T√çTULO "${selectedTitle}" que o usu√°rio escolheu.\n- Use a AMBIENTA√á√ÉO DETECTADA acima para definir o conte√∫do (personagem, cen√°rio, elementos).\n- N√ÉO use o conte√∫do do prompt padr√£o. Use APENAS o estilo visual dele.\n- N√ÉO crie um prompt novo. APLIQUE o estilo do prompt padr√£o ao t√≠tulo "${selectedTitle}" usando a ambienta√ß√£o detectada.\n\nPROCESSO OBRIGAT√ìRIO:\n1. EXTRAIA do prompt padr√£o APENAS os elementos de ESTILO VISUAL:\n   - Tipo de composi√ß√£o (ex: "close-up dram√°tico", "composi√ß√£o dividida", "cena √©pica")\n   - Paleta de cores (ex: "dourado e azul escuro", "tons terrosos", "vermelho e preto")\n   - Estilo de tipografia (ex: "textos dourados serifados com bevel/emboss", "fonte bold com outline preto")\n   - Ilumina√ß√£o e atmosfera (ex: "ilumina√ß√£o dram√°tica", "c√©u tempestuoso", "chiaroscuro", "luz dourada")\n   - Estilo geral (ex: "cinematogr√°fico", "documental", "√©pico", "realista")\n\n2. USE a AMBIENTA√á√ÉO DETECTADA para definir o CONTE√öDO:\n   - Personagem/Sujeito: ${personagemCalc}\n   - Cen√°rio/Ambienta√ß√£o: ${ambientacaoCalc}\n   - Elementos de fundo: ${elementosDeFundoCalc}\n   ${acessoriosCalc ? `- Acess√≥rios: ${acessoriosCalc}` : ''}\n\n3. APLIQUE o estilo extra√≠do + a ambienta√ß√£o detectada ao criar thumbnails sobre "${selectedTitle}":\n   - Use a mesma composi√ß√£o do prompt padr√£o (ex: se o estilo √© "close-up", fa√ßa close-up do ${personagemCalc})\n   - Use a mesma paleta de cores do prompt padr√£o\n   - Use o mesmo estilo de tipografia do prompt padr√£o\n   - Use a AMBIENTA√á√ÉO DETECTADA (${ambientacaoCalc}) como cen√°rio\n   - Use os ELEMENTOS DE FUNDO DETECTADOS (${elementosDeFundoCalc})\n   - Use a mesma ilumina√ß√£o e atmosfera do prompt padr√£o\n   - Mantenha o estilo geral do prompt padr√£o\n\n4. RESULTADO: Thumbnails sobre "${selectedTitle}" com o ESTILO VISUAL do prompt padr√£o + CONTE√öDO baseado na ambienta√ß√£o detectada pelo t√≠tulo.\n\nEXEMPLO:\n- Prompt padr√£o: "close-up dram√°tico com textos dourados serifados, ilumina√ß√£o dram√°tica"\n- T√≠tulo: "${selectedTitle}" (ex: sobre neandertais)\n- Ambienta√ß√£o detectada: ${personagemCalc}, ${ambientacaoCalc}, ${elementosDeFundoCalc}\n- RESULTADO: "close-up dram√°tico de ${personagemCalc} em ${ambientacaoCalc} com textos dourados serifados, ilumina√ß√£o dram√°tica"\n\n‚ö†Ô∏è N√ÉO REPLIQUE O CONTE√öDO DO PROMPT PADR√ÉO. USE A AMBIENTA√á√ÉO DETECTADA PELO T√çTULO.\n` : ''}

IMAGEM DE REFER√äNCIA: [A imagem da thumbnail original do v√≠deo est√° anexada]
${thumbnailReferences.length > 0 ? `
üé® THUMBNAILS DE REFER√äNCIA DO CANAL/NICHO (IMPORTANTE - ESTILO DO CANAL):
${thumbnailReferences.map((ref, idx) => `[IMAGEM ${idx + 1} DE REFER√äNCIA DO CANAL: A thumbnail de refer√™ncia ${idx + 1} do canal est√° anexada${ref.description ? ` (Descri√ß√£o: ${ref.description})` : ''}]`).join('\n')}

‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - USE AS THUMBNAILS DE REFER√äNCIA DO CANAL COMO ESTILO PRINCIPAL ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è:
- Analise cuidadosamente TODAS as ${thumbnailReferences.length} thumbnail(s) de refer√™ncia do canal que est√£o anexadas acima.
- Estas thumbnails representam o ESTILO VISUAL OFICIAL do canal/nicho "${subniche}".
- A IDEIA 1 DEVE replicar fielmente o estilo visual dessas thumbnails de refer√™ncia do canal (composi√ß√£o, cores, tipografia, elementos visuais, posicionamento de texto, etc.).
- Identifique os elementos comuns entre as thumbnails de refer√™ncia: tipo de composi√ß√£o, paleta de cores, estilo de texto, posicionamento de elementos, ilumina√ß√£o, etc.
- Replique EXATAMENTE esse estilo visual na IDEIA 1, mantendo a identidade visual do canal.
- A IDEIA 2 pode ser mais criativa, mas ainda deve respeitar a identidade visual do canal baseada nas thumbnails de refer√™ncia.
- Se as thumbnails de refer√™ncia do canal usarem textos em dourado, composi√ß√£o dividida, close-up dram√°tico ou outros elementos espec√≠ficos, REPLIQUE-OS FIELMENTE na IDEIA 1.
` : ''}
T√çTULO DO V√çDEO: "${selectedTitle}"
SUBNICHO: "${subniche}"
ESTILO DE ARTE: "${style}"
IDIOMA: "${language}"

‚ö†Ô∏è ATEN√á√ÉO CR√çTICA: As thumbnails DEVEM parecer FOTOGRAFIAS REAIS, n√£o ilustra√ß√µes, desenhos ou renderiza√ß√µes. A descri√ß√£oThumbnail deve descrever uma FOTO REAL tirada por um fot√≥grafo profissional em um local real, com pessoas reais e objetos reais.

${(() => {
    const ruleData = getThumbnailViralRules(thumbnailRule || 'auto', selectedTitle);
    if (ruleData.mode === 'auto') {
        return `\nüîç MODO AUTOM√ÅTICO - AN√ÅLISE DE REGRA:\nAnalise o t√≠tulo "${selectedTitle}" e identifique qual das 12 regras de thumbnail viral abaixo melhor se encaixa. Aplique a regra identificada de forma RIGOROSA e EXPL√çCITA na descri√ß√£o da thumbnail.\n\nüìã AS 12 REGRAS DE THUMBNAIL VIRAL DO YOUTUBE:\n\n1Ô∏è‚É£ REGRA DA CLAREZA IMEDIATA (1 SEGUNDO): Checklist: 1 ideia principal, 1 personagem, 1 emo√ß√£o, 1 objeto-chave.\n\n2Ô∏è‚É£ REGRA DO ASSUNTO √öNICO: Nada divide a aten√ß√£o. Foque em UM √öNICO assunto dominante.\n\n3Ô∏è‚É£ REGRA DO ROSTO GRANDE: Rostos com forte express√£o emocional aumentam CTR de 20% a 60%. Express√µes: choque, surpresa, medo, raiva, felicidade extrema.\n\n4Ô∏è‚É£ REGRA DO CONTRASTE BRUTAL: Use contraste entre texto vs fundo, personagem vs fundo, cores complementares (azul/laranja, amarelo/roxo).\n\n5Ô∏è‚É£ REGRA DA COR ESTRAT√âGICA: Amarelo (aten√ß√£o), Vermelho (urg√™ncia), Azul (confian√ßa), Verde (dinheiro), Preto (premium/mist√©rio).\n\n6Ô∏è‚É£ REGRA DOS TER√áOS: Posicione o assunto nos cruzamentos dos "9 quadrantes".\n\n7Ô∏è‚É£ REGRA DO TEXTO ULTRA CURTO: Texto deve ter 2 a 4 palavras. Exemplos: "Ele mentiu", "Descobri isso", "Ningu√©m viu".\n\n8Ô∏è‚É£ REGRA DO ZOOM EMOCIONAL: Use um elemento GIGANTE que amplifique a emo√ß√£o (conta banc√°ria gigante, faca gigante, lupa gigante, n√∫mero gigante).\n\n9Ô∏è‚É£ REGRA DO MIST√âRIO: Crie uma pergunta impl√≠cita (algo escondido atr√°s de blur, objeto cortado pela metade, pessoa olhando para fora do quadro).\n\nüîü REGRA DOS PONTOS DE FUGA: Use linhas visuais (setas, linhas diagonais, perspectiva) que guiem o olhar para o foco.\n\n1Ô∏è‚É£1Ô∏è‚É£ REGRA DO ESPA√áO NEGATIVO: Deixe √°reas vazias que acentuem o foco no elemento principal.\n\n1Ô∏è‚É£2Ô∏è‚É£ REGRA DA COER√äNCIA COM O T√çTULO: T√≠tulo = contexto, Thumbnail = emo√ß√£o. Devem contar a mesma hist√≥ria com √¢ngulos diferentes.\n\n‚ö†Ô∏è CR√çTICO: Identifique qual regra melhor se encaixa e aplique-a de forma EXPL√çCITA na descri√ß√£o da thumbnail.`;
    } else {
        return `\nüìã REGRA SELECIONADA: ${ruleData.rule.name}\n${ruleData.rule.description}\n\n‚ö†Ô∏è CR√çTICO: Aplique esta regra de forma EXPL√çCITA e RIGOROSA:\n${ruleData.instructions}`;
    }
})()}

üéØ OBJETIVO: Criar thumbnails otimizadas para CTR acima de 25% usando t√©cnicas profissionais e as regras acima.

SUA TAREFA:
Crie DUAS (2) ideias distintas para thumbnail:

‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - ORDEM DAS IDEIAS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
${hasStandardPrompt ? `
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ATEN√á√ÉO CR√çTICA: PROMPT PADR√ÉO EST√Å ATIVO - USAR APENAS O ESTILO VISUAL ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
- O PROMPT PADR√ÉO acima √© APENAS ESTILO VISUAL (como criar), N√ÉO √© o conte√∫do (o que criar).
- O CONTE√öDO das thumbnails DEVE ser sobre o t√≠tulo "${selectedTitle}" que o usu√°rio escolheu.
- Ambas as IDEIAS devem APLICAR o estilo visual do prompt padr√£o ao t√≠tulo "${selectedTitle}".
- N√ÉO use o conte√∫do/tema do prompt padr√£o. Use APENAS os elementos de estilo (composi√ß√£o, cores, tipografia, ilumina√ß√£o, atmosfera).
- EXTRAIA o estilo do prompt padr√£o e APLIQUE ao tema de "${selectedTitle}".

` : ''}
- **IDEIA 1 (R√âPLICA E MELHORIA DA THUMBNAIL ORIGINAL DO V√çDEO):** 
  * OBRIGAT√ìRIO: Esta ideia DEVE replicar e melhorar a thumbnail ORIGINAL do v√≠deo ao qual foram feitos os t√≠tulos.
  ${hasStandardPrompt ? `* APLIQUE O ESTILO DO PROMPT PADR√ÉO: Use os elementos de estilo do prompt padr√£o (composi√ß√£o, cores, tipografia, ilumina√ß√£o) mantendo o conte√∫do relacionado ao t√≠tulo "${selectedTitle}".\n` : ''}
  * Analise cuidadosamente a IMAGEM DE REFER√äNCIA (thumbnail original do v√≠deo) que est√° anexada.
  ${hasStandardPrompt ? `* INTEGRE O ESTILO DO PROMPT PADR√ÉO: Mantenha a estrutura da thumbnail original, mas aplique os elementos de estilo do prompt padr√£o (cores, tipografia, ilumina√ß√£o, atmosfera) ao t√≠tulo "${selectedTitle}".\n` : ''}
  * Replique a estrutura da thumbnail de refer√™ncia quase 1:1: mantenha EXATAMENTE a mesma composi√ß√£o, √¢ngulo de c√¢mera, enquadramento, posi√ß√£o dos personagens/objetos, paleta de cores, quantidade de texto, posi√ß√£o do texto, elementos visuais principais e storytelling.
  * PRESERVE o poder viral da thumbnail original que gerou milh√µes de views.
  * Apenas ELEVE A QUALIDADE: mais nitidez (8K), contraste refor√ßado, ilumina√ß√£o cinematogr√°fica profissional, corre√ß√µes de cor profissionais, tratamento de pele profissional, brilho nos olhos, textura realista, limpeza de ru√≠dos, adicione luzes/sombras profissionais, aplique efeitos de texto Photoshop com valores espec√≠ficos.
  * N√ÉO altere o storytelling principal, apenas entregue a vers√£o definitiva com acabamento premium.
  * Resultado: praticamente igual √† thumbnail original, mas com sensa√ß√£o de upgrade premium e leitura instant√¢nea mais clara e clic√°vel.

- **IDEIA 2 (THUMBNAIL MELHORADA E OTIMIZADA):** 
  * Esta √© uma vers√£o COMPLETAMENTE NOVA, melhorada e otimizada para CTR alto (30%+).
  ${hasStandardPrompt ? `* APLIQUE O ESTILO DO PROMPT PADR√ÉO: Crie uma thumbnail NOVA sobre o t√≠tulo "${selectedTitle}" usando os elementos de estilo do prompt padr√£o (composi√ß√£o, cores, tipografia, ilumina√ß√£o, atmosfera).\n` : ''}
  * Crie um conceito totalmente novo com foco em CTR m√°ximo: novo enquadramento, nova composi√ß√£o, novos elementos que gerem curiosidade extrema.
  * Use gatilhos agressivos (perigo, segredo revelado, n√∫meros gigantes, setas, antes/depois, close dram√°tico) e cores super contrastantes.
  ${hasStandardPrompt ? `* MANTENHA O ESTILO DO CANAL: Use os elementos visuais do prompt padr√£o (ex: textos dourados, close-up dram√°tico, composi√ß√£o dividida, etc.) mas adaptados ao t√≠tulo "${selectedTitle}".\n` : ''}
  * Construa um storytelling diferente, alinhado ao t√≠tulo "${selectedTitle}", que prometa algo ainda mais irresist√≠vel que a vers√£o original.
  * O texto deve ser redesenhado para m√°xima legibilidade mobile, com layer styles profissionais e valores precisos.
  * Esta vers√£o deve ser AINDA MELHOR que a original, com t√©cnicas avan√ßadas de viraliza√ß√£o.

PARA CADA UMA DAS 2 IDEIAS, GERE:
1. **"seoDescription"**: Descri√ß√£o EXTREMAMENTE OTIMIZADA para SEO e viraliza√ß√£o (300-500 palavras), com emojis estrat√©gicos, par√°grafos estruturados, CTAs claras, palavras-chave relevantes, formata√ß√£o profissional com separadores visuais, se√ß√µes organizadas (introdu√ß√£o, conte√∫do, sobre canal, links, hashtags), linguagem persuasiva que gere curiosidade e urg√™ncia, no idioma "${language}".

2. **"seoTags"**: Array com 15-25 tags MAIS RELEVANTES (LIMITE M√ÅXIMO: 300 caracteres no total, incluindo v√≠rgulas e espa√ßos. N√ÉO ultrapasse 300 caracteres), incluindo: tags de cauda curta (1-2 palavras), tags de cauda longa (3-5 palavras), tags de nicho, tags de tend√™ncia, tags de formato, tags de emo√ß√£o, tags de benef√≠cio, tags de palavra-chave principal, tags de sin√¥nimos. Todas RELEVANTES ao t√≠tulo "${selectedTitle}" e subnicho "${subniche}", no idioma "${language}". Priorize tags mais relevantes e estrat√©gicas. Se necess√°rio, reduza a quantidade de tags para n√£o ultrapassar 300 caracteres.

3. **"frasesDeGancho"**: Array com 5 frases CURTAS de impacto (2-4 palavras cada), OBRIGATORIAMENTE no idioma "${language}". ${!includePhrases ? 'IMPORTANTE: Retorne array vazio [].' : `
                ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO E OBRIGAT√ìRIO - IDIOMA DAS FRASES DE GANCHO ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
                
                As frases de gancho DEVEM estar EXATAMENTE no idioma "${language}".
                
                ${language === 'Portugu√™s' ? `
                ‚úÖ CORRETO (Portugu√™s): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante", "A Verdade", "Nunca Visto", "Descobri Tudo", "Isso Mudou Tudo", "Revela√ß√£o Surpreendente"
                ‚ùå ERRADO (Ingl√™s - N√ÉO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ‚ùå ERRADO (Espanhol - N√ÉO USAR): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"
                ` : language === 'Ingl√™s' ? `
                ‚úÖ CORRETO (Ingl√™s): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation", "The Truth", "Never Seen", "I Discovered Everything", "This Changed Everything"
                ‚ùå ERRADO (Portugu√™s - N√ÉO USAR): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"
                ‚ùå ERRADO (Espanhol - N√ÉO USAR): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante"
                ` : `
                ‚úÖ CORRETO (Espanhol): "√âl Minti√≥", "Descubr√≠ Esto", "Nadie Vio", "Prohibido", "Revelaci√≥n Impactante", "La Verdad", "Nunca Visto", "Descubr√≠ Todo", "Esto Cambi√≥ Todo", "Revelaci√≥n Sorprendente"
                ‚ùå ERRADO (Portugu√™s - N√ÉO USAR): "Ele Mentiu", "Descobri Isso", "Ningu√©m Viu", "Proibido", "Revela√ß√£o Chocante"
                ‚ùå ERRADO (Ingl√™s - N√ÉO USAR): "He Lied", "I Discovered This", "Nobody Saw", "Forbidden", "Shocking Revelation"
                `}
                
                REGRAS OBRIGAT√ìRIAS:
                1. Se "${language}" for "Portugu√™s", TODAS as 5 frases DEVEM estar em PORTUGU√äS (Brasil)
                2. Se "${language}" for "Ingl√™s", TODAS as 5 frases DEVEM estar em INGL√äS
                3. Se "${language}" for "Espanhol", TODAS as 5 frases DEVEM estar em ESPANHOL
                4. NUNCA, JAMAIS retorne frases em ingl√™s se o idioma escolhido for portugu√™s ou espanhol
                5. NUNCA, JAMAIS retorne frases em portugu√™s se o idioma escolhido for ingl√™s ou espanhol
                6. NUNCA, JAMAIS retorne frases em espanhol se o idioma escolhido for portugu√™s ou ingl√™s
                7. Cada frase deve ter 2 a 4 palavras, no m√°ximo
                8. As frases devem ser impactantes e relacionadas ao t√≠tulo "${selectedTitle}"
                
                ANTES DE RETORNAR O JSON, VERIFIQUE:
                - Todas as 5 frases est√£o no idioma "${language}"?
                - Nenhuma frase est√° em ingl√™s se "${language}" for portugu√™s ou espanhol?
                - Nenhuma frase est√° em portugu√™s se "${language}" for ingl√™s ou espanhol?
                - Nenhuma frase est√° em espanhol se "${language}" for portugu√™s ou ingl√™s?
                
                Se alguma resposta for N√ÉO, CORRIJA as frases antes de retornar o JSON.
                `}

4. **"descricaoThumbnail"**: Prompt EXTREMAMENTE DETALHADO em INGL√äS para IA de gera√ß√£o de imagem. ${!includePhrases ? 'N√ÉO inclua placeholder para texto. Apenas elementos visuais.' : 'DEVE incluir placeholder "[FRASE DE GANCHO AQUI]" com descri√ß√£o profissional de texto Photoshop (layer effects, stroke, drop shadow, outer glow, bevel & emboss, tipografia profissional, valores espec√≠ficos).'} 

${hasStandardPrompt ? `\n‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - O PROMPT PADR√ÉO √â APENAS ESTILO - APLICAR AO T√çTULO "${selectedTitle}" ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è:\nA descri√ß√£oThumbnail DEVE APLICAR APENAS O ESTILO VISUAL do prompt padr√£o acima ao t√≠tulo "${selectedTitle}".\n\nPROCESSO OBRIGAT√ìRIO:\n1. EXTRAIA do prompt padr√£o APENAS os elementos de ESTILO VISUAL:\n   - Tipo de composi√ß√£o (close-up, composi√ß√£o dividida, cena √©pica, etc.)\n   - Paleta de cores (dourado, azul escuro, vermelho, preto, etc.)\n   - Estilo de tipografia (dourado serifado, bevel/emboss, outline preto, etc.)\n   - Elementos visuais recorrentes (pir√¢mides, navios, fogo, tempestades, silhuetas, etc.)\n   - Ilumina√ß√£o e atmosfera (dram√°tica, stormy, chiaroscuro, luz dourada, etc.)\n   - Estilo geral (cinematogr√°fico, documental, √©pico, realista, etc.)\n\n2. IGNORE o conte√∫do/tema do prompt padr√£o. O conte√∫do DEVE ser sobre "${selectedTitle}".\n\n3. APLIQUE o estilo extra√≠do ao criar uma thumbnail sobre "${selectedTitle}":\n   - Use a mesma composi√ß√£o mas com elementos relacionados a "${selectedTitle}"\n   - Use a mesma paleta de cores\n   - Use o mesmo estilo de tipografia\n   - Adapte os elementos visuais ao tema de "${selectedTitle}" (mantendo o estilo)\n   - Use a mesma ilumina√ß√£o e atmosfera\n   - Mantenha o estilo geral\n\n4. RESULTADO: Thumbnail sobre "${selectedTitle}" mas com o estilo visual do prompt padr√£o.\n\nEXEMPLO PR√ÅTICO:\n- Prompt padr√£o: "close-up dram√°tico de l√≠der ind√≠gena com textos dourados serifados, ilumina√ß√£o dram√°tica, c√©u tempestuoso"\n- T√≠tulo escolhido: "${selectedTitle}" (ex: sobre tecnologia inca)\n- RESULTADO: "close-up dram√°tico de [elementos relacionados a ${selectedTitle}] com textos dourados serifados, ilumina√ß√£o dram√°tica, c√©u tempestuoso"\n\n‚ö†Ô∏è N√ÉO USE O CONTE√öDO DO PROMPT PADR√ÉO. USE APENAS O ESTILO E APLIQUE AO T√çTULO "${selectedTitle}".\n\nüö´ OBRIGAT√ìRIO - INSTRU√á√ïES DE EXCLUS√ÉO (SEMPRE INCLUIR NA descricaoThumbnail):\nA descricaoThumbnail DEVE SEMPRE incluir estas instru√ß√µes de exclus√£o no final:\n"Exclude mesoamerican pyramids, feathered headdress, conquistadors, Spanish ships, jaguar motifs, and any aztec elements unless specifically relevant to the detected theme. Exclude any logos, watermarks, channel badges or branding marks. Do not render channel names or corner marks."\n\n‚ö†Ô∏è CR√çTICO: Estas instru√ß√µes de exclus√£o s√£o OBRIGAT√ìRIAS e devem ser inclu√≠das em TODAS as descri√ß√µes de thumbnail, independentemente do prompt padr√£o usado.\n` : ''}

DEVE come√ßar com: "${getStyleSpecificPrompt(style, includePhrases)}" ${hasStandardPrompt ? `e APLICAR o estilo visual do PROMPT PADR√ÉO acima ao t√≠tulo "${selectedTitle}", mantendo todos os elementos de estilo (composi√ß√£o, cores, tipografia, ilumina√ß√£o, atmosfera) mas adaptando o conte√∫do ao tema do t√≠tulo.` : 'e aplicar as regras de thumbnail viral identificadas acima de forma EXPL√çCITA.'}

Retorne APENAS JSON v√°lido:
{
  "ideias": [
    {
      "seoDescription": "Descri√ß√£o completa e otimizada...",
      "seoTags": ["tag1", "tag2", ...],
      "frasesDeGancho": ${includePhrases ? '["Frase 1", "Frase 2", "Frase 3", "Frase 4", "Frase 5"]' : '[]'},
      "descricaoThumbnail": "Ultra-high-definition (8K) professional photograph... ${includePhrases ? '[FRASE DE GANCHO AQUI]' : ''}..."
    },
    {
      "seoDescription": "Outra descri√ß√£o completa e otimizada...",
      "seoTags": ["tagA", "tagB", ...],
      "frasesDeGancho": ${includePhrases ? '["Outra 1", "Outra 2", "Outra 3", "Outra 4", "Outra 5"]' : '[]'},
      "descricaoThumbnail": "Ultra-high-definition (8K) professional photograph... ${includePhrases ? '[FRASE DE GANCHO AQUI]' : ''}..."
    }
  ]
}`;

        // Chamar API apropriada
        let response;
        if (useLaozhang) {
            response = await callLaozhangAPI(
                thumbPrompt,
                apiKeyToUse,
                modelForAPI,
                videoDetails.thumbnailUrl,
                userId,
                '/api/analyze/thumbnail/laozhang',
                JSON.stringify({ endpoint: '/api/analyze/thumbnail/laozhang', model: modelForAPI })
            );
            // callLaozhangAPI retorna string diretamente
            response = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        } else {
            // Preparar imagens adicionais (thumbnails de refer√™ncia)
            const additionalImages = thumbnailReferences.map(ref => ref.thumbnail_base64).filter(Boolean);
            
            // Chamar API apropriada com m√∫ltiplas imagens
            if (serviceToUse === 'claude') {
                response = await callClaudeAPI(thumbPrompt, apiKeyToUse, modelForAPI, videoDetails.thumbnailUrl, null, additionalImages);
            } else if (serviceToUse === 'openai') {
                response = await callOpenAIAPI(thumbPrompt, apiKeyToUse, modelForAPI, videoDetails.thumbnailUrl, additionalImages);
            } else if (serviceToUse === 'gemini') {
                response = await callGeminiAPI(thumbPrompt, apiKeyToUse, modelForAPI, videoDetails.thumbnailUrl, additionalImages);
            } else {
                response = await apiCallFunction(thumbPrompt, apiKeyToUse, modelForAPI, videoDetails.thumbnailUrl);
            }
            
            // APIs pr√≥prias retornam objeto com propriedade titles
            if (response && typeof response === 'object' && response.titles) {
                response = response.titles;
            }
        }

        // Parsear resposta usando fun√ß√£o robusta existente
        let parsedData;
        const rawResponse = typeof response === 'string' ? response : JSON.stringify(response);
        
        try {
            // Usar a fun√ß√£o parseAIResponse que j√° tem tratamento robusto para JSON malformado
            parsedData = parseAIResponse(rawResponse, 'Thumbnail Laozhang');
            
            // Verificar se o JSON tem a estrutura esperada
            if (!parsedData || typeof parsedData !== 'object') {
                throw new Error('Resposta da IA n√£o retornou um objeto JSON v√°lido.');
            }
            
            // Verificar se tem "ideias" no objeto parseado
            if (!parsedData.ideias) {
                throw new Error('Resposta da IA n√£o cont√©m o campo "ideias" esperado.');
            }
        } catch (e) {
            console.log('[Thumbnail Laozhang] Erro no parse inicial, tentando extrair JSON completo...');
            
            // Tentar extrair JSON completo usando contagem de chaves
            try {
                // Primeiro, encontrar onde est√° "ideias"
                const ideiasIndex = rawResponse.indexOf('"ideias"');
                if (ideiasIndex === -1) {
                    throw new Error('Campo "ideias" n√£o encontrado na resposta.');
                }
                
                // Encontrar o in√≠cio do objeto que cont√©m "ideias" (procurar para tr√°s)
                let objStart = rawResponse.lastIndexOf('{', ideiasIndex);
                if (objStart === -1) {
                    // Se n√£o encontrou, tentar encontrar qualquer { antes de "ideias"
                    objStart = rawResponse.indexOf('{');
                }
                
                if (objStart !== -1) {
                    // Extrair JSON completo a partir do objeto encontrado
                    const jsonFromStart = extractCompleteJson(rawResponse.substring(objStart));
                    if (jsonFromStart) {
                        const fixedJson = fixJsonWithUnescapedNewlines(jsonFromStart);
                        parsedData = JSON.parse(fixedJson);
                        console.log('[Thumbnail Laozhang] ‚úÖ JSON extra√≠do e parseado com sucesso usando contagem de chaves');
                    } else {
                        throw new Error('N√£o foi poss√≠vel extrair JSON completo usando contagem de chaves.');
                    }
                } else {
                    throw new Error('N√£o foi poss√≠vel encontrar in√≠cio do objeto JSON.');
                }
            } catch (extractError) {
                console.error('[Thumbnail Laozhang] Erro ao extrair JSON:', extractError.message);
                console.error('[Thumbnail Laozhang] Erro original:', e.message);
                console.error('[Thumbnail Laozhang] Resposta (primeiros 2000 chars):', rawResponse.substring(0, 2000));
                throw new Error(`Erro ao processar resposta da IA: ${e.message}. Tentativa de extra√ß√£o tamb√©m falhou: ${extractError.message}`);
            }
        }

        if (!parsedData.ideias || !Array.isArray(parsedData.ideias) || parsedData.ideias.length === 0) {
            throw new Error("A IA n√£o retornou o array 'ideias' esperado.");
        }

        // Validar e processar dados antes de enviar (mesma l√≥gica da rota principal)
        // Nota: A ambienta√ß√£o j√° foi calculada anteriormente (linhas 16960-16986) e as vari√°veis est√£o dispon√≠veis:
        // ambientacaoArr, elementosArr, acessoriosCalc, personagemCalc, ambientacaoCalc, elementosDeFundoCalc

        if (parsedData.ideias && Array.isArray(parsedData.ideias)) {
            parsedData.ideias = parsedData.ideias.map((idea, index) => {
                // Validar tags - limitar a 300 caracteres
                if (idea.seoTags && Array.isArray(idea.seoTags)) {
                    let tagsString = idea.seoTags.join(', ');
                    if (tagsString.length > 300) {
                        // Reduzir tags at√© ficar dentro do limite
                        let reducedTags = [];
                        let currentLength = 0;
                        for (const tag of idea.seoTags) {
                            const tagWithComma = reducedTags.length > 0 ? ', ' + tag : tag;
                            if (currentLength + tagWithComma.length <= 300) {
                                reducedTags.push(tag);
                                currentLength += tagWithComma.length;
                            } else {
                                break;
                            }
                        }
                        idea.seoTags = reducedTags;
                        console.log(`[Thumbnail Laozhang] Tags reduzidas para respeitar limite de 300 caracteres`);
                    }
                }
                
                // Validar frases de gancho - garantir que estejam no idioma correto
                if (idea.frasesDeGancho && Array.isArray(idea.frasesDeGancho) && includePhrases) {
                    const isPortuguese = language === 'Portugu√™s';
                    const isSpanish = language === 'Espanhol';
                    const portugueseWords = ['que', 'n√£o', 'voc√™', 'com', 'para', 'mais', 'muito', 'isso', 'aqui', 'agora', 'tamb√©m', 'sempre', 'depois', 'antes', 'ainda', 'ent√£o', 'assim', 'mesmo', 'todo', 'toda', 'todos', 'todas', 'ele', 'ela', 'eles', 'elas'];
                    const spanishWords = ['que', 'no', 't√∫', 'con', 'para', 'm√°s', 'muy', 'esto', 'aqu√≠', 'ahora', 'tambi√©n', 'siempre', 'despu√©s', 'antes', 'a√∫n', 'entonces', 'as√≠', 'mismo', 'todo', 'toda', 'todos', 'todas', '√©l', 'ella', 'ellos', 'ellas'];
                    
                    idea.frasesDeGancho = idea.frasesDeGancho.map(frase => {
                        if (!frase || typeof frase !== 'string') return frase;
                        const fraseLower = frase.toLowerCase();
                        let needsTranslation = false;
                        
                        if (isPortuguese && !portugueseWords.some(word => fraseLower.includes(word)) && (fraseLower.includes('the ') || fraseLower.includes(' a ') || fraseLower.includes('this '))) {
                            needsTranslation = true;
                        } else if (isSpanish && !spanishWords.some(word => fraseLower.includes(word)) && (fraseLower.includes('the ') || fraseLower.includes(' a ') || fraseLower.includes('this '))) {
                            needsTranslation = true;
                        }
                        
                        if (needsTranslation) {
                            console.warn(`[Thumbnail Laozhang] Frase de gancho pode estar no idioma errado: "${frase}" (idioma esperado: ${language})`);
                        }
                        
                        return frase;
                    });
                }
                
                // Modularizar a descricaoThumbnail: aplicar estilo fixo e ambienta√ß√£o din√¢mica pelo t√≠tulo
                const baseTemplate = `Generate a historical cinematic thumbnail depicting {PERSONAGEM} wearing {ACESSORIOS} against {AMBIENTE}. Position the subject in the foreground taking up 60% of the frame with an epic background showing {ELEMENTOS_DE_FUNDO}. Use high contrast lighting with gold or cold tones depending on theme and a dramatic sky with storm clouds or environmental effects. The title should be in bold, imposing gold text with a subtle glow effect. The overall mood should be cinematic, realistic and historically significant with ultra-high detail.`;
                let built = baseTemplate
                    .replace('{PERSONAGEM}', personagemCalc)
                    .replace('{ACESSORIOS}', acessoriosCalc || 'authentic period accessories')
                    .replace('{AMBIENTE}', ambientacaoCalc)
                    .replace('{ELEMENTOS_DE_FUNDO}', elementosDeFundoCalc || 'contextual historical elements');
                if (includePhrases) {
                    built += `\nProfessional Photoshop-quality text design displaying [FRASE DE GANCHO AQUI], with multiple layer effects (stroke, drop shadow, outer glow, bevel and emboss), perfect kerning, anti-aliasing, large bold serif gold typography at bottom.`;
                }
                built += `\nExclude mesoamerican pyramids, feathered headdress, conquistadors, Spanish ships unless specifically relevant to the detected theme. CRITICAL - REMOVE ALL CORNER MARKINGS: Exclude any logos, watermarks, channel badges, branding marks, corner icons, decorative elements, or any visual elements in the four corners of the image (top-left, top-right, bottom-left, bottom-right). The image must be completely clean in all four corners.`;
                idea.descricaoThumbnail = built;

                // Calcular score viral baseado no algoritmo do YouTube
                const viralScore = calculateThumbnailViralScore(idea.descricaoThumbnail, index, parsedData.ideias.length);
                idea.viralScore = viralScore;
                
                return idea;
            });
        }

        res.status(200).json(parsedData.ideias);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/analyze/thumbnail/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao gerar ideias de thumbnail.' });
    }
});

// === ROTA PARA GERAR PROMPTS DE CENA ===
app.post('/api/generate/scene-prompts', authenticateToken, async (req, res) => {
    const { script, model, style, imageModel, mode, wordsPerScene, unit, characters, selectedModel, isVO3, expectedScenes } = req.body;
    const userId = req.user.id;
    const forVO3 = isVO3 === true || isVO3 === 'true' || isVO3 === 1; // Suporta boolean, string ou n√∫mero

    if (!script || !script.trim()) {
        return res.status(400).json({ msg: 'O roteiro √© obrigat√≥rio.' });
    }

    if (!model) {
        return res.status(400).json({ msg: 'O modelo de IA √© obrigat√≥rio.' });
    }

    try {
        // Verificar se deve usar cr√©ditos (laozhang.ai) ou API pr√≥pria
        // REGRA: Usa cr√©ditos se usu√°rio marcou prefer√™ncia OU n√£o tem plano que permite API pr√≥pria OU n√£o tem API pr√≥pria configurada
        // REGRA CR√çTICA: Se prefer√™ncia N√ÉO est√° marcada E usu√°rio tem plano que permite E tem API pr√≥pria ‚Üí usar API pr√≥pria
        let service = 'gemini';
        if (model.includes('claude') || model.includes('sonnet')) {
            service = 'claude';
        } else if (model.includes('gpt') || model.includes('openai')) {
            service = 'openai';
        }

        const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
        let decryptedKey = null;
        let useLaozhang = false;
        let laozhangApiKey = null;

        if (creditsCheck.shouldUse) {
            // Usar cr√©ditos (laozhang.ai)
            console.log(`[Scene Prompts] ‚úÖ Usando cr√©ditos (${creditsCheck.reason})`);
            laozhangApiKey = await getLaozhangApiKey();
            if (laozhangApiKey) {
                useLaozhang = true;
            } else {
                return res.status(500).json({ msg: 'Sistema de cr√©ditos n√£o configurado. Entre em contato com o suporte.' });
            }
        } else {
            // Usar API pr√≥pria
            console.log(`[Scene Prompts] ‚úÖ Usando API pr√≥pria (${creditsCheck.reason})`);
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (!keyData) {
                return res.status(400).json({ msg: `Chave de API do ${service} n√£o configurada. Configure nas Configura√ß√µes.` });
            }

            decryptedKey = decrypt(keyData.api_key);
            if (!decryptedKey) {
                return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
            }
        }

        // Usar o n√∫mero exato enviado pelo frontend, ou calcular se n√£o foi enviado
        const wordCount = script.trim().split(/\s+/).filter(Boolean).length;
        let estimatedScenes, minScenes, maxScenes;
        
        if (expectedScenes && parseInt(expectedScenes) > 0) {
            // Usar o n√∫mero exato do frontend
            estimatedScenes = parseInt(expectedScenes);
            minScenes = estimatedScenes;
            maxScenes = estimatedScenes;
            console.log(`[Scene Prompts] Usando n√∫mero exato do frontend: ${estimatedScenes} cenas`);
        } else {
            // Calcular n√∫mero estimado de cenas baseado no modo (fallback)
            if (mode === 'manual' && wordsPerScene) {
                const unitType = unit || 'words'; // 'words' ou 'seconds'
                const value = parseInt(wordsPerScene);
                
                if (unitType === 'seconds') {
                    // Modo manual por segundos: assumir ~2.5 palavras por segundo de narra√ß√£o
                    const wordsPerSecond = 2.5;
                    const wordsPerInterval = value * wordsPerSecond;
                    estimatedScenes = Math.max(1, Math.round(wordCount / wordsPerInterval));
                    minScenes = Math.max(1, Math.floor(wordCount / (wordsPerInterval * 1.4)));
                    maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / (wordsPerInterval * 0.6)));
                } else {
                    // Modo manual: baseado em palavras por cena
                    estimatedScenes = Math.max(1, Math.round(wordCount / value));
                    minScenes = Math.max(1, Math.floor(wordCount / (value * 1.4)));
                    maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / (value * 0.6)));
                }
            } else {
                // Modo autom√°tico: 1 cena a cada ~90 palavras
                estimatedScenes = Math.max(1, Math.round(wordCount / 90));
                minScenes = Math.max(1, Math.floor(wordCount / 140));
                maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / 60));
            }
        }

        // ============================================
        // CAMADA 1: √ÇNCORA VISUAL GLOBAL (VERS√ÉO DEFINITIVA FINAL)
        // ============================================
        // REGRA DE OURO: Se uma cena parecer que poderia ser uma foto real, ela est√° errada.
        // Ela precisa parecer uma miniatura filmada, n√£o uma pessoa filmada.
        // Este texto nunca muda. Nunca.
        const GLOBAL_VISUAL_ANCHOR = `
üß© GLOBAL VISUAL IDENTITY ‚Äî LOCKED:

The entire story exists inside a cinematic narrative diorama.
All environments are handcrafted miniature scale models,
the world feels like a physical maquette filmed up close.

All characters, including close-ups and portraits,
must appear as stylized sculpted figures,
never as real human faces.

All faces must retain a sculpted, physical miniature appearance.
No natural photographic skin softness.
Faces should look like crafted figures, not real people,
even in close-up shots.

Consistent semi-stylized realism across all scenes,
no photorealistic skin, no natural human softness.

Matte materials, handcrafted textures,
subtle imperfections, physical model feel.

Cinematic depth of field,
controlled perspective,
subtle tilt-shift to reinforce miniature scale.

Every frame must look like a frozen cinematic moment
from the same miniature world.

‚ö†Ô∏è This text NEVER changes. NEVER.
‚ö†Ô∏è If a scene looks like it could be a real photograph, it's wrong.
‚ö†Ô∏è It must look like a filmed miniature, not a filmed person.

üö´ NEGATIVE PROMPT ‚Äî √öLTIMO REFOR√áO:
photorealistic humans,
hyper-detailed skin,
real-world full scale environments,
life-size architecture,
photographic realism,
cinema movie still look,
video game graphics,
cartoon style,
anime style,
plastic or glossy materials,
stop-motion puppets,
toy-like exaggeration,
full-scale real world,
wide open real locations,
global illumination,
neutral camera angles,
real human skin texture,
natural photographic portrait,
beauty photography lighting,
hyper-smooth faces,
ultra-real close-up photography,
photographic portrait,
beauty photography,
natural skin translucency,
cinema realism close-up

‚ö†Ô∏è If any of these appear visually, the scene has failed.

WHAT CAN VARY (WITHOUT BREAKING STYLE):
‚úÖ Lighting (warm / cold)
‚úÖ Time of day
‚úÖ Emotion
‚úÖ Action
‚úÖ Narrative framing

WHAT NEVER VARIES:
‚ùå Scale
‚ùå Character type (always stylized sculpted figures)
‚ùå Material (always matte, handcrafted)
‚ùå Camera language (always story-driven)
‚ùå Realism level (always semi-stylized, never photorealistic)

SCENE VALIDATION CHECKLIST (ALL MUST BE YES):
- Does it look like a physical miniature?
- Could it fit on a table?
- Do people look like sculpted figures, not actors?
- Do close-ups look like stylized sculptures, not real faces?
- Does light look controlled, not randomly natural?
- Does it look like a frame from the same film as all others?

If any answer is NO ‚Üí regenerate the scene.

REINFORCEMENT PHRASES (INCLUDE ONE PER SCENE, ALTERNATING):
- "as if filmed inside a handcrafted scale model"
- "the environment feels like a physical miniature set"
- "miniature world with cinematic lighting"
`;

        // ============================================
        // CAMADA 2: ESTILO (MODIFICADORES)
        // ============================================
        // O estilo apenas modula ilumina√ß√£o, contraste, paleta, mood
        // N√ÉO pode alterar: tipo de personagem, escala, c√¢mera, realismo
        const styleModifiers = {
            'photorealistic': 'High contrast lighting, sharp focus, professional photography aesthetic, saturated colors.',
            'cinematic': 'Dramatic cinematic lighting, low-key illumination, strong shadows, emotional tension, film-like contrast, controlled color palette.',
            'cinematic-diorama': 'Dramatic cinematic lighting with practical light sources, low-key illumination, strong volumetric shadows, emotional storytelling atmosphere, warm color palette with desaturated shadows.',
            'documentary': 'Natural lighting, authentic moments, journalistic approach, realistic color grading.',
            'cinematic-narrative': 'Story-driven lighting, emotional depth, narrative composition, dramatic shadows.',
            'anime': 'Vibrant colors, expressive lighting, high saturation, dynamic contrast.',
            'cartoon': 'Colorful palette, expressive lighting, high contrast, playful mood.',
            'cartoon-premium': 'Premium animation quality, sophisticated color palette, professional lighting.',
            'fantasy': 'Magical lighting, epic atmosphere, enchanted color palette, mystical elements.',
            'stick-figure': 'Minimalist lighting, simple lines, white background, clean aesthetic.',
            'whiteboard': 'Clean educational lighting, hand-drawn illustrations, minimalist aesthetic.',
            'tech-minimalist': 'Modern clean lighting, futuristic aesthetic, minimalist design.',
            'spiritual-minimalist': 'Serene lighting, meditative atmosphere, zen aesthetic, soft illumination.',
            'viral-vibrant': 'High contrast, saturated colors, social media optimized, vibrant palette.',
            'modern-documentary': 'Dynamic contemporary lighting, authentic moments, modern color grading.',
            'analog-horror': 'VHS quality grain, retro horror aesthetic, low-fi texture, analog degradation.',
            'dark-theater': 'Dramatic stage lighting, intense shadows, theatrical illumination.',
            'naturalist-drama': 'Realistic emotional lighting, authentic human moments, natural color palette.',
            'spiritual-neorealism': 'Transcendent realistic lighting, mystical atmosphere, spiritual color grading.',
            'psychological-surrealism': 'Dreamlike lighting, abstract reality, surreal color palette.',
            'fragmented-memory': 'Collage aesthetic, fragmented composition, layered lighting.',
            'fragmented-narrative': 'Fragmented narrative style, collage composition, layered visual narrative.',
            'dream-real': 'Liminal space lighting, ethereal atmosphere, dream-reality blend.',
            'vhs-nostalgic': 'VHS nostalgic aesthetic, retro 80s/90s quality, vintage grain, analog texture.'
        };
        
        // Modificador adicional opcional para refinar ainda mais o estilo
        const styleModifier = style && style !== 'none' && styleModifiers[style] 
            ? `\n\nüé® REFINAMENTO DE ESTILO (${style}):\n${styleModifiers[style]}\n\n‚ö†Ô∏è Este refinamento complementa a √Çncora Visual Global acima, ajustando detalhes de ilumina√ß√£o, contraste e paleta de cores.` 
            : '';
        const imageModelInstruction = imageModel ? ` Os prompts devem ser otimizados para ${imageModel}.` : '';
        const charactersInstruction = characters ? `\n\nPERSONAGENS CONSISTENTES:\n${characters}\n\nIMPORTANTE: Use essas descri√ß√µes de personagens de forma consistente em todas as cenas onde eles aparecerem.` : '';
        
        // Instru√ß√µes espec√≠ficas para VO3
        const vo3Instructions = forVO3 ? `
        
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è MODO VO3 ATIVADO - OTIMIZA√á√ÉO PARA GERA√á√ÉO DE V√çDEO ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
Os prompts devem ser OTIMIZADOS ESPECIFICAMENTE para o modelo VO3 (gera√ß√£o de v√≠deo).

REGRAS CR√çTICAS PARA VO3:
1. MOVIMENTO E A√á√ÉO: Cada prompt DEVE descrever movimento, a√ß√£o ou transi√ß√£o. VO3 precisa de elementos din√¢micos para gerar v√≠deo fluido.
   - Use verbos de a√ß√£o: "walking", "running", "flying", "rotating", "approaching", "receding", "panning", "zooming"
   - Descreva dire√ß√£o de movimento: "from left to right", "approaching camera", "flying away", "spinning clockwise"
   - Inclua transi√ß√µes: "fade in", "slow reveal", "gradual zoom", "smooth pan"

2. SFX (EFEITOS SONOROS) EMBUTIDOS: Cada prompt DEVE incluir descri√ß√µes de efeitos sonoros relevantes para a cena, usando a sintaxe: [SFX: descri√ß√£o do som]
   - Exemplos: [SFX: distant explosion, rumbling], [SFX: footsteps on gravel, crunching], [SFX: wind howling, atmospheric], [SFX: engine revving, mechanical], [SFX: water splashing, liquid], [SFX: door creaking, wooden], [SFX: birds chirping, nature], [SFX: crowd murmuring, ambient], [SFX: glass breaking, shattering], [SFX: thunder rumbling, weather]
   - Inclua SFX que fa√ßa sentido para a a√ß√£o visual descrita
   - Use 1-3 SFX por cena, dependendo da complexidade
   - SFX deve estar ENTRE PAR√äNTESES QUADRADOS no formato [SFX: nome do som, categoria]

3. DURA√á√ÉO E RITMO: Indique o ritmo/tempo da cena quando relevante
   - "slow motion", "time-lapse", "real-time", "fast-paced", "leisurely pace"

4. CONTINUIDADE VISUAL: Mantenha consist√™ncia entre cenas consecutivas
   - Se uma cena termina com um personagem √† esquerda, a pr√≥xima pode come√ßar com ele √† direita (mostrando movimento)
   - Descreva posi√ß√µes relativas que permitam transi√ß√µes suaves

5. ELEMENTOS CINEMATOGR√ÅFICOS PARA V√çDEO:
   - Movimentos de c√¢mera: "camera panning left", "dolly forward", "crane shot rising", "handheld following"
   - Profundidade din√¢mica: "foreground elements moving", "background parallax", "layered movement"
   - Mudan√ßas de foco: "rack focus from A to B", "shallow focus transitioning"

FORMATO DO PROMPT PARA VO3:
Cada prompt_text deve seguir este padr√£o:
"[Descri√ß√£o visual detalhada com movimento e a√ß√£o] [SFX: som1, categoria1] [SFX: som2, categoria2] [Movimento de c√¢mera] [Ritmo/tempo]"

EXEMPLO DE PROMPT VO3:
"Aerial view of a military helicopter flying low over a desert landscape, rotor blades spinning rapidly, dust clouds trailing behind, camera tracking the helicopter from behind and slightly above, smooth forward motion, golden hour lighting casting long shadows, [SFX: helicopter rotor blades, mechanical] [SFX: wind rushing, atmospheric] [SFX: distant engine roar, vehicle] - fast-paced action sequence, dynamic camera movement"` : '';

        const prompt = `${GLOBAL_VISUAL_ANCHOR}${styleModifier}

Voc√™ √© um especialista em cria√ß√£o de prompts para ${forVO3 ? 'gera√ß√£o de v√≠deo (VO3)' : 'gera√ß√£o de imagens'} usando IA.

TAREFA:
Analise o roteiro fornecido e crie prompts detalhados para cada cena do v√≠deo. Cada prompt deve descrever visualmente o que deve aparecer ${forVO3 ? 'no v√≠deo' : 'na imagem'} para aquela parte do roteiro.${vo3Instructions}

ROTEIRO:
"""
${script}
"""

INSTRU√á√ïES:
1. üîí OBRIGAT√ìRIO: TODAS as cenas DEVEM seguir a √ÇNCORA VISUAL GLOBAL acima. Esta √© a base visual definida pelo estilo escolhido (${selectedStyle}).
2. üé® O estilo "${selectedStyle}" foi selecionado pelo usu√°rio. TODOS os prompts devem seguir este estilo visual consistentemente.
3. ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - N√öMERO EXATO DE CENAS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è: Voc√™ DEVE gerar EXATAMENTE ${estimatedScenes} cenas. N√ÉO mais, N√ÉO menos. O frontend espera ${estimatedScenes} cenas e voc√™ DEVE entregar todas elas. Se a resposta ficar muito longa, continue mesmo assim. √â OBRIGAT√ìRIO gerar todas as ${estimatedScenes} cenas.
4. Cada prompt deve ter entre ${forVO3 ? '800-1500' : '600-1200'} caracteres${forVO3 ? ' (VO3 precisa de mais detalhes para movimento e SFX)' : ''}
5. Cada prompt deve ser em INGL√äS e otimizado para ${forVO3 ? 'gera√ß√£o de v√≠deo (VO3)' : 'gera√ß√£o de imagens'}
6. Seja espec√≠fico e detalhado: descreva composi√ß√£o, ilumina√ß√£o, cores, atmosfera, personagens, cen√°rio${forVO3 ? ', movimento, a√ß√£o, transi√ß√µes e efeitos sonoros' : ''}
7. Use termos t√©cnicos de fotografia/cinematografia quando apropriado${imageModelInstruction}${charactersInstruction}
8. ‚ö†Ô∏è CR√çTICO: Cada prompt_text DEVE incluir os elementos da √Çncora Visual Global. N√£o gere cenas com est√©tica diferente (stop-motion, realismo fotogr√°fico, cartoon, game, etc.). Todas as cenas devem pertencer ao mesmo mundo visual.
9. üîß REFOR√áO DE ESCALA: Cada prompt_text DEVE incluir UMA das frases de refor√ßo (alternando entre cenas):
   - "as if filmed inside a handcrafted scale model"
   - "the environment feels like a physical miniature set"
   - "miniature world with cinematic lighting"
   Alternar entre essas tr√™s frases para evitar repeti√ß√£o √≥bvia, mas sempre incluir uma delas para refor√ßar a escala de miniatura.

FORMATO DE RESPOSTA (JSON):
{
  "scenes": [
    {
      "scene_number": 1,
      "scene_description": "Breve descri√ß√£o da cena em portugu√™s",
      "prompt_text": "Prompt detalhado em ingl√™s para ${forVO3 ? 'gera√ß√£o de v√≠deo VO3 com SFX embutido' : 'gera√ß√£o de imagem'} (${forVO3 ? '800-1500' : '600-1200'} caracteres)${forVO3 ? ' - DEVE incluir [SFX: ...] e descri√ß√µes de movimento' : ''}"
    },
    {
      "scene_number": 2,
      "scene_description": "Breve descri√ß√£o da cena em portugu√™s",
      "prompt_text": "Prompt detalhado em ingl√™s para ${forVO3 ? 'gera√ß√£o de v√≠deo VO3 com SFX embutido' : 'gera√ß√£o de imagem'} (${forVO3 ? '800-1500' : '600-1200'} caracteres)${forVO3 ? ' - DEVE incluir [SFX: ...] e descri√ß√µes de movimento' : ''}"
    }
  ]
}

IMPORTANTE:
- Responda APENAS com o JSON v√°lido, sem texto adicional
- Certifique-se de que cada prompt_text tem entre ${forVO3 ? '800-1500' : '600-1200'} caracteres
${forVO3 ? '- TODOS os prompts DEVE incluir pelo menos 1-3 SFX no formato [SFX: nome do som, categoria]\n- TODOS os prompts DEVE descrever movimento, a√ß√£o ou transi√ß√£o para VO3\n' : ''}
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è REGRA ABSOLUTA - N√öMERO DE CENAS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è:
- Voc√™ DEVE gerar EXATAMENTE ${estimatedScenes} cenas. N√ÉO ${minScenes}, N√ÉO ${maxScenes}, mas EXATAMENTE ${estimatedScenes} cenas.
- O JSON DEVE conter um array "scenes" com EXATAMENTE ${estimatedScenes} objetos.
- N√ÉO pare antes de gerar todas as ${estimatedScenes} cenas, mesmo que a resposta fique muito longa.
- Se voc√™ gerar menos de ${estimatedScenes} cenas, a resposta ser√° considerada INCOMPLETA e REJEITADA.
- O roteiro tem ${wordCount} palavras, o que justifica ${estimatedScenes} cenas. Gere TODAS elas.
- Comece pela cena 1 e continue at√© a cena ${estimatedScenes}. N√ÉO pule nenhuma cena.
- √â CR√çTICO e OBRIGAT√ìRIO que o array "scenes" tenha EXATAMENTE ${estimatedScenes} elementos.`;

        let apiCallFunction;
        let response;
        
        if (useLaozhang && laozhangApiKey) {
            // Usar cr√©ditos (laozhang.ai)
            console.log(`[Scene Prompts] Gerando prompts com laozhang.ai (cr√©ditos) - modelo: ${model}... (timeout: ${scenePromptsTimeout/1000}s)`);
            // Passar o timeout calculado no operationType para o callLaozhangAPI ajustar
            response = await callLaozhangAPI(prompt, laozhangApiKey, model, null, userId, '/api/generate/scene-prompts', JSON.stringify({ endpoint: '/api/generate/scene-prompts', model, estimatedScenes, timeout: scenePromptsTimeout }));
        } else {
            // Usar API pr√≥pria
            if (service === 'gemini') {
                apiCallFunction = callGeminiAPI;
                response = await apiCallFunction(prompt, decryptedKey, model);
            } else if (service === 'claude') {
                console.log(`[Scene Prompts] Gerando prompts com ${service} (API pr√≥pria) - modelo: ${model}... (timeout: ${scenePromptsTimeout/1000}s)`);
                response = await callClaudeAPI(prompt, decryptedKey, model, null, scenePromptsTimeout);
            } else {
                apiCallFunction = callOpenAIAPI;
                response = await apiCallFunction(prompt, decryptedKey, model);
            }
            
            if (!response) {
                console.log(`[Scene Prompts] Gerando prompts com ${service} (API pr√≥pria) - modelo: ${model}...`);
            }
        }

        // Parsear resposta
        let scenesData;
        let rawResponse = response;
        
        if (typeof response === 'string') {
            rawResponse = response.trim();
        } else {
            rawResponse = JSON.stringify(response);
        }
        
        console.log('[Scene Prompts] Resposta bruta (primeiros 1000 chars):', rawResponse.substring(0, 1000));
        
        // Verificar se a API recusou a requisi√ß√£o (apenas se for uma mensagem de erro clara, n√£o JSON v√°lido)
        // Primeiro, tentar verificar se h√° JSON v√°lido na resposta
        const hasValidJson = rawResponse.match(/\{[\s\S]*"scenes"[\s\S]*\}/) || rawResponse.match(/\{[\s\S]*"scene_number"[\s\S]*\}/);
        
        // Se n√£o h√° JSON v√°lido, verificar se √© uma mensagem de erro da API
        if (!hasValidJson) {
            const errorPatterns = [
                /^I'm sorry,?\s+I can't assist/i,
                /^I'm sorry,?\s+I cannot/i,
                /^I'm unable to assist/i,
                /^I cannot fulfill/i,
                /^I must decline/i,
                /^I can't help with that/i,
                /^I'm not able to/i,
                /^This request violates/i,
                /^I cannot comply/i
            ];
            
            const trimmedResponse = rawResponse.trim();
            const isError = errorPatterns.some(pattern => pattern.test(trimmedResponse));
            
            // Tamb√©m verificar se √© uma resposta muito curta (menos de 100 chars) que come√ßa com mensagem de erro
            if (isError || (trimmedResponse.length < 100 && trimmedResponse.toLowerCase().startsWith("i'm sorry"))) {
                console.error('[Scene Prompts] API recusou a requisi√ß√£o:', rawResponse.substring(0, 500));
                throw new Error(`A API de IA recusou processar o prompt. Isso pode acontecer se o conte√∫do violar as pol√≠ticas de uso da API. Tente simplificar o roteiro ou remover conte√∫do sens√≠vel. Resposta: ${rawResponse.substring(0, 500)}`);
            }
        }
        
        // Tentar parsear diretamente
        try {
            scenesData = JSON.parse(rawResponse);
        } catch (e) {
            console.log('[Scene Prompts] Tentativa 1 de parsing falhou, tentando extrair JSON...');
            
            // Tentar extrair JSON usando regex mais robusto
            const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    scenesData = JSON.parse(jsonMatch[0]);
                } catch (e2) {
                    console.log('[Scene Prompts] Tentativa 2 de parsing falhou, tentando corrigir JSON...');
                    
                    // Tentar corrigir JSON comum (remover markdown, code blocks, etc)
                    let cleanedJson = jsonMatch[0]
                        .replace(/```json\s*/g, '')
                        .replace(/```\s*/g, '')
                        .replace(/^[^{]*/, '')
                        .replace(/[^}]*$/, '');
                    
                    try {
                        scenesData = JSON.parse(cleanedJson);
                    } catch (e3) {
                        console.log('[Scene Prompts] Tentativa 3 de parsing falhou, tentando extrair scenes diretamente...');
                        
                        // √öltima tentativa: procurar por "scenes" no texto
                        const scenesMatch = rawResponse.match(/"scenes"\s*:\s*\[[\s\S]*\]/);
                        if (scenesMatch) {
                            try {
                                scenesData = JSON.parse(`{${scenesMatch[0]}}`);
                            } catch (e4) {
                                console.error('[Scene Prompts] Erro no parsing:', e4.message);
                                throw new Error(`Resposta da IA n√£o cont√©m JSON v√°lido. Erro: ${e4.message}`);
                            }
                        } else {
                            throw new Error(`Resposta da IA n√£o cont√©m JSON v√°lido. Primeiros 500 caracteres: ${rawResponse.substring(0, 500)}`);
                        }
                    }
                }
            } else {
                throw new Error(`Nenhum JSON encontrado na resposta. Primeiros 500 caracteres: ${rawResponse.substring(0, 500)}`);
            }
        }

        // Validar estrutura - verificar se h√° campos aninhados (como "titles" contendo JSON string)
        if (!scenesData) {
            throw new Error('Resposta da IA est√° vazia ou inv√°lida.');
        }
        
        // Se a resposta tem um campo que cont√©m JSON string, parsear novamente
        if (scenesData.titles && typeof scenesData.titles === 'string') {
            try {
                const parsedTitles = JSON.parse(scenesData.titles);
                if (parsedTitles.scenes) {
                    scenesData = parsedTitles;
                }
            } catch (e) {
                console.log('[Scene Prompts] Campo titles n√£o √© JSON v√°lido, continuando...');
            }
        }
        
        // Se a resposta tem um campo que cont√©m JSON string em outro formato
        if (scenesData.content && typeof scenesData.content === 'string') {
            try {
                const parsedContent = JSON.parse(scenesData.content);
                if (parsedContent.scenes) {
                    scenesData = parsedContent;
                }
            } catch (e) {
                console.log('[Scene Prompts] Campo content n√£o √© JSON v√°lido, continuando...');
            }
        }
        
        // Verificar se scenes existe diretamente ou em algum n√≠vel aninhado
        if (!scenesData.scenes) {
            // Procurar em todos os n√≠veis
            const findScenes = (obj) => {
                if (Array.isArray(obj)) {
                    return obj;
                }
                if (typeof obj === 'object' && obj !== null) {
                    if (obj.scenes && Array.isArray(obj.scenes)) {
                        return obj.scenes;
                    }
                    for (const key in obj) {
                        const found = findScenes(obj[key]);
                        if (found) return found;
                    }
                }
                return null;
            };
            
            const foundScenes = findScenes(scenesData);
            if (foundScenes) {
                scenesData = { scenes: foundScenes };
            } else {
                console.error('[Scene Prompts] Estrutura de resposta inv√°lida:', JSON.stringify(scenesData).substring(0, 1000));
                throw new Error('A IA n√£o retornou a estrutura esperada. Verifique se a resposta cont√©m um campo "scenes".');
            }
        }
        
        if (!Array.isArray(scenesData.scenes)) {
            console.error('[Scene Prompts] Campo scenes n√£o √© array:', typeof scenesData.scenes);
            throw new Error('O campo "scenes" da resposta n√£o √© um array v√°lido.');
        }
        
        if (scenesData.scenes.length === 0) {
            throw new Error('A IA retornou um array de cenas vazio. Tente novamente com um roteiro mais detalhado.');
        }
        
        // Validar cada cena
        const validScenes = scenesData.scenes.filter(scene => 
            scene && 
            (scene.prompt_text || scene.prompt || scene.text) &&
            (scene.scene_description || scene.description || scene.scene_number || scene.number)
        );
        
        if (validScenes.length === 0) {
            throw new Error('Nenhuma cena v√°lida encontrada na resposta da IA. Verifique o formato esperado.');
        }
        
        // Normalizar estrutura das cenas
        scenesData.scenes = validScenes.map((scene, index) => ({
            scene_number: scene.scene_number || scene.number || index + 1,
            scene_description: scene.scene_description || scene.description || `Cena ${index + 1}`,
            prompt_text: scene.prompt_text || scene.prompt || scene.text || ''
        }));
        
        console.log(`[Scene Prompts] ‚úÖ ${scenesData.scenes.length} cenas parseadas com sucesso!`);
        
        // Verificar se gerou todas as cenas esperadas e tentar gerar as faltantes at√© completar
        let totalAttempts = 0;
        const maxTotalAttempts = 5; // M√°ximo de 5 tentativas totais para gerar todas as cenas
        
        while (scenesData.scenes.length < estimatedScenes && totalAttempts < maxTotalAttempts) {
            const missingScenes = estimatedScenes - scenesData.scenes.length;
            console.warn(`[Scene Prompts] ‚ö†Ô∏è Apenas ${scenesData.scenes.length} cenas foram geradas, mas esper√°vamos ${estimatedScenes} cenas. Faltam ${missingScenes} cenas. Tentativa ${totalAttempts + 1}/${maxTotalAttempts}...`);
            
            // Tentar gerar as cenas faltantes usando a fun√ß√£o de retry
            try {
                let apiCallFunction;
                if (useLaozhang && laozhangApiKey) {
                    apiCallFunction = (prompt, key, model) => callLaozhangAPI(prompt, key, model, null, userId, '/api/generate/scene-prompts', JSON.stringify({ endpoint: '/api/generate/scene-prompts', model }));
                } else if (service === 'gemini') {
                    apiCallFunction = callGeminiAPI;
                } else if (service === 'claude') {
                    // Usar o timeout calculado anteriormente (scenePromptsTimeout)
                    apiCallFunction = (prompt, key, model) => callClaudeAPI(prompt, key, model, null, scenePromptsTimeout);
                } else {
                    apiCallFunction = callOpenAIAPI;
                }
                
                const additionalScenes = await generateScenesWithRetries({
                    apiFunc: apiCallFunction,
                    apiKey: useLaozhang ? laozhangApiKey : decryptedKey,
                    model: model,
                    script: script,
                    styleInstruction: styleModifier,
                    imageModelInstruction: imageModelInstruction,
                    charactersInstruction: charactersInstruction,
                    estimatedScenes: missingScenes,
                    minScenes: missingScenes, // Exigir exatamente o n√∫mero faltante
                    maxScenes: missingScenes, // Exigir exatamente o n√∫mero faltante
                    wordCount: wordCount,
                    serviceLabel: useLaozhang ? 'Laozhang' : service,
                    maxAttempts: 3
                });
                
                if (additionalScenes && additionalScenes.length > 0) {
                    // Ajustar n√∫meros das cenas para continuar a sequ√™ncia
                    const lastSceneNumber = scenesData.scenes.length;
                    additionalScenes.forEach((scene, idx) => {
                        scene.scene_number = lastSceneNumber + idx + 1;
                    });
                    scenesData.scenes = scenesData.scenes.concat(additionalScenes);
                    console.log(`[Scene Prompts] ‚úÖ ${additionalScenes.length} cenas adicionais geradas! Total: ${scenesData.scenes.length}/${estimatedScenes} cenas.`);
                } else {
                    console.warn(`[Scene Prompts] ‚ö†Ô∏è Nenhuma cena adicional foi gerada nesta tentativa.`);
                }
            } catch (retryError) {
                console.error(`[Scene Prompts] Erro ao tentar gerar cenas faltantes:`, retryError.message);
            }
            
            totalAttempts++;
            
            // Se ainda faltam cenas mas j√° tentamos v√°rias vezes, parar para evitar loop infinito
            if (scenesData.scenes.length < estimatedScenes && totalAttempts >= maxTotalAttempts) {
                console.warn(`[Scene Prompts] ‚ö†Ô∏è Atingido limite de tentativas (${maxTotalAttempts}). Geradas ${scenesData.scenes.length}/${estimatedScenes} cenas.`);
                break;
            }
        }
        
        if (scenesData.scenes.length < estimatedScenes) {
            console.warn(`[Scene Prompts] ‚ö†Ô∏è Apenas ${scenesData.scenes.length} cenas foram geradas, mas esper√°vamos ${estimatedScenes} cenas.`);
        } else {
            console.log(`[Scene Prompts] ‚úÖ Todas as ${estimatedScenes} cenas foram geradas com sucesso!`);
        }

        // Fun√ß√£o auxiliar para limpar nome do modelo (remover fornecedores)
        const cleanModelName = (model) => {
            if (!model) return 'GPT-4o';
            let clean = String(model)
                .replace(/laozhang\.ai/gi, '')
                .replace(/laozhang/gi, '')
                .replace(/openai/gi, '')
                .replace(/anthropic/gi, '')
                .replace(/google/gi, '')
                .trim();
            clean = clean.replace(/^(laozhang-|claude-|gemini-|gpt-|openai-|anthropic-)/i, '');
            clean = clean.replace(/-(laozhang|claude|gemini|gpt|openai|anthropic)$/i, '');
            // Mapear para nomes amig√°veis
            if (clean.includes('gpt-4o')) return 'GPT-4o';
            if (clean.includes('claude-3-7-sonnet') || clean.includes('sonnet-3-7')) return 'Claude 3.7 Sonnet';
            if (clean.includes('claude-sonnet-4') || clean.includes('sonnet-4')) return 'Claude Sonnet 4';
            if (clean.includes('gemini-2.5-pro')) return 'Gemini 2.5 Pro';
            return clean || 'GPT-4o';
        };
        
        // Usar selectedModel se fornecido (modelo selecionado no frontend), sen√£o usar model
        const modelToReturn = cleanModelName(selectedModel || model);
        
        res.json({
            msg: `${scenesData.scenes.length} prompts de cena gerados com sucesso!${scenesData.scenes.length < minScenes ? ` (Esper√°vamos ${estimatedScenes} cenas, mas apenas ${scenesData.scenes.length} foram geradas. Tente novamente ou use um modelo com maior limite de tokens.)` : ''}`,
            scenes: scenesData.scenes,
            modelUsed: modelToReturn, // Retornar apenas o nome do modelo (sem fornecedor)
            expectedScenes: estimatedScenes,
            generatedScenes: scenesData.scenes.length
        });

    } catch (err) {
        console.error('[Scene Prompts] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar prompts de cena.' });
    }
});

// Rota alternativa que SEMPRE usa Laozhang.ai
app.post('/api/generate/scene-prompts/laozhang', authenticateToken, async (req, res) => {
    const { script, style, imageModel, mode, wordsPerScene, unit, characters, selectedModel, isVO3, expectedScenes } = req.body;
    const userId = req.user.id;
    const forVO3 = isVO3 === true || isVO3 === 'true' || isVO3 === 1; // Suporta boolean, string ou n√∫mero

    if (!script || !script.trim()) {
        return res.status(400).json({ msg: 'O roteiro √© obrigat√≥rio.' });
    }

    try {
        // Verificar se deve usar cr√©ditos (laozhang.ai) ou API pr√≥pria
        // REGRA: Usa cr√©ditos se usu√°rio marcou prefer√™ncia OU n√£o tem plano que permite API pr√≥pria OU n√£o tem API pr√≥pria configurada
        // REGRA CR√çTICA: Se prefer√™ncia N√ÉO est√° marcada E usu√°rio tem plano que permite E tem API pr√≥pria ‚Üí usar API pr√≥pria
        
        // Determinar modelo a partir do selectedModel
        let model = selectedModel || 'gpt-4o';
        let service = 'gemini';
        if (model.includes('claude') || model.includes('sonnet')) {
            service = 'claude';
        } else if (model.includes('gpt') || model.includes('openai')) {
            service = 'openai';
        }
        
        // Determinar ordem de prefer√™ncia baseado no modelo
        let preferenceOrder = ['claude', 'openai', 'gemini'];
        if (service === 'gemini') preferenceOrder = ['gemini', 'claude', 'openai'];
        else if (service === 'claude') preferenceOrder = ['claude', 'openai', 'gemini'];
        else if (service === 'openai') preferenceOrder = ['openai', 'claude', 'gemini'];
        
        const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
        
        let useLaozhang = false;
        let apiKeyToUse = null;
        let serviceToUse = null;
        let apiCallFunction = null;
        
        if (creditsCheck.shouldUse) {
            // Se deve usar cr√©ditos, usar laozhang.ai
            const laozhangKey = await getLaozhangApiKey();
            if (laozhangKey) {
                useLaozhang = true;
                apiKeyToUse = laozhangKey;
                serviceToUse = 'laozhang';
                apiCallFunction = callLaozhangAPI;
                console.log(`[Scene Prompts] ‚úÖ Usando Laozhang.ai (${creditsCheck.reason})`);
            } else {
                console.warn('[Scene Prompts] ‚ö†Ô∏è Laozhang.ai n√£o configurada, tentando usar APIs pr√≥prias do usu√°rio');
            }
        } else {
            console.log(`[Scene Prompts] ‚úÖ Usando API pr√≥pria (${creditsCheck.reason})`);
        }
        
        // Se n√£o usar laozhang.ai, usar APIs pr√≥prias do usu√°rio
        if (!useLaozhang) {
            serviceToUse = service;
            
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (!keyData) {
                return res.status(400).json({ msg: `Chave de API do ${service} n√£o configurada. Configure nas Configura√ß√µes.` });
            }
            
            apiKeyToUse = decrypt(keyData.api_key);
            if (!apiKeyToUse) {
                return res.status(500).json({ msg: 'Falha ao descriptografar a chave de API.' });
            }
            
            // Calcular uma estimativa segura de cenas PARA timeout (n√£o usar estimatedScenes aqui,
            // porque ele s√≥ √© inicializado mais abaixo e causava TDZ: "Cannot access 'estimatedScenes' before initialization")
            const wordCountForTimeout = script.trim().split(/\s+/).filter(Boolean).length;
            const estimatedScenesForTimeout = (() => {
                const explicit = parseInt(expectedScenes, 10);
                if (!Number.isNaN(explicit) && explicit > 0) return explicit;
                
                if (mode === 'manual' && wordsPerScene) {
                    const value = parseInt(wordsPerScene, 10);
                    if (!Number.isNaN(value) && value > 0) {
                        const unitType = unit || 'words'; // 'words' ou 'seconds'
                        if (unitType === 'seconds') {
                            // ~2.5 palavras por segundo de narra√ß√£o
                            const wordsPerSecond = 2.5;
                            const wordsPerInterval = value * wordsPerSecond;
                            return Math.max(1, Math.round(wordCountForTimeout / wordsPerInterval));
                        }
                        return Math.max(1, Math.round(wordCountForTimeout / value));
                    }
                }
                
                // Fallback autom√°tico: ~1 cena a cada 90 palavras
                return Math.max(1, Math.round(wordCountForTimeout / 90));
            })();
            
            // Calcular timeout dinamicamente baseado no n√∫mero de cenas esperadas
            // Base: 5 minutos (300s) + 2 segundos por cena adicional acima de 20
            const baseTimeout = 300000; // 5 minutos
            const timeoutPerScene = 2000; // 2 segundos por cena
            const baseScenes = 20;
            const calculatedTimeout = baseTimeout + (Math.max(0, estimatedScenesForTimeout - baseScenes) * timeoutPerScene);
            // Limitar a 20 minutos m√°ximo (1200000ms) para evitar timeouts muito longos
            const scenePromptsTimeout = Math.min(1200000, Math.max(300000, calculatedTimeout));
            
            console.log(`[Scene Prompts] Timeout calculado: ${scenePromptsTimeout/1000}s (${estimatedScenesForTimeout} cenas esperadas)`);
            
            if (service === 'gemini') {
                apiCallFunction = callGeminiAPI;
            } else if (service === 'claude') {
                // Criar wrapper para passar timeout customizado
                apiCallFunction = async (prompt, key, model) => {
                    return await callClaudeAPI(prompt, key, model, null, scenePromptsTimeout);
                };
            } else {
                apiCallFunction = callOpenAIAPI;
            }
        }

        // Usar o n√∫mero exato enviado pelo frontend, ou calcular se n√£o foi enviado
        const wordCount = script.trim().split(/\s+/).filter(Boolean).length;
        let estimatedScenes, minScenes, maxScenes;
        
        if (expectedScenes && parseInt(expectedScenes) > 0) {
            // Usar o n√∫mero exato do frontend
            estimatedScenes = parseInt(expectedScenes);
            minScenes = estimatedScenes;
            maxScenes = estimatedScenes;
            console.log(`[Scene Prompts Laozhang] Usando n√∫mero exato do frontend: ${estimatedScenes} cenas`);
        } else {
            // Calcular n√∫mero estimado de cenas baseado no modo (fallback)
            if (mode === 'manual' && wordsPerScene) {
                const unitType = unit || 'words'; // 'words' ou 'seconds'
                const value = parseInt(wordsPerScene);
                
                if (unitType === 'seconds') {
                    // Modo manual por segundos: assumir ~2.5 palavras por segundo de narra√ß√£o
                    const wordsPerSecond = 2.5;
                    const wordsPerInterval = value * wordsPerSecond;
                    estimatedScenes = Math.max(1, Math.round(wordCount / wordsPerInterval));
                    minScenes = Math.max(1, Math.floor(wordCount / (wordsPerInterval * 1.4)));
                    maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / (wordsPerInterval * 0.6)));
                } else {
                    // Modo manual: baseado em palavras por cena
                    estimatedScenes = Math.max(1, Math.round(wordCount / value));
                    minScenes = Math.max(1, Math.floor(wordCount / (value * 1.4)));
                    maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / (value * 0.6)));
                }
            } else {
                estimatedScenes = Math.max(1, Math.round(wordCount / 90));
                minScenes = Math.max(1, Math.floor(wordCount / 140));
                maxScenes = Math.max(estimatedScenes + 2, Math.ceil(wordCount / 60));
            }
        }

        // ============================================
        // CAMADA 1: √ÇNCORA VISUAL GLOBAL (DIN√ÇMICA BASEADA NO ESTILO)
        // ============================================
        // A √¢ncora visual agora √© gerada dinamicamente baseada no estilo escolhido pelo usu√°rio
        const selectedStyle = style || 'photorealistic';
        const GLOBAL_VISUAL_ANCHOR = getGlobalVisualAnchor(selectedStyle);

        // ============================================
        // CAMADA 2: ESTILO (MODIFICADORES)
        // ============================================
        // O estilo apenas modula ilumina√ß√£o, contraste, paleta, mood
        // N√ÉO pode alterar: tipo de personagem, escala, c√¢mera, realismo
        const styleModifiers = {
            'photorealistic': 'High contrast lighting, sharp focus, professional photography aesthetic, saturated colors.',
            'cinematic': 'Dramatic cinematic lighting, low-key illumination, strong shadows, emotional tension, film-like contrast, controlled color palette.',
            'cinematic-diorama': 'Dramatic cinematic lighting with practical light sources, low-key illumination, strong volumetric shadows, emotional storytelling atmosphere, warm color palette with desaturated shadows.',
            'documentary': 'Natural lighting, authentic moments, journalistic approach, realistic color grading.',
            'cinematic-narrative': 'Story-driven lighting, emotional depth, narrative composition, dramatic shadows.',
            'anime': 'Vibrant colors, expressive lighting, high saturation, dynamic contrast.',
            'cartoon': 'Colorful palette, expressive lighting, high contrast, playful mood.',
            'cartoon-premium': 'Premium animation quality, sophisticated color palette, professional lighting.',
            'fantasy': 'Magical lighting, epic atmosphere, enchanted color palette, mystical elements.',
            'stick-figure': 'Minimalist lighting, simple lines, white background, clean aesthetic.',
            'whiteboard': 'Clean educational lighting, hand-drawn illustrations, minimalist aesthetic.',
            'tech-minimalist': 'Modern clean lighting, futuristic aesthetic, minimalist design.',
            'spiritual-minimalist': 'Serene lighting, meditative atmosphere, zen aesthetic, soft illumination.',
            'viral-vibrant': 'High contrast, saturated colors, social media optimized, vibrant palette.',
            'modern-documentary': 'Dynamic contemporary lighting, authentic moments, modern color grading.',
            'analog-horror': 'VHS quality grain, retro horror aesthetic, low-fi texture, analog degradation.',
            'dark-theater': 'Dramatic stage lighting, intense shadows, theatrical illumination.',
            'naturalist-drama': 'Realistic emotional lighting, authentic human moments, natural color palette.',
            'spiritual-neorealism': 'Transcendent realistic lighting, mystical atmosphere, spiritual color grading.',
            'psychological-surrealism': 'Dreamlike lighting, abstract reality, surreal color palette.',
            'fragmented-memory': 'Collage aesthetic, fragmented composition, layered lighting.',
            'fragmented-narrative': 'Fragmented narrative style, collage composition, layered visual narrative.',
            'dream-real': 'Liminal space lighting, ethereal atmosphere, dream-reality blend.',
            'vhs-nostalgic': 'VHS nostalgic aesthetic, retro 80s/90s quality, vintage grain, analog texture.'
        };
        
        // Modificador adicional opcional para refinar ainda mais o estilo
        const styleModifier = style && style !== 'none' && styleModifiers[style] 
            ? `\n\nüé® REFINAMENTO DE ESTILO (${style}):\n${styleModifiers[style]}\n\n‚ö†Ô∏è Este refinamento complementa a √Çncora Visual Global acima, ajustando detalhes de ilumina√ß√£o, contraste e paleta de cores.` 
            : '';
        const imageModelInstruction = imageModel ? ` Os prompts devem ser otimizados para ${imageModel}.` : '';
        const charactersInstruction = characters ? `\n\nPERSONAGENS CONSISTENTES:\n${characters}\n\nIMPORTANTE: Use essas descri√ß√µes de personagens de forma consistente em todas as cenas onde eles aparecerem.` : '';
        
        // Instru√ß√µes espec√≠ficas para VO3 (mesmas da rota principal)
        const vo3Instructions = forVO3 ? `
        
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è MODO VO3 ATIVADO - OTIMIZA√á√ÉO PARA GERA√á√ÉO DE V√çDEO ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
Os prompts devem ser OTIMIZADOS ESPECIFICAMENTE para o modelo VO3 (gera√ß√£o de v√≠deo).

REGRAS CR√çTICAS PARA VO3:
1. MOVIMENTO E A√á√ÉO: Cada prompt DEVE descrever movimento, a√ß√£o ou transi√ß√£o. VO3 precisa de elementos din√¢micos para gerar v√≠deo fluido.
   - Use verbos de a√ß√£o: "walking", "running", "flying", "rotating", "approaching", "receding", "panning", "zooming"
   - Descreva dire√ß√£o de movimento: "from left to right", "approaching camera", "flying away", "spinning clockwise"
   - Inclua transi√ß√µes: "fade in", "slow reveal", "gradual zoom", "smooth pan"

2. SFX (EFEITOS SONOROS) EMBUTIDOS: Cada prompt DEVE incluir descri√ß√µes de efeitos sonoros relevantes para a cena, usando a sintaxe: [SFX: descri√ß√£o do som]
   - Exemplos: [SFX: distant explosion, rumbling], [SFX: footsteps on gravel, crunching], [SFX: wind howling, atmospheric], [SFX: engine revving, mechanical], [SFX: water splashing, liquid], [SFX: door creaking, wooden], [SFX: birds chirping, nature], [SFX: crowd murmuring, ambient], [SFX: glass breaking, shattering], [SFX: thunder rumbling, weather]
   - Inclua SFX que fa√ßa sentido para a a√ß√£o visual descrita
   - Use 1-3 SFX por cena, dependendo da complexidade
   - SFX deve estar ENTRE PAR√äNTESES QUADRADOS no formato [SFX: nome do som, categoria]

3. DURA√á√ÉO E RITMO: Indique o ritmo/tempo da cena quando relevante
   - "slow motion", "time-lapse", "real-time", "fast-paced", "leisurely pace"

4. CONTINUIDADE VISUAL: Mantenha consist√™ncia entre cenas consecutivas
   - Se uma cena termina com um personagem √† esquerda, a pr√≥xima pode come√ßar com ele √† direita (mostrando movimento)
   - Descreva posi√ß√µes relativas que permitam transi√ß√µes suaves

5. ELEMENTOS CINEMATOGR√ÅFICOS PARA V√çDEO:
   - Movimentos de c√¢mera: "camera panning left", "dolly forward", "crane shot rising", "handheld following"
   - Profundidade din√¢mica: "foreground elements moving", "background parallax", "layered movement"
   - Mudan√ßas de foco: "rack focus from A to B", "shallow focus transitioning"

FORMATO DO PROMPT PARA VO3:
Cada prompt_text deve seguir este padr√£o:
"[Descri√ß√£o visual detalhada com movimento e a√ß√£o] [SFX: som1, categoria1] [SFX: som2, categoria2] [Movimento de c√¢mera] [Ritmo/tempo]"

EXEMPLO DE PROMPT VO3:
"Aerial view of a military helicopter flying low over a desert landscape, rotor blades spinning rapidly, dust clouds trailing behind, camera tracking the helicopter from behind and slightly above, smooth forward motion, golden hour lighting casting long shadows, [SFX: helicopter rotor blades, mechanical] [SFX: wind rushing, atmospheric] [SFX: distant engine roar, vehicle] - fast-paced action sequence, dynamic camera movement"` : '';

        const prompt = `${GLOBAL_VISUAL_ANCHOR}${styleModifier}

Voc√™ √© um especialista em cria√ß√£o de prompts para ${forVO3 ? 'gera√ß√£o de v√≠deo (VO3)' : 'gera√ß√£o de imagens'} usando IA.

TAREFA:
Analise o roteiro fornecido e crie prompts detalhados para cada cena do v√≠deo. Cada prompt deve descrever visualmente o que deve aparecer ${forVO3 ? 'no v√≠deo' : 'na imagem'} para aquela parte do roteiro.${vo3Instructions}

ROTEIRO:
"""
${script}
"""

INSTRU√á√ïES:
1. üîí OBRIGAT√ìRIO: TODAS as cenas DEVEM seguir a √ÇNCORA VISUAL GLOBAL acima. Esta √© a base visual definida pelo estilo escolhido (${selectedStyle}).
2. üé® O estilo "${selectedStyle}" foi selecionado pelo usu√°rio. TODOS os prompts devem seguir este estilo visual consistentemente.
3. ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - N√öMERO EXATO DE CENAS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è: Voc√™ DEVE gerar EXATAMENTE ${estimatedScenes} cenas. N√ÉO mais, N√ÉO menos. O frontend espera ${estimatedScenes} cenas e voc√™ DEVE entregar todas elas. Se a resposta ficar muito longa, continue mesmo assim. √â OBRIGAT√ìRIO gerar todas as ${estimatedScenes} cenas.
4. Cada prompt deve ter entre ${forVO3 ? '800-1500' : '600-1200'} caracteres${forVO3 ? ' (VO3 precisa de mais detalhes para movimento e SFX)' : ''}
5. Cada prompt deve ser em INGL√äS e otimizado para ${forVO3 ? 'gera√ß√£o de v√≠deo (VO3)' : 'gera√ß√£o de imagens'}
6. Seja espec√≠fico e detalhado: descreva composi√ß√£o, ilumina√ß√£o, cores, atmosfera, personagens, cen√°rio${forVO3 ? ', movimento, a√ß√£o, transi√ß√µes e efeitos sonoros' : ''}
7. Use termos t√©cnicos de fotografia/cinematografia quando apropriado${imageModelInstruction}${charactersInstruction}
8. ‚ö†Ô∏è CR√çTICO: Cada prompt_text DEVE seguir o estilo "${selectedStyle}" consistentemente. Todas as cenas devem pertencer ao mesmo mundo visual definido pela √Çncora Visual Global.
9. üîß REFOR√áO DE ESTILO: Cada prompt_text DEVE incluir elementos espec√≠ficos do estilo "${selectedStyle}" conforme definido na √Çncora Visual Global acima. Use as frases de refor√ßo apropriadas para o estilo escolhido.

FORMATO DE RESPOSTA (JSON):
{
  "scenes": [
    {
      "scene_number": 1,
      "scene_description": "Breve descri√ß√£o da cena",
      "prompt_text": "Prompt detalhado em ingl√™s para ${forVO3 ? 'gera√ß√£o de v√≠deo VO3 com SFX embutido' : 'gera√ß√£o de imagem'} (${forVO3 ? '800-1500' : '600-1200'} caracteres)${forVO3 ? ' - DEVE incluir [SFX: ...] e descri√ß√µes de movimento' : ''}"
    },
    ...
  ]
}

IMPORTANTE: 
- Retorne APENAS o JSON, sem texto adicional
- Certifique-se de que cada prompt_text tem entre ${forVO3 ? '800-1500' : '600-1200'} caracteres
${forVO3 ? '- TODOS os prompts DEVE incluir pelo menos 1-3 SFX no formato [SFX: nome do som, categoria]\n- TODOS os prompts DEVE descrever movimento, a√ß√£o ou transi√ß√£o para VO3\n' : ''}
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è REGRA ABSOLUTA - N√öMERO DE CENAS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è:
- Voc√™ DEVE gerar EXATAMENTE ${estimatedScenes} cenas. N√ÉO ${minScenes}, N√ÉO ${maxScenes}, mas EXATAMENTE ${estimatedScenes} cenas.
- O JSON DEVE conter um array "scenes" com EXATAMENTE ${estimatedScenes} objetos.
- N√ÉO pare antes de gerar todas as ${estimatedScenes} cenas, mesmo que a resposta fique muito longa.
- Se voc√™ gerar menos de ${estimatedScenes} cenas, a resposta ser√° considerada INCOMPLETA e REJEITADA.
- O roteiro tem ${wordCount} palavras, o que justifica ${estimatedScenes} cenas. Gere TODAS elas.
- Comece pela cena 1 e continue at√© a cena ${estimatedScenes}. N√ÉO pule nenhuma cena.
- √â CR√çTICO e OBRIGAT√ìRIO que o array "scenes" tenha EXATAMENTE ${estimatedScenes} elementos.`;

        // Mapear modelo selecionado para modelo da API (Laozhang ou pr√≥pria)
        let modelForAPI = null;
        if (useLaozhang) {
            // Mapear para modelo Laozhang
            if (selectedModel === 'gpt-4o' || selectedModel === 'GPT-4o (2025)') {
                modelForAPI = 'gpt-4o';
            } else if (selectedModel === 'claude-3-7-sonnet-20250219' || selectedModel === 'Claude 3.7 Sonnet (Fev/25)') {
                modelForAPI = 'claude-3-7-sonnet-20250219';
            } else if (selectedModel === 'gemini-2.5-pro' || selectedModel === 'Gemini 2.5 Pro (2025)') {
                modelForAPI = 'gemini-2.5-pro';
            } else if (selectedModel && selectedModel.includes('claude')) {
                modelForAPI = 'claude-3-7-sonnet-20250219';
            } else if (selectedModel && selectedModel.includes('gemini')) {
                modelForAPI = 'gemini-2.5-pro';
            } else if (selectedModel && selectedModel.includes('gpt')) {
                modelForAPI = 'gpt-4o';
            } else {
                modelForAPI = selectedModel || 'gpt-4o';
            }
        } else {
            // Usar modelo original para API pr√≥pria
            modelForAPI = selectedModel || model;
        }
        
        // Se ainda n√£o tem modelo, usar 'gpt-4o' apenas como √∫ltimo recurso
        if (!modelForAPI) {
            console.warn(`[Scene Prompts] ‚ö†Ô∏è Modelo n√£o fornecido ou n√£o reconhecido, usando 'gpt-4o' como fallback`);
            modelForAPI = 'gpt-4o';
        }
        
        console.log(`[Scene Prompts] Modelo recebido: "${selectedModel || 'N/A'}" -> Mapeado para API: "${modelForAPI}" (${useLaozhang ? 'Laozhang' : serviceToUse})`);
        
        // Chamar API apropriada
        let response;
        // Calcular timeout dinamicamente baseado no n√∫mero de cenas esperadas (antes de chamar a API)
        const baseTimeout = 300000; // 5 minutos
        const timeoutPerScene = 2000; // 2 segundos por cena
        const baseScenes = 20;
        const calculatedTimeout = baseTimeout + (Math.max(0, estimatedScenes - baseScenes) * timeoutPerScene);
        const scenePromptsTimeout = Math.min(1200000, Math.max(300000, calculatedTimeout));
        
        console.log(`[Scene Prompts Laozhang] Timeout calculado: ${scenePromptsTimeout/1000}s (${estimatedScenes} cenas esperadas)`);
        
        if (useLaozhang) {
            response = await callLaozhangAPI(
                prompt, 
                apiKeyToUse, 
                modelForAPI, 
                null, 
                userId, 
                '/api/generate/scene-prompts/laozhang', 
                JSON.stringify({ endpoint: '/api/generate/scene-prompts/laozhang', model: modelForAPI, estimatedScenes, timeout: scenePromptsTimeout })
            );
            // callLaozhangAPI retorna string diretamente
            response = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        } else {
            if (serviceToUse === 'claude') {
                console.log(`[Scene Prompts] Usando timeout estendido de ${scenePromptsTimeout/1000}s para Claude (gera√ß√£o de m√∫ltiplas cenas)`);
                response = await callClaudeAPI(prompt, apiKeyToUse, modelForAPI, null, scenePromptsTimeout);
            } else {
                response = await apiCallFunction(prompt, apiKeyToUse, modelForAPI);
            }
            // APIs pr√≥prias retornam objeto com propriedade titles
            if (response && typeof response === 'object' && response.titles) {
                response = response.titles;
            } else if (typeof response === 'string') {
                response = response.trim();
            } else {
                response = JSON.stringify(response);
            }
        }

        // Parsear resposta - callLaozhangAPI retorna string diretamente agora
        let scenesData;
        let rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        console.log(`[Scene Prompts] Resposta bruta (primeiros 500 chars):`, rawResponse.substring(0, 500));
        
        // Limpar markdown code blocks primeiro
        rawResponse = rawResponse
            .replace(/^```json\s*/i, '')  // Remover ```json no in√≠cio
            .replace(/^```\s*/i, '')      // Remover ``` no in√≠cio
            .replace(/\s*```\s*$/i, '')   // Remover ``` no final
            .trim();
        
        // Verificar se a API recusou a requisi√ß√£o (apenas se for uma mensagem de erro clara, n√£o JSON v√°lido)
        // Primeiro, tentar verificar se h√° JSON v√°lido na resposta
        const hasValidJson = rawResponse.match(/\{[\s\S]*"scenes"[\s\S]*\}/) || rawResponse.match(/\{[\s\S]*"scene_number"[\s\S]*\}/);
        
        // Se n√£o h√° JSON v√°lido, verificar se √© uma mensagem de erro da API
        if (!hasValidJson) {
            const errorPatterns = [
                /^I'm sorry,?\s+I can't assist/i,
                /^I'm sorry,?\s+I cannot/i,
                /^I'm unable to assist/i,
                /^I cannot fulfill/i,
                /^I must decline/i,
                /^I can't help with that/i,
                /^I'm not able to/i,
                /^This request violates/i,
                /^I cannot comply/i
            ];
            
            const trimmedResponse = rawResponse.trim();
            const isError = errorPatterns.some(pattern => pattern.test(trimmedResponse));
            
            // Tamb√©m verificar se √© uma resposta muito curta (menos de 100 chars) que come√ßa com mensagem de erro
            if (isError || (trimmedResponse.length < 100 && trimmedResponse.toLowerCase().startsWith("i'm sorry"))) {
                console.error('[Scene Prompts] API recusou a requisi√ß√£o:', rawResponse.substring(0, 500));
                throw new Error(`A API de IA recusou processar o prompt. Isso pode acontecer se o conte√∫do violar as pol√≠ticas de uso da API. Tente simplificar o roteiro ou remover conte√∫do sens√≠vel. Resposta: ${rawResponse.substring(0, 500)}`);
            }
        }
        
        try {
            // Tentar parsear diretamente
            scenesData = JSON.parse(rawResponse);
        } catch (e) {
            console.log('[Scene Prompts] Tentativa 1 de parsing falhou, tentando extrair JSON...');
            // Tentar extrair JSON usando regex (procurar por { ... } completo)
            const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    let jsonStr = jsonMatch[0];
                    // Limpar mais caracteres problem√°ticos
                    jsonStr = jsonStr
                        .replace(/```json\s*/gi, '')
                        .replace(/```\s*/g, '')
                        .replace(/^[^{]*/, '')  // Remover texto antes do {
                        .replace(/[^}]*$/, ''); // Remover texto depois do }
                    
                    scenesData = JSON.parse(jsonStr);
                } catch (e2) {
                    console.log('[Scene Prompts] Tentativa 2 de parsing falhou, tentando corrigir JSON truncado...');
                    // Tentar encontrar o array de scenes diretamente
                    const scenesArrayMatch = rawResponse.match(/"scenes"\s*:\s*\[([\s\S]*?)\]/);
                    if (scenesArrayMatch) {
                        try {
                            // Tentar construir JSON v√°lido com o array encontrado
                            let scenesArrayStr = scenesArrayMatch[1];
                            // Tentar fechar o array corretamente
                            if (!scenesArrayStr.trim().endsWith('}')) {
                                // Procurar por objetos de cena completos
                                const sceneObjects = scenesArrayStr.match(/\{[^{}]*\}/g);
                                if (sceneObjects && sceneObjects.length > 0) {
                                    scenesArrayStr = sceneObjects.join(',\n');
                                }
                            }
                            scenesData = JSON.parse(`{"scenes": [${scenesArrayStr}]}`);
                        } catch (e3) {
                            console.log('[Scene Prompts] Tentativa 3 de parsing falhou, tentando extrair cenas individuais...');
                            // √öltima tentativa: extrair cenas individuais parseando objetos JSON completos
                            const simpleScenePattern = /\{\s*"scene_number"\s*:\s*\d+[\s\S]*?\}/g;
                            const simpleMatches = rawResponse.match(simpleScenePattern);
                            if (simpleMatches && simpleMatches.length > 0) {
                                const parsedScenes = [];
                                for (const sceneStr of simpleMatches) {
                                    try {
                                        const scene = JSON.parse(sceneStr);
                                        if (scene.scene_number && (scene.prompt_text || scene.prompt || scene.text)) {
                                            parsedScenes.push({
                                                scene_number: scene.scene_number || scene.number || parsedScenes.length + 1,
                                                scene_description: scene.scene_description || scene.description || `Cena ${parsedScenes.length + 1}`,
                                                prompt_text: scene.prompt_text || scene.prompt || scene.text || ''
                                            });
                                        }
                                    } catch (parseErr) {
                                        console.warn('[Scene Prompts] Erro ao parsear cena individual:', parseErr.message);
                                    }
                                }
                                if (parsedScenes.length > 0) {
                                    scenesData = { scenes: parsedScenes };
                                    console.log(`[Scene Prompts] ‚úÖ Extra√≠das ${parsedScenes.length} cenas parseando objetos individuais!`);
                                } else {
                                    throw new Error(`N√£o foi poss√≠vel extrair cenas da resposta. Primeiros 1000 caracteres: ${rawResponse.substring(0, 1000)}`);
                                }
                            } else {
                                throw new Error(`N√£o foi poss√≠vel extrair cenas da resposta. Primeiros 1000 caracteres: ${rawResponse.substring(0, 1000)}`);
                            }
                        }
                    } else {
                        throw new Error(`Nenhum JSON encontrado na resposta. Primeiros 500 caracteres: ${rawResponse.substring(0, 500)}`);
                    }
                }
            } else {
                throw new Error(`Nenhum JSON encontrado na resposta. Primeiros 500 caracteres: ${rawResponse.substring(0, 500)}`);
            }
        }

        if (!scenesData.scenes || !Array.isArray(scenesData.scenes)) {
            // Tentar encontrar scenes em diferentes n√≠veis
            console.log('[Scene Prompts] Tentando encontrar scenes em diferentes n√≠veis...');
            console.log('[Scene Prompts] Estrutura completa:', JSON.stringify(scenesData).substring(0, 1000));
            
            // Procurar scenes em qualquer n√≠vel
            const findScenes = (obj, path = '') => {
                if (Array.isArray(obj) && obj.length > 0 && obj[0].prompt_text) {
                    return obj;
                }
                if (typeof obj === 'object' && obj !== null) {
                    for (const key in obj) {
                        if (key === 'scenes' && Array.isArray(obj[key])) {
                            return obj[key];
                        }
                        const found = findScenes(obj[key], `${path}.${key}`);
                        if (found) return found;
                    }
                }
                return null;
            };
            
            const foundScenes = findScenes(scenesData);
            if (foundScenes && Array.isArray(foundScenes)) {
                console.log('[Scene Prompts] ‚úÖ Scenes encontradas em n√≠vel aninhado!');
                scenesData.scenes = foundScenes;
            } else {
                throw new Error(`A IA n√£o retornou a estrutura esperada. Verifique se a resposta cont√©m um campo "scenes". Estrutura recebida: ${JSON.stringify(scenesData).substring(0, 500)}`);
            }
        }

        const validScenes = scenesData.scenes.filter(scene => 
            scene && 
            (scene.prompt_text || scene.prompt || scene.text) &&
            (scene.scene_description || scene.description || scene.scene_number || scene.number)
        );
        
        if (validScenes.length === 0) {
            throw new Error('Nenhuma cena v√°lida encontrada na resposta da IA.');
        }

        scenesData.scenes = validScenes.map((scene, index) => ({
            scene_number: scene.scene_number || scene.number || (index + 1),
            scene_description: scene.scene_description || scene.description || `Cena ${index + 1}`,
            prompt_text: scene.prompt_text || scene.prompt || scene.text || ''
        }));

        console.log(`[Scene Prompts] ‚úÖ ${scenesData.scenes.length} cenas parseadas com sucesso!`);
        
        // Verificar se gerou todas as cenas esperadas e tentar gerar as faltantes at√© completar
        let totalAttempts = 0;
        const maxTotalAttempts = 5; // M√°ximo de 5 tentativas totais para gerar todas as cenas
        
        while (scenesData.scenes.length < estimatedScenes && totalAttempts < maxTotalAttempts) {
            const missingScenes = estimatedScenes - scenesData.scenes.length;
            console.warn(`[Scene Prompts] ‚ö†Ô∏è Apenas ${scenesData.scenes.length} cenas foram geradas, mas esper√°vamos ${estimatedScenes} cenas. Faltam ${missingScenes} cenas. Tentativa ${totalAttempts + 1}/${maxTotalAttempts}...`);
            
            // Tentar gerar as cenas faltantes usando a fun√ß√£o de retry
            try {
                let apiCallFunction;
                if (useLaozhang && apiKeyToUse) {
                    apiCallFunction = (prompt, key, model) => callLaozhangAPI(prompt, key, model, null, userId, '/api/generate/scene-prompts/laozhang', JSON.stringify({ endpoint: '/api/generate/scene-prompts/laozhang', model }));
                } else if (serviceToUse === 'gemini') {
                    apiCallFunction = callGeminiAPI;
                } else if (serviceToUse === 'claude') {
                    // Usar o timeout calculado anteriormente (scenePromptsTimeout)
                    apiCallFunction = (prompt, key, model) => callClaudeAPI(prompt, key, model, null, scenePromptsTimeout);
                } else {
                    apiCallFunction = callOpenAIAPI;
                }
                
                const additionalScenes = await generateScenesWithRetries({
                    apiFunc: apiCallFunction,
                    apiKey: apiKeyToUse,
                    model: model,
                    script: script,
                    styleInstruction: styleModifier,
                    imageModelInstruction: imageModelInstruction,
                    charactersInstruction: charactersInstruction,
                    estimatedScenes: missingScenes,
                    minScenes: missingScenes, // Exigir exatamente o n√∫mero faltante
                    maxScenes: missingScenes, // Exigir exatamente o n√∫mero faltante
                    wordCount: wordCount,
                    serviceLabel: useLaozhang ? 'Laozhang' : serviceToUse,
                    maxAttempts: 3
                });
                
                if (additionalScenes && additionalScenes.length > 0) {
                    // Ajustar n√∫meros das cenas para continuar a sequ√™ncia
                    const lastSceneNumber = scenesData.scenes.length;
                    additionalScenes.forEach((scene, idx) => {
                        scene.scene_number = lastSceneNumber + idx + 1;
                    });
                    scenesData.scenes = scenesData.scenes.concat(additionalScenes);
                    console.log(`[Scene Prompts] ‚úÖ ${additionalScenes.length} cenas adicionais geradas! Total: ${scenesData.scenes.length}/${estimatedScenes} cenas.`);
                } else {
                    console.warn(`[Scene Prompts] ‚ö†Ô∏è Nenhuma cena adicional foi gerada nesta tentativa.`);
                }
            } catch (retryError) {
                console.error(`[Scene Prompts] Erro ao tentar gerar cenas faltantes:`, retryError.message);
            }
            
            totalAttempts++;
            
            // Se ainda faltam cenas mas j√° tentamos v√°rias vezes, parar para evitar loop infinito
            if (scenesData.scenes.length < estimatedScenes && totalAttempts >= maxTotalAttempts) {
                console.warn(`[Scene Prompts] ‚ö†Ô∏è Atingido limite de tentativas (${maxTotalAttempts}). Geradas ${scenesData.scenes.length}/${estimatedScenes} cenas.`);
                break;
            }
        }
        
        if (scenesData.scenes.length < estimatedScenes) {
            console.warn(`[Scene Prompts] ‚ö†Ô∏è Apenas ${scenesData.scenes.length} cenas foram geradas, mas esper√°vamos ${estimatedScenes} cenas.`);
        } else {
            console.log(`[Scene Prompts] ‚úÖ Todas as ${estimatedScenes} cenas foram geradas com sucesso!`);
        }

        // Limpar nome do modelo (remover prefixos de fornecedores)
        const cleanModelName = (model) => {
            if (!model) return 'GPT-4o';
            // Remover prefixos de fornecedores
            let clean = model.replace(/^(laozhang-|claude-|gemini-|gpt-)/i, '');
            // Mapear para nomes amig√°veis
            if (clean.includes('gpt-4o')) return 'GPT-4o';
            if (clean.includes('claude-3-7-sonnet') || clean.includes('sonnet-3-7')) return 'Claude 3.7 Sonnet';
            if (clean.includes('claude-sonnet-4') || clean.includes('sonnet-4')) return 'Claude Sonnet 4';
            if (clean.includes('gemini-2.5-pro')) return 'Gemini 2.5 Pro';
            if (clean.includes('gemini-2.5-flash')) return 'Gemini 2.5 Flash';
            return clean || 'GPT-4o';
        };
        
        const modelToReturn = cleanModelName(selectedModel || 'gpt-4o');
        
        res.json({
            msg: `${scenesData.scenes.length} prompts de cena gerados com sucesso!${scenesData.scenes.length < minScenes ? ` (Esper√°vamos ${estimatedScenes} cenas, mas apenas ${scenesData.scenes.length} foram geradas. Tente novamente.)` : ''}`,
            scenes: scenesData.scenes,
            modelUsed: modelToReturn, // Retornar apenas o nome do modelo (sem fornecedor)
            expectedScenes: estimatedScenes,
            generatedScenes: scenesData.scenes.length
        });

    } catch (err) {
        console.error('[Scene Prompts] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar prompts de cena.' });
    }
});

// === ROTAS DE HIST√ìRICO DE PROMPTS DE CENA ===

// Salvar no hist√≥rico
app.post('/api/scene-prompts/history', authenticateToken, async (req, res) => {
    const { script, scenes, model, style, mode, wordsPerScene, characters, title } = req.body;
    const userId = req.user.id;

    if (!script || !scenes || !Array.isArray(scenes)) {
        return res.status(400).json({ msg: 'Script e cenas s√£o obrigat√≥rios.' });
    }

    try {
        // Garantir que a tabela existe
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        const result = await db.run(
            `INSERT INTO scene_prompts_history 
             (user_id, title, script, scenes_json, model, style, mode, words_per_scene, characters, scene_count)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
                userId,
                title || `Prompts gerados em ${new Date().toLocaleString('pt-BR')}`,
                script,
                JSON.stringify(scenes),
                model || null,
                style || null,
                mode || 'automatic',
                wordsPerScene || null,
                characters || null,
                scenes.length
            ]
        );

        res.json({ msg: 'Hist√≥rico salvo com sucesso!', id: result.lastID });
    } catch (err) {
        console.error('[Scene Prompts History] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao salvar hist√≥rico.' });
    }
});

// Listar hist√≥rico
app.get('/api/scene-prompts/history', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { limit = 20 } = req.query;

    try {
        // Garantir que a tabela existe
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        const history = await db.all(
            `SELECT id, title, scene_count, model, style, mode, created_at 
             FROM scene_prompts_history 
             WHERE user_id = ? 
             ORDER BY created_at DESC 
             LIMIT ?`,
            [userId, parseInt(limit)]
        );

        res.json({ history: history || [] });
    } catch (err) {
        console.error('[Scene Prompts History] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao carregar hist√≥rico.' });
    }
});

// Carregar prompt espec√≠fico
app.get('/api/scene-prompts/history/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;

    try {
        // Garantir que a tabela existe
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        const item = await db.get(
            `SELECT * FROM scene_prompts_history WHERE id = ? AND user_id = ?`,
            [id, userId]
        );

        if (!item) {
            return res.status(404).json({ msg: 'Prompt n√£o encontrado.' });
        }

        res.json({
            id: item.id,
            title: item.title,
            script: item.script,
            scenes: JSON.parse(item.scenes_json),
            model: item.model,
            style: item.style,
            mode: item.mode,
            wordsPerScene: item.words_per_scene,
            characters: item.characters,
            scene_count: item.scene_count,
            created_at: item.created_at
        });
    } catch (err) {
        console.error('[Scene Prompts History] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao carregar prompt.' });
    }
});

// Deletar prompt do hist√≥rico
app.delete('/api/scene-prompts/history/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;

    try {
        // Garantir que a tabela existe
        await db.exec(`
            CREATE TABLE IF NOT EXISTS scene_prompts_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                title TEXT,
                script TEXT NOT NULL,
                scenes_json TEXT NOT NULL,
                model TEXT,
                style TEXT,
                mode TEXT,
                words_per_scene INTEGER,
                characters TEXT,
                scene_count INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
        
        const result = await db.run(
            `DELETE FROM scene_prompts_history WHERE id = ? AND user_id = ?`,
            [id, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Prompt n√£o encontrado.' });
        }

        res.json({ msg: 'Prompt exclu√≠do com sucesso!' });
    } catch (err) {
        console.error('[Scene Prompts History] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao excluir prompt.' });
    }
});

// === ROTA PARA DETECTAR PERSONAGENS NO ROTEIRO ===
app.post('/api/detect/characters', authenticateToken, async (req, res) => {
    const { script, model } = req.body;
    const userId = req.user.id;

    if (!script || !script.trim()) {
        return res.status(400).json({ msg: 'O roteiro √© obrigat√≥rio.' });
    }

    if (!model) {
        return res.status(400).json({ msg: 'O modelo de IA √© obrigat√≥rio.' });
    }

    try {
        // Determinar qual servi√ßo usar baseado no modelo
        let service = 'gemini';
        if (model.includes('claude') || model.includes('sonnet')) {
            service = 'claude';
        } else if (model.includes('gpt') || model.includes('openai')) {
            service = 'openai';
        }

        // Buscar chave de API
        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
        if (!keyData) {
            return res.status(400).json({ msg: `Chave de API do ${service} n√£o configurada. Configure nas Configura√ß√µes.` });
        }

        const decryptedKey = decrypt(keyData.api_key);
        if (!decryptedKey) {
            return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
        }

        const prompt = `Voc√™ √© um diretor de elenco especializado em analisar roteiros e identificar personagens para gera√ß√£o de imagens com IA.

**ROTEIRO PARA ANALISAR:**
${script}

---

**INSTRU√á√ïES:**
1. Identifique todos os personagens principais e secund√°rios mencionados no roteiro.
2. Para cada personagem, crie uma descri√ß√£o concisa e pr√°tica que inclua:
   - Nome do personagem (ou descri√ß√£o se n√£o tiver nome)
   - Idade aparente
   - Apar√™ncia f√≠sica (cor de cabelo, olhos, tipo f√≠sico, tra√ßos distintivos)
   - Vestimentas principais
   - Caracter√≠sticas visuais importantes para manter consist√™ncia

3. **FORMATO DE SA√çDA OBRIGAT√ìRIO:** Voc√™ DEVE retornar um objeto JSON com a seguinte estrutura exata:
{
  "characters": [
    "Nome, idade, descri√ß√£o f√≠sica e caracter√≠sticas visuais",
    "Outro personagem, idade, descri√ß√£o f√≠sica e caracter√≠sticas visuais"
  ]
}

**EXEMPLO DE FORMATO:**
{
  "characters": [
    "Jo√£o, um homem de 40 anos, cabelo grisalho, √≥culos, rosto marcado, vestindo terno escuro",
    "Maria, uma jovem de 25 anos, cabelo longo e ruivo, olhos verdes, vestindo vestido casual"
  ]
}

**REGRA CR√çTICA:**
- Retorne APENAS o JSON v√°lido, sem texto adicional antes ou depois
- Cada string no array deve ser uma descri√ß√£o completa e pr√°tica do personagem
- Foque em caracter√≠sticas visuais que ajudem a manter consist√™ncia nas imagens geradas
- Se um personagem n√£o tem nome, use uma descri√ß√£o clara (ex: "Policial veterano, 50 anos, cabelo grisalho curto, uniforme azul")
- Limite a descri√ß√£o de cada personagem a uma linha, mas seja completo e detalhado
- Retorne no formato JSON exato especificado acima, com a propriedade "characters" contendo um array de strings

**AGORA ANALISE O ROTEIRO FORNECIDO E RETORNE O JSON COM OS PERSONAGENS IDENTIFICADOS:**`;

        let apiCallFunction;
        if (service === 'gemini') apiCallFunction = callGeminiAPI;
        else if (service === 'claude') apiCallFunction = callClaudeAPI;
        else apiCallFunction = callOpenAIAPI;

        console.log(`[Detect Characters] Detectando personagens com ${service} (modelo: ${model})...`);
        const rawResponse = await apiCallFunction(prompt, decryptedKey, model);

        // Parse robusto da resposta
        let characters = [];
        let parsedData = null;

        // Tentar extrair JSON da resposta
        if (typeof rawResponse === 'string') {
            try {
                parsedData = JSON.parse(rawResponse);
            } catch (e) {
                // Tentar extrair JSON de dentro de markdown ou texto
                const jsonMatch = rawResponse.match(/\{[\s\S]*"characters"[\s\S]*\[[\s\S]*\][\s\S]*\}/);
                if (jsonMatch) {
                    try {
                        parsedData = JSON.parse(jsonMatch[0]);
                    } catch (e2) {
                        console.warn('[Detect Characters] Erro ao parsear JSON extra√≠do:', e2);
                    }
                }
            }
        } else {
            parsedData = rawResponse;
        }

        // Extrair characters de diferentes estruturas poss√≠veis
        if (parsedData) {
            // Caso 1: { characters: [...] }
            if (parsedData.characters && Array.isArray(parsedData.characters)) {
                characters = parsedData.characters;
            }
            // Caso 2: { data: { characters: [...] } }
            else if (parsedData.data && parsedData.data.characters && Array.isArray(parsedData.data.characters)) {
                characters = parsedData.data.characters;
            }
            // Caso 3: { data: [...] }
            else if (parsedData.data && Array.isArray(parsedData.data)) {
                characters = parsedData.data;
            }
            // Caso 4: { titles: "..." } - tentar parsear o conte√∫do
            else if (parsedData.titles && typeof parsedData.titles === 'string') {
                try {
                    const titlesParsed = JSON.parse(parsedData.titles);
                    if (titlesParsed.characters && Array.isArray(titlesParsed.characters)) {
                        characters = titlesParsed.characters;
                    } else if (Array.isArray(titlesParsed)) {
                        characters = titlesParsed;
                    }
                } catch (e) {
                    // Tentar extrair JSON do texto
                    const jsonMatch = parsedData.titles.match(/\{[\s\S]*"characters"[\s\S]*\[[\s\S]*\][\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            const extracted = JSON.parse(jsonMatch[0]);
                            if (extracted.characters && Array.isArray(extracted.characters)) {
                                characters = extracted.characters;
                            }
                        } catch (e2) {
                            console.warn('[Detect Characters] Erro ao parsear JSON de titles:', e2);
                        }
                    }
                }
            }
            // Caso 5: Buscar qualquer array no objeto
            else {
                for (const key in parsedData) {
                    if (Array.isArray(parsedData[key])) {
                        characters = parsedData[key];
                        break;
                    }
                }
            }
        }

        // Filtrar e limpar personagens
        if (characters.length > 0) {
            characters = characters
                .filter(char => char && typeof char === 'string' && char.trim().length > 0)
                .map(char => char.trim());
        }

        if (characters.length === 0) {
            return res.status(400).json({ 
                msg: 'Nenhum personagem foi detectado. Verifique se o roteiro cont√©m personagens identific√°veis.',
                characters: '',
                charactersList: []
            });
        }

        // Formatar para o campo de texto (uma linha por personagem)
        const charactersText = characters.join('\n');

        console.log(`[Detect Characters] ‚úÖ ${characters.length} personagem(ns) detectado(s)!`);

        res.json({
            msg: `${characters.length} personagem(ns) detectado(s) com sucesso!`,
            characters: charactersText,
            charactersList: characters
        });

    } catch (err) {
        console.error('[Detect Characters] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao detectar personagens.' });
    }
});

// === ROTA LAOZHANG PARA DETEC√á√ÉO DE PERSONAGENS ===
app.post('/api/detect/characters/laozhang', authenticateToken, async (req, res) => {
    const { script, selectedModel } = req.body;
    const userId = req.user.id;

    if (!script || !script.trim()) {
        return res.status(400).json({ msg: 'O roteiro √© obrigat√≥rio.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo n√£o configurada no painel admin.' });
        }

        // Mapear modelo selecionado para modelo Laozhang
        // Se n√£o houver modelo selecionado, usar GPT-4o como padr√£o
        const laozhangModel = selectedModel === 'Claude 3.7 Sonnet (Fev/25)' ? 'claude-3-7-sonnet-20250219' :
                             selectedModel === 'Gemini 2.5 Pro (2025)' ? 'gemini-2.5-pro' :
                             (!selectedModel || !selectedModel.trim()) ? 'gpt-4o' : selectedModel;

        const prompt = `Voc√™ √© um diretor de elenco especializado em analisar roteiros e identificar personagens para gera√ß√£o de imagens com IA.

**ROTEIRO PARA ANALISAR:**
${script}

---

**INSTRU√á√ïES:**
1. Identifique todos os personagens principais e secund√°rios mencionados no roteiro.
2. Para cada personagem, crie uma descri√ß√£o concisa e pr√°tica que inclua:
   - Nome do personagem (ou descri√ß√£o se n√£o tiver nome)
   - Idade aparente
   - Apar√™ncia f√≠sica (cor de cabelo, olhos, tipo f√≠sico, tra√ßos distintivos)
   - Vestimentas principais
   - Caracter√≠sticas visuais importantes para manter consist√™ncia

3. **FORMATO DE SA√çDA OBRIGAT√ìRIO:** Voc√™ DEVE retornar um objeto JSON com a seguinte estrutura exata:
{
  "characters": [
    "Nome, idade, descri√ß√£o f√≠sica e caracter√≠sticas visuais",
    "Outro personagem, idade, descri√ß√£o f√≠sica e caracter√≠sticas visuais"
  ]
}

**EXEMPLO DE FORMATO:**
{
  "characters": [
    "Jo√£o, um homem de 40 anos, cabelo grisalho, √≥culos, rosto marcado, vestindo terno escuro",
    "Maria, uma jovem de 25 anos, cabelo longo e ruivo, olhos verdes, vestindo vestido casual"
  ]
}

**REGRA CR√çTICA:**
- Retorne APENAS o JSON v√°lido, sem texto adicional antes ou depois
- Cada string no array deve ser uma descri√ß√£o completa e pr√°tica do personagem
- Foque em caracter√≠sticas visuais que ajudem a manter consist√™ncia nas imagens geradas
- Se um personagem n√£o tem nome, use uma descri√ß√£o clara (ex: "Policial veterano, 50 anos, cabelo grisalho curto, uniforme azul")
- Limite a descri√ß√£o de cada personagem a uma linha, mas seja completo e detalhado
- Retorne no formato JSON exato especificado acima, com a propriedade "characters" contendo um array de strings

**AGORA ANALISE O ROTEIRO FORNECIDO E RETORNE O JSON COM OS PERSONAGENS IDENTIFICADOS:**`;

        console.log(`[Detect Characters Laozhang] Detectando personagens com modelo: ${laozhangModel}...`);
        const response = await callLaozhangAPI(
            prompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_detect_characters',
            JSON.stringify({ endpoint: '/api/detect/characters/laozhang', model: laozhangModel })
        );

        // Parse robusto da resposta
        let characters = [];
        let parsedData = null;

        // Tentar extrair JSON da resposta
        const rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        try {
            parsedData = JSON.parse(rawResponse);
        } catch (e) {
            // Tentar extrair JSON de dentro de markdown ou texto
            const jsonMatch = rawResponse.match(/\{[\s\S]*"characters"[\s\S]*\[[\s\S]*\][\s\S]*\}/);
            if (jsonMatch) {
                try {
                    parsedData = JSON.parse(jsonMatch[0]);
                } catch (e2) {
                    console.warn('[Detect Characters Laozhang] Erro ao parsear JSON extra√≠do:', e2);
                }
            }
        }

        // Extrair characters de diferentes estruturas poss√≠veis
        if (parsedData) {
            if (parsedData.characters && Array.isArray(parsedData.characters)) {
                characters = parsedData.characters;
            } else if (parsedData.data && parsedData.data.characters && Array.isArray(parsedData.data.characters)) {
                characters = parsedData.data.characters;
            } else if (parsedData.data && Array.isArray(parsedData.data)) {
                characters = parsedData.data;
            }
        }

        // Filtrar e limpar personagens
        if (characters.length > 0) {
            characters = characters
                .filter(char => char && typeof char === 'string' && char.trim().length > 0)
                .map(char => char.trim());
        }

        if (characters.length === 0) {
            return res.status(400).json({ 
                msg: 'Nenhum personagem foi detectado. Verifique se o roteiro cont√©m personagens identific√°veis.',
                characters: '',
                charactersList: []
            });
        }

        // Formatar para o campo de texto (uma linha por personagem)
        const charactersText = characters.join('\n');

        console.log(`[Detect Characters Laozhang] ‚úÖ ${characters.length} personagem(ns) detectado(s)!`);

        res.json({
            msg: `${characters.length} personagem(ns) detectado(s) com sucesso!`,
            characters: charactersText,
            charactersList: characters
        });

    } catch (err) {
        console.error('[Detect Characters Laozhang] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao detectar personagens.' });
    }
});

// === ROTA PARA REESCREVER PROMPT BLOQUEADO ===
app.post('/api/rewrite/blocked-prompt', authenticateToken, async (req, res) => {
    const { prompt, model } = req.body;
    const userId = req.user.id;

    if (!prompt || !prompt.trim()) {
        return res.status(400).json({ msg: 'O prompt √© obrigat√≥rio.' });
    }

    try {
        const selectedModel = model || 'gpt-4o';
        let service = 'gemini';
        if (selectedModel.includes('claude') || selectedModel.includes('sonnet')) {
            service = 'claude';
        } else if (selectedModel.includes('gpt') || selectedModel.includes('openai')) {
            service = 'openai';
        }

        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
        if (!keyData) {
            return res.status(400).json({ msg: `Chave de API do ${service} n√£o configurada.` });
        }

        const decryptedKey = decrypt(keyData.api_key);
        if (!decryptedKey) {
            return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
        }

        const rewritePrompt = `O prompt a seguir foi bloqueado por violar pol√≠ticas de conte√∫do. Reescreva-o mantendo a ess√™ncia visual, hist√≥ria e estilo, mas removendo qualquer conte√∫do que possa ser considerado inseguro ou inadequado. O prompt reescrito deve ser em INGL√äS e otimizado para gera√ß√£o de imagens.

PROMPT ORIGINAL:
"""${prompt}"""

INSTRU√á√ïES:
1. Mantenha a ess√™ncia visual, composi√ß√£o e estilo do prompt original
2. Remova qualquer refer√™ncia a viol√™ncia, conte√∫do adulto ou conte√∫do inadequado
3. Mantenha a narrativa e a atmosfera geral
4. O prompt reescrito deve ter entre 600-1200 caracteres
5. Responda APENAS com o prompt reescrito, sem explica√ß√µes adicionais

PROMPT REWRITTEN:`;

        let apiCallFunction;
        if (service === 'gemini') apiCallFunction = callGeminiAPI;
        else if (service === 'claude') apiCallFunction = callClaudeAPI;
        else apiCallFunction = callOpenAIAPI;

        const response = await apiCallFunction(rewritePrompt, decryptedKey, selectedModel);
        
        let rewrittenText = '';
        if (typeof response === 'string') {
            rewrittenText = response.trim();
        } else if (response.titles) {
            rewrittenText = response.titles;
        } else if (response.text) {
            rewrittenText = response.text;
        }
        
        // Limpar o texto
        rewrittenText = rewrittenText
            .replace(/```[\s\S]*?```/g, '')
            .replace(/`/g, '')
            .replace(/^[^"]*["']|["'][^"]*$/g, '')
            .replace(/^(Prompt|Prompt reformulado|Nova vers√£o|Vers√£o reformulada|PROMPT REWRITTEN)[:Ôºö]\s*/i, '')
            .replace(/\n+/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
        
        if (!rewrittenText || rewrittenText.length < 50) {
            throw new Error('Prompt reescrito inv√°lido ou muito curto');
        }
        
        // Adicionar sufixos de qualidade se n√£o estiverem presentes
        if (!rewrittenText.includes('photorealistic')) {
            rewrittenText += ', photorealistic, hyperrealistic, cinematic, 8k, ultra high definition, sharp focus, professional photography';
        }

        res.json({
            msg: 'Prompt reescrito com sucesso!',
            rewrittenPrompt: rewrittenText
        });

    } catch (err) {
        console.error('[Rewrite Prompt] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao reescrever prompt.' });
    }
});

// === ROTA LAOZHANG PARA REESCREVER PROMPT BLOQUEADO ===
app.post('/api/rewrite/blocked-prompt/laozhang', authenticateToken, async (req, res) => {
    const { prompt, selectedModel } = req.body;
    const userId = req.user.id;

    if (!prompt || !prompt.trim()) {
        return res.status(400).json({ msg: 'O prompt √© obrigat√≥rio.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo n√£o configurada no painel admin.' });
        }

        // Mapear modelo selecionado para modelo Laozhang
        // Se n√£o houver modelo selecionado, usar GPT-4o como padr√£o
        const laozhangModel = selectedModel === 'Claude 3.7 Sonnet (Fev/25)' ? 'claude-3-7-sonnet-20250219' :
                             selectedModel === 'Gemini 2.5 Pro (2025)' ? 'gemini-2.5-pro' :
                             (!selectedModel || !selectedModel.trim()) ? 'gpt-4o' : selectedModel;

        const rewritePrompt = `O prompt a seguir foi bloqueado por violar pol√≠ticas de conte√∫do. Reescreva-o mantendo a ess√™ncia visual, hist√≥ria e estilo, mas removendo qualquer conte√∫do que possa ser considerado inseguro ou inadequado. O prompt reescrito deve ser em INGL√äS e otimizado para gera√ß√£o de imagens.

PROMPT ORIGINAL:
"""${prompt}"""

INSTRU√á√ïES:
1. Mantenha a ess√™ncia visual, composi√ß√£o e estilo do prompt original
2. Remova qualquer refer√™ncia a viol√™ncia, conte√∫do adulto ou conte√∫do inadequado
3. Mantenha a narrativa e a atmosfera geral
4. O prompt reescrito deve ter entre 600-1200 caracteres
5. Responda APENAS com o prompt reescrito, sem explica√ß√µes adicionais

PROMPT REWRITTEN:`;

        const response = await callLaozhangAPI(
            rewritePrompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_rewrite_prompt',
            JSON.stringify({ endpoint: '/api/rewrite/blocked-prompt/laozhang', model: laozhangModel })
        );
        
        let rewrittenText = '';
        if (typeof response === 'string') {
            rewrittenText = response.trim();
        } else if (response.titles) {
            rewrittenText = response.titles;
        } else if (response.text) {
            rewrittenText = response.text;
        }
        
        // Limpar o texto
        rewrittenText = rewrittenText
            .replace(/```[\s\S]*?```/g, '')
            .replace(/`/g, '')
            .replace(/^[^"]*["']|["'][^"]*$/g, '')
            .replace(/^(Prompt|Prompt reformulado|Nova vers√£o|Vers√£o reformulada|PROMPT REWRITTEN)[:Ôºö]\s*/i, '')
            .replace(/\n+/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
        
        if (!rewrittenText || rewrittenText.length < 50) {
            throw new Error('Prompt reescrito inv√°lido ou muito curto');
        }
        
        // Adicionar sufixos de qualidade se n√£o estiverem presentes
        if (!rewrittenText.includes('photorealistic')) {
            rewrittenText += ', photorealistic, hyperrealistic, cinematic, 8k, ultra high definition, sharp focus, professional photography';
        }

        res.json({
            msg: 'Prompt reescrito com sucesso!',
            rewrittenPrompt: rewrittenText
        });

    } catch (err) {
        console.error('[Rewrite Prompt Laozhang] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao reescrever prompt.' });
    }
});

// === ROTA PARA REGENERAR IMAGEM COM PROMPT EDITADO ===
app.post('/api/generate/imagefx/regenerate', authenticateToken, async (req, res) => {
    const { prompt, aspectRatio, style } = req.body;
    const userId = req.user.id;

    if (!prompt) {
        return res.status(400).json({ msg: 'O prompt √© obrigat√≥rio.' });
    }

    try {
        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'imagefx']);
        if (!keyData) {
            return res.status(400).json({ msg: 'Cookies do ImageFX n√£o configurados. Salve-os nas Configura√ß√µes.' });
        }
        
        const decryptedCookies = decrypt(keyData.api_key);
        if (!decryptedCookies) {
            return res.status(500).json({ msg: 'Falha ao desencriptar os seus cookies.' });
        }
        
        const imageFx = new ImageFX(decryptedCookies);
        
        // Mapeamento de estilos (mesmo do generate/imagefx)
        const styleSuffixes = {
            'photorealistic': 'photorealistic, hyperrealistic, ultra high definition, 8k, sharp focus, professional photography, taken with a high-end camera like a Sony Œ±7 IV, detailed skin texture, natural lighting',
            'cinematic': 'cinematic, dramatic lighting, film grain, anamorphic lens, color grading, movie still, Hollywood style, epic composition',
            'documentary': 'documentary style, natural lighting, authentic, candid photography, real moments, journalistic approach, raw and unfiltered',
            'cinematic-narrative': 'cinematic narrative, storytelling composition, dramatic angles, emotional depth, visual storytelling, film photography',
            'anime': 'anime style, Japanese animation, vibrant colors, expressive characters, detailed backgrounds, manga-inspired, cel-shaded',
            'cartoon': 'cartoon style, animated, colorful, expressive, playful, hand-drawn aesthetic, vibrant palette',
            'cartoon-premium': 'premium cartoon style, high-quality animation, detailed character design, rich colors, professional animation studio quality',
            'fantasy': 'fantasy art, magical atmosphere, epic scale, mystical lighting, enchanted, otherworldly, detailed fantasy illustration',
            'stick-figure': 'stick figure style, minimalist line art, simple black lines on white background, clean and minimal',
            'whiteboard': 'whiteboard animation style, clean white background, hand-drawn illustrations, educational, clear and simple',
            'tech-minimalist': 'tech minimalist, clean design, modern aesthetic, geometric shapes, minimal color palette, futuristic, sleek',
            'spiritual-minimalist': 'spiritual minimalist, serene atmosphere, soft lighting, peaceful composition, meditative, zen aesthetic',
            'viral-vibrant': 'viral vibrant style, high contrast, saturated colors, bold composition, eye-catching, social media optimized, vibrant and energetic',
            'modern-documentary': 'modern documentary style, contemporary aesthetic, dynamic composition, real-world setting, authentic moments',
            'analog-horror': 'analog horror aesthetic, VHS quality, grainy texture, retro horror, distorted colors, unsettling atmosphere, 80s/90s horror',
            'dark-theater': 'dark theater style, dramatic stage lighting, theatrical composition, intense shadows, dramatic performance',
            'naturalist-drama': 'naturalist drama, realistic emotional scenes, natural lighting, authentic human moments, raw emotion',
            'spiritual-neorealism': 'spiritual neorealism, transcendent realism, ethereal lighting, spiritual atmosphere, mystical realism',
            'psychological-surrealism': 'psychological surrealism, dreamlike imagery, surreal composition, psychological depth, abstract reality',
            'fragmented-memory': 'fragmented memory style, collage aesthetic, fragmented composition, memory-like quality, layered imagery',
            'fragmented-narrative': 'fragmented narrative, collage style, mixed media, layered storytelling, fragmented visual narrative',
            'dream-real': 'dream-real style, liminal space between dream and reality, surreal realism, ethereal atmosphere, dreamlike quality',
            'vhs-nostalgic': 'VHS nostalgic, retro 80s/90s aesthetic, vintage quality, nostalgic colors, retro film grain, analog feel'
        };
        
        // Obter sufixo do estilo ou usar padr√£o
        const styleSuffix = (style && styleSuffixes[style]) ? styleSuffixes[style] : styleSuffixes['photorealistic'];
        let currentPrompt = `${prompt}, ${styleSuffix}`;
        
        const aspectRatioMap = {
            '16:9': AspectRatio.LANDSCAPE,
            '9:16': AspectRatio.PORTRAIT,
            '1:1': AspectRatio.SQUARE
        };
        
        const results = await imageFx.generateImage(currentPrompt, {
            numberOfImages: 1,
            aspectRatio: aspectRatioMap[aspectRatio || '16:9'] || AspectRatio.LANDSCAPE,
            resizeTo16_9: (aspectRatio || '16:9') === '16:9'
        });

        if (!results || results.length === 0) {
            throw new Error('A API n√£o retornou imagens.');
        }

        const imageData = results[0];
        const imageUrl = imageData.url || `data:image/png;base64,${imageData.base64 || ''}`;
        const imageBase64 = imageData.base64 || (imageUrl.startsWith('data:') ? imageUrl.split(',')[1] : null);

        res.status(200).json({ 
            msg: 'Imagem regenerada com sucesso!',
            image: imageBase64 || imageUrl,
            imageUrl: imageUrl,
            prompt: currentPrompt
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/generate/imagefx/regenerate]:', err);
        
        if (err instanceof AccountError || err.message?.includes('cookie') || err.message?.includes('autentica√ß√£o')) {
            return res.status(401).json({ 
                msg: 'Cookies do ImageFX expirados ou inv√°lidos. Por favor, atualize os cookies nas Configura√ß√µes.',
                requiresAuth: true
            });
        }
        
        res.status(500).json({ msg: err.message || 'Erro ao regenerar imagem.' });
    }
});

// === ROTA PARA GERAR M√öLTIPLAS IMAGENS (BATCH) ===
app.post('/api/generate/imagefx/batch', authenticateToken, async (req, res) => {
    const { prompts, style, aspectRatio } = req.body;
    const userId = req.user.id;

    if (!prompts || !Array.isArray(prompts) || prompts.length === 0) {
        return res.status(400).json({ msg: 'Uma lista de prompts √© obrigat√≥ria.' });
    }

    try {
        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'imagefx']);
        if (!keyData) {
            return res.status(400).json({ msg: 'Cookies do ImageFX n√£o configurados. Salve-os nas Configura√ß√µes.' });
        }
        
        const decryptedCookies = decrypt(keyData.api_key);
        if (!decryptedCookies) {
            return res.status(500).json({ msg: 'Falha ao desencriptar os seus cookies.' });
        }
        
        const imageFx = new ImageFX(decryptedCookies);
        const results = [];
        const errors = [];

        // Gerar imagens em paralelo (m√°ximo 3 por vez para evitar rate limit)
        const batchSize = 3;
        for (let i = 0; i < prompts.length; i += batchSize) {
            const batch = prompts.slice(i, i + batchSize);
            const batchPromises = batch.map(async (prompt, index) => {
                try {
                    const fullPrompt = `${prompt}, photorealistic, hyperrealistic, cinematic, 8k, ultra high definition, sharp focus, professional photography, taken with a high-end camera like a Sony Œ±7 IV, detailed skin texture, natural lighting`;
                    
                    const aspectRatioMap = {
                        '16:9': AspectRatio.LANDSCAPE,
                        '9:16': AspectRatio.PORTRAIT,
                        '1:1': AspectRatio.SQUARE
                    };
                    
                    const images = await imageFx.generateImage(fullPrompt, {
                        aspectRatio: aspectRatioMap[aspectRatio || '16:9'] || AspectRatio.LANDSCAPE,
                        numberOfImages: 1,
                        resizeTo16_9: (aspectRatio || '16:9') === '16:9'
                    });
                    
                    if (images && images.length > 0) {
                        return {
                            prompt: prompt,
                            image: images[0].getImageData(),
                            sceneNumber: i + index + 1,
                            success: true
                        };
                    }
                    throw new Error('Nenhuma imagem gerada');
                } catch (error) {
                    return {
                        prompt: prompt,
                        error: error.message,
                        sceneNumber: i + index + 1,
                        success: false
                    };
                }
            });

            const batchResults = await Promise.all(batchPromises);
            results.push(...batchResults);
        }

        const successCount = results.filter(r => r.success).length;
        const failCount = results.filter(r => !r.success).length;

        res.json({
            msg: `${successCount} imagem(ns) gerada(s) com sucesso${failCount > 0 ? `, ${failCount} falha(s)` : ''}`,
            results: results,
            successCount,
            failCount
        });

    } catch (err) {
        console.error('[ImageFX Batch] Erro:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar imagens em lote.' });
    }
});


// === ROTA PARA GERAR IMAGEM COM IMAGEFX ===
app.post('/api/generate/imagefx', authenticateToken, async (req, res) => {
    const { prompt, niche, subniche, style, saveToLibrary } = req.body;
    const userId = req.user.id;

    if (!prompt) {
        return res.status(400).json({ msg: 'Um prompt (descri√ß√£o da thumbnail) √© obrigat√≥rio.' });
    }

    try {
        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'imagefx']);
        if (!keyData) {
            return res.status(400).json({ msg: 'Cookies do ImageFX n√£o configurados. Salve-os nas Configura√ß√µes.' });
        }
        
        const decryptedCookies = decrypt(keyData.api_key);
        if (!decryptedCookies) {
            return res.status(500).json({ msg: 'Falha ao desencriptar os seus cookies.' });
        }
        
        console.log('[ImageFX] A iniciar gera√ß√£o...');
        const imageFx = new ImageFX(decryptedCookies);
        
        // Mapeamento de estilos para sufixos de prompt
        const styleSuffixes = {
            'photorealistic': 'photorealistic, hyperrealistic, ultra high definition, 8k, sharp focus, professional photography, taken with a high-end camera like a Sony Œ±7 IV, detailed skin texture, natural lighting',
            'cinematic': 'cinematic, dramatic lighting, film grain, anamorphic lens, color grading, movie still, Hollywood style, epic composition',
            'documentary': 'documentary style, natural lighting, authentic, candid photography, real moments, journalistic approach, raw and unfiltered',
            'cinematic-narrative': 'cinematic narrative, storytelling composition, dramatic angles, emotional depth, visual storytelling, film photography',
            'anime': 'anime style, Japanese animation, vibrant colors, expressive characters, detailed backgrounds, manga-inspired, cel-shaded',
            'cartoon': 'cartoon style, animated, colorful, expressive, playful, hand-drawn aesthetic, vibrant palette',
            'cartoon-premium': 'premium cartoon style, high-quality animation, detailed character design, rich colors, professional animation studio quality',
            'fantasy': 'fantasy art, magical atmosphere, epic scale, mystical lighting, enchanted, otherworldly, detailed fantasy illustration',
            'stick-figure': 'stick figure style, minimalist line art, simple black lines on white background, clean and minimal',
            'whiteboard': 'whiteboard animation style, clean white background, hand-drawn illustrations, educational, clear and simple',
            'tech-minimalist': 'tech minimalist, clean design, modern aesthetic, geometric shapes, minimal color palette, futuristic, sleek',
            'spiritual-minimalist': 'spiritual minimalist, serene atmosphere, soft lighting, peaceful composition, meditative, zen aesthetic',
            'viral-vibrant': 'viral vibrant style, high contrast, saturated colors, bold composition, eye-catching, social media optimized, vibrant and energetic',
            'modern-documentary': 'modern documentary style, contemporary aesthetic, dynamic composition, real-world setting, authentic moments',
            'analog-horror': 'analog horror aesthetic, VHS quality, grainy texture, retro horror, distorted colors, unsettling atmosphere, 80s/90s horror',
            'dark-theater': 'dark theater style, dramatic stage lighting, theatrical composition, intense shadows, dramatic performance',
            'naturalist-drama': 'naturalist drama, realistic emotional scenes, natural lighting, authentic human moments, raw emotion',
            'spiritual-neorealism': 'spiritual neorealism, transcendent realism, ethereal lighting, spiritual atmosphere, mystical realism',
            'psychological-surrealism': 'psychological surrealism, dreamlike imagery, surreal composition, psychological depth, abstract reality',
            'fragmented-memory': 'fragmented memory style, collage aesthetic, fragmented composition, memory-like quality, layered imagery',
            'fragmented-narrative': 'fragmented narrative, collage style, mixed media, layered storytelling, fragmented visual narrative',
            'dream-real': 'dream-real style, liminal space between dream and reality, surreal realism, ethereal atmosphere, dreamlike quality',
            'vhs-nostalgic': 'VHS nostalgic, retro 80s/90s aesthetic, vintage quality, nostalgic colors, retro film grain, analog feel'
        };
        
        // Obter sufixo do estilo ou usar padr√£o
        const styleSuffix = styleSuffixes[style] || styleSuffixes['photorealistic'];
        let currentPrompt = `${prompt}, ${styleSuffix}`;
        
        const maxRetries = 5;
        let attempt = 0;
        let images = null;
        let lastError = null;
        
        // Fun√ß√£o para detectar se o erro √© de pol√≠tica de conte√∫do
        const isPolicyError = (error) => {
            if (!error || !error.message) return false;
            const errorStr = error.message.toLowerCase();
            const errorCode = error.code;
            
            return (
                errorCode === 400 && (
                    errorStr.includes('bloqueado') ||
                    errorStr.includes('conte√∫do inseguro') ||
                    errorStr.includes('public_error') ||
                    errorStr.includes('prominent_people') ||
                    errorStr.includes('filter_failed') ||
                    errorStr.includes('policy') ||
                    errorStr.includes('unsafe')
                )
            );
        };
        
        // Fun√ß√£o para reformular o prompt usando IA
        const reformulatePrompt = async (originalPrompt, errorMessage) => {
            try {
                const services = ['gemini', 'claude', 'openai'];
                let reformulatedPrompt = null;
                
                for (const service of services) {
                    try {
                        const serviceKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                        if (!serviceKeyData) continue;
                        
                        const decryptedKey = decrypt(serviceKeyData.api_key);
                        if (!decryptedKey) continue;
                        
                        let apiCallFunction;
                        let model;
                        if (service === 'gemini') {
                            apiCallFunction = callGeminiAPI;
                            model = 'gemini-2.0-flash';
                        } else if (service === 'claude') {
                            apiCallFunction = callClaudeAPI;
                            model = 'claude-3-5-haiku-20241022';
                        } else {
                            apiCallFunction = callOpenAIAPI;
                            model = 'gpt-4o-mini';
                        }
                        
                        const reformulationPrompt = `O prompt a seguir foi bloqueado por violar pol√≠ticas de conte√∫do. Reescreva-o mantendo a ess√™ncia visual, hist√≥ria e estilo, mas removendo qualquer conte√∫do que possa ser considerado inseguro ou inadequado. O prompt reescrito deve ser em INGL√äS e otimizado para gera√ß√£o de imagens.

PROMPT ORIGINAL:
"""${originalPrompt}"""

INSTRU√á√ïES:
1. Mantenha a ess√™ncia visual, composi√ß√£o e estilo do prompt original
2. Remova qualquer refer√™ncia a viol√™ncia, conte√∫do adulto ou conte√∫do inadequado
3. Mantenha a narrativa e a atmosfera geral
4. O prompt reescrito deve ter entre 600-1200 caracteres
5. Responda APENAS com o prompt reescrito, sem explica√ß√µes adicionais

PROMPT REWRITTEN:`;

                        const response = await apiCallFunction(reformulationPrompt, decryptedKey, model);
                        
                        let extractedText = '';
                        if (typeof response === 'string') {
                            extractedText = response;
                        } else if (response.titles) {
                            extractedText = response.titles;
                        } else if (response.text) {
                            extractedText = response.text;
                        }
                        
                        reformulatedPrompt = extractedText
                            .replace(/```[\s\S]*?```/g, '')
                            .replace(/`/g, '')
                            .replace(/^[^"]*["']|["'][^"]*$/g, '')
                            .replace(/^(Prompt|Prompt reformulado|Nova vers√£o|Vers√£o reformulada|PROMPT REWRITTEN)[:Ôºö]\s*/i, '')
                            .replace(/\n+/g, ' ')
                            .replace(/\s+/g, ' ')
                            .trim();
                        
                        if (reformulatedPrompt && reformulatedPrompt.length > 50 && reformulatedPrompt.length < 2000) {
                            console.log(`[ImageFX] Prompt reformulado usando ${service} (${reformulatedPrompt.length} caracteres)`);
                            if (!reformulatedPrompt.includes('photorealistic')) {
                                reformulatedPrompt += ', photorealistic, hyperrealistic, cinematic, 8k, ultra high definition, sharp focus, professional photography';
                            }
                            break;
                        }
                    } catch (serviceErr) {
                        console.warn(`[ImageFX] Falha ao reformular com ${service}:`, serviceErr.message);
                        continue;
                    }
                }
                
                if (!reformulatedPrompt) {
                    reformulatedPrompt = originalPrompt
                        .replace(/real person|actual person|specific person|celebrity|famous person/gi, 'generic person')
                        + ', generic characters, no specific individuals, artistic representation';
                }
                
                return reformulatedPrompt;
            } catch (err) {
                console.error('[ImageFX] Erro ao reformular prompt:', err);
                return originalPrompt.replace(/real person|actual person|specific person/gi, 'generic person') + ', generic characters';
            }
        };
        
        // Loop de tentativas com reformula√ß√£o autom√°tica
        while (attempt < maxRetries && !images) {
            attempt++;
            try {
                console.log(`[ImageFX] Tentativa ${attempt}/${maxRetries} com prompt: ${currentPrompt.substring(0, 100)}...`);
                
                const results = await imageFx.generateImage(currentPrompt, {
                    numberOfImages: 1,
                    aspectRatio: AspectRatio.LANDSCAPE,
                    resizeTo16_9: true
                });

                if (results && results.length > 0) {
                    images = results;
                    console.log(`[ImageFX] Imagem gerada com sucesso na tentativa ${attempt}`);
                    break;
                }
            } catch (err) {
                lastError = err;
                console.warn(`[ImageFX] Erro na tentativa ${attempt}:`, err.message);
                
                if (isPolicyError(err) && attempt < maxRetries) {
                    console.log(`[ImageFX] Erro de pol√≠tica detectado. Reformulando prompt...`);
                    currentPrompt = await reformulatePrompt(currentPrompt, err.message);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    continue;
                } else {
                    throw err;
                }
            }
        }

        if (!images || images.length === 0) {
            throw new Error(lastError?.message || 'O ImageFX n√£o retornou imagens ap√≥s m√∫ltiplas tentativas.');
        }

        // O generateImage retorna um array de objetos com url, sanitizedPrompt, etc.
        const imageResult = images[0];
        const imageUrl = imageResult.url || '';
        
        // Extrair base64 da URL data:image
        let finalBase64 = null;
        if (imageUrl && imageUrl.startsWith('data:image')) {
            finalBase64 = imageUrl.split(',')[1];
        }
        
        const finalUrl = imageUrl || (finalBase64 ? `data:image/png;base64,${finalBase64}` : '');

        // Salvar automaticamente na biblioteca se solicitado
        let savedId = null;
        if (saveToLibrary && finalUrl) {
            try {
                const result = await db.run(
                    `INSERT INTO viral_thumbnails_library (user_id, thumbnail_url, thumbnail_description, niche, subniche, style, viral_score)
                     VALUES (?, ?, ?, ?, ?, ?, ?)`,
                    [userId, finalUrl, prompt, niche || null, subniche || null, style || null, 8]
                );
                savedId = result.lastID;
                console.log(`[ImageFX] Thumbnail salva na biblioteca com ID ${savedId}`);
            } catch (libErr) {
                console.warn('[ImageFX] Erro ao salvar thumbnail na biblioteca:', libErr.message);
            }
        }

        res.status(200).json({ 
            msg: 'Imagem gerada com sucesso!',
            image: finalBase64,
            imageUrl: finalUrl,
            base64: finalBase64,
            prompt: currentPrompt,
            savedToLibrary: savedId !== null,
            libraryId: savedId,
            attempts: attempt,
            wasRewritten: attempt > 1
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/generate/imagefx]:', err);
        
        // Verificar se √© erro de autentica√ß√£o (cookies expirados)
        if (err instanceof AccountError || err.message?.includes('cookie') || err.message?.includes('autentica√ß√£o')) {
            return res.status(401).json({ 
                msg: 'Cookies do ImageFX expirados ou inv√°lidos. Por favor, atualize os cookies nas Configura√ß√µes.',
                requiresAuth: true
            });
        }
        
        // Verificar se √© erro do ImageFX com c√≥digo espec√≠fico
        if (err.code === 400 && err.message) {
            const errorMsg = err.message;
            if (errorMsg.includes('PUBLIC_ERROR') || errorMsg.includes('filter_failed')) {
                return res.status(500).json({ 
                    msg: 'N√£o foi poss√≠vel gerar a imagem ap√≥s m√∫ltiplas tentativas de reformula√ß√£o. O conte√∫do pode violar pol√≠ticas do gerador de imagens. Tente modificar o prompt manualmente para remover refer√™ncias a pessoas reais ou conte√∫do sens√≠vel.',
                    error: errorMsg
                });
            }
        }
        
        res.status(500).json({ msg: err.message || 'Erro interno do servidor ao gerar imagem.' });
    }
});

// === ROTA: GERAR THUMBNAIL POR T√çTULO (SEGUINDO PROMPT PADR√ÉO) ===
app.post('/api/generate/imagefx/by-title', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { title, niche, subniche, folder_id, prompt_variant, language = 'pt-BR', style = 'photorealistic', variations = 1, prompt_ai = 'none', theme_key } = req.body || {};
    try {
        if (!title || !title.trim()) return res.status(400).json({ msg: 'T√≠tulo √© obrigat√≥rio.' });
        // Buscar prompt padr√£o (varia√ß√£o selecionada)
        let query = 'SELECT id, prompt_1, prompt_2, prompt_3, standard_prompt, prompt_selected FROM thumbnail_style_prompts WHERE user_id = ?';
        const params = [userId];
        if (folder_id) { query += ' AND (folder_id = ? OR folder_id IS NULL)'; params.push(folder_id); }
        if (subniche) { query += ' AND (subniche = ? OR subniche IS NULL)'; params.push(subniche); }
        if (niche) { query += ' AND (niche = ? OR niche IS NULL)'; params.push(niche); }
        query += ' ORDER BY updated_at DESC LIMIT 1';
        const promptData = await db.get(query, params);
        if (!promptData) return res.status(400).json({ msg: 'Prompt padr√£o n√£o encontrado para este nicho/subnicho.' });
        const selectedNum = prompt_variant || promptData.prompt_selected || 1;
        let basePrompt = null;
        if (selectedNum === 1 && promptData.prompt_1) basePrompt = promptData.prompt_1;
        else if (selectedNum === 2 && promptData.prompt_2) basePrompt = promptData.prompt_2;
        else if (selectedNum === 3 && promptData.prompt_3) basePrompt = promptData.prompt_3;
        else basePrompt = promptData.standard_prompt || promptData.prompt_1 || promptData.prompt_2 || promptData.prompt_3;
        if (!basePrompt) return res.status(400).json({ msg: 'Prompt padr√£o vazio.' });
        // Adaptar ao t√≠tulo sem reescrever o padr√£o
        const titleText = title.trim();
        const placeholders = [/\\[\\s*T[√çI]TULO\\s*\\]/gi, /\\{\\s*TITLE\\s*\\}/gi, /<\\s*TITLE\\s*>/gi, /\\{\\{\\s*title\\s*\\}\\}/gi, /\\[TITLE\\]/g];
        let hadPlaceholder = false;
        for (const rx of placeholders) {
            if (rx.test(basePrompt)) {
                basePrompt = basePrompt.replace(rx, `\"${titleText}\"`);
                hadPlaceholder = true;
            }
        }
        // N√£o injetar o t√≠tulo completo no prompt visual; vamos criar HEADLINE/SUBHEADLINE
        if (!hadPlaceholder) {
            // Apenas mant√©m o basePrompt sem inserir "Title: ..."
        }
        // Remover instru√ß√µes de cen√°rio r√≠gidas do prompt base para permitir varia√ß√£o por t√≠tulo
        try {
            const scenePatterns = [
                /background should.*?\\./gi,
                /background.*?(sky|mountain|desert|forest|jungle|city|ships|pyramids|ruins).*?\\./gi,
                /setting:.*?\\./gi,
                /scene shows.*?\\./gi
            ];
            for (const p of scenePatterns) {
                basePrompt = basePrompt.replace(p, '').replace(/\\n{2,}/g, '\\n');
            }
        } catch {}
        // Extra√ß√£o leve de cen√°rio (IA opcional + heur√≠sticas)
        const words = titleText.split(/\\s+/).map(w => w.trim()).filter(Boolean);
        const eraTerms = ['antiguidade','medieval','renascimento','col√¥nia','imp√©rio','revolu√ß√£o','s√©culo','era','dinastia'];
        const placeTerms = ['roma','egito','azteca','inca','maya','espanha','m√©xico','peru','andino','atl√¢ntico','pac√≠fico','deserto','selva','floresta'];
        const detectedEra = words.find(w => eraTerms.includes(w.toLowerCase()));
        const detectedPlace = words.find(w => placeTerms.includes(w.toLowerCase()));
        let scenarioHints = [];
        if (detectedEra) scenarioHints.push(`historical era: ${detectedEra}`);
        if (detectedPlace) scenarioHints.push(`setting: ${detectedPlace}`);
        // Mapeamento de cen√°rios por cultura/tema para elementos visuais caracter√≠sticos
        const sceneMap = [
            { keys: ['azteca','aztecas','mexica','tenochtitlan'], elements: ['aztec pyramids', 'feathered headdress', 'jaguar warrior motifs', 'Spanish ships on horizon', 'smoke of battle', 'ancient temples'] },
            { keys: ['inca','incas','atahualpa','machu','andino','peru'], elements: ['andes mountains', 'Machu Picchu ruins', 'stone terraces', 'lamas', 'conquistador silhouettes', 'stormy sky'] },
            { keys: ['maya','mayas','mayan','chichen','yucatan'], elements: ['step pyramids', 'jungle canopy', 'stone glyphs', 'misty forest', 'sun shafts through foliage'] },
            { keys: ['roma','romanos','roman'], elements: ['colosseum', 'roman columns', 'laurel wreath', 'legion standards', 'marble statues'] },
            { keys: ['egito','egypt','fara√≥','pharaoh','pyramids','giza'], elements: ['desert dunes', 'pyramids of giza', 'hieroglyph walls', 'golden sun', 'ancient statues'] }
        ];
        const tLower = titleText.toLowerCase();
        let sceneElements = [];
        for (const entry of sceneMap) {
            if (entry.keys.some(k => tLower.includes(k))) {
                sceneElements = entry.elements;
                break;
            }
        }
        // Regras adicionais para Neandertais/DNA
        if (/(neandertal|neanderthal|neandertais)/i.test(titleText)) {
            sceneElements = ['ice age landscape', 'stormy blue-gray sky', 'cave entrance', 'primitive tools', 'human skull silhouette', 'double helix DNA overlay', 'scientific lab glow'];
        }
        // Evitar elementos conflitantes quando tema n√£o √© mesoamericano
        let avoidElements = [];
        if (!/(azteca|aztecas|mexica|tenochtitlan)/i.test(titleText)) {
            avoidElements.push('mesoamerican pyramids', 'feathered headdress', 'jaguar warrior motif', 'spanish ships on horizon');
        }
        // Remover sujeito fixo do prompt base (l√≠der com cocar etc.) para permitir troca por t√≠tulo
        try {
            const subjectPatterns = [
                /indigenous leader.*?\\./gi,
                /feathered headdress.*?\\./gi,
                /jaguar warrior.*?\\./gi,
                /conquistador silhouettes.*?\\./gi
            ];
            for (const p of subjectPatterns) {
                basePrompt = basePrompt.replace(p, '').replace(/\\n{2,}/g, '\\n');
            }
            const hardRemovals = [
                /feather(?:ed)?\\s+headdress/gi,
                /headdress/gi,
                /jaguar\\s+warrior/gi,
                /conquistador(s)?/gi,
                /spanish\\s+ships?/gi,
                /mesoamerican/gi,
                /aztec(as)?/gi,
                /pyramids?/gi,
                /logo/gi,
                /watermark/gi,
                /badge/gi,
                /branding/gi
            ];
            for (const p of hardRemovals) {
                basePrompt = basePrompt.replace(p, '');
            }
            basePrompt = basePrompt.replace(/\\s{2,}/g, ' ').trim();
        } catch {}
        // Definir SUJEITO principal conforme t√≠tulo
        let subjectDescription = null;
        if (/(neandertal|neanderthal|neandertais)/i.test(titleText)) {
            subjectDescription = 'stoic Neanderthal male in fur cloak holding stone tools, rugged facial features, scientific overlay subtly present';
        } else if (/(dna|genetic|gen√©tica)/i.test(titleText)) {
            subjectDescription = 'scientific composition with double helix DNA as secondary element; keep human silhouette subtle';
        } else if (/(roma|romanos|roman)/i.test(titleText)) {
            subjectDescription = 'Roman figure with laurel wreath and toga, classical lighting';
        } else if (/(egito|egypt|pharaoh|fara√≥)/i.test(titleText)) {
            subjectDescription = 'ancient Egyptian figure with royal collar, desert lighting';
        }
        // IA opcional para enriquecer hints (n√£o reescrever prompt)
        try {
            if (prompt_ai && prompt_ai !== 'none') {
                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, prompt_ai]);
                if (keyData) {
                    const decryptedKey = decrypt(keyData.api_key);
                    const model = prompt_ai === 'gemini' ? 'gemini-2.0-flash' : (prompt_ai === 'openai' ? 'gpt-4o-mini' : 'claude-3-5-haiku-20241022');
                    const ask = `From the title "${titleText}", extract 3 short scenario hints (setting, era, key elements) that can vary while keeping composition locked. Return as lines: hint: value`;
                    let resp;
                    if (prompt_ai === 'gemini') resp = await callGeminiAPI(ask, decryptedKey, model);
                    else if (prompt_ai === 'openai') resp = await callOpenAIAPI(ask, decryptedKey, model);
                    else resp = await callClaudeAPI(ask, decryptedKey, model);
                    const text = typeof resp === 'string' ? resp : (resp.text || resp.titles || '');
                    const lines = String(text).split(/\\n+/).map(s => s.trim()).filter(Boolean).slice(0, 5);
                    scenarioHints.push(...lines);
                }
            }
        } catch (e) {
            console.warn('[ByTitle] IA de cen√°rio opcional falhou:', e.message);
        }
        const styleLock = 'Keep composition, subject placement, palette, typography and lighting exactly as in channel references. Do not change layout. Maintain gold title text at bottom with dramatic lighting. Do not render any literal text from these instructions.';
        let finalPrompt = `${basePrompt}`;
        // HEADLINE/SUBHEADLINE derivadas do t√≠tulo
        const extractHeadline = (raw) => {
            let head = raw.split(':')[0].trim();
            // Limitar tamanho e capitalizar
            head = head.replace(/^[\\s\\-‚Äì]+|[\\s\\-‚Äì]+$/g, '');
            return head;
        };
        const extractSub = (raw) => {
            const paren = raw.match(/\\(([^\\)]+)\\)/);
            if (paren && paren[1]) return paren[1].trim();
            const parts = raw.split(':');
            if (parts[1]) {
                // pegar n√∫cleo forte (2‚Äì5 palavras)
                let sub = parts[1]
                    .replace(/\\b(sobre|acerca|de|da|do|dos|das|su[a]?|el|la|los|las|the|a)\\b/gi, '')
                    .replace(/[\"']/g, '')
                    .trim();
                // Se ainda muito longo, encurtar
                const words = sub.split(/\\s+/).filter(Boolean);
                if (words.length > 6) sub = words.slice(0, 6).join(' ');
                return sub || parts[1].trim();
            }
            return '';
        };
        const headlineText = extractHeadline(titleText);
        const subText = extractSub(titleText);
        const theme = (() => {
            const s = titleText.toLowerCase();
            if (s.includes('fara√≥') || s.includes('egito') || s.includes('egip') || s.includes('pir√¢mide') || s.includes('piramide')) return 'egito';
            if (s.includes('neandertal') || s.includes('neanderthal') || s.includes('neandertais') || s.includes('neandertales')) return 'prehistoria';
            if (s.includes('inca') || s.includes('atahualpa') || s.includes('moctezuma') || s.includes('azteca') || s.includes('aztecas') || s.includes('mexica')) return 'america_pre_colombiana';
            if (s.includes('viking') || s.includes('vikings')) return 'viking';
            if (s.includes('roma') || s.includes('romano') || s.includes('romanos') || s.includes('roman')) return 'roma';
            if (s.includes('segunda guerra') || s.includes('world war') || s.includes('guerra mundial')) return 'ww2';
            if (s.includes('cristandade') || s.includes('crist√£o') || s.includes('cristian') || s.includes('cathedral') || s.includes('catedral')) return 'cristandade';
            return 'default';
        })();
        const themes = {
            egito: { AMBIENTE: ['desert dunes', 'pyramids', 'pharaoh temples', 'golden sun'], ELEMENTOS: ['hieroglyph walls', 'golden crown', 'architect tools'] },
            prehistoria: { AMBIENTE: ['frozen mountains', 'glacial valleys', 'burning forests'], ELEMENTOS: ['fur clothing', 'primitive tools', 'ice age forests'] },
            america_pre_colombiana: { AMBIENTE: ['jungles', 'stepped pyramids', 'volcanic eruptions'], ELEMENTOS: ['feather headdress', 'obsidian blade', 'conquistador silhouettes'] },
            viking: { AMBIENTE: ['stormy oceans', 'burning ships', 'icy fjords'], ELEMENTOS: ['longships', 'axes', 'ravens'] },
            roma: { AMBIENTE: ['colosseum', 'roman columns', 'marble statues'], ELEMENTOS: ['legion standards', 'laurel wreath', 'toga textures'] },
            ww2: { AMBIENTE: ['ruined cities', 'smoke', 'searchlights'], ELEMENTOS: ['tanks', 'helmets', 'barbed wire'] },
            cristandade: { AMBIENTE: ['gothic cathedrals', 'stained glass light', 'stone plazas'], ELEMENTOS: ['crosses', 'incense smoke', 'candles'] },
            default: { AMBIENTE: ['dramatic scenery', 'smoke', 'conflict'], ELEMENTOS: ['contextual props'] }
        };
        let dbMatch = null;
        if (theme_key) {
            await ensureAmbientationsTable();
            dbMatch = await db.get('SELECT * FROM niche_ambientations WHERE user_id = ? AND theme_key = ? LIMIT 1', [userId, theme_key]);
        }
        if (!dbMatch) {
            dbMatch = await detectAmbientationFromTitle(userId, titleText, niche);
        }
        if (dbMatch) {
            sceneElements = String(dbMatch.ambiente || '').split(',').map(s => s.trim()).filter(Boolean);
            scenarioHints = String(dbMatch.elementos || '').split(',').map(s => s.trim()).filter(Boolean);
            if (!subjectDescription && dbMatch.subject) subjectDescription = dbMatch.subject;
        } else if (themes[theme]) {
            sceneElements = themes[theme].AMBIENTE;
            scenarioHints = themes[theme].ELEMENTOS;
            if (!subjectDescription) {
                if (theme === 'prehistoria') subjectDescription = 'realistic Neanderthal with fur cloak and stone tools';
                else if (theme === 'egito') subjectDescription = 'ancient Egyptian figure with royal collar';
                else if (theme === 'america_pre_colombiana') subjectDescription = 'Mesoamerican leader with traditional attire';
                else if (theme === 'viking') subjectDescription = 'Viking warrior with fur and axe';
                else if (theme === 'roma') subjectDescription = 'Roman figure with laurel wreath and toga';
                else if (theme === 'ww2') subjectDescription = 'civilian silhouette amid wartime ruins';
                else if (theme === 'cristandade') subjectDescription = 'historical figure near cathedral light';
            }
        }
        const personagem = subjectDescription || 'historical figure with authentic attire';
        const ambientacao = (sceneElements && sceneElements.length) ? sceneElements.join(', ') : 'landscapes and architecture matching the title theme';
        const elementosIconicos = [scenarioHints.join('; '), avoidElements.length ? `avoid: ${avoidElements.join(', ')}` : ''].filter(Boolean).join('; ');
        const elementosDeFundo = scenarioHints.join(', ');
        const acessoriosPreset = (dbMatch && dbMatch.acessorios) ? String(dbMatch.acessorios) : (
            theme === 'prehistoria' ? 'primitive fur and animal hides, no metal or feathers' :
            theme === 'egito' ? 'gold necklaces and ceremonial regalia' :
            theme === 'viking' ? 'fur, leather armor, iron helmet' : ''
        );
        // Modulariza√ß√£o do prompt padr√£o: preencher placeholders ou ajustar blocos de cen√°rio/elementos
        let adaptedPrompt = `${basePrompt}`;
        const phMap = { PERSONAGEM: personagem, ACESSORIOS: acessoriosPreset, AMBIENTE: ambientacao, ELEMENTOS_DE_FUNDO: elementosDeFundo };
        let placeholdersFound = false;
        for (const [key, val] of Object.entries(phMap)) {
            const rx = new RegExp(`\\{${key}\\}`, 'gi');
            if (rx.test(adaptedPrompt)) { placeholdersFound = true; adaptedPrompt = adaptedPrompt.replace(rx, val); }
        }
        if (!placeholdersFound) {
            const bgRx = /(background[^\.]*?)(:|should|with) [^\.]*\./i;
            if (bgRx.test(adaptedPrompt)) adaptedPrompt = adaptedPrompt.replace(bgRx, `$1: ${ambientacao}.`);
            const incRx = /(include[^\.]*elements[^\.]*?)(:|such as) [^\.]*\./i;
            if (incRx.test(adaptedPrompt)) adaptedPrompt = adaptedPrompt.replace(incRx, `$1: ${elementosIconicos}.`);
            if (!bgRx.test(adaptedPrompt)) adaptedPrompt += `\\n\\nBackground: ${ambientacao}.`;
            if (!incRx.test(adaptedPrompt)) adaptedPrompt += `\\nInclude elements: ${elementosDeFundo}.`;
        }
        const headlineLine = `Headline: \\\"${headlineText}\\\" (translate to ${language}) in gold all-caps serif with subtle glow; do not render the word 'Headline'.`;
        const subheadlineLine = subText ? `Subheadline: \\\"${subText}\\\" (translate to ${language}) below, smaller, high contrast; do not render the word 'Subheadline'.` : '';
        const negativeBlock = `Exclude mesoamerican pyramids, feathered headdress, conquistadors, Spanish ships, jaguar motifs, and any aztec elements. CRITICAL - REMOVE ALL CORNER MARKINGS: Exclude any logos, watermarks, channel badges, branding marks, corner icons, decorative elements, or any visual elements in the four corners of the image (top-left, top-right, bottom-left, bottom-right). The image must be completely clean in all four corners. Do not render channel names, corner marks, badges, icons, symbols, text, or any decorative elements in the corners.`;
        finalPrompt = `${adaptedPrompt}\\n\\n${headlineLine}\\n${subheadlineLine}\\n\\n${negativeBlock}\\n\\n${styleLock}`;
        // Reutilizar rota de gera√ß√£o
        const images = [];
        for (let i = 0; i < Math.max(1, Math.min(variations, 4)); i++) {
            const genResp = await fetch(`http://localhost:${PORT}/api/generate/imagefx`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': req.headers['authorization'] || '' },
                body: JSON.stringify({ prompt: finalPrompt, niche, subniche, style, saveToLibrary: true })
            });
            const genData = await genResp.json();
            if (!genResp.ok) throw new Error(genData.msg || 'Erro ao gerar imagem');
            images.push({
                imageUrl: genData.imageUrl || genData.image || genData.result || null,
                savedToLibrary: !!genData.savedToLibrary,
                libraryId: genData.libraryId || null
            });
        }
        try { await saveAmbientationSnapshot(userId, niche, theme, titleText, sceneElements, scenarioHints, subjectDescription); } catch {}
        return res.json({ success: true, promptUsed: finalPrompt, images });
    } catch (err) {
        console.error('[ByTitle] Erro:', err);
        return res.status(500).json({ msg: err.message || 'Erro ao gerar por t√≠tulo.' });
    }
});

app.get('/api/ambientations/detect', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const title = String(req.query.title || '');
        const niche = req.query.niche || null;
        const match = await detectAmbientationFromTitle(userId, title, niche);
        if (!match) return res.json({ found: false });
        return res.json({ found: true, data: match });
    } catch (err) {
        return res.status(500).json({ msg: 'Falha ao detectar ambienta√ß√£o.' });
    }
});

app.post('/api/ambientations', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { niche, theme_key, keywords, ambiente, elementos, subject } = req.body || {};
        await ensureAmbientationsTable();
        await db.run(
            `INSERT INTO niche_ambientations (user_id, niche, theme_key, keywords, ambiente, elementos, subject, updated_at)
             VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
            [userId, niche || null, theme_key || null, String(keywords || ''), String(ambiente || ''), String(elementos || ''), String(subject || '')]
        );
        return res.json({ success: true });
    } catch (err) {
        return res.status(500).json({ msg: 'Falha ao salvar ambienta√ß√£o.' });
    }
});

app.post('/api/ambientations/seed', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        await seedDefaultAmbientations(userId);
        return res.json({ success: true });
    } catch (err) {
        return res.status(500).json({ msg: 'Falha ao popular temas padr√£o.' });
    }
});

app.get('/api/ambientations', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const rows = await db.all('SELECT id, niche, theme_key, keywords, ambiente, elementos, subject FROM niche_ambientations WHERE user_id = ?', [userId]);
        return res.json(rows || []);
    } catch (err) {
        return res.status(500).json({ msg: 'Falha ao listar ambienta√ß√µes.' });
    }
});
// === FUN√á√ïES DE TRANSCRI√á√ÉO COM WHISPER ===

/**
 * Baixa o √°udio usando yt-dlp (m√©todo mais est√°vel - ignora bugs do ytdl-core)
 */
async function downloadAudioWithYtDlp(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const audioPath = path.join(TEMP_DIR, `${videoId}_${Date.now()}.mp3`);
    
    console.log(`[Whisper] ‚è≥ Baixando √°udio com yt-dlp (m√©todo est√°vel): ${videoId}`);
    
    try {
        // Verificar se yt-dlp est√° dispon√≠vel
        try {
            await execAsync('yt-dlp --version');
        } catch (versionErr) {
            throw new Error('Ferramenta de download n√£o dispon√≠vel no servidor.');
        }
        
        // Montar flags est√°veis para YouTube (EJS + runtime JS + cookies opcionais)
        const cookiesPath = '/data/youtube.cookies.txt';
        const cookiesFlag = fs.existsSync(cookiesPath) ? `--cookies ${cookiesPath}` : '';
        const outputTemplate = audioPath.replace('.mp3', '.%(ext)s');
        const command = `yt-dlp -f bestaudio --extract-audio --audio-format mp3 ${cookiesFlag} \
            --js-runtimes node --force-ipv4 --sleep-requests 5 --no-check-certificate --restrict-filenames \
            -o "${outputTemplate}" "${videoUrl}"`;
        
        console.log(`[Whisper] Executando: yt-dlp...`);
        
        // Timeout curto para evitar esperas longas (15 segundos)
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Timeout: Download demorou mais de 15 segundos')), 15000);
        });
        
        const execPromise = execAsync(command, {
            maxBuffer: 10 * 1024 * 1024 // 10MB buffer
        });
        
        let stdout, stderr;
        try {
            const result = await Promise.race([execPromise, timeoutPromise]);
            stdout = result.stdout;
            stderr = result.stderr;
        } catch (err) {
            // Detectar bloqueio do YouTube rapidamente
            const errorMessage = err.message || err.stderr || '';
            if (errorMessage.includes('Sign in to confirm you\'re not a bot') || 
                errorMessage.includes('confirm you\'re not a bot') ||
                errorMessage.includes('bot detection')) {
                throw new Error('YouTube bloqueou o acesso. O v√≠deo requer autentica√ß√£o ou est√° protegido contra bots.');
            }
            throw err;
        }
        
        // Verificar stderr para bloqueios mesmo em caso de sucesso parcial
        if (stderr) {
            if (stderr.includes('Sign in to confirm you\'re not a bot') || 
                stderr.includes('confirm you\'re not a bot') ||
                stderr.includes('bot detection')) {
                throw new Error('YouTube bloqueou o acesso. O v√≠deo requer autentica√ß√£o ou est√° protegido contra bots.');
            }
            if (!stderr.includes('WARNING')) {
                console.warn(`[Whisper] Avisos do yt-dlp:`, stderr);
            }
        }
        
        // Verificar se o arquivo foi criado
        if (!fs.existsSync(audioPath)) {
            // yt-dlp pode criar com extens√£o diferente, procurar arquivo
            const files = fs.readdirSync(TEMP_DIR);
            const audioFile = files.find(f => f.startsWith(videoId) && (f.endsWith('.mp3') || f.endsWith('.m4a') || f.endsWith('.webm')));
            if (audioFile) {
                const foundPath = path.join(TEMP_DIR, audioFile);
                // Se n√£o for MP3, converter
                if (!audioFile.endsWith('.mp3')) {
                    const mp3Path = audioPath;
                    await new Promise((resolve, reject) => {
                        ffmpeg(foundPath)
                            .audioCodec('libmp3lame')
                            .format('mp3')
                            .on('end', () => {
                                fs.unlinkSync(foundPath); // Remover arquivo original
                                resolve();
                            })
                            .on('error', reject)
                            .save(mp3Path);
                    });
                }
                console.log(`[Whisper] ‚úÖ √Åudio baixado com yt-dlp: ${audioPath}`);
                return audioPath;
            }
            throw new Error('Arquivo de √°udio n√£o foi criado pelo downloader');
        }
        
        console.log(`[Whisper] ‚úÖ √Åudio baixado com yt-dlp: ${audioPath}`);
        return audioPath;
    } catch (err) {
        const errorMessage = err.message || '';
        // Detectar bloqueio do YouTube e falhar rapidamente
        if (errorMessage.includes('Sign in to confirm you\'re not a bot') || 
            errorMessage.includes('confirm you\'re not a bot') ||
            errorMessage.includes('bot detection') ||
            errorMessage.includes('YouTube bloqueou')) {
            console.error(`[Whisper] ‚ùå YouTube bloqueou o acesso (bot detection):`, errorMessage);
            throw new Error('YouTube bloqueou o acesso. Este v√≠deo requer autentica√ß√£o ou est√° protegido contra bots. Tente novamente mais tarde ou use a transcri√ß√£o manual.');
        }
        console.error(`[Whisper] ‚ùå Erro ao baixar com yt-dlp:`, errorMessage);
        throw err;
    }
}

/**
 * Baixa o √°udio de um v√≠deo do YouTube e extrai para arquivo MP3
 * Tenta primeiro com ytdl-core, depois com yt-dlp como fallback (100% est√°vel)
 */
async function downloadAndExtractAudio(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const audioPath = path.join(TEMP_DIR, `${videoId}_${Date.now()}.mp3`);
    
    console.log(`[Whisper] ‚è≥ Baixando √°udio do v√≠deo: ${videoId}`);
    
    // Tentar primeiro com ytdl-core
    try {
        return await new Promise((resolve, reject) => {
            try {
                // Baixar stream de √°udio do YouTube
                // dlChunkSize: 0 evita o bug de segmenta√ß√£o de stream
                // highWaterMark: 1 << 25 evita travamento (33MB buffer)
                const stream = ytdl(videoUrl, {
                    quality: 'highestaudio',
                    filter: 'audioonly',
                    dlChunkSize: 0, // Corrige bug de segmenta√ß√£o
                    highWaterMark: 1 << 25 // 33MB buffer - evita travamento
                });
                
                // Verificar se o stream tem dados v√°lidos
                let hasData = false;
                stream.on('data', (chunk) => {
                    hasData = true;
                });
                
                // Timeout curto para detectar se n√£o h√° dados chegando (3 segundos)
                const dataTimeout = setTimeout(() => {
                    if (!hasData) {
                        stream.destroy();
                        // Tentar yt-dlp quando stream vazio
                        console.log(`[Whisper] Stream vazio detectado, tentando yt-dlp...`);
                        downloadAudioWithYtDlp(videoId)
                            .then(resolve)
                            .catch((ytdlpErr) => {
                                reject(new Error(`Stream vazio e downloader alternativo indispon√≠vel.`));
                            });
                    }
                }, 3000); // 3 segundos para detectar falta de dados (reduzido de 5s)
                
                // Converter para MP3 usando FFmpeg (m√©todo simplificado do tutorial)
                const ffmpegProcess = ffmpeg(stream)
                    .audioCodec('libmp3lame')
                    .noVideo() // Garantir que s√≥ processa √°udio
                    .on('start', (commandLine) => {
                        console.log(`[Whisper] FFmpeg iniciado...`);
                    })
                    .on('progress', (progress) => {
                        if (progress.percent) {
                            console.log(`[Whisper] Progresso: ${Math.round(progress.percent)}%`);
                        }
                    })
                    .on('end', () => {
                        clearTimeout(dataTimeout);
                        console.log(`[Whisper] ‚úÖ √Åudio extra√≠do com sucesso: ${audioPath}`);
                        resolve(audioPath);
                    })
                    .on('error', (err) => {
                        clearTimeout(dataTimeout);
                        const errorMsg = err.message || '';
                        console.error(`[Whisper] ‚ùå Erro no FFmpeg:`, errorMsg);
                        
                        // Detectar bloqueio do YouTube rapidamente
                        if (errorMsg.includes('Sign in to confirm you\'re not a bot') || 
                            errorMsg.includes('confirm you\'re not a bot') ||
                            errorMsg.includes('bot detection')) {
                            reject(new Error('YouTube bloqueou o acesso. Este v√≠deo requer autentica√ß√£o ou est√° protegido contra bots.'));
                            return;
                        }
                        
                        // Verificar se √© erro relacionado a stream vazio - tentar yt-dlp
                        if (errorMsg.includes('Input stream error') ||
                            errorMsg.includes('pipe') ||
                            errorMsg.includes('EPIPE') ||
                            errorMsg.includes('Stream vazio')) {
                            console.log(`[Whisper] FFmpeg falhou por stream vazio, tentando yt-dlp...`);
                            downloadAudioWithYtDlp(videoId)
                                .then(resolve)
                                .catch((ytdlpErr) => {
                                    reject(new Error(`FFmpeg falhou e downloader alternativo indispon√≠vel.`));
                                });
                        } else {
                            reject(new Error(`Erro ao processar √°udio: ${errorMsg}`));
                        }
                    })
                    .save(audioPath);
                
                // Tratar erros do stream do YouTube
                stream.on('error', (streamErr) => {
                    clearTimeout(dataTimeout);
                    const errorMsg = streamErr.message || '';
                    console.error(`[Whisper] ‚ùå Erro no stream do YouTube:`, errorMsg);
                    
                    // Detectar bloqueio do YouTube rapidamente e falhar imediatamente
                    if (errorMsg.includes('Sign in to confirm you\'re not a bot') || 
                        errorMsg.includes('confirm you\'re not a bot') ||
                        errorMsg.includes('bot detection')) {
                        reject(new Error('YouTube bloqueou o acesso. Este v√≠deo requer autentica√ß√£o ou est√° protegido contra bots.'));
                        return;
                    }
                    
                    // Verificar se √© o erro conhecido de parsing - tentar yt-dlp como fallback
                    if (errorMsg.includes('Could not parse') ||
                        errorMsg.includes('decipher function') ||
                        errorMsg.includes('Stream URLs will be missing')) {
                        console.log(`[Whisper] ytdl-core falhou, tentando yt-dlp (m√©todo 100% est√°vel)...`);
                        // Tentar com yt-dlp
                        downloadAudioWithYtDlp(videoId)
                            .then(resolve)
                            .catch((ytdlpErr) => {
                                const ytdlpErrorMsg = ytdlpErr.message || '';
                                // Se yt-dlp tamb√©m detectar bloqueio, falhar imediatamente
                                if (ytdlpErrorMsg.includes('YouTube bloqueou') || 
                                    ytdlpErrorMsg.includes('bot') ||
                                    ytdlpErrorMsg.includes('Sign in to confirm')) {
                                    reject(new Error('YouTube bloqueou o acesso. Este v√≠deo requer autentica√ß√£o ou est√° protegido contra bots.'));
                                } else {
                                    console.error(`[Whisper] yt-dlp tamb√©m falhou:`, ytdlpErrorMsg);
                                    reject(new Error(`N√£o foi poss√≠vel baixar o √°udio. ytdl-core falhou e yt-dlp n√£o est√° instalado ou tamb√©m falhou.`));
                                }
                            });
                    } else {
                        reject(new Error(`Erro ao baixar √°udio do YouTube: ${errorMsg}`));
                    }
                });
                
                // Limpar timeout quando stream terminar
                stream.on('end', () => {
                    clearTimeout(dataTimeout);
                });
                
            } catch (err) {
                console.error(`[Whisper] ‚ùå Erro ao iniciar download com ytdl-core:`, err.message);
                
                // Verificar se √© o erro conhecido de parsing - tentar yt-dlp como fallback
                if (err.message && (
                    err.message.includes('Could not parse') ||
                    err.message.includes('decipher function') ||
                    err.message.includes('Stream URLs will be missing')
                )) {
                    console.log(`[Whisper] ytdl-core falhou, tentando yt-dlp (m√©todo 100% est√°vel)...`);
                    // Tentar com yt-dlp
                    downloadAudioWithYtDlp(videoId)
                        .then(resolve)
                        .catch((ytdlpErr) => {
                            console.error(`[Whisper] yt-dlp tamb√©m falhou:`, ytdlpErr.message);
                            reject(new Error(`N√£o foi poss√≠vel baixar o √°udio. ytdl-core falhou e yt-dlp n√£o est√° instalado ou tamb√©m falhou. Instale yt-dlp: pip install -U yt-dlp`));
                        });
                } else {
                    reject(err);
                }
            }
        });
    } catch (err) {
        // Se ytdl-core falhar completamente, tentar yt-dlp
        console.log(`[Whisper] ytdl-core falhou completamente, tentando yt-dlp (m√©todo 100% est√°vel)...`);
        try {
            return await downloadAudioWithYtDlp(videoId);
        } catch (ytdlpErr) {
            throw new Error(`Ambos os m√©todos falharam. ytdl-core: ${err.message.substring(0, 50)}. yt-dlp: ${ytdlpErr.message.substring(0, 50)}.`);
        }
    }
}

/**
 * Transcreve √°udio usando OpenAI Whisper
 */
async function transcribeWithWhisper(audioPath, userId) {
    try {
        // Buscar chave da OpenAI
        const openaiKeyData = await db.get(
            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
            [userId, 'openai']
        );
        
        if (!openaiKeyData) {
            throw new Error('Chave de API da OpenAI n√£o configurada. Configure sua chave OpenAI nas configura√ß√µes.');
        }
        
        const openaiApiKey = decrypt(openaiKeyData.api_key);
        if (!openaiApiKey) {
            throw new Error('Falha ao desencriptar a chave de API da OpenAI.');
        }
        
        // Inicializar cliente OpenAI
        const openai = new OpenAI({
            apiKey: openaiApiKey
        });
        
        console.log(`[Whisper] üß† Enviando para transcri√ß√£o (Whisper)...`);
        
        // Transcrever usando Whisper (m√©todo simplificado do tutorial)
        const transcription = await openai.audio.transcriptions.create({
            file: fs.createReadStream(audioPath),
            model: 'whisper-1', // Modelo correto do Whisper
            language: 'pt' // Portugu√™s por padr√£o
        });
        
        // A resposta do Whisper pode ser texto direto ou objeto com .text
        const transcriptText = typeof transcription === 'string' ? transcription : transcription.text || transcription;
        
        console.log(`[Whisper] ‚úÖ Transcri√ß√£o conclu√≠da! Tamanho: ${transcriptText.length} caracteres`);
        
        // Limpar arquivo tempor√°rio
        try {
            fs.unlinkSync(audioPath);
            console.log(`[Whisper] Arquivo tempor√°rio removido: ${audioPath}`);
        } catch (cleanupErr) {
            console.warn(`[Whisper] Aviso: N√£o foi poss√≠vel remover arquivo tempor√°rio:`, cleanupErr.message);
        }
        
        return transcriptText;
    } catch (err) {
        // Limpar arquivo tempor√°rio em caso de erro
        try {
            if (fs.existsSync(audioPath)) {
                fs.unlinkSync(audioPath);
            }
        } catch (cleanupErr) {
            console.warn(`[Whisper] Erro ao limpar arquivo:`, cleanupErr.message);
        }
        throw err;
    }
}

/**
 * Fun√ß√£o principal para transcrever v√≠deo usando Whisper (fallback universal)
 */
async function transcribeVideoWithWhisper(videoId, userId) {
    let audioPath = null;
    try {
        // 1. Baixar e extrair √°udio
        audioPath = await downloadAndExtractAudio(videoId);
        
        // 2. Transcrever com Whisper
        const transcript = await transcribeWithWhisper(audioPath, userId);
        
        return transcript;
    } catch (err) {
        // Garantir limpeza do arquivo em caso de erro
        if (audioPath && fs.existsSync(audioPath)) {
            try {
                fs.unlinkSync(audioPath);
            } catch (cleanupErr) {
                console.warn(`[Whisper] Erro ao limpar arquivo ap√≥s erro:`, cleanupErr.message);
            }
        }
        throw err;
    }
}

/**
 * Busca transcri√ß√£o usando youtube-transcript (GRATUITO, busca legendas diretamente do YouTube)
 * Este √© o m√©todo mais r√°pido e confi√°vel quando o v√≠deo tem legendas
 */
async function getTranscriptFromYouTubeTranscript(videoId) {
    try {
        console.log(`[YouTube-Transcript] üîç Buscando transcri√ß√£o via youtube-transcript para: ${videoId}`);
        
        // Tentar buscar transcri√ß√£o com diferentes configura√ß√µes
        let transcriptData;
        const languages = ['pt', 'en', 'es', null]; // Tentar portugu√™s, ingl√™s, espanhol, e sem especificar
        
        for (const lang of languages) {
            try {
                if (lang) {
                    console.log(`[YouTube-Transcript] Tentando idioma: ${lang}`);
                    transcriptData = await YoutubeTranscript.fetchTranscript(videoId, { lang });
                } else {
                    console.log(`[YouTube-Transcript] Tentando sem especificar idioma`);
                    transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
                }
                
                if (transcriptData && transcriptData.length > 0) {
                    break; // Sucesso, sair do loop
                }
            } catch (langErr) {
                console.log(`[YouTube-Transcript] Falha com idioma ${lang || 'padr√£o'}: ${langErr.message}`);
                continue; // Tentar pr√≥ximo idioma
            }
        }
        
        if (!transcriptData || transcriptData.length === 0) {
            throw new Error('Nenhuma transcri√ß√£o encontrada em nenhum idioma dispon√≠vel');
        }
        
        // Juntar todos os textos
        const transcriptText = transcriptData.map(item => item.text).join(' ').trim();
        
        if (!transcriptText || transcriptText.length === 0) {
            throw new Error('Transcri√ß√£o vazia');
        }
        
        console.log(`[YouTube-Transcript] ‚úÖ Transcri√ß√£o obtida! (${transcriptText.length} caracteres, ${transcriptData.length} segmentos)`);
        return transcriptText;
    } catch (err) {
        console.warn(`[YouTube-Transcript] ‚ö†Ô∏è Falha:`, err.message);
        throw new Error(`Nenhuma transcri√ß√£o encontrada: ${err.message}`);
    }
}
/**
 * Busca transcri√ß√£o usando m√∫ltiplos m√©todos com fallback autom√°tico
 * Ordem de prioridade:
 * 1. youtube-transcript (gratuito, mais r√°pido)
 * 2. Whisper Local (open-source, se instalado)
 */
async function getTranscriptWithFallback(videoUrl, userId, videoTitle = null) {
    const videoId = videoUrl.includes('youtu.be') 
        ? videoUrl.split('youtu.be/')[1]?.split('?')[0]
        : new URL(videoUrl).searchParams.get('v') || videoUrl;
    
    console.log(`[Transcri√ß√£o] üéØ Iniciando busca de transcri√ß√£o com m√∫ltiplos m√©todos para: ${videoId}`);
    
    // Timeout geral de 30 segundos para toda a opera√ß√£o de transcri√ß√£o
    const overallTimeout = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Timeout: Opera√ß√£o de transcri√ß√£o demorou mais de 30 segundos')), 30000);
    });
    
    const transcriptionPromise = (async () => {
        // M√âTODO 1: youtube-transcript (GRATUITO, mais r√°pido)
        try {
            console.log(`[Transcri√ß√£o] Tentando m√©todo 1: youtube-transcript (gratuito)...`);
            const transcript = await getTranscriptFromYouTubeTranscript(videoId);
            console.log(`[Transcri√ß√£o] ‚úÖ‚úÖ‚úÖ SUCESSO com youtube-transcript!`);
            return { transcript, source: 'youtube-transcript' };
        } catch (youtubeTranscriptErr) {
            console.warn(`[Transcri√ß√£o] M√©todo 1 falhou:`, youtubeTranscriptErr.message);
        }
        
        // M√âTODO 2: Whisper Local (open-source, se instalado)
        try {
            console.log(`[Transcri√ß√£o] Tentando m√©todo 2: Whisper Local (open-source)...`);
            
            // Verificar se Whisper est√° instalado usando m√©todo confi√°vel
            if (!checkWhisperInstalled()) {
                console.warn('[Transcri√ß√£o] ‚ùå Whisper n√£o encontrado ‚Äî pulando m√©todo local');
                throw new Error('Whisper n√£o est√° instalado. Instale com: pip install git+https://github.com/openai/whisper.git');
            }
            
            console.log(`[Transcri√ß√£o] ‚úÖ Whisper detectado e dispon√≠vel`);
            
            // Para Whisper, usar yt-dlp diretamente (mais confi√°vel que ytdl-core)
            // ytdl-core est√° tendo problemas com YouTube, ent√£o vamos direto para yt-dlp
            console.log(`[Transcri√ß√£o] Baixando √°udio com yt-dlp (m√©todo mais confi√°vel)...`);
            let audioPath;
            let isBotBlocked = false;
            
            try {
                audioPath = await downloadAudioWithYtDlp(videoId);
            } catch (ytdlpErr) {
                const errorMsg = ytdlpErr.message || '';
                // Se detectar bloqueio de bot, n√£o tentar ytdl-core (vai falhar tamb√©m)
                if (errorMsg.includes('YouTube bloqueou') || 
                    errorMsg.includes('bot') ||
                    errorMsg.includes('Sign in to confirm')) {
                    isBotBlocked = true;
                    throw ytdlpErr;
                }
                // Se yt-dlp falhar por outro motivo, tentar com ytdl-core como √∫ltimo recurso
                console.log(`[Transcri√ß√£o] yt-dlp falhou, tentando ytdl-core como fallback...`);
                try {
                    audioPath = await downloadAndExtractAudio(videoId);
                } catch (ytdlErr) {
                    const ytdlErrorMsg = ytdlErr.message || '';
                    if (ytdlErrorMsg.includes('YouTube bloqueou') || 
                        ytdlErrorMsg.includes('bot') ||
                        ytdlErrorMsg.includes('Sign in to confirm')) {
                        isBotBlocked = true;
                    }
                    throw ytdlErr;
                }
            }
            
            // Se foi bloqueado, n√£o tentar transcrever
            if (isBotBlocked) {
                throw new Error('YouTube bloqueou o acesso. Este v√≠deo requer autentica√ß√£o ou est√° protegido contra bots.');
            }
            
            const transcript = await transcribeWithWhisperLocal(audioPath);
            console.log(`[Transcri√ß√£o] ‚úÖ‚úÖ‚úÖ SUCESSO com Whisper Local!`);
            return { transcript, source: 'whisper-local' };
        } catch (whisperErr) {
            const errorMsg = whisperErr.message || '';
            // Se foi bloqueio de bot, falhar imediatamente sem tentar outros m√©todos
            if (errorMsg.includes('YouTube bloqueou') || 
                errorMsg.includes('bot') ||
                errorMsg.includes('Sign in to confirm')) {
                throw new Error('YouTube bloqueou o acesso. Este v√≠deo requer autentica√ß√£o ou est√° protegido contra bots. Tente novamente mais tarde ou use a transcri√ß√£o manual.');
            }
            console.warn(`[Transcri√ß√£o] M√©todo 2 falhou:`, errorMsg);
        }
        
        // Se todos os m√©todos falharam
        throw new Error('Todos os m√©todos de transcri√ß√£o falharam. Tente novamente mais tarde ou cole a transcri√ß√£o manualmente.');
    })();
    
    // Executar com timeout geral
    try {
        return await Promise.race([transcriptionPromise, overallTimeout]);
    } catch (err) {
        const errorMsg = err.message || '';
        if (errorMsg.includes('Timeout')) {
            throw new Error('A transcri√ß√£o est√° demorando muito. O YouTube pode estar bloqueando o acesso. Tente novamente mais tarde ou use a transcri√ß√£o manual.');
        }
        throw err;
    }
}


/**
 * Verifica se o Whisper est√° instalado corretamente
 * @returns {boolean} true se Whisper est√° dispon√≠vel, false caso contr√°rio
 */
function checkWhisperInstalled() {
    try {
        const output = execSync('python3 -c "import whisper; print(\'OK\')"', {
            encoding: 'utf8',
            timeout: 5000,
            stdio: ['ignore', 'pipe', 'pipe']
        }).toString().trim();
        return output === 'OK';
    } catch (err) {
        return false;
    }
}

// Fun√ß√£o para detectar idioma do t√≠tulo baseado em padr√µes comuns
function detectLanguageFromTitle(title) {
    if (!title || typeof title !== 'string') return null;
    
    const titleLower = title.toLowerCase();
    
    // Padr√µes para espanhol
    const spanishPatterns = [
        /\b(el|la|los|las|un|una|de|del|en|con|por|para|que|es|son|est√°|est√°n|se|su|sus|m√°s|muy|tambi√©n|como|cuando|donde|porque|este|esta|estos|estas)\b/i,
        /[√°√©√≠√≥√∫√±√º]/i
    ];
    
    // Padr√µes para portugu√™s
    const portuguesePatterns = [
        /\b(o|a|os|as|um|uma|de|do|da|dos|das|em|com|por|para|que|√©|s√£o|est√°|est√£o|se|seu|sua|seus|suas|mais|muito|tamb√©m|como|quando|onde|porque|este|esta|estes|estas)\b/i,
        /[√°√©√≠√≥√∫√¢√™√¥√£√µ√ß]/i
    ];
    
    // Padr√µes para ingl√™s
    const englishPatterns = [
        /\b(the|a|an|and|or|but|in|on|at|to|for|of|with|by|from|as|is|are|was|were|be|been|being|have|has|had|do|does|did|will|would|should|could|may|might|this|that|these|those|what|which|who|when|where|why|how)\b/i
    ];
    
    // Contar ocorr√™ncias de cada idioma
    let spanishScore = 0;
    let portugueseScore = 0;
    let englishScore = 0;
    
    spanishPatterns.forEach(pattern => {
        if (pattern.test(title)) spanishScore++;
    });
    
    portuguesePatterns.forEach(pattern => {
        if (pattern.test(title)) portugueseScore++;
    });
    
    englishPatterns.forEach(pattern => {
        if (pattern.test(title)) englishScore++;
    });
    
    // Retornar o idioma com maior score
    if (spanishScore > portugueseScore && spanishScore > englishScore) {
        return 'es';
    } else if (portugueseScore > englishScore) {
        return 'pt';
    } else if (englishScore > 0) {
        return 'en';
    }
    
    // Se n√£o detectar, retornar null (usar√° fallback)
    return null;
}


/**
 * Transcreve √°udio usando Whisper LOCAL (open-source oficial da OpenAI)
 * Requer: pip install -U openai-whisper
 * Documenta√ß√£o: https://github.com/openai/whisper
 * Aceita MP3, WAV, M4A e outros formatos suportados pelo Whisper
 * 
 * Modelos dispon√≠veis:
 * - tiny: ~39M par√¢metros, ~1GB VRAM, ~10x mais r√°pido
 * - base: ~74M par√¢metros, ~1GB VRAM, ~7x mais r√°pido (recomendado)
 * - small: ~244M par√¢metros, ~2GB VRAM, ~4x mais r√°pido
 * - medium: ~769M par√¢metros, ~5GB VRAM, ~2x mais r√°pido
 * - large: ~1550M par√¢metros, ~10GB VRAM, 1x (mais preciso)
 * - turbo: ~809M par√¢metros, ~6GB VRAM, ~8x mais r√°pido (otimizado)
 */
async function transcribeWithWhisperLocal(audioPath) {
    try {
        console.log(`[Whisper Local] üß† Transcrevendo com Whisper local (open-source oficial da OpenAI)...`);
        
        // Verificar se arquivo existe
        if (!fs.existsSync(audioPath)) {
            throw new Error(`Arquivo de √°udio n√£o encontrado: ${audioPath}`);
        }
        
        // Preparar caminho do arquivo de sa√≠da
        const outputDir = path.dirname(audioPath);
        const audioName = path.basename(audioPath, path.extname(audioPath));
        const transcriptFile = path.join(outputDir, `${audioName}.txt`);
        
        // Executar Whisper local usando o modelo oficial da OpenAI
        // --model base: modelo base (equil√≠brio entre velocidade e qualidade)
        // Sem --language: Whisper detecta automaticamente o idioma (comportamento padr√£o)
        // --output_format txt: formato texto simples
        // --output_dir: diret√≥rio de sa√≠da
        // Whisper aceita MP3, WAV, M4A, FLAC, etc automaticamente
        // Usar 'python -m whisper' para garantir que funcione mesmo se n√£o estiver no PATH
    let command = `python3 -m whisper "${audioPath}" --model base --output_format txt --output_dir "${outputDir}"`;
        
        console.log(`[Whisper Local] Executando: python3 -m whisper "${path.basename(audioPath)}" com modelo base (detec√ß√£o autom√°tica de idioma)...`);
        
        try {
            execSync(command, { 
                stdio: 'inherit',
                timeout: 600000 // 10 minutos de timeout
            });
        } catch (pythonErr) {
            console.error(`[Whisper Local] Erro ao executar Whisper:`, pythonErr.message);
            throw new Error(`Falha ao transcrever com Whisper: ${pythonErr.message}`);
        }
        
        // Ler arquivo de transcri√ß√£o gerado
        if (!fs.existsSync(transcriptFile)) {
            throw new Error('Arquivo de transcri√ß√£o n√£o foi gerado pelo Whisper');
        }
        
        const transcriptText = fs.readFileSync(transcriptFile, 'utf8').trim();
        
        if (!transcriptText || transcriptText.length === 0) {
            throw new Error('Transcri√ß√£o vazia - o √°udio pode estar sem fala ou muito baixo');
        }
        
        console.log(`[Whisper Local] ‚úÖ Transcri√ß√£o conclu√≠da! Tamanho: ${transcriptText.length} caracteres`);
        
        // Limpar arquivos tempor√°rios
        try {
            fs.unlinkSync(audioPath);
            fs.unlinkSync(transcriptFile);
            // Limpar outros arquivos gerados pelo Whisper (JSON, VTT, SRT, etc)
            const files = fs.readdirSync(outputDir);
            files.forEach(file => {
                if (file.startsWith(audioName) && file !== audioName) {
                    try {
                        fs.unlinkSync(path.join(outputDir, file));
                    } catch (e) {
                        // Ignorar erros de limpeza
                    }
                }
            });
        } catch (cleanupErr) {
            console.warn(`[Whisper Local] Aviso: N√£o foi poss√≠vel remover alguns arquivos tempor√°rios:`, cleanupErr.message);
        }
        
        return transcriptText;
    } catch (err) {
        // Limpar arquivo tempor√°rio em caso de erro
        try {
            if (fs.existsSync(audioPath)) {
                fs.unlinkSync(audioPath);
            }
        } catch (cleanupErr) {
            console.warn(`[Whisper Local] Erro ao limpar arquivo:`, cleanupErr.message);
        }
        throw err;
    }
}

/**
 * Baixa v√≠deo de URL (YouTube ou MP4 direto) e extrai √°udio
 */
async function downloadVideoAndExtractAudio(videoUrl) {
    const tempVideo = path.join(TEMP_DIR, `video_${Date.now()}.mp4`);
    const tempAudio = path.join(TEMP_DIR, `audio_${Date.now()}.wav`);
    
    try {
        console.log(`[Download] üé¨ Baixando v√≠deo de: ${videoUrl}`);
        
        // Verificar se √© URL do YouTube
        if (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be')) {
            // Extrair ID do v√≠deo
            let videoId = null;
            if (videoUrl.includes('youtu.be')) {
                videoId = videoUrl.split('youtu.be/')[1]?.split('?')[0];
            } else {
                const urlObj = new URL(videoUrl);
                videoId = urlObj.searchParams.get('v');
            }
            
            if (videoId) {
                // Usar m√©todo existente para baixar √°udio do YouTube
                return await downloadAndExtractAudio(videoId);
            }
        }
        
        // Para URLs diretas de v√≠deo (MP4, etc)
        console.log(`[Download] Baixando v√≠deo direto...`);
        const response = await axios.get(videoUrl, { 
            responseType: 'arraybuffer',
            timeout: 300000 // 5 minutos
        });
        fs.writeFileSync(tempVideo, response.data);
        
        console.log(`[Download] üéß Extraindo √°udio...`);
        await new Promise((resolve, reject) => {
            ffmpeg(tempVideo)
                .noVideo()
                .audioCodec('pcm_s16le')
                .audioChannels(1)
                .audioFrequency(16000)
                .save(tempAudio)
                .on('end', resolve)
                .on('error', reject);
        });
        
        // Limpar v√≠deo tempor√°rio
        try {
            fs.unlinkSync(tempVideo);
        } catch (e) {}
        
        return tempAudio;
    } catch (err) {
        // Limpar arquivos tempor√°rios em caso de erro
        try {
            if (fs.existsSync(tempVideo)) fs.unlinkSync(tempVideo);
            if (fs.existsSync(tempAudio)) fs.unlinkSync(tempAudio);
        } catch (e) {}
        throw err;
    }
}

// === ROTAS DE TRANSCRI√á√ÉO ===

/**
 * Rota para transcrever v√≠deo por URL (YouTube ou MP4 direto)
 * Usa Whisper LOCAL (open-source, sem API Key)
 * GET /api/transcribe?url=https://www.youtube.com/watch?v=XXXXX
 * GET /api/transcribe?url=https://meusite.com/video.mp4
 */
app.get('/api/transcribe', authenticateToken, async (req, res) => {
    const videoUrl = req.query.url;
    
    if (!videoUrl) {
        return res.status(400).json({ 
            error: 'URL obrigat√≥ria',
            msg: 'Forne√ßa a URL do v√≠deo no par√¢metro ?url='
        });
    }
    
    let tempAudio = null;
    
    try {
        console.log(`[Transcribe] üé¨ Iniciando transcri√ß√£o para: ${videoUrl}`);
        
        // 1. Baixar v√≠deo e extrair √°udio
        tempAudio = await downloadVideoAndExtractAudio(videoUrl);
        
        // 2. Transcrever com Whisper local
        const transcript = await transcribeWithWhisperLocal(tempAudio);
        
        console.log(`[Transcribe] ‚úÖ Transcri√ß√£o conclu√≠da!`);
        res.json({ 
            success: true, 
            text: transcript,
            source: 'whisper-local'
        });
    } catch (err) {
        console.error(`[Transcribe] ‚ùå Erro na transcri√ß√£o:`, err.message);
        
        // Limpar arquivo tempor√°rio em caso de erro
        if (tempAudio && fs.existsSync(tempAudio)) {
            try {
                fs.unlinkSync(tempAudio);
            } catch (e) {}
        }
        
        res.status(500).json({ 
            error: 'Falha ao transcrever v√≠deo',
            msg: 'Transcri√ß√£o indispon√≠vel no momento. Tente novamente ou cole a transcri√ß√£o manualmente.'
        });
    }
});

// === ROTAS DE AGENTES DE ROTEIRO ===

/**
 * Fun√ß√£o para obter transcri√ß√£o com sistema de fallback
 * Tenta usar DownSub primeiro, depois YoutubeTranscript, depois outros m√©todos
 */
async function getTranscriptWithFallback(videoUrl, userId, videoTitle = null) {
    const errors = [];
    
    // M√âTODO 1: Tentar usar API DownSub (se configurada)
    try {
        console.log('[Transcri√ß√£o] Tentando usar API DownSub...');
        
        // Buscar chave do DownSub do admin
        const downsubApi = await db.get(`
            SELECT api_key FROM api_providers 
            WHERE provider = 'downsub' AND is_active = 1
            LIMIT 1
        `);
        
        if (downsubApi && downsubApi.api_key) {
            let apiKey = null;
            try {
                // Tentar descriptografar primeiro
                apiKey = decrypt(downsubApi.api_key);
            } catch (decryptErr) {
                // Se falhar, pode n√£o estar criptografada
                console.warn('[Transcri√ß√£o] Erro ao descriptografar chave DownSub, tentando usar diretamente:', decryptErr.message);
                apiKey = downsubApi.api_key;
            }
            
            // Se ainda n√£o tiver chave, usar diretamente (pode n√£o estar criptografada)
            if (!apiKey) {
                apiKey = downsubApi.api_key;
            }
            
            if (apiKey && apiKey.trim().length > 0) {
                console.log('[Transcri√ß√£o] Chave DownSub encontrada, tentando obter transcri√ß√£o...');
                const transcript = await getTranscriptFromDownSub(videoUrl, apiKey);
                if (transcript && transcript.trim().length > 0) {
                    console.log('[Transcri√ß√£o] ‚úì Sucesso com DownSub!');
                    return { transcript, source: 'downsub' };
                }
            } else {
                console.warn('[Transcri√ß√£o] Chave DownSub vazia ou inv√°lida');
            }
        } else {
            console.log('[Transcri√ß√£o] API DownSub n√£o configurada ou inativa');
        }
    } catch (downsubErr) {
        console.warn('[Transcri√ß√£o] DownSub falhou:', downsubErr.message);
        errors.push(`DownSub: ${downsubErr.message}`);
    }
    
    // M√âTODO 2: Tentar usar YoutubeTranscript (biblioteca)
    try {
        console.log('[Transcri√ß√£o] Tentando usar YoutubeTranscript...');
        const videoId = videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be')
            ? (videoUrl.match(/[?&]v=([^&]+)/) || videoUrl.match(/youtu\.be\/([^?]+)/))?.[1]
            : videoUrl;
        
        if (videoId) {
            const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
            const transcript = transcriptData.map(t => t.text).join(' ');
            if (transcript && transcript.trim().length > 0) {
                console.log('[Transcri√ß√£o] ‚úì Sucesso com YoutubeTranscript!');
                return { transcript, source: 'youtube-transcript' };
            }
        }
    } catch (ytErr) {
        console.warn('[Transcri√ß√£o] YoutubeTranscript falhou:', ytErr.message);
        errors.push(`YoutubeTranscript: ${ytErr.message}`);
    }
    
    // Se todos os m√©todos falharam
    throw new Error(`Todos os m√©todos de transcri√ß√£o falharam. Erros: ${errors.join('; ')}`);
}

// Rota para obter transcri√ß√£o completa de um v√≠deo
app.get('/api/video/transcript/:videoId', authenticateToken, async (req, res) => {
    let { videoId } = req.params;
    const userId = req.user.id;

    console.log(`[Transcri√ß√£o] Rota chamada - Par√¢metro recebido: "${videoId}"`);
    console.log(`[Transcri√ß√£o] User ID: ${userId}`);
    console.log(`[Transcri√ß√£o] URL completa: ${req.url}`);
    console.log(`[Transcri√ß√£o] Par√¢metros:`, req.params);
    
    // Garantir que a resposta n√£o ser√° fechada prematuramente
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('Keep-Alive', 'timeout=900'); // 15 minutos

    // Validar e limpar o ID do v√≠deo (fazer isso antes de qualquer coisa)
    // Remover qualquer caractere inv√°lido que possa ter sido adicionado (como :1 no final)
    let cleanVideoId = String(videoId || '').trim();
    
    // Remover sufixos estranhos que podem aparecer (como :1, :2, etc)
    cleanVideoId = cleanVideoId.split(':')[0].split('?')[0].split('#')[0];
    
    // Validar formato b√°sico do videoId do YouTube (11 caracteres alfanum√©ricos)
    if (!cleanVideoId || cleanVideoId.length < 10) {
        console.error(`[Transcri√ß√£o] ‚ùå VideoId inv√°lido: "${videoId}" -> "${cleanVideoId}"`);
        return res.status(400).json({ 
            msg: 'ID do v√≠deo inv√°lido',
            error: `VideoId recebido: "${videoId}"`
        });
    }
    
    // Se for uma URL completa, extrair o ID
    if (cleanVideoId.includes('youtube.com') || cleanVideoId.includes('youtu.be')) {
        try {
            const urlObj = new URL(cleanVideoId.includes('http') ? cleanVideoId : `https://${cleanVideoId}`);
            if (urlObj.hostname.includes('youtu.be')) {
                cleanVideoId = urlObj.pathname.substring(1);
            } else {
                cleanVideoId = urlObj.searchParams.get('v') || cleanVideoId;
            }
        } catch (urlErr) {
            console.warn(`[Transcri√ß√£o] Erro ao processar URL, usando como ID: ${cleanVideoId}`);
        }
    }

    // Log adicional para debug
    console.log(`[Transcri√ß√£o] VideoId limpo: "${cleanVideoId}" (tamanho: ${cleanVideoId.length})`);
    
    try {
        // Primeiro, tentar buscar do banco de dados (cache)
        const analysis = await db.get(
            'SELECT full_transcript FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
            [cleanVideoId, userId]
        );

        if (analysis && analysis.full_transcript) {
            console.log(`[Transcri√ß√£o] ‚úì Transcri√ß√£o encontrada no cache`);
            return res.status(200).json({ 
                transcript: analysis.full_transcript,
                source: 'database'
            });
        }

        // Buscar t√≠tulo do v√≠deo do banco de dados para detectar idioma
        let videoTitle = null;
        try {
            const videoData = await db.get(
                'SELECT original_title FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                [cleanVideoId, userId]
            );
            if (videoData && videoData.original_title) {
                videoTitle = videoData.original_title;
                console.log(`[Transcri√ß√£o] T√≠tulo encontrado: ${videoTitle}`);
            }
        } catch (titleErr) {
            console.warn(`[Transcri√ß√£o] N√£o foi poss√≠vel buscar t√≠tulo do v√≠deo:`, titleErr.message);
        }
        
        // Usar sistema de fallback com m√∫ltiplos m√©todos
        console.log(`[Transcri√ß√£o] Buscando transcri√ß√£o com sistema de fallback para v√≠deo ID: ${cleanVideoId}`);
        console.log(`[Transcri√ß√£o] URL do v√≠deo: https://www.youtube.com/watch?v=${cleanVideoId}`);
        
        try {
            const videoUrl = `https://www.youtube.com/watch?v=${cleanVideoId}`;
            const result = await getTranscriptWithFallback(videoUrl, userId, videoTitle);
            
            if (result.transcript && result.transcript.trim().length > 0) {
                console.log(`[Transcri√ß√£o] ‚úì‚úì‚úì SUCESSO com ${result.source}! (${result.transcript.length} caracteres)`);
                
                // Salvar no banco de dados para cache
                try {
                    await db.run(
                        'UPDATE analyzed_videos SET full_transcript = ? WHERE youtube_video_id = ? AND user_id = ?',
                        [result.transcript, cleanVideoId, userId]
                    );
                } catch (dbErr) {
                    console.warn(`[Transcri√ß√£o] Aviso: N√£o foi poss√≠vel salvar transcri√ß√£o no banco:`, dbErr.message);
                }
                
                return res.status(200).json({ 
                    transcript: result.transcript,
                    source: result.source
                });
            } else {
                throw new Error('Transcri√ß√£o vazia retornada');
            }
        } catch (transcriptErr) {
            console.error(`[Transcri√ß√£o] ‚úó‚úó‚úó FALHA com todos os m√©todos:`, transcriptErr.message);
            console.error(`[Transcri√ß√£o] Stack trace:`, transcriptErr.stack?.substring(0, 300));
            
            // Retornar erro espec√≠fico
            let userMessage = 'N√£o foi poss√≠vel obter a transcri√ß√£o deste v√≠deo.';
            let statusCode = 404;
            
            if (transcriptErr.message.includes('Whisper n√£o est√° instalado')) {
                userMessage = 'N√£o foi poss√≠vel obter a transcri√ß√£o automaticamente neste momento. Tente novamente mais tarde ou cole a transcri√ß√£o manualmente ao criar o agente de roteiro.';
            } else if (transcriptErr.message.includes('Todos os m√©todos de transcri√ß√£o falharam')) {
                userMessage = 'N√£o foi poss√≠vel obter a transcri√ß√£o com nenhum m√©todo dispon√≠vel.\n\nPoss√≠veis solu√ß√µes:\n1. Verifique se o v√≠deo possui legendas habilitadas no YouTube\n2. Tente novamente mais tarde\n3. Cole a transcri√ß√£o manualmente ao criar o agente de roteiro';
            } else {
                userMessage = `Erro ao buscar transcri√ß√£o: ${transcriptErr.message}`;
            }
            
            if (!res.headersSent) {
                return res.status(statusCode).json({ 
                    msg: userMessage,
                    error: process.env.NODE_ENV === 'development' ? {
                        error: transcriptErr.message,
                        videoId: cleanVideoId,
                        videoUrl: `https://www.youtube.com/watch?v=${cleanVideoId}`
                    } : undefined
                });
            }
        }
    } catch (err) {
        console.error('[ERRO NA ROTA /api/video/transcript]:', err);
        console.error('[ERRO Stack]:', err.stack?.substring(0, 500));
        
        // Garantir que sempre retornamos uma resposta, mesmo em caso de erro
        if (!res.headersSent) {
            try {
                res.status(500).json({ 
                    msg: err.message || 'Erro ao obter transcri√ß√£o do v√≠deo.',
                    error: process.env.NODE_ENV === 'development' ? {
                        message: err.message,
                        stack: err.stack?.substring(0, 300)
                    } : undefined
                });
            } catch (responseErr) {
                console.error('[ERRO ao enviar resposta de erro]:', responseErr);
            }
        } else {
            console.warn('[AVISO] Tentativa de enviar resposta quando headers j√° foram enviados');
        }
    }
});

app.post('/api/video/transcript/analyze', authenticateToken, async (req, res) => {
    const { transcript, videoId, videoTitle, niche, subniche, generateAgent } = req.body || {};
    const userId = req.user.id;

    if (!transcript || typeof transcript !== 'string' || transcript.trim().length < 400) {
        return res.status(400).json({ msg: 'Forne√ßa a transcri√ß√£o completa (m√≠nimo ~400 caracteres) para gerar a an√°lise.' });
    }

    try {
        const result = await analyzeTranscriptForVirality({
            userId,
            transcript,
            videoTitle,
            niche,
            subniche
        });

        const response = {
            analysis: result.analysis,
            provider: result.provider,
            videoId: videoId || null
        };

        // Se solicitado, gerar agente automaticamente ap√≥s a an√°lise
        if (generateAgent === true) {
            try {
                const agentResult = await generateAgentFromTranscript({
                    userId,
                    transcript,
                    videoTitle,
                    niche,
                    subniche,
                    analysis: result.analysis
                });
                response.agent = agentResult.agent;
                response.agentProvider = agentResult.provider;
            } catch (agentErr) {
                console.error('[ERRO ao gerar agente automaticamente]:', agentErr);
                response.agentError = agentErr.message;
            }
        }

        res.status(200).json(response);
    } catch (err) {
        console.error('[ERRO /api/video/transcript/analyze]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao analisar o roteiro.' });
    }
});

// === ROTA LAOZHANG PARA AN√ÅLISE DE TRANSCRI√á√ÉO ===
app.post('/api/video/transcript/analyze/laozhang', authenticateToken, async (req, res) => {
    const { transcript, videoId, videoTitle, niche, subniche, model: requestedModel } = req.body || {};
    const userId = req.user.id;

    if (!transcript || typeof transcript !== 'string' || transcript.trim().length < 400) {
        return res.status(400).json({ msg: 'Forne√ßa a transcri√ß√£o completa (m√≠nimo ~400 caracteres) para gerar a an√°lise.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo n√£o configurada no painel admin.' });
        }
        
        // Mapear modelo selecionado para modelo da laozhang.ai
        let modelToUse = requestedModel || 'gpt-4o';
        if (modelToUse === 'gpt-4o' || modelToUse === 'GPT-4o (2025)') {
            modelToUse = 'gpt-4o';
        } else if (modelToUse === 'claude-3-7-sonnet-20250219' || modelToUse === 'Claude 3.7 Sonnet (Fev/25)') {
            modelToUse = 'claude-3-7-sonnet-20250219';
        } else if (modelToUse === 'gemini-2.5-pro' || modelToUse === 'Gemini 2.5 Pro (2025)') {
            modelToUse = 'gemini-2.5-pro';
        }

        const sanitizedTranscript = transcript.trim();
        const truncatedTranscript = sanitizedTranscript.length > 20000
            ? `${sanitizedTranscript.substring(0, 20000)}\n[... conte√∫do truncado para an√°lise ...]`
            : sanitizedTranscript;

        const analysisPrompt = `
Voc√™ √© um ESTRATEGISTA DE CONTE√öDO para YouTube. Analise profundamente o roteiro abaixo e explique POR QUE ele viralizou.

Retorne APENAS um JSON v√°lido no formato:
{
  "resumo": "s√≠ntese em 2-3 frases",
  "motivosVirais": ["motivo 1", "motivo 2", "..."],
  "gatilhosEmocionais": ["gatilho 1", "..."],
  "estruturaNarrativa": [
    { "etapa": "Nome curto", "descricao": "O que acontece nessa parte", "tempoAproximado": "0:00-0:45" }
  ],
  "formulaChecklist": [
    {
      "item": "Elemento da f√≥rmula",
      "status": "aplicado" ou "melhorar",
      "porqueFunciona": "Explica√ß√£o curta",
      "comoAplicarNoMeuConteudo": "Diretriz pr√°tica",
      "upgradeSugerido": "Ajuste para ficar 10/10"
    }
  ],
  "diferencialProposto": "Diferencial para deixar ainda melhor",
  "sugestoesAplicacao": ["a√ß√£o 1", "a√ß√£o 2"],
  "alertas": ["poss√≠veis riscos ou pontos de aten√ß√£o"]
}

Regras:
- Idioma: portugu√™s do Brasil.
- N√£o copie trechos do roteiro; descreva a f√≥rmula e o racioc√≠nio.
- Mostre como replicar a estrutura sem plagiar.
- Foque em transformar os aprendizados em um checklist acion√°vel.

Contexto do v√≠deo:
- T√≠tulo: ${videoTitle || 'N/A'}
- Nicho: ${niche || 'N/A'}
- Subnicho: ${subniche || 'N/A'}

ROTEIRO COMPLETO:
"""${truncatedTranscript}"""`;

        const response = await callLaozhangAPI(
            analysisPrompt,
            laozhangApiKey,
            modelToUse,
            null,
            userId,
            'api_transcript_analyze',
            JSON.stringify({ endpoint: '/api/video/transcript/analyze/laozhang', model: modelToUse })
        );

        // Parsear resposta JSON
        let analysis;
        const rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        try {
            analysis = JSON.parse(rawResponse);
        } catch (e) {
            // Tentar extrair JSON
            const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    analysis = JSON.parse(jsonMatch[0]);
                } catch (e2) {
                    throw new Error('Resposta da IA n√£o cont√©m JSON v√°lido.');
                }
            } else {
                throw new Error('Resposta da IA n√£o cont√©m JSON v√°lido.');
            }
        }

        res.status(200).json({
            analysis: analysis,
            provider: 'laozhang',
            videoId: videoId || null
        });
    } catch (err) {
        console.error('[ERRO /api/video/transcript/analyze/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao analisar o roteiro.' });
    }
});

// Rota para criar um agente de roteiro a partir de um v√≠deo transcrito
app.post('/api/script-agents/create', authenticateToken, async (req, res) => {
    const { videoId, videoUrl, videoTitle, agentName, niche, subniche, manualTranscript, viralInsights } = req.body;
    const userId = req.user.id;

    if (!videoId || !agentName) {
        return res.status(400).json({ msg: 'ID do v√≠deo e nome do agente s√£o obrigat√≥rios.' });
    }

    try {
        // PRIORIDADE 1: Usar transcri√ß√£o manual se fornecida
        let fullTranscript = null;
        
        if (manualTranscript && manualTranscript.trim().length > 0) {
            fullTranscript = manualTranscript.trim();
            console.log(`[Agente] ‚úÖ Usando transcri√ß√£o manual fornecida pelo usu√°rio (${fullTranscript.length} caracteres)`);
        } else {
            // PRIORIDADE 2: Buscar transcri√ß√£o do banco de dados
            try {
                const analysis = await db.get(
                    'SELECT full_transcript FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                    [videoId, userId]
                );

                if (analysis && analysis.full_transcript) {
                    fullTranscript = analysis.full_transcript;
                    console.log(`[Agente] ‚úÖ Usando transcri√ß√£o do banco de dados (${fullTranscript.length} caracteres)`);
                } else {
                    // PRIORIDADE 3: Tentar buscar diretamente do YouTube (fallback antigo)
                    console.log(`[Agente] ‚ö†Ô∏è Transcri√ß√£o n√£o encontrada no banco, tentando m√©todo alternativo...`);
                    const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
                    if (geminiKeyData) {
                        const geminiApiKey = decrypt(geminiKeyData.api_key);
                        if (geminiApiKey) {
                            try {
                                const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);
                                fullTranscript = transcriptData.map(t => t.text).join(' ');
                                console.log(`[Agente] ‚úÖ Transcri√ß√£o obtida via YouTube Transcript (${fullTranscript.length} caracteres)`);
                            } catch (ytErr) {
                                console.warn(`[Agente] ‚ö†Ô∏è Falha ao buscar transcri√ß√£o via YouTube Transcript:`, ytErr.message);
                            }
                        }
                    }
                }
            } catch (transcriptErr) {
                console.warn('[Agente] Erro ao obter transcri√ß√£o:', transcriptErr.message);
            }
        }

        // Se n√£o houver transcri√ß√£o, permitir criar agente b√°sico (ser√° criado com prompt b√°sico)
        if (!fullTranscript || fullTranscript.trim().length < 100) {
            console.warn(`[Agente] ‚ö†Ô∏è Transcri√ß√£o n√£o dispon√≠vel ou muito curta (${fullTranscript?.length || 0} caracteres). Criando agente com prompt b√°sico.`);
            // N√£o retornar erro, mas criar agente com prompt b√°sico baseado apenas no t√≠tulo e nicho
        }

        // Analisar e capturar a f√≥rmula viral durante a cria√ß√£o do agente
        let viralFormulaData = null;
        if (fullTranscript && fullTranscript.trim().length >= 500) {
            try {
                const claudeKeyRow = await db.get(
                    'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                    [userId, 'claude']
                );

                if (claudeKeyRow && claudeKeyRow.api_key) {
                    const claudeApiKey = decrypt(claudeKeyRow.api_key);
                    if (claudeApiKey) {
                        const viralReplicator = new ViralFormulaReplicator();
                        console.log('[Agente] üîç Analisando f√≥rmula viral durante cria√ß√£o do agente...');
                        viralFormulaData = await viralReplicator.analyzeViralFormula(
                            fullTranscript,
                            claudeApiKey,
                            videoTitle,
                            niche || subniche || 'geral'
                        );
                        console.log('[Agente] ‚úÖ F√≥rmula viral capturada e pronta para reutiliza√ß√£o futura.');
                    } else {
                        console.warn('[Agente] ‚ö†Ô∏è Falha ao desencriptar API key do Claude para an√°lise de f√≥rmula.');
                    }
                } else {
                    console.warn('[Agente] ‚ö†Ô∏è API key do Claude n√£o configurada. F√≥rmula viral n√£o ser√° armazenada.');
                }
            } catch (formulaErr) {
                console.error('[Agente] ‚ö†Ô∏è Erro ao analisar f√≥rmula viral durante cria√ß√£o do agente:', formulaErr.message);
            }
        }

        // Buscar provedor de IA preferencial (Claude > GPT > Gemini)
        const aiProvider = await getPreferredAIProvider(userId, ['claude', 'openai', 'gemini']);
        if (!aiProvider) {
            return res.status(400).json({ msg: 'Configure uma chave do Claude, OpenAI ou Gemini para criar agentes.' });
        }

        // Criar prompt para o agente usando IA
        let agentPrompt;
        let insightsSection = '';
        if (viralInsights && typeof viralInsights === 'object') {
            try {
                const serializedInsights = JSON.stringify(viralInsights);
                insightsSection = `\nINSIGHTS DO V√çDEO VIRAL (checklist e diferencial identificados anteriormente):\n${serializedInsights.substring(0, 6000)}\n`;
            } catch (err) {
                console.warn('[Agente] N√£o foi poss√≠vel serializar viralInsights:', err.message);
            }
        }
        
        if (fullTranscript && fullTranscript.trim().length >= 100) {
            // Usar o roteiro completo (ou at√© 50000 caracteres para an√°lise mais profunda)
            const transcriptToAnalyze = fullTranscript.length > 50000 
                ? fullTranscript.substring(0, 50000) + '\n[... roteiro continua ...]'
                : fullTranscript;
            
            agentPrompt = `PASSO 1 - CRIAR ROTEIRO BASE:
Preciso que voc√™ me ajude a criar um agente de cria√ß√£o de roteiros em forma de documento no nicho de ${niche || 'N/A'} subnichado em ${subniche || 'N/A'}. 

Vou te mandar uma transcri√ß√£o de um roteiro e quero que o agente crie roteiros com a mesma estrutura da TRANSCRI√á√ÉO. O agente deve criar os roteiros com par√°grafos longos, cheios, sem quebras de linha excessivas e deve evitar termos t√©cnicos como "capitulo x" ou "parte tal" deve seguir apenas com o conte√∫do para facilitar que eu copie o roteiro para um documento. O agente deve produzir roteiros com em m√©dia 30 mil caracteres em ptbr. Preciso que o texto seja feito em um bloco √∫nico, sem separa√ß√£o por subt√≠tulos ou t√≥picos e que n√£o possua palavras destacadas em negrito ou algo do tipo. Esse texto vai ser narrado por uma IA, por isso pe√ßo que retire todos os travess√µes ou hifens em palavras ou frases, para que n√£o ocorra nenhum tipo de bug na hora que a IA for narrar esse texto. Corte a introdu√ß√£o da resposta do prompt e v√° direto ao texto traduzido. Mantenha a ess√™ncia de um roteiro feito para youtube, como CTA de like e inscri√ß√£o no canal.

PASSO 2 - INTRODU√á√ÉO:
Crie uma introdu√ß√£o breve e impactante para o v√≠deo com o t√≠tulo "${videoTitle || 'N/A'}" como refer√™ncia no agente. A introdu√ß√£o deve ser envolvente, criar conex√£o com o p√∫blico, gerar identifica√ß√£o imediata, tocar diretamente na dor que o espectador sente e apresentar a promessa de uma solu√ß√£o real e acess√≠vel. Use linguagem emocional, simples e direta, como se estivesse falando com algu√©m que sofre com esse problema h√° muito tempo. Utilize riqueza de detalhes e storytelling para o p√∫blico se identificar.

PASSO 3 - CTA DE INSCRI√á√ÉO:
Crie um CTA de inscri√ß√£o envolvente e humanizado para um canal desse nicho e subnicho espec√≠fico voltado ao p√∫blico que sofre com essa dor espec√≠fica. O CTA deve incentivar a inscri√ß√£o de forma acolhedora, sem press√£o, destacando os benef√≠cios de acompanhar o canal. Use linguagem simples, direta e emocional. O tom deve transmitir cuidado, confian√ßa e autoridade.

PASSO 4 - CTA DE COMENT√ÅRIO:
Crie um CTA envolvente, localizado por volta de 1/3 do v√≠deo, que provoque o espectador a comentar. O trecho deve usar uma pergunta direta, gerar identifica√ß√£o com a dor ou dificuldade da audi√™ncia, e ativar emocionalmente a pessoa ‚Äî como se ela estivesse sendo ouvida pela primeira vez. O texto deve induzir o coment√°rio com uma frase pronta para copiar e colar, e fazer o espectador sentir que sua participa√ß√£o ajuda outras pessoas. Use um tom emp√°tico, acolhedor e de conversa √≠ntima, como se estivesse falando com um amigo que sofre em sil√™ncio.

TRANSCRI√á√ÉO DE REFER√äNCIA:
"""${transcriptToAnalyze}"""

T√çTULO DO V√çDEO: ${videoTitle || 'N/A'}
NICHE: ${niche || 'N/A'}
SUBNICHE: ${subniche || 'N/A'}

INSTRU√á√ïES PARA O AGENTE:
Com base na transcri√ß√£o acima, crie um agente que:
1. Gere roteiros seguindo a mesma estrutura e estilo da transcri√ß√£o
2. Use a introdu√ß√£o, CTA de inscri√ß√£o e CTA de coment√°rio criados acima
3. Mantenha o tom, estilo narrativo e elementos virais identificados
4. Produza roteiros completos de aproximadamente 30.000 caracteres
5. Formate o texto como um bloco √∫nico, sem quebras excessivas ou formata√ß√£o especial
6. Remova todos os travess√µes e hifens que possam causar problemas na narra√ß√£o por IA

Crie:`;
        } else {
            // Se n√£o houver transcri√ß√£o, criar um prompt b√°sico baseado apenas no t√≠tulo e nicho
            agentPrompt = `Voc√™ √© um especialista em criar roteiros virais para YouTube. Crie um "agente de roteiro" baseado nas informa√ß√µes dispon√≠veis sobre um v√≠deo de sucesso.

T√çTULO DO V√çDEO: ${videoTitle || 'N/A'}
NICHE: ${niche || 'N/A'}
SUBNICHE: ${subniche || 'N/A'}

NOTA: A transcri√ß√£o completa do v√≠deo n√£o est√° dispon√≠vel, mas voc√™ deve criar um agente de roteiro baseado no t√≠tulo, nicho e subnicho fornecidos. O agente deve ser capaz de gerar roteiros virais seguindo o padr√£o sugerido pelo t√≠tulo e contexto do nicho.

Crie:`;
        }

        agentPrompt += `${insightsSection}

IMPORTANTE:
- N√ÉO copie o texto do roteiro original.
- Extraia apenas a F√ìRMULA, estrutura, ritmo e gatilhos que tornam o v√≠deo viral.
- Use os 4 PASSOS acima (roteiro base, introdu√ß√£o, CTA inscri√ß√£o, CTA coment√°rio) como base para criar o agente.
- O agente deve ser capaz de receber APENAS um t√≠tulo de v√≠deo e gerar um roteiro completo seguindo EXATAMENTE a mesma estrutura e f√≥rmula viral do roteiro original analisado.

Responda APENAS com um objeto JSON v√°lido no seguinte formato:
{
  "agent_prompt": "Prompt base detalhado que inclui os 4 PASSOS (roteiro base, introdu√ß√£o, CTA inscri√ß√£o, CTA coment√°rio) e captura a estrutura e elementos virais do roteiro original. O prompt deve instruir o agente a criar roteiros de ~30.000 caracteres em bloco √∫nico, sem formata√ß√£o especial, sem travess√µes/hifens, mantendo a ess√™ncia do YouTube com CTAs de like e inscri√ß√£o.",
  "agent_instructions": "Instru√ß√µes completas que explicam: 1) Como usar a introdu√ß√£o criada no PASSO 2, 2) Como usar o CTA de inscri√ß√£o do PASSO 3, 3) Como usar o CTA de coment√°rio do PASSO 4, 4) A estrutura exata do roteiro (timing, se√ß√µes, progress√£o), 5) Os elementos virais que DEVEM ser mantidos em cada replica√ß√£o, 6) Como adaptar o conte√∫do para novos t√≠tulos mantendo a ess√™ncia, 7) Padr√µes e f√≥rmulas identificadas que geram engajamento.",
  "introduction": "Introdu√ß√£o criada no PASSO 2 que ser√° usada pelo agente",
  "subscriptionCTA": "CTA de inscri√ß√£o criado no PASSO 3 que ser√° usado pelo agente",
  "commentCTA": "CTA de coment√°rio criado no PASSO 4 que ser√° usado pelo agente"
}`;

        let response;
        let responseText = '';
        
        if (aiProvider.service === 'laozhang') {
            response = await callLaozhangAPI(
                agentPrompt, 
                aiProvider.apiKey, 
                aiProvider.model, 
                null, 
                userId, 
                'api_call', 
                JSON.stringify({ endpoint: '/api/script-agents/create', model: aiProvider.model })
            );
            // callLaozhangAPI retorna string diretamente
            responseText = typeof response === 'string' ? response : JSON.stringify(response);
        } else if (aiProvider.service === 'claude') {
            response = await callClaudeAPI(agentPrompt, aiProvider.apiKey, aiProvider.model);
        } else if (aiProvider.service === 'openai') {
            response = await callOpenAIAPI(agentPrompt, aiProvider.apiKey, aiProvider.model);
        } else {
            response = await callGeminiAPI(agentPrompt, aiProvider.apiKey, aiProvider.model);
        }
        
        // Extrair o texto da resposta (se ainda n√£o foi extra√≠do para laozhang)
        if (aiProvider.service !== 'laozhang') {
            if (response && response.titles) {
                responseText = response.titles;
            } else if (typeof response === 'string') {
                responseText = response;
            } else {
                console.error(`[Agente] Formato de resposta inesperado:`, typeof response);
                throw new Error('Formato de resposta inesperado da API');
            }
        }
        
        console.log(`[Agente] Resposta recebida (primeiros 500 caracteres):`, responseText.substring(0, 500));
        
        let agentPromptText = '';
        let agentInstructions = '';

        try {
            // Como o Gemini est√° configurado com responseMimeType: "application/json",
            // a resposta deve ser JSON v√°lido diretamente
            let parsed;
            
            // Tentar parsear diretamente como JSON
            try {
                parsed = JSON.parse(responseText);
            } catch (directParseError) {
                // Se falhar, tentar extrair JSON da resposta (pode ter markdown ou texto extra)
                let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    // Tentar encontrar JSON entre markdown code blocks
                    jsonMatch = responseText.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
                    if (jsonMatch && jsonMatch[1]) {
                        parsed = JSON.parse(jsonMatch[1]);
                    } else {
                        throw new Error('Nenhum JSON encontrado na resposta');
                    }
                } else {
                    // Limpar e parsear JSON extra√≠do
                    const cleanedJson = jsonMatch[0]
                        .replace(/```json|```/g, '')
                        .trim();
                    parsed = JSON.parse(cleanedJson);
                }
            }
            
            // Verificar se o JSON tem os campos esperados
            if (parsed && parsed.agent_prompt && parsed.agent_instructions) {
                agentPromptText = parsed.agent_prompt;
                agentInstructions = parsed.agent_instructions;
                
                // Adicionar introdu√ß√£o, CTA de inscri√ß√£o e CTA de coment√°rio √†s instru√ß√µes se dispon√≠veis
                if (parsed.introduction || parsed.subscriptionCTA || parsed.commentCTA) {
                    agentInstructions += '\n\n=== ELEMENTOS ESPEC√çFICOS DO AGENTE ===\n';
                    if (parsed.introduction) {
                        agentInstructions += `\nINTRODU√á√ÉO (usar no in√≠cio de cada roteiro):\n${parsed.introduction}\n`;
                    }
                    if (parsed.subscriptionCTA) {
                        agentInstructions += `\nCTA DE INSCRI√á√ÉO (usar no final do roteiro):\n${parsed.subscriptionCTA}\n`;
                    }
                    if (parsed.commentCTA) {
                        agentInstructions += `\nCTA DE COMENT√ÅRIO (usar por volta de 1/3 do v√≠deo):\n${parsed.commentCTA}\n`;
                    }
                }
                
                console.log(`[Agente] ‚úÖ Agente criado com sucesso a partir da resposta da IA`);
            } else {
                console.warn(`[Agente] JSON parseado mas campos ausentes. Campos encontrados:`, Object.keys(parsed || {}));
                throw new Error('JSON n√£o cont√©m agent_prompt e agent_instructions');
            }
        } catch (parseError) {
            console.warn(`[Agente] Erro ao parsear resposta do Gemini:`, parseError.message);
            console.log(`[Agente] Resposta completa recebida:`, responseText);
            
            // Fallback: criar um prompt b√°sico baseado no v√≠deo
            agentPromptText = `Voc√™ √© um roteirista especializado em criar document√°rios virais para YouTube. Analise o seguinte padr√£o comprovado e crie um novo roteiro de document√°rio cativante e informativo.

**Padr√£o de Sucesso (baseado no v√≠deo "${videoTitle}"):**
- Estrutura narrativa envolvente com ganchos poderosos
- Ritmo din√¢mico que mant√©m o espectador engajado
- Informa√ß√µes precisas apresentadas de forma acess√≠vel
- Elementos visuais e sonoros que complementam a narrativa

**Nicho:** ${niche || 'N/A'}
**Sub-nicho:** ${subniche || 'N/A'}

Crie roteiros seguindo esta estrutura e estilo, adaptando o conte√∫do para novos t√≥picos dentro do mesmo nicho.`;

            agentInstructions = `Este agente foi criado a partir do v√≠deo "${videoTitle || 'N/A'}".

**Como usar:**
1. Forne√ßa um novo t√≥pico dentro do nicho "${niche || 'geral'}"
2. O agente gerar√° um roteiro seguindo a mesma estrutura e estilo do v√≠deo original
3. Mantenha os elementos que tornaram o v√≠deo original um sucesso: ganchos poderosos, ritmo envolvente, estrutura narrativa clara

**Elementos virais identificados:**
- Abertura enigm√°tica que captura aten√ß√£o imediata
- Desenvolvimento progressivo da narrativa
- Informa√ß√µes apresentadas de forma envolvente
- Conclus√£o que deixa o espectador querendo mais`;
            
            console.log(`[Agente] Usando fallback: prompt b√°sico criado`);
        }

        const viralFormulaJson = viralFormulaData ? JSON.stringify(viralFormulaData) : null;

        // Salvar o agente no banco de dados
        const result = await db.run(
            `INSERT INTO script_agents (user_id, agent_name, niche, subniche, source_video_id, source_video_url, source_video_title, full_transcript, agent_prompt, agent_instructions, viral_formula_json)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, agentName, niche || null, subniche || null, videoId, videoUrl || null, videoTitle || null, fullTranscript, agentPromptText, agentInstructions, viralFormulaJson]
        );

        // Salvar automaticamente em agentes virais
        try {
            // Preparar instru√ß√µes completas incluindo a f√≥rmula viral se dispon√≠vel
            let fullInstructions = agentInstructions || agentPromptText || '';
            if (viralFormulaJson) {
                try {
                    const formulaData = JSON.parse(viralFormulaJson);
                    fullInstructions += '\n\n=== F√ìRMULA VIRAL IDENTIFICADA ===\n';
                    fullInstructions += JSON.stringify(formulaData, null, 2);
                } catch (e) {
                    fullInstructions += '\n\n=== F√ìRMULA VIRAL ===\n' + viralFormulaJson;
                }
            }
            
            // Adicionar informa√ß√µes do v√≠deo fonte na descri√ß√£o
            const description = `Agente gerado automaticamente a partir do v√≠deo "${videoTitle || 'N/A'}". ${niche ? `Nicho: ${niche}` : ''} ${subniche ? `| Subnicho: ${subniche}` : ''}`;
            
            // Verificar se as colunas existem antes de inserir
            // Adicionar colunas se n√£o existirem (migra√ß√£o suave)
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN niche TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna niche:', e.message);
            }
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN subniche TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna subniche:', e.message);
            }
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN formula_json TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna formula_json:', e.message);
            }
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN source_video_id TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna source_video_id:', e.message);
            }
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN source_video_url TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna source_video_url:', e.message);
            }
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN source_video_title TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna source_video_title:', e.message);
            }
            try {
                await db.run(`ALTER TABLE viral_agents ADD COLUMN agent_prompt TEXT`);
            } catch (e) {
                if (!/duplicate column name/i.test(e.message)) console.warn('[DB] Erro ao adicionar coluna agent_prompt:', e.message);
            }
            
            await db.run(`
                INSERT INTO viral_agents (
                    user_id, name, description, instructions, model, 
                    niche, subniche, formula_json, source_video_id, 
                    source_video_url, source_video_title, agent_prompt,
                    created_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            `, [
                userId,
                agentName,
                description,
                fullInstructions,
                'gpt-4o', // Modelo padr√£o
                niche || null,
                subniche || null,
                viralFormulaJson || null,
                videoId || null,
                videoUrl || null,
                videoTitle || null,
                agentPromptText || null
            ]);
            
            console.log('[Agente] ‚úÖ Agente salvo automaticamente em agentes virais com todos os campos');
        } catch (viralAgentErr) {
            console.warn('[Agente] ‚ö†Ô∏è Erro ao salvar em agentes virais:', viralAgentErr.message);
            // N√£o falhar a cria√ß√£o do agente se n√£o conseguir salvar em viral_agents
        }

        res.status(200).json({
            msg: 'Agente de roteiro criado com sucesso!',
            agentId: result.lastID,
            agent: {
                id: result.lastID,
                name: agentName,
                niche: niche || null,
                subniche: subniche || null,
                hasViralFormula: !!viralFormulaJson
            }
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/create]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao criar agente de roteiro.' });
    }
});

// === ROTA LAOZHANG PARA CRIA√á√ÉO DE AGENTES ===
app.post('/api/script-agents/create/laozhang', authenticateToken, async (req, res) => {
    const { videoId, videoUrl, videoTitle, agentName, niche, subniche, manualTranscript, viralInsights } = req.body;
    const userId = req.user.id;

    if (!videoId || !agentName) {
        return res.status(400).json({ msg: 'ID do v√≠deo e nome do agente s√£o obrigat√≥rios.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo n√£o configurada no painel admin.' });
        }

        // Buscar transcri√ß√£o (mesma l√≥gica da rota original)
        let fullTranscript = null;
        if (manualTranscript && manualTranscript.trim().length > 0) {
            fullTranscript = manualTranscript.trim();
        } else {
            const analysis = await db.get(
                'SELECT full_transcript FROM analyzed_videos WHERE youtube_video_id = ? AND user_id = ? ORDER BY analyzed_at DESC LIMIT 1',
                [videoId, userId]
            );
            if (analysis && analysis.full_transcript) {
                fullTranscript = analysis.full_transcript;
            }
        }

        // Criar prompt (mesma l√≥gica da rota original, simplificado)
        let agentPrompt = fullTranscript && fullTranscript.trim().length >= 100
            ? `Voc√™ √© um ESPECIALISTA EM AN√ÅLISE DE ROTEIROS VIRAIS para YouTube. Analise o roteiro abaixo e crie um agente de roteiro.

ROTEIRO: ${fullTranscript.substring(0, 20000)}
T√çTULO: ${videoTitle || 'N/A'}
NICHE: ${niche || 'N/A'}
SUBNICHE: ${subniche || 'N/A'}

Retorne JSON:
{
  "agent_prompt": "Prompt base...",
  "agent_instructions": "Instru√ß√µes detalhadas..."
}`
            : `Crie um agente de roteiro baseado em:
T√çTULO: ${videoTitle || 'N/A'}
NICHE: ${niche || 'N/A'}
SUBNICHE: ${subniche || 'N/A'}

Retorne JSON:
{
  "agent_prompt": "Prompt base...",
  "agent_instructions": "Instru√ß√µes detalhadas..."
}`;

        const response = await callLaozhangAPI(
            agentPrompt,
            laozhangApiKey,
            'claude-3-7-sonnet-20250219',
            null,
            userId,
            'api_script_agents_create',
            JSON.stringify({ endpoint: '/api/script-agents/create/laozhang', model: 'claude-3-7-sonnet-20250219' })
        );

        // Parsear resposta
        let agentPromptText, agentInstructions;
        let rawResponse = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        // Limpar caracteres de controle inv√°lidos do JSON
        // Remover quebras de linha e tabs n√£o escapados dentro de strings JSON
        rawResponse = rawResponse
            .replace(/\n/g, '\\n')  // Escapar quebras de linha
            .replace(/\r/g, '\\r')  // Escapar carriage return
            .replace(/\t/g, '\\t')  // Escapar tabs
            .replace(/\f/g, '\\f')  // Escapar form feed
            .replace(/\b/g, '\\b')  // Escapar backspace
            // Mas manter quebras de linha v√°lidas fora de strings (formata√ß√£o JSON)
            .replace(/\\n(?=\s*[,\}\]])/g, '\n')  // Restaurar quebras de linha v√°lidas ap√≥s v√≠rgulas/fechamentos
            .replace(/\\n(?=\s*")/g, '\n');      // Restaurar quebras de linha v√°lidas antes de strings
        
        // Tentar extrair JSON de markdown code blocks primeiro
        const codeBlockMatch = rawResponse.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
        if (codeBlockMatch && codeBlockMatch[1]) {
            rawResponse = codeBlockMatch[1];
        }
        
        try {
            // Tentar parse direto
            const parsed = JSON.parse(rawResponse);
            agentPromptText = parsed.agent_prompt || parsed.agentPrompt;
            agentInstructions = parsed.agent_instructions || parsed.agentInstructions;
        } catch (e) {
            console.warn('[Agente Laozhang] Erro ao parsear JSON diretamente, tentando extrair:', e.message);
            
            // Tentar extrair JSON usando regex mais robusto
            const jsonMatch = rawResponse.match(/\{[\s\S]*"agent_prompt"[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    // Limpar caracteres de controle problem√°ticos antes de parsear
                    let cleanedJson = jsonMatch[0]
                        .replace(/[\x00-\x1F\x7F]/g, '') // Remover caracteres de controle
                        .replace(/([^\\])\n/g, '$1\\n')  // Escapar quebras de linha n√£o escapadas
                        .replace(/([^\\])\r/g, '$1\\r')  // Escapar carriage return n√£o escapados
                        .replace(/([^\\])\t/g, '$1\\t'); // Escapar tabs n√£o escapados
                    
                    const parsed = JSON.parse(cleanedJson);
                    agentPromptText = parsed.agent_prompt || parsed.agentPrompt;
                    agentInstructions = parsed.agent_instructions || parsed.agentInstructions;
                } catch (e2) {
                    console.error('[Agente Laozhang] Erro ao parsear JSON extra√≠do:', e2.message);
                    // Fallback: tentar extrair valores diretamente com regex
                    const promptMatch = rawResponse.match(/"agent_prompt"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
                    const instructionsMatch = rawResponse.match(/"agent_instructions"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
                    
                    if (promptMatch && promptMatch[1]) {
                        agentPromptText = promptMatch[1].replace(/\\n/g, '\n').replace(/\\"/g, '"');
                    }
                    if (instructionsMatch && instructionsMatch[1]) {
                        agentInstructions = instructionsMatch[1].replace(/\\n/g, '\n').replace(/\\"/g, '"');
                    }
                    
                    // Se ainda n√£o conseguiu, usar fallback
                    if (!agentPromptText) {
                        agentPromptText = `Crie roteiros virais para YouTube no nicho ${niche || 'geral'}.`;
                    }
                    if (!agentInstructions) {
                        agentInstructions = `Agente criado a partir do v√≠deo "${videoTitle || 'N/A'}".`;
                    }
                }
            } else {
                console.warn('[Agente Laozhang] Nenhum JSON encontrado na resposta, usando fallback');
                // Fallback
                agentPromptText = `Crie roteiros virais para YouTube no nicho ${niche || 'geral'}.`;
                agentInstructions = `Agente criado a partir do v√≠deo "${videoTitle || 'N/A'}".`;
            }
        }
        
        // Garantir que temos valores v√°lidos
        if (!agentPromptText || agentPromptText.trim().length === 0) {
            agentPromptText = `Crie roteiros virais para YouTube no nicho ${niche || 'geral'}.`;
        }
        if (!agentInstructions || agentInstructions.trim().length === 0) {
            agentInstructions = `Agente criado a partir do v√≠deo "${videoTitle || 'N/A'}".`;
        }

        // Salvar agente
        const result = await db.run(
            `INSERT INTO script_agents (user_id, agent_name, niche, subniche, source_video_id, source_video_url, source_video_title, full_transcript, agent_prompt, agent_instructions)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, agentName, niche || null, subniche || null, videoId, videoUrl || null, videoTitle || null, fullTranscript, agentPromptText, agentInstructions]
        );

        res.status(201).json({
            msg: 'Agente de roteiro criado com sucesso!',
            agentId: result.lastID
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/create/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao criar agente de roteiro.' });
    }
});

// Rota para listar todos os agentes de roteiro do usu√°rio
app.get('/api/script-agents', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const agents = await db.all(
            `SELECT id, agent_name, niche, subniche, source_video_title, usage_count, created_at, updated_at
             FROM script_agents
             WHERE user_id = ?
             ORDER BY updated_at DESC`,
            [userId]
        );

        res.status(200).json({ agents });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents]:', err);
        res.status(500).json({ msg: 'Erro ao listar agentes de roteiro.' });
    }
});

// Rota para obter detalhes de um agente espec√≠fico
app.get('/api/script-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        const agent = await db.get(
            `SELECT * FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }

        res.status(200).json({ agent });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId]:', err);
        res.status(500).json({ msg: 'Erro ao buscar agente.' });
    }
});

// Fun√ß√£o helper para enviar progresso via SSE
function sendProgress(sessionId, data) {
    const client = sseClients.get(sessionId);
    if (client) {
        client.write(`data: ${JSON.stringify(data)}\n\n`);
    }
}

// Rota SSE para progresso em tempo real (aceita token via header ou query string)
app.get('/api/script-agents/progress/:sessionId', (req, res) => {
    const { sessionId } = req.params;
    
    // Permite token via Authorization header ou query ?token=
    const authHeader = req.headers['authorization'];
    let token = authHeader && authHeader.split(' ')[1];
    if (!token && req.query && req.query.token) {
        token = req.query.token;
    }
    
    if (!token) {
        return res.status(401).json({ msg: 'Token n√£o fornecido.' });
    }
    
    jwt.verify(token, JWT_SECRET, (err) => {
        if (err) {
            return res.status(403).json({ msg: 'Token inv√°lido ou expirado.' });
        }
        
        res.setHeader('Content-Type', 'text/event-stream');
        res.setHeader('Cache-Control', 'no-cache');
        res.setHeader('Connection', 'keep-alive');
        res.flushHeaders();
        
        sseClients.set(sessionId, res);
        console.log(`[SSE] Cliente conectado: ${sessionId}`);
        
        req.on('close', () => {
            sseClients.delete(sessionId);
            console.log(`[SSE] Cliente desconectado: ${sessionId}`);
        });
    });
});

// Rota para gerar roteiro usando um agente
app.post('/api/script-agents/:agentId/generate', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { title, topic, duration, language, cta, model, additionalInstructions, sessionId, parts } = req.body;
    const userId = req.user.id;

    if (!title) {
        return res.status(400).json({ msg: 'T√≠tulo do v√≠deo √© obrigat√≥rio.' });
    }

        // Se n√£o fornecer dura√ß√£o, usar 5 minutos como padr√£o
        let scriptDuration = duration ? parseInt(duration) : 5;
        
        // Se n√£o fornecer idioma, usar portugu√™s como padr√£o
        const scriptLanguage = language || 'pt';
        
        // Configurar CTAs (Call to Action)
        const ctaConfig = {
            inicio: cta?.inicio || false,
            meio: cta?.meio || false,
            final: cta?.final !== undefined ? cta.final : true // Padr√£o: CTA no final
        };
        
        // Se n√£o fornecer modelo, usar Claude como padr√£o (recomendado para roteiros)
        const selectedModel = model || 'claude-3-7-sonnet-20250219';
        
        // A dura√ß√£o j√° vem ajustada do frontend (com 3-5 minutos extras)
        // N√£o adicionar mais minutos aqui para evitar duplica√ß√£o
        // Mas aumentar wordsPerMinute para garantir margem de seguran√ßa
        const originalDuration = scriptDuration;
        console.log(`[Script Generate] Dura√ß√£o recebida do frontend: ${scriptDuration} minutos (j√° ajustada)`);

    try {
        console.log(`[Script Generate] Requisi√ß√£o recebida - agentId: ${agentId}, userId: ${userId}, title: ${title}`);
        
        if (!agentId) {
            console.error(`[Script Generate] agentId n√£o fornecido na URL`);
            return res.status(400).json({ msg: 'ID do agente √© obrigat√≥rio.' });
        }

        // Buscar o agente
        console.log(`[Script Generate] Buscando agente com id=${agentId} e user_id=${userId}`);
        
        // Primeiro, verificar se o agente existe (sem filtro de user_id)
        const agentExists = await db.get(
            `SELECT id, user_id, agent_name FROM script_agents WHERE id = ?`,
            [agentId]
        );
        
        if (!agentExists) {
            console.error(`[Script Generate] Agente ${agentId} n√£o existe no banco de dados`);
            // Listar todos os agentes do usu√°rio para debug
            const userAgents = await db.all(
                `SELECT id, agent_name FROM script_agents WHERE user_id = ?`,
                [userId]
            );
            console.log(`[Script Generate] Agentes dispon√≠veis para user_id=${userId}:`, userAgents);
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }
        
        if (agentExists.user_id !== userId) {
            console.error(`[Script Generate] Agente ${agentId} existe mas pertence ao user_id=${agentExists.user_id}, n√£o ao user_id=${userId}`);
            return res.status(403).json({ msg: 'Voc√™ n√£o tem permiss√£o para usar este agente.' });
        }
        
        // Buscar o agente completo
        const agent = await db.get(
            `SELECT * FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );
        
        if (!agent) {
            console.error(`[Script Generate] Erro inesperado: agente existe mas n√£o foi encontrado com filtro user_id`);
            return res.status(500).json({ msg: 'Erro ao buscar agente.' });
        }

        console.log(`[Script Generate] Agente encontrado: ${agent.agent_name || 'Sem nome'}`);

        // Identificar servi√ßo e buscar chave
        let service;
        if (selectedModel.startsWith('gemini')) service = 'gemini';
        else if (selectedModel.startsWith('claude')) service = 'claude';
        else if (selectedModel.startsWith('gpt')) service = 'openai';
        else service = 'gemini';

        const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
        if (!keyData) {
            return res.status(400).json({ msg: `Chave de API do ${service} n√£o configurada.` });
        }
        const decryptedKey = decrypt(keyData.api_key);
        if (!decryptedKey) {
            return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
        }

        // Dividir em blocos de 3 minutos para respeitar o front-end
        const BASE_PART_DURATION = 3;
        const idealParts = Math.max(1, Math.ceil(scriptDuration / BASE_PART_DURATION));
        let requestedParts = parseInt(parts, 10);
        if (Number.isNaN(requestedParts) || requestedParts <= 0) {
            requestedParts = null;
        }
        // SEMPRE respeitar o n√∫mero de partes solicitado pelo frontend
        let numberOfParts = requestedParts || idealParts;
        if (requestedParts) {
            console.log(`[Roteiro] Usando n√∫mero de partes solicitado pelo frontend: ${requestedParts} (ideal seria ${idealParts})`);
            numberOfParts = requestedParts; // SEMPRE usar o valor do frontend
        } else {
            console.log(`[Roteiro] Nenhuma parte especificada, usando c√°lculo ideal: ${idealParts}`);
            numberOfParts = idealParts;
        }
        
        const partDurations = [];
        for (let idx = 0; idx < numberOfParts; idx++) {
            if (idx === numberOfParts - 1) {
                const consumed = BASE_PART_DURATION * (numberOfParts - 1);
                const remaining = scriptDuration - consumed;
                partDurations.push(remaining > 0 ? remaining : BASE_PART_DURATION);
            } else {
                partDurations.push(Math.min(BASE_PART_DURATION, scriptDuration));
            }
        }
        
        console.log(`[Roteiro] Dura√ß√£o: ${scriptDuration} minutos. Dividindo em ${numberOfParts} parte(s) (~3 minutos cada). √öltima parte: ${partDurations[numberOfParts - 1]} minuto(s).`);

        let scriptContent = '';

        // Se for dividido em partes, gerar cada parte separadamente
        if (numberOfParts > 1) {
            console.log(`[Roteiro] Gerando roteiro em ${numberOfParts} partes...`);
            const scriptParts = [];
            
            // Enviar progresso inicial
            if (sessionId) {
                sendProgress(sessionId, {
                    stage: 'generating',
                    progress: 0,
                    currentPart: 0,
                    totalParts: numberOfParts,
                    message: `Iniciando gera√ß√£o de ${numberOfParts} partes...`
                });
            }
            
            for (let partIndex = 0; partIndex < numberOfParts; partIndex++) {
                const isLastPart = partIndex === numberOfParts - 1;
                const currentPartDuration = partDurations[partIndex] || BASE_PART_DURATION;
                const currentPartWords = currentPartDuration * wordsPerMinute;
                const partNumber = partIndex + 1;
                
                console.log(`[Roteiro] Gerando parte ${partNumber}/${numberOfParts} (${currentPartDuration} minutos, ~${currentPartWords} palavras)...`);
                
                const partPrompt = `${agent.agent_prompt || 'Crie um roteiro viral para YouTube seguindo a estrutura e f√≥rmula identificada no roteiro viral original.'}

INSTRU√á√ïES DETALHADAS DO AGENTE (F√ìRMULA VIRAL):
${agent.agent_instructions || ''}

${additionalInstructions ? `\nINSTRU√á√ïES ADICIONAIS DO USU√ÅRIO:\n${additionalInstructions}\n` : ''}

T√çTULO DO V√çDEO PARA O QUAL DEVO CRIAR O ROTEIRO:
"${title}"

IMPORTANTE: Este √© apenas a PARTE ${partNumber} de ${numberOfParts} do roteiro completo.

DURA√á√ÉO DESTA PARTE: ${currentPartDuration} minutos (${currentPartDuration * 60} segundos)

IDIOMA DO ROTEIRO: ${scriptLanguage === 'pt' ? 'Portugu√™s (Brasil)' : scriptLanguage === 'pt-PT' ? 'Portugu√™s (Portugal)' : scriptLanguage === 'es' ? 'Espa√±ol' : scriptLanguage === 'en' ? 'English' : scriptLanguage === 'fr' ? 'Fran√ßais' : scriptLanguage === 'de' ? 'Deutsch' : scriptLanguage === 'it' ? 'Italiano' : scriptLanguage === 'ru' ? '–†—É—Å—Å–∫–∏–π' : scriptLanguage === 'ja' ? 'Êó•Êú¨Ë™û' : scriptLanguage === 'zh' ? '‰∏≠Êñá' : scriptLanguage}

${(ctaConfig.inicio && partIndex === 0) || (ctaConfig.meio && partIndex === Math.floor(numberOfParts / 2)) || (ctaConfig.final && isLastPart) ? `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CALL TO ACTION (CTA) - OBRIGAT√ìRIO E NATURAL ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
${ctaConfig.inicio && partIndex === 0 ? `‚úÖ CTA no IN√çCIO (primeiros 30 segundos): 
   - Voc√™ DEVE incluir uma chamada para a√ß√£o NATURAL e ORG√ÇNICA nos primeiros 30 segundos desta parte
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar for√ßado
   - Exemplos naturais: "Se voc√™ est√° gostando deste conte√∫do, j√° deixa seu like e se inscreva no canal para n√£o perder os pr√≥ximos v√≠deos", "Antes de continuar, se inscreva no canal e ative o sininho para receber notifica√ß√µes", "Se este conte√∫do est√° te ajudando, j√° deixa seu like e comenta o que achou"
   - O CTA deve fazer parte do fluxo narrativo natural, n√£o deve parecer uma interrup√ß√£o
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, n√£o uma marca√ß√£o separada\n` : ''}
${ctaConfig.meio && partIndex === Math.floor(numberOfParts / 2) ? `‚úÖ CTA no MEIO (aproximadamente na metade do v√≠deo):
   - Voc√™ DEVE incluir uma chamada para a√ß√£o NATURAL e ORG√ÇNICA no meio desta parte
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar for√ßado
   - Exemplos naturais: "Se voc√™ est√° aprendendo algo novo aqui, j√° deixa seu like e compartilha com quem precisa ver isso", "Antes de continuarmos, se inscreva no canal para n√£o perder o restante deste conte√∫do", "Se este v√≠deo est√° te ajudando, j√° deixa seu like e comenta suas d√∫vidas"
   - O CTA deve fazer parte do fluxo narrativo natural, n√£o deve parecer uma interrup√ß√£o
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, n√£o uma marca√ß√£o separada\n` : ''}
${ctaConfig.final && isLastPart ? `‚úÖ CTA no FINAL (√∫ltimos 30 segundos):
   - Voc√™ DEVE incluir uma chamada para a√ß√£o FORTE, NATURAL e ORG√ÇNICA nos √∫ltimos 30 segundos desta parte
   - Este √© o CTA mais importante - deve ser impactante mas ainda assim natural
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar for√ßado
   - Exemplos naturais: "Se este conte√∫do te ajudou, j√° deixa seu like, se inscreva no canal, ative o sininho, compartilhe com seus amigos e comente o que achou", "N√£o esque√ßa de deixar seu like, se inscrever no canal e compartilhar este v√≠deo com quem precisa ver isso", "Se voc√™ gostou deste conte√∫do, j√° deixa seu like, se inscreva no canal, ative o sininho para receber notifica√ß√µes e compartilhe com seus amigos"
   - O CTA deve fazer parte do fluxo narrativo natural, n√£o deve parecer uma interrup√ß√£o
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, n√£o uma marca√ß√£o separada
   - CR√çTICO: Este CTA final √© essencial para o engajamento do v√≠deo\n` : ''}
‚ö†Ô∏è REGRAS IMPORTANTES SOBRE CTAs:
- Os CTAs devem ser inclu√≠dos de forma NATURAL e ORG√ÇNICA no texto narrativo
- N√ÉO use marca√ß√µes como "[CTA]", "(CTA)", ou qualquer indica√ß√£o expl√≠cita de CTA
- N√ÉO interrompa o fluxo narrativo abruptamente para incluir o CTA
- O CTA deve fazer parte da narrativa, como se fosse uma conversa natural com o espectador
- Use linguagem conversacional e envolvente
- Seja persuasivo mas genu√≠no, n√£o for√ßado
- O CTA deve parecer que faz parte naturalmente do roteiro, n√£o algo adicionado depois
` : ''}

${topic ? `T√ìPICO ESPEC√çFICO (se fornecido): ${topic}\n` : ''}
NICHE: ${agent.niche || 'N/A'}
SUBNICHE: ${agent.subniche || 'N/A'}

TAREFA:
Crie a PARTE ${partNumber} de ${numberOfParts} do roteiro COMPLETO e DETALHADO para o t√≠tulo acima, seguindo EXATAMENTE a mesma estrutura, ritmo, tom e elementos virais identificados no roteiro original.

O roteiro desta parte deve:
- Ter EXATAMENTE ${currentPartDuration} minutos de dura√ß√£o (${currentPartDuration * 60} segundos)
${!isLastPart ? `- ‚ö†Ô∏è CR√çTICO - ESTRUTURA OBRIGAT√ìRIA: Esta parte DEVE ter EXATAMENTE 5 PAR√ÅGRAFOS
- Cada parte DEVE ter ENTRE 390 e 450 PALAVRAS (total da parte)
- Cada par√°grafo DEVE ter ENTRE 75 e 90 PALAVRAS
- Distribui√ß√£o ideal: 5 par√°grafos √ó 78-90 palavras cada = 390-450 palavras totais
- Cada par√°grafo deve ser separado por uma quebra de linha dupla (espa√ßo em branco entre par√°grafos)
- Os 5 par√°grafos devem estar bem distribu√≠dos ao longo dos ${currentPartDuration} minutos desta parte
- Estrutura obrigat√≥ria: 5 par√°grafos distintos e bem definidos, cada um com 75-90 palavras` : `- Esta √© a √öLTIMA parte do roteiro - pode ter um n√∫mero vari√°vel de par√°grafos conforme necess√°rio para concluir o conte√∫do`}
- Replicar a estrutura narrativa exata do roteiro viral original
- Manter os mesmos elementos virais (ganchos, ritmo, tom, t√©cnicas de engajamento)
- Adaptar o conte√∫do para o novo t√≠tulo fornecido
- CR√çTICO: N√ÉO inclua marca√ß√µes como "(M√∫sica...)", "(Visual:...)", "NARRADOR:", etc.
- O roteiro deve ser APENAS texto puro para voice over, sem dire√ß√µes de cena, m√∫sica ou visualiza√ß√µes
- Escreva como se estivesse narrando diretamente, sem prefixos ou marca√ß√µes t√©cnicas
- Manter a f√≥rmula de sucesso que tornou o roteiro original viral
- Distribuir o conte√∫do proporcionalmente para preencher os ${currentPartDuration} minutos desta parte

FORMATO DE RESPOSTA OBRIGAT√ìRIO:
- Responda APENAS com o roteiro em TEXTO SIMPLES (n√£o use JSON, n√£o use estruturas de dados)
- N√ÉO use formato JSON, n√£o use objetos, n√£o use arrays, n√£o use chaves {}
${!isLastPart ? `- ‚ö†Ô∏è CR√çTICO: Esta parte DEVE ter EXATAMENTE 5 PAR√ÅGRAFOS
- Cada parte DEVE ter ENTRE 390 e 450 PALAVRAS (total da parte)
- Cada par√°grafo DEVE ter ENTRE 75 e 90 PALAVRAS
- Distribui√ß√£o ideal: 5 par√°grafos √ó 78-90 palavras cada = 390-450 palavras totais
- Cada par√°grafo deve ser separado por uma quebra de linha dupla (espa√ßo em branco entre par√°grafos)
- Estrutura obrigat√≥ria: 5 par√°grafos distintos e bem definidos, cada um com 75-90 palavras
- Os 5 par√°grafos devem estar bem distribu√≠dos ao longo dos ${currentPartDuration} minutos desta parte` : `- Esta √© a √öLTIMA parte - pode ter um n√∫mero vari√°vel de par√°grafos conforme necess√°rio para concluir`}
- O roteiro deve ser texto corrido, dividido em par√°grafos ou se√ß√µes claras
- Cada se√ß√£o pode ter indica√ß√£o de tempo entre par√™nteses ou colchetes, mas o conte√∫do deve ser texto narrativo direto
- Exemplo de formato correto:
  "[0:00-0:30] Texto do roteiro aqui... 
  
  [0:30-1:30] Continua√ß√£o do roteiro...
  
  [1:30-3:00] Mais conte√∫do..."
  
- N√ÉO use formato como: {"section": "...", "time": "...", "content": "..."}
- N√ÉO use listas numeradas ou com marcadores para estruturar o roteiro
- O roteiro deve ser texto narrativo fluido, como se fosse o texto que ser√° narrado no v√≠deo

REGRAS CR√çTICAS DE DURA√á√ÉO PARA ESTA PARTE - OBRIGAT√ìRIO:
- Esta PARTE ${partNumber} do roteiro DEVE ter EXATAMENTE ${currentPartDuration} minutos de dura√ß√£o
${!isLastPart ? `- ‚ö†Ô∏è CR√çTICO: Esta PARTE DEVE ter ENTRE 390 e 450 PALAVRAS (total)
- Esta PARTE DEVE ter EXATAMENTE 5 PAR√ÅGRAFOS
- Cada PAR√ÅGRAFO deve ter ENTRE 75 e 90 PALAVRAS
- Distribui√ß√£o: 5 par√°grafos √ó 78-90 palavras = 390-450 palavras totais
- META DE PALAVRAS DA PARTE: 390-450 palavras
- META DE PALAVRAS POR PAR√ÅGRAFO: 75-90 palavras` : `- Esta √© a √öLTIMA parte - pode ter n√∫mero vari√°vel de palavras e par√°grafos conforme necess√°rio`}
- ‚ö†Ô∏è CR√çTICO: Se voc√™ retornar menos de ${currentPartWords - 50} palavras ou mais de ${currentPartWords + 50} palavras, o roteiro ser√° REJEITADO
- ‚ö†Ô∏è CR√çTICO: N√ÉO retorne JSON vazio, N√ÉO retorne objetos, N√ÉO retorne apenas estrutura - ESCREVA O ROTEIRO COMPLETO COM ${currentPartWords} PALAVRAS
- Se esta parte tiver menos de ${currentPartWords} palavras, voc√™ DEVE expandir o conte√∫do at√© atingir EXATAMENTE ${currentPartWords} palavras
- Distribua o conte√∫do proporcionalmente para preencher TODOS os ${currentPartDuration} minutos desta parte
- IMPORTANTE: Conte as palavras antes de finalizar. Esta parte DEVE ter entre ${currentPartWords} e ${currentPartWords + 50} palavras
- CR√çTICO: Se voc√™ n√£o conseguir gerar ${currentPartWords} palavras, continue expandindo o conte√∫do at√© atingir essa quantidade

CONTEXTO DA PARTE:
${partIndex === 0 ? '- Esta √© a PRIMEIRA parte do roteiro. Comece com um gancho poderoso e envolvente.' : ''}
${!isLastPart ? `- Esta √© a parte ${partNumber} de ${numberOfParts}. Continue a narrativa de forma fluida, desenvolvendo o tema.` : ''}
${isLastPart ? `- Esta √© a √öLTIMA parte do roteiro (parte ${partNumber} de ${numberOfParts}). Conclua de forma impactante e envolvente.` : ''}
${partIndex > 0 ? `- A parte anterior terminou em um ponto espec√≠fico. Continue naturalmente a partir desse ponto.` : ''}

RESPOSTA FINAL - CR√çTICO:
- Responda APENAS com o roteiro em TEXTO SIMPLES e DIRETO
- N√ÉO use JSON, N√ÉO use objetos {}, N√ÉO use arrays [], N√ÉO use chaves ou colchetes para estruturar
- N√ÉO use formato: {"roteiro": "...", "duracao": "...", "estrutura": "..."}
- N√ÉO use formato: [{"section": "...", "time": "...", "content": "..."}]
- O roteiro deve ser texto corrido, como se voc√™ estivesse escrevendo o texto que ser√° narrado
- ‚ö†Ô∏è CR√çTICO - N√ÉO INCLUA MARCA√á√ïES DE PARTE OU TEMPO:
  - N√ÉO inclua marca√ß√µes como "PARTE 1", "Parte 1", "PARTE 1 0:00 - 3:00", "Parte 1 0:00 - 3:00"
  - N√ÉO inclua marca√ß√µes de tempo como "[0:00-3:00]", "(0:00)", "0:00 - 3:00", "0:00-3:00"
  - N√ÉO inclua qualquer indica√ß√£o de n√∫mero de parte ou intervalo de tempo no texto
  - O roteiro deve ser APENAS texto narrativo puro, sem marca√ß√µes t√©cnicas
  - Escreva como se estivesse narrando diretamente, sem prefixos, sem marca√ß√µes de parte ou tempo
  - CR√çTICO: Se voc√™ incluir marca√ß√µes de parte ou tempo, o roteiro ser√° rejeitado
- IMPORTANTE: O roteiro ser√° usado para VOICE OVER, ent√£o escreva de forma natural e fluida
- Use pontos finais e dois pontos para separar frases naturalmente
- Exemplo CORRETO de resposta:
  "[0:00-0:30] Em meio √†s selvas densas da Am√©rica Central, duas civiliza√ß√µes se enfrentaram...
  
  [0:30-1:30] Os Mayas, mestres do tempo e da escrita, constru√≠ram imp√©rios...
  
  [1:30-3:00] As ra√≠zes dos Mayas se estendem por s√©culos, florescendo nas terras baixas..."
  
- Exemplo ERRADO (N√ÉO FA√áA ISSO):
  {"roteiro": "texto", "duracao": "15 minutos"}
- O texto deve estar pronto para ser copiado e usado diretamente na narra√ß√£o do v√≠deo
- N√ÉO inclua NADA al√©m do roteiro em si - nem explica√ß√µes, nem metadados, nem JSON
- N√ÉO mencione que √© "parte X" no texto do roteiro - escreva como se fosse um roteiro cont√≠nuo
- CR√çTICO: N√ÉO inclua marca√ß√µes como "(M√∫sica...)", "(Visual:...)", "NARRADOR:", etc.
- O roteiro deve ser APENAS texto puro para voice over, sem dire√ß√µes de cena, m√∫sica ou visualiza√ß√µes
- Escreva como se estivesse narrando diretamente, sem prefixos ou marca√ß√µes t√©cnicas
- Meta de palavras para ESTA PARTE: ${currentPartWords} palavras para ${currentPartDuration} minutos`;

                // Sistema de retry: tentar gerar a parte at√© 3x em caso de erro
                let partGenerationSuccess = false;
                let partResponse;
                let retryCount = 0;
                const MAX_RETRIES = 3;
                
                while (!partGenerationSuccess && retryCount < MAX_RETRIES) {
                    try {
                        if (retryCount > 0) {
                            console.log(`[Roteiro] Tentativa ${retryCount + 1}/${MAX_RETRIES} para parte ${partNumber}...`);
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'generating',
                                    progress: Math.min(80, Math.round((partIndex / numberOfParts) * 80)),
                                    currentPart: partNumber,
                                    totalParts: numberOfParts,
                                    message: `Refazendo parte ${partNumber}/${numberOfParts} (tentativa ${retryCount + 1}/${MAX_RETRIES})...`,
                                    details: {
                                        partNumber,
                                        status: 'generating',
                                        percentage: 5,
                                        completedParts: partIndex
                                    }
                                });
                            }
                        } else {
                            console.log(`[Roteiro] Chamando API ${service} para parte ${partNumber}...`);
                            // Enviar progresso da parte atual
                            if (sessionId) {
                                const partProgressStart = Math.min(80, Math.round((partIndex / numberOfParts) * 80));
                                sendProgress(sessionId, {
                                    stage: 'generating',
                                    progress: partProgressStart,
                                    currentPart: partNumber,
                                    totalParts: numberOfParts,
                                    message: `Gerando parte ${partNumber}/${numberOfParts}...`,
                                    details: {
                                        partNumber,
                                        status: 'generating',
                                        percentage: 5,
                                        completedParts: partIndex
                                    }
                                });
                            }
                        }
                        
                        if (service === 'gemini') {
                            partResponse = await callGeminiAPI(partPrompt, decryptedKey, selectedModel);
                        } else if (service === 'claude') {
                            partResponse = await callClaudeAPI(partPrompt, decryptedKey, selectedModel);
                        } else {
                            partResponse = await callOpenAIAPI(partPrompt, decryptedKey, selectedModel);
                        }
                        console.log(`[Roteiro] API ${service} respondeu para parte ${partNumber}`);
                        partGenerationSuccess = true;
                    } catch (partError) {
                        retryCount++;
                        console.error(`[Roteiro] Erro ao gerar parte ${partNumber} (tentativa ${retryCount}/${MAX_RETRIES}):`, partError.message);
                        
                        if (retryCount < MAX_RETRIES) {
                            console.log(`[Roteiro] Aguardando 2 segundos antes de tentar novamente...`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        } else {
                            // Ap√≥s todas as tentativas, gerar mensagem de erro espec√≠fica
                            console.error(`[Roteiro] Falha definitiva na parte ${partNumber} ap√≥s ${MAX_RETRIES} tentativas`);
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'error',
                                    progress: Math.min(80, Math.round((partIndex / numberOfParts) * 80)),
                                    currentPart: partNumber,
                                    totalParts: numberOfParts,
                                    message: `‚ùå Erro na parte ${partNumber}/${numberOfParts} ap√≥s ${MAX_RETRIES} tentativas. Continuando...`,
                                    details: {
                                        partNumber,
                                        status: 'error',
                                        percentage: 0,
                                        completedParts: partIndex
                                    }
                                });
                            }
                            throw partError; // Re-throw para ser capturado pelo catch externo
                        }
                    }
                }
                
                // Se chegou aqui, a parte foi gerada com sucesso
                try {

                    // Limpar resposta da parte
                    let partContent = extractTextFromAIResponse(partResponse).trim();
                    partContent = partContent
                        .replace(/^```[\w]*\n?/gm, '')
                        .replace(/```$/gm, '')
                        .replace(/^\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                        .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                        .replace(/"content"\s*:\s*"([^"]+)"/gi, '$1')
                        .replace(/"script"\s*:\s*"([^"]+)"/gi, '$1')
                        .replace(/\{[\s\S]*\}/g, '')
                        .trim();
                    
                    // Remover marca√ß√µes de roteiro (m√∫sica, visual, narrador, etc.) - apenas texto para voice over
                    partContent = cleanScriptForVoiceOver(partContent);

                    const partWordCount = partContent.trim().split(/\s+/).filter(w => w.length > 0).length;
                    console.log(`[Roteiro] Parte ${partNumber}/${numberOfParts} gerada: ${partWordCount} palavras (meta: ${currentPartWords})`);

                    // Validar e expandir parte se necess√°rio
                    if (partWordCount < currentPartWords - 50) {
                        console.warn(`[Roteiro] Parte ${partNumber} muito curta: ${partWordCount} palavras. Expandindo...`);
                        if (sessionId) {
                            sendProgress(sessionId, {
                                stage: 'generating',
                                progress: Math.min(82, Math.round((partIndex / numberOfParts) * 80) + 5),
                                currentPart: partNumber,
                                totalParts: numberOfParts,
                                message: `Expandindo parte ${partNumber}/${numberOfParts} para atingir a minutagem...`,
                                details: {
                                    partNumber,
                                    status: 'expanding',
                                    percentage: Math.min(90, Math.round((partWordCount / currentPartWords) * 100)),
                                    completedParts: partIndex
                                }
                            });
                        }
                        const partExpansionPrompt = `O roteiro abaixo √© a parte ${partNumber} de ${numberOfParts} e tem apenas ${partWordCount} palavras, mas precisa ter EXATAMENTE ${currentPartWords} palavras.

ROTEIRO DA PARTE ${partNumber} (${partWordCount} palavras - MUITO CURTO):
${partContent}

INSTRU√á√ïES:
1. Expanda esta parte para ter EXATAMENTE ${currentPartWords} palavras
2. Mantenha o mesmo estilo e tom
3. Adicione mais detalhes, exemplos, explica√ß√µes
4. N√ÉO use JSON, objetos ou arrays - apenas texto corrido
5. Responda APENAS com o roteiro expandido`;

                        try {
                            let expansionResponse;
                            if (service === 'gemini') {
                                expansionResponse = await callGeminiAPI(partExpansionPrompt, decryptedKey, selectedModel);
                            } else if (service === 'claude') {
                                expansionResponse = await callClaudeAPI(partExpansionPrompt, decryptedKey, selectedModel);
                            } else {
                                expansionResponse = await callOpenAIAPI(partExpansionPrompt, decryptedKey, selectedModel);
                            }

                            let expandedPart = extractTextFromAIResponse(expansionResponse).trim();
                            expandedPart = cleanScriptForVoiceOver(expandedPart)
                                .replace(/^```[\w]*\n?/gm, '')
                                .replace(/```$/gm, '')
                                .replace(/^\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                                .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                                .replace(/\{[\s\S]*\}/g, '')
                                .trim();

                            const expandedWordCount = expandedPart.trim().split(/\s+/).filter(w => w.length > 0).length;
                            if (expandedWordCount >= currentPartWords - 50) {
                                partContent = expandedPart;
                                console.log(`[Roteiro] Parte ${partNumber} expandida: ${expandedWordCount} palavras`);
                            }
                        } catch (expansionErr) {
                            console.error(`[Roteiro] Erro ao expandir parte ${partNumber}:`, expansionErr.message);
                        }
                    }

                    scriptParts.push(partContent);
                    
                    if (sessionId) {
                        const completedParts = partNumber;
                        const completionProgress = Math.min(85, Math.round((completedParts / numberOfParts) * 80));
                        const finalPartWords = partContent.trim().split(/\s+/).filter(w => w.length > 0).length;
                        sendProgress(sessionId, {
                            stage: 'generating',
                            progress: completionProgress,
                            currentPart: partNumber,
                            totalParts: numberOfParts,
                            message: `Parte ${partNumber}/${numberOfParts} conclu√≠da (${finalPartWords} palavras).`,
                            details: {
                                partNumber,
                                status: 'completed',
                                percentage: 100,
                                completedParts,
                                words: finalPartWords
                            }
                        });
                    }
                } catch (partErr) {
                    console.error(`[Roteiro] ‚ùå Erro DEFINITIVO ao processar parte ${partNumber} ap√≥s ${MAX_RETRIES} tentativas:`, partErr.message);
                    
                    // Adicionar mensagem de erro ao array de partes (mantendo a posi√ß√£o)
                    scriptParts.push(`[ERRO NA PARTE ${partNumber}/${numberOfParts}]\n\n‚ùå N√£o foi poss√≠vel gerar esta parte do roteiro ap√≥s ${MAX_RETRIES} tentativas.\nMotivo: ${partErr.message}\n\nPor favor, gere novamente ou edite manualmente.\n\n[FIM DO ERRO - PARTE ${partNumber}]`);
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'error',
                            progress: Math.min(85, Math.round((partNumber / numberOfParts) * 80)),
                            currentPart: partNumber,
                            totalParts: numberOfParts,
                            message: `‚ùå Erro definitivo na parte ${partNumber}/${numberOfParts}. Continuando...`,
                            details: {
                                partNumber,
                                status: 'error',
                                percentage: 0,
                                completedParts: partNumber - 1
                            }
                        });
                    }
                    
                    // N√ÉO INTERROMPE O LOOP - continua gerando as pr√≥ximas partes
                    console.log(`[Roteiro] Continuando com a pr√≥xima parte...`);
                }
            }
            
            // Ap√≥s todas as partes serem geradas (com sucesso ou erro), continuar o processamento
            console.log(`[Roteiro] Todas as ${numberOfParts} partes foram processadas. Montando roteiro final...`);
            
            // Unir todas as partes em um roteiro completo
            const fullScript = scriptParts.join('\n\n---\n\n');
            const totalWords = fullScript.trim().split(/\s+/).filter(w => w.length > 0).length;
            
            console.log(`[Roteiro] Roteiro final montado: ${totalWords} palavras (${scriptParts.length} partes)`);
            
            // Verificar se h√° partes com erro
            const hasErrors = scriptParts.some(part => part.includes('[ERRO NA PARTE'));
            if (hasErrors) {
                console.warn(`[Roteiro] ‚ö†Ô∏è Roteiro cont√©m partes com erro. O usu√°rio dever√° revisar.`);
            }
            
            // Continuar com a otimiza√ß√£o e valida√ß√£o (mesmo com erros em algumas partes)
            if (sessionId) {
                sendProgress(sessionId, {
                    stage: hasErrors ? 'partial_success' : 'optimizing',
                    progress: 85,
                    message: hasErrors ? '‚ö†Ô∏è Roteiro gerado com algumas partes com erro. Otimizando...' : 'Otimizando roteiro...',
                    totalParts: numberOfParts,
                    details: {
                        completedParts: numberOfParts,
                        hasErrors: hasErrors
                    }
                });
            }
            
            // Usar o fullScript j√° montado com as partes (incluindo erros, se houver)
            scriptContent = fullScript;
        } else {
            // Se n√£o precisa dividir, gerar normalmente
            const scriptPrompt = `${agent.agent_prompt}

T√çTULO DO V√çDEO PARA O QUAL VOC√ä DEVE GERAR O ROTEIRO:
"${title}"

${topic ? `CONTEXTO ADICIONAL FORNECIDO PELO USU√ÅRIO:
"${topic}"

` : ''}INSTRU√á√ïES PARA GERA√á√ÉO DO ROTEIRO:

O roteiro deve:
- Ter EXATAMENTE ${scriptDuration} minutos de dura√ß√£o (${scriptDuration * 60} segundos)
- Replicar a estrutura narrativa exata do roteiro viral original
- Manter os mesmos elementos virais (ganchos, ritmo, tom, t√©cnicas de engajamento)
- Adaptar o conte√∫do para o novo t√≠tulo fornecido
- Incluir timing espec√≠fico de cada se√ß√£o para totalizar ${scriptDuration} minutos
- Manter a f√≥rmula de sucesso que tornou o roteiro original viral
- Distribuir o conte√∫do proporcionalmente para preencher os ${scriptDuration} minutos

FORMATO DE RESPOSTA OBRIGAT√ìRIO:
- Responda APENAS com o roteiro em TEXTO SIMPLES (n√£o use JSON, n√£o use estruturas de dados)
- N√ÉO use formato JSON, n√£o use objetos, n√£o use arrays, n√£o use chaves {}
- O roteiro deve ser texto corrido, dividido em par√°grafos ou se√ß√µes claras
- Cada se√ß√£o pode ter indica√ß√£o de tempo entre par√™nteses ou colchetes, mas o conte√∫do deve ser texto narrativo direto
- Exemplo de formato correto:
  "[0:00-0:30] Texto do roteiro aqui... 
  
  [0:30-1:30] Continua√ß√£o do roteiro...
  
  [1:30-3:00] Mais conte√∫do..."
  
- N√ÉO use formato como: {"section": "...", "time": "...", "content": "..."}
- N√ÉO use listas numeradas ou com marcadores para estruturar o roteiro
- O roteiro deve ser texto narrativo fluido, como se fosse o texto que ser√° narrado no v√≠deo

REGRAS CR√çTICAS DE DURA√á√ÉO - OBRIGAT√ìRIO:
- O roteiro DEVE ter EXATAMENTE ${scriptDuration} minutos de dura√ß√£o
- O roteiro DEVE ter EXATAMENTE ${scriptDuration * wordsPerMinute} palavras (${wordsPerMinute} palavras por minuto)
- N√ÉO aceite menos de ${scriptDuration * wordsPerMinute} palavras - o roteiro DEVE ter NO M√çNIMO ${scriptDuration * wordsPerMinute} palavras
- N√ÉO aceite mais de ${(scriptDuration * wordsPerMinute) + 100} palavras - o roteiro DEVE ter NO M√ÅXIMO ${(scriptDuration * wordsPerMinute) + 100} palavras
- Se o roteiro tiver menos de ${scriptDuration * wordsPerMinute} palavras, voc√™ DEVE expandir o conte√∫do at√© atingir EXATAMENTE ${scriptDuration * wordsPerMinute} palavras
- Distribua o conte√∫do proporcionalmente para preencher TODOS os ${scriptDuration} minutos
- Certifique-se de que o tempo total indicado nas se√ß√µes some ${scriptDuration} minutos (${scriptDuration * 60} segundos)
- IMPORTANTE: Conte as palavras antes de finalizar. O roteiro DEVE ter entre ${scriptDuration * wordsPerMinute} e ${(scriptDuration * wordsPerMinute) + 100} palavras
- CR√çTICO: Se voc√™ n√£o conseguir gerar ${scriptDuration * wordsPerMinute} palavras, continue expandindo o conte√∫do at√© atingir essa quantidade

RESPOSTA FINAL - CR√çTICO:
- Responda APENAS com o roteiro em TEXTO SIMPLES e DIRETO
- N√ÉO use JSON, N√ÉO use objetos {}, N√ÉO use arrays [], N√ÉO use chaves ou colchetes para estruturar
- N√ÉO use formato: {"roteiro": "...", "duracao": "...", "estrutura": "..."}
- N√ÉO use formato: [{"section": "...", "time": "...", "content": "..."}]
- O roteiro deve ser texto corrido, como se voc√™ estivesse escrevendo o texto que ser√° narrado
- Voc√™ pode usar [0:00-0:30] para indicar tempo, mas o resto deve ser texto narrativo puro
- IMPORTANTE: O roteiro ser√° usado para VOICE OVER, ent√£o escreva de forma natural e fluida
- Use pontos finais e dois pontos para separar frases naturalmente
- O texto deve estar pronto para ser copiado e usado diretamente na narra√ß√£o do v√≠deo
- N√ÉO inclua NADA al√©m do roteiro em si - nem explica√ß√µes, nem metadados, nem JSON
- Meta de palavras: aproximadamente ${scriptDuration * wordsPerMinute} palavras para ${scriptDuration} minutos`;

            let apiCallFunction;
            if (service === 'gemini') apiCallFunction = callGeminiAPI;
            else if (service === 'claude') apiCallFunction = callClaudeAPI;
            else apiCallFunction = callOpenAIAPI;

            const originalResponse = await apiCallFunction(scriptPrompt, decryptedKey, selectedModel);
            
            // Extrair conte√∫do da resposta (pode vir em diferentes formatos)
            scriptContent = extractTextFromAIResponse(originalResponse) || '';

        // Limpar o roteiro: remover explica√ß√µes, metadados, markdown, JSON, etc.
        // Garantir que a sa√≠da seja apenas o roteiro limpo em texto simples
        scriptContent = scriptContent
            // Remover estruturas JSON completas (objetos e arrays)
            .replace(/\{[\s\S]*?"script"[\s\S]*?\}/g, '')
            .replace(/\{[\s\S]*?"section"[\s\S]*?\}/g, '')
            .replace(/\{[\s\S]*?"content"[\s\S]*?\}/g, '')
            .replace(/\{[\s\S]*?"time"[\s\S]*?\}/g, '')
            // Remover arrays JSON
            .replace(/\[[\s\S]*?\{[\s\S]*?\}[\s\S]*?\]/g, '')
            // Extrair apenas o conte√∫do de texto de estruturas JSON (se ainda houver)
            .replace(/"content"\s*:\s*"([^"]+)"/gi, '$1')
            .replace(/"text"\s*:\s*"([^"]+)"/gi, '$1')
            .replace(/"script"\s*:\s*"([^"]+)"/gi, '$1')
            // Remover blocos de c√≥digo markdown
            .replace(/```[\s\S]*?```/g, '')
            // Remover JSON completo entre chaves (mais agressivo)
            .replace(/\{[^{}]*"roteiro"[\s\S]*?\}/g, '')
            .replace(/\{[^{}]*"duracao"[\s\S]*?\}/g, '')
            .replace(/\{[^{}]*"estrutura"[\s\S]*?\}/g, '')
            .replace(/\{[\s\S]{0,5000}\}/g, '')
            // Remover cabe√ßalhos markdown excessivos
            .replace(/^#{1,6}\s+.+$/gm, '')
            // Remover linhas que come√ßam com "Roteiro:", "Script:", etc (metadados)
            .replace(/^(Roteiro|Script|Conte√∫do|Texto|Output|Resultado|Aqui est√°|Segue|Abaixo est√°|Este √© o|O roteiro √©|title|section|time):\s*/gmi, '')
            // Remover explica√ß√µes comuns no in√≠cio/fim
            .replace(/\s*(Espero que|Espero|Boa sorte|Bom trabalho|Sucesso|Bom v√≠deo)\.?$/gmi, '')
            // Remover aspas JSON restantes
            .replace(/^["']|["']$/gm, '')
            // Remover m√∫ltiplas quebras de linha (mais de 2)
            .replace(/\n{3,}/g, '\n\n')
            // Limpar espa√ßos no in√≠cio e fim
            .trim();
        
        // Se o conte√∫do ainda estiver muito curto ou vazio ap√≥s limpeza, tentar extrair texto de JSON
        if (scriptContent.length < 100) {
            try {
                // Tentar encontrar e parsear JSON na resposta original
                const rawText = typeof originalResponse === 'string'
                    ? originalResponse
                    : JSON.stringify(originalResponse || '');
                const jsonMatch = rawText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const jsonObj = JSON.parse(jsonMatch[0]);
                    
                    if (jsonObj.script && Array.isArray(jsonObj.script)) {
                        // Extrair conte√∫do de array de objetos (formato do exemplo do usu√°rio)
                        scriptContent = jsonObj.script.map(item => {
                            if (item.content) {
                                const timeStr = item.time ? `[${item.time}] ` : '';
                                return timeStr + item.content;
                            }
                            if (typeof item === 'string') return item;
                            return '';
                        }).filter(Boolean).join('\n\n');
                    } else if (jsonObj.content) {
                        scriptContent = jsonObj.content;
                    } else if (jsonObj.script && typeof jsonObj.script === 'string') {
                        scriptContent = jsonObj.script;
                    } else if (jsonObj.text) {
                        scriptContent = jsonObj.text;
                    }
                }
            } catch (e) {
                // Se falhar ao parsear JSON, tentar extrair texto diretamente
                console.warn('[Roteiro] Erro ao parsear JSON, tentando extra√ß√£o direta:', e.message);
                
                // Tentar extrair conte√∫do de strings JSON sem parsear completamente
                const rawText = typeof originalResponse === 'string'
                    ? originalResponse
                    : JSON.stringify(originalResponse || '');
                const contentMatches = rawText.match(/"content"\s*:\s*"([^"]+)"/gi);
                if (contentMatches && contentMatches.length > 0) {
                    scriptContent = contentMatches.map(match => {
                        const extracted = match.match(/"content"\s*:\s*"([^"]+)"/i);
                        return extracted ? extracted[1] : '';
                    }).filter(Boolean).join('\n\n');
                }
            }
        }
        
            // Garantir que o conte√∫do final n√£o esteja vazio
            if (!scriptContent || scriptContent.trim().length < 50) {
                console.warn('[Roteiro] Conte√∫do muito curto ap√≥s limpeza, usando resposta original');
                scriptContent = extractTextFromAIResponse(originalResponse) || '';
            }
        }

        // Validar quantidade de palavras e expandir se necess√°rio
        // Usar 130 palavras/minuto de forma rigorosa
        const wordsPerMinuteRigorous = 130;
        const expectedWords = scriptDuration * wordsPerMinuteRigorous;
        // Toler√¢ncia mais rigorosa: m√°ximo 10% acima da dura√ß√£o solicitada
        const maxAllowedMinutes = scriptDuration * 1.1; // M√°ximo 10% acima
        const maxWords = maxAllowedMinutes * wordsPerMinuteRigorous;
        const minWords = expectedWords - 30; // Toler√¢ncia m√≠nima de -30 palavras
        
        let wordCount = scriptContent.trim().split(/\s+/).filter(w => w.length > 0).length;
        const estimatedMinutes = Math.round((wordCount / wordsPerMinuteRigorous) * 10) / 10;
        
        console.log(`[Roteiro] Valida√ß√£o rigorosa: ${wordCount} palavras encontradas (${estimatedMinutes} min), esperado: ${expectedWords} palavras (${scriptDuration} min)`);
        console.log(`[Roteiro] Toler√¢ncia: ${minWords}-${maxWords} palavras (${scriptDuration}-${maxAllowedMinutes.toFixed(1)} min)`);
        
        // Se o roteiro exceder muito a dura√ß√£o, avisar mas continuar
        if (estimatedMinutes > maxAllowedMinutes) {
            console.warn(`[Roteiro] ‚ö†Ô∏è Roteiro excede a dura√ß√£o solicitada: ${estimatedMinutes} min (solicitado: ${scriptDuration} min, m√°ximo: ${maxAllowedMinutes.toFixed(1)} min)`);
        }

        // Tentar expandir at√© atingir a quantidade m√≠nima (m√°ximo 3 tentativas)
        let expansionAttempts = 0;
        const maxExpansionAttempts = 3;
        
        while (wordCount < minWords && expansionAttempts < maxExpansionAttempts) {
            expansionAttempts++;
            const wordsNeeded = expectedWords - wordCount;
            const expansionRatio = expectedWords / wordCount; // Quantas vezes precisa expandir
            
            console.warn(`[Roteiro] Tentativa ${expansionAttempts}/${maxExpansionAttempts}: Roteiro muito curto: ${wordCount} palavras (m√≠nimo: ${minWords}). Expandindo...`);
            
            // Criar prompt de expans√£o mais agressivo
            const expansionPrompt = `O roteiro abaixo tem apenas ${wordCount} palavras, mas precisa ter EXATAMENTE ${expectedWords} palavras para ${scriptDuration} minutos de narra√ß√£o.

IMPORTANTE: 
- N√ÉO inclua marca√ß√µes como "(M√∫sica...)", "(Visual:...)", "NARRADOR:", etc.
- O roteiro deve ser APENAS texto puro para voice over, sem dire√ß√µes de cena, m√∫sica ou visualiza√ß√µes
- Escreva como se estivesse narrando diretamente, sem prefixos ou marca√ß√µes t√©cnicas

ROTEIRO ATUAL (${wordCount} palavras - MUITO CURTO):
${scriptContent}

INSTRU√á√ïES CR√çTICAS:
1. Voc√™ DEVE expandir este roteiro para ter EXATAMENTE ${expectedWords} palavras (atualmente tem apenas ${wordCount})
2. Voc√™ precisa adicionar aproximadamente ${wordsNeeded} palavras a mais
3. Mantenha o mesmo estilo, tom e estrutura narrativa
4. Expanda CADA se√ß√£o do roteiro proporcionalmente
5. Adicione mais detalhes, exemplos concretos, explica√ß√µes profundas, desenvolvimento de ideias, contexto hist√≥rico, curiosidades, an√°lises mais detalhadas
6. N√ÉO altere o in√≠cio ou o final, mas expanda significativamente o conte√∫do do meio
7. O roteiro deve continuar sendo texto corrido, SEM JSON, sem objetos, sem arrays
8. Cada par√°grafo deve ser expandido com mais informa√ß√µes relevantes
9. Adicione transi√ß√µes mais elaboradas entre as se√ß√µes
10. Desenvolva mais profundamente cada ideia apresentada
11. CR√çTICO: O roteiro final DEVE ter entre ${expectedWords} e ${expectedWords + 50} palavras
12. Conte mentalmente as palavras enquanto escreve. Se o roteiro n√£o tiver pelo menos ${expectedWords} palavras, continue expandindo at√© atingir essa quantidade.
13. CR√çTICO: N√ÉO inclua marca√ß√µes como "(M√∫sica...)", "(Visual:...)", "NARRADOR:", etc.
14. O roteiro deve ser APENAS texto puro para voice over, sem dire√ß√µes de cena, m√∫sica ou visualiza√ß√µes
15. Escreva como se estivesse narrando diretamente, sem prefixos ou marca√ß√µes t√©cnicas

RESPOSTA FINAL - CR√çTICO:
Escreva APENAS o texto do roteiro expandido em TEXTO SIMPLES, sem explica√ß√µes adicionais, sem metadados, N√ÉO use JSON.
Responda com o roteiro expandido imediatamente, sem envolver em objetos ou formata√ß√£o especial.`;

            try {
                let expansionResponse;
                let usedService = service;
                
                // Tentar com a API principal
                try {
                if (service === 'gemini') {
                    expansionResponse = await callGeminiAPI(expansionPrompt, decryptedKey, selectedModel);
                } else if (service === 'claude') {
                    expansionResponse = await callClaudeAPI(expansionPrompt, decryptedKey, selectedModel);
                } else {
                    expansionResponse = await callOpenAIAPI(expansionPrompt, decryptedKey, selectedModel);
                    }
                } catch (apiErr) {
                    // Se falhou (503, timeout, etc), tentar API alternativa
                    const errorMsg = apiErr.message || '';
                    if (errorMsg.includes('overloaded') || errorMsg.includes('503') || errorMsg.includes('timeout') || errorMsg.includes('UNAVAILABLE')) {
                        console.warn(`[Roteiro] ‚ö†Ô∏è ${service} falhou (${errorMsg.substring(0, 100)}). Tentando API alternativa...`);
                        
                        // Tentar fallback: Gemini ‚Üí Claude ‚Üí OpenAI ‚Üí (loop)
                        const fallbackOrder = service === 'gemini' 
                            ? ['claude', 'openai'] 
                            : service === 'claude'
                            ? ['openai', 'gemini']
                            : ['claude', 'gemini'];
                        
                        let fallbackSuccess = false;
                        for (const fallbackService of fallbackOrder) {
                            try {
                                const fallbackKey = await db.get(
                                    'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                                    [userId, fallbackService]
                                );
                                
                                if (fallbackKey) {
                                    const fallbackDecryptedKey = decrypt(fallbackKey.api_key);
                                    const fallbackModel = fallbackService === 'gemini' 
                                        ? 'gemini-2.5-pro' 
                                        : fallbackService === 'claude'
                                        ? 'claude-3-7-sonnet-20250219'
                                        : 'gpt-4o';
                                    
                                    console.log(`[Roteiro] üîÑ Tentando ${fallbackService} como fallback...`);
                                    
                                    if (fallbackService === 'gemini') {
                                        expansionResponse = await callGeminiAPI(expansionPrompt, fallbackDecryptedKey, fallbackModel);
                                    } else if (fallbackService === 'claude') {
                                        expansionResponse = await callClaudeAPI(expansionPrompt, fallbackDecryptedKey, fallbackModel);
                                    } else {
                                        expansionResponse = await callOpenAIAPI(expansionPrompt, fallbackDecryptedKey, fallbackModel);
                                    }
                                    
                                    usedService = fallbackService;
                                    fallbackSuccess = true;
                                    console.log(`[Roteiro] ‚úÖ Fallback para ${fallbackService} bem-sucedido!`);
                                    break;
                                }
                            } catch (fallbackErr) {
                                console.warn(`[Roteiro] ‚ö†Ô∏è Fallback ${fallbackService} tamb√©m falhou: ${fallbackErr.message.substring(0, 100)}`);
                            }
                        }
                        
                        if (!fallbackSuccess) {
                            throw apiErr; // Se todos falharam, lan√ßar erro original
                        }
                    } else {
                        throw apiErr; // Se n√£o √© erro de sobrecarga, lan√ßar erro
                    }
                }

                // Limpar resposta de expans√£o
                let expandedContent = extractTextFromAIResponse(expansionResponse).trim();
                expandedContent = cleanScriptForVoiceOver(expandedContent);
                expandedContent = expandedContent
                    .replace(/^```[\w]*\n?/gm, '')
                    .replace(/```$/gm, '')
                    .replace(/^\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                    .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/"content"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/"script"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/\{[\s\S]*\}/g, '')
                    .replace(/\[[\s\S]*?\]/g, '') // Remover arrays JSON
                    .trim();

                const expandedWordCount = expandedContent.trim().split(/\s+/).filter(w => w.length > 0).length;
                console.log(`[Roteiro] Ap√≥s tentativa ${expansionAttempts}: ${expandedWordCount} palavras (meta: ${expectedWords})`);

                if (expandedWordCount >= minWords) {
                    scriptContent = expandedContent;
                    wordCount = expandedWordCount;
                    console.log(`[Roteiro] ‚úÖ Expans√£o bem-sucedida! Roteiro agora tem ${wordCount} palavras.`);
                    break; // Sair do loop se atingiu o m√≠nimo
                } else if (expandedWordCount > wordCount) {
                    // Mesmo que n√£o tenha atingido o m√≠nimo, se expandiu, usar o expandido
                    scriptContent = expandedContent;
                    wordCount = expandedWordCount;
                    console.log(`[Roteiro] Roteiro expandido de ${wordCount} para ${expandedWordCount} palavras, mas ainda abaixo do m√≠nimo. Tentando novamente...`);
                } else {
                    console.warn(`[Roteiro] Expans√£o n√£o aumentou o n√∫mero de palavras. Tentando abordagem diferente...`);
                }
            } catch (expansionErr) {
                console.error(`[Roteiro] Erro na tentativa ${expansionAttempts} de expans√£o:`, expansionErr.message);
                // Continuar para pr√≥xima tentativa ou usar o que temos
            }
        }

        // Verifica√ß√£o final - se ainda estiver muito curto, fazer uma √∫ltima tentativa com prompt diferente
        if (wordCount < minWords) {
            console.warn(`[Roteiro] Roteiro ainda muito curto ap√≥s ${expansionAttempts} tentativas: ${wordCount} palavras. Fazendo √∫ltima tentativa...`);
            
            // √öltima tentativa: pedir para duplicar e expandir o conte√∫do
            const finalExpansionPrompt = `O roteiro abaixo precisa ser DUPLICADO e EXPANDIDO para ter EXATAMENTE ${expectedWords} palavras.

IMPORTANTE: 
- N√ÉO inclua marca√ß√µes como "(M√∫sica...)", "(Visual:...)", "NARRADOR:", etc.
- O roteiro deve ser APENAS texto puro para voice over, sem dire√ß√µes de cena, m√∫sica ou visualiza√ß√µes
- Escreva como se estivesse narrando diretamente, sem prefixos ou marca√ß√µes t√©cnicas

ROTEIRO ATUAL (${wordCount} palavras):
${scriptContent}

INSTRU√á√ïES FINAIS:
1. Voc√™ DEVE criar um roteiro com EXATAMENTE ${expectedWords} palavras
2. Mantenha a estrutura e o estilo, mas EXPANDA CADA IDEIA significativamente
3. Adicione exemplos, detalhes, explica√ß√µes, contexto, curiosidades
4. Desenvolva cada par√°grafo com muito mais profundidade
5. SEM JSON, objetos ou arrays - apenas texto corrido
6. CR√çTICO: N√ÉO inclua marca√ß√µes como "(M√∫sica...)", "(Visual:...)", "NARRADOR:", etc.
7. O roteiro deve ser APENAS texto puro para voice over, sem dire√ß√µes de cena, m√∫sica ou visualiza√ß√µes
8. Escreva como se estivesse narrando diretamente, sem prefixos ou marca√ß√µes t√©cnicas
9. Responda APENAS com o roteiro expandido

RESPOSTA FINAL - CR√çTICO:
Escreva APENAS o texto do roteiro expandido em TEXTO SIMPLES, N√ÉO use JSON.`;

            try {
                let finalResponse;
                if (service === 'gemini') {
                    finalResponse = await callGeminiAPI(finalExpansionPrompt, decryptedKey, selectedModel);
                } else if (service === 'claude') {
                    finalResponse = await callClaudeAPI(finalExpansionPrompt, decryptedKey, selectedModel);
                } else {
                    finalResponse = await callOpenAIAPI(finalExpansionPrompt, decryptedKey, selectedModel);
                }

                let finalContent = extractTextFromAIResponse(finalResponse).trim()
                    .replace(/^```[\w]*\n?/gm, '')
                    .replace(/```$/gm, '')
                    .replace(/^\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                    .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/\{[\s\S]*\}/g, '')
                    .trim();

                const finalWordCount = finalContent.trim().split(/\s+/).filter(w => w.length > 0).length;
                if (finalWordCount >= minWords) {
                    scriptContent = finalContent;
                    wordCount = finalWordCount;
                    console.log(`[Roteiro] ‚úÖ √öltima tentativa bem-sucedida! Roteiro agora tem ${wordCount} palavras.`);
                }
            } catch (finalErr) {
                console.error('[Roteiro] Erro na √∫ltima tentativa de expans√£o:', finalErr.message);
            }
        }

        // Verifica√ß√£o final - se ainda estiver muito curto, usar o que temos mas avisar
        const finalWordCount = scriptContent.trim().split(/\s+/).filter(w => w.length > 0).length;
        if (finalWordCount < minWords) {
            console.warn(`[Roteiro] ‚ö†Ô∏è Roteiro final ainda abaixo do m√≠nimo ap√≥s todas as tentativas: ${finalWordCount} palavras (m√≠nimo: ${minWords})`);
            // Em vez de retornar erro, vamos usar o roteiro mesmo que curto, mas adicionar uma nota
            // O sistema vai continuar funcionando, mas o usu√°rio ser√° avisado
            console.log(`[Roteiro] Usando roteiro com ${finalWordCount} palavras (abaixo do ideal de ${expectedWords}, mas funcional)`);
        } else {
            console.log(`[Roteiro] ‚úÖ Roteiro validado com sucesso: ${finalWordCount} palavras (meta: ${expectedWords})`);
        }

        // === OTIMIZA√á√ÉO DO ROTEIRO ===
        console.log('[Otimizador] üîç Analisando roteiro gerado...');
        
        // Progresso: 90% - Iniciando otimiza√ß√£o
        if (sessionId) {
            sendProgress(sessionId, {
                stage: 'optimizing',
                progress: 90,
                message: 'Analisando qualidade do roteiro...'
            });
        }
        
        const optimizer = new ScriptOptimizer(agent.niche || 'geral');
        const analysis = optimizer.analyzeScript(scriptContent);
        const optimizationReport = optimizer.generateReport(analysis);
        
        console.log('[Otimizador] üìä An√°lise conclu√≠da:');
        console.log(`  - Score Geral: ${analysis.overallScore}/10`);
        console.log(`  - Reten√ß√£o: ${analysis.retentionScore}/10`);
        console.log(`  - Autenticidade: ${analysis.authenticityScore}/10`);
        console.log(`  - Alinhamento: ${analysis.nicheAlignment}/10`);
        console.log(`  - Problemas detectados: ${analysis.problems.length}`);
        console.log(`  - Indicadores de IA: ${analysis.aiIndicators.length}`);
        console.log(`  - Clich√™s: ${analysis.cliches.length}`);
        
        // === P√ìS-PROCESSAMENTO AUTOM√ÅTICO ===
        // Se score < 8 ou tem muitos problemas, aplicar otimiza√ß√µes autom√°ticas
        let finalScriptContent = scriptContent;
        let needsOptimization = false;
        let optimizationReason = '';
        
        // üö® CR√çTICO: SEMPRE otimizar se h√° inconsist√™ncias de nomes (DESASTRE TOTAL)
        if (analysis.nameInconsistencies && analysis.nameInconsistencies.length > 0) {
            needsOptimization = true;
            optimizationReason = `üö® DESASTRE TOTAL: ${analysis.nameInconsistencies.length} inconsist√™ncias de nomes detectadas`;
            console.log(`[Otimizador] üö® CR√çTICO: ${analysis.nameInconsistencies.length} inconsist√™ncias de nomes! FOR√áANDO otimiza√ß√£o...`);
        } 
        // Verificar se precisa otimizar por score baixo
        else if (analysis.overallScore < 8) {
            needsOptimization = true;
            optimizationReason = `Score ${analysis.overallScore}/10 est√° abaixo de 8`;
            console.log(`[Otimizador] üîß ${optimizationReason}. Aplicando corre√ß√µes...`);
        } 
        // Verificar se tem muitos clich√™s
        else if (analysis.cliches.length > 3) {
            needsOptimization = true;
            optimizationReason = `${analysis.cliches.length} clich√™s detectados`;
            console.log(`[Otimizador] üîß ${optimizationReason}. Aplicando corre√ß√µes...`);
        } 
        // Verificar se tem muitos indicadores de IA
        else if (analysis.aiIndicators.length > 2) {
            needsOptimization = true;
            optimizationReason = `${analysis.aiIndicators.length} indicadores de IA detectados`;
            console.log(`[Otimizador] üîß ${optimizationReason}. Aplicando corre√ß√µes...`);
        }
        
        if (needsOptimization) {
            // Progresso: 93% - Otimizando
            if (sessionId) {
                sendProgress(sessionId, {
                    stage: 'optimizing',
                    progress: 93,
                    message: 'Removendo repeti√ß√µes e clich√™s...'
                });
            }
            
            try {
                const originalWordCount = scriptContent.split(/\s+/).filter(w => w.length > 0).length;
                
                // FASE 1: Otimiza√ß√µes B√°sicas
                if (sessionId) {
                    sendProgress(sessionId, {
                        stage: 'optimizing',
                        progress: 93,
                        message: 'üîß Normalizando nomes de personagens...',
                        details: {
                            phase: 'basic',
                            step: 'normalize_names'
                        }
                    });
                }
                
                finalScriptContent = optimizer.optimizeScript(scriptContent);
                
                if (sessionId) {
                    sendProgress(sessionId, {
                        stage: 'optimizing',
                        progress: 94,
                        message: 'üßπ Removendo repeti√ß√µes e clich√™s...',
                        details: {
                            phase: 'basic',
                            step: 'remove_repetitions'
                        }
                    });
                }
                
                finalScriptContent = removeRepetitions(finalScriptContent);
                finalScriptContent = optimizer.humanizeText(finalScriptContent);
                
                // Garantir que n√£o diminuiu muito o tamanho
                const currentWordCount = finalScriptContent.split(/\s+/).filter(w => w.length > 0).length;
                if (currentWordCount < originalWordCount * 0.85) {
                    console.warn(`[Otimizador] ‚ö†Ô∏è Roteiro reduziu muito: ${originalWordCount} ‚Üí ${currentWordCount} palavras. Revertendo...`);
                    finalScriptContent = scriptContent; // Reverter para o original
                }
                
                // Re-analisar ap√≥s otimiza√ß√µes b√°sicas
                let finalAnalysis = optimizer.analyzeScript(finalScriptContent);
                console.log(`[Otimizador] ‚úÖ Otimiza√ß√£o b√°sica conclu√≠da! Score: ${analysis.overallScore}/10 ‚Üí ${finalAnalysis.overallScore}/10`);
                
                if (sessionId) {
                    sendProgress(sessionId, {
                        stage: 'optimizing',
                        progress: 94,
                        message: `‚úÖ Fase 1 conclu√≠da - Score: ${finalAnalysis.overallScore}/10`,
                        details: {
                            phase: 'basic',
                            step: 'complete',
                            score: finalAnalysis.overallScore,
                            wordCount: currentWordCount
                        }
                    });
                }
                
                // FASE 2: üéØ REPLICADOR DE F√ìRMULA VIRAL (usa f√≥rmula armazenada ou transcri√ß√£o original)
                const hasOriginalScript = agent.full_transcript && agent.full_transcript.trim().length > 500;
                let storedViralFormula = null;
                if (agent.viral_formula_json) {
                    try {
                        storedViralFormula = JSON.parse(agent.viral_formula_json);
                    } catch (formulaParseErr) {
                        console.warn('[Otimizador] ‚ö†Ô∏è N√£o foi poss√≠vel parsear viral_formula_json do agente:', formulaParseErr.message);
                    }
                }
                const canReplicateStructure = !!storedViralFormula || hasOriginalScript;
                
                if (canReplicateStructure) {
                    console.log('[Otimizador] üéØ Aplicando REPLICADOR DE F√ìRMULA VIRAL (obrigat√≥rio para manter a estrutura original).');
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'viral_replication',
                            progress: 95,
                            message: storedViralFormula
                                ? 'üéØ Aplicando f√≥rmula viral armazenada...'
                                : 'üéØ Analisando f√≥rmula viral do roteiro original...',
                            details: {
                                phase: 'viral',
                                step: storedViralFormula ? 'loading_formula' : 'analyzing_formula'
                            }
                        });
                    }
                    
                    try {
                        const claudeKeyData = await db.get(
                            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                            [userId, 'claude']
                        );
                        
                        if (claudeKeyData && claudeKeyData.api_key) {
                            const claudeApiKey = decrypt(claudeKeyData.api_key);
                            const viralReplicator = new ViralFormulaReplicator();
                            
                            let viralFormula = storedViralFormula;
                            
                            // Passo 1: Analisar f√≥rmula viral do roteiro original caso n√£o exista uma armazenada
                            if (!viralFormula && hasOriginalScript) {
                                viralFormula = await viralReplicator.analyzeViralFormula(
                                    agent.full_transcript,
                                    claudeApiKey,
                                    agent.source_video_title || title,
                                    agent.niche
                                );
                                
                                // Armazenar para reutiliza√ß√£o futura
                                if (viralFormula) {
                                    try {
                                        await db.run(
                                            `UPDATE script_agents SET viral_formula_json = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                            [JSON.stringify(viralFormula), agent.id]
                                        );
                                        console.log('[Otimizador] üíæ F√≥rmula viral salva no agente para reutiliza√ß√£o.');
                                    } catch (saveErr) {
                                        console.warn('[Otimizador] ‚ö†Ô∏è N√£o foi poss√≠vel salvar a f√≥rmula viral no agente:', saveErr.message);
                                    }
                                }
                            }

                            if (!viralFormula) {
                                console.warn('[Otimizador] ‚ö†Ô∏è F√≥rmula viral n√£o dispon√≠vel. Pulando replica√ß√£o.');
                                if (sessionId) {
                                    sendProgress(sessionId, {
                                        stage: 'viral_replication',
                                        progress: 96,
                                        message: '‚ö†Ô∏è F√≥rmula viral indispon√≠vel para replica√ß√£o',
                                        details: {
                                            phase: 'viral',
                                            step: 'skipped',
                                            reason: 'formula_missing'
                                        }
                                    });
                                }
                                throw new Error('F√≥rmula viral indispon√≠vel');
                            }
                            
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'viral_replication',
                                    progress: 96,
                                    message: storedViralFormula ? 'üöÄ Aplicando f√≥rmula viral armazenada...' : 'üöÄ Replicando f√≥rmula viral no novo roteiro...',
                                    details: {
                                        phase: 'viral',
                                        step: storedViralFormula ? 'applying_formula' : 'replicating_formula',
                                        formula: viralFormula
                                    }
                                });
                            }
                            
                            // Passo 2: Replicar f√≥rmula no novo roteiro
                            const replicationResult = await viralReplicator.replicateFormula(
                                viralFormula,
                                title,
                                agent.full_transcript || '[F√≥rmula carregada sem transcri√ß√£o completa]',
                                finalScriptContent,
                                claudeApiKey,
                                agent.niche,
                                scriptDuration
                            );
                            
                            if (replicationResult.success) {
                                const newWordCount = replicationResult.replicatedScript.split(/\s+/).filter(w => w.length > 0).length;
                                
                                // Validar que n√£o diminuiu muito
                                if (newWordCount < originalWordCount * 0.85) {
                                    console.warn(`[Otimizador] ‚ö†Ô∏è Replica√ß√£o diminuiu muito: ${originalWordCount} ‚Üí ${newWordCount}. Mantendo vers√£o anterior.`);
                                } else {
                                    finalScriptContent = replicationResult.replicatedScript;
                                    console.log('[Otimizador] üéâ F√≥rmula viral replicada com sucesso!');
                                    
                                    if (sessionId) {
                                        sendProgress(sessionId, {
                                            stage: 'viral_replication',
                                            progress: 97,
                                            message: '‚úÖ F√≥rmula viral replicada! Roteiro 10/10',
                                            details: {
                                                phase: 'viral',
                                                step: 'replicated',
                                                newWordCount: newWordCount,
                                                formula: viralFormula
                                            }
                                        });
                                    }
                                    
                                    // Re-analisar ap√≥s replica√ß√£o
                                    finalAnalysis = optimizer.analyzeScript(finalScriptContent);
                                    console.log(`[Otimizador] üöÄ Score FINAL ap√≥s replica√ß√£o viral: ${finalAnalysis.overallScore}/10`);
                                }
                            }
                        } else {
                            console.warn('[Otimizador] ‚ö†Ô∏è API Key do Claude n√£o encontrada para replica√ß√£o viral.');
                        }
                    } catch (viralErr) {
                        console.error('[Otimizador] ‚ö†Ô∏è Erro na replica√ß√£o viral:', viralErr.message);
                        console.log('[Otimizador] Continuando sem replica√ß√£o viral.');
                    }
                }
                
                // FASE 3: ü§ñ VALIDA√á√ÉO INTELIGENTE COM CLAUDE AI (se score ainda baixo e n√£o tem roteiro original)
                const needsAICorrection = (
                    finalAnalysis.overallScore < 7 ||
                    (finalAnalysis.nameInconsistencies && finalAnalysis.nameInconsistencies.length > 0) ||
                    finalAnalysis.aiIndicators.length > 2 ||
                    finalAnalysis.cliches.length > 5
                );
                
                if (needsAICorrection) {
                    console.log(`[Otimizador] ü§ñ Score ${finalAnalysis.overallScore}/10 ainda baixo. Ativando VALIDADOR INTELIGENTE (Claude AI)...`);
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'ai_correction',
                            progress: 95,
                            message: 'ü§ñ Claude AI analisando problemas...',
                            details: {
                                phase: 'ai',
                                step: 'analyzing',
                                currentScore: finalAnalysis.overallScore,
                                problems: finalAnalysis.problems.length,
                                nameInconsistencies: finalAnalysis.nameInconsistencies?.length || 0
                            }
                        });
                    }
                    
                    try {
                        // Buscar API key do Claude
                        const claudeKeyData = await db.get(
                            'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                            [userId, 'claude']
                        );
                        
                        if (claudeKeyData && claudeKeyData.api_key) {
                            const claudeApiKey = decrypt(claudeKeyData.api_key);
                            const aiValidator = new AIScriptValidator();
                            
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'ai_correction',
                                    progress: 96,
                                    message: '‚úçÔ∏è Claude AI reescrevendo roteiro...',
                                    details: {
                                        phase: 'ai',
                                        step: 'rewriting'
                                    }
                                });
                            }
                            
                            const validationResult = await aiValidator.validateAndFixScript(
                                finalScriptContent,
                                finalAnalysis,
                                claudeApiKey,
                                agent.niche,
                                title
                            );
                            
                            if (validationResult.success) {
                                const newWordCount = validationResult.correctedScript.split(/\s+/).filter(w => w.length > 0).length;
                                
                                // Validar que n√£o diminuiu o tamanho
                                if (newWordCount < originalWordCount * 0.85) {
                                    console.warn(`[Otimizador] ‚ö†Ô∏è Claude reduziu muito o roteiro: ${originalWordCount} ‚Üí ${newWordCount}. Mantendo vers√£o anterior.`);
                                    if (sessionId) {
                                        sendProgress(sessionId, {
                                            stage: 'ai_correction',
                                            progress: 97,
                                            message: '‚ö†Ô∏è Roteiro corrigido muito curto, mantendo vers√£o anterior',
                                            details: {
                                                phase: 'ai',
                                                step: 'rejected',
                                                reason: 'too_short'
                                            }
                                        });
                                    }
                                } else {
                                    finalScriptContent = validationResult.correctedScript;
                                    console.log('[Otimizador] üéâ Claude AI corrigiu o roteiro!');
                                    console.log(`[Otimizador] üìä Melhorias: ${validationResult.improvements.join(', ')}`);
                                    
                                    if (sessionId) {
                                        sendProgress(sessionId, {
                                            stage: 'ai_correction',
                                            progress: 97,
                                            message: '‚úÖ Claude AI finalizou corre√ß√£o!',
                                            details: {
                                                phase: 'ai',
                                                step: 'corrected',
                                                improvements: validationResult.improvements,
                                                newWordCount: newWordCount
                                            }
                                        });
                                    }
                                    
                                    // Re-analisar ap√≥s corre√ß√£o da IA
                                    finalAnalysis = optimizer.analyzeScript(finalScriptContent);
                                    console.log(`[Otimizador] üöÄ Score FINAL ap√≥s Claude: ${finalAnalysis.overallScore}/10`);
                                }
                            }
                        } else {
                            console.warn('[Otimizador] ‚ö†Ô∏è API Key do Claude n√£o encontrada. Pulando valida√ß√£o inteligente.');
                            if (sessionId) {
                                sendProgress(sessionId, {
                                    stage: 'ai_correction',
                                    progress: 95,
                                    message: '‚ö†Ô∏è API Key do Claude n√£o configurada',
                                    details: {
                                        phase: 'ai',
                                        step: 'skipped',
                                        reason: 'no_api_key'
                                    }
                                });
                            }
                        }
                    } catch (aiErr) {
                        console.error('[Otimizador] ‚ö†Ô∏è Erro na valida√ß√£o com Claude:', aiErr.message);
                        console.log('[Otimizador] Continuando com otimiza√ß√£o b√°sica.');
                        if (sessionId) {
                            sendProgress(sessionId, {
                                stage: 'ai_correction',
                                progress: 95,
                                message: `‚ö†Ô∏è Erro no Claude: ${aiErr.message}`,
                                details: {
                                    phase: 'ai',
                                    step: 'error',
                                    error: aiErr.message
                                }
                            });
                        }
                    }
                }
                
                // Atualizar an√°lise final
                analysis.overallScore = finalAnalysis.overallScore;
                analysis.retentionScore = finalAnalysis.retentionScore;
                analysis.authenticityScore = finalAnalysis.authenticityScore;
                analysis.nicheAlignment = finalAnalysis.nicheAlignment;
                analysis.problems = finalAnalysis.problems;
                analysis.cliches = finalAnalysis.cliches;
                analysis.aiIndicators = finalAnalysis.aiIndicators;
                analysis.nameInconsistencies = finalAnalysis.nameInconsistencies || [];
                
                // üö® VALIDA√á√ÉO CR√çTICA: NOTA M√çNIMA 8.5/10
                const MIN_SCORE_REQUIRED = 9;
                if (finalAnalysis.overallScore < MIN_SCORE_REQUIRED) {
                    const errorMsg = `Roteiro n√£o atingiu a nota m√≠nima de ${MIN_SCORE_REQUIRED}/10. Score atual: ${finalAnalysis.overallScore}/10`;
                    console.error(`[Otimizador] ‚ùå ${errorMsg}`);
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'failed',
                            progress: 98,
                            message: `‚ùå Score ${finalAnalysis.overallScore}/10 abaixo do m√≠nimo (${MIN_SCORE_REQUIRED})`,
                            details: {
                                phase: 'validation',
                                step: 'failed',
                                score: finalAnalysis.overallScore,
                                minRequired: MIN_SCORE_REQUIRED,
                                problems: finalAnalysis.problems,
                                suggestions: finalAnalysis.suggestions
                            }
                        });
                    }
                    
                    throw new Error(`${errorMsg}\n\nProblemas encontrados:\n${finalAnalysis.problems.join('\n')}\n\nSugest√µes:\n${finalAnalysis.suggestions.join('\n')}\n\nPor favor, tente:\n1. Usar outro modelo de IA (Claude recomendado)\n2. Fornecer um t√≠tulo mais espec√≠fico\n3. Revisar o agente de roteiro\n4. Gerar novamente com instru√ß√µes mais detalhadas`);
                }
                
                // Validar que n√£o h√° inconsist√™ncias cr√≠ticas
                if (finalAnalysis.nameInconsistencies && finalAnalysis.nameInconsistencies.length > 0) {
                    const errorMsg = `Roteiro ainda cont√©m ${finalAnalysis.nameInconsistencies.length} inconsist√™ncias de nomes ap√≥s otimiza√ß√£o`;
                    console.error(`[Otimizador] ‚ùå ${errorMsg}`);
                    console.error(`Inconsist√™ncias: ${finalAnalysis.nameInconsistencies.join(', ')}`);
                    
                    if (sessionId) {
                        sendProgress(sessionId, {
                            stage: 'failed',
                            progress: 98,
                            message: '‚ùå Inconsist√™ncias de nomes n√£o corrigidas',
                            details: {
                                phase: 'validation',
                                step: 'failed',
                                nameInconsistencies: finalAnalysis.nameInconsistencies
                            }
                        });
                    }
                    
                    throw new Error(`${errorMsg}:\n${finalAnalysis.nameInconsistencies.join('\n')}\n\nO roteiro n√£o pode ser finalizado com nomes de personagens inconsistentes. Tente gerar novamente.`);
                }
                
                console.log(`[Otimizador] ‚úÖ Valida√ß√£o final aprovada! Score: ${finalAnalysis.overallScore}/10`);
                
                if (sessionId) {
                    sendProgress(sessionId, {
                        stage: 'validating',
                        progress: 98,
                        message: `‚úÖ Valida√ß√£o aprovada! Score: ${finalAnalysis.overallScore}/10`,
                        details: {
                            phase: 'validation',
                            step: 'passed',
                            score: finalAnalysis.overallScore,
                            wordCount: finalScriptContent.split(/\s+/).filter(w => w.length > 0).length
                        }
                    });
                }
                
            } catch (optErr) {
                console.error('[Otimizador] Erro na otimiza√ß√£o:', optErr.message);
                console.log('[Otimizador] Usando roteiro original sem otimiza√ß√µes');
                finalScriptContent = scriptContent;
            }
        } else {
            console.log(`[Otimizador] ‚úÖ Roteiro j√° est√° em alta qualidade (score ${analysis.overallScore}/10)`);
        }
        
        scriptContent = finalScriptContent;
        
        // Aplicar limpeza final para remover qualquer marca√ß√£o restante
        scriptContent = cleanScriptForVoiceOver(scriptContent);

        // Salvar o roteiro gerado com an√°lise de otimiza√ß√£o
        const scriptResult = await db.run(
            `INSERT INTO generated_scripts (user_id, script_agent_id, title, script_content, model_used, niche, subniche, optimization_score, optimization_report, retention_score, authenticity_score)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, agentId, title, scriptContent, selectedModel, agent.niche, agent.subniche, analysis.overallScore, optimizationReport, analysis.retentionScore, analysis.authenticityScore]
        );

        // Atualizar contador de uso do agente
        await db.run(
            `UPDATE script_agents SET usage_count = usage_count + 1, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
            [agentId]
        );

        // Garantir que scriptContent n√£o esteja vazio
        if (!scriptContent || scriptContent.trim().length === 0) {
            console.error('[Roteiro] Erro: Roteiro gerado est√° vazio');
            return res.status(500).json({ 
                msg: 'Erro ao gerar roteiro: O conte√∫do retornado est√° vazio. Tente novamente ou use outro modelo de IA.' 
            });
        }

        // Progresso: 100% - Conclu√≠do
        if (sessionId) {
            sendProgress(sessionId, {
                stage: 'complete',
                progress: 100,
                message: 'Roteiro gerado com sucesso!',
                viralScore: analysis.overallScore,
                totalParts: numberOfParts,
                details: {
                    score: analysis.overallScore,
                    scriptId: scriptResult.lastID
                }
            });
        }

        res.status(200).json({
            msg: 'Roteiro gerado com sucesso!',
            script: scriptContent,
            scriptId: scriptResult.lastID,
            title: title,
            model: selectedModel,
            duration: scriptDuration,
            language: scriptLanguage,
            wordCount: scriptContent.trim().split(/\s+/).filter(w => w.length > 0).length,
            optimization: {
                overallScore: analysis.overallScore,
                retentionScore: analysis.retentionScore,
                authenticityScore: analysis.authenticityScore,
                nicheAlignment: analysis.nicheAlignment,
                problems: analysis.problems,
                suggestions: analysis.suggestions,
                aiIndicators: analysis.aiIndicators,
                cliches: analysis.cliches,
                nameInconsistencies: analysis.nameInconsistencies || [],
                wasOptimized: needsOptimization,
                optimizationReason: needsOptimization ? optimizationReason : null
            }
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId/generate]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar roteiro.' });
    }
});

// === ROTA LAOZHANG PARA GERA√á√ÉO DE ROTEIROS ===
app.post('/api/script-agents/:agentId/generate/laozhang', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { title, topic, duration, language, cta, selectedModel, additionalInstructions, sessionId, parts } = req.body;
    const userId = req.user.id;

    console.log(`[Script Laozhang] Requisi√ß√£o recebida - agentId: ${agentId}, userId: ${userId}, title: ${title}`);

    if (!title) {
        return res.status(400).json({ msg: 'T√≠tulo do v√≠deo √© obrigat√≥rio.' });
    }

    if (!agentId) {
        console.error(`[Script Laozhang] agentId n√£o fornecido na URL`);
        return res.status(400).json({ msg: 'ID do agente √© obrigat√≥rio.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo n√£o configurada no painel admin.' });
        }

        // Buscar o agente
        console.log(`[Script Laozhang] Buscando agente com id=${agentId} e user_id=${userId}`);
        
        // Primeiro, verificar se o agente existe (sem filtro de user_id)
        const agentExists = await db.get(
            `SELECT id, user_id, agent_name FROM script_agents WHERE id = ?`,
            [agentId]
        );
        
        if (!agentExists) {
            console.error(`[Script Laozhang] Agente ${agentId} n√£o existe no banco de dados`);
            // Listar todos os agentes do usu√°rio para debug
            const userAgents = await db.all(
                `SELECT id, agent_name FROM script_agents WHERE user_id = ?`,
                [userId]
            );
            console.log(`[Script Laozhang] Agentes dispon√≠veis para user_id=${userId}:`, userAgents);
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }
        
        if (agentExists.user_id !== userId) {
            console.error(`[Script Laozhang] Agente ${agentId} existe mas pertence ao user_id=${agentExists.user_id}, n√£o ao user_id=${userId}`);
            return res.status(403).json({ msg: 'Voc√™ n√£o tem permiss√£o para usar este agente.' });
        }
        
        // Buscar o agente completo
        const agent = await db.get(
            `SELECT * FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );
        
        if (!agent) {
            console.error(`[Script Laozhang] Erro inesperado: agente existe mas n√£o foi encontrado com filtro user_id`);
            return res.status(500).json({ msg: 'Erro ao buscar agente.' });
        }

        console.log(`[Script Laozhang] Agente encontrado: ${agent.agent_name || 'Sem nome'}`);

        let scriptDuration = duration ? parseInt(duration) : 5;
        const scriptLanguage = language || 'pt';
        
        // Configurar CTAs (Call to Action)
        const ctaConfig = {
            inicio: cta?.inicio || false,
            meio: cta?.meio || false,
            final: cta?.final !== undefined ? cta.final : true // Padr√£o: CTA no final
        };
        
        console.log(`[Script Laozhang] CTAs configurados: in√≠cio=${ctaConfig.inicio}, meio=${ctaConfig.meio}, final=${ctaConfig.final}`);
        
        // Mapear o modelo selecionado (aceitar tanto os valores do frontend quanto os nomes completos)
        let laozhangModel = null;
        if (selectedModel) {
            const modelLower = selectedModel.toLowerCase();
            if (modelLower.includes('claude') || modelLower.includes('sonnet') || selectedModel === 'claude-3-7-sonnet-20250219' || selectedModel === 'Claude 3.7 Sonnet (Fev/25)') {
                laozhangModel = 'claude-3-7-sonnet-20250219';
            } else if (modelLower.includes('gemini') || modelLower.includes('pro') || selectedModel === 'gemini-2.5-pro' || selectedModel === 'Gemini 2.5 Pro (2025)') {
                laozhangModel = 'gemini-2.5-pro';
            } else if (modelLower.includes('gpt') || modelLower.includes('4o') || selectedModel === 'gpt-4o' || selectedModel === 'GPT-4o (2025)') {
                laozhangModel = 'gpt-4o';
            } else {
                // Tentar usar o modelo diretamente
                laozhangModel = selectedModel;
            }
        }
        
        // Se ainda n√£o tem modelo, usar 'gpt-4o' apenas como √∫ltimo recurso
        if (!laozhangModel) {
            console.warn(`[Script Laozhang] ‚ö†Ô∏è Modelo n√£o fornecido, usando 'gpt-4o' como fallback`);
            laozhangModel = 'gpt-4o';
        }
        
        console.log(`[Script Laozhang] Modelo selecionado: "${selectedModel || 'N/A'}" -> Mapeado para API: "${laozhangModel}"`);

        // A dura√ß√£o j√° vem ajustada do frontend (com 3-5 minutos extras)
        // N√£o adicionar mais minutos aqui para evitar duplica√ß√£o
        // Mas aumentar wordsPerMinute para garantir margem de seguran√ßa
        const originalDuration = scriptDuration;
        console.log(`[Script Laozhang] Dura√ß√£o recebida do frontend: ${scriptDuration} minutos (j√° ajustada)`);
        
        // Definir palavras por minuto baseado no modelo
        // Aumentar para garantir que sempre seja suficiente (margem de seguran√ßa)
        // GPT: 200 palavras/minuto (aumentado para garantir dura√ß√£o m√≠nima)
        // Claude: 180 palavras/minuto (aumentado para garantir dura√ß√£o m√≠nima)
        // Gemini: 180 palavras/minuto (aumentado para garantir dura√ß√£o m√≠nima)
        let wordsPerMinute = 180; // Base aumentada para todos os modelos
        if (laozhangModel === 'gpt-4o') {
            wordsPerMinute = 200; // Aumentado para 200 para garantir dura√ß√£o m√≠nima
            console.log(`[Script Laozhang] GPT detectado: usando ${wordsPerMinute} palavras/minuto (aumentado para garantir dura√ß√£o m√≠nima)`);
        } else if (laozhangModel === 'claude-3-7-sonnet-20250219') {
            wordsPerMinute = 180; // Aumentado para 180 para garantir dura√ß√£o m√≠nima
            console.log(`[Script Laozhang] Claude detectado: usando ${wordsPerMinute} palavras/minuto (aumentado para garantir dura√ß√£o m√≠nima)`);
        } else {
            wordsPerMinute = 180; // Gemini aumentado para 180
            console.log(`[Script Laozhang] Gemini detectado: usando ${wordsPerMinute} palavras/minuto (aumentado para garantir dura√ß√£o m√≠nima)`);
        }

        // Criar prompt detalhado e espec√≠fico
        // IMPORTANTE: Incluir palavras-chave para detectar como script request
        const targetWords = scriptDuration * wordsPerMinute;
        
        // Calcular n√∫mero de partes ANTES de criar o prompt (para usar no prompt)
        // SEMPRE respeitar o n√∫mero de partes solicitado pelo frontend
        let requestedParts = parseInt(parts, 10);
        if (Number.isNaN(requestedParts) || requestedParts <= 0) {
            requestedParts = null;
        }
        const idealParts = Math.max(1, Math.ceil(scriptDuration / 3));
        const numberOfParts = requestedParts || idealParts;
        if (requestedParts) {
            console.log(`[Script Laozhang] Usando n√∫mero de partes solicitado pelo frontend: ${requestedParts} (ideal seria ${idealParts})`);
        } else {
            console.log(`[Script Laozhang] Nenhuma parte especificada, usando c√°lculo ideal: ${idealParts}`);
        }
        
        const prompt = `${agent.agent_prompt || 'Voc√™ √© um ESPECIALISTA EM ROTEIROS VIRAIS para YouTube. Crie roteiros envolventes, cativantes e otimizados para viraliza√ß√£o.'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
INSTRU√á√ïES DETALHADAS DO AGENTE (F√ìRMULA VIRAL):
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
${agent.agent_instructions || 'Siga a estrutura e f√≥rmula viral identificada no roteiro original analisado.'}

${additionalInstructions ? `\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
INSTRU√á√ïES ADICIONAIS DO USU√ÅRIO:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
${additionalInstructions}\n` : ''}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PAR√ÇMETROS DO ROTEIRO:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
T√çTULO: "${title}"
DURA√á√ÉO: ${scriptDuration} minutos (aproximadamente ${targetWords} palavras - ${wordsPerMinute} palavras/minuto)
IDIOMA: ${scriptLanguage === 'pt' ? 'Portugu√™s (Brasil)' : scriptLanguage === 'en' ? 'Ingl√™s' : 'Espanhol'}
${topic ? `T√ìPICO ADICIONAL: ${topic}\n` : ''}
NICHE: ${agent.niche || 'N/A'}
SUBNICHE: ${agent.subniche || 'N/A'}

${(ctaConfig.inicio || ctaConfig.meio || ctaConfig.final) ? `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CALL TO ACTION (CTA) - OBRIGAT√ìRIO E NATURAL ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
${ctaConfig.inicio ? `‚úÖ CTA no IN√çCIO (primeiros 30 segundos): 
   - Voc√™ DEVE incluir uma chamada para a√ß√£o NATURAL e ORG√ÇNICA nos primeiros 30 segundos do roteiro
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar for√ßado
   - Exemplos naturais: "Se voc√™ est√° gostando deste conte√∫do, j√° deixa seu like e se inscreva no canal para n√£o perder os pr√≥ximos v√≠deos", "Antes de continuar, se inscreva no canal e ative o sininho para receber notifica√ß√µes", "Se este conte√∫do est√° te ajudando, j√° deixa seu like e comenta o que achou"
   - O CTA deve fazer parte do fluxo narrativo natural, n√£o deve parecer uma interrup√ß√£o
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, n√£o uma marca√ß√£o separada\n` : ''}
${ctaConfig.meio ? `‚úÖ CTA no MEIO (aproximadamente na metade do v√≠deo):
   - Voc√™ DEVE incluir uma chamada para a√ß√£o NATURAL e ORG√ÇNICA no meio do roteiro
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar for√ßado
   - Exemplos naturais: "Se voc√™ est√° aprendendo algo novo aqui, j√° deixa seu like e compartilha com quem precisa ver isso", "Antes de continuarmos, se inscreva no canal para n√£o perder o restante deste conte√∫do", "Se este v√≠deo est√° te ajudando, j√° deixa seu like e comenta suas d√∫vidas"
   - O CTA deve fazer parte do fluxo narrativo natural, n√£o deve parecer uma interrup√ß√£o
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, n√£o uma marca√ß√£o separada\n` : ''}
${ctaConfig.final ? `‚úÖ CTA no FINAL (√∫ltimos 30 segundos):
   - Voc√™ DEVE incluir uma chamada para a√ß√£o FORTE, NATURAL e ORG√ÇNICA nos √∫ltimos 30 segundos do roteiro
   - Este √© o CTA mais importante - deve ser impactante mas ainda assim natural
   - Integre o CTA de forma fluida e natural no contexto do roteiro, sem soar for√ßado
   - Exemplos naturais: "Se este conte√∫do te ajudou, j√° deixa seu like, se inscreva no canal, ative o sininho, compartilhe com seus amigos e comente o que achou", "N√£o esque√ßa de deixar seu like, se inscrever no canal e compartilhar este v√≠deo com quem precisa ver isso", "Se voc√™ gostou deste conte√∫do, j√° deixa seu like, se inscreva no canal, ative o sininho para receber notifica√ß√µes e compartilhe com seus amigos"
   - O CTA deve fazer parte do fluxo narrativo natural, n√£o deve parecer uma interrup√ß√£o
   - IMPORTANTE: O CTA deve ser parte do texto narrativo, n√£o uma marca√ß√£o separada
   - CR√çTICO: Este CTA final √© essencial para o engajamento do v√≠deo\n` : ''}
‚ö†Ô∏è REGRAS IMPORTANTES SOBRE CTAs:
- Os CTAs devem ser inclu√≠dos de forma NATURAL e ORG√ÇNICA no texto narrativo
- N√ÉO use marca√ß√µes como "[CTA]", "(CTA)", ou qualquer indica√ß√£o expl√≠cita de CTA
- N√ÉO interrompa o fluxo narrativo abruptamente para incluir o CTA
- O CTA deve fazer parte da narrativa, como se fosse uma conversa natural com o espectador
- Use linguagem conversacional e envolvente
- Seja persuasivo mas genu√≠no, n√£o for√ßado
- O CTA deve parecer que faz parte naturalmente do roteiro, n√£o algo adicionado depois
- CR√çTICO: Se os CTAs n√£o forem inclu√≠dos de forma natural, o roteiro ser√° considerado incompleto

` : ''}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
RESPOSTA FINAL - CR√çTICO: ROTEIRO EM TEXTO SIMPLES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è FORMATO DE RESPOSTA OBRIGAT√ìRIO ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è

Voc√™ DEVE retornar APENAS o texto do roteiro em TEXTO SIMPLES. N√ÉO use JSON. N√ÉO use markdown. N√ÉO use objetos ou estruturas de dados.

N√ÉO retorne:
‚ùå JSON (n√£o use { }, n√£o use "roteiro": "...", n√£o use "script": "...")
‚ùå Markdown (n√£o use code blocks, n√£o use #, n√£o use **)
‚ùå Objetos ou estruturas de dados
‚ùå Metadados ou informa√ß√µes adicionais

RETORNE APENAS:
‚úÖ O texto puro do roteiro
‚úÖ Texto corrido e natural
‚úÖ Direto ao ponto, sem formata√ß√µes especiais
‚úÖ Apenas o conte√∫do do roteiro em si

‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è DURA√á√ÉO OBRIGAT√ìRIA - CR√çTICO ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
O roteiro DEVE ter EXATAMENTE ${scriptDuration} minutos de dura√ß√£o quando narrado.
Isso significa NO M√çNIMO ${targetWords} palavras (${scriptDuration} minutos √ó ${wordsPerMinute} palavras por minuto).
‚ö†Ô∏è CR√çTICO: O roteiro NUNCA pode ter MENOS de ${targetWords} palavras. Se tiver menos, ser√° REJEITADO.
‚ö†Ô∏è CR√çTICO: O roteiro deve ter PELO MENOS ${targetWords} palavras para garantir ${scriptDuration} minutos de narra√ß√£o.
‚ö†Ô∏è CR√çTICO: Se o roteiro tiver menos de ${targetWords} palavras, voc√™ DEVE expandir o conte√∫do at√© atingir PELO MENOS ${targetWords} palavras.
‚ö†Ô∏è CR√çTICO: √â melhor ter mais palavras do que menos. Se necess√°rio, adicione mais detalhes, exemplos, explica√ß√µes ou contexto para atingir ${targetWords} palavras.
‚ö†Ô∏è CR√çTICO: Conte as palavras antes de finalizar. O roteiro DEVE ter PELO MENOS ${targetWords} palavras.

EXEMPLO DE FORMATO CORRETO:
Olviden todo lo que saben sobre las guerras antiguas. Olviden los ej√©rcitos, las lanzas y los escudos. Existi√≥ una batalla mucho m√°s sofisticada. Una guerra silenciosa librada no en los campos de batalla, sino en los observatorios, en los calendarios, y en la mente de los ingenieros m√°s brillantes de la historia de Am√©rica.

EXEMPLO DE FORMATO INCORRETO (N√ÉO FA√áA ISSO):
{
  "roteiro": "Olviden todo lo que saben..."
}

ou

code block json com:
{
  "roteiro": "..."
}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
INSTRU√á√ïES FINAIS:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
1. Crie um roteiro completo, envolvente e otimizado para viraliza√ß√£o
2. Siga EXATAMENTE a f√≥rmula viral identificada nas instru√ß√µes do agente
3. Adapte o conte√∫do para o t√≠tulo "${title}" mantendo a estrutura viral
4. ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - DURA√á√ÉO OBRIGAT√ìRIA ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è:
   - O roteiro DEVE ter PELO MENOS ${targetWords} palavras (${scriptDuration} minutos de dura√ß√£o) distribu√≠das em ${numberOfParts} partes
   - ‚ö†Ô∏è CR√çTICO: O roteiro NUNCA pode ter MENOS de ${targetWords} palavras. Se tiver menos, ser√° REJEITADO.
   - ‚ö†Ô∏è CR√çTICO: √â melhor ter mais palavras do que menos. Se necess√°rio, expanda o conte√∫do at√© atingir PELO MENOS ${targetWords} palavras.
   - ‚ö†Ô∏è CR√çTICO: Conte as palavras antes de finalizar. O roteiro DEVE ter PELO MENOS ${targetWords} palavras.
   - ‚ö†Ô∏è CR√çTICO: Voc√™ DEVE gerar conte√∫do para TODAS as ${numberOfParts} partes. N√ÉO pare antes de completar todas as partes.
   - ‚ö†Ô∏è CR√çTICO: Se voc√™ gerar apenas ${Math.ceil(numberOfParts * 0.35)} partes ou menos, o roteiro estar√° INCOMPLETO e ser√° REJEITADO.
   - ‚ö†Ô∏è CR√çTICO: Voc√™ tem tempo suficiente - N√ÉO tenha pressa, complete TODAS as partes e garanta PELO MENOS ${targetWords} palavras.
5. Use o idioma ${scriptLanguage === 'pt' ? 'Portugu√™s (Brasil)' : scriptLanguage === 'en' ? 'Ingl√™s' : 'Espanhol'}
6. ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO - ESTRUTURA DE PAR√ÅGRAFOS E PALAVRAS - GERAR TODAS AS PARTES ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è:
   - O roteiro DEVE ser dividido em EXATAMENTE ${numberOfParts} PARTES (cada parte = aproximadamente 3 minutos)
   - ‚ö†Ô∏è CR√çTICO: Voc√™ DEVE gerar conte√∫do para TODAS as ${numberOfParts} partes. N√ÉO pare antes de completar todas as partes.
   - Cada parte (EXCETO A √öLTIMA) DEVE ter EXATAMENTE 5 PAR√ÅGRAFOS
   - Cada parte (EXCETO A √öLTIMA) DEVE ter ENTRE 390 e 450 PALAVRAS (total da parte)
   - Cada par√°grafo (EXCETO NA √öLTIMA PARTE) DEVE ter ENTRE 75 e 90 PALAVRAS
   - Distribui√ß√£o ideal: 5 par√°grafos √ó 78-90 palavras cada = 390-450 palavras totais por parte
   - Cada par√°grafo deve ser separado por uma quebra de linha dupla (espa√ßo em branco entre par√°grafos)
   - A √∫ltima parte pode ter um n√∫mero vari√°vel de par√°grafos e palavras conforme necess√°rio para concluir o conte√∫do
   - Estrutura obrigat√≥ria (voc√™ DEVE gerar TODAS estas partes): 
     ${Array.from({ length: numberOfParts }, (_, i) => {
         const partNum = i + 1;
         if (partNum === numberOfParts) {
             return `     * Parte ${partNum} (√öLTIMA): n√∫mero vari√°vel de par√°grafos e palavras (conforme necess√°rio para concluir)`;
         } else {
             return `     * Parte ${partNum}: 5 par√°grafos (390-450 palavras totais, 75-90 palavras por par√°grafo)`;
         }
     }).join('\n')}
   - ‚ö†Ô∏è CR√çTICO: Voc√™ DEVE gerar conte√∫do para TODAS as ${numberOfParts} partes listadas acima. N√ÉO pare na parte ${numberOfParts === 1 ? '1' : numberOfParts > 2 ? '2 ou 3' : '2'}. Continue at√© completar a parte ${numberOfParts}.
   - Os par√°grafos devem estar bem distribu√≠dos ao longo de cada parte
   - IMPORTANTE: Separe claramente cada par√°grafo com uma linha em branco
   - CR√çTICO: Conte as palavras de cada par√°grafo e da parte completa antes de finalizar
   - CR√çTICO: O roteiro completo DEVE ter ${targetWords} palavras distribu√≠das entre as ${numberOfParts} partes
7. Escreva APENAS o texto do roteiro, SEM JSON, SEM markdown, SEM formata√ß√µes especiais
8. ‚ö†Ô∏è CR√çTICO - N√ÉO INCLUA MARCA√á√ïES DE PARTE OU TEMPO:
   - N√ÉO inclua marca√ß√µes como "PARTE 1", "Parte 1", "PARTE 1 0:00 - 3:00", "Parte 1 0:00 - 3:00"
   - N√ÉO inclua marca√ß√µes de tempo como "[0:00-3:00]", "(0:00)", "0:00 - 3:00", "0:00-3:00"
   - N√ÉO inclua qualquer indica√ß√£o de n√∫mero de parte ou intervalo de tempo no texto
   - O roteiro deve ser APENAS texto narrativo puro, sem marca√ß√µes t√©cnicas
   - Escreva como se estivesse narrando diretamente, sem prefixos, sem marca√ß√µes de parte ou tempo
   - CR√çTICO: Se voc√™ incluir marca√ß√µes de parte ou tempo, o roteiro ser√° rejeitado

‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è LEMBRE-SE: Voc√™ DEVE gerar conte√∫do para TODAS as ${numberOfParts} partes. O roteiro completo deve ter ${targetWords} palavras. N√ÉO pare antes de completar todas as ${numberOfParts} partes. Se voc√™ parar antes da parte ${numberOfParts}, o roteiro estar√° incompleto e ser√° rejeitado.

AGORA, CRIE O ROTEIRO COMPLETO COM TODAS AS ${numberOfParts} PARTES (SEM MARCA√á√ïES DE PARTE OU TEMPO):`;

        console.log(`[Script Laozhang] Gerando roteiro com modelo: ${laozhangModel}, dura√ß√£o: ${scriptDuration} minutos (${targetWords} palavras), partes: ${numberOfParts}`);
        
        // Enviar progresso inicial
        if (sessionId) {
            sendProgress(sessionId, {
                stage: 'initializing',
                progress: 5,
                message: 'Inicializando gera√ß√£o...',
                totalParts: numberOfParts,
                currentPart: 0,
                details: { totalParts: numberOfParts }
            });
            
            sendProgress(sessionId, {
                stage: 'preparing',
                progress: 10,
                message: `Preparando IA do agente (meta: ${targetWords.toLocaleString()} palavras)...`,
                totalParts: numberOfParts,
                currentPart: 0,
                details: { model: laozhangModel, targetWords, totalParts: numberOfParts }
            });
        }
        
        const startTime = Date.now();
        
        // Simular progresso por partes durante a gera√ß√£o
        let currentPartSimulated = 0;
        const progressInterval = setInterval(() => {
            if (sessionId && currentPartSimulated < numberOfParts) {
                currentPartSimulated++;
                const progress = Math.min(80, 10 + (currentPartSimulated / numberOfParts) * 70);
                sendProgress(sessionId, {
                    stage: 'generating',
                    progress: progress,
                    currentPart: currentPartSimulated,
                    totalParts: numberOfParts,
                    message: `Gerando parte ${currentPartSimulated}/${numberOfParts}...`,
                    details: {
                        partNumber: currentPartSimulated,
                        status: 'generating',
                        percentage: Math.round((currentPartSimulated / numberOfParts) * 100),
                        completedParts: currentPartSimulated - 1
                    }
                });
            }
        }, 2000); // Atualizar a cada 2 segundos
        
        const response = await callLaozhangAPI(
            prompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_script_agents_generate',
            JSON.stringify({ endpoint: '/api/script-agents/:agentId/generate/laozhang', model: laozhangModel })
        );
        
        clearInterval(progressInterval);
        
        console.log(`[Script Laozhang] Resposta recebida do modelo ${laozhangModel}`);
        
        // Marcar todas as partes como conclu√≠das sequencialmente
        if (sessionId) {
            for (let partNum = 1; partNum <= numberOfParts; partNum++) {
                sendProgress(sessionId, {
                    stage: 'generating',
                    progress: Math.min(95, 10 + (partNum / numberOfParts) * 85),
                    currentPart: partNum,
                    totalParts: numberOfParts,
                    message: `Parte ${partNum}/${numberOfParts} conclu√≠da!`,
                    details: {
                        partNumber: partNum,
                        status: 'completed',
                        percentage: 100,
                        completedParts: partNum
                    }
                });
                // Pequeno delay entre cada atualiza√ß√£o para visualiza√ß√£o
                await new Promise(resolve => setTimeout(resolve, 400));
            }
            
            sendProgress(sessionId, {
                stage: 'completed',
                progress: 100,
                currentPart: numberOfParts,
                totalParts: numberOfParts,
                message: 'Roteiro gerado com sucesso!',
                details: { completed: true, completedParts: numberOfParts }
            });
        }

        let scriptContent = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        console.log(`[Script Laozhang] Resposta recebida (primeiros 500 chars):`, scriptContent.substring(0, 500));
        
        // Limpar o roteiro (remover JSON, markdown, etc) - processo mais robusto
        let cleanedScript = scriptContent;
        
        // 1. Remover markdown code blocks
        cleanedScript = cleanedScript.replace(/```[\s\S]*?```/g, '');
        cleanedScript = cleanedScript.replace(/```json[\s\S]*?```/gi, '');
        cleanedScript = cleanedScript.replace(/```text[\s\S]*?```/gi, '');
        
        // 2. Tentar extrair texto de estruturas JSON comuns
        const jsonPatterns = [
            /"roteiro"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /"script"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /"content"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /"texto"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /"text"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/gi,
            /roteiro["']?\s*:\s*["']([^"']+)["']/gi,
            /script["']?\s*:\s*["']([^"']+)["']/gi
        ];
        
        for (const pattern of jsonPatterns) {
            const match = cleanedScript.match(pattern);
            if (match && match[1]) {
                cleanedScript = match[1]
                    .replace(/\\n/g, '\n')
                    .replace(/\\r/g, '\r')
                    .replace(/\\t/g, '\t')
                    .replace(/\\"/g, '"')
                    .replace(/\\'/g, "'")
                    .replace(/\\\\/g, '\\');
                console.log(`[Script Laozhang] Extra√≠do texto de JSON usando padr√£o: ${pattern}`);
                break;
            }
        }
        
        // 3. Remover estruturas JSON restantes
        cleanedScript = cleanedScript
            .replace(/^[^{]*\{[\s\S]*?"roteiro"\s*:\s*/, '')  // Remove in√≠cio de JSON at√© "roteiro":
            .replace(/^[^{]*\{[\s\S]*?"script"\s*:\s*/, '')  // Remove in√≠cio de JSON at√© "script":
            .replace(/^[^{]*\{[\s\S]*?"content"\s*:\s*/, '')  // Remove in√≠cio de JSON at√© "content":
            .replace(/["']roteiro["']\s*:\s*["']?/gi, '')     // Remove "roteiro": "
            .replace(/["']script["']\s*:\s*["']?/gi, '')      // Remove "script": "
            .replace(/["']content["']\s*:\s*["']?/gi, '')     // Remove "content": "
            .replace(/["']texto["']\s*:\s*["']?/gi, '')       // Remove "texto": "
            .replace(/["']text["']\s*:\s*["']?/gi, '')        // Remove "text": "
            .replace(/^[^{]*\{/, '')                          // Remove { no in√≠cio
            .replace(/\}[^}]*$/, '')                          // Remove } no final
            .replace(/^[\s\n\r]*["']/, '')                    // Remove " no in√≠cio
            .replace(/["'][\s\n\r]*$/, '')                    // Remove " no final
            .trim();
        
        // 4. Se ainda parece JSON, tentar parsear e extrair
        if (cleanedScript.trim().startsWith('{') || cleanedScript.trim().startsWith('[')) {
            try {
                const parsed = JSON.parse(cleanedScript);
                if (parsed.roteiro) {
                    cleanedScript = typeof parsed.roteiro === 'string' ? parsed.roteiro : JSON.stringify(parsed.roteiro);
                } else if (parsed.script) {
                    cleanedScript = typeof parsed.script === 'string' ? parsed.script : JSON.stringify(parsed.script);
                } else if (parsed.content) {
                    cleanedScript = typeof parsed.content === 'string' ? parsed.content : JSON.stringify(parsed.content);
                } else if (typeof parsed === 'string') {
                    cleanedScript = parsed;
                }
                console.log(`[Script Laozhang] Parseado JSON e extra√≠do conte√∫do`);
            } catch (parseErr) {
                console.warn(`[Script Laozhang] N√£o foi poss√≠vel parsear como JSON, usando texto limpo:`, parseErr.message);
            }
        }
        
        // 5. Limpeza final - remover TODAS as marca√ß√µes para voice over
        cleanedScript = cleanedScript
            // Remover marca√ß√µes de PARTE X com intervalos de tempo (mais agressivo - m√∫ltiplas tentativas)
            .replace(/PARTE\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gi, '') // Remove linha inteira com "PARTE 1 0:00 - 3:00"
            .replace(/Parte\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gi, '') // Remove linha inteira com "Parte 1 0:00 - 3:00"
            .replace(/PARTE\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}/gi, '') // Remove "PARTE 1 0:00 - 3:00" (sem quebra de linha)
            .replace(/Parte\s+\d+.*?\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}/gi, '') // Remove "Parte 1 0:00 - 3:00" (sem quebra de linha)
            .replace(/PARTE\s+\d+.*?(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})/gi, '') // Remove "PARTE 1 0:00 - 3:00" (qualquer varia√ß√£o)
            .replace(/Parte\s+\d+.*?(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})/gi, '') // Remove "Parte 1 0:00 - 3:00" (qualquer varia√ß√£o)
            .replace(/^\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}.*?\n/gmi, '') // Remove linha que come√ßa com "0:00 - 3:00"
            .replace(/^\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2}\s*/gmi, '') // Remove "0:00 - 3:00" no in√≠cio da linha (sem quebra)
            .replace(/PARTE\s+\d+\s*$/gmi, '') // Remove "PARTE 1" sozinho no final da linha
            .replace(/Parte\s+\d+\s*$/gmi, '') // Remove "Parte 1" sozinho no final da linha
            // Remover marca√ß√µes de cenas
            .replace(/^Cena\s+\d+:\s*/gmi, '') // Remove "Cena 1:", "Cena 2:", etc.
            .replace(/^CENA\s+\d+:\s*/gmi, '') // Remove "CENA 1:", "CENA 2:", etc.
            .replace(/^Scene\s+\d+:\s*/gmi, '') // Remove "Scene 1:", "Scene 2:", etc.
            .replace(/^SCENE\s+\d+:\s*/gmi, '') // Remove "SCENE 1:", "SCENE 2:", etc.
            .replace(/^Parte\s+\d+:\s*/gmi, '') // Remove "Parte 1:", "Parte 2:", etc.
            .replace(/^PARTE\s+\d+:\s*/gmi, '') // Remove "PARTE 1:", "PARTE 2:", etc.
            // Remover marca√ß√µes de tempo
            .replace(/\[?\d{1,2}:\d{2}-\d{1,2}:\d{2}\]?\s*/g, '') // Remove [0:00-0:30]
            .replace(/\(\d{1,2}:\d{2}\)\s*/g, '') // Remove (0:30)
            .replace(/^\d{1,2}:\d{2}\s*/gm, '') // Remove 0:30 no in√≠cio da linha
            // Remover t√≠tulos de se√ß√µes em mai√∫sculas
            .replace(/^[A-Z][A-Z\s]+:\s*/gm, '') // Remove t√≠tulos em mai√∫sculas seguidos de dois pontos
            // Limpar aspas
            .replace(/^\s*["']+/, '')  // Remove aspas no in√≠cio
            .replace(/["']+\s*$/, '')  // Remove aspas no final
            // Limpar espa√ßos e quebras excessivas
            .replace(/\n{3,}/g, '\n\n') // Remove m√∫ltiplas quebras de linha
            .replace(/^\s+/gm, '') // Remove espa√ßos no in√≠cio de cada linha
            .replace(/\s+$/gm, '') // Remove espa√ßos no final de cada linha
            .trim();
        
        // 6. Se o script estiver vazio ou muito curto, usar a resposta original
        if (!cleanedScript || cleanedScript.length < 100) {
            console.warn(`[Script Laozhang] Script limpo muito curto (${cleanedScript?.length || 0} chars), usando resposta original`);
            cleanedScript = scriptContent.trim();
        }
        
        console.log(`[Script Laozhang] Script final (primeiros 300 chars):`, cleanedScript.substring(0, 300));
        
        // Validar e expandir roteiro se necess√°rio
        let wordCount = cleanedScript.split(/\s+/).filter(word => word.length > 0).length;
        const expectedWordCount = targetWords;
        const wordCountDifference = Math.abs(wordCount - expectedWordCount);
        const wordCountPercentage = ((wordCount / expectedWordCount) * 100).toFixed(1);
        
        console.log(`[Script Laozhang] Valida√ß√£o de dura√ß√£o:`);
        console.log(`  - Palavras esperadas: ${expectedWordCount} (${scriptDuration} minutos)`);
        console.log(`  - Palavras geradas: ${wordCount}`);
        console.log(`  - Diferen√ßa: ${wordCountDifference} palavras (${wordCountPercentage}% do esperado)`);
        
        // Se o roteiro estiver muito curto (menos de 95% do esperado), expandir
        const minWordCount = Math.floor(expectedWordCount * 0.95); // 95% do esperado como m√≠nimo absoluto
        if (wordCount < minWordCount) {
            const wordsNeeded = minWordCount - wordCount;
            console.warn(`[Script Laozhang] ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CR√çTICO: Roteiro MUITO CURTO! Esperado M√çNIMO: ${minWordCount} palavras, Gerado: ${wordCount} palavras (${wordCountPercentage}%). Faltam ${wordsNeeded} palavras.`);
            console.log(`[Script Laozhang] üîÑ Expandindo roteiro para atingir a dura√ß√£o m√≠nima...`);
            const expansionPrompt = `O roteiro abaixo est√° muito curto. Ele tem ${wordCount} palavras, mas precisa ter PELO MENOS ${minWordCount} palavras para garantir ${scriptDuration} minutos de dura√ß√£o.

ROTEIRO ATUAL:
${cleanedScript.substring(0, 2000)}

INSTRU√á√ïES:
1. EXPANDA o roteiro acima adicionando pelo menos ${wordsNeeded} palavras
2. Mantenha o mesmo estilo, tom e estrutura
3. Adicione mais detalhes, exemplos, explica√ß√µes ou desenvolvimentos
4. N√ÉO altere o in√≠cio ou o final, apenas EXPANDA o conte√∫do do meio
5. ‚ö†Ô∏è CR√çTICO: O roteiro expandido DEVE ter PELO MENOS ${minWordCount} palavras (√© melhor ter mais do que menos)
6. ‚ö†Ô∏è CR√çTICO: Conte as palavras antes de finalizar. O roteiro DEVE ter PELO MENOS ${minWordCount} palavras
7. Retorne APENAS o roteiro expandido em texto simples, SEM JSON, SEM markdown, SEM marca√ß√µes de parte ou tempo

ROTEIRO EXPANDIDO:`;

            try {
                const expansionResponse = await callLaozhangAPI(
                    expansionPrompt,
                    laozhangApiKey,
                    laozhangModel,
                    null,
                    userId,
                    'api_script_agents_generate',
                    JSON.stringify({ endpoint: '/api/script-agents/:agentId/generate/laozhang', model: laozhangModel, action: 'expand' })
                );
                
                let expandedScript = typeof expansionResponse === 'string' ? expansionResponse.trim() : JSON.stringify(expansionResponse);
                
                // Limpar o roteiro expandido da mesma forma
                expandedScript = expandedScript
                    .replace(/```[\s\S]*?```/g, '')
                    .replace(/```json[\s\S]*?```/gi, '')
                    .replace(/\{[\s\S]*?"roteiro"[\s\S]*?\}/g, '')
                    .replace(/"roteiro"\s*:\s*"([^"]+)"/gi, '$1')
                    .replace(/\{[\s\S]*\}/g, '')
                    .trim();
                
                const expandedWordCount = expandedScript.split(/\s+/).filter(word => word.length > 0).length;
                
                if (expandedWordCount >= expectedWordCount * 0.8) {
                    cleanedScript = expandedScript;
                    wordCount = expandedWordCount;
                    console.log(`[Script Laozhang] ‚úÖ Roteiro expandido com sucesso! Nova contagem: ${wordCount} palavras (${((wordCount / expectedWordCount) * 100).toFixed(1)}%)`);
                } else {
                    console.warn(`[Script Laozhang] ‚ö†Ô∏è Expans√£o n√£o foi suficiente. Mantendo roteiro original.`);
                }
            } catch (expandErr) {
                console.error(`[Script Laozhang] Erro ao expandir roteiro:`, expandErr);
                console.warn(`[Script Laozhang] Mantendo roteiro original apesar de estar curto.`);
            }
        } else if (wordCount > expectedWordCount * 1.3) {
            console.warn(`[Script Laozhang] ‚ö†Ô∏è ATEN√á√ÉO: Roteiro muito longo! Esperado: ${expectedWordCount} palavras, Gerado: ${wordCount} palavras (${wordCountPercentage}%)`);
        } else {
            console.log(`[Script Laozhang] ‚úÖ Dura√ß√£o do roteiro est√° dentro do esperado (${wordCountPercentage}%)`);
        }

        // Salvar roteiro no banco
        // Verificar se as colunas duration_minutes e language existem
        let columnsToInsert = ['user_id', 'script_agent_id', 'title', 'script_content', 'model_used', 'niche', 'subniche'];
        // Limpar nome do modelo para salvar (sem prefixo de fornecedor)
        const cleanModelForSave = (model) => {
            if (!model) return 'GPT-4o';
            // Remover prefixos e mapear para nomes amig√°veis
            let clean = model.replace(/^(laozhang-|claude-|gemini-|gpt-)/i, '');
            if (clean.includes('gpt-4o')) return 'GPT-4o';
            if (clean.includes('claude-3-7-sonnet') || clean.includes('sonnet-3-7')) return 'Claude 3.7 Sonnet';
            if (clean.includes('claude-sonnet-4') || clean.includes('sonnet-4')) return 'Claude Sonnet 4';
            if (clean.includes('gemini-2.5-pro')) return 'Gemini 2.5 Pro';
            return clean || 'GPT-4o';
        };
        let valuesToInsert = [userId, agentId, title, cleanedScript, cleanModelForSave(laozhangModel), agent.niche, agent.subniche];
        
        try {
            // Tentar verificar se as colunas existem
            const tableInfo = await db.all(`PRAGMA table_info(generated_scripts)`);
            const columnNames = tableInfo.map(col => col.name);
            
            if (columnNames.includes('duration_minutes')) {
                columnsToInsert.push('duration_minutes');
                valuesToInsert.push(scriptDuration);
            }
            if (columnNames.includes('language')) {
                columnsToInsert.push('language');
                valuesToInsert.push(scriptLanguage);
            }
        } catch (pragmaErr) {
            console.warn('[Script Laozhang] Erro ao verificar colunas, usando apenas colunas b√°sicas:', pragmaErr.message);
        }
        
        const result = await db.run(
            `INSERT INTO generated_scripts (${columnsToInsert.join(', ')})
             VALUES (${columnsToInsert.map(() => '?').join(', ')})`,
            valuesToInsert
        );

        // Enviar progresso final
        if (sessionId) {
            sendProgress(sessionId, {
                stage: 'completed',
                progress: 100,
                message: 'Roteiro gerado com sucesso!',
                details: { completed: true, scriptId: result.lastID }
            });
        }

        res.status(200).json({
            msg: 'Roteiro gerado com sucesso!',
            scriptId: result.lastID,
            script: cleanedScript
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId/generate/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar roteiro.' });
    }
});

// Rota para atualizar um agente
app.put('/api/script-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { agentName, niche, subniche, agentPrompt, agentInstructions } = req.body;
    const userId = req.user.id;

    try {
        const agent = await db.get(
            `SELECT id FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }

        const updates = [];
        const values = [];

        if (agentName !== undefined) {
            updates.push('agent_name = ?');
            values.push(agentName);
        }
        if (niche !== undefined) {
            updates.push('niche = ?');
            values.push(niche);
        }
        if (subniche !== undefined) {
            updates.push('subniche = ?');
            values.push(subniche);
        }
        if (agentPrompt !== undefined) {
            updates.push('agent_prompt = ?');
            values.push(agentPrompt);
        }
        if (agentInstructions !== undefined) {
            updates.push('agent_instructions = ?');
            values.push(agentInstructions);
        }

        if (updates.length === 0) {
            return res.status(400).json({ msg: 'Nenhum campo para atualizar.' });
        }

        updates.push('updated_at = CURRENT_TIMESTAMP');
        values.push(agentId);

        await db.run(
            `UPDATE script_agents SET ${updates.join(', ')} WHERE id = ?`,
            values
        );

        res.status(200).json({ msg: 'Agente atualizado com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId PUT]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar agente.' });
    }
});
// Rota para deletar um agente
app.delete('/api/script-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        const result = await db.run(
            `DELETE FROM script_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }

        res.status(200).json({ msg: 'Agente deletado com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/script-agents/:agentId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao deletar agente.' });
    }
});

// Rota para listar roteiros gerados
app.get('/api/scripts', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { agentId } = req.query;

    try {
        let scripts;
        if (agentId) {
            scripts = await db.all(
                `SELECT gs.*, sa.agent_name
                 FROM generated_scripts gs
                 LEFT JOIN script_agents sa ON gs.script_agent_id = sa.id
                 WHERE gs.user_id = ? AND gs.script_agent_id = ?
                 ORDER BY gs.created_at DESC`,
                [userId, agentId]
            );
        } else {
            scripts = await db.all(
                `SELECT gs.*, sa.agent_name
                 FROM generated_scripts gs
                 LEFT JOIN script_agents sa ON gs.script_agent_id = sa.id
                 WHERE gs.user_id = ?
                 ORDER BY gs.created_at DESC`,
                [userId]
            );
        }

        res.status(200).json({ scripts });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts]:', err);
        res.status(500).json({ msg: 'Erro ao listar roteiros.' });
    }
});

// Rota para obter um roteiro espec√≠fico
app.get('/api/scripts/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scriptId = req.params.id;

    try {
        const script = await db.get(
            `SELECT gs.*, sa.agent_name
             FROM generated_scripts gs
             LEFT JOIN script_agents sa ON gs.script_agent_id = sa.id
             WHERE gs.id = ? AND gs.user_id = ?`,
            [scriptId, userId]
        );

        if (!script) {
            return res.status(404).json({ msg: 'Roteiro n√£o encontrado.' });
        }

        res.json({ script });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts/:id]:', err);
        res.status(500).json({ msg: 'Erro ao obter roteiro.' });
    }
});

// Rota para deletar um roteiro
app.delete('/api/scripts/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scriptId = req.params.id;

    try {
        const result = await db.run(
            `DELETE FROM generated_scripts WHERE id = ? AND user_id = ?`,
            [scriptId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Roteiro n√£o encontrado.' });
        }

        res.json({ msg: 'Roteiro exclu√≠do com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir roteiro.' });
    }
});

// ==================== ROTAS PARA AGENTES VIRAIS ====================

// Rota para criar um agente viral
app.post('/api/viral-agents', authenticateToken, async (req, res) => {
    const { name, description, memory, instructions, model } = req.body;
    const userId = req.user.id;

    if (!name || name.trim().length === 0) {
        return res.status(400).json({ msg: 'Nome do agente √© obrigat√≥rio.' });
    }

    try {
        const result = await db.run(
            `INSERT INTO viral_agents (user_id, name, description, memory, instructions, model)
             VALUES (?, ?, ?, ?, ?, ?)`,
            [userId, name.trim(), description || null, memory || null, instructions || null, model || 'gpt-4o']
        );

        const newAgent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ?`,
            [result.lastID]
        );

        res.status(201).json({
            msg: 'Agente viral criado com sucesso!',
            agent: newAgent
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents POST]:', err);
        res.status(500).json({ msg: 'Erro ao criar agente viral.' });
    }
});

// Rota para listar todos os agentes virais do usu√°rio
app.get('/api/viral-agents', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const agents = await db.all(
            `SELECT va.*, 
                    COUNT(DISTINCT vaf.id) as file_count,
                    COUNT(DISTINCT vac.id) as conversation_count
             FROM viral_agents va
             LEFT JOIN viral_agent_files vaf ON va.id = vaf.agent_id
             LEFT JOIN viral_agent_conversations vac ON va.id = vac.agent_id
             WHERE va.user_id = ?
             GROUP BY va.id
             ORDER BY va.is_favorite DESC, va.updated_at DESC`,
            [userId]
        );

        res.status(200).json({ agents });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents GET]:', err);
        res.status(500).json({ msg: 'Erro ao listar agentes virais.' });
    }
});

// Rota para obter um agente viral espec√≠fico
app.get('/api/viral-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        const agent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }

        // Buscar arquivos do agente
        const files = await db.all(
            `SELECT * FROM viral_agent_files WHERE agent_id = ? ORDER BY created_at DESC`,
            [agentId]
        );

        // Buscar conversas do agente
        const conversations = await db.all(
            `SELECT * FROM viral_agent_conversations 
             WHERE agent_id = ? AND user_id = ? 
             ORDER BY updated_at DESC`,
            [agentId, userId]
        );

        res.status(200).json({
            agent: {
                ...agent,
                files,
                conversations
            }
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId GET]:', err);
        res.status(500).json({ msg: 'Erro ao obter agente viral.' });
    }
});

// Rota para atualizar um agente viral
app.put('/api/viral-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { name, description, memory, instructions, is_favorite, model, formula_json, niche, subniche, agent_prompt } = req.body;
    const userId = req.user.id;

    try {
        const agent = await db.get(
            `SELECT id FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }

        const updates = [];
        const values = [];

        if (name !== undefined) {
            updates.push('name = ?');
            values.push(name.trim());
        }
        if (description !== undefined) {
            updates.push('description = ?');
            values.push(description);
        }
        if (memory !== undefined) {
            updates.push('memory = ?');
            values.push(memory);
        }
        if (instructions !== undefined) {
            updates.push('instructions = ?');
            values.push(instructions);
        }
        if (model !== undefined) {
            updates.push('model = ?');
            values.push(model);
        }
        if (is_favorite !== undefined) {
            updates.push('is_favorite = ?');
            values.push(is_favorite ? 1 : 0);
        }
        if (formula_json !== undefined) {
            updates.push('formula_json = ?');
            values.push(typeof formula_json === 'object' ? JSON.stringify(formula_json) : formula_json);
        }
        if (niche !== undefined) {
            updates.push('niche = ?');
            values.push(niche);
        }
        if (subniche !== undefined) {
            updates.push('subniche = ?');
            values.push(subniche);
        }
        if (agent_prompt !== undefined) {
            updates.push('agent_prompt = ?');
            values.push(agent_prompt);
        }

        if (updates.length === 0) {
            return res.status(400).json({ msg: 'Nenhum campo para atualizar.' });
        }

        updates.push('updated_at = CURRENT_TIMESTAMP');
        values.push(agentId);

        await db.run(
            `UPDATE viral_agents SET ${updates.join(', ')} WHERE id = ?`,
            values
        );

        const updatedAgent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ?`,
            [agentId]
        );

        res.status(200).json({
            msg: 'Agente atualizado com sucesso!',
            agent: updatedAgent
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId PUT]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar agente viral.' });
    }
});

// Rota para deletar um agente viral
app.delete('/api/viral-agents/:agentId', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        const result = await db.run(
            `DELETE FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }

        res.status(200).json({ msg: 'Agente deletado com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao deletar agente viral.' });
    }
});

// Rota para adicionar arquivo a um agente viral
app.post('/api/viral-agents/:agentId/files', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { file_name, file_content, file_type, file_size } = req.body;
    const userId = req.user.id;

    if (!file_name || !file_content) {
        return res.status(400).json({ msg: 'Nome e conte√∫do do arquivo s√£o obrigat√≥rios.' });
    }

    try {
        // Verificar se o agente pertence ao usu√°rio
        const agent = await db.get(
            `SELECT id FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }

        const result = await db.run(
            `INSERT INTO viral_agent_files (agent_id, file_name, file_content, file_type, file_size)
             VALUES (?, ?, ?, ?, ?)`,
            [agentId, file_name, file_content, file_type || 'text/plain', file_size || file_content.length]
        );

        const newFile = await db.get(
            `SELECT * FROM viral_agent_files WHERE id = ?`,
            [result.lastID]
        );

        res.status(201).json({
            msg: 'Arquivo adicionado com sucesso!',
            file: newFile
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/files POST]:', err);
        res.status(500).json({ msg: 'Erro ao adicionar arquivo.' });
    }
});

// Rota para listar arquivos de um agente viral
app.get('/api/viral-agents/:agentId/files', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const userId = req.user.id;

    try {
        // Verificar se o agente pertence ao usu√°rio
        const agent = await db.get(
            `SELECT id FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }

        const files = await db.all(
            `SELECT * FROM viral_agent_files WHERE agent_id = ? ORDER BY created_at DESC`,
            [agentId]
        );

        res.status(200).json({ files });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/files GET]:', err);
        res.status(500).json({ msg: 'Erro ao listar arquivos.' });
    }
});

// Rota para deletar arquivo de um agente viral
app.delete('/api/viral-agents/:agentId/files/:fileId', authenticateToken, async (req, res) => {
    const { agentId, fileId } = req.params;
    const userId = req.user.id;

    try {
        // Verificar se o agente pertence ao usu√°rio
        const agent = await db.get(
            `SELECT id FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }

        const result = await db.run(
            `DELETE FROM viral_agent_files WHERE id = ? AND agent_id = ?`,
            [fileId, agentId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Arquivo n√£o encontrado.' });
        }

        res.status(200).json({ msg: 'Arquivo deletado com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/files/:fileId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao deletar arquivo.' });
    }
});

// Rota para criar uma nova conversa com um agente viral
app.post('/api/viral-agents/:agentId/conversations', authenticateToken, async (req, res) => {
    const { agentId } = req.params;
    const { title } = req.body;
    const userId = req.user.id;

    try {
        // Verificar se o agente pertence ao usu√°rio
        const agent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }

        const result = await db.run(
            `INSERT INTO viral_agent_conversations (agent_id, user_id, title)
             VALUES (?, ?, ?)`,
            [agentId, userId, title || 'Nova Conversa']
        );

        const newConversation = await db.get(
            `SELECT * FROM viral_agent_conversations WHERE id = ?`,
            [result.lastID]
        );

        res.status(201).json({
            msg: 'Conversa criada com sucesso!',
            conversation: newConversation
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/conversations POST]:', err);
        res.status(500).json({ msg: 'Erro ao criar conversa.' });
    }
});

// Rota para enviar mensagem para um agente viral (chat) - COM STREAMING
// Fun√ß√£o helper para remover avalia√ß√£o do roteiro e extrair nota/checklist
function removeAvaliacaoFromRoteiro(roteiroTexto) {
    let nota = null;
    let checklist = null;
    let roteiroFinal = roteiroTexto ? roteiroTexto.trim() : '';
    
    if (!roteiroFinal) {
        return { roteiroFinal: '', nota: null, checklist: null };
    }
    
    // Remover a se√ß√£o completa de avalia√ß√£o (texto + JSON)
    const avaliacaoRegex = /#\s*üìä\s*AVALIA√á√ÉO\s*DO\s*ROTEIRO[\s\S]*$/i;
    if (avaliacaoRegex.test(roteiroFinal)) {
        // Encontrar onde come√ßa a avalia√ß√£o
        const avaliacaoIndex = roteiroFinal.search(avaliacaoRegex);
        if (avaliacaoIndex !== -1) {
            // Extrair JSON da avalia√ß√£o antes de remover
            const parteAvaliacao = roteiroFinal.substring(avaliacaoIndex);
            const jsonMatch = parteAvaliacao.match(/\{[\s\S]*"nota"[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    const avaliacao = JSON.parse(jsonMatch[0]);
                    nota = avaliacao.nota;
                    checklist = avaliacao.checklist || null;
                } catch (e) {
                    // Tentar extrair nota do texto
                    const notaMatch = parteAvaliacao.match(/nota[:\s]*(\d+)\/10/i);
                    if (notaMatch) {
                        nota = parseInt(notaMatch[1]);
                    }
                }
            } else {
                // Tentar extrair nota do texto se n√£o houver JSON
                const notaMatch = parteAvaliacao.match(/nota[:\s]*(\d+)\/10/i);
                if (notaMatch) {
                    nota = parseInt(notaMatch[1]);
                }
            }
            // Remover toda a se√ß√£o de avalia√ß√£o
            roteiroFinal = roteiroFinal.substring(0, avaliacaoIndex).trim();
        }
    } else {
        // Se n√£o encontrar a se√ß√£o completa, tentar remover apenas o JSON
        const jsonMatch = roteiroFinal.match(/\{[\s\S]*"nota"[\s\S]*\}/);
        if (jsonMatch) {
            try {
                const avaliacao = JSON.parse(jsonMatch[0]);
                nota = avaliacao.nota;
                checklist = avaliacao.checklist || null;
                roteiroFinal = roteiroFinal.replace(/\{[\s\S]*"nota"[\s\S]*\}/, '').trim();
            } catch (e) {
                const notaMatch = roteiroFinal.match(/nota[:\s]*(\d+)\/10/i);
                if (notaMatch) {
                    nota = parseInt(notaMatch[1]);
                    roteiroFinal = roteiroFinal.replace(/nota[:\s]*\d+\/10[\s\S]*/i, '').trim();
                }
            }
        }
    }
    
    // Remover tamb√©m qualquer texto relacionado √† avalia√ß√£o que possa ter ficado
    roteiroFinal = roteiroFinal.replace(/An√°lise da Avalia√ß√£o:[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/Pontos Fortes:[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/√Årea de Melhoria:[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/GANCHO INICIAL[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/ESTRUTURA NARRATIVA[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/ENGAJAMENTO EMOCIONAL[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/DENSIDADE DE VALOR[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/T√âCNICAS DE RETEN√á√ÉO[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/LINGUAGEM E TOM[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/ELEMENTOS ESTRUTURAIS[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/LOOPS ABERTOS[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/VARIA√á√ÉO EMOCIONAL[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/FINAL SATISFAT√ìRIO[\s\S]*$/i, '').trim();
    roteiroFinal = roteiroFinal.replace(/```json[\s\S]*?```/gi, '').trim();
    
    return { roteiroFinal, nota, checklist };
}

app.post('/api/viral-agents/:agentId/chat', authenticateToken, async (req, res) => {
        const { agentId } = req.params;
        const { conversation_id, message, model: requestModel, stream = true } = req.body;
        const userId = req.user.id;

    if (!message || !conversation_id) {
        return res.status(400).json({ msg: 'Mensagem e ID da conversa s√£o obrigat√≥rios.' });
    }

    try {
        // Verificar se o agente pertence ao usu√°rio
        const agent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }
        
        // Usar modelo do agente ou o modelo da requisi√ß√£o
        const modelToUse = requestModel || agent.model || 'gpt-4o';

        // Verificar se a conversa pertence ao usu√°rio e ao agente
        const conversation = await db.get(
            `SELECT * FROM viral_agent_conversations 
             WHERE id = ? AND agent_id = ? AND user_id = ?`,
            [conversation_id, agentId, userId]
        );

        if (!conversation) {
            return res.status(404).json({ msg: 'Conversa n√£o encontrada.' });
        }

        // Salvar mensagem do usu√°rio
        await db.run(
            `INSERT INTO viral_agent_messages (conversation_id, role, content)
             VALUES (?, ?, ?)`,
            [conversation_id, 'user', message]
        );

        // Buscar hist√≥rico de mensagens da conversa
        const messageHistory = await db.all(
            `SELECT role, content FROM viral_agent_messages 
             WHERE conversation_id = ? 
             ORDER BY created_at ASC`,
            [conversation_id]
        );

        // Buscar arquivos do agente
        const agentFiles = await db.all(
            `SELECT file_name, file_content FROM viral_agent_files WHERE agent_id = ?`,
            [agentId]
        );

        // Preparar contexto para o Claude (CR√çTICO: sempre incluir mem√≥ria e instru√ß√µes)
        // FORMATO RIGOROSO: Priorizar instru√ß√µes e mem√≥ria de forma clara e enf√°tica
        let systemPrompt = '';
        
        // IN√çCIO: Instru√ß√£o cr√≠tica para seguir as configura√ß√µes
        systemPrompt += `# ‚ö†Ô∏è INSTRU√á√ïES CR√çTICAS - SIGA RIGOROSAMENTE\n\n`;
        systemPrompt += `Voc√™ √© um agente especializado que DEVE seguir EXATAMENTE as instru√ß√µes e mem√≥ria configuradas abaixo.\n`;
        systemPrompt += `N√ÉO invente ou ignore essas configura√ß√µes. Elas definem seu comportamento e conhecimento.\n\n`;
        
        // MEM√ìRIA PRIMEIRO (contexto sobre o usu√°rio/agente)
        if (agent.memory && agent.memory.trim()) {
            systemPrompt += `# üìù MEM√ìRIA DO AGENTE (CONTEXTO OBRIGAT√ìRIO)\n`;
            systemPrompt += `A seguir est√° a mem√≥ria configurada para este agente. Use essas informa√ß√µes para personalizar suas respostas:\n\n`;
            systemPrompt += `${agent.memory}\n\n`;
            systemPrompt += `---\n\n`;
            console.log('[Viral Agents] ‚úÖ Mem√≥ria inclu√≠da, tamanho:', agent.memory.length);
        } else {
            console.warn('[Viral Agents] ‚ö†Ô∏è Mem√≥ria vazia ou n√£o definida');
        }
        
        // INSTRU√á√ïES (comportamento e formato)
        if (agent.instructions && agent.instructions.trim()) {
            systemPrompt += `# üéØ INSTRU√á√ïES DO AGENTE (SEGUIR OBRIGATORIAMENTE)\n`;
            systemPrompt += `As instru√ß√µes abaixo definem COMO voc√™ deve se comportar e QUAIS regras seguir:\n\n`;
            systemPrompt += `${agent.instructions}\n\n`;
            systemPrompt += `---\n\n`;
            console.log('[Viral Agents] ‚úÖ Instru√ß√µes inclu√≠das, tamanho:', agent.instructions.length);
        } else {
            console.warn('[Viral Agents] ‚ö†Ô∏è Instru√ß√µes vazias ou n√£o definidas');
        }
        
        // ARQUIVOS (refer√™ncias adicionais)
        if (agentFiles.length > 0) {
            systemPrompt += `# üìé ARQUIVOS DISPON√çVEIS (REFER√äNCIA)\n`;
            systemPrompt += `Use os arquivos abaixo como refer√™ncia adicional quando relevante:\n\n`;
            agentFiles.forEach(file => {
                systemPrompt += `## ${file.file_name}\n${file.file_content}\n\n`;
            });
            systemPrompt += `---\n\n`;
            console.log('[Viral Agents] ‚úÖ Arquivos inclu√≠dos:', agentFiles.length);
        }
        
        // RELEMBRAR: Seguir as configura√ß√µes
        systemPrompt += `# ‚ö†Ô∏è LEMBRETE FINAL\n`;
        systemPrompt += `- Use a MEM√ìRIA para personalizar suas respostas ao contexto do usu√°rio\n`;
        systemPrompt += `- Siga as INSTRU√á√ïES rigorosamente para manter consist√™ncia\n`;
        systemPrompt += `- Se as instru√ß√µes pedirem um formato espec√≠fico, use EXATAMENTE esse formato\n`;
        systemPrompt += `- Se a mem√≥ria descrever o prop√≥sito do agente, mantenha esse prop√≥sito em todas as respostas\n\n`;
        
        // INSTRU√á√ÉO CR√çTICA: Gerar roteiro completo (SEM avalia√ß√£o)
        systemPrompt += `# üé¨ INSTRU√á√ÉO FINAL - CR√çTICA\n\n`;
        systemPrompt += `VOC√ä DEVE:\n`;
        systemPrompt += `1. Seguir RIGOROSAMENTE as INSTRU√á√ïES e MEM√ìRIA configuradas acima\n`;
        systemPrompt += `2. Gerar um ROTEIRO COMPLETO baseado na mensagem do usu√°rio\n`;
        systemPrompt += `3. O roteiro deve ser detalhado, completo e seguir o formato especificado nas instru√ß√µes\n`;
        systemPrompt += `4. N√ÉO pare no meio do roteiro - complete TODA a hist√≥ria at√© o final\n`;
        systemPrompt += `5. N√ÉO corte o roteiro - continue at√© concluir completamente a narrativa\n`;
        systemPrompt += `6. Use a mem√≥ria para personalizar o roteiro ao contexto do usu√°rio\n`;
        systemPrompt += `7. N√ÉO inclua avalia√ß√µes, an√°lises ou coment√°rios sobre o roteiro - apenas o roteiro em si\n`;
        systemPrompt += `8. Se o roteiro for longo, continue escrevendo at√© o final - N√ÉO pare antes de concluir\n\n`;
        systemPrompt += `IMPORTANTE: Se as instru√ß√µes pedirem um formato espec√≠fico de roteiro, use EXATAMENTE esse formato.\n`;
        systemPrompt += `Se a mem√≥ria descrever o prop√≥sito do agente, mantenha esse prop√≥sito ao gerar o roteiro.\n`;
        systemPrompt += `CR√çTICO: Voc√™ tem at√© 16384 tokens dispon√≠veis. Use TODOS se necess√°rio para completar o roteiro.\n`;
        systemPrompt += `N√ÉO pare no meio - continue at√© o final completo do roteiro.\n\n`;

        // Verificar prefer√™ncia do usu√°rio: usar cr√©ditos (laozhang.ai) ou APIs pr√≥prias
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;
        
        console.log('[Viral Agents] Prefer√™ncia do usu√°rio:', { userId, useCredits, userPrefs });
        
        let useLaozhang = false;
        let laozhangApiKey = null;
        
        // REGRA CR√çTICA: Se prefer√™ncia marcada, SEMPRE usar Laozhang (cr√©ditos)
        if (useCredits) {
            // Buscar chave da laozhang.ai usando a fun√ß√£o existente
            const laozhangKey = await getLaozhangApiKey();
            console.log('[Viral Agents] Chave Laozhang encontrada:', laozhangKey ? 'Sim' : 'N√£o', typeof laozhangKey);
            
            if (laozhangKey) {
                // Normalizar a chave (j√° vem normalizada da fun√ß√£o, mas garantir)
                if (typeof laozhangKey === 'string') {
                    laozhangApiKey = laozhangKey.trim();
                } else if (typeof laozhangKey === 'object' && laozhangKey !== null) {
                    // Se ainda for objeto, extrair api_key
                    laozhangApiKey = (laozhangKey.api_key || laozhangKey.key || JSON.stringify(laozhangKey)).trim();
                } else {
                    laozhangApiKey = String(laozhangKey).trim();
                }
                
                console.log('[Viral Agents] Chave Laozhang normalizada:', laozhangApiKey ? `Sim (${laozhangApiKey.length} chars)` : 'N√£o');
                
                if (laozhangApiKey && laozhangApiKey.length > 10) {
                    useLaozhang = true;
                    console.log('[Viral Agents] ‚úÖ Usando Laozhang.ai (prefer√™ncia: usar cr√©ditos) com modelo:', modelToUse);
                } else {
                    console.error('[Viral Agents] ‚ùå Chave Laozhang inv√°lida ou muito curta. Tamanho:', laozhangApiKey?.length || 0);
                    return res.status(500).json({ 
                        msg: 'Chave da API Laozhang.ai n√£o configurada ou inv√°lida. Configure no painel admin.' 
                    });
                }
            } else {
                console.error('[Viral Agents] ‚ùå Chave Laozhang n√£o encontrada, mesmo com prefer√™ncia marcada');
                return res.status(500).json({ 
                    msg: 'Chave da API Laozhang.ai n√£o configurada. Configure no painel admin ou desmarque a prefer√™ncia de usar cr√©ditos.' 
                });
            }
        } else {
            console.log('[Viral Agents] Prefer√™ncia n√£o marcada, verificando se deve usar cr√©ditos por falta de API pr√≥pria...');
            // Mesmo sem prefer√™ncia marcada, verificar se deve usar cr√©ditos (sem API pr√≥pria)
            const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
            if (creditsCheck.shouldUse && !creditsCheck.hasOwnApi) {
                console.log('[Viral Agents] ‚úÖ Usando cr√©ditos (sem API pr√≥pria configurada)');
                const laozhangKey = await getLaozhangApiKey();
                if (laozhangKey) {
                    laozhangApiKey = typeof laozhangKey === 'string' ? laozhangKey.trim() : String(laozhangKey).trim();
                    if (laozhangApiKey && laozhangApiKey.length > 10) {
                        useLaozhang = true;
                    }
                }
            }
        }
        
        // Se n√£o usar laozhang, determinar qual servi√ßo usar baseado no modelo
        let serviceName = 'claude';
        if (!useLaozhang) {
            if (modelToUse && (modelToUse.includes('gpt') || modelToUse.includes('GPT'))) {
                serviceName = 'openai';
            } else if (modelToUse && modelToUse.includes('gemini')) {
                serviceName = 'gemini';
            }

            // Buscar API key do servi√ßo apropriado
            const apiKeyRow = await db.get(
                'SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?',
                [userId, serviceName]
            );

            if (!apiKeyRow || !apiKeyRow.api_key) {
                return res.status(400).json({ msg: `API key do ${serviceName === 'openai' ? 'OpenAI' : serviceName === 'gemini' ? 'Gemini' : 'Claude'} n√£o configurada. Configure nas configura√ß√µes.` });
            }

            var apiKey = decrypt(apiKeyRow.api_key);
            if (!apiKey) {
                return res.status(500).json({ msg: 'Erro ao descriptografar API key.' });
            }
        }

        // Preparar mensagens
        const messages = [];
        
        // Adicionar hist√≥rico de mensagens (apenas user e assistant)
        messageHistory.forEach(msg => {
            if (msg.role === 'user' || msg.role === 'assistant') {
                messages.push({
                    role: msg.role,
                    content: msg.content
                });
            }
        });

        let assistantMessage = '';
        
        // Preparar prompt completo para laozhang (usado tanto em streaming quanto n√£o-streaming)
        // IMPORTANTE: Incluir systemPrompt de forma enf√°tica no in√≠cio
        let fullPrompt = '';
        if (useLaozhang && laozhangApiKey) {
            // Come√ßar com systemPrompt (mem√≥ria + instru√ß√µes) de forma muito clara
            if (systemPrompt && systemPrompt.trim()) {
                fullPrompt = `=== CONFIGURA√á√ïES DO AGENTE (SEGUIR RIGOROSAMENTE) ===\n\n${systemPrompt}\n\n=== FIM DAS CONFIGURA√á√ïES ===\n\n`;
            } else {
                fullPrompt = 'Voc√™ √© um assistente √∫til.\n\n';
            }
            
            // Adicionar hist√≥rico de conversa
            if (messages.length > 0) {
                fullPrompt += `=== HIST√ìRICO DA CONVERSA ===\n\n`;
                messages.forEach(msg => {
                    fullPrompt += `${msg.role === 'user' ? 'Usu√°rio' : 'Assistente'}: ${msg.content}\n\n`;
                });
                fullPrompt += `=== FIM DO HIST√ìRICO ===\n\n`;
            }
            
            // Adicionar mensagem atual com instru√ß√£o clara
            fullPrompt += `=== MENSAGEM ATUAL DO USU√ÅRIO ===\n\n`;
            fullPrompt += `Usu√°rio: ${message}\n\n`;
            fullPrompt += `=== SUA RESPOSTA (SEGUINDO AS CONFIGURA√á√ïES ACIMA) ===\n\n`;
            fullPrompt += `INSTRU√á√ïES PARA SUA RESPOSTA:\n`;
            fullPrompt += `1. Siga RIGOROSAMENTE as CONFIGURA√á√ïES DO AGENTE acima (mem√≥ria e instru√ß√µes)\n`;
            fullPrompt += `2. Gere um ROTEIRO COMPLETO baseado na mensagem do usu√°rio\n`;
            fullPrompt += `3. O roteiro deve ser detalhado e seguir o formato especificado nas instru√ß√µes\n`;
            fullPrompt += `4. N√ÉO pare no meio - complete TODA a hist√≥ria/roteiro at√© o final\n`;
            fullPrompt += `5. N√ÉO corte o roteiro - continue escrevendo at√© concluir completamente\n`;
            fullPrompt += `6. Use a mem√≥ria para personalizar o roteiro ao contexto\n`;
            fullPrompt += `7. N√ÉO inclua avalia√ß√µes, an√°lises ou coment√°rios - apenas o roteiro em si\n`;
            fullPrompt += `8. Voc√™ tem at√© 16384 tokens dispon√≠veis - use TODOS se necess√°rio para completar o roteiro\n\n`;
            fullPrompt += `Agora gere sua resposta seguindo essas instru√ß√µes:\n\n`;
            fullPrompt += `Assistente:`;
            
            console.log('[Viral Agents] üìã FullPrompt constru√≠do, tamanho:', fullPrompt.length);
            console.log('[Viral Agents] üìã Primeiros 500 chars do fullPrompt:', fullPrompt.substring(0, 500));
        }

        // Se usar laozhang.ai, chamar API laozhang
        if (useLaozhang && laozhangApiKey) {
            console.log('[Viral Agents] üöÄ Iniciando chamada Laozhang.ai com modelo:', modelToUse, 'Stream:', stream);
            
            if (stream) {
                // Streaming com laozhang (usar endpoint direto com streaming)
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                
                try {
                    // Mapear modelo para formato laozhang (manter o mesmo formato)
                    const laozhangModel = modelToUse || 'gpt-4o';
                    console.log('[Viral Agents] üìù Modelo Laozhang:', laozhangModel);
                    
                    // Preparar mensagens para c√°lculo de tokens (CR√çTICO: sempre incluir systemPrompt com mem√≥ria e instru√ß√µes)
                    const systemContent = systemPrompt && systemPrompt.trim() ? systemPrompt : 'Voc√™ √© um assistente √∫til.';
                    console.log('[Viral Agents] üìã System content inclu√≠do no streaming, tamanho:', systemContent.length);
                    const allMessages = [
                        { role: 'system', content: systemContent },
                        ...messages,
                        { role: 'user', content: message }
                    ];
                    
                    // Calcular tokens aproximados (input + output estimado)
                    const promptText = allMessages.map(m => m.content).join('\n');
                    const promptTokens = Math.ceil(promptText.length / 4);
                    // Estimativa para roteiros: baseado no max_tokens configurado (16384)
                    // Usar 80% do max_tokens como estimativa conservadora
                    const estimatedOutputTokens = Math.ceil(16384 * 0.8);
                    const totalTokens = promptTokens + estimatedOutputTokens;
                    
                    console.log('[Viral Agents] üí∞ Calculando cr√©ditos:', {
                        promptTokens,
                        estimatedOutputTokens,
                        totalTokens
                    });
                    
                    // Debitar cr√©ditos ANTES da chamada
                    let creditDebitResult = null;
                    try {
                        const laozhangProviderId = await getLaozhangApiProviderId();
                        if (laozhangProviderId) {
                            creditDebitResult = await checkAndDebitCredits(
                                userId,
                                laozhangProviderId,
                                totalTokens,
                                'viral_agent_chat',
                                JSON.stringify({ agent_id: agentId, conversation_id: conversation_id, model: laozhangModel, stream: true })
                            );
                            console.log(`[Viral Agents] üí∞ Cr√©ditos debitados: ${creditDebitResult.creditsUsed.toFixed(4)}, Novo saldo: ${creditDebitResult.newBalance.toFixed(4)}`);
                        } else {
                            console.warn('[Viral Agents] ‚ö†Ô∏è Provider Laozhang n√£o encontrado, pulando d√©bito de cr√©ditos');
                        }
                    } catch (creditError) {
                        console.error('[Viral Agents] ‚ùå Erro ao debitar cr√©ditos:', creditError.message);
                        // Se n√£o tiver cr√©ditos suficientes, lan√ßar erro
                        if (creditError.message.includes('Cr√©ditos insuficientes')) {
                            res.write(`data: ${JSON.stringify({ error: creditError.message })}\n\n`);
                            res.end();
                            return;
                        }
                        // Se for outro erro, continuar mas logar
                    }
                    
                    const payload = {
                        model: laozhangModel,
                        messages: allMessages,
                        temperature: 0.7,
                        max_tokens: 16384, // Aumentado para permitir roteiros mais longos
                        stream: true
                    };
                    
                    console.log('[Viral Agents] üì§ Enviando requisi√ß√£o para Laozhang.ai:', {
                        endpoint: LAOZHANG_CHAT_ENDPOINT,
                        model: laozhangModel,
                        messages_count: payload.messages.length,
                        system_prompt_length: systemPrompt?.length || 0
                    });
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 300000);
                    
                    const response = await fetch(LAOZHANG_CHAT_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${laozhangApiKey}`,
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });
                    
                    console.log('[Viral Agents] üì• Resposta Laozhang:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        const error = await response.json().catch(() => ({ error: { message: 'Erro desconhecido' } }));
                        console.error('[Viral Agents] ‚ùå Erro Laozhang:', error);
                        res.write(`data: ${JSON.stringify({ error: error.error?.message || error.message || 'Erro ao processar mensagem' })}\n\n`);
                        res.end();
                        return;
                    }
                    
                    console.log('[Viral Agents] ‚úÖ Resposta OK, iniciando leitura do stream...');
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let fullMessage = '';
                    let streamEnded = false;
                    
                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) {
                                streamEnded = true;
                                break;
                            }
                            
                            const chunk = decoder.decode(value, { stream: true });
                            const lines = chunk.split('\n');
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6).trim();
                                    if (!data || data === '[DONE]') {
                                        streamEnded = true;
                                        break;
                                    }
                                    
                                    try {
                                        const parsed = JSON.parse(data);
                                        if (parsed.choices?.[0]?.delta?.content) {
                                            const text = parsed.choices[0].delta.content;
                                            fullMessage += text;
                                            res.write(`data: ${JSON.stringify({ text: text })}\n\n`);
                                        } else if (parsed.choices?.[0]?.message?.content) {
                                            // Algumas APIs retornam conte√∫do completo
                                            fullMessage += parsed.choices[0].message.content;
                                            res.write(`data: ${JSON.stringify({ text: parsed.choices[0].message.content })}\n\n`);
                                        }
                                    } catch (e) {
                                        // Ignorar erros de parsing de linhas inv√°lidas
                                        console.warn('[Viral Agents] Erro ao parsear linha:', e.message);
                                    }
                                }
                            }
                            
                            if (streamEnded) break;
                        }
                    } catch (streamError) {
                        console.error('[Viral Agents] Erro durante leitura do stream:', streamError);
                        // Continuar para finalizar mesmo com erro
                    }
                    
                    // Garantir que sempre finalize o stream e salve a mensagem
                    clearTimeout(timeoutId);
                    
                    try {
                        // Extrair nota e checklist
                        let nota = null;
                        let checklist = null;
                        let roteiroFinal = fullMessage.trim();
                        
                        if (roteiroFinal) {
                            // Remover a se√ß√£o completa de avalia√ß√£o (texto + JSON)
                            // Procura por "# üìä AVALIA√á√ÉO DO ROTEIRO" ou varia√ß√µes e remove tudo at√© o final
                            const avaliacaoRegex = /#\s*üìä\s*AVALIA√á√ÉO\s*DO\s*ROTEIRO[\s\S]*$/i;
                            if (avaliacaoRegex.test(roteiroFinal)) {
                                // Encontrar onde come√ßa a avalia√ß√£o
                                const avaliacaoIndex = roteiroFinal.search(avaliacaoRegex);
                                if (avaliacaoIndex !== -1) {
                                    // Extrair JSON da avalia√ß√£o antes de remover
                                    const parteAvaliacao = roteiroFinal.substring(avaliacaoIndex);
                                    const jsonMatch = parteAvaliacao.match(/\{[\s\S]*"nota"[\s\S]*\}/);
                                    if (jsonMatch) {
                                        try {
                                            const avaliacao = JSON.parse(jsonMatch[0]);
                                            nota = avaliacao.nota;
                                            checklist = avaliacao.checklist || null;
                                        } catch (e) {
                                            // Tentar extrair nota do texto
                                            const notaMatch = parteAvaliacao.match(/nota[:\s]*(\d+)\/10/i);
                                            if (notaMatch) {
                                                nota = parseInt(notaMatch[1]);
                                            }
                                        }
                                    } else {
                                        // Tentar extrair nota do texto se n√£o houver JSON
                                        const notaMatch = parteAvaliacao.match(/nota[:\s]*(\d+)\/10/i);
                                        if (notaMatch) {
                                            nota = parseInt(notaMatch[1]);
                                        }
                                    }
                                    // Remover toda a se√ß√£o de avalia√ß√£o
                                    roteiroFinal = roteiroFinal.substring(0, avaliacaoIndex).trim();
                                }
                            } else {
                                // Se n√£o encontrar a se√ß√£o completa, tentar remover apenas o JSON
                                const jsonMatch = roteiroFinal.match(/\{[\s\S]*"nota"[\s\S]*\}/);
                                if (jsonMatch) {
                                    try {
                                        const avaliacao = JSON.parse(jsonMatch[0]);
                                        nota = avaliacao.nota;
                                        checklist = avaliacao.checklist || null;
                                        roteiroFinal = roteiroFinal.replace(/\{[\s\S]*"nota"[\s\S]*\}/, '').trim();
                                    } catch (e) {
                                        const notaMatch = roteiroFinal.match(/nota[:\s]*(\d+)\/10/i);
                                        if (notaMatch) {
                                            nota = parseInt(notaMatch[1]);
                                            roteiroFinal = roteiroFinal.replace(/nota[:\s]*\d+\/10[\s\S]*/i, '').trim();
                                        }
                                    }
                                }
                            }
                            
                            // Remover tamb√©m qualquer texto relacionado √† avalia√ß√£o que possa ter ficado
                            roteiroFinal = roteiroFinal.replace(/An√°lise da Avalia√ß√£o:[\s\S]*$/i, '').trim();
                            roteiroFinal = roteiroFinal.replace(/Pontos Fortes:[\s\S]*$/i, '').trim();
                            roteiroFinal = roteiroFinal.replace(/√Årea de Melhoria:[\s\S]*$/i, '').trim();
                            roteiroFinal = roteiroFinal.replace(/GANCHO INICIAL[\s\S]*$/i, '').trim();
                            roteiroFinal = roteiroFinal.replace(/ESTRUTURA NARRATIVA[\s\S]*$/i, '').trim();
                            
                            // Salvar mensagem no banco (CR√çTICO: sempre salvar)
                            await db.run(
                                `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                 VALUES (?, ?, ?)`,
                                [conversation_id, 'assistant', roteiroFinal]
                            );
                            console.log('[Viral Agents] ‚úÖ Mensagem salva no banco, tamanho:', roteiroFinal.length);
                            
                            // Atualizar t√≠tulo da conversa
                            const conversationTitle = await db.get(
                                `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                                [conversation_id]
                            );
                            
                            if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                                const firstPhrase = message.substring(0, 50).trim();
                                const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                                await db.run(
                                    `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                    [title, conversation_id]
                                );
                            } else {
                                await db.run(
                                    `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                    [conversation_id]
                                );
                            }
                            
                            // Enviar evento de finaliza√ß√£o (CR√çTICO: sempre enviar)
                            res.write(`data: ${JSON.stringify({ done: true, nota: nota, checklist: checklist })}\n\n`);
                            console.log('[Viral Agents] ‚úÖ Evento done:true enviado');
                        } else {
                            // Se n√£o houver mensagem, ainda assim enviar done
                            console.warn('[Viral Agents] ‚ö†Ô∏è Mensagem vazia, enviando done mesmo assim');
                            res.write(`data: ${JSON.stringify({ done: true, nota: null, checklist: null })}\n\n`);
                        }
                    } catch (saveError) {
                        console.error('[Viral Agents] ‚ùå Erro ao salvar mensagem:', saveError);
                        // Mesmo com erro ao salvar, enviar done para o frontend
                        res.write(`data: ${JSON.stringify({ done: true, error: 'Erro ao salvar mensagem', nota: null, checklist: null })}\n\n`);
                    }
                    
                    // Sempre finalizar a resposta
                    res.end();
                    console.log('[Viral Agents] ‚úÖ Stream finalizado');
                    return;
                } catch (err) {
                    console.error('[La Casa Dark Core Streaming] Erro:', err);
                    clearTimeout(timeoutId);
                    try {
                        // Tentar salvar mensagem parcial se houver
                        if (fullMessage && fullMessage.trim()) {
                            await db.run(
                                `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                 VALUES (?, ?, ?)`,
                                [conversation_id, 'assistant', fullMessage.trim()]
                            );
                        }
                        // Sempre enviar evento de erro ou finaliza√ß√£o
                        res.write(`data: ${JSON.stringify({ done: true, error: err.message || 'Erro no streaming', nota: null, checklist: null })}\n\n`);
                    } catch (finalError) {
                        console.error('[Viral Agents] Erro ao finalizar stream:', finalError);
                        res.write(`data: ${JSON.stringify({ done: true, error: 'Erro cr√≠tico no streaming' })}\n\n`);
                    }
                    res.end();
                }
                return;
            } else {
                // Modo n√£o-streaming com laozhang
                try {
                    // Mapear modelo do frontend para formato da laozhang.ai
                    let laozhangModel = null;
                    if (modelToUse) {
                        if (modelToUse === 'gpt-4o' || modelToUse === 'GPT-4o (2025)') {
                            laozhangModel = 'gpt-4o';
                        } else if (modelToUse === 'claude-3-7-sonnet-20250219' || modelToUse === 'Claude 3.7 Sonnet (Fev/25)') {
                            laozhangModel = 'claude-3-7-sonnet-20250219';
                        } else if (modelToUse === 'gemini-2.5-pro' || modelToUse === 'Gemini 2.5 Pro (2025)') {
                            laozhangModel = 'gemini-2.5-pro';
                        } else if (modelToUse.includes('claude')) {
                            laozhangModel = 'claude-3-7-sonnet-20250219';
                        } else if (modelToUse.includes('gemini')) {
                            laozhangModel = 'gemini-2.5-pro';
                        } else if (modelToUse.includes('gpt')) {
                            laozhangModel = 'gpt-4o';
                        } else {
                            laozhangModel = modelToUse;
                        }
                    }
                    
                    // Se ainda n√£o tem modelo, usar 'gpt-4o' apenas como √∫ltimo recurso
                    if (!laozhangModel) {
                        console.warn(`[Viral Agents] ‚ö†Ô∏è Modelo n√£o fornecido, usando 'gpt-4o' como fallback`);
                        laozhangModel = 'gpt-4o';
                    }
                    
                    console.log('[Viral Agents] üìù Modo n√£o-streaming Laozhang - Modelo recebido:', modelToUse, '-> Mapeado para API:', laozhangModel);
                    console.log('[Viral Agents] üì§ Chamando callLaozhangAPI...');
                    console.log('[Viral Agents] üìã FullPrompt tamanho:', fullPrompt?.length || 0, 'SystemPrompt inclu√≠do:', systemPrompt ? 'Sim' : 'N√£o');
                    
                    // Garantir que fullPrompt est√° constru√≠do corretamente com systemPrompt enf√°tico
                    if (!fullPrompt || fullPrompt.trim().length === 0) {
                        console.warn('[Viral Agents] ‚ö†Ô∏è FullPrompt vazio, reconstruindo com systemPrompt...');
                        // Reconstruir com formata√ß√£o enf√°tica
                        if (systemPrompt && systemPrompt.trim()) {
                            fullPrompt = `=== CONFIGURA√á√ïES DO AGENTE (SEGUIR RIGOROSAMENTE) ===\n\n${systemPrompt}\n\n=== FIM DAS CONFIGURA√á√ïES ===\n\n`;
                        } else {
                            fullPrompt = 'Voc√™ √© um assistente √∫til.\n\n';
                        }
                        
                        // Adicionar hist√≥rico
                        if (messages.length > 0) {
                            fullPrompt += `=== HIST√ìRICO DA CONVERSA ===\n\n`;
                            messages.forEach(msg => {
                                fullPrompt += `${msg.role === 'user' ? 'Usu√°rio' : 'Assistente'}: ${msg.content}\n\n`;
                            });
                            fullPrompt += `=== FIM DO HIST√ìRICO ===\n\n`;
                        }
                        
                        // Adicionar mensagem atual
                        fullPrompt += `=== MENSAGEM ATUAL DO USU√ÅRIO ===\n\n`;
                        fullPrompt += `Usu√°rio: ${message}\n\n`;
                        fullPrompt += `=== SUA RESPOSTA (SEGUINDO AS CONFIGURA√á√ïES ACIMA) ===\n\n`;
                        fullPrompt += `Assistente:`;
                    }
                    
                    // Adicionar marcador para callLaozhangAPI detectar como roteiro
                    const promptWithMarker = fullPrompt + '\n\nIMPORTANTE: Gere o roteiro completo em TEXTO SIMPLES, sem usar JSON ou formata√ß√µes especiais.';
                    console.log('[Viral Agents] üìù Prompt final tamanho:', promptWithMarker.length);
                    console.log('[Viral Agents] üí∞ Chamando callLaozhangAPI com userId:', userId ? 'Sim' : 'N√£o');
                    assistantMessage = await callLaozhangAPI(promptWithMarker, laozhangApiKey, laozhangModel, null, userId, 'viral_agent_chat', JSON.stringify({ agent_id: agentId, conversation_id: conversation_id, model: laozhangModel }));
                    console.log('[Viral Agents] ‚úÖ Resposta recebida, tamanho:', assistantMessage?.length || 0);
                    
                    // Extrair nota e checklist usando fun√ß√£o helper - modo n√£o-streaming laozhang
                    const { roteiroFinal, nota, checklist } = removeAvaliacaoFromRoteiro(assistantMessage);
                    
                    // Salvar roteiro completo (sem a nota)
                    await db.run(
                        `INSERT INTO viral_agent_messages (conversation_id, role, content)
                         VALUES (?, ?, ?)`,
                        [conversation_id, 'assistant', roteiroFinal]
                    );
                    
                    const conversationTitle = await db.get(
                        `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                        [conversation_id]
                    );
                    
                    if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                        const firstPhrase = message.substring(0, 50).trim();
                        const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                        await db.run(
                            `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                            [title, conversation_id]
                        );
                    } else {
                        await db.run(
                            `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                            [conversation_id]
                        );
                    }
                    
                    return res.status(200).json({ response: roteiroFinal, nota: nota, checklist: checklist });
                } catch (err) {
                    console.error('[La Casa Dark Core API] Erro:', err);
                    return res.status(500).json({ msg: err.message || 'Erro ao processar mensagem.' });
                }
            }
        } else if (serviceName === 'claude') {
            // API do Claude
            const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';
            
            // Mapear modelo se necess√°rio
            const modelAliases = {
                'claude-3-5-sonnet-20241022': 'claude-3-7-sonnet-20250219',
                'claude-3-5-sonnet-20240620': 'claude-3-7-sonnet-20250219',
                'claude-3-5-sonnet-latest': 'claude-3-7-sonnet-20250219',
                'claude-3-sonnet-20240229': 'claude-3-7-sonnet-20250219',
                'claude-3.5-sonnet-20241022': 'claude-3-7-sonnet-20250219',
                'claude-3.5-sonnet-20240620': 'claude-3-7-sonnet-20250219',
                'claude-3-haiku-20240307': 'claude-3-7-sonnet-20250219',
                'claude-3.5-haiku-20241022': 'claude-3-7-sonnet-20250219',
                'claude-3-5-haiku-20241022': 'claude-3-7-sonnet-20250219',
                'claude-3-5-haiku-latest': 'claude-3-7-sonnet-20250219',
                'claude-3-opus-20240229': 'claude-opus-4-20250514'
            };
            
            let modelName = modelAliases[modelToUse] || modelToUse;
            const supportedModels = new Set([
                'claude-3-7-sonnet-20250219',
                'claude-sonnet-4-20250514',
                'claude-opus-4-20250514'
            ]);
            
            if (!supportedModels.has(modelName)) {
                if (modelToUse && modelToUse.toLowerCase().includes('opus')) {
                    modelName = 'claude-opus-4-20250514';
                } else if (modelToUse && (modelToUse.toLowerCase().includes('sonnet') || modelToUse.toLowerCase().includes('4'))) {
                    modelName = 'claude-sonnet-4-20250514';
                } else {
                    modelName = 'claude-3-7-sonnet-20250219';
                }
            }
            
            // Preparar mensagens com system prompt
            const claudeMessages = [...messages];
            
            const payload = {
                model: modelName,
                max_tokens: 16384, // Aumentado para permitir roteiros mais longos e completos
                messages: claudeMessages,
                stream: stream // Habilitar streaming
            };
            
            // Adicionar system prompt se houver (CR√çTICO: sempre incluir mem√≥ria e instru√ß√µes)
            // Claude usa o campo 'system' que tem alta prioridade e deve seguir rigorosamente
            if (systemPrompt && systemPrompt.trim()) {
                payload.system = systemPrompt;
                console.log('[Viral Agents] ‚úÖ System prompt inclu√≠do no payload Claude (mem√≥ria + instru√ß√µes), tamanho:', systemPrompt.length);
                console.log('[Viral Agents] üìã Primeiros 500 chars do system prompt:', systemPrompt.substring(0, 500));
            } else {
                console.warn('[Viral Agents] ‚ö†Ô∏è System prompt vazio ou n√£o definido - Claude pode n√£o seguir instru√ß√µes!');
            }

            if (stream) {
                // Configurar SSE para streaming
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000); // 5 minutos para roteiros longos

                try {
                    const response = await fetch(CLAUDE_API_URL, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        res.write(`data: ${JSON.stringify({ error: error.error?.message || 'Erro ao processar mensagem' })}\n\n`);
                        res.end();
                        return;
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let fullMessage = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                    if (data === '[DONE]') {
                                        clearTimeout(timeoutId);
                                        
                                        // Extrair nota e checklist usando fun√ß√£o helper
                                        const { roteiroFinal, nota, checklist } = removeAvaliacaoFromRoteiro(fullMessage);
                                        
                                        // Salvar roteiro completo (sem a nota)
                                        await db.run(
                                            `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                             VALUES (?, ?, ?)`,
                                            [conversation_id, 'assistant', roteiroFinal]
                                        );
                                        
                                        // Atualizar t√≠tulo da conversa
                                        const conversationTitle = await db.get(
                                            `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                                            [conversation_id]
                                        );
                                        
                                        if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                                            const firstPhrase = message.substring(0, 50).trim();
                                            const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                                            await db.run(
                                                `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                                [title, conversation_id]
                                            );
                                        } else {
                                            await db.run(
                                                `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                                [conversation_id]
                                            );
                                        }
                                        
                                        res.write(`data: ${JSON.stringify({ done: true, nota: nota, checklist: checklist })}\n\n`);
                                        res.end();
                                        return;
                                    }

                                try {
                                    const parsed = JSON.parse(data);
                                    if (parsed.type === 'content_block_delta' && parsed.delta?.text) {
                                        const text = parsed.delta.text;
                                        fullMessage += text;
                                        res.write(`data: ${JSON.stringify({ text: text })}\n\n`);
                                    }
                                } catch (e) {
                                    // Ignorar linhas inv√°lidas
                                }
                            }
                        }
                        
                        // Se o loop terminou sem receber [DONE], finalizar manualmente
                        if (fullMessage.trim()) {
                            clearTimeout(timeoutId);
                            
                            // Extrair nota e checklist usando fun√ß√£o helper
                            const { roteiroFinal, nota, checklist } = removeAvaliacaoFromRoteiro(fullMessage);
                            
                            // Salvar mensagem
                            await db.run(
                                `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                 VALUES (?, ?, ?)`,
                                [conversation_id, 'assistant', roteiroFinal]
                            );
                            
                            // Atualizar conversa
                            const conversationTitle = await db.get(
                                `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                                [conversation_id]
                            );
                            
                            if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                                const firstPhrase = message.substring(0, 50).trim();
                                const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                                await db.run(
                                    `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                    [title, conversation_id]
                                );
                            } else {
                                await db.run(
                                    `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                    [conversation_id]
                                );
                            }
                            
                            res.write(`data: ${JSON.stringify({ done: true, nota: nota, checklist: checklist })}\n\n`);
                            res.end();
                            return;
                        }
                    }
                } catch (err) {
                    clearTimeout(timeoutId);
                    console.error('[Claude Streaming] Erro:', err);
                    try {
                        // Tentar salvar mensagem parcial
                        if (fullMessage && fullMessage.trim()) {
                            await db.run(
                                `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                 VALUES (?, ?, ?)`,
                                [conversation_id, 'assistant', fullMessage.trim()]
                            );
                        }
                        res.write(`data: ${JSON.stringify({ done: true, error: err.message || 'Erro no streaming', nota: null, checklist: null })}\n\n`);
                    } catch (finalError) {
                        res.write(`data: ${JSON.stringify({ done: true, error: 'Erro cr√≠tico no streaming' })}\n\n`);
                    }
                    res.end();
                }
                return;
            } else {
                // Modo n√£o-streaming (fallback)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000);

                const response = await fetch(CLAUDE_API_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify(payload),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (!response.ok) {
                    console.error('[Claude API] Erro:', result);
                    return res.status(response.status).json({ 
                        msg: result.error?.message || 'Erro ao processar mensagem com Claude.',
                        error: result.error 
                    });
                }

                assistantMessage = result.content[0].text;
            }
            
        } else if (serviceName === 'openai') {
            // API do OpenAI
            const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
            
            const openaiMessages = [];
            if (systemPrompt) {
                openaiMessages.push({
                    role: 'system',
                    content: systemPrompt
                });
            }
            openaiMessages.push(...messages);
            
            const payload = {
                model: modelToUse || 'gpt-4o',
                messages: openaiMessages,
                max_tokens: 16384, // Aumentado para permitir roteiros mais longos e completos
                temperature: 0.7,
                stream: stream
            };
            
            if (stream) {
                // Streaming para OpenAI
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000);

                try {
                    const response = await fetch(OPENAI_API_URL, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        res.write(`data: ${JSON.stringify({ error: error.error?.message || 'Erro ao processar mensagem' })}\n\n`);
                        res.end();
                        return;
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let fullMessage = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') {
                                    clearTimeout(timeoutId);
                                    
                                    // Extrair nota e pontos fortes do JSON (se houver)
                                    let nota = null;
                                    let pontosFortes = [];
                                    let roteiroFinal = fullMessage;
                                    
                                    // Tentar encontrar JSON no final da mensagem
                                    const jsonMatch = fullMessage.match(/\{[\s\S]*"nota"[\s\S]*\}/);
                                    if (jsonMatch) {
                                        try {
                                            const avaliacao = JSON.parse(jsonMatch[0]);
                                            nota = avaliacao.nota;
                                                checklist = avaliacao.checklist || null;
                                            // Remover JSON do roteiro
                                            roteiroFinal = fullMessage.replace(/\{[\s\S]*"nota"[\s\S]*\}/, '').trim();
                                        } catch (e) {
                                            // Se n√£o conseguir parsear, tentar extrair nota manualmente
                                            const notaMatch = fullMessage.match(/nota[:\s]*(\d+)\/10/i);
                                            if (notaMatch) {
                                                nota = parseInt(notaMatch[1]);
                                                roteiroFinal = fullMessage.replace(/nota[:\s]*\d+\/10[\s\S]*/i, '').trim();
                                            }
                                        }
                                    }
                                    
                                    // Salvar roteiro completo (sem a nota)
                                    await db.run(
                                        `INSERT INTO viral_agent_messages (conversation_id, role, content)
                                         VALUES (?, ?, ?)`,
                                        [conversation_id, 'assistant', roteiroFinal]
                                    );
                                    
                                    const conversationTitle = await db.get(
                                        `SELECT title FROM viral_agent_conversations WHERE id = ?`,
                                        [conversation_id]
                                    );
                                    
                                    if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
                                        const firstPhrase = message.substring(0, 50).trim();
                                        const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
                                        await db.run(
                                            `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                            [title, conversation_id]
                                        );
                                    } else {
                                        await db.run(
                                            `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                                            [conversation_id]
                                        );
                                    }
                                    
                                    res.write(`data: ${JSON.stringify({ done: true, nota: nota, checklist: checklist })}\n\n`);
                                    res.end();
                                    return;
                                }

                                try {
                                    const parsed = JSON.parse(data);
                                    if (parsed.choices?.[0]?.delta?.content) {
                                        const text = parsed.choices[0].delta.content;
                                        fullMessage += text;
                                        res.write(`data: ${JSON.stringify({ text: text })}\n\n`);
                                    }
                                } catch (e) {
                                    // Ignorar linhas inv√°lidas
                                }
                            }
                        }
                    }
                } catch (err) {
                    clearTimeout(timeoutId);
                    console.error('[La Casa Dark Core Streaming] Erro:', err);
                    res.write(`data: ${JSON.stringify({ error: err.message || 'Erro no streaming' })}\n\n`);
                    res.end();
                }
                return;
            } else {
                // Modo n√£o-streaming (fallback)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000);

                const response = await fetch(OPENAI_API_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(payload),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (!response.ok) {
                    console.error('[La Casa Dark Core API] Erro:', result);
                    return res.status(response.status).json({ 
                        msg: result.error?.message || 'Erro ao processar mensagem com OpenAI.',
                        error: result.error 
                    });
                }

                assistantMessage = result.choices[0].message.content;
            }
            
        } else if (serviceName === 'gemini') {
            // API do Gemini usando @google/genai
            const { GoogleGenAI } = require('@google/genai');
            const genAI = new GoogleGenAI(apiKey);
            
            // Preparar prompt completo com system prompt, hist√≥rico e mensagem atual
            let fullPrompt = '';
            if (systemPrompt) {
                fullPrompt += systemPrompt + '\n\n';
            }
            
            // Adicionar hist√≥rico
            messages.forEach(msg => {
                fullPrompt += `${msg.role === 'user' ? 'Usu√°rio' : 'Assistente'}: ${msg.content}\n\n`;
            });
            
            // Adicionar mensagem atual
            fullPrompt += `Usu√°rio: ${message}\nAssistente:`;

            const model = genAI.getGenerativeModel({ model: modelToUse || 'gemini-2.5-pro' });
            const result = await model.generateContent(fullPrompt);
            assistantMessage = result.response.text();
        }

        // Extrair nota e checklist usando fun√ß√£o helper - modo n√£o-streaming
        let nota = null;
        let checklist = null;
        const { roteiroFinal, nota: notaExtraida, checklist: checklistExtraido } = removeAvaliacaoFromRoteiro(assistantMessage);
        if (notaExtraida !== null) nota = notaExtraida;
        if (checklistExtraido !== null) checklist = checklistExtraido;
        const pontosFortes = checklist ? Object.keys(checklist).filter(k => checklist[k] === true) : [];
        if (notaExtraida !== null) nota = notaExtraida;
        if (checklistExtraido !== null) checklist = checklistExtraido;
        
        // Salvar roteiro completo (sem a nota)
        await db.run(
            `INSERT INTO viral_agent_messages (conversation_id, role, content)
             VALUES (?, ?, ?)`,
            [conversation_id, 'assistant', roteiroFinal]
        );

        // Atualizar t√≠tulo da conversa com primeira frase da mensagem do usu√°rio (se ainda for "Nova Conversa")
        const conversationTitle = await db.get(
            `SELECT title FROM viral_agent_conversations WHERE id = ?`,
            [conversation_id]
        );
        
        if (conversationTitle && (conversationTitle.title === 'Nova Conversa' || !conversationTitle.title)) {
            // Pegar primeira frase da mensagem do usu√°rio (primeiros 50 caracteres)
            const firstPhrase = message.substring(0, 50).trim();
            const title = firstPhrase.length < message.length ? firstPhrase + '...' : firstPhrase;
            
            await db.run(
                `UPDATE viral_agent_conversations SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                [title, conversation_id]
            );
        } else {
            // Apenas atualizar timestamp
            await db.run(
                `UPDATE viral_agent_conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
                [conversation_id]
            );
        }

        res.status(200).json({ response: roteiroFinal, nota: nota, checklist: checklist });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/chat POST]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao processar mensagem.' });
    }
});

// Rota para obter mensagens de uma conversa
app.get('/api/viral-agents/:agentId/conversations/:conversationId/messages', authenticateToken, async (req, res) => {
    const { agentId, conversationId } = req.params;
    const userId = req.user.id;

    try {
        // Verificar se a conversa pertence ao usu√°rio e ao agente
        const conversation = await db.get(
            `SELECT * FROM viral_agent_conversations 
             WHERE id = ? AND agent_id = ? AND user_id = ?`,
            [conversationId, agentId, userId]
        );

        if (!conversation) {
            return res.status(404).json({ msg: 'Conversa n√£o encontrada.' });
        }

        const messages = await db.all(
            `SELECT * FROM viral_agent_messages 
             WHERE conversation_id = ? 
             ORDER BY created_at ASC`,
            [conversationId]
        );

        res.status(200).json({ messages });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/conversations/:conversationId/messages GET]:', err);
        res.status(500).json({ msg: 'Erro ao obter mensagens.' });
    }
});

// Rota para deletar uma conversa
app.delete('/api/viral-agents/:agentId/conversations/:conversationId', authenticateToken, async (req, res) => {
    const { agentId, conversationId } = req.params;
    const userId = req.user.id;

    try {
        const result = await db.run(
            `DELETE FROM viral_agent_conversations 
             WHERE id = ? AND agent_id = ? AND user_id = ?`,
            [conversationId, agentId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Conversa n√£o encontrada.' });
        }

        res.status(200).json({ msg: 'Conversa deletada com sucesso!' });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/conversations/:conversationId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao deletar conversa.' });
    }
});

// Rota para gerar documento MD de uma conversa
app.get('/api/viral-agents/:agentId/conversations/:conversationId/markdown', authenticateToken, async (req, res) => {
    const { agentId, conversationId } = req.params;
    const userId = req.user.id;

    try {
        // Verificar se o agente pertence ao usu√°rio
        const agent = await db.get(
            `SELECT * FROM viral_agents WHERE id = ? AND user_id = ?`,
            [agentId, userId]
        );

        if (!agent) {
            return res.status(404).json({ msg: 'Agente n√£o encontrado.' });
        }

        // Verificar se a conversa pertence ao usu√°rio e ao agente
        const conversation = await db.get(
            `SELECT * FROM viral_agent_conversations 
             WHERE id = ? AND agent_id = ? AND user_id = ?`,
            [conversationId, agentId, userId]
        );

        if (!conversation) {
            return res.status(404).json({ msg: 'Conversa n√£o encontrada.' });
        }

        // Buscar todas as mensagens da conversa
        const messages = await db.all(
            `SELECT role, content, created_at FROM viral_agent_messages 
             WHERE conversation_id = ? 
             ORDER BY created_at ASC`,
            [conversationId]
        );

        // Gerar conte√∫do Markdown
        let mdContent = `# ${conversation.title || 'Conversa'}\n\n`;
        mdContent += `**Agente:** ${agent.name}\n`;
        mdContent += `**Data:** ${new Date(conversation.created_at).toLocaleString('pt-BR')}\n\n`;
        mdContent += `---\n\n`;

        messages.forEach(msg => {
            const roleLabel = msg.role === 'user' ? '**Usu√°rio:**' : '**Assistente:**';
            const timestamp = new Date(msg.created_at).toLocaleString('pt-BR');
            mdContent += `${roleLabel} (${timestamp})\n\n`;
            mdContent += `${msg.content}\n\n`;
            mdContent += `---\n\n`;
        });

        // Retornar como HTML para abrir em nova aba
        const htmlContent = `<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${conversation.title || 'Conversa'} - ${agent.name}</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        pre {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #3a3a3a;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        code {
            background: #2a2a2a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        h1 { color: #f59e0b; border-bottom: 2px solid #f59e0b; padding-bottom: 10px; }
        h2 { color: #fbbf24; margin-top: 30px; }
        hr { border: none; border-top: 1px solid #3a3a3a; margin: 20px 0; }
        .copy-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 1000;
        }
        .copy-btn:hover { background: #d97706; }
    </style>
</head>
<body>
    <button class="copy-btn" onclick="copyAll()">Copiar Tudo</button>
    <pre id="content">${mdContent.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
    <script>
        function copyAll() {
            const content = document.getElementById('content').textContent;
            navigator.clipboard.writeText(content).then(() => {
                alert('Conte√∫do copiado!');
            });
        }
    </script>
</body>
</html>`;

        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.send(htmlContent);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/viral-agents/:agentId/conversations/:conversationId/markdown GET]:', err);
        res.status(500).json({ msg: 'Erro ao gerar documento.' });
    }
});

// ==================== FIM DAS ROTAS PARA AGENTES VIRAIS ====================

// Rota para download de roteiro em formato TXT
app.get('/api/scripts/:id/download/txt', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scriptId = req.params.id;

    try {
        const script = await db.get(
            `SELECT * FROM generated_scripts WHERE id = ? AND user_id = ?`,
            [scriptId, userId]
        );

        if (!script) {
            return res.status(404).json({ msg: 'Roteiro n√£o encontrado.' });
        }

        // Criar conte√∫do TXT com cabe√ßalho
        let txtContent = `T√çTULO: ${script.title}\n`;
        txtContent += `DATA: ${new Date(script.created_at).toLocaleString('pt-BR')}\n`;
        txtContent += `MODELO: ${script.model_used || 'N/A'}\n`;
        if (script.niche) txtContent += `NICHO: ${script.niche}\n`;
        if (script.subniche) txtContent += `SUBNICHO: ${script.subniche}\n`;
        if (script.optimization_score) {
            txtContent += `\nAN√ÅLISE DE OTIMIZA√á√ÉO:\n`;
            txtContent += `Score Geral: ${script.optimization_score}/10\n`;
            txtContent += `Reten√ß√£o: ${script.retention_score}/10\n`;
            txtContent += `Autenticidade: ${script.authenticity_score}/10\n`;
        }
        txtContent += `\n${'='.repeat(60)}\n\nROTEIRO:\n\n`;
        txtContent += script.script_content;
        
        if (script.optimization_report) {
            txtContent += `\n\n${'='.repeat(60)}\n\n`;
            txtContent += script.optimization_report;
        }

        // Definir headers para download
        const filename = `roteiro_${script.id}_${script.title.replace(/[^a-z0-9]/gi, '_').substring(0, 50)}.txt`;
        res.setHeader('Content-Type', 'text/plain; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        res.send(txtContent);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts/:id/download/txt]:', err);
        res.status(500).json({ msg: 'Erro ao fazer download do roteiro.' });
    }
});

// Rota para download de roteiro em formato SRT (legendas)
app.get('/api/scripts/:id/download/srt', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const scriptId = req.params.id;

    try {
        const script = await db.get(
            `SELECT * FROM generated_scripts WHERE id = ? AND user_id = ?`,
            [scriptId, userId]
        );

        if (!script) {
            return res.status(404).json({ msg: 'Roteiro n√£o encontrado.' });
        }

        // Converter roteiro em formato SRT
        // Estimativa: 150 palavras por minuto, 3-5 palavras por legenda
        const scriptText = script.script_content;
        const sentences = scriptText.split(/[.!?]\s+/).filter(s => s.trim().length > 0);
        
        let srtContent = '';
        let counter = 1;
        let currentTime = 0; // em segundos
        
        for (const sentence of sentences) {
            const words = sentence.trim().split(/\s+/);
            const wordsPerSubtitle = 8; // M√°ximo de palavras por legenda
            
            // Dividir senten√ßa em partes menores se necess√°rio
            for (let i = 0; i < words.length; i += wordsPerSubtitle) {
                const chunk = words.slice(i, i + wordsPerSubtitle).join(' ');
                const chunkWords = chunk.split(/\s+/).length;
                const duration = (chunkWords / 150) * 60; // 150 palavras por minuto
                
                // Formatar timestamps
                const startTime = formatSRTTime(currentTime);
                const endTime = formatSRTTime(currentTime + duration);
                
                srtContent += `${counter}\n`;
                srtContent += `${startTime} --> ${endTime}\n`;
                srtContent += `${chunk}\n\n`;
                
                counter++;
                currentTime += duration;
            }
        }

        // Definir headers para download
        const filename = `roteiro_${script.id}_${script.title.replace(/[^a-z0-9]/gi, '_').substring(0, 50)}.srt`;
        res.setHeader('Content-Type', 'text/plain; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        res.send(srtContent);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/scripts/:id/download/srt]:', err);
        res.status(500).json({ msg: 'Erro ao fazer download do roteiro em SRT.' });
    }
});

// Fun√ß√£o auxiliar para formatar tempo no formato SRT (HH:MM:SS,mmm)
function formatSRTTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const millis = Math.floor((seconds % 1) * 1000);
    
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')},${String(millis).padStart(3, '0')}`;
}


// === ROTAS DE EXPLORA√á√ÉO DE NICHO ===

app.post('/api/niche/find-subniche', authenticateToken, async (req, res) => {
    const { nichePrincipal, ideiaInicial, model } = req.body;
    const userId = req.user.id;

    if (!nichePrincipal || !ideiaInicial || !model) {
        return res.status(400).json({ msg: 'Todos os campos s√£o obrigat√≥rios.' });
    }

    try {
        const prompt = `
            Voc√™ √© um ESPECIALISTA EM CRIA√á√ÉO DE CANAIS MILION√ÅRIOS NO YOUTUBE com experi√™ncia em identificar oportunidades de subnichos com alto potencial de viraliza√ß√£o.
            
            OBJETIVO: Encontrar um subnicho dentro de "${nichePrincipal}" que permita criar um canal MILION√ÅRIO com MILH√ïES DE VIEWS, ALTO CTR e conte√∫do que VIRALIZE.
            
            PROMPT INICIAL PARA EDUCAR O GPT:
            Quero criar um canal no YouTube dentro do nicho de "${nichePrincipal}", inicialmente pensei em abordar "${ideiaInicial}", mas percebi que j√° h√° bastante concorr√™ncia nesse subnicho. 
            
            Estou em busca de uma ideia de subnicho dentro de "${nichePrincipal}" que:
            - Ainda esteja pouco explorada no YouTube, com pouca ou nenhuma concorr√™ncia
            - Tenha alto volume de buscas e interesse crescente
            - Tenha bom potencial de monetiza√ß√£o
            - TENHA ALTO POTENCIAL DE VIRALIZA√á√ÉO e capacidade de gerar milh√µes de views
            - Permita criar conte√∫do com alto CTR (acima de 25%)
            - Tenha oportunidades de criar t√≠tulos e thumbnails virais
            
            O objetivo √© encontrar uma oportunidade √∫nica para criar conte√∫do relevante, com forte demanda, baixa competi√ß√£o, e POTENCIAL PARA CRIAR UM CANAL MILION√ÅRIO com milh√µes de views e alto CTR.
            
            Com base em dados atuais e tend√™ncias, o que voc√™ recomenda? Forne√ßa uma an√°lise detalhada que inclua:
            - O subnicho recomendado e por que ele tem potencial para gerar milh√µes de views
            - An√°lise de concorr√™ncia e oportunidades
            - Potencial de viraliza√ß√£o e alto CTR
            - Estrat√©gias para criar conte√∫do que viralize
            - Sugest√µes de t√≠tulos e thumbnails que gerem alto CTR
        `;

        // Verificar se deve usar cr√©ditos (laozhang.ai) ou API pr√≥pria
        // REGRA: Usa cr√©ditos se usu√°rio marcou prefer√™ncia OU n√£o tem plano que permite API pr√≥pria OU n√£o tem API pr√≥pria configurada
        // REGRA CR√çTICA: Se prefer√™ncia N√ÉO est√° marcada E usu√°rio tem plano que permite E tem API pr√≥pria ‚Üí usar API pr√≥pria
        let useLaozhang = false;
        let apiKeyToUse = null;
        let serviceToUse = null;
        let apiCallFunction = null;
        
        try {
            // Determinar ordem de prefer√™ncia baseado no modelo
            let preferenceOrder = ['claude', 'openai', 'gemini'];
            if (model.startsWith('gemini')) preferenceOrder = ['gemini', 'claude', 'openai'];
            else if (model.startsWith('claude')) preferenceOrder = ['claude', 'openai', 'gemini'];
            else if (model.startsWith('gpt')) preferenceOrder = ['openai', 'claude', 'gemini'];
            
            const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
            
            if (creditsCheck.shouldUse) {
                // Se deve usar cr√©ditos, usar laozhang.ai
                const laozhangKey = await getLaozhangApiKey();
                if (laozhangKey) {
                    useLaozhang = true;
                    apiKeyToUse = laozhangKey;
                    serviceToUse = 'laozhang';
                    apiCallFunction = callLaozhangAPI;
                    console.log(`[Find Subniche] ‚úÖ Usando Laozhang.ai (${creditsCheck.reason})`);
                } else {
                    console.warn('[Find Subniche] ‚ö†Ô∏è Laozhang.ai n√£o configurada, tentando usar APIs pr√≥prias do usu√°rio');
                }
            } else {
                console.log(`[Find Subniche] ‚úÖ Usando API pr√≥pria (${creditsCheck.reason})`);
            }
        } catch (err) {
            console.warn('[Find Subniche] Erro ao verificar uso de cr√©ditos:', err.message);
        }
        
        // Se n√£o usar laozhang.ai, usar APIs pr√≥prias do usu√°rio
        if (!useLaozhang) {
            let service;
            if (model.startsWith('gemini')) service = 'gemini';
            else if (model.startsWith('claude')) service = 'claude';
            else if (model.startsWith('gpt')) service = 'openai';
            else return res.status(400).json({ msg: 'Modelo de IA inv√°lido.' });
            
            serviceToUse = service;
            
            const userKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (!userKeyData) return res.status(400).json({ msg: `Nenhuma Chave de API do ${service} configurada.` });
            
            apiKeyToUse = decrypt(userKeyData.api_key);
            if (!apiKeyToUse) return res.status(500).json({ msg: 'Falha ao desencriptar a sua chave de API.' });

            if (service === 'gemini') apiCallFunction = callGeminiAPI;
            else if (service === 'claude') apiCallFunction = callClaudeAPI;
            else apiCallFunction = callOpenAIAPI;
        }
        
        // Chamar API apropriada
        let response;
        if (useLaozhang) {
            response = await callLaozhangAPI(
                prompt, 
                apiKeyToUse, 
                model, 
                null, 
                userId, 
                '/api/niche/find-subniche', 
                JSON.stringify({ endpoint: '/api/niche/find-subniche', model })
            );
            // callLaozhangAPI retorna string diretamente
            response = typeof response === 'string' ? response.trim() : JSON.stringify(response);
            response = { titles: response };
        } else {
            response = await apiCallFunction(prompt, apiKeyToUse, model);
        }
        
        const recommendation = parseAIResponse(response.titles, serviceToUse);

        res.status(200).json({ recommendation: recommendation.text || recommendation });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/niche/find-subniche]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});

// === ROTA LAOZHANG PARA ENCONTRAR SUBNICHOS ===
app.post('/api/niche/find-subniche/laozhang', authenticateToken, async (req, res) => {
    const { nichePrincipal, ideiaInicial, selectedModel } = req.body;
    const userId = req.user.id;

    if (!nichePrincipal || !ideiaInicial) {
        return res.status(400).json({ msg: 'Nicho principal e ideia inicial s√£o obrigat√≥rios.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo n√£o configurada no painel admin.' });
        }

        // Se n√£o houver modelo selecionado, usar GPT-4o como padr√£o
        const laozhangModel = selectedModel === 'Claude 3.7 Sonnet (Fev/25)' ? 'claude-3-7-sonnet-20250219' :
                             selectedModel === 'Gemini 2.5 Pro (2025)' ? 'gemini-2.5-pro' :
                             (!selectedModel || !selectedModel.trim()) ? 'gpt-4o' : selectedModel;

        const prompt = `
Voc√™ √© um ESPECIALISTA EM CRIA√á√ÉO DE CANAIS MILION√ÅRIOS NO YOUTUBE.

OBJETIVO: Encontrar um subnicho dentro de "${nichePrincipal}" que permita criar um canal MILION√ÅRIO.

Quero criar um canal no YouTube dentro do nicho de "${nichePrincipal}", inicialmente pensei em abordar "${ideiaInicial}", mas percebi que j√° h√° bastante concorr√™ncia.

Estou em busca de uma ideia de subnicho dentro de "${nichePrincipal}" que:
- Ainda esteja pouco explorada no YouTube, com pouca ou nenhuma concorr√™ncia
- Tenha alto volume de buscas e interesse crescente
- Tenha bom potencial de monetiza√ß√£o
- TENHA ALTO POTENCIAL DE VIRALIZA√á√ÉO e capacidade de gerar milh√µes de views
- Permita criar conte√∫do com alto CTR (acima de 25%)
- Tenha oportunidades de criar t√≠tulos e thumbnails virais

IMPORTANTE: Responda APENAS com um JSON v√°lido no seguinte formato (sem texto adicional antes ou depois):

{
  "subnicho_recomendado": "Nome do subnicho recomendado",
  "analise_potencial": "An√°lise detalhada explicando por que este subnicho tem potencial para gerar milh√µes de views, incluindo dados de mercado, tend√™ncias e oportunidades",
  "analise_concorrencia": "An√°lise da concorr√™ncia atual, mostrando por que h√° pouca competi√ß√£o e quais s√£o as oportunidades de diferencia√ß√£o",
  "potencial_viralizacao": "Explica√ß√£o detalhada do potencial de viraliza√ß√£o, incluindo fatores que podem fazer o conte√∫do viralizar e gerar milh√µes de views",
  "estrategias_conteudo": [
    "Estrat√©gia 1 para criar conte√∫do que viralize",
    "Estrat√©gia 2 para criar conte√∫do que viralize",
    "Estrat√©gia 3 para criar conte√∫do que viralize",
    "Estrat√©gia 4 para criar conte√∫do que viralize"
  ],
  "sugestoes_titulos_thumbnails": {
    "titulos": [
      "T√≠tulo viral 1 que gere alto CTR",
      "T√≠tulo viral 2 que gere alto CTR",
      "T√≠tulo viral 3 que gere alto CTR",
      "T√≠tulo viral 4 que gere alto CTR"
    ],
    "thumbnails": [
      {
        "imagem": "Descri√ß√£o da imagem do thumbnail 1",
        "texto": "Texto do thumbnail 1",
        "cores": "Cores recomendadas para o thumbnail 1"
      },
      {
        "imagem": "Descri√ß√£o da imagem do thumbnail 2",
        "texto": "Texto do thumbnail 2",
        "cores": "Cores recomendadas para o thumbnail 2"
      },
      {
        "imagem": "Descri√ß√£o da imagem do thumbnail 3",
        "texto": "Texto do thumbnail 3",
        "cores": "Cores recomendadas para o thumbnail 3"
      },
      {
        "imagem": "Descri√ß√£o da imagem do thumbnail 4",
        "texto": "Texto do thumbnail 4",
        "cores": "Cores recomendadas para o thumbnail 4"
      }
    ]
  }
}

Responda APENAS com o JSON, sem texto adicional antes ou depois.
`;

        const response = await callLaozhangAPI(
            prompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_niche_find_subniche',
            JSON.stringify({ endpoint: '/api/niche/find-subniche/laozhang', model: laozhangModel })
        );

        // Tentar extrair JSON da resposta
        let recommendation = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        // Tentar parsear JSON se a resposta cont√©m JSON
        try {
            const jsonMatch = recommendation.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                recommendation = parsed;
            }
        } catch (e) {
            console.warn('[Find Subniche] Falha ao parsear JSON, retornando texto:', e.message);
        }
        
        res.status(200).json({ recommendation: recommendation });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/niche/find-subniche/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});

app.post('/api/niche/analyze-competitor', authenticateToken, async (req, res) => {
    const { competitorUrl, model } = req.body;
    const userId = req.user.id;

    if (!competitorUrl || !model) {
        return res.status(400).json({ msg: 'URL do canal e modelo de IA s√£o obrigat√≥rios.' });
    }

    try {
        // 1. Obter chaves de API
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        if (!geminiKeyData) return res.status(400).json({ msg: 'Chave de API do Gemini √© necess√°ria para buscar dados do YouTube.' });
        const geminiApiKey = decrypt(geminiKeyData.api_key);
        if (!geminiApiKey) return res.status(500).json({ msg: 'Falha ao desencriptar a chave do Gemini.' });

        // 2. Obter ID do canal a partir da URL
        const match = competitorUrl.match(/youtube\.com\/(?:@([\w.-]+)|channel\/([\w-]+))/);
        if (!match) return res.status(400).json({ msg: 'Formato de URL do canal n√£o suportado.' });
        
        let ytChannelId;
        const handle = match[1];
        const legacyId = match[2];

        if (handle) {
            const searchApiUrl = `https://www.googleapis.com/youtube/v3/search?part=id&q=${handle}&type=channel&maxResults=1&key=${geminiApiKey}`;
            const searchResponse = await fetch(searchApiUrl);
            const searchData = await searchResponse.json();
            if (!searchResponse.ok || !searchData.items || searchData.items.length === 0) {
                throw new Error(`N√£o foi poss√≠vel encontrar o canal para o handle: @${handle}.`);
            }
            ytChannelId = searchData.items[0].id.channelId;
        } else {
            ytChannelId = legacyId;
        }
        if (!ytChannelId) throw new Error('N√£o foi poss√≠vel determinar o ID do canal.');

        // 3. Buscar v√≠deos do canal
        const [popularVideos, latestVideos] = await Promise.all([
            getChannelVideosWithDetails(ytChannelId, geminiApiKey, 'viewCount', 10),
            getChannelVideosWithDetails(ytChannelId, geminiApiKey, 'date', 10)
        ]);

        let videoDataForPrompt = "Lista de v√≠deos publicados pelo canal:\n\n";
        videoDataForPrompt += "--- V√çDEOS MAIS POPULARES ---\n";
        popularVideos.forEach(v => {
            videoDataForPrompt += `- T√≠tulo: "${v.title}", Visualiza√ß√µes: ${v.views}, Publicado h√°: ${v.days} dias\n`;
        });
        videoDataForPrompt += "\n--- V√çDEOS MAIS RECENTES ---\n";
        latestVideos.forEach(v => {
            videoDataForPrompt += `- T√≠tulo: "${v.title}", Visualiza√ß√µes: ${v.views}, Publicado h√°: ${v.days} dias\n`;
        });

        // 4. Construir o PROMPT 2 (OTIMIZADO PARA CRIAR CANAIS MILION√ÅRIOS)
        const prompt = `
            Voc√™ √© um ESPECIALISTA EM CRIA√á√ÉO DE CANAIS MILION√ÅRIOS NO YOUTUBE com experi√™ncia em analisar canais de sucesso e criar estrat√©gias vencedoras.
            
            OBJETIVO: Analisar um canal de sucesso no YouTube e usar essa an√°lise como base para criar um canal MILION√ÅRIO com MILH√ïES DE VIEWS e ALTO CTR dentro do mesmo nicho.
            
            PROMPT 2 - AN√ÅLISE DE CANAL COMPETIDOR:
            Preciso da sua ajuda para analisar um canal de sucesso no YouTube e usar essa an√°lise como base para a cria√ß√£o do meu pr√≥prio canal dentro do mesmo nicho.
            
            Vou te fornecer as seguintes informa√ß√µes:
            ${videoDataForPrompt}
            
            Com base nesses dados, preciso que voc√™ fa√ßa uma AN√ÅLISE PROFUNDA E ESTRAT√âGICA e me responda com:
            
            1. **An√°lise de Nicho e Subnicho:**
               - Qual √© o nicho exato desse canal e seu subnicho (se houver)?
               - Por que esse nicho/subnicho funcionou t√£o bem?
               - H√° oportunidades de subnichos pouco explorados com alto potencial de viraliza√ß√£o?
            
            2. **Diferenciais de Sucesso:**
               - Quais s√£o os principais diferenciais que tornam esse canal bem-sucedido?
               - O que faz esse canal gerar milh√µes de views?
               - Quais s√£o os elementos √∫nicos que criam alta taxa de engajamento?
            
            3. **P√∫blico-Alvo:**
               - Qual √© o p√∫blico-alvo (perfil demogr√°fico, interesses, comportamento)?
               - Que tipo de conte√∫do esse p√∫blico consome?
               - Quais s√£o as necessidades e desejos n√£o atendidos desse p√∫blico?
            
            4. **Estrat√©gias de Conte√∫do Virais:**
               - Quais estrat√©gias de conte√∫do parecem ser as mais eficazes (tipo de v√≠deo, frequ√™ncia, estilo de narrativa, t√≠tulos, miniaturas, SEO)?
               - Quais padr√µes ou formatos se repetem nos v√≠deos de maior sucesso?
               - O que faz os v√≠deos terem alto CTR e gerarem milh√µes de views?
               - Quais s√£o as f√≥rmulas de t√≠tulos e thumbnails que funcionaram?
            
            5. **An√°lise de Oportunidades:**
               - H√° algo nos coment√°rios que revele desejos ou insatisfa√ß√µes da audi√™ncia que eu possa usar como oportunidade? (Simule uma an√°lise de sentimentos com base nos t√≠tulos e views)
               - Quais s√£o as oportunidades que eu posso explorar para criar um canal similar, por√©m com diferenciais competitivos?
               - Como posso criar conte√∫do que viralize e gere milh√µes de views?
            
            6. **Orienta√ß√£o Estrat√©gica para Criar Canal Milion√°rio:**
               - Como devo estruturar o conte√∫do do meu canal para gerar milh√µes de views?
               - Qual linha editorial devo seguir para alto CTR e viraliza√ß√£o?
               - Sugest√µes de nome de canal, temas iniciais e identidade visual que atraiam milh√µes de views
               - Ideias de roteiros para os primeiros v√≠deos, baseados no que mais funciona no canal analisado
               - Estrat√©gias para criar t√≠tulos e thumbnails que gerem alto CTR (acima de 25%)
               - Como criar conte√∫do que viralize e gere engajamento massivo
            
            FOCO: Criar um canal MILION√ÅRIO com MILH√ïES DE VIEWS, ALTO CTR (acima de 25%), e conte√∫do que VIRALIZE.
            
            Analise tudo com aten√ß√£o e me d√™ uma resposta estrat√©gica e pr√°tica, voltada para resultados e cria√ß√£o de canais milion√°rios, em formato JSON. O JSON deve ter chaves como "analise_nicho", "diferenciais_sucesso", "publico_alvo", "estrategias_conteudo", "padroes_videos", "analise_comentarios", "oportunidades_explorar", e "orientacoes_finais" (que por sua vez cont√©m "estrutura_conteudo", "linha_editorial", "sugestoes_branding", "ideias_roteiros", "estrategias_viralizacao", "titulos_ctr_alto", "thumbnails_virais").
        `;

        // 5. Chamar a IA - Verificar se deve usar cr√©ditos (laozhang.ai) ou API pr√≥pria
        // REGRA: Usa cr√©ditos se usu√°rio marcou prefer√™ncia OU n√£o tem plano que permite API pr√≥pria OU n√£o tem API pr√≥pria configurada
        // REGRA CR√çTICA: Se prefer√™ncia N√ÉO est√° marcada E usu√°rio tem plano que permite E tem API pr√≥pria ‚Üí usar API pr√≥pria
        let useLaozhang = false;
        let apiKeyToUse = null;
        let serviceToUse = null;
        let apiCallFunction = null;
        
        try {
            // Determinar ordem de prefer√™ncia baseado no modelo
            let preferenceOrder = ['claude', 'openai', 'gemini'];
            if (model.startsWith('gemini')) preferenceOrder = ['gemini', 'claude', 'openai'];
            else if (model.startsWith('claude')) preferenceOrder = ['claude', 'openai', 'gemini'];
            else if (model.startsWith('gpt')) preferenceOrder = ['openai', 'claude', 'gemini'];
            
            const creditsCheck = await shouldUseCredits(userId, preferenceOrder);
            
            if (creditsCheck.shouldUse) {
                // Se deve usar cr√©ditos, usar laozhang.ai
                const laozhangKey = await getLaozhangApiKey();
                if (laozhangKey) {
                    useLaozhang = true;
                    apiKeyToUse = laozhangKey;
                    serviceToUse = 'laozhang';
                    apiCallFunction = callLaozhangAPI;
                    console.log(`[Analyze Competitor] ‚úÖ Usando Laozhang.ai (${creditsCheck.reason})`);
                } else {
                    console.warn('[Analyze Competitor] ‚ö†Ô∏è Laozhang.ai n√£o configurada, tentando usar APIs pr√≥prias do usu√°rio');
                }
            } else {
                console.log(`[Analyze Competitor] ‚úÖ Usando API pr√≥pria (${creditsCheck.reason})`);
            }
        } catch (err) {
            console.warn('[Analyze Competitor] Erro ao verificar uso de cr√©ditos:', err.message);
        }
        
        // Se n√£o usar laozhang.ai, usar APIs pr√≥prias do usu√°rio
        if (!useLaozhang) {
            let service;
            if (model.startsWith('gemini')) service = 'gemini';
            else if (model.startsWith('claude')) service = 'claude';
            else if (model.startsWith('gpt')) service = 'openai';
            else return res.status(400).json({ msg: 'Modelo de IA inv√°lido.' });
            
            serviceToUse = service;
            
            const userKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (!userKeyData) return res.status(400).json({ msg: `Nenhuma Chave de API do ${service} configurada.` });
            
            apiKeyToUse = decrypt(userKeyData.api_key);
            if (!apiKeyToUse) return res.status(500).json({ msg: 'Falha ao desencriptar a sua chave de API.' });

            if (service === 'gemini') apiCallFunction = callGeminiAPI;
            else if (service === 'claude') apiCallFunction = callClaudeAPI;
            else apiCallFunction = callOpenAIAPI;
        }
        
        // Chamar API apropriada
        let response;
        if (useLaozhang) {
            response = await callLaozhangAPI(
                prompt, 
                apiKeyToUse, 
                model, 
                null, 
                userId, 
                '/api/niche/analyze-competitor', 
                JSON.stringify({ endpoint: '/api/niche/analyze-competitor', model })
            );
            // callLaozhangAPI retorna string diretamente
            response = typeof response === 'string' ? response.trim() : JSON.stringify(response);
            response = { titles: response };
        } else {
            response = await apiCallFunction(prompt, apiKeyToUse, model);
        }
        
        const analysis = parseAIResponse(response.titles, serviceToUse);

        res.status(200).json(analysis);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/niche/analyze-competitor]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});

// === ROTA LAOZHANG PARA AN√ÅLISE DE CONCORRENTES ===
app.post('/api/niche/analyze-competitor/laozhang', authenticateToken, async (req, res) => {
    const { competitorUrl, selectedModel } = req.body;
    const userId = req.user.id;

    if (!competitorUrl) {
        return res.status(400).json({ msg: 'URL do canal √© obrigat√≥ria.' });
    }

    try {
        const laozhangApiKey = await getLaozhangApiKey();
        if (!laozhangApiKey) {
            return res.status(400).json({ msg: 'Chave de API do provedor externo n√£o configurada no painel admin.' });
        }

        // Buscar chave do Gemini/YouTube para buscar dados do canal
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        
        let apiKey = null;
        if (youtubeKeyData) {
            apiKey = youtubeKeyData.api_key.includes(':') ? decrypt(youtubeKeyData.api_key) : youtubeKeyData.api_key;
        } else if (geminiKeyData) {
            apiKey = geminiKeyData.api_key.includes(':') ? decrypt(geminiKeyData.api_key) : geminiKeyData.api_key;
        }
        
        if (!apiKey) {
            return res.status(400).json({ msg: 'Chave de API do YouTube ou Gemini √© necess√°ria para buscar dados do canal.' });
        }

        // Obter ID do canal (mesma l√≥gica da rota original)
        const match = competitorUrl.match(/youtube\.com\/(?:@([\w.-]+)|channel\/([\w-]+))/);
        if (!match) return res.status(400).json({ msg: 'Formato de URL do canal n√£o suportado.' });
        
        let ytChannelId;
        const handle = match[1];
        const legacyId = match[2];

        if (handle) {
            const searchApiUrl = `https://www.googleapis.com/youtube/v3/search?part=id&q=${handle}&type=channel&maxResults=1&key=${apiKey}`;
            const searchResponse = await fetch(searchApiUrl);
            const searchData = await searchResponse.json();
            if (searchResponse.ok && searchData.items && searchData.items.length > 0) {
                ytChannelId = searchData.items[0].id.channelId;
            }
        }

        if (!ytChannelId && legacyId) {
            ytChannelId = legacyId;
        }

        if (!ytChannelId) {
            return res.status(400).json({ msg: 'N√£o foi poss√≠vel identificar o canal a partir da URL fornecida.' });
        }

        // Buscar dados do canal e v√≠deos (mesma l√≥gica da rota original, simplificada)
        const channelUrl = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${ytChannelId}&key=${apiKey}`;
        const channelResponse = await fetch(channelUrl);
        const channelData = await channelResponse.json();

        if (!channelResponse.ok || !channelData.items || channelData.items.length === 0) {
            return res.status(400).json({ msg: 'Canal n√£o encontrado.' });
        }

        const channel = channelData.items[0];
        const competitorData = await getChannelVideosWithDetails(ytChannelId, apiKey, 'viewCount', 5);

        // Criar prompt para an√°lise - usar GPT-4o como padr√£o se n√£o houver modelo selecionado
        const laozhangModel = selectedModel === 'Claude 3.7 Sonnet (Fev/25)' ? 'claude-3-7-sonnet-20250219' :
                             selectedModel === 'Gemini 2.5 Pro (2025)' ? 'gemini-2.5-pro' :
                             selectedModel && selectedModel.trim() ? selectedModel : 'gpt-4o';

        const prompt = `
Voc√™ √© um ESPECIALISTA EM CRIA√á√ÉO DE CANAIS MILION√ÅRIOS NO YOUTUBE.

OBJETIVO: Analisar um canal concorrente de sucesso e fornecer um plano estrat√©gico completo para criar um canal milion√°rio no mesmo nicho.

DADOS DO CANAL ANALISADO:
- NOME: ${channel.snippet.title}
- DESCRI√á√ÉO: ${channel.snippet.description || 'N/A'}
- INSCRITOS: ${channel.statistics.subscriberCount || 'N/A'}
- TOTAL DE V√çDEOS: ${channel.statistics.videoCount || 'N/A'}
- TOTAL DE VIEWS: ${channel.statistics.viewCount || 'N/A'}

V√çDEOS MAIS POPULARES:
${competitorData.map((v, i) => `${i + 1}. "${v.title}" - ${v.views.toLocaleString('pt-BR')} visualiza√ß√µes`).join('\n')}

IMPORTANTE: Responda APENAS com um JSON v√°lido no seguinte formato (sem texto adicional antes ou depois):

{
  "content_strategies": {
    "overview": "Vis√£o geral das estrat√©gias de conte√∫do que fazem este canal ter sucesso",
    "playlist_strategy": "Estrat√©gia de playlists e organiza√ß√£o de conte√∫do (se aplic√°vel)",
    "storytelling": "T√©cnicas de storytelling e narrativa utilizadas",
    "engagement_tactics": "T√°ticas de engajamento que geram milh√µes de views"
  },
  "title_and_thumbnail_patterns": {
    "title_patterns": "Padr√µes identificados nos t√≠tulos que geram alto CTR e milh√µes de views",
    "thumbnail_patterns": "Padr√µes visuais e elementos que aparecem nos thumbnails de sucesso"
  },
  "posting_frequency": {
    "current_frequency": "An√°lise da frequ√™ncia atual de postagem do canal",
    "recommendation": "Recomenda√ß√£o de frequ√™ncia ideal para maximizar views e engajamento"
  },
  "niche_and_subniches": {
    "primary_niche": "Nicho principal identificado",
    "subniches": [
      "Subnicho 1 explorado",
      "Subnicho 2 explorado",
      "Subnicho 3 explorado"
    ]
  },
  "differentiation_opportunities": {
    "live_interactions": "Oportunidades de intera√ß√£o ao vivo que podem diferenciar seu canal",
    "exclusive_interviews": "Oportunidades de entrevistas exclusivas ou conte√∫do √∫nico",
    "collaborations": "Estrat√©gias de colabora√ß√£o para aumentar alcance",
    "content_gaps": "Lacunas de conte√∫do identificadas que voc√™ pode explorar",
    "unique_angles": "√Çngulos √∫nicos que voc√™ pode usar para se diferenciar"
  },
  "strategic_recommendations": {
    "channel_name_suggestions": [
      "Sugest√£o de nome 1",
      "Sugest√£o de nome 2",
      "Sugest√£o de nome 3"
    ],
    "first_videos_ideas": [
      "Ideia de v√≠deo inicial 1",
      "Ideia de v√≠deo inicial 2",
      "Ideia de v√≠deo inicial 3"
    ],
    "growth_strategy": "Estrat√©gia completa de crescimento para alcan√ßar milh√µes de views",
    "monetization_opportunities": "Oportunidades de monetiza√ß√£o espec√≠ficas para este nicho"
  }
}

Responda APENAS com o JSON, sem texto adicional antes ou depois.
`;

        const response = await callLaozhangAPI(
            prompt,
            laozhangApiKey,
            laozhangModel,
            null,
            userId,
            'api_niche_analyze_competitor',
            JSON.stringify({ endpoint: '/api/niche/analyze-competitor/laozhang', model: laozhangModel })
        );

        // Tentar extrair JSON da resposta
        let analysis = typeof response === 'string' ? response.trim() : JSON.stringify(response);
        
        // Tentar parsear JSON se a resposta cont√©m JSON
        try {
            const jsonMatch = analysis.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                analysis = parsed;
            }
        } catch (e) {
            console.warn('[Analyze Competitor] Falha ao parsear JSON, retornando texto:', e.message);
        }
        
        res.status(200).json(analysis);

    } catch (err) {
        console.error('[ERRO NA ROTA /api/niche/analyze-competitor/laozhang]:', err);
        res.status(500).json({ msg: err.message || 'Erro interno do servidor.' });
    }
});


// === ROTAS DE ADMIN ===

app.get('/api/admin/stats', authenticateToken, isAdmin, async (req, res) => {
    try {
        const totalUsers = await db.get('SELECT COUNT(*) as count FROM users');
        const pendingUsers = await db.get('SELECT COUNT(*) as count FROM users WHERE isApproved = 0');
        const onlineUsers = await db.get("SELECT COUNT(*) as count FROM users WHERE last_login_at > datetime('now', '-15 minutes')");
        const logins24h = await db.get("SELECT COUNT(*) as count FROM users WHERE last_login_at > datetime('now', '-24 hours')");

        res.json({
            totalUsers: totalUsers.count,
            pendingUsers: pendingUsers.count,
            onlineUsers: onlineUsers.count,
            logins24h: logins24h.count
        });
    } catch (err) {
        console.error('Erro ao buscar estat√≠sticas admin:', err);
        res.status(500).json({ msg: 'Erro ao buscar estat√≠sticas.' });
    }
});

app.get('/api/admin/users', authenticateToken, isAdmin, async (req, res) => {
    const { search, status } = req.query;
    try {
        let query = 'SELECT id, name, email, whatsapp, isAdmin, isBlocked, isApproved, plan, subscription_plan, created_at FROM users';
        const params = [];
        const conditions = [];

        if (search) {
            conditions.push('(email LIKE ? OR whatsapp LIKE ? OR name LIKE ?)');
            params.push(`%${search}%`, `%${search}%`, `%${search}%`);
        }

        if (status) {
            if (status === 'pending') conditions.push('isApproved = 0');
            if (status === 'active') conditions.push('isApproved = 1 AND isBlocked = 0');
            if (status === 'blocked') conditions.push('isBlocked = 1');
        }

        if (conditions.length > 0) {
            query += ' WHERE ' + conditions.join(' AND ');
        }
        
        const users = await db.all(query, params);
        res.json(users);
    } catch (err) {
        console.error('Erro ao buscar utilizadores admin:', err);
        res.status(500).json({ msg: 'Erro no servidor.' });
    }
});

app.post('/api/admin/users/approve-all', authenticateToken, isAdmin, async (req, res) => {
    try {
        await db.run('UPDATE users SET isApproved = 1 WHERE isApproved = 0');
        res.status(200).json({ msg: 'Todos os utilizadores pendentes foram aprovados.' });
    } catch (err) {
        console.error('Erro ao aprovar todos os utilizadores:', err);
        res.status(500).json({ msg: 'Erro ao aprovar utilizadores.' });
    }
});

app.put('/api/admin/users/:id', authenticateToken, isAdmin, async (req, res) => {
    const { id } = req.params;
    const { name, whatsapp, isAdmin, isBlocked, isApproved } = req.body;
    try {
        await db.run('UPDATE users SET name = ?, whatsapp = ?, isAdmin = ?, isBlocked = ?, isApproved = ? WHERE id = ?', [name, whatsapp, isAdmin, isBlocked, isApproved, id]);
        res.status(200).json({ msg: 'Utilizador atualizado com sucesso.' });
    } catch (err) {
        res.status(500).json({ msg: 'Erro ao atualizar utilizador.' });
    }
});

app.put('/api/admin/users/:id/password', authenticateToken, isAdmin, async (req, res) => {
    const { id } = req.params;
    const { password } = req.body;
    if (!password || password.length < 6) {
        return res.status(400).json({ msg: 'A senha deve ter pelo menos 6 caracteres.' });
    }
    try {
        // Obter dados do usu√°rio antes de atualizar
        const userData = await db.get('SELECT name, email FROM users WHERE id = ?', [id]);
        if (!userData) {
            return res.status(404).json({ msg: 'Usu√°rio n√£o encontrado.' });
        }
        
        const salt = await bcrypt.genSalt(10);
        const password_hash = await bcrypt.hash(password, salt);
        await db.run('UPDATE users SET password_hash = ? WHERE id = ?', [password_hash, id]);
        
        // Enviar email de senha provis√≥ria
        try {
            const protocol = req.protocol;
            const host = req.get('host');
            const loginUrl = `${protocol}://${host}/la-casa-dark-core-auth.html`;
            
            await sendTemplateEmail('password_reset', userData.email, {
                nome: userData.name,
                email: userData.email,
                senha_provisoria: password,
                link_acesso: loginUrl
            });
        } catch (emailError) {
            console.error('[EMAIL] Erro ao enviar email de senha provis√≥ria:', emailError.message);
            // N√£o falhar a opera√ß√£o se o email falhar
        }
        
        res.status(200).json({ msg: 'Senha atualizada com sucesso e email enviado.' });
    } catch (err) {
        res.status(500).json({ msg: 'Erro ao atualizar a senha.' });
    }
});

// Fun√ß√£o para adicionar cr√©ditos autom√°ticos baseado no plano
async function addPlanCredits(userId, planName, isRenewal = false) {
    try {
        // Obter cr√©ditos do plano
        const planCredits = await db.get('SELECT monthly_credits FROM plan_credits WHERE plan_name = ?', [planName]);
        if (!planCredits) {
            console.warn(`[PLAN CREDITS] Plano ${planName} n√£o encontrado na tabela plan_credits`);
            return;
        }
        
        const creditsToAdd = planCredits.monthly_credits;
        if (creditsToAdd <= 0) return;
        
        // Verificar se usu√°rio j√° tem cr√©ditos
        let userCredits = await db.get('SELECT balance FROM user_credits WHERE user_id = ?', [userId]);
        
        if (!userCredits) {
            // Criar registro de cr√©ditos
            await db.run('INSERT INTO user_credits (user_id, balance) VALUES (?, ?)', [userId, creditsToAdd]);
        } else {
            // Adicionar cr√©ditos
            await db.run(
                'UPDATE user_credits SET balance = balance + ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?',
                [creditsToAdd, userId]
            );
        }
        
        // Registrar transa√ß√£o
        await db.run(`
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description)
            VALUES (?, ?, 'credit', ?)
        `, [userId, creditsToAdd, isRenewal ? `Renova√ß√£o mensal de cr√©ditos - Plano ${planName}` : `Cr√©ditos iniciais - Plano ${planName}`]);
        
        // Registrar renova√ß√£o
        const isAnnual = planName.includes('annual');
        const nextRenewal = new Date();
        nextRenewal.setMonth(nextRenewal.getMonth() + 1);
        
        await db.run(`
            INSERT INTO credit_renewals (user_id, plan_name, credits_added, renewal_date, next_renewal_date, is_annual)
            VALUES (?, ?, ?, CURRENT_TIMESTAMP, ?, ?)
        `, [userId, planName, creditsToAdd, nextRenewal.toISOString(), isAnnual ? 1 : 0]);
        
        console.log(`[PLAN CREDITS] ${creditsToAdd} cr√©ditos adicionados ao usu√°rio ${userId} (Plano: ${planName})`);
    } catch (error) {
        console.error('[PLAN CREDITS] Erro ao adicionar cr√©ditos:', error);
    }
}

// Fun√ß√£o para verificar e renovar cr√©ditos mensalmente
async function checkAndRenewCredits() {
    try {
        // Buscar usu√°rios com planos ativos que precisam renovar
        const usersToRenew = await db.all(`
            SELECT u.id, u.subscription_plan, u.plan, cr.next_renewal_date
            FROM users u
            LEFT JOIN credit_renewals cr ON u.id = cr.user_id
            WHERE (u.subscription_plan IS NOT NULL AND u.subscription_plan != 'plan-free')
               OR (u.plan IS NOT NULL AND u.plan != 'plan-free')
            GROUP BY u.id
            HAVING MAX(cr.next_renewal_date) < datetime('now')
               OR MAX(cr.next_renewal_date) IS NULL
        `);
        
        for (const user of usersToRenew) {
            const planName = user.subscription_plan || user.plan;
            if (planName && planName !== 'plan-free') {
                await addPlanCredits(user.id, planName, true);
            }
        }
        
        console.log(`[PLAN CREDITS] Verifica√ß√£o de renova√ß√£o conclu√≠da. ${usersToRenew.length} usu√°rios processados.`);
    } catch (error) {
        console.error('[PLAN CREDITS] Erro ao verificar renova√ß√µes:', error);
    }
}

// Executar verifica√ß√£o de renova√ß√£o a cada hora
setInterval(checkAndRenewCredits, 60 * 60 * 1000); // 1 hora

// PUT /api/admin/users/:id/plan - Alterar plano do usu√°rio
app.put('/api/admin/users/:id/plan', authenticateToken, isAdmin, async (req, res) => {
    try {
        const userId = parseInt(req.params.id);
        const { plan } = req.body;
        
        if (!plan) {
            return res.status(400).json({ message: 'Plano √© obrigat√≥rio' });
        }
        
        const validPlans = ['plan-free', 'plan-start', 'plan-turbo', 'plan-master', 'plan-start-annual', 'plan-turbo-annual', 'plan-master-annual'];
        if (!validPlans.includes(plan)) {
            return res.status(400).json({ message: 'Plano inv√°lido' });
        }
        
        const user = await db.get('SELECT id, email FROM users WHERE id = ?', [userId]);
        if (!user) {
            return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });
        }
        
        // Atualizar plano
        await db.run('UPDATE users SET subscription_plan = ?, plan = ? WHERE id = ?', [plan, plan, userId]);
        
        // Adicionar cr√©ditos autom√°ticos se n√£o for plano free
        if (plan !== 'plan-free') {
            await addPlanCredits(userId, plan, false);
        }
        
        res.json({ 
            message: 'Plano alterado com sucesso',
            plan: plan
        });
    } catch (error) {
        console.error('Erro ao alterar plano:', error);
        res.status(500).json({ message: 'Erro ao alterar plano' });
    }
});

app.put('/api/admin/users/:id/status', authenticateToken, isAdmin, async (req, res) => {
    const { id } = req.params;
    const { isBlocked } = req.body;
    try {
        await db.run('UPDATE users SET isBlocked = ? WHERE id = ?', [isBlocked, id]);
        res.status(200).json({ msg: `Utilizador ${isBlocked ? 'bloqueado' : 'desbloqueado'} com sucesso.` });
    } catch (err) {
        res.status(500).json({ msg: 'Erro ao alterar o status do utilizador.' });
    }
});

app.delete('/api/admin/users/:id', authenticateToken, isAdmin, async (req, res) => {
    const { id } = req.params;
    if (parseInt(id, 10) === req.user.id) {
        return res.status(400).json({ msg: 'N√£o pode excluir a sua pr√≥pria conta de administrador.' });
    }
    try {
        await db.run('DELETE FROM users WHERE id = ?', [id]);
        res.status(200).json({ msg: 'Utilizador exclu√≠do com sucesso.' });
    } catch (err) {
        res.status(500).json({ msg: 'Erro ao excluir utilizador.' });
    }
});


// === ROTAS DE PASTAS E HIST√ìRICO ===

app.post('/api/folders', authenticateToken, async (req, res) => {
    const { name } = req.body;
    const userId = req.user.id;

    if (!name) {
        return res.status(400).json({ msg: 'O nome da pasta √© obrigat√≥rio.' });
    }
    try {
        const result = await db.run(
            'INSERT INTO analysis_folders (user_id, name) VALUES (?, ?)',
            [userId, name]
        );
        res.status(201).json({ id: result.lastID, name });
    } catch (err) {
        console.error('Erro ao criar pasta:', err);
        res.status(500).json({ msg: 'Erro no servidor ao criar pasta.' });
    }
});

app.get('/api/folders', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    try {
        const folders = await db.all('SELECT id, name FROM analysis_folders WHERE user_id = ? ORDER BY name', [userId]);
        res.status(200).json(folders);
    } catch (err) {
        console.error('Erro ao listar pastas:', err);
        res.status(500).json({ msg: 'Erro no servidor ao listar pastas.' });
    }
});

app.delete('/api/folders/:folderId', authenticateToken, async (req, res) => {
    const { folderId } = req.params;
    const userId = req.user.id;
    try {
        const result = await db.run(
            'DELETE FROM analysis_folders WHERE id = ? AND user_id = ?',
            [folderId, userId]
        );
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Pasta n√£o encontrada ou n√£o pertence a este utilizador.' });
        }
        res.status(200).json({ msg: 'Pasta exclu√≠da com sucesso. As an√°lises foram movidas para o Hist√≥rico Geral.' });
    } catch (err) {
        console.error('Erro ao excluir pasta:', err);
        res.status(500).json({ msg: 'Erro no servidor ao excluir pasta.' });
    }
});
app.get('/api/history', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { folderId, page = 1, limit = 50, search, niche, dateFilter } = req.query;
    
    try {
        const pageNum = parseInt(page) || 1;
        const limitNum = parseInt(limit) || 50;
        const offset = (pageNum - 1) * limitNum;
        
        let baseWhere = 'user_id = ?';
        let params = [userId];
        let countParams = [userId];
        
        if (folderId) {
            baseWhere += ' AND folder_id = ?';
            params.push(folderId);
            countParams.push(folderId);
        } else {
            baseWhere += ' AND folder_id IS NULL';
        }
        
        // Filtro de busca
        if (search) {
            baseWhere += ' AND original_title LIKE ?';
            params.push(`%${search}%`);
            countParams.push(`%${search}%`);
        }
        
        // Filtro de nicho
        if (niche) {
            baseWhere += ' AND detected_subniche LIKE ?';
            params.push(`%${niche}%`);
            countParams.push(`%${niche}%`);
        }
        
        // Filtro de data
        if (dateFilter) {
            const now = new Date();
            let dateStart;
            switch (dateFilter) {
                case 'today':
                    dateStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    break;
                case 'week':
                    dateStart = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    break;
                case 'month':
                    dateStart = new Date(now.getFullYear(), now.getMonth(), 1);
                    break;
                case 'year':
                    dateStart = new Date(now.getFullYear(), 0, 1);
                    break;
            }
            if (dateStart) {
                baseWhere += ' AND analyzed_at >= ?';
                params.push(dateStart.toISOString());
                countParams.push(dateStart.toISOString());
            }
        }
        
        let query = `SELECT id, original_title, detected_subniche, analyzed_at FROM analyzed_videos WHERE ${baseWhere} ORDER BY analyzed_at DESC LIMIT ? OFFSET ?`;
        params.push(limitNum, offset);
        
        let countQuery = `SELECT COUNT(*) as total FROM analyzed_videos WHERE ${baseWhere}`;
        
        const [history, totalResult] = await Promise.all([
            db.all(query, params),
            db.get(countQuery, countParams)
        ]);
        
        // Garantir que history √© sempre um array
        const historyArray = Array.isArray(history) ? history : [];
        
        const total = totalResult?.total || 0;
        const totalPages = Math.ceil(total / limitNum);
        
        res.status(200).json({
            data: historyArray,
            pagination: {
                page: pageNum,
                limit: limitNum,
                total: total,
                totalPages: totalPages,
                hasNext: pageNum < totalPages,
                hasPrev: pageNum > 1
            }
        });
        
    } catch (err) {
        console.error('Erro ao listar hist√≥rico:', err);
        res.status(500).json({ msg: 'Erro no servidor ao listar hist√≥rico.' });
    }
});

app.delete('/api/history', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { ids } = req.body;

    if (!ids || !Array.isArray(ids) || ids.length === 0) {
        return res.status(400).json({ msg: 'Nenhum ID de an√°lise fornecido.' });
    }

    try {
        const placeholders = ids.map(() => '?').join(',');
        const result = await db.run(
            `DELETE FROM analyzed_videos WHERE id IN (${placeholders}) AND user_id = ?`,
            [...ids, userId]
        );
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Nenhuma an√°lise encontrada ou n√£o pertence a este utilizador.' });
        }
        
        res.status(200).json({ msg: `${result.changes} an√°lise(s) exclu√≠da(s) com sucesso.` });
        
    } catch (err) {
        console.error('Erro ao excluir an√°lises:', err);
        res.status(500).json({ msg: 'Erro no servidor ao excluir an√°lises.' });
    }
});

// Rota para buscar nichos √∫nicos do hist√≥rico
app.get('/api/history/niches', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const niches = await db.all(
            `SELECT DISTINCT detected_subniche as niche 
             FROM analyzed_videos 
             WHERE user_id = ? AND detected_subniche IS NOT NULL AND detected_subniche != '' 
             ORDER BY detected_subniche`,
            [userId]
        );

        const nichesArray = niches.map(row => row.niche).filter(Boolean);
        res.status(200).json({ niches: nichesArray });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/history/niches]:', err);
        res.status(500).json({ msg: 'Erro ao buscar nichos.' });
    }
});

app.get('/api/history/load/:analysisId', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { analysisId } = req.params;

    try {
        const analysis = await db.get(
            'SELECT * FROM analyzed_videos WHERE id = ? AND user_id = ?',
            [analysisId, userId]
        );
        if (!analysis) return res.status(404).json({ msg: 'An√°lise n√£o encontrada.' });

        // Primeiro, verificar quantos t√≠tulos existem no total
        const totalCount = await db.get(
            'SELECT COUNT(*) as total FROM generated_titles WHERE video_analysis_id = ?',
            [analysisId]
        );
        console.log(`[Hist√≥rico] Total de t√≠tulos no banco para an√°lise ${analysisId}: ${totalCount?.total || 0}`);
        
        const titles = await db.all(
            'SELECT id, title_text as titulo, model_used as model, pontuacao, impact_score, explicacao, formula, is_checked FROM generated_titles WHERE video_analysis_id = ? ORDER BY id ASC',
            [analysisId]
        );
        
        // Log para debug: verificar quantos t√≠tulos foram carregados e de quais modelos
        console.log(`[Hist√≥rico] Carregando an√°lise ${analysisId}: ${titles.length} t√≠tulos encontrados (esperado: ${totalCount?.total || 0})`);
        const titlesByModel = {};
        titles.forEach(t => {
            const model = t.model || 'Desconhecido';
            titlesByModel[model] = (titlesByModel[model] || 0) + 1;
        });
        console.log(`[Hist√≥rico] T√≠tulos por modelo:`, titlesByModel);
        
        // Se houver discrep√¢ncia, logar detalhes
        if (titles.length !== (totalCount?.total || 0)) {
            console.error(`[Hist√≥rico] ‚ö†Ô∏è DISCREP√ÇNCIA: ${titles.length} t√≠tulos carregados, mas ${totalCount?.total || 0} existem no banco!`);
        }

        // Calcular receita e RPM baseado no nicho
        const rpm = getRPMByNiche(analysis.detected_niche);
        const views = parseInt(analysis.original_views) || 0;
        const estimatedRevenueUSD = (views / 1000) * rpm.usd;
        const estimatedRevenueBRL = (views / 1000) * rpm.brl;

        const responseData = {
            niche: analysis.detected_niche,
            subniche: analysis.detected_subniche,
            analiseOriginal: JSON.parse(analysis.analysis_data_json || '{}'),
            titulosSugeridos: titles,
            modelUsed: titles.length > 0 ? titles[0].model : 'Carregado',
            videoDetails: {
                title: analysis.original_title,
                translatedTitle: analysis.translated_title || null,
                views: views,
                comments: analysis.original_comments,
                days: analysis.original_days,
                thumbnailUrl: analysis.original_thumbnail_url,
                videoId: analysis.youtube_video_id,
                estimatedRevenueUSD: estimatedRevenueUSD,
                estimatedRevenueBRL: estimatedRevenueBRL,
                rpmUSD: rpm.usd,
                rpmBRL: rpm.brl
            },
            originalVideoUrl: analysis.video_url 
        };
        res.status(200).json(responseData);

    } catch (err) {
        console.error('Erro ao carregar an√°lise:', err);
        res.status(500).json({ msg: 'Erro no servidor ao carregar an√°lise.' });
    }
});


// === ROTAS DE CANAIS MONITORADOS (para an√°lise de canais) ===
app.post('/api/channels/monitor', authenticateToken, async (req, res) => {
    const { channelUrl, channelName } = req.body;
    const userId = req.user.id;

    if (!channelUrl || !channelName) {
        return res.status(400).json({ msg: 'Nome e URL do canal s√£o obrigat√≥rios.' });
    }

    try {
        // Verificar limite de 5 canais por usu√°rio
        const channelCount = await db.get('SELECT COUNT(*) as count FROM monitored_channels WHERE user_id = ?', [userId]);
        if (channelCount && channelCount.count >= 5) {
            return res.status(400).json({ msg: 'Limite de 5 canais monitorados atingido. Exclua um canal antes de adicionar outro.' });
        }

        const result = await db.run(
            'INSERT INTO monitored_channels (user_id, channel_name, channel_url) VALUES (?, ?, ?)',
            [userId, channelName, channelUrl]
        );
        res.status(201).json({ id: result.lastID, channel_name: channelName, channel_url: channelUrl });
    } catch (err) {
        console.error('Erro ao adicionar canal:', err);
        if (err.message.includes('UNIQUE constraint failed')) {
            return res.status(400).json({ msg: 'Este canal j√° est√° sendo monitorado por voc√™.' });
        }
        res.status(500).json({ msg: 'Erro no servidor ao adicionar canal.' });
    }
});

app.get('/api/channels/monitor', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    try {
        if (!db) {
            console.error('[Canais Monitorados] Banco de dados n√£o est√° dispon√≠vel');
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }
        
        const channels = await db.all(
            'SELECT id, channel_name, channel_url, last_checked FROM monitored_channels WHERE user_id = ? ORDER BY channel_name',
            [userId]
        );
        
        console.log(`[Canais Monitorados] Encontrados ${channels.length} canais para usu√°rio ${userId}`);
        res.status(200).json(channels || []);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/monitor]:', err);
        res.status(500).json({ msg: 'Erro no servidor ao listar canais.' });
    }
});

app.delete('/api/channels/monitor/:channelId', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { channelId } = req.params;

    try {
        const result = await db.run(
            'DELETE FROM monitored_channels WHERE id = ? AND user_id = ?',
            [channelId, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Canal n√£o encontrado ou n√£o pertence a este utilizador.' });
        }
        
        res.status(200).json({ msg: 'Canal removido com sucesso.' });
    } catch (err) {
        console.error('Erro ao excluir canal:', err);
        res.status(500).json({ msg: 'Erro no servidor ao excluir canal.' });
    }
});

app.get('/api/channels/monitor/:channelId/check', authenticateToken, async (req, res) => {
    const { channelId } = req.params;
    const userId = req.user.id;
    try {
        const channel = await db.get('SELECT channel_url FROM monitored_channels WHERE id = ? AND user_id = ?', [channelId, userId]);
        if (!channel) {
            return res.status(404).json({ msg: 'Canal n√£o encontrado.' });
        }

        // Buscar chave do YouTube primeiro, se n√£o encontrar, usar Gemini como fallback
        let youtubeApiKey = null;
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData && youtubeKeyData.api_key) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
            if (!youtubeApiKey && youtubeKeyData.api_key && !youtubeKeyData.api_key.includes(':')) {
                youtubeApiKey = youtubeKeyData.api_key;
            }
        }
        
        // Se n√£o encontrou chave do YouTube, tentar usar Gemini como fallback
        if (!youtubeApiKey) {
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData && geminiKeyData.api_key) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
                if (!youtubeApiKey && geminiKeyData.api_key && !geminiKeyData.api_key.includes(':')) {
                    youtubeApiKey = geminiKeyData.api_key;
                }
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ msg: 'Chave de API do YouTube ou Gemini √© necess√°ria para esta fun√ß√£o. Configure uma delas nas configura√ß√µes.' });
        }

        // Extrair ID do canal da URL (suporta m√∫ltiplos formatos)
        let ytChannelId = null;
        let channelUrl = channel.channel_url.trim();
        
        console.log(`[Canais Monitorados] Tentando extrair ID do canal da URL: ${channelUrl}`);
        
        // Se for URL de v√≠deo, extrair o canal do v√≠deo
        // Suporta m√∫ltiplos formatos: youtube.com/watch?v=, youtu.be/, youtube.com/embed/, etc.
        const videoMatch = channelUrl.match(/(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
        if (videoMatch) {
            try {
                const videoId = videoMatch[1];
                console.log(`[Canais Monitorados] URL de v√≠deo detectada, ID do v√≠deo: ${videoId}`);
                const videoUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${youtubeApiKey}`;
                const videoResponse = await fetch(videoUrl);
                const videoData = await videoResponse.json();
                
                if (!videoResponse.ok) {
                    console.error(`[Canais Monitorados] Erro na API do YouTube ao buscar v√≠deo: ${videoResponse.status}`, videoData);
                } else if (videoData.items && videoData.items.length > 0) {
                    ytChannelId = videoData.items[0].snippet.channelId;
                    console.log(`[Canais Monitorados] Canal ID extra√≠do do v√≠deo: ${ytChannelId}`);
                } else {
                    console.warn(`[Canais Monitorados] V√≠deo n√£o encontrado na API do YouTube: ${videoId}`);
                }
            } catch (videoErr) {
                console.error('[Canais Monitorados] Erro ao extrair canal do v√≠deo:', videoErr);
            }
        } else {
            console.log(`[Canais Monitorados] URL n√£o √© de v√≠deo, tentando formatos de canal...`);
        }
        
        // Se n√£o encontrou via v√≠deo, tentar formatos de canal
        if (!ytChannelId) {
            // Regex melhorada para capturar mais formatos, incluindo URLs truncadas
            // Suporta: @handle, /channel/ID, /c/ID, /user/ID, ou ID direto (UC...)
            let match = channelUrl.match(/youtube\.com\/(?:@([\w.-]+)|channel\/([\w-]+)|c\/([\w-]+)|user\/([\w-]+)|(?:embed\/)?([\w-]{24}))/);
            
            // Se n√£o encontrou, tentar formatos alternativos
            if (!match) {
                // Tentar capturar handle mesmo em URLs truncadas ou sem dom√≠nio completo
                match = channelUrl.match(/@([\w.-]+)/);
                if (match) {
                    match = [null, match[1], null, null, null, null];
                }
                // Tentar capturar ID de canal direto (UC...)
                else if (channelUrl.match(/^UC[\w-]{22}$/)) {
                    match = [null, null, channelUrl, null, null, null];
                }
            }
            
            if (match) {
                const handle = match[1];
                const legacyId = match[2] || match[3] || match[4] || match[5];

                if (handle) {
                    try {
                        console.log(`[Canais Monitorados] Tentando buscar canal por handle: @${handle}`);
                        // Tentar buscar via channels.list primeiro (mais preciso)
                        const channelsApiUrl = `https://www.googleapis.com/youtube/v3/channels?part=id&forHandle=${encodeURIComponent(handle)}&key=${youtubeApiKey}`;
                        const channelsResponse = await fetch(channelsApiUrl);
                        const channelsData = await channelsResponse.json();
                        
                        if (channelsResponse.ok && channelsData.items && channelsData.items.length > 0) {
                            ytChannelId = channelsData.items[0].id;
                            console.log(`[Canais Monitorados] Canal ID encontrado via channels.list: ${ytChannelId}`);
                        } else {
                            // Fallback: usar search
                            console.log(`[Canais Monitorados] Tentando buscar via search como fallback`);
                            const searchApiUrl = `https://www.googleapis.com/youtube/v3/search?part=id,snippet&q=${encodeURIComponent('@' + handle)}&type=channel&maxResults=1&key=${youtubeApiKey}`;
                            const searchResponse = await fetch(searchApiUrl);
                            const searchData = await searchResponse.json();

                            if (searchResponse.ok && searchData.items && searchData.items.length > 0) {
                                ytChannelId = searchData.items[0].id.channelId;
                                console.log(`[Canais Monitorados] Canal ID encontrado via search: ${ytChannelId}`);
                            } else {
                                console.warn(`[Canais Monitorados] Nenhum canal encontrado para handle: @${handle}`);
                            }
                        }
                    } catch (searchErr) {
                        console.error(`[Canais Monitorados] Erro ao buscar canal por handle:`, searchErr);
                    }
                } else if (legacyId) {
                    // Tentar validar se √© um ID de canal v√°lido
                    console.log(`[Canais Monitorados] Tentando validar ID de canal: ${legacyId}`);
                    // IDs de canal do YouTube come√ßam com UC e t√™m 24 caracteres
                    if (legacyId.length >= 24 || legacyId.startsWith('UC')) {
                        // Verificar se √© um ID v√°lido fazendo uma busca
                        try {
                            const validateUrl = `https://www.googleapis.com/youtube/v3/channels?part=id&id=${legacyId}&key=${youtubeApiKey}`;
                            const validateResponse = await fetch(validateUrl);
                            const validateData = await validateResponse.json();
                            
                            if (validateResponse.ok && validateData.items && validateData.items.length > 0) {
                                ytChannelId = legacyId;
                                console.log(`[Canais Monitorados] ID de canal validado: ${ytChannelId}`);
                            } else {
                                console.warn(`[Canais Monitorados] ID de canal n√£o √© v√°lido: ${legacyId}`);
                            }
                        } catch (validateErr) {
                            console.error(`[Canais Monitorados] Erro ao validar ID:`, validateErr);
                        }
                    }
                }
            } else {
                console.warn(`[Canais Monitorados] N√£o foi poss√≠vel fazer match da URL: ${channelUrl}`);
            }
        }

        if (!ytChannelId) {
            return res.status(400).json({ msg: 'N√£o foi poss√≠vel determinar o ID do canal. Verifique se a URL est√° correta. Formatos suportados: @handle, /channel/ID, /c/ID, /user/ID, ou URL de v√≠deo.' });
        }

        // Fetch latest, popular, and pinned videos com tratamento de erro robusto
        let latestVideos = [];
        let popularVideos = [];
        let pinnedVideoIds = [];
        
        try {
            const results = await Promise.allSettled([
                getChannelVideosWithDetails(ytChannelId, youtubeApiKey, 'date', 5).catch(err => {
                    console.error('[Canais Monitorados] Erro ao buscar v√≠deos recentes:', err);
                    return [];
                }),
                getChannelVideosWithDetails(ytChannelId, youtubeApiKey, 'viewCount', 5).catch(err => {
                    console.error('[Canais Monitorados] Erro ao buscar v√≠deos populares:', err);
                    return [];
                }),
                db.all('SELECT id, youtube_video_id FROM pinned_videos WHERE user_id = ? AND monitored_channel_id = ? ORDER BY pinned_at DESC', [userId, channelId]).catch(err => {
                    console.error('[Canais Monitorados] Erro ao buscar v√≠deos fixados:', err);
                    return [];
                })
            ]);
            
            if (results[0].status === 'fulfilled') latestVideos = Array.isArray(results[0].value) ? results[0].value : [];
            if (results[1].status === 'fulfilled') popularVideos = Array.isArray(results[1].value) ? results[1].value : [];
            if (results[2].status === 'fulfilled') pinnedVideoIds = Array.isArray(results[2].value) ? results[2].value : [];
        } catch (fetchErr) {
            console.error('[Canais Monitorados] Erro ao buscar v√≠deos:', fetchErr);
            // Continuar com arrays vazios
        }

        let pinnedVideos = [];
        if (pinnedVideoIds.length > 0) {
            try {
                const idsToFetch = pinnedVideoIds.map(p => p.youtube_video_id).filter(id => id).join(',');
                if (!idsToFetch) {
                    console.warn('[Canais Monitorados] Nenhum ID v√°lido para v√≠deos fixados');
                } else {
                    const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${idsToFetch}&key=${youtubeApiKey}`;
                    const detailsResponse = await fetch(detailsUrl);
                    
                    if (!detailsResponse.ok) {
                        const errorText = await detailsResponse.text();
                        console.error('[Canais Monitorados] Erro ao buscar v√≠deos fixados:', detailsResponse.status, errorText.substring(0, 200));
                    } else {
                        const detailsData = await detailsResponse.json();
                        if (detailsData.items && Array.isArray(detailsData.items)) {
                            // Calcular receita e RPM para v√≠deos fixados
                            pinnedVideos = detailsData.items.map(item => {
                                const pinData = pinnedVideoIds.find(p => p.youtube_video_id === item.id);
                                const views = parseInt(item.statistics.viewCount || 0);
                                // Buscar nicho do canal para calcular RPM correto
                                // Por enquanto usar padr√£o, pode ser melhorado buscando do user_channels
                                const rpm = getRPMByNiche(null);
                                const estimatedRevenueUSD = (views / 1000) * rpm.usd;
                                const estimatedRevenueBRL = (views / 1000) * rpm.brl;
                                
                                return {
                                    pinId: pinData.id,
                                    videoId: item.id,
                                    title: item.snippet.title,
                                    thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default?.url || '',
                                    views: views,
                                    likes: parseInt(item.statistics.likeCount || 0),
                                    comments: parseInt(item.statistics.commentCount || 0),
                                    estimatedRevenueUSD: estimatedRevenueUSD,
                                    estimatedRevenueBRL: estimatedRevenueBRL,
                                    rpmUSD: rpm.usd,
                                    rpmBRL: rpm.brl
                                };
                            });
                        }
                    }
                }
            } catch (pinnedErr) {
                console.error('[Canais Monitorados] Erro ao processar v√≠deos fixados:', pinnedErr);
                // Continuar com array vazio
            }
        }
        
        try {
            await db.run('UPDATE monitored_channels SET last_checked = CURRENT_TIMESTAMP WHERE id = ?', [channelId]);
        } catch (updateErr) {
            console.warn('[Canais Monitorados] Erro ao atualizar last_checked:', updateErr);
            // N√£o bloquear a resposta por causa disso
        }
        
        res.status(200).json({
            latest: Array.isArray(latestVideos) ? latestVideos : [],
            popular: Array.isArray(popularVideos) ? popularVideos : [],
            pinned: Array.isArray(pinnedVideos) ? pinnedVideos : []
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/monitor/:channelId/check]:', err);
        // Sempre retornar JSON, nunca HTML
        res.status(500).json({ msg: err.message || 'Erro ao buscar v√≠deos do canal.' });
    }
});

app.get('/api/channels/:channelId/pinned', authenticateToken, async (req, res) => {
    const { channelId } = req.params;
    const userId = req.user.id;
    try {
        // Buscar chave do YouTube primeiro, se n√£o encontrar, usar Gemini como fallback
        let youtubeApiKey = null;
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData && youtubeKeyData.api_key) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
            if (!youtubeApiKey && youtubeKeyData.api_key && !youtubeKeyData.api_key.includes(':')) {
                youtubeApiKey = youtubeKeyData.api_key;
            }
        }
        
        // Se n√£o encontrou chave do YouTube, tentar usar Gemini como fallback
        if (!youtubeApiKey) {
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData && geminiKeyData.api_key) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
                if (!youtubeApiKey && geminiKeyData.api_key && !geminiKeyData.api_key.includes(':')) {
                    youtubeApiKey = geminiKeyData.api_key;
                }
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ msg: 'Chave de API do YouTube ou Gemini √© necess√°ria. Configure uma delas nas configura√ß√µes.' });
        }

        const pinnedVideoIds = await db.all('SELECT id, youtube_video_id FROM pinned_videos WHERE user_id = ? AND monitored_channel_id = ? ORDER BY pinned_at DESC', [userId, channelId]);
        
        if (pinnedVideoIds.length === 0) {
            return res.json([]);
        }

        const idsToFetch = pinnedVideoIds.map(p => p.youtube_video_id).join(',');
        const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${idsToFetch}&key=${youtubeApiKey}`;
        const detailsResponse = await fetch(detailsUrl);
        const detailsData = await detailsResponse.json();
        
        let pinnedVideos = [];
        if (detailsResponse.ok && detailsData.items) {
            pinnedVideos = detailsData.items.map(item => {
                const pinData = pinnedVideoIds.find(p => p.youtube_video_id === item.id);
                return {
                    pinId: pinData.id,
                    videoId: item.id,
                    title: item.snippet.title,
                    thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default.url,
                    views: item.statistics.viewCount || 0,
                    likes: item.statistics.likeCount || 0,
                    comments: item.statistics.commentCount || 0,
                };
            });
        }
        res.status(200).json(pinnedVideos);

    } catch (err) {
        console.error('Erro ao buscar v√≠deos fixados do canal:', err);
        res.status(500).json({ msg: err.message });
    }
});


// === ROTAS DE V√çDEOS (PIN) ===
app.post('/api/videos/pin', authenticateToken, async (req, res) => {
    const { videoId, title, thumbnail, channelId } = req.body;
    const userId = req.user.id;

    if (!videoId || !title || !thumbnail || !channelId) {
        return res.status(400).json({ msg: 'Dados do v√≠deo e do canal insuficientes.' });
    }

    try {
        const count = await db.get('SELECT COUNT(*) as count FROM pinned_videos WHERE user_id = ? AND monitored_channel_id = ?', [userId, channelId]);
        if (count.count >= 6) {
            return res.status(400).json({ msg: 'Limite de 6 v√≠deos fixados por canal atingido.' });
        }

        await db.run(
            'INSERT INTO pinned_videos (user_id, monitored_channel_id, youtube_video_id, title, thumbnail_url) VALUES (?, ?, ?, ?, ?)',
            [userId, channelId, videoId, title, thumbnail]
        );
        res.status(201).json({ msg: 'V√≠deo fixado com sucesso.' });
    } catch (err) {
        if (err.code === 'SQLITE_CONSTRAINT') {
            return res.status(409).json({ msg: 'Este v√≠deo j√° foi fixado neste canal.' });
        }
        console.error("Erro ao fixar v√≠deo:", err);
        res.status(500).json({ msg: 'Erro no servidor ao fixar v√≠deo.' });
    }
});

app.delete('/api/videos/unpin/:pinId', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { pinId } = req.params;
    try {
        const result = await db.run(
            'DELETE FROM pinned_videos WHERE id = ? AND user_id = ?',
            [pinId, userId]
        );
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'V√≠deo fixado n√£o encontrado ou n√£o pertence a este utilizador.' });
        }
        res.status(200).json({ msg: 'V√≠deo removido dos fixados.' });
    } catch (err) {
        console.error("Erro ao remover v√≠deo fixado:", err);
        res.status(500).json({ msg: 'Erro no servidor ao remover v√≠deo fixado.' });
    }
});

// GET /api/videos/generated - Lista v√≠deos gerados pelo usu√°rio
app.get('/api/videos/generated', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    
    try {
        const videos = await db.all(
            `SELECT id, operation_id, video_uri, prompt, model, aspect_ratio, resolution, created_at 
             FROM generated_videos 
             WHERE user_id = ? 
             ORDER BY created_at DESC 
             LIMIT 50`,
            [userId]
        );
        
        res.status(200).json({ videos: videos || [] });
    } catch (err) {
        console.error("Erro ao listar v√≠deos gerados:", err);
        res.status(500).json({ msg: 'Erro no servidor ao listar v√≠deos gerados.' });
    }
});

// === ROTAS DE ANALYTICS E TRACKING ===

// Registrar tracking de v√≠deo publicado
app.post('/api/analytics/track', authenticateToken, async (req, res) => {
    const { analysisId, youtubeVideoId, titleUsed, thumbnailUsed, predictedCtr, predictedViews, publishedAt } = req.body;
    const userId = req.user.id;

    if (!youtubeVideoId || !titleUsed) {
        return res.status(400).json({ msg: 'YouTube Video ID e t√≠tulo s√£o obrigat√≥rios.' });
    }

    try {
        const result = await db.run(
            `INSERT INTO video_tracking (user_id, analysis_id, youtube_video_id, title_used, thumbnail_used, predicted_ctr, predicted_views, published_at, channel_id)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, analysisId || null, youtubeVideoId, titleUsed, thumbnailUsed || null, predictedCtr || null, predictedViews || null, publishedAt || new Date().toISOString(), req.body.channelId || null]
        );
        res.status(201).json({ id: result.lastID, msg: 'Tracking iniciado com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/track]:', err);
        res.status(500).json({ msg: 'Erro ao registrar tracking.' });
    }
});

// Fun√ß√£o helper para obter RPM baseado no nicho (usada em m√∫ltiplas rotas)
// Fun√ß√£o para analisar canal e detectar nicho/subnicho automaticamente
async function analyzeChannelNiche(channelId, channelName, accessToken, userId) {
    try {
        console.log(`[An√°lise Canal] Analisando canal ${channelId} (${channelName})...`);
        
        // Buscar os 5 v√≠deos mais recentes do canal (reduzido para ser mais r√°pido)
        const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${channelId}&order=date&maxResults=5&type=video`;
        const searchResponse = await fetch(searchUrl, {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        
        if (!searchResponse.ok) {
            console.warn(`[An√°lise Canal] Erro ao buscar v√≠deos do canal ${channelId}`);
            return { niche: null, subniche: null };
        }
        
        const searchData = await searchResponse.json();
        if (!searchData.items || searchData.items.length === 0) {
            console.warn(`[An√°lise Canal] Nenhum v√≠deo encontrado no canal ${channelId}`);
            return { niche: null, subniche: null };
        }
        
        // Extrair t√≠tulos dos v√≠deos
        const videoTitles = searchData.items
            .map(item => item.snippet?.title || '')
            .filter(title => title.length > 0)
            .slice(0, 5); // Limitar a 5 t√≠tulos para an√°lise mais r√°pida
        
        if (videoTitles.length === 0) {
            return { niche: null, subniche: null };
        }
        
        // Buscar chaves de API do usu√°rio para an√°lise
        const keysData = await db.all('SELECT service_name, api_key FROM user_api_keys WHERE user_id = ?', [userId]);
        const keys = {};
        keysData.forEach(k => { keys[k.service_name] = decrypt(k.api_key); });
        
        // Tentar usar Gemini, Claude ou OpenAI (nesta ordem)
        let detectedNiche = null;
        let detectedSubniche = null;
        
        const analysisPrompt = `Voc√™ √© um especialista em an√°lise de conte√∫do do YouTube. Analise os seguintes t√≠tulos de v√≠deos de um canal do YouTube e identifique o NICHO e SUBNICHE do canal.

T√≠tulos dos v√≠deos:
${videoTitles.map((title, i) => `${i + 1}. ${title}`).join('\n')}

Nome do canal: ${channelName}

Analise os padr√µes, temas e assuntos recorrentes nos t√≠tulos para identificar:
- O NICHO principal (categoria ampla: Entretenimento, Educa√ß√£o, Tecnologia, Finan√ßas, Gaming, etc.)
- O SUBNICHE espec√≠fico (√°rea mais espec√≠fica dentro do nicho: Gaming FPS, Finan√ßas Pessoais, Programa√ß√£o Web, etc.)

IMPORTANTE: Responda APENAS com um objeto JSON v√°lido, sem nenhum texto adicional antes ou depois:
{
  "niche": "Nome do nicho principal",
  "subniche": "Nome do subnicho espec√≠fico ou null se n√£o houver subnicho claro"
}

Seja espec√≠fico e preciso. Se n√£o conseguir identificar claramente, use "Entretenimento" como nicho padr√£o e deixe subniche como null.`;

        // Tentar Gemini primeiro
        if (keys.gemini) {
            try {
                const response = await callGeminiAPI(analysisPrompt, keys.gemini, 'gemini-2.0-flash');
                const parsed = parseAIResponse(response.titles, 'gemini');
                if (parsed.niche) {
                    detectedNiche = parsed.niche;
                    detectedSubniche = parsed.subniche || null;
                    console.log(`[An√°lise Canal] Nicho detectado via Gemini: ${detectedNiche} / ${detectedSubniche}`);
                    return { niche: detectedNiche, subniche: detectedSubniche };
                }
            } catch (err) {
                console.warn(`[An√°lise Canal] Erro ao usar Gemini: ${err.message}`);
            }
        }
        
        // Tentar Claude
        if (keys.claude) {
            try {
                const response = await callClaudeAPI(analysisPrompt, keys.claude, 'claude-3-5-haiku-20241022');
                const parsed = parseAIResponse(response.titles, 'claude');
                if (parsed.niche) {
                    detectedNiche = parsed.niche;
                    detectedSubniche = parsed.subniche || null;
                    console.log(`[An√°lise Canal] Nicho detectado via Claude: ${detectedNiche} / ${detectedSubniche}`);
                    return { niche: detectedNiche, subniche: detectedSubniche };
                }
            } catch (err) {
                console.warn(`[An√°lise Canal] Erro ao usar Claude: ${err.message}`);
            }
        }
        
        // Tentar OpenAI
        if (keys.openai) {
            try {
                const response = await callOpenAIAPI(analysisPrompt, keys.openai, 'gpt-4o-mini');
                const parsed = parseAIResponse(response.titles, 'openai');
                if (parsed.niche) {
                    detectedNiche = parsed.niche;
                    detectedSubniche = parsed.subniche || null;
                    console.log(`[An√°lise Canal] Nicho detectado via OpenAI: ${detectedNiche} / ${detectedSubniche}`);
                    return { niche: detectedNiche, subniche: detectedSubniche };
                }
            } catch (err) {
                console.warn(`[An√°lise Canal] Erro ao usar OpenAI: ${err.message}`);
            }
        }
        
        // Se nenhuma IA funcionou, retornar null
        console.warn(`[An√°lise Canal] N√£o foi poss√≠vel detectar nicho para o canal ${channelId}`);
        return { niche: null, subniche: null };
        
    } catch (err) {
        console.error(`[An√°lise Canal] Erro ao analisar canal ${channelId}:`, err.message);
        return { niche: null, subniche: null };
    }
}

function getRPMByNiche(niche) {
    if (!niche) return { usd: 2.0, brl: 11.0 }; // Padr√£o: Entretenimento
    
    const nicheLower = niche.toLowerCase();
    
    // RPMs reais por nicho (USD por 1000 views) - baseado em dados do mercado
    const rpmMap = {
        'finan√ßa': { usd: 15.0, brl: 82.5 },
        'financeiro': { usd: 15.0, brl: 82.5 },
        'investimento': { usd: 18.0, brl: 99.0 },
        'investimentos': { usd: 18.0, brl: 99.0 },
        'educa√ß√£o financeira': { usd: 12.0, brl: 66.0 },
        'tecnologia': { usd: 7.0, brl: 38.5 },
        'tech': { usd: 7.0, brl: 38.5 },
        'programa√ß√£o': { usd: 8.0, brl: 44.0 },
        'gaming': { usd: 3.5, brl: 19.25 },
        'jogos': { usd: 3.5, brl: 19.25 },
        'game': { usd: 3.5, brl: 19.25 },
        'educa√ß√£o': { usd: 5.0, brl: 27.5 },
        'educacional': { usd: 5.0, brl: 27.5 },
        'culin√°ria': { usd: 3.0, brl: 16.5 },
        'receitas': { usd: 3.0, brl: 16.5 },
        'fitness': { usd: 4.0, brl: 22.0 },
        'sa√∫de': { usd: 4.5, brl: 24.75 },
        'entretenimento': { usd: 2.0, brl: 11.0 },
        'vlogs': { usd: 2.5, brl: 13.75 },
        'viagens': { usd: 4.0, brl: 22.0 },
        'hist√≥ria': { usd: 3.5, brl: 19.25 },
        'ci√™ncia': { usd: 5.5, brl: 30.25 },
        'neg√≥cios': { usd: 10.0, brl: 55.0 },
        'empreendedorismo': { usd: 9.0, brl: 49.5 },
        'marketing': { usd: 8.0, brl: 44.0 },
        'vendas': { usd: 9.0, brl: 49.5 }
    };
    
    // Buscar nicho correspondente (busca parcial)
    for (const [key, value] of Object.entries(rpmMap)) {
        if (nicheLower.includes(key)) {
            return value;
        }
    }
    
    // Se n√£o encontrar, retornar padr√£o baseado em palavras-chave
    if (nicheLower.includes('finance') || nicheLower.includes('dinheiro') || nicheLower.includes('invest')) {
        return { usd: 12.0, brl: 66.0 };
    }
    if (nicheLower.includes('tech') || nicheLower.includes('program') || nicheLower.includes('software')) {
        return { usd: 7.0, brl: 38.5 };
    }
    if (nicheLower.includes('game') || nicheLower.includes('jogo')) {
        return { usd: 3.5, brl: 19.25 };
    }
    if (nicheLower.includes('educ') || nicheLower.includes('curso') || nicheLower.includes('aprend')) {
        return { usd: 5.0, brl: 27.5 };
    }
    
    // Padr√£o: Entretenimento
    return { usd: 2.0, brl: 11.0 };
}

// Atualizar m√©tricas de v√≠deo (buscar do YouTube)
app.post('/api/analytics/update/:trackingId', authenticateToken, async (req, res) => {
    const { trackingId } = req.params;
    const userId = req.user.id;

    try {
        // Buscar tracking com informa√ß√µes do canal
        const tracking = await db.get(`
            SELECT vt.youtube_video_id, vt.channel_id, uc.niche 
            FROM video_tracking vt
            LEFT JOIN user_channels uc ON vt.channel_id = uc.id
            WHERE vt.id = ? AND vt.user_id = ?
        `, [trackingId, userId]);
        
        if (!tracking) {
            return res.status(404).json({ msg: 'Tracking n√£o encontrado.' });
        }

        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        if (!geminiKeyData) {
            return res.status(400).json({ msg: 'Chave de API do Gemini √© necess√°ria.' });
        }
        const geminiApiKey = decrypt(geminiKeyData.api_key);

        let videoDetails;
        try {
            videoDetails = await callYouTubeDataAPI(tracking.youtube_video_id, geminiApiKey);
        } catch (apiErr) {
            console.error('[Analytics Update] Erro ao buscar dados do YouTube:', apiErr.message);
            return res.status(500).json({ msg: `Erro ao buscar dados do YouTube: ${apiErr.message}` });
        }
        
        // Calcular CTR estimado (YouTube n√£o fornece CTR diretamente, ent√£o estimamos)
        // Usar uma f√≥rmula mais realista baseada nas views
        // V√≠deos com muitas views geralmente t√™m CTR mais baixo, v√≠deos novos podem ter CTR mais alto
        const views = parseInt(videoDetails.views) || 0;
        let estimatedCtr = 0;
        if (views > 0) {
            // F√≥rmula mais realista: CTR diminui conforme views aumentam
            // V√≠deos com 1K views: ~15% CTR, 10K views: ~10% CTR, 100K views: ~5% CTR, 1M views: ~3% CTR
            if (views < 10000) {
                estimatedCtr = 15 - (views / 10000) * 5; // 15% a 10%
            } else if (views < 100000) {
                estimatedCtr = 10 - ((views - 10000) / 90000) * 5; // 10% a 5%
            } else if (views < 1000000) {
                estimatedCtr = 5 - ((views - 100000) / 900000) * 2; // 5% a 3%
            } else {
                estimatedCtr = Math.max(2, 3 - ((views - 1000000) / 10000000) * 1); // 3% a 2%
            }
            estimatedCtr = Math.max(2, Math.min(30, estimatedCtr)); // Limitar entre 2% e 30%
        }
        
        // Calcular receita baseada no RPM do nicho do canal
        const rpm = getRPMByNiche(tracking.niche);
        const estimatedRevenue = (views / 1000) * rpm.usd;

        await db.run(
            `UPDATE video_tracking 
             SET actual_views = ?, actual_likes = ?, actual_comments = ?, actual_ctr = ?, revenue_estimate = ?, last_updated = CURRENT_TIMESTAMP
             WHERE id = ?`,
            [videoDetails.views, videoDetails.likes, videoDetails.comments, estimatedCtr, estimatedRevenue, trackingId]
        );

        // Criar snapshot
        await db.run(
            `INSERT INTO analytics_snapshots (user_id, video_tracking_id, views, likes, comments, ctr)
             VALUES (?, ?, ?, ?, ?, ?)`,
            [userId, trackingId, videoDetails.views, videoDetails.likes, videoDetails.comments, estimatedCtr]
        );

        res.status(200).json({ 
            views: videoDetails.views,
            likes: videoDetails.likes,
            comments: videoDetails.comments,
            ctr: estimatedCtr,
            revenue: estimatedRevenue
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/update]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar m√©tricas.' });
    }
});

// Obter dashboard de analytics
app.get('/api/analytics/dashboard', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    console.log(`[Analytics Dashboard] Requisi√ß√£o recebida para userId: ${userId}`);

    try {
        if (!db) {
            console.error('[Analytics Dashboard] Banco de dados n√£o est√° dispon√≠vel');
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        // Verificar se a tabela existe e tem dados
        let stats = {
            total_videos: 0,
            total_views: 0,
            total_likes: 0,
            total_comments: 0,
            avg_ctr: 0,
            total_revenue: 0,
            viral_videos: 0
        };
        
        try {
            // Verificar se a tabela existe primeiro
            const tableCheck = await db.get(`
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='video_tracking'
            `);
            
            if (tableCheck) {
                stats = await db.get(`
                    SELECT 
                        COUNT(*) as total_videos,
                        COALESCE(SUM(actual_views), 0) as total_views,
                        COALESCE(SUM(actual_likes), 0) as total_likes,
                        COALESCE(SUM(actual_comments), 0) as total_comments,
                        COALESCE(AVG(actual_ctr), 0) as avg_ctr,
                        COALESCE(SUM(revenue_estimate), 0) as total_revenue,
                        COUNT(CASE WHEN actual_views >= 1000000 THEN 1 END) as viral_videos
                    FROM video_tracking
                    WHERE user_id = ?
                `, [userId]) || stats;
            }
            console.log(`[Analytics Dashboard] Stats encontrados:`, stats);
        } catch (dbErr) {
            console.error('[Analytics Dashboard] Erro ao buscar stats:', dbErr);
            // Manter valores padr√£o
        }

        let recentVideos = [];
        try {
            // Verificar se a tabela existe primeiro
            const tableCheck = await db.get(`
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='video_tracking'
            `);
            
            if (tableCheck) {
                recentVideos = await db.all(`
                    SELECT vt.id, vt.youtube_video_id, vt.title_used, vt.actual_views, vt.actual_ctr, vt.revenue_estimate, 
                           vt.published_at, vt.tracked_at, vt.channel_id, uc.channel_name
                    FROM video_tracking vt
                    LEFT JOIN user_channels uc ON vt.channel_id = uc.id
                    WHERE vt.user_id = ?
                    ORDER BY COALESCE(vt.published_at, vt.tracked_at) DESC
                    LIMIT 50
                `, [userId]) || [];
            }
            console.log(`[Analytics Dashboard] V√≠deos recentes encontrados:`, recentVideos.length);
        } catch (dbErr) {
            console.error('[Analytics Dashboard] Erro ao buscar v√≠deos recentes:', dbErr);
            recentVideos = [];
        }

        // Usar a fun√ß√£o getRPMByNiche definida globalmente acima
        
        // Calcular RPM por canal (baseado no nicho)
        let totalRPMUSD = 0;
        let totalRPMBRL = 0;
        let channelsCount = 0;
        
        try {
            const channelsWithNiche = await db.all(`
                SELECT DISTINCT uc.niche 
                FROM user_channels uc
                INNER JOIN video_tracking vt ON vt.channel_id = uc.id
                WHERE uc.user_id = ? AND uc.niche IS NOT NULL AND uc.niche != ''
            `, [userId]);
            
            if (channelsWithNiche && channelsWithNiche.length > 0) {
                channelsWithNiche.forEach(ch => {
                    const rpm = getRPMByNiche(ch.niche);
                    totalRPMUSD += rpm.usd;
                    totalRPMBRL += rpm.brl;
                    channelsCount++;
                });
                // M√©dia dos RPMs
                totalRPMUSD = totalRPMUSD / channelsCount;
                totalRPMBRL = totalRPMBRL / channelsCount;
            } else {
                // Se n√£o h√° canais com nicho, usar padr√£o
                const defaultRPM = getRPMByNiche(null);
                totalRPMUSD = defaultRPM.usd;
                totalRPMBRL = defaultRPM.brl;
            }
        } catch (rpmErr) {
            console.error('[Analytics] Erro ao calcular RPM por nicho:', rpmErr);
            const defaultRPM = getRPMByNiche(null);
            totalRPMUSD = defaultRPM.usd;
            totalRPMBRL = defaultRPM.brl;
        }
        
        // Calcular receita estimada baseada no RPM real do nicho
        const totalViews = parseInt(stats?.total_views || 0);
        const usdToBrlRate = 5.50;
        
        // Calcular receita total: somar receita do banco + receita estimada baseada no RPM do nicho
        // Se h√° receita no banco, usar ela; sen√£o, calcular baseado no RPM do nicho
        let totalRevenueUSD = parseFloat(stats?.total_revenue || 0);
        
        // Se n√£o h√° receita no banco mas h√° views, calcular baseado no RPM do nicho
        if (totalRevenueUSD === 0 && totalViews > 0 && totalRPMUSD > 0) {
            totalRevenueUSD = (totalViews * totalRPMUSD) / 1000;
        }
        // Se h√° receita no banco, recalcular baseado no RPM do nicho para atualizar
        else if (totalViews > 0 && totalRPMUSD > 0) {
            // Recalcular receita baseada no RPM atual do nicho (mais preciso)
            totalRevenueUSD = (totalViews * totalRPMUSD) / 1000;
        }
        
        const totalRevenueBRL = totalRevenueUSD * usdToBrlRate;
        
        // RPM final (usar o calculado baseado no nicho, ou calcular a partir da receita se houver)
        let rpmUSD = totalRPMUSD;
        let rpmBRL = totalRPMBRL;
        
        // Se n√£o h√° RPM calculado mas h√° receita, calcular RPM a partir da receita
        if (rpmUSD === 0 && totalRevenueUSD > 0 && totalViews > 0) {
            rpmUSD = (totalRevenueUSD / totalViews) * 1000;
            rpmBRL = (totalRevenueBRL / totalViews) * 1000;
        }

        // Garantir que recentVideos √© sempre um array
        const recentVideosArray = Array.isArray(recentVideos) ? recentVideos : [];
        
        const response = {
            stats: {
                totalVideos: parseInt(stats?.total_videos || 0),
                totalViews: totalViews,
                totalLikes: parseInt(stats?.total_likes || 0),
                totalComments: parseInt(stats?.total_comments || 0),
                avgCtr: parseFloat(stats?.avg_ctr || 0),
                totalRevenue: totalRevenueUSD,
                totalRevenueBRL: totalRevenueBRL,
                rpmUSD: rpmUSD,
                rpmBRL: rpmBRL,
                viralVideos: parseInt(stats?.viral_videos || 0)
            },
            recentVideos: recentVideosArray
        };

        console.log(`[Analytics Dashboard] Enviando resposta:`, JSON.stringify(response).substring(0, 200));
        res.status(200).json(response);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/dashboard]:', err);
        // Sempre retornar JSON v√°lido, nunca HTML
        res.status(500).json({ 
            stats: {
                totalVideos: 0,
                totalViews: 0,
                totalLikes: 0,
                totalComments: 0,
                avgCtr: 0,
                totalRevenue: 0,
                totalRevenueBRL: 0,
                rpmUSD: 2.0,
                rpmBRL: 11.0,
                viralVideos: 0
            },
            recentVideos: [],
            error: err.message || 'Erro no servidor ao buscar dados do dashboard.'
        });
    }
});

// Excluir v√≠deo do tracking
app.delete('/api/analytics/track/:trackingId', authenticateToken, async (req, res) => {
    const { trackingId } = req.params;
    const userId = req.user.id;

    try {
        if (!db) {
            console.error('[Analytics Delete] Banco de dados n√£o est√° dispon√≠vel');
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        // Verificar se o tracking pertence ao usu√°rio
        const tracking = await db.get('SELECT id FROM video_tracking WHERE id = ? AND user_id = ?', [trackingId, userId]);
        if (!tracking) {
            return res.status(404).json({ msg: 'Tracking n√£o encontrado ou n√£o pertence a este usu√°rio.' });
        }

        // Excluir snapshots relacionados primeiro (devido √† foreign key)
        await db.run('DELETE FROM analytics_snapshots WHERE video_tracking_id = ?', [trackingId]);

        // Excluir o tracking
        const result = await db.run('DELETE FROM video_tracking WHERE id = ? AND user_id = ?', [trackingId, userId]);
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Tracking n√£o encontrado.' });
        }

        console.log(`[Analytics Delete] V√≠deo ${trackingId} exclu√≠do pelo usu√°rio ${userId}`);
        res.status(200).json({ msg: 'V√≠deo exclu√≠do do tracking com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/track/:trackingId DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir v√≠deo do tracking.' });
    }
});
// === NOVAS FUNCIONALIDADES DE ANALYTICS E VALIDA√á√ÉO ===

// 1. ROI Calculator - Calcular receita total gerada pelos v√≠deos
app.get('/api/analytics/roi', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { startDate, endDate } = req.query;

    try {
        let query = `
            SELECT 
                COUNT(*) as total_videos,
                SUM(actual_views) as total_views,
                SUM(revenue_estimate) as total_revenue,
                AVG(actual_ctr) as avg_ctr,
                SUM(actual_likes) as total_likes,
                SUM(actual_comments) as total_comments
            FROM video_tracking
            WHERE user_id = ? AND actual_views > 0
        `;
        const params = [userId];

        if (startDate) {
            query += ' AND published_at >= ?';
            params.push(startDate);
        }
        if (endDate) {
            query += ' AND published_at <= ?';
            params.push(endDate);
        }

        const stats = await db.get(query, params);

        // Calcular ROI (assumindo que cada an√°lise custa $0.50 ou similar)
        const costPerAnalysis = 0.50;
        const totalCost = (stats.total_videos || 0) * costPerAnalysis;
        const totalRevenue = stats.total_revenue || 0;
        const roi = totalCost > 0 ? ((totalRevenue - totalCost) / totalCost) * 100 : 0;

        res.status(200).json({
            totalVideos: stats.total_videos || 0,
            totalViews: stats.total_views || 0,
            totalRevenue: totalRevenue,
            totalCost: totalCost,
            roi: roi.toFixed(2),
            avgCtr: (stats.avg_ctr || 0).toFixed(2),
            totalLikes: stats.total_likes || 0,
            totalComments: stats.total_comments || 0,
            netProfit: (totalRevenue - totalCost).toFixed(2)
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/roi]:', err);
        res.status(500).json({ msg: 'Erro ao calcular ROI.' });
    }
});

// 2. Leaderboard - Melhores t√≠tulos/thumbnails por views
app.get('/api/analytics/leaderboard', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { type = 'all', limit = 10 } = req.query; // type: 'titles', 'thumbnails', 'all'

    try {
        let leaderboard = [];

        if (type === 'titles' || type === 'all') {
            const topTitles = await db.all(`
                SELECT 
                    title_used as item,
                    'title' as type,
                    actual_views as views,
                    actual_ctr as ctr,
                    revenue_estimate as revenue,
                    published_at
                FROM video_tracking
                WHERE user_id = ? AND title_used IS NOT NULL AND actual_views > 0
                ORDER BY actual_views DESC
                LIMIT ?
            `, [userId, parseInt(limit)]);
            leaderboard = leaderboard.concat(topTitles);
        }

        if (type === 'thumbnails' || type === 'all') {
            const topThumbnails = await db.all(`
                SELECT 
                    thumbnail_used as item,
                    'thumbnail' as type,
                    actual_views as views,
                    actual_ctr as ctr,
                    revenue_estimate as revenue,
                    published_at
                FROM video_tracking
                WHERE user_id = ? AND thumbnail_used IS NOT NULL AND actual_views > 0
                ORDER BY actual_views DESC
                LIMIT ?
            `, [userId, parseInt(limit)]);
            leaderboard = leaderboard.concat(topThumbnails);
        }

        // Ordenar por views e limitar
        leaderboard.sort((a, b) => (b.views || 0) - (a.views || 0));
        leaderboard = leaderboard.slice(0, parseInt(limit));

        res.status(200).json({ leaderboard });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/leaderboard]:', err);
        res.status(500).json({ msg: 'Erro ao buscar leaderboard.' });
    }
});

// 3. Heatmap de Sucesso - F√≥rmulas de t√≠tulo que funcionam melhor por nicho
app.get('/api/analytics/heatmap', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        // Buscar t√≠tulos da biblioteca com suas m√©tricas de sucesso
        // Nota: JOIN pode n√£o funcionar se n√£o houver correspond√™ncia exata, ent√£o fazemos query separada
        const heatmapData = await db.all(`
            SELECT 
                COALESCE(uc.niche, 'Geral') as niche,
                COALESCE(uc.subniche, '') as subniche,
                COUNT(*) as usage_count,
                AVG(vt.actual_views) as avg_views,
                AVG(vt.actual_ctr) as avg_ctr,
                MAX(vt.actual_views) as max_views
            FROM video_tracking vt
            LEFT JOIN user_channels uc ON vt.channel_id = uc.id
            WHERE vt.user_id = ? AND vt.actual_views > 0
            GROUP BY COALESCE(uc.niche, 'Geral'), COALESCE(uc.subniche, '')
            ORDER BY avg_views DESC
        `, [userId]);

        // Tamb√©m buscar dados da biblioteca de t√≠tulos
        const libraryData = await db.all(`
            SELECT 
                niche,
                subniche,
                formula_type,
                COUNT(*) as count,
                AVG(original_views) as avg_views,
                AVG(original_ctr) as avg_ctr
            FROM viral_titles_library
            WHERE user_id = ? AND original_views > 0
            GROUP BY niche, subniche, formula_type
        `, [userId]);

        res.status(200).json({
            tracking: heatmapData,
            library: libraryData
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/heatmap]:', err);
        res.status(500).json({ msg: 'Erro ao buscar heatmap.' });
    }
});

// 4. Score Predictor - IA prev√™ potencial de views antes de publicar
app.post('/api/analytics/predict-score', authenticateToken, async (req, res) => {
    const { title, thumbnailDescription, niche, subniche } = req.body;
    const userId = req.user.id;

    if (!title) {
        return res.status(400).json({ msg: 'T√≠tulo √© obrigat√≥rio.' });
    }

    try {
        // Buscar hist√≥rico de sucesso do usu√°rio
        const userHistory = await db.all(`
            SELECT 
                AVG(actual_views) as avg_views,
                AVG(actual_ctr) as avg_ctr,
                COUNT(*) as total_videos
            FROM video_tracking
            WHERE user_id = ? AND actual_views > 0
        `, [userId]);

        // Buscar t√≠tulos similares na biblioteca
        const similarTitles = await db.all(`
            SELECT 
                original_views,
                original_ctr,
                viral_score
            FROM viral_titles_library
            WHERE user_id = ? AND niche = ? AND original_views > 0
            ORDER BY original_views DESC
            LIMIT 10
        `, [userId, niche || '']);

        // Calcular score baseado em m√∫ltiplos fatores
        let predictedViews = 0;
        let predictedCtr = 0;
        let score = 0;

        // Fator 1: Hist√≥rico do usu√°rio
        if (userHistory[0] && userHistory[0].total_videos > 0) {
            predictedViews = userHistory[0].avg_views || 0;
            predictedCtr = userHistory[0].avg_ctr || 0;
        }

        // Fator 2: T√≠tulos similares
        if (similarTitles.length > 0) {
            const avgSimilarViews = similarTitles.reduce((sum, t) => sum + (t.original_views || 0), 0) / similarTitles.length;
            const avgSimilarCtr = similarTitles.reduce((sum, t) => sum + (t.original_ctr || 0), 0) / similarTitles.length;
            
            // M√©dia ponderada: 60% hist√≥rico do usu√°rio, 40% t√≠tulos similares
            predictedViews = (predictedViews * 0.6) + (avgSimilarViews * 0.4);
            predictedCtr = (predictedCtr * 0.6) + (avgSimilarCtr * 0.4);
        }

        // Fator 3: An√°lise do t√≠tulo (comprimento, palavras-chave, etc)
        const titleLength = title.length;
        const hasNumbers = /\d/.test(title);
        const hasQuestion = title.includes('?');
        const hasExclamation = title.includes('!');
        const powerWords = ['SECRETO', 'REVELADO', 'ESCONDIDO', 'PROIBIDO', 'CHOCANTE', 'INCR√çVEL', 'NUNCA VISTO'];
        const hasPowerWords = powerWords.some(word => title.toUpperCase().includes(word));

        // Ajustar score baseado em caracter√≠sticas do t√≠tulo
        let titleScore = 50; // Base
        if (titleLength >= 40 && titleLength <= 60) titleScore += 10; // Tamanho ideal
        if (hasNumbers) titleScore += 5;
        if (hasQuestion) titleScore += 8;
        if (hasExclamation) titleScore += 5;
        if (hasPowerWords) titleScore += 15;

        // Calcular score final (0-100)
        score = Math.min(100, Math.max(0, titleScore + (predictedCtr * 2)));

        // Ajustar views previstas baseado no score
        predictedViews = predictedViews * (score / 50);

        res.status(200).json({
            predictedViews: Math.round(predictedViews),
            predictedCtr: predictedCtr.toFixed(2),
            score: Math.round(score),
            factors: {
                titleLength,
                hasNumbers,
                hasQuestion,
                hasExclamation,
                hasPowerWords,
                userHistory: userHistory[0] || null,
                similarTitlesCount: similarTitles.length
            }
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/predict-score]:', err);
        res.status(500).json({ msg: 'Erro ao prever score.' });
    }
});

// 5. Valida√ß√£o de T√≠tulo
app.post('/api/analytics/validate-title', authenticateToken, async (req, res) => {
    const { title, niche } = req.body;

    if (!title) {
        return res.status(400).json({ msg: 'T√≠tulo √© obrigat√≥rio.' });
    }

    try {
        const validations = {
            length: {
                value: title.length,
                min: 30,
                max: 70,
                ideal: 40,
                passed: title.length >= 30 && title.length <= 70,
                score: title.length >= 40 && title.length <= 60 ? 100 : title.length >= 30 && title.length <= 70 ? 70 : 50
            },
            hasNumbers: {
                value: /\d/.test(title),
                passed: /\d/.test(title),
                score: /\d/.test(title) ? 100 : 50,
                tip: 'N√∫meros aumentam CTR em at√© 20%'
            },
            hasQuestion: {
                value: title.includes('?'),
                passed: title.includes('?'),
                score: title.includes('?') ? 100 : 60,
                tip: 'Perguntas geram curiosidade'
            },
            hasPowerWords: {
                value: ['SECRETO', 'REVELADO', 'ESCONDIDO', 'PROIBIDO', 'CHOCANTE', 'INCR√çVEL', 'NUNCA VISTO', 'EXCLUSIVO'].some(w => title.toUpperCase().includes(w)),
                passed: ['SECRETO', 'REVELADO', 'ESCONDIDO', 'PROIBIDO', 'CHOCANTE', 'INCR√çVEL', 'NUNCA VISTO', 'EXCLUSIVO'].some(w => title.toUpperCase().includes(w)),
                score: ['SECRETO', 'REVELADO', 'ESCONDIDO', 'PROIBIDO', 'CHOCANTE', 'INCR√çVEL', 'NUNCA VISTO', 'EXCLUSIVO'].some(w => title.toUpperCase().includes(w)) ? 100 : 50,
                tip: 'Palavras poderosas aumentam engajamento'
            },
            capitalization: {
                value: title.split(' ').filter(w => w[0] && w[0] === w[0].toUpperCase()).length,
                passed: title.split(' ').filter(w => w[0] && w[0] === w[0].toUpperCase()).length >= 3,
                score: title.split(' ').filter(w => w[0] && w[0] === w[0].toUpperCase()).length >= 3 ? 100 : 70,
                tip: 'Capitaliza√ß√£o adequada melhora legibilidade'
            }
        };

        const totalScore = Object.values(validations).reduce((sum, v) => sum + (v.score || 0), 0) / Object.keys(validations).length;
        const passedCount = Object.values(validations).filter(v => v.passed).length;
        const totalChecks = Object.keys(validations).length;

        res.status(200).json({
            title,
            validations,
            overallScore: Math.round(totalScore),
            passedChecks: `${passedCount}/${totalChecks}`,
            recommendation: totalScore >= 80 ? 'excellent' : totalScore >= 60 ? 'good' : 'needs_improvement',
            tips: Object.values(validations).filter(v => !v.passed && v.tip).map(v => v.tip)
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/validate-title]:', err);
        res.status(500).json({ msg: 'Erro ao validar t√≠tulo.' });
    }
});

// Fun√ß√£o para calcular score viral de thumbnail baseado no algoritmo do YouTube
function calculateThumbnailViralScore(thumbnailDescription, index, totalThumbnails) {
    if (!thumbnailDescription || typeof thumbnailDescription !== 'string') {
        return 8; // Score padr√£o se n√£o houver descri√ß√£o
    }
    
    const descLower = thumbnailDescription.toLowerCase();
    let baseScore = 6; // Score base (m√≠nimo 6)
    
    // Fatores do algoritmo do YouTube que aumentam CTR:
    
    // 1. Presen√ßa de rosto humano (aumenta CTR em 20-30%)
    if (/face|rosto|pessoa|person|human|portrait|close-up|closeup/i.test(descLower)) {
        baseScore += 0.8;
    }
    
    // 2. Express√µes emocionais fortes (aumenta engajamento)
    const emotionWords = ['surprised', 'surpreso', 'shocked', 'chocado', 'excited', 'animado', 'angry', 'bravo', 'happy', 'feliz', 'fear', 'medo', 'shock', 'choque'];
    const emotionCount = emotionWords.filter(word => descLower.includes(word)).length;
    baseScore += Math.min(emotionCount * 0.3, 1.0);
    
    // 3. Texto na thumbnail (aumenta cliques)
    if (/text|texto|phrase|frase|word|palavra|letter|letra|font|fonte/i.test(descLower)) {
        baseScore += 0.6;
    }
    
    // 4. Alto contraste e cores vibrantes (melhora visibilidade)
    if (/contrast|contraste|bright|brilhante|vibrant|vibrante|color|cor|saturated|saturado/i.test(descLower)) {
        baseScore += 0.5;
    }
    
    // 5. Composi√ß√£o profissional (regra dos ter√ßos, centro)
    if (/rule of thirds|ter√ßos|center|centro|composition|composi√ß√£o|framing|enquadramento/i.test(descLower)) {
        baseScore += 0.4;
    }
    
    // 6. Elementos que geram curiosidade
    const curiosityElements = ['mystery', 'mist√©rio', 'secret', 'segredo', 'hidden', 'escondido', 'reveal', 'revelar', 'blur', 'desfocado', 'question', 'pergunta'];
    const curiosityCount = curiosityElements.filter(word => descLower.includes(word)).length;
    baseScore += Math.min(curiosityCount * 0.2, 0.6);
    
    // 7. Qualidade t√©cnica (8K, profissional, etc)
    if (/8k|ultra.*high|professional|profissional|cinematic|cinematogr√°fico|arri|red|canon|nikon/i.test(descLower)) {
        baseScore += 0.3;
    }
    
    // 8. Elementos visuais poderosos
    if (/arrow|seta|number|n√∫mero|before.*after|antes.*depois|comparison|compara√ß√£o/i.test(descLower)) {
        baseScore += 0.4;
    }
    
    // 9. Ilumina√ß√£o profissional
    if (/lighting|ilumina√ß√£o|dramatic.*light|luz.*dram√°tica|rim.*light|backlight/i.test(descLower)) {
        baseScore += 0.3;
    }
    
    // 10. Varia√ß√£o baseada no √≠ndice (para garantir diferentes scores)
    // Primeira thumbnail geralmente √© melhor (r√©plica melhorada)
    // Segunda thumbnail √© nova e otimizada
    const indexVariation = index === 0 ? 0.2 : -0.1; // Primeira ligeiramente melhor
    baseScore += indexVariation;
    
    // Adicionar pequena varia√ß√£o aleat√≥ria para simular algoritmo do YouTube
    // (varia√ß√£o de -0.3 a +0.3 para tornar mais realista)
    const randomVariation = (Math.random() * 0.6) - 0.3;
    baseScore += randomVariation;
    
    // Garantir que o score fique entre 6.0 e 10.0
    baseScore = Math.max(6.0, Math.min(10.0, baseScore));
    
    // Arredondar para 1 casa decimal
    return Math.round(baseScore * 10) / 10;
}

// 6. Valida√ß√£o de Thumbnail (an√°lise b√°sica)
app.post('/api/analytics/validate-thumbnail', authenticateToken, async (req, res) => {
    const { thumbnailDescription, niche } = req.body;

    if (!thumbnailDescription) {
        return res.status(400).json({ msg: 'Descri√ß√£o da thumbnail √© obrigat√≥ria.' });
    }

    try {
        const validations = {
            hasFace: {
                value: /face|rosto|pessoa|person|human/i.test(thumbnailDescription),
                passed: /face|rosto|pessoa|person|human/i.test(thumbnailDescription),
                score: /face|rosto|pessoa|person|human/i.test(thumbnailDescription) ? 100 : 50,
                tip: 'Rostos humanos aumentam CTR em at√© 30%'
            },
            hasText: {
                value: /text|texto|phrase|frase|word|palavra/i.test(thumbnailDescription),
                passed: /text|texto|phrase|frase|word|palavra/i.test(thumbnailDescription),
                score: /text|texto|phrase|frase|word|palavra/i.test(thumbnailDescription) ? 100 : 60,
                tip: 'Texto na thumbnail aumenta cliques'
            },
            hasContrast: {
                value: /contrast|contraste|bright|brilhante|vibrant|vibrante|color/i.test(thumbnailDescription),
                passed: /contrast|contraste|bright|brilhante|vibrant|vibrante|color/i.test(thumbnailDescription),
                score: /contrast|contraste|bright|brilhante|vibrant|vibrante|color/i.test(thumbnailDescription) ? 100 : 50,
                tip: 'Alto contraste melhora visibilidade'
            },
            hasEmotion: {
                value: /emotion|emo√ß√£o|expression|express√£o|surprised|surpreso|shocked|chocado|excited|animado/i.test(thumbnailDescription),
                passed: /emotion|emo√ß√£o|expression|express√£o|surprised|surpreso|shocked|chocado|excited|animado/i.test(thumbnailDescription),
                score: /emotion|emo√ß√£o|expression|express√£o|surprised|surpreso|shocked|chocado|excited|animado/i.test(thumbnailDescription) ? 100 : 50,
                tip: 'Express√µes emocionais geram mais cliques'
            },
            composition: {
                value: 'center' in thumbnailDescription.toLowerCase() || 'rule of thirds' in thumbnailDescription.toLowerCase(),
                passed: 'center' in thumbnailDescription.toLowerCase() || 'rule of thirds' in thumbnailDescription.toLowerCase(),
                score: 'center' in thumbnailDescription.toLowerCase() || 'rule of thirds' in thumbnailDescription.toLowerCase() ? 100 : 70,
                tip: 'Composi√ß√£o adequada melhora impacto visual'
            }
        };

        const totalScore = Object.values(validations).reduce((sum, v) => sum + (v.score || 0), 0) / Object.keys(validations).length;
        const passedCount = Object.values(validations).filter(v => v.passed).length;
        const totalChecks = Object.keys(validations).length;

        res.status(200).json({
            thumbnailDescription,
            validations,
            overallScore: Math.round(totalScore),
            passedChecks: `${passedCount}/${totalChecks}`,
            recommendation: totalScore >= 80 ? 'excellent' : totalScore >= 60 ? 'good' : 'needs_improvement',
            tips: Object.values(validations).filter(v => !v.passed && v.tip).map(v => v.tip)
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/validate-thumbnail]:', err);
        res.status(500).json({ msg: 'Erro ao validar thumbnail.' });
    }
});

// 7. Compara√ß√£o com Competidores
app.post('/api/analytics/compare-competitors', authenticateToken, async (req, res) => {
    const { title, thumbnailDescription, niche, competitorVideoIds } = req.body;
    const userId = req.user.id;

    if (!title || !competitorVideoIds || !Array.isArray(competitorVideoIds)) {
        return res.status(400).json({ msg: 'T√≠tulo e lista de IDs de v√≠deos competidores s√£o obrigat√≥rios.' });
    }

    try {
        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        if (!geminiKeyData) {
            return res.status(400).json({ msg: 'Chave de API do Gemini √© necess√°ria.' });
        }
        const geminiApiKey = decrypt(geminiKeyData.api_key);

        // Buscar dados dos v√≠deos competidores
        const competitorData = await Promise.all(
            competitorVideoIds.slice(0, 5).map(async (videoId) => {
                try {
                    const data = await callYouTubeDataAPI(videoId, geminiApiKey);
                    return {
                        videoId,
                        title: data.title,
                        views: data.views,
                        likes: data.likes,
                        comments: data.comments,
                        days: data.days
                    };
                } catch (err) {
                    console.error(`Erro ao buscar v√≠deo ${videoId}:`, err);
                    return null;
                }
            })
        );

        const validCompetitors = competitorData.filter(c => c !== null);

        if (validCompetitors.length === 0) {
            return res.status(400).json({ msg: 'Nenhum v√≠deo competidor v√°lido encontrado.' });
        }

        // Calcular m√©tricas m√©dias dos competidores
        const avgViews = validCompetitors.reduce((sum, c) => sum + (c.views || 0), 0) / validCompetitors.length;
        const avgLikes = validCompetitors.reduce((sum, c) => sum + (c.likes || 0), 0) / validCompetitors.length;
        const avgComments = validCompetitors.reduce((sum, c) => sum + (c.comments || 0), 0) / validCompetitors.length;

        // Comparar caracter√≠sticas do t√≠tulo
        const yourTitleLength = title.length;
        const competitorTitleLengths = validCompetitors.map(c => (c.title || '').length);
        const avgCompetitorTitleLength = competitorTitleLengths.reduce((sum, l) => sum + l, 0) / competitorTitleLengths.length;

        // An√°lise comparativa
        const comparison = {
            titleLength: {
                yours: yourTitleLength,
                average: Math.round(avgCompetitorTitleLength),
                difference: yourTitleLength - avgCompetitorTitleLength,
                better: Math.abs(yourTitleLength - 50) < Math.abs(avgCompetitorTitleLength - 50)
            },
            performance: {
                avgCompetitorViews: Math.round(avgViews),
                avgCompetitorLikes: Math.round(avgLikes),
                avgCompetitorComments: Math.round(avgComments)
            },
            recommendations: []
        };

        if (yourTitleLength < 30) {
            comparison.recommendations.push('Seu t√≠tulo √© muito curto. T√≠tulos entre 40-60 caracteres performam melhor.');
        } else if (yourTitleLength > 70) {
            comparison.recommendations.push('Seu t√≠tulo √© muito longo. Considere reduzir para melhorar CTR.');
        }

        if (avgViews > 100000) {
            comparison.recommendations.push(`Competidores t√™m m√©dia de ${Math.round(avgViews / 1000)}K views. Considere estudar seus t√≠tulos.`);
        }

        res.status(200).json({
            yourTitle: title,
            competitors: validCompetitors,
            comparison,
            score: comparison.titleLength.better ? 75 : 50
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/analytics/compare-competitors]:', err);
        res.status(500).json({ msg: 'Erro ao comparar com competidores.' });
    }
});

// === ROTAS DE BIBLIOTECA DE T√çTULOS VIRAIS ===

// Adicionar t√≠tulo √† biblioteca (autom√°tico quando an√°lise √© feita)
app.post('/api/library/titles', authenticateToken, async (req, res) => {
    const { title, niche, subniche, originalViews, originalCtr, formulaType, keywords, viralScore } = req.body;
    const userId = req.user.id;

    if (!title) {
        return res.status(400).json({ msg: 'T√≠tulo √© obrigat√≥rio.' });
    }

    try {
        const result = await db.run(
            `INSERT INTO viral_titles_library (user_id, title, niche, subniche, original_views, original_ctr, formula_type, keywords, viral_score)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, title, niche || null, subniche || null, originalViews || null, originalCtr || null, formulaType || null, keywords || null, viralScore || null]
        );
        res.status(201).json({ id: result.lastID, msg: 'T√≠tulo adicionado √† biblioteca.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles]:', err);
        res.status(500).json({ msg: 'Erro ao adicionar t√≠tulo √† biblioteca.' });
    }
});
// Buscar t√≠tulos da biblioteca
app.get('/api/library/titles', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { niche, subniche, minViews, minCtr, favorite, search, page = 1, limit = 6 } = req.query;
    console.log(`[Biblioteca Titles] Requisi√ß√£o recebida para userId: ${userId}`, { niche, subniche, minViews, favorite, search, page, limit });

    try {
        if (!db) {
            console.error('[Biblioteca Titles] Banco de dados n√£o est√° dispon√≠vel');
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        const pageNum = parseInt(page) || 1;
        const limitNum = parseInt(limit) || 6;
        const offset = (pageNum - 1) * limitNum;

        let baseQuery = 'SELECT * FROM viral_titles_library WHERE user_id = ?';
        const params = [userId];
        const countParams = [userId];

        if (niche) {
            baseQuery += ' AND niche = ?';
            params.push(niche);
            countParams.push(niche);
        }
        if (subniche) {
            baseQuery += ' AND subniche = ?';
            params.push(subniche);
            countParams.push(subniche);
        }
        if (minViews) {
            baseQuery += ' AND original_views >= ?';
            params.push(parseInt(minViews));
            countParams.push(parseInt(minViews));
        }
        if (minCtr) {
            baseQuery += ' AND original_ctr >= ?';
            params.push(parseFloat(minCtr));
            countParams.push(parseFloat(minCtr));
        }
        if (favorite === 'true') {
            baseQuery += ' AND is_favorite = 1';
        }
        if (search) {
            baseQuery += ' AND title LIKE ?';
            params.push(`%${search}%`);
            countParams.push(`%${search}%`);
        }

        // Contar total de registros - usar countParams que j√° foi constru√≠do acima
        let countQuery = 'SELECT COUNT(*) as total FROM viral_titles_library WHERE user_id = ?';
        
        if (niche) {
            countQuery += ' AND niche = ?';
        }
        if (subniche) {
            countQuery += ' AND subniche = ?';
        }
        if (minViews) {
            countQuery += ' AND original_views >= ?';
        }
        if (minCtr) {
            countQuery += ' AND original_ctr >= ?';
        }
        if (favorite === 'true') {
            countQuery += ' AND is_favorite = 1';
        }
        if (search) {
            countQuery += ' AND title LIKE ?';
        }
        
        const countResult = await db.get(countQuery, countParams);
        const total = countResult?.total || 0;
        const totalPages = Math.ceil(total / limitNum);

        // Query com pagina√ß√£o
        const query = baseQuery + ` ORDER BY created_at DESC LIMIT ? OFFSET ?`;
        params.push(limitNum, offset);

        console.log(`[Biblioteca Titles] Executando query com pagina√ß√£o: p√°gina ${pageNum}, limite ${limitNum}`);
        let titles = [];
        try {
            titles = await db.all(query, params);
            console.log(`[Biblioteca Titles] T√≠tulos encontrados: ${titles.length} de ${total} total`);
        } catch (dbErr) {
            console.error('[Biblioteca Titles] Erro ao buscar t√≠tulos:', dbErr);
            titles = [];
        }

        // Garantir que titles √© sempre um array
        const titlesArray = Array.isArray(titles) ? titles : [];
        res.status(200).json({
            data: titlesArray,
            pagination: {
                page: pageNum,
                limit: limitNum,
                total: total,
                totalPages: totalPages,
                hasNext: pageNum < totalPages,
                hasPrev: pageNum > 1
            }
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles]:', err);
        // Sempre retornar JSON v√°lido (array vazio), nunca HTML
        res.status(200).json([]);
    }
});

// Excluir t√≠tulo da biblioteca
app.delete('/api/library/titles/:id', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        const result = await db.run('DELETE FROM viral_titles_library WHERE id = ? AND user_id = ?', [id, userId]);
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'T√≠tulo n√£o encontrado ou n√£o pertence a este usu√°rio.' });
        }

        console.log(`[Biblioteca] T√≠tulo ${id} exclu√≠do pelo usu√°rio ${userId}`);
        res.status(200).json({ msg: 'T√≠tulo exclu√≠do da biblioteca com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir t√≠tulo da biblioteca.' });
    }
});

// Marcar/desmarcar t√≠tulo como favorito
app.put('/api/library/titles/:id/favorite', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const { isFavorite } = req.body;
    const userId = req.user.id;

    try {
        await db.run(
            'UPDATE viral_titles_library SET is_favorite = ? WHERE id = ? AND user_id = ?',
            [isFavorite ? 1 : 0, id, userId]
        );
        res.status(200).json({ msg: 'Favorito atualizado.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/titles/:id/favorite]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar favorito.' });
    }
});

// === ROTAS DE BIBLIOTECA DE THUMBNAILS VIRAIS ===

// Adicionar thumbnail √† biblioteca
app.post('/api/library/thumbnails', authenticateToken, async (req, res) => {
    const { thumbnailUrl, thumbnailDescription, niche, subniche, originalViews, originalCtr, style, elements, viralScore } = req.body;
    const userId = req.user.id;

    if (!thumbnailUrl && !thumbnailDescription) {
        return res.status(400).json({ msg: 'URL da thumbnail ou descri√ß√£o √© obrigat√≥ria.' });
    }

    try {
        const result = await db.run(
            `INSERT INTO viral_thumbnails_library (user_id, thumbnail_url, thumbnail_description, niche, subniche, original_views, original_ctr, style, elements, viral_score)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, thumbnailUrl || null, thumbnailDescription || null, niche || null, subniche || null, originalViews || null, originalCtr || null, style || null, elements || null, viralScore || null]
        );
        res.status(201).json({ id: result.lastID, msg: 'Thumbnail adicionada √† biblioteca.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails]:', err);
        res.status(500).json({ msg: 'Erro ao adicionar thumbnail √† biblioteca.' });
    }
});

// Buscar thumbnails da biblioteca
app.get('/api/library/thumbnails', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { niche, subniche, minViews, minCtr, favorite, style, search } = req.query;
    console.log(`[Biblioteca Thumbnails] Requisi√ß√£o recebida para userId: ${userId}`, { niche, minViews, favorite, style, search });

    try {
        if (!db) {
            console.error('[Biblioteca Thumbnails] Banco de dados n√£o est√° dispon√≠vel');
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        let query = 'SELECT * FROM viral_thumbnails_library WHERE user_id = ?';
        const params = [userId];

        if (niche) {
            query += ' AND niche = ?';
            params.push(niche);
        }
        if (subniche) {
            query += ' AND subniche = ?';
            params.push(subniche);
        }
        if (minViews) {
            query += ' AND original_views >= ?';
            params.push(parseInt(minViews));
        }
        if (minCtr) {
            query += ' AND original_ctr >= ?';
            params.push(parseFloat(minCtr));
        }
        if (favorite === 'true') {
            query += ' AND is_favorite = 1';
        }
        if (style) {
            query += ' AND style = ?';
            params.push(style);
        }
        if (search) {
            query += ' AND (niche LIKE ? OR subniche LIKE ? OR thumbnail_description LIKE ?)';
            const searchPattern = `%${search}%`;
            params.push(searchPattern, searchPattern, searchPattern);
        }

        query += ' ORDER BY created_at DESC LIMIT 100';

        console.log(`[Biblioteca Thumbnails] Executando query:`, query.substring(0, 100));
        let thumbnails = [];
        try {
            thumbnails = await db.all(query, params);
            console.log(`[Biblioteca Thumbnails] Thumbnails encontradas:`, thumbnails.length);
        } catch (dbErr) {
            console.error('[Biblioteca Thumbnails] Erro ao buscar thumbnails:', dbErr);
            thumbnails = [];
        }

        // Garantir que thumbnails √© sempre um array
        const thumbnailsArray = Array.isArray(thumbnails) ? thumbnails : [];
        res.status(200).json(thumbnailsArray);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails]:', err);
        // Sempre retornar JSON v√°lido (array vazio), nunca HTML
        res.status(200).json([]);
    }
});

// Rota para buscar nichos √∫nicos da biblioteca
app.get('/api/library/niches', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        if (!db) {
            console.error('[Biblioteca Niches] Banco de dados n√£o est√° dispon√≠vel');
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        // Buscar nichos √∫nicos de t√≠tulos e thumbnails
        const titlesNiches = await db.all(
            `SELECT DISTINCT niche FROM viral_titles_library WHERE user_id = ? AND niche IS NOT NULL AND niche != ''`,
            [userId]
        );
        
        const thumbnailsNiches = await db.all(
            `SELECT DISTINCT niche FROM viral_thumbnails_library WHERE user_id = ? AND niche IS NOT NULL AND niche != ''`,
            [userId]
        );

        // Combinar e remover duplicatas
        const allNiches = new Set();
        titlesNiches.forEach(row => {
            if (row.niche) allNiches.add(row.niche);
        });
        thumbnailsNiches.forEach(row => {
            if (row.niche) allNiches.add(row.niche);
        });

        const nichesArray = Array.from(allNiches).sort();
        res.status(200).json({ niches: nichesArray });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/niches]:', err);
        res.status(500).json({ msg: 'Erro ao buscar nichos.' });
    }
});

// Excluir thumbnail da biblioteca
app.delete('/api/library/thumbnails/:id', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        const result = await db.run('DELETE FROM viral_thumbnails_library WHERE id = ? AND user_id = ?', [id, userId]);
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Thumbnail n√£o encontrada ou n√£o pertence a este usu√°rio.' });
        }

        console.log(`[Biblioteca] Thumbnail ${id} exclu√≠da pelo usu√°rio ${userId}`);
        res.status(200).json({ msg: 'Thumbnail exclu√≠da da biblioteca com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir thumbnail da biblioteca.' });
    }
});

// Marcar/desmarcar thumbnail como favorito
app.put('/api/library/thumbnails/:id/favorite', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const { isFavorite } = req.body;
    const userId = req.user.id;

    try {
        await db.run(
            'UPDATE viral_thumbnails_library SET is_favorite = ? WHERE id = ? AND user_id = ?',
            [isFavorite ? 1 : 0, id, userId]
        );
        res.status(200).json({ msg: 'Favorito atualizado.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/library/thumbnails/:id/favorite]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar favorito.' });
    }
});

// === ROTAS DE INTEGRA√á√ÉO YOUTUBE API ===

// Iniciar OAuth do YouTube (retorna URL de autoriza√ß√£o)
app.get('/api/youtube/oauth/authorize', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const CLIENT_ID = process.env.YOUTUBE_CLIENT_ID || 'YOUR_CLIENT_ID';
    const REDIRECT_URI = process.env.YOUTUBE_REDIRECT_URI || 'http://localhost:5001/api/youtube/oauth/callback';
    const SCOPE = 'https://www.googleapis.com/auth/youtube.upload https://www.googleapis.com/auth/youtube';

    if (CLIENT_ID === 'YOUR_CLIENT_ID') {
        return res.status(500).json({ msg: 'Credenciais do YouTube n√£o configuradas. Configure YOUTUBE_CLIENT_ID no arquivo .env. Veja CONFIGURACAO_YOUTUBE.md para mais informa√ß√µes.' });
    }

    // Validar e limpar REDIRECT_URI
    let cleanRedirectUri = REDIRECT_URI.trim();
    // Remover barra final se houver
    if (cleanRedirectUri.endsWith('/')) {
        cleanRedirectUri = cleanRedirectUri.slice(0, -1);
    }

    // Criar um state token seguro com o userId
    // Em produ√ß√£o, voc√™ deve usar um token JWT ou criptografado
    const stateToken = Buffer.from(JSON.stringify({ userId, timestamp: Date.now() })).toString('base64');

    // Construir URL de autoriza√ß√£o com par√¢metros corretos
    const authParams = new URLSearchParams({
        client_id: CLIENT_ID,
        redirect_uri: cleanRedirectUri,
        response_type: 'code',
        scope: SCOPE,
        access_type: 'offline',
        prompt: 'consent', // For√ßa sele√ß√£o de conta mesmo se j√° logado
        include_granted_scopes: 'true', // Permite m√∫ltiplas contas
        state: stateToken
    });

    const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?${authParams.toString()}`;

    console.log(`[YouTube OAuth] URL de autoriza√ß√£o gerada para userId: ${userId}`);
    console.log(`[YouTube OAuth] Redirect URI: ${cleanRedirectUri}`);

    res.status(200).json({ authUrl, msg: 'Use esta URL para autorizar o acesso ao YouTube.' });
});

// Callback OAuth (ser√° chamado pelo Google ap√≥s autoriza√ß√£o)
// NOTA: Este endpoint n√£o usa authenticateToken porque o Google redireciona diretamente
// O userId √© validado atrav√©s do state parameter
app.get('/api/youtube/oauth/callback', async (req, res) => {
    const { code, error, state } = req.query;
    
    let userId = null;
    
    // Decodificar state para obter userId
    try {
        if (state) {
            const stateData = JSON.parse(Buffer.from(state, 'base64').toString());
            userId = stateData.userId;
            
            // Validar que o state n√£o √© muito antigo (m√°ximo 10 minutos)
            const maxAge = 10 * 60 * 1000; // 10 minutos
            if (Date.now() - stateData.timestamp > maxAge) {
                return res.status(400).send(`
                    <!DOCTYPE html>
                    <html>
                    <head><title>Erro - Token Expirado</title></head>
                    <body style="font-family: Arial; text-align: center; padding: 50px;">
                        <h1>‚ùå Token Expirado</h1>
                        <p>O token de autoriza√ß√£o expirou. Por favor, tente novamente.</p>
                        <button onclick="window.close()">Fechar</button>
                    </body>
                    </html>
                `);
            }
        } else {
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Erro - Estado Inv√°lido</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px;">
                    <h1>‚ùå Erro na Autoriza√ß√£o</h1>
                    <p>Estado inv√°lido. Por favor, tente conectar novamente.</p>
                    <button onclick="window.close()">Fechar</button>
                </body>
                </html>
            `);
        }
    } catch (e) {
        console.error('[YouTube OAuth] Erro ao decodificar state:', e);
        return res.status(400).send(`
            <!DOCTYPE html>
            <html>
            <head><title>Erro - Estado Inv√°lido</title></head>
            <body style="font-family: Arial; text-align: center; padding: 50px;">
                <h1>‚ùå Erro na Autoriza√ß√£o</h1>
                <p>Estado inv√°lido ou corrompido. Por favor, tente conectar novamente.</p>
                <button onclick="window.close()">Fechar</button>
            </body>
            </html>
        `);
    }

    if (error) {
        console.error('[YouTube OAuth] Erro na autoriza√ß√£o:', error);
        return res.status(400).send(`
            <!DOCTYPE html>
            <html>
            <head><title>Erro na Autoriza√ß√£o</title></head>
            <body style="font-family: Arial; text-align: center; padding: 50px;">
                <h1>‚ùå Erro na Autoriza√ß√£o</h1>
                <p>${error}</p>
                <button onclick="window.close()">Fechar</button>
            </body>
            </html>
        `);
    }

    if (!code) {
        return res.status(400).json({ msg: 'C√≥digo de autoriza√ß√£o n√£o fornecido.' });
    }

    const CLIENT_ID = process.env.YOUTUBE_CLIENT_ID || 'YOUR_CLIENT_ID';
    const CLIENT_SECRET = process.env.YOUTUBE_CLIENT_SECRET || 'YOUR_CLIENT_SECRET';
    let REDIRECT_URI = process.env.YOUTUBE_REDIRECT_URI || 'http://localhost:5001/api/youtube/oauth/callback';

    // Limpar e validar REDIRECT_URI
    REDIRECT_URI = REDIRECT_URI.trim();
    if (REDIRECT_URI.endsWith('/')) {
        REDIRECT_URI = REDIRECT_URI.slice(0, -1);
    }

    if (CLIENT_ID === 'YOUR_CLIENT_ID' || CLIENT_SECRET === 'YOUR_CLIENT_SECRET') {
        return res.status(500).json({ msg: 'Credenciais do YouTube n√£o configuradas. Configure YOUTUBE_CLIENT_ID e YOUTUBE_CLIENT_SECRET no arquivo .env' });
    }
    try {
        // Trocar code por access_token e refresh_token
        const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                code: code,
                client_id: CLIENT_ID,
                client_secret: CLIENT_SECRET,
                redirect_uri: REDIRECT_URI,
                grant_type: 'authorization_code',
            }),
        });

        if (!tokenResponse.ok) {
            const errorText = await tokenResponse.text();
            console.error('[YouTube OAuth] Erro ao trocar c√≥digo por token:', errorText);
            return res.status(400).json({ msg: 'Falha ao obter tokens de acesso.' });
        }

        const tokenData = await tokenResponse.json();
        const { access_token, refresh_token, expires_in } = tokenData;

        if (!access_token) {
            return res.status(400).json({ msg: 'Token de acesso n√£o recebido.' });
        }

        // Buscar TODOS os canais da conta Google (at√© 50 canais)
        const channelsResponse = await fetch('https://www.googleapis.com/youtube/v3/channels?part=snippet&mine=true&maxResults=50', {
            headers: {
                'Authorization': `Bearer ${access_token}`,
            },
        });

        let availableChannels = [];
        
        if (channelsResponse.ok) {
            const channelsData = await channelsResponse.json();
            if (channelsData.items && channelsData.items.length > 0) {
                availableChannels = channelsData.items.map(item => ({
                    id: item.id,
                    name: item.snippet?.title || 'Canal sem nome',
                    thumbnail: item.snippet?.thumbnails?.default?.url || '',
                    description: item.snippet?.description || ''
                }));
            }
        }

        if (availableChannels.length === 0) {
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Nenhum Canal Encontrado</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px;">
                    <h1>‚ùå Nenhum Canal Encontrado</h1>
                    <p>N√£o foi poss√≠vel encontrar canais nesta conta Google.</p>
                    <button onclick="window.close()">Fechar</button>
                </body>
                </html>
            `);
        }

        // Verificar quantos canais j√° est√£o conectados
        const existingChannelsCount = await db.get(
            'SELECT COUNT(*) as count FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
            [userId]
        );
        const currentCount = existingChannelsCount?.count || 0;
        const maxChannels = 10;
        const remainingSlots = maxChannels - currentCount;

        if (remainingSlots <= 0) {
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Limite Atingido</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px;">
                    <h1>‚ùå Limite de Canais Atingido</h1>
                    <p>Voc√™ j√° tem 10 canais conectados. Desconecte um canal antes de adicionar outro.</p>
                    <button onclick="window.close()">Fechar</button>
                </body>
                </html>
            `);
        }

        // Verificar quais canais j√° est√£o conectados
        const existingChannels = await db.all(
            'SELECT channel_id FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
            [userId]
        );
        const existingChannelIds = new Set(existingChannels.map(c => c.channel_id));

        // Filtrar canais j√° conectados e limitar aos slots dispon√≠veis
        const selectableChannels = availableChannels
            .filter(ch => !existingChannelIds.has(ch.id))
            .slice(0, remainingSlots);

        if (selectableChannels.length === 0) {
            return res.status(400).send(`
                <!DOCTYPE html>
                <html>
                <head><title>Todos os Canais J√° Conectados</title></head>
                <body style="font-family: Arial; text-align: center; padding: 50px;">
                    <h1>‚ÑπÔ∏è Todos os Canais J√° Est√£o Conectados</h1>
                    <p>Todos os canais desta conta Google j√° est√£o conectados ou voc√™ atingiu o limite de 10 canais.</p>
                    <button onclick="window.close()">Fechar</button>
                </body>
                </html>
            `);
        }

        // Calcular quando o token expira
        const expiresAt = expires_in 
            ? new Date(Date.now() + expires_in * 1000).toISOString()
            : null;

        // Armazenar temporariamente os tokens e dados para processamento posterior
        // Usar uma sess√£o tempor√°ria ou passar via state
        const tempSessionId = `temp_${userId}_${Date.now()}`;
        
        // Salvar dados tempor√°rios (em produ√ß√£o, use Redis ou similar)
        // Por enquanto, vamos passar via query params criptografados ou usar uma abordagem diferente
        // Vou criar uma rota POST para processar a sele√ß√£o
        
        // Retornar p√°gina de sele√ß√£o de canais
        const channelsHTML = selectableChannels.map((channel, index) => `
            <div class="channel-item" style="display: flex; align-items: center; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 8px; margin-bottom: 1rem; cursor: pointer; transition: all 0.3s;" 
                 onmouseover="this.style.background='rgba(255,255,255,0.2)'" 
                 onmouseout="this.style.background='rgba(255,255,255,0.1)'"
                 onclick="toggleChannel('${channel.id}', '${channel.name.replace(/'/g, "\\'")}')">
                <input type="checkbox" id="channel_${channel.id}" value="${channel.id}" style="margin-right: 1rem; width: 20px; height: 20px; cursor: pointer;">
                ${channel.thumbnail ? `<img src="${channel.thumbnail}" style="width: 48px; height: 48px; border-radius: 50%; margin-right: 1rem;" alt="${channel.name}">` : ''}
                <div style="flex: 1;">
                    <div style="font-weight: bold; margin-bottom: 0.25rem;">${channel.name}</div>
                    <div style="font-size: 0.85rem; opacity: 0.8;">ID: ${channel.id}</div>
                </div>
            </div>
        `).join('');

        res.status(200).send(`
            <!DOCTYPE html>
            <html>
            <head>
                <title>Selecionar Canais - YouTube</title>
                <style>
                    * { box-sizing: border-box; }
                    body {
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                        margin: 0;
                        padding: 2rem;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        min-height: 100vh;
                    }
                    .container {
                        max-width: 600px;
                        margin: 0 auto;
                        background: rgba(255, 255, 255, 0.1);
                        border-radius: 15px;
                        padding: 2rem;
                        backdrop-filter: blur(10px);
                    }
                    h1 { margin-top: 0; text-align: center; }
                    .info {
                        background: rgba(255, 255, 255, 0.15);
                        padding: 1rem;
                        border-radius: 8px;
                        margin-bottom: 1.5rem;
                        font-size: 0.9rem;
                    }
                    .channel-item:hover {
                        transform: translateX(5px);
                    }
                    .actions {
                        display: flex;
                        gap: 1rem;
                        margin-top: 2rem;
                    }
                    button {
                        flex: 1;
                        padding: 1rem;
                        border: none;
                        border-radius: 8px;
                        font-size: 1rem;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.3s;
                    }
                    .btn-primary {
                        background: white;
                        color: #667eea;
                    }
                    .btn-primary:hover {
                        background: #f0f0f0;
                        transform: scale(1.02);
                    }
                    .btn-secondary {
                        background: rgba(255, 255, 255, 0.2);
                        color: white;
                    }
                    .btn-secondary:hover {
                        background: rgba(255, 255, 255, 0.3);
                    }
                    .btn-primary:disabled {
                        opacity: 0.5;
                        cursor: not-allowed;
                    }
                </style>
            </head>
            <body>
                <div class="container">
                    <h1>üé¨ Selecione os Canais</h1>
                    <div class="info">
                        <strong>üìä Encontrados:</strong> ${selectableChannels.length} canal(is) dispon√≠vel(is)<br>
                        <strong>‚úÖ Voc√™ pode selecionar at√©:</strong> ${remainingSlots} canal(is)
                    </div>
                    <form id="channelsForm">
                        ${channelsHTML}
                    </form>
                    <div class="actions">
                        <button type="button" class="btn-secondary" onclick="window.close()">Cancelar</button>
                        <button type="button" class="btn-primary" id="connectBtn" onclick="connectSelectedChannels()" disabled>
                            Conectar Canais Selecionados (0)
                        </button>
                    </div>
                </div>
                <script>
                    const selectedChannels = new Set();
                    const channelsData = ${JSON.stringify(selectableChannels)};
                    const accessToken = '${access_token}';
                    const refreshToken = '${refresh_token || ''}';
                    const expiresAt = '${expiresAt || ''}';
                    const userId = ${userId};
                    
                    function toggleChannel(channelId, channelName) {
                        const checkbox = document.getElementById('channel_' + channelId);
                        if (selectedChannels.has(channelId)) {
                            selectedChannels.delete(channelId);
                            checkbox.checked = false;
                        } else {
                            selectedChannels.add(channelId);
                            checkbox.checked = true;
                        }
                        updateButton();
                    }
                    
                    function updateButton() {
                        const btn = document.getElementById('connectBtn');
                        const count = selectedChannels.size;
                        btn.disabled = count === 0;
                        btn.textContent = 'Conectar Canais Selecionados (' + count + ')';
                    }
                    
                    async function connectSelectedChannels() {
                        if (selectedChannels.size === 0) return;
                        
                        const btn = document.getElementById('connectBtn');
                        btn.disabled = true;
                        btn.textContent = 'Conectando...';
                        
                        try {
                            // Detectar a URL base automaticamente
                            // Se estiver em localhost, usar porta 5001, sen√£o usar a mesma origem
                            let apiBase;
                            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                                apiBase = 'http://localhost:5001';
                            } else {
                                // Em produ√ß√£o, usar a mesma origem
                                apiBase = window.location.origin;
                            }
                            
                            const response = await fetch(apiBase + '/api/youtube/oauth/connect-channels', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    userId: userId,
                                    channelIds: Array.from(selectedChannels),
                                    accessToken: accessToken,
                                    refreshToken: refreshToken,
                                    expiresAt: expiresAt
                                })
                            });
                            
                            const data = await response.json();
                            
                            if (response.ok) {
                                document.body.innerHTML = \`
                                    <div class="container" style="text-align: center;">
                                        <h1>‚úÖ Canais Conectados com Sucesso!</h1>
                                        <p>\${data.connected} canal(is) conectado(s)</p>
                                        <p>Voc√™ pode fechar esta janela e voltar ao dashboard.</p>
                                        <button class="btn-primary" onclick="window.close()">Fechar</button>
                                    </div>
                                \`;
                            } else {
                                throw new Error(data.msg || 'Erro ao conectar canais');
                            }
                        } catch (err) {
                            alert('Erro: ' + err.message);
                            btn.disabled = false;
                            updateButton();
                        }
                    }
                    
                    // Permitir clicar em qualquer lugar do item para selecionar
                    document.querySelectorAll('.channel-item').forEach(item => {
                        item.addEventListener('click', function(e) {
                            if (e.target.type !== 'checkbox') {
                                const checkbox = this.querySelector('input[type="checkbox"]');
                                checkbox.click();
                            }
                        });
                    });
                </script>
            </body>
            </html>
        `);
    } catch (err) {
        console.error('[YouTube OAuth] Erro no callback:', err);
        return res.status(500).json({ msg: `Erro ao processar autoriza√ß√£o: ${err.message}` });
    }
});

// === PARTE 2: AUTOMA√á√ÉO E INTEGRA√á√ÉO COM YOUTUBE ===

// A.1 - Agendamento Inteligente: IA sugere melhor hor√°rio para publicar baseado no nicho
app.post('/api/youtube/suggest-best-time', authenticateToken, async (req, res) => {
    const { niche, subniche, timezone } = req.body;
    const userId = req.user.id;

    if (!niche) {
        return res.status(400).json({ msg: 'Nicho √© obrigat√≥rio para sugerir hor√°rio.' });
    }

    try {
        // Verificar se deve usar cr√©ditos (laozhang.ai) ou API pr√≥pria
        // REGRA: Usa cr√©ditos se usu√°rio marcou prefer√™ncia OU n√£o tem plano que permite API pr√≥pria OU n√£o tem API pr√≥pria configurada
        // REGRA CR√çTICA: Se prefer√™ncia N√ÉO est√° marcada E usu√°rio tem plano que permite E tem API pr√≥pria ‚Üí usar API pr√≥pria
        const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
        
        let bestTime = null;
        let explanation = '';
        
        // Se deve usar cr√©ditos, usar laozhang.ai primeiro
        if (creditsCheck.shouldUse) {
            const laozhangKey = await getLaozhangApiKey();
            if (laozhangKey) {
                try {
                    const prompt = `Voc√™ √© um especialista em estrat√©gia de YouTube e an√°lise de dados de engajamento.

Analise o nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''} e sugira o MELHOR hor√°rio para publicar v√≠deos neste nicho.

Considere:
1. Hor√°rios de pico de engajamento para este nicho espec√≠fico
2. Fuso hor√°rio do p√∫blico-alvo (principalmente Brasil/Am√©rica Latina)
3. Dias da semana que performam melhor
4. Padr√µes de comportamento do p√∫blico deste nicho

Responda APENAS com um JSON v√°lido no formato:
{
  "bestTime": "HH:MM" (formato 24h, ex: "18:00"),
  "bestDays": ["segunda", "ter√ßa", "quarta", "quinta", "sexta", "s√°bado", "domingo"] (array com os melhores dias),
  "explanation": "Explica√ß√£o detalhada do porqu√™ este hor√°rio √© ideal",
  "alternativeTimes": ["HH:MM", "HH:MM"] (2-3 hor√°rios alternativos)
}

IMPORTANTE: Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await callLaozhangAPI(prompt, laozhangKey, 'gpt-4o', null, userId, '/api/youtube/suggest-best-time', JSON.stringify({ endpoint: '/api/youtube/suggest-best-time', model: 'gpt-4o' }));
                    const responseText = response.titles || response.text || '';
                    
                    // Tentar extrair JSON da resposta
                    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.bestTime) {
                                bestTime = parsed;
                                explanation = parsed.explanation || '';
                                console.log(`[Agendamento Inteligente] Hor√°rio sugerido usando API configurada como padr√£o: ${parsed.bestTime}`);
                            }
                        } catch (e) {
                            console.warn(`[Agendamento Inteligente] Falha ao parsear JSON:`, e.message);
                        }
                    }
                } catch (serviceErr) {
                    console.warn(`[Agendamento Inteligente] Falha com API configurada como padr√£o:`, serviceErr.message);
                }
            }
        }
        
        // Se n√£o usar cr√©ditos ou se laozhang falhou, usar APIs pr√≥prias
        if (!bestTime) {
            // Tentar usar Gemini primeiro, depois Claude, depois OpenAI
            const services = ['gemini', 'claude', 'openai'];

            for (const service of services) {
                try {
                    const serviceKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                    if (!serviceKeyData) continue;

                    const decryptedKey = decrypt(serviceKeyData.api_key);
                    if (!decryptedKey) continue;

                    let apiCallFunction;
                    let model;
                    if (service === 'gemini') {
                        apiCallFunction = callGeminiAPI;
                        model = 'gemini-2.0-flash';
                    } else if (service === 'claude') {
                        apiCallFunction = callClaudeAPI;
                        model = 'claude-3-5-haiku-20241022';
                    } else {
                        apiCallFunction = callOpenAIAPI;
                        model = 'gpt-4o-mini';
                    }

                    const prompt = `Voc√™ √© um especialista em estrat√©gia de YouTube e an√°lise de dados de engajamento.

Analise o nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''} e sugira o MELHOR hor√°rio para publicar v√≠deos neste nicho.

Considere:
1. Hor√°rios de pico de engajamento para este nicho espec√≠fico
2. Fuso hor√°rio do p√∫blico-alvo (principalmente Brasil/Am√©rica Latina)
3. Dias da semana que performam melhor
4. Padr√µes de comportamento do p√∫blico deste nicho

Responda APENAS com um JSON v√°lido no formato:
{
  "bestTime": "HH:MM" (formato 24h, ex: "18:00"),
  "bestDays": ["segunda", "ter√ßa", "quarta", "quinta", "sexta", "s√°bado", "domingo"] (array com os melhores dias),
  "explanation": "Explica√ß√£o detalhada do porqu√™ este hor√°rio √© ideal",
  "alternativeTimes": ["HH:MM", "HH:MM"] (2-3 hor√°rios alternativos)
}

IMPORTANTE: Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await apiCallFunction(prompt, decryptedKey, model);
                    const responseText = response.titles || response.text || '';
                    
                    // Tentar extrair JSON da resposta
                    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.bestTime) {
                                bestTime = parsed;
                                explanation = parsed.explanation || '';
                                console.log(`[Agendamento Inteligente] Hor√°rio sugerido usando ${service}: ${parsed.bestTime}`);
                                break;
                            }
                        } catch (e) {
                            console.warn(`[Agendamento Inteligente] Falha ao parsear JSON de ${service}:`, e.message);
                        }
                    }
                } catch (serviceErr) {
                    console.warn(`[Agendamento Inteligente] Falha com ${service}:`, serviceErr.message);
                    continue;
                }
            }
        }

        // Fallback: hor√°rios padr√£o baseados em pesquisas gerais
        if (!bestTime) {
            const defaultTimes = {
                'Entretenimento': { bestTime: '18:00', bestDays: ['sexta', 's√°bado', 'domingo'], explanation: 'Hor√°rio de pico para entretenimento: fim de tarde e fins de semana' },
                'Educa√ß√£o': { bestTime: '19:00', bestDays: ['segunda', 'ter√ßa', 'quarta', 'quinta'], explanation: 'Hor√°rio ideal para conte√∫do educativo: in√≠cio da noite em dias √∫teis' },
                'Tecnologia': { bestTime: '20:00', bestDays: ['ter√ßa', 'quarta', 'quinta'], explanation: 'P√∫blico de tecnologia mais ativo no in√≠cio da noite' },
                'Finan√ßas': { bestTime: '08:00', bestDays: ['segunda', 'ter√ßa', 'quarta'], explanation: 'Hor√°rio de trabalho: p√∫blico financeiro mais ativo pela manh√£' }
            };
            
            const nicheKey = Object.keys(defaultTimes).find(k => niche.toLowerCase().includes(k.toLowerCase()));
            bestTime = nicheKey ? defaultTimes[nicheKey] : { bestTime: '18:00', bestDays: ['sexta', 's√°bado'], explanation: 'Hor√°rio padr√£o otimizado para engajamento geral' };
            bestTime.alternativeTimes = ['16:00', '20:00'];
        }

        res.status(200).json({
            suggestedTime: bestTime.bestTime,
            suggestedDays: bestTime.bestDays || ['sexta', 's√°bado'],
            explanation: bestTime.explanation || explanation,
            alternativeTimes: bestTime.alternativeTimes || []
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/suggest-best-time]:', err);
        res.status(500).json({ msg: 'Erro ao sugerir hor√°rio de publica√ß√£o.' });
    }
});

// A.3 - Auto-tags e Descri√ß√£o: Preencher automaticamente tags e descri√ß√£o otimizadas
app.post('/api/youtube/generate-metadata', authenticateToken, async (req, res) => {
    const { title, model: requestedModel, niche, subniche, videoDescription } = req.body;
    const userId = req.user.id;

    if (!title) {
        return res.status(400).json({ msg: 'T√≠tulo √© obrigat√≥rio para gerar metadata.' });
    }

    try {
        // Verificar se deve usar cr√©ditos (laozhang.ai) ou API pr√≥pria
        // REGRA: Usa cr√©ditos se usu√°rio marcou prefer√™ncia OU n√£o tem plano que permite API pr√≥pria OU n√£o tem API pr√≥pria configurada
        // REGRA CR√çTICA: Se prefer√™ncia N√ÉO est√° marcada E usu√°rio tem plano que permite E tem API pr√≥pria ‚Üí usar API pr√≥pria
        const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
        
        console.log(`[Generate Metadata] shouldUseCredits: ${creditsCheck.shouldUse}, reason: ${creditsCheck.reason}, requestedModel: ${requestedModel}`);
        
        let metadata = null;
        
        // Se deve usar cr√©ditos, usar laozhang.ai
        if (creditsCheck.shouldUse) {
            console.log('[Generate Metadata] Verificando chave laozhang.ai...');
            const laozhangKey = await getLaozhangApiKey();
            console.log('[Generate Metadata] Chave laozhang.ai encontrada:', laozhangKey ? 'Sim' : 'N√£o');
            if (laozhangKey) {
                // Determinar modelo a usar
                let modelToUse = 'gpt-4o';
                if (requestedModel) {
                    if (requestedModel.includes('gpt') || requestedModel === 'gpt-4o') {
                        modelToUse = 'gpt-4o';
                    } else if (requestedModel.includes('claude') || requestedModel === 'claude-3-7-sonnet-20250219') {
                        modelToUse = 'claude-3-7-sonnet-20250219';
                    } else if (requestedModel.includes('gemini') || requestedModel === 'gemini-2.5-pro') {
                        modelToUse = 'gemini-2.5-pro';
                    }
                }
                
                try {
                    const prompt = `Voc√™ √© um ESPECIALISTA EM ALGORITMO DO YOUTUBE e otimiza√ß√£o de conte√∫do, com conhecimento profundo sobre como o algoritmo do YouTube classifica, recomenda e promove v√≠deos.

T√≠tulo do v√≠deo: "${title}"
${niche ? `Nicho: "${niche}"` : ''}
${subniche ? `Subnicho: "${subniche}"` : ''}
${videoDescription ? `Descri√ß√£o do conte√∫do: "${videoDescription}"` : ''}

Sua tarefa √© gerar metadata ALTAMENTE OTIMIZADA PARA O ALGORITMO DO YOUTUBE:

1. DESCRI√á√ÉO OTIMIZADA PARA O ALGORITMO DO YOUTUBE (M√ÅXIMO 500 CARACTERES):
   
   ESTRUTURA OBRIGAT√ìRIA (seguir EXATAMENTE nesta ordem):
   
   a) PRIMEIRA LINHA (Hook + Palavra-chave principal):
      - Repetir a palavra-chave principal do t√≠tulo nas primeiras palavras
      - Criar um hook que desperte curiosidade e aumente CTR
      - Exemplo: "Descubra como [palavra-chave] mudou tudo..."
   
   b) SEGUNDA E TERCEIRA LINHAS (Conte√∫do + Contexto):
      - Expandir o tema usando varia√ß√µes da palavra-chave
      - Adicionar contexto que o algoritmo usa para categorizar
      - Incluir termos relacionados que o YouTube associa ao conte√∫do
   
   c) QUARTA LINHA (Call-to-Action):
      - CTA direto para aumentar engajamento (inscrever-se, like, comentar)
      - Use emojis estrat√©gicos (m√°ximo 3-4) para aumentar CTR
   
   d) √öLTIMA LINHA (Hashtags):
      - 2-3 hashtags relevantes (sem # no in√≠cio, apenas o texto)
      - Use hashtags que o YouTube reconhece como categorias
   
   REGRAS PARA O ALGORITMO:
   - Palavras-chave principais devem aparecer nas primeiras 125 caracteres (YouTube indexa isso)
   - Use termos que o YouTube associa a v√≠deos virais no nicho
   - Evite palavras gen√©ricas, seja espec√≠fico
   - Estrutura clara ajuda o algoritmo a entender o conte√∫do
   - M√ÅXIMO 500 caracteres (o algoritmo prioriza descri√ß√µes concisas)

2. TAGS OTIMIZADAS PARA O ALGORITMO (25-35 tags):

   DISTRIBUI√á√ÉO ESTRAT√âGICA:
   
   a) Palavras-chave principais (8-10 tags):
      - Extrair todas as palavras-chave importantes do t√≠tulo
      - Incluir varia√ß√µes exatas das palavras do t√≠tulo
      - Exemplo: se t√≠tulo tem "jantar fam√≠lia", incluir "jantar", "fam√≠lia", "jantar fam√≠lia"
   
   b) Long-tail keywords (8-10 tags):
      - Frases de busca que pessoas realmente usam
      - Termos de 3-5 palavras que combinam palavras-chave
      - Exemplo: "jantar em fam√≠lia", "hist√≥ria de fam√≠lia", "testamento fam√≠lia"
   
   c) Termos relacionados ao nicho (5-7 tags):
      - Termos que o YouTube associa ao conte√∫do similar
      - Palavras que aparecem em v√≠deos virais do mesmo tema
      - Termos de tend√™ncia no nicho
   
   d) Termos em ingl√™s estrat√©gicos (4-6 tags):
      - Tradu√ß√µes das palavras-chave principais
      - Termos internacionais que aumentam alcance
      - Misture portugu√™s e ingl√™s
   
   ESTRAT√âGIA PARA O ALGORITMO:
   - Primeiras 5 tags s√£o as MAIS IMPORTANTES (YouTube prioriza)
   - Use tags que aparecem em v√≠deos com alta performance no nicho
   - Evite tags gen√©ricas demais (ex: "v√≠deo", "youtube")
   - Foque em tags espec√≠ficas que o algoritmo usa para recomendar
   - Total: 25-35 tags (YouTube permite at√© 500 caracteres em tags)

REGRAS CR√çTICAS PARA O ALGORITMO:
- Descri√ß√£o: M√ÅXIMO 500 caracteres, palavras-chave nas primeiras 125
- Tags: 25-35 tags, primeiras 5 s√£o cr√≠ticas
- SEO: Otimize para busca E recomenda√ß√£o do algoritmo
- Engajamento: CTAs aumentam sinais de engajamento (algoritmo prioriza)
- Idioma: Portugu√™s (Brasil) para descri√ß√£o, portugu√™s + ingl√™s para tags
- Especificidade: Seja espec√≠fico, n√£o gen√©rico (algoritmo recompensa)

Responda APENAS com um JSON v√°lido no formato:
{
  "description": "Descri√ß√£o otimizada para algoritmo do YouTube (m√°ximo 500 caracteres)...",
  "tags": ["tag1", "tag2", "tag3", ...] (25-35 tags, primeiras 5 s√£o as mais importantes)
}

IMPORTANTE: A descri√ß√£o deve seguir EXATAMENTE a estrutura: Hook+Palavra-chave ‚Üí Conte√∫do ‚Üí CTA ‚Üí Hashtags

Responda APENAS com o JSON, sem texto adicional.`;

                    console.log(`[Auto-metadata] Chamando API configurada como padr√£o com modelo ${modelToUse} para gerar metadata`);
                    const response = await callLaozhangAPI(prompt, laozhangKey, modelToUse, null, userId, '/api/youtube/generate-metadata', JSON.stringify({ endpoint: '/api/youtube/generate-metadata', model: modelToUse }));
                    // callLaozhangAPI retorna uma string diretamente, n√£o um objeto
                    const responseText = typeof response === 'string' ? response : (response?.titles || response?.text || response?.content || JSON.stringify(response) || '');
                    
                    console.log(`[Auto-metadata] Resposta recebida da API configurada como padr√£o (${responseText.length} caracteres)`);
                    console.log(`[Auto-metadata] Primeiros 500 caracteres da resposta:`, responseText.substring(0, 500));
                    
                    // Verificar se a API recusou a requisi√ß√£o (apenas se for uma mensagem de erro clara, n√£o JSON v√°lido)
                    const hasValidJson = responseText.match(/\{[\s\S]*"description"[\s\S]*\}/) || responseText.match(/\{[\s\S]*"tags"[\s\S]*\}/);
                    
                    if (!hasValidJson) {
                        const errorPatterns = [
                            /^I'm sorry,?\s+I can't assist/i,
                            /^I'm sorry,?\s+I cannot/i,
                            /^I'm unable to assist/i,
                            /^I cannot fulfill/i,
                            /^I must decline/i,
                            /^I can't help with that/i,
                            /^I'm not able to/i,
                            /^This request violates/i,
                            /^I cannot comply/i
                        ];
                        
                        const trimmedResponse = responseText.trim();
                        const isError = errorPatterns.some(pattern => pattern.test(trimmedResponse));
                        
                        if (isError || (trimmedResponse.length < 100 && trimmedResponse.toLowerCase().startsWith("i'm sorry"))) {
                            console.error('[Auto-metadata] API recusou a requisi√ß√£o:', responseText.substring(0, 500));
                            throw new Error(`A API de IA recusou processar o prompt. Isso pode acontecer se o conte√∫do violar as pol√≠ticas de uso da API. Tente simplificar o conte√∫do ou remover conte√∫do sens√≠vel.`);
                        }
                    }
                    
                    // Tentar extrair JSON da resposta - usar regex mais robusto para pegar JSON completo
                    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    // Se n√£o encontrar, tentar remover markdown code blocks
                    if (!jsonMatch) {
                        const cleaned = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                        jsonMatch = cleaned.match(/\{[\s\S]*\}/);
                    }
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.description && parsed.tags && Array.isArray(parsed.tags)) {
                                // Garantir que a descri√ß√£o n√£o ultrapasse 500 caracteres
                                if (parsed.description.length > 500) {
                                    parsed.description = parsed.description.substring(0, 497) + '...';
                                    console.log(`[Auto-metadata] Descri√ß√£o truncada para 500 caracteres`);
                                }
                                
                                // Limitar tags a 35 e garantir que sejam strings v√°lidas
                                parsed.tags = parsed.tags
                                    .filter(tag => tag && typeof tag === 'string' && tag.trim().length > 0)
                                    .map(tag => tag.trim())
                                    .slice(0, 35);
                                
                                metadata = parsed;
                                console.log(`[Auto-metadata] ‚úÖ Metadata gerada usando API configurada como padr√£o com modelo ${modelToUse} (${parsed.tags.length} tags, descri√ß√£o: ${parsed.description.length} caracteres)`);
                            } else {
                                console.warn(`[Auto-metadata] Resposta da API configurada como padr√£o n√£o tem formato esperado`);
                                console.warn(`[Auto-metadata] Resposta completa:`, responseText.substring(0, 1000));
                            }
                        } catch (e) {
                            console.warn(`[Auto-metadata] Falha ao parsear JSON:`, e.message);
                        }
                    } else {
                        console.warn(`[Auto-metadata] Nenhum JSON encontrado na resposta da API configurada como padr√£o`);
                    }
                } catch (serviceErr) {
                    console.error(`[Auto-metadata] Erro ao usar API configurada como padr√£o:`, serviceErr.message);
                    // Se deve usar cr√©ditos e laozhang falhou, n√£o tentar APIs pr√≥prias
                    if (creditsCheck.shouldUse) {
                        return res.status(500).json({ 
                            msg: 'Erro ao gerar metadata usando sistema de cr√©ditos. Verifique se a chave est√° configurada corretamente no painel admin.' 
                        });
                    }
                }
            } else if (creditsCheck.shouldUse) {
                // Se deve usar cr√©ditos mas n√£o tem chave
                return res.status(400).json({ 
                    msg: 'Sistema de cr√©ditos n√£o est√° configurado. Configure a chave no painel admin ou configure uma API pr√≥pria nas Configura√ß√µes.' 
                });
            }
        }
        
        // Se n√£o usar cr√©ditos ou se laozhang falhou (e n√£o √© obrigat√≥rio), usar APIs pr√≥prias
        if (!metadata && !creditsCheck.shouldUse) {
            // Se o modelo foi especificado, usar APENAS ele (n√£o tentar todos)
            let service = null;
            let targetModel = requestedModel || null;
            
            if (targetModel) {
                // Mapear modelo para servi√ßo - usar APENAS o servi√ßo correspondente
                if (targetModel.includes('gpt') || targetModel === 'gpt-4o') {
                    service = 'openai';
                    targetModel = 'gpt-4o';
                } else if (targetModel.includes('claude') || targetModel === 'claude-3-7-sonnet-20250219') {
                    service = 'claude';
                    targetModel = 'claude-3-7-sonnet-20250219';
                } else if (targetModel.includes('gemini') || targetModel === 'gemini-2.5-pro') {
                    service = 'gemini';
                    targetModel = 'gemini-2.5-pro';
                }
            }
            
            // Se n√£o especificou modelo ou n√£o encontrou correspond√™ncia, tentar todos (fallback)
            const services = service ? [service] : ['gemini', 'claude', 'openai'];

            for (const serviceToUse of services) {
                try {
                    const serviceKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, serviceToUse]);
                    if (!serviceKeyData) {
                        if (service) {
                            // Se especificou um modelo mas n√£o tem a chave, retornar erro
                            return res.status(400).json({ 
                                msg: `Chave de API do ${serviceToUse === 'openai' ? 'OpenAI' : serviceToUse === 'claude' ? 'Claude' : 'Gemini'} n√£o configurada. Configure a chave nas Configura√ß√µes.` 
                            });
                        }
                        continue;
                    }

                    const decryptedKey = decrypt(serviceKeyData.api_key);
                    if (!decryptedKey) {
                        if (service) {
                            return res.status(500).json({ msg: 'Falha ao desencriptar a chave de API.' });
                        }
                        continue;
                    }

                    let apiCallFunction;
                    let model;
                    if (serviceToUse === 'gemini') {
                        apiCallFunction = callGeminiAPI;
                        model = targetModel && targetModel.includes('gemini') ? targetModel : 'gemini-2.5-pro';
                    } else if (serviceToUse === 'claude') {
                        apiCallFunction = callClaudeAPI;
                        model = targetModel && targetModel.includes('claude') ? targetModel : 'claude-3-7-sonnet-20250219';
                    } else {
                        apiCallFunction = callOpenAIAPI;
                        model = targetModel && targetModel.includes('gpt') ? targetModel : 'gpt-4o';
                    }
                    
                    console.log(`[Auto-metadata] Usando ${serviceToUse} com modelo ${model}`);

                    const prompt = `Voc√™ √© um ESPECIALISTA EM ALGORITMO DO YOUTUBE e otimiza√ß√£o de conte√∫do, com conhecimento profundo sobre como o algoritmo do YouTube classifica, recomenda e promove v√≠deos.

T√≠tulo do v√≠deo: "${title}"
${niche ? `Nicho: "${niche}"` : ''}
${subniche ? `Subnicho: "${subniche}"` : ''}
${videoDescription ? `Descri√ß√£o do conte√∫do: "${videoDescription}"` : ''}

Sua tarefa √© gerar metadata ALTAMENTE OTIMIZADA PARA O ALGORITMO DO YOUTUBE:

1. DESCRI√á√ÉO OTIMIZADA PARA O ALGORITMO DO YOUTUBE (M√ÅXIMO 500 CARACTERES):
   
   ESTRUTURA OBRIGAT√ìRIA (seguir EXATAMENTE nesta ordem):
   
   a) PRIMEIRA LINHA (Hook + Palavra-chave principal):
      - Repetir a palavra-chave principal do t√≠tulo nas primeiras palavras
      - Criar um hook que desperte curiosidade e aumente CTR
      - Exemplo: "Descubra como [palavra-chave] mudou tudo..."
   
   b) SEGUNDA E TERCEIRA LINHAS (Conte√∫do + Contexto):
      - Expandir o tema usando varia√ß√µes da palavra-chave
      - Adicionar contexto que o algoritmo usa para categorizar
      - Incluir termos relacionados que o YouTube associa ao conte√∫do
   
   c) QUARTA LINHA (Call-to-Action):
      - CTA direto para aumentar engajamento (inscrever-se, like, comentar)
      - Use emojis estrat√©gicos (m√°ximo 3-4) para aumentar CTR
   
   d) √öLTIMA LINHA (Hashtags):
      - 2-3 hashtags relevantes (sem # no in√≠cio, apenas o texto)
      - Use hashtags que o YouTube reconhece como categorias
   
   REGRAS PARA O ALGORITMO:
   - Palavras-chave principais devem aparecer nas primeiras 125 caracteres (YouTube indexa isso)
   - Use termos que o YouTube associa a v√≠deos virais no nicho
   - Evite palavras gen√©ricas, seja espec√≠fico
   - Estrutura clara ajuda o algoritmo a entender o conte√∫do
   - M√ÅXIMO 500 caracteres (o algoritmo prioriza descri√ß√µes concisas)

2. TAGS OTIMIZADAS PARA O ALGORITMO (25-35 tags):

   DISTRIBUI√á√ÉO ESTRAT√âGICA:
   
   a) Palavras-chave principais (8-10 tags):
      - Extrair todas as palavras-chave importantes do t√≠tulo
      - Incluir varia√ß√µes exatas das palavras do t√≠tulo
      - Exemplo: se t√≠tulo tem "jantar fam√≠lia", incluir "jantar", "fam√≠lia", "jantar fam√≠lia"
   
   b) Long-tail keywords (8-10 tags):
      - Frases de busca que pessoas realmente usam
      - Termos de 3-5 palavras que combinam palavras-chave
      - Exemplo: "jantar em fam√≠lia", "hist√≥ria de fam√≠lia", "testamento fam√≠lia"
   
   c) Termos relacionados ao nicho (5-7 tags):
      - Termos que o YouTube associa ao conte√∫do similar
      - Palavras que aparecem em v√≠deos virais do mesmo tema
      - Termos de tend√™ncia no nicho
   
   d) Termos em ingl√™s estrat√©gicos (4-6 tags):
      - Tradu√ß√µes das palavras-chave principais
      - Termos internacionais que aumentam alcance
      - Misture portugu√™s e ingl√™s
   
   ESTRAT√âGIA PARA O ALGORITMO:
   - Primeiras 5 tags s√£o as MAIS IMPORTANTES (YouTube prioriza)
   - Use tags que aparecem em v√≠deos com alta performance no nicho
   - Evite tags gen√©ricas demais (ex: "v√≠deo", "youtube")
   - Foque em tags espec√≠ficas que o algoritmo usa para recomendar
   - Total: 25-35 tags (YouTube permite at√© 500 caracteres em tags)

REGRAS CR√çTICAS PARA O ALGORITMO:
- Descri√ß√£o: M√ÅXIMO 500 caracteres, palavras-chave nas primeiras 125
- Tags: 25-35 tags, primeiras 5 s√£o cr√≠ticas
- SEO: Otimize para busca E recomenda√ß√£o do algoritmo
- Engajamento: CTAs aumentam sinais de engajamento (algoritmo prioriza)
- Idioma: Portugu√™s (Brasil) para descri√ß√£o, portugu√™s + ingl√™s para tags
- Especificidade: Seja espec√≠fico, n√£o gen√©rico (algoritmo recompensa)

Responda APENAS com um JSON v√°lido no formato:
{
  "description": "Descri√ß√£o otimizada para algoritmo do YouTube (m√°ximo 500 caracteres)...",
  "tags": ["tag1", "tag2", "tag3", ...] (25-35 tags, primeiras 5 s√£o as mais importantes)
}

IMPORTANTE: A descri√ß√£o deve seguir EXATAMENTE a estrutura: Hook+Palavra-chave ‚Üí Conte√∫do ‚Üí CTA ‚Üí Hashtags

Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await apiCallFunction(prompt, decryptedKey, model);
                    // A resposta pode ser string direta ou objeto
                    const responseText = typeof response === 'string' ? response : (response?.titles || response?.text || response?.content || JSON.stringify(response) || '');
                    
                    console.log(`[Auto-metadata] Resposta de ${serviceToUse} (modelo ${model}):`, responseText.substring(0, 200));
                    console.log(`[Auto-metadata] Tamanho da resposta: ${responseText.length} caracteres`);
                    
                    // Tentar extrair JSON da resposta - usar regex mais robusto para pegar JSON completo
                    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    // Se n√£o encontrar, tentar remover markdown code blocks
                    if (!jsonMatch) {
                        const cleaned = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                        jsonMatch = cleaned.match(/\{[\s\S]*\}/);
                    }
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.description && parsed.tags && Array.isArray(parsed.tags)) {
                                // Garantir que a descri√ß√£o n√£o ultrapasse 500 caracteres
                                if (parsed.description.length > 500) {
                                    parsed.description = parsed.description.substring(0, 497) + '...';
                                    console.log(`[Auto-metadata] Descri√ß√£o truncada para 500 caracteres`);
                                }
                                
                                // Limitar tags a 35 e garantir que sejam strings v√°lidas
                                // IMPORTANTE: Ordenar tags para que as mais importantes fiquem primeiro (YouTube prioriza)
                                parsed.tags = parsed.tags
                                    .filter(tag => tag && typeof tag === 'string' && tag.trim().length > 0)
                                    .map(tag => tag.trim())
                                    .slice(0, 35);
                                
                                metadata = parsed;
                                console.log(`[Auto-metadata] ‚úÖ Metadata gerada usando ${serviceToUse} com modelo ${model} (${parsed.tags.length} tags, descri√ß√£o: ${parsed.description.length} caracteres)`);
                                console.log(`[Auto-metadata] Primeiras 5 tags (mais importantes):`, parsed.tags.slice(0, 5).join(', '));
                                break; // Parar o loop quando encontrar sucesso
                            }
                        } catch (e) {
                            console.warn(`[Auto-metadata] Falha ao parsear JSON de ${serviceToUse}:`, e.message);
                        }
                    }
                } catch (serviceErr) {
                    console.warn(`[Auto-metadata] Falha com ${serviceToUse}:`, serviceErr.message);
                    // Se especificou um modelo e falhou, retornar erro
                    if (service) {
                        return res.status(500).json({ 
                            msg: `Erro ao gerar metadata usando ${serviceToUse === 'openai' ? 'OpenAI' : serviceToUse === 'claude' ? 'Claude' : 'Gemini'}. Verifique sua chave de API.` 
                        });
                    }
                    continue;
                }
            }
        }

        // Fallback: gerar metadata b√°sica
        if (!metadata) {
            const keywords = title.toLowerCase().split(/\s+/).filter(w => w.length > 3);
            const fallbackDescription = `${title}\n\n${videoDescription || 'Conte√∫do exclusivo sobre ' + (subniche || niche || 'este tema') + '. N√£o perca!'}\n\nüîî Inscreva-se no canal para mais conte√∫do!\nüëç Deixe seu like se gostou!\nüí¨ Comente o que achou!\n\n#${(subniche || niche || 'youtube').replace(/\s+/g, '')}`;
            
            // Gerar mais tags do fallback
            const baseTags = keywords.slice(0, 20);
            const nicheTags = [niche, subniche].filter(Boolean);
            const relatedTags = niche ? [
                `${niche} brasil`,
                `${niche} youtube`,
                `${niche} 2025`,
                `v√≠deo ${niche}`,
                `conte√∫do ${niche}`
            ] : [];
            
            metadata = {
                description: fallbackDescription.length > 500 ? fallbackDescription.substring(0, 497) + '...' : fallbackDescription,
                tags: [...baseTags, ...nicheTags, ...relatedTags].slice(0, 35)
            };
        }

        // Valida√ß√£o final: garantir que descri√ß√£o n√£o ultrapasse 500 caracteres
        if (metadata.description && metadata.description.length > 500) {
            metadata.description = metadata.description.substring(0, 497) + '...';
            console.log(`[Auto-metadata] ‚ö†Ô∏è Descri√ß√£o final truncada para 500 caracteres`);
        }
        
        // Valida√ß√£o final: garantir que tags sejam v√°lidas e limitadas a 35
        if (metadata.tags && Array.isArray(metadata.tags)) {
            metadata.tags = metadata.tags
                .filter(tag => tag && typeof tag === 'string' && tag.trim().length > 0)
                .map(tag => tag.trim())
                .slice(0, 35);
        }
        
        res.status(200).json({
            description: metadata.description,
            tags: metadata.tags
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/generate-metadata]:', err);
        res.status(500).json({ msg: 'Erro ao gerar metadata.' });
    }
});

// === ROTAS DE GERA√á√ÉO DE V√çDEO (VEO) ===

// Armazenar opera√ß√µes de gera√ß√£o de v√≠deo em mem√≥ria (em produ√ß√£o, usar Redis ou banco)
const videoOperations = new Map();

const decodeOperationId = (encodedId) => {
    try {
        let decoded = decodeURIComponent(encodedId);
        decoded = decoded.replace(/^\/+/, '');
        return decoded;
    } catch (error) {
        console.error('[Veo] Erro ao decodificar operationId:', error.message);
        return encodedId;
    }
};

// POST /api/video/generate - Gerar v√≠deo usando Veo
app.post('/api/video/generate', authenticateToken, async (req, res) => {
    const {
        prompt,
        model = 'sora_video2-15s',
        aspectRatio = '16:9',
        resolution = '720p',
        mode = 'text-to-video',
        startFrame,
        endFrame,
        referenceImages = [],
        styleImage,
        inputVideo,
        isLooping = false
    } = req.body;

    const userId = req.user.id;

    console.log('[Veo] Dados recebidos do frontend:', {
        prompt: prompt ? `"${prompt.substring(0, 50)}..."` : 'VAZIO',
        model,
        mode,
        aspectRatio,
        resolution,
        hasStartFrame: !!startFrame,
        hasEndFrame: !!endFrame,
        hasReferenceImages: referenceImages?.length > 0,
        hasInputVideo: !!inputVideo
    });

    try {
        // Verificar prefer√™ncia do usu√°rio (usar cr√©ditos ou API pr√≥pria)
        const userPrefs = await db.get('SELECT use_credits_instead_of_own_api FROM user_preferences WHERE user_id = ?', [userId]);
        const useCredits = userPrefs && userPrefs.use_credits_instead_of_own_api === 1;

        let useLaozhang = false;
        let useAdminApi = false;
        let adminApi = null;
        let apiKey = null;
        let usingPanelVideoKey = false;
        let apiKeySource = null;
        let userGeminiKeyRow = null;

        let laozhangApiKey = null;
        
        // Se usu√°rio prefere usar cr√©ditos, usar Laozhang.ai (obrigat√≥rio)
        if (useCredits) {
            laozhangApiKey = await getLaozhangApiKey();
            if (laozhangApiKey) {
                // Normalizar a chave
                if (typeof laozhangApiKey === 'object' && laozhangApiKey.api_key) {
                    laozhangApiKey = laozhangApiKey.api_key;
                } else if (typeof laozhangApiKey === 'string') {
                    laozhangApiKey = laozhangApiKey.trim();
                } else {
                    laozhangApiKey = String(laozhangApiKey).trim();
                }
                
                if (laozhangApiKey && laozhangApiKey.length > 10) {
                    useLaozhang = true;
                    apiKeySource = 'laozhang';
                    console.log('[Veo] ‚úÖ Usando Laozhang.ai com cr√©ditos (prefer√™ncia do usu√°rio)');
                } else {
                    console.warn('[Veo] ‚ö†Ô∏è Chave Laozhang inv√°lida ou muito curta');
                    return res.status(400).json({
                        message: 'Chave do provedor externo inv√°lida. Configure corretamente no painel admin.',
                        details: 'A gera√ß√£o via cr√©ditos depende da API configurada no painel admin. Configure a chave corretamente.'
                    });
                }
            } else {
                console.warn('[Veo] ‚ö†Ô∏è Prefer√™ncia por cr√©ditos, mas Laozhang.ai n√£o est√° configurada');
                return res.status(400).json({
                    message: 'Para usar cr√©ditos, configure a chave do provedor externo no painel admin.',
                    details: 'A gera√ß√£o via cr√©ditos depende da API configurada no painel admin. Configure a chave ou desmarque a op√ß√£o de cr√©ditos.'
                });
            }
        }
        
        // S√≥ buscar outras APIs se n√£o usar laozhang
        if (!useLaozhang) {
            const panelVideoApiKey = await getAdminVideoApiKey();
            if (panelVideoApiKey) {
                apiKey = panelVideoApiKey;
                usingPanelVideoKey = true;
                apiKeySource = 'panel_video';
                console.log('[Veo] Usando chave de v√≠deo configurada no painel admin');
            }
        }

        // Se n√£o usar Laozhang, buscar chave do usu√°rio ou admin
        if (!useLaozhang && !usingPanelVideoKey) {
            // Buscar chave do usu√°rio
            const geminiKeyData = await db.get('SELECT id, api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            let userApiKey = null;
            if (geminiKeyData && geminiKeyData.api_key) {
                try {
                    userApiKey = decrypt(geminiKeyData.api_key);
                } catch (decryptError) {
                    console.warn('[Veo] Erro ao descriptografar chave do usu√°rio:', decryptError.message);
                    // Se falhar, tentar usar diretamente (pode n√£o estar criptografada)
                    userApiKey = geminiKeyData.api_key;
                }
            }
            if (userApiKey) {
                userGeminiKeyRow = geminiKeyData;
            }
            // Buscar API do admin (qualquer tipo, mas preferir Gemini)
            adminApi = await getDefaultAdminApi();
            let adminApiKey = null;
            
            // Primeiro tentar buscar API Gemini do admin
            if (adminApi && adminApi.provider === 'gemini' && adminApi.api_key) {
                // Tentar descriptografar a chave do admin se necess√°rio
                if (adminApi.api_key.includes(':')) {
                    try {
                        adminApiKey = decrypt(adminApi.api_key);
                    } catch (decryptError) {
                        console.warn('[Veo] Erro ao descriptografar chave do admin, tentando usar diretamente:', decryptError.message);
                        adminApiKey = adminApi.api_key;
                    }
                } else {
                    adminApiKey = adminApi.api_key;
                }
            }
            
            // Se n√£o encontrou Gemini, buscar qualquer API do admin ativa
            if (!adminApiKey && adminApi && adminApi.api_key) {
                console.warn('[Veo] API do admin n√£o √© Gemini, mas tentando usar mesmo assim');
                if (adminApi.api_key.includes(':')) {
                    try {
                        adminApiKey = decrypt(adminApi.api_key);
                    } catch (decryptError) {
                        adminApiKey = adminApi.api_key;
                    }
                } else {
                    adminApiKey = adminApi.api_key;
                }
            }

            // Decidir qual chave usar
            if (userApiKey) {
                apiKey = userApiKey;
                apiKeySource = 'user_gemini';
                console.log('[Veo] Usando API pr√≥pria do usu√°rio');
            } else if (adminApiKey) {
                // Fallback: usar API do admin se pr√≥pria n√£o dispon√≠vel
                apiKey = adminApiKey;
                useAdminApi = true;
                apiKeySource = 'admin_provider';
                console.log('[Veo] Usando API do admin (API pr√≥pria n√£o dispon√≠vel)');
            }
        }

        // Validar API key antes de usar
        if (!useLaozhang && (!apiKey || apiKey.trim() === '')) {
            console.error('[Veo] ‚ùå API Key n√£o encontrada ou vazia');
            console.error('[Veo] - useCredits:', useCredits);
            console.error('[Veo] - useLaozhang:', useLaozhang);
            
            // Se preferir cr√©ditos mas n√£o tem API, sugerir configurar Laozhang.ai ou API Gemini no admin
            if (useCredits) {
                return res.status(400).json({ 
                    message: 'Para usar cr√©ditos na gera√ß√£o de v√≠deo, configure uma API no painel admin.',
                    details: 'Veo requer uma API configurada no painel admin. Configure no painel admin.'
                });
            }
            
            return res.status(400).json({ 
                message: 'Chave de API do Gemini n√£o configurada ou inv√°lida. Veo requer uma chave do Gemini com billing habilitado. Configure no painel admin (tipo Gemini) ou nas suas configura√ß√µes.' 
            });
        }
        
        // Se usar Laozhang, usar a API da Laozhang.ai com modelo Veo
        if (useLaozhang) {
            const laozhangKey = laozhangApiKey || await getLaozhangApiKey();
            if (!laozhangKey) {
                return res.status(400).json({ 
                    message: 'Provedor externo n√£o configurado no painel admin. Configure a chave de API primeiro.' 
                });
            }
            
            // Mapear modelo do frontend para modelo Laozhang.ai
            // Documenta√ß√£o: https://docs1.laozhang.ai/api-capabilities/veo/veo-31-overview
            // Para 16:9 (paisagem), usar modelos landscape: veo-3.1-landscape-fast ou veo-3.1-landscape
            // Para outros formatos, usar modelos padr√£o: veo-3.1-fast ou veo-3.1
            let laozhangModel = model;
            
            // Modo fixo: text-to-video (n√£o suporta image-to-video)
            const isImageToVideo = false; // Sempre false para text-to-video
            
            // Determinar se √© paisagem (16:9)
            const isLandscape = aspectRatio === '16:9';
            
            // Mapear modelos Sora 2 (apenas 15s - maior qualidade)
            if (model === 'sora_video2-15s' || model === 'sora_video2-landscape-15s' || model.includes('sora_video2')) {
                // Sora 2 de 15s usa modelos espec√≠ficos conforme aspect ratio
                // sora_video2-15s = Portrait (704√ó1280, 15s), sora_video2-landscape-15s = Landscape (1280√ó704, 15s)
                if (isLandscape) {
                    laozhangModel = 'sora_video2-landscape-15s';
                } else {
                    laozhangModel = 'sora_video2-15s';
                }
                // Sora 2 suporta image-to-video nativamente, n√£o precisa de modelo diferente
                console.log(`[Sora 2 Laozhang] Modelo selecionado: ${laozhangModel} (${isLandscape ? 'Landscape' : 'Portrait'}, 15s)`);
            } else if (model === 'veo-3.1-fast' || model.includes('veo-3.1-fast')) {
                if (isLandscape) {
                    // Para paisagem 16:9, usar modelos landscape
                    laozhangModel = isImageToVideo ? 'veo-3.1-landscape-fast-fl' : 'veo-3.1-landscape-fast';
                } else {
                    // Para outros formatos, usar modelos padr√£o
                    laozhangModel = isImageToVideo ? 'veo-3.1-fast-fl' : 'veo-3.1-fast';
                }
            } else if (model === 'veo-3.1' || model.includes('veo-3.1')) {
                if (isLandscape) {
                    // Para paisagem 16:9, usar modelos landscape
                    laozhangModel = isImageToVideo ? 'veo-3.1-landscape-fl' : 'veo-3.1-landscape';
                } else {
                    // Para outros formatos, usar modelos padr√£o
                    laozhangModel = isImageToVideo ? 'veo-3.1-fl' : 'veo-3.1';
                }
            } else {
                // Se j√° for um modelo espec√≠fico (Sora 2), usar diretamente
                laozhangModel = model;
            }
            
            const isSora2 = laozhangModel.includes('sora_video2');
            const modelType = isSora2 ? 'Sora 2' : 'Veo';
            console.log(`[${modelType} Laozhang] Modo detectado: ${mode}, Image-to-video: ${isImageToVideo}, Aspect Ratio: ${aspectRatio}, Landscape: ${isLandscape}, Modelo selecionado: ${laozhangModel}`);
            
            console.log(`[${modelType} Laozhang] Usando Laozhang.ai com modelo:`, laozhangModel);
            console.log('[Veo Laozhang] Prompt:', prompt ? `"${prompt.substring(0, 100)}..."` : 'VAZIO');
            
            // Construir payload no formato Chat Completions da Laozhang.ai
            // Documenta√ß√£o: https://docs1.laozhang.ai/api-capabilities/veo/veo-31-overview
            // Formato: messages com role "user" e content como array de objetos {type, text/image_url}
            
            const laozhangMessages = [];
            
            // Adicionar texto do prompt (modo text-to-video)
            if (prompt && prompt.trim()) {
                laozhangMessages.push({
                    type: 'text',
                    text: prompt.trim()
                });
            }
            
            // Modo text-to-video: n√£o adiciona frames, refer√™ncias ou v√≠deos de entrada
            // (c√≥digo removido - apenas text-to-video suportado)
            
            // Construir payload final no formato Chat Completions
            const laozhangPayload = {
                model: laozhangModel,
                messages: [
                    {
                        role: 'user',
                        content: laozhangMessages
                    }
                ],
                stream: true, // Recomendado pela documenta√ß√£o para obter progresso
                n: 1 // N√∫mero de v√≠deos a gerar (1-4)
            };
            
            // Adicionar par√¢metros adicionais se necess√°rio
            // Nota: resolu√ß√£o e aspect ratio s√£o controlados pelo modelo escolhido
            // veo-3.1-landscape* para 16:9, outros para formato padr√£o
            
            try {
                // Laozhang.ai usa endpoint Chat Completions padr√£o
                const endpoint = LAOZHANG_CHAT_ENDPOINT;
                
                console.log(`[Veo Laozhang] Usando endpoint: ${endpoint}`);
                console.log(`[Veo Laozhang] Modelo: ${laozhangModel}`);
                console.log(`[Veo Laozhang] Modo: ${mode}`);
                console.log(`[Veo Laozhang] Payload (resumido):`, JSON.stringify({
                    model: laozhangPayload.model,
                    messages: laozhangPayload.messages.map(m => ({
                        role: m.role,
                        content: m.content.map(c => c.type === 'text' ? { type: c.type, text: c.text.substring(0, 50) + '...' } : { type: c.type })
                    })),
                    stream: laozhangPayload.stream,
                    n: laozhangPayload.n
                }, null, 2));
                
                // Debitar cr√©ditos antes da chamada
                const laozhangProviderId = await getLaozhangApiProviderId();
                if (laozhangProviderId && userId) {
                    // Estimar cr√©ditos baseado na resolu√ß√£o e modelo
                    // Sora 2 = $0.15, veo-3.1-fast* = $0.15, veo-3.1 (padr√£o) = $0.25
                    const isSora2 = laozhangModel.includes('sora_video2');
                    const isFastModel = laozhangModel.includes('fast');
                    const estimatedCredits = (isSora2 || isFastModel) ? 15 : 25; // Aproximado em cr√©ditos
                    await checkAndDebitCredits(
                        userId,
                        laozhangProviderId,
                        estimatedCredits,
                        'api_video_generation',
                        JSON.stringify({ 
                            endpoint: '/api/video/generate', 
                            model: laozhangModel, 
                            mode, 
                            resolution, 
                            aspectRatio 
                        })
                    );
                }
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${laozhangKey}`
                    },
                    body: JSON.stringify(laozhangPayload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`[Veo Laozhang] ‚ùå Erro HTTP ${response.status}:`, errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                // Laozhang.ai retorna stream quando stream=true
                // Processar resposta stream ou JSON
                let laozhangResponse;
                const contentType = response.headers.get('content-type');
                
                // Verificar se o frontend quer SSE para progresso em tempo real
                const acceptHeader = req.headers.accept || '';
                const wantsSSE = acceptHeader.includes('text/event-stream');
                
                if (contentType && contentType.includes('text/event-stream')) {
                    // Resposta √© stream - processar eventos SSE
                    console.log('[Veo Laozhang] Resposta √© stream, processando eventos SSE...');
                    
                    // Se frontend quer SSE, configurar resposta como SSE
                    if (wantsSSE) {
                        res.setHeader('Content-Type', 'text/event-stream');
                        res.setHeader('Cache-Control', 'no-cache');
                        res.setHeader('Connection', 'keep-alive');
                    }
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    let operationId = null;
                    let fullContent = ''; // Acumular todo o conte√∫do
                    let isFinished = false;
                    let lastProgress = 0; // √öltima porcentagem enviada
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';
                        
                        for (const line of lines) {
                            if (line.trim() === '' || line === '[DONE]') continue;
                            
                            if (line.startsWith('data: ')) {
                                try {
                                    const dataStr = line.substring(6);
                                    if (dataStr === '[DONE]') {
                                        isFinished = true;
                                        break;
                                    }
                                    
                                    const data = JSON.parse(dataStr);
                                    
                                    // Procurar por operationId
                                    if (data.id) {
                                        operationId = data.id;
                                    }
                                    
                                    // Acumular conte√∫do dos chunks
                                    if (data.choices && data.choices.length > 0) {
                                        const choice = data.choices[0];
                                        if (choice.delta) {
                                            // Acumular conte√∫do se existir
                                            if (choice.delta.content) {
                                                fullContent += choice.delta.content;
                                                console.log('[Veo Laozhang] Conte√∫do acumulado:', fullContent.length, 'chars. √öltimo chunk:', choice.delta.content.substring(0, 50));
                                                
                                                // Extrair porcentagem de progresso do conte√∫do
                                                // Padr√µes: "ËøõÂ∫¶Ôºö9.0%", "Progress: 36.0%", "üèÉ ËøõÂ∫¶Ôºö44.9%"
                                                const progressMatch = choice.delta.content.match(/(?:ËøõÂ∫¶|Progress)[Ôºö:]\s*(\d+\.?\d*)%/i) || 
                                                                     choice.delta.content.match(/(\d+\.?\d*)%/);
                                                if (progressMatch && progressMatch[1]) {
                                                    const progressPercent = parseFloat(progressMatch[1]);
                                                    if (!isNaN(progressPercent) && progressPercent !== lastProgress) {
                                                        lastProgress = progressPercent;
                                                        console.log(`[Veo Laozhang] üìä Progresso detectado: ${progressPercent}%`);
                                                        
                                                        // Atualizar progresso na opera√ß√£o se j√° existir
                                                        if (operationId && videoOperations.has(operationId)) {
                                                            const op = videoOperations.get(operationId);
                                                            op.progress = progressPercent;
                                                            op.progressMessage = `Gerando v√≠deo... ${progressPercent.toFixed(1)}%`;
                                                            videoOperations.set(operationId, op);
                                                        }
                                                    }
                                                }
                                            }
                                            
                                            // Verificar se h√° v√≠deo diretamente no delta
                                            if (choice.delta.video || choice.delta.uri || choice.delta.url) {
                                                const videoUri = choice.delta.video?.uri || choice.delta.uri || choice.delta.url;
                                                console.log('[Veo Laozhang] ‚úÖ V√≠deo URI encontrado no delta:', videoUri);
                                                return res.json({
                                                    video: { uri: videoUri },
                                                    status: 'completed',
                                                    message: 'V√≠deo gerado com sucesso.'
                                                });
                                            }
                                            
                                            // Verificar outros campos que podem conter o v√≠deo
                                            if (choice.delta.role === 'assistant' && choice.delta.function_call) {
                                                console.log('[Veo Laozhang] Function call encontrado no delta');
                                            }
                                        }
                                        
                                        // Verificar se terminou
                                        if (choice.finish_reason === 'stop') {
                                            isFinished = true;
                                            console.log('[Veo Laozhang] ‚úÖ Stream finalizado. Conte√∫do total acumulado:', fullContent.length, 'caracteres');
                                            if (fullContent.length > 0) {
                                                console.log('[Veo Laozhang] Primeiros 500 chars do conte√∫do:', fullContent.substring(0, 500));
                                            }
                                        }
                                    }
                                    
                                    // Se v√≠deo estiver pronto diretamente no evento
                                    if (data.video || data.uri || data.url) {
                                        const videoUri = data.video?.uri || data.uri || data.url;
                                        return res.json({
                                            video: { uri: videoUri },
                                            status: 'completed',
                                            message: 'V√≠deo gerado com sucesso.'
                                        });
                                    }
                                } catch (e) {
                                    // Ignorar linhas que n√£o s√£o JSON
                                    console.warn('[Veo Laozhang] Erro ao parsear evento SSE:', e.message);
                                }
                            }
                        }
                        
                        if (isFinished) break;
                    }
                    
                    // Processar conte√∫do completo quando stream terminar
                    if (fullContent && fullContent.trim()) {
                        console.log('[Veo Laozhang] Conte√∫do completo recebido (', fullContent.length, 'caracteres):', fullContent.substring(0, 500));
                        
                        // Limpar o conte√∫do (pode ter markdown code blocks)
                        let cleanContent = fullContent.trim();
                        cleanContent = cleanContent.replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/```\s*$/i, '');
                        
                        // Tentar parsear como JSON
                        let contentData = null;
                        try {
                            contentData = JSON.parse(cleanContent);
                            console.log('[Veo Laozhang] ‚úÖ Conte√∫do parseado como JSON');
                        } catch (parseError) {
                            // Se n√£o for JSON v√°lido, tentar extrair JSON do texto
                            console.log('[Veo Laozhang] Conte√∫do n√£o √© JSON puro, tentando extrair JSON...');
                            const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
                            if (jsonMatch) {
                                try {
                                    contentData = JSON.parse(jsonMatch[0]);
                                    console.log('[Veo Laozhang] ‚úÖ JSON extra√≠do do texto');
                                } catch (e) {
                                    console.warn('[Veo Laozhang] N√£o foi poss√≠vel parsear JSON extra√≠do');
                                }
                            }
                        }
                        
                        // Se conseguiu parsear como JSON
                        if (contentData) {
                            // Procurar v√≠deo URI em diferentes formatos
                            const videoUri = contentData.video?.uri || 
                                          contentData.video?.url ||
                                          contentData.uri || 
                                          contentData.url ||
                                          contentData.videoUri ||
                                          contentData.video_url;
                            
                            if (videoUri) {
                                console.log('[Veo Laozhang] ‚úÖ V√≠deo URI encontrado no JSON:', videoUri);
                                return res.json({
                                    video: { uri: videoUri },
                                    status: 'completed',
                                    message: 'V√≠deo gerado com sucesso.'
                                });
                            }
                            
                            // Se cont√©m operationId para polling
                            if (contentData.operationId || contentData.id || contentData.operation) {
                                operationId = contentData.operationId || contentData.id || contentData.operation;
                            }
                        }
                        
                        // Se n√£o encontrou no JSON, tentar extrair URI do texto (regex)
                        console.log('[Veo Laozhang] Tentando extrair URI do texto com regex...');
                        // Padr√µes mais espec√≠ficos primeiro, depois gen√©ricos
                        // Sora 2 retorna links em formato markdown: [click here](https://sora.gptkey.asia/assets/sora/xxx.mp4)
                        const uriPatterns = [
                            /\[[^\]]+\]\(([^\)]+\.mp4[^\)]*)\)/g,  // Markdown links [text](url.mp4) - Sora 2
                            /https?:\/\/[^\s"',<>\)]+\.mp4[^\)]*/g,  // URLs .mp4 (prioridade)
                            /https?:\/\/[^\s"',<>\)]+/g,  // URLs completas (sem par√™nteses no final)
                            /https?:\/\/[^\s"',<>]+/g,  // URLs completas (fallback)
                            /uri["\s:]+["']?([^"'\s]+)["']?/i,  // uri: "url"
                            /url["\s:]+["']?([^"'\s]+)["']?/i   // url: "url"
                        ];
                        
                        for (const pattern of uriPatterns) {
                            const matches = cleanContent.match(pattern);
                            if (matches && matches.length > 0) {
                                console.log('[Veo Laozhang] Matches encontrados:', matches.length, matches.slice(0, 3));
                                
                                // Pegar a primeira URL que parece ser de v√≠deo
                                let videoUri = matches.find(url => 
                                    url.includes('googleapis.com') || 
                                    url.includes('storage.googleapis.com') ||
                                    url.includes('aliyuncs.com') ||  // Laozhang.ai usa Aliyun CDN
                                    url.includes('sora.gptkey.asia') ||  // Sora 2 CDN
                                    url.includes('mycdn') ||
                                    url.includes('video') ||
                                    url.match(/https?:\/\/[^\s"']+\.mp4/i)
                                ) || matches[0];
                                
                                // Se o match foi de markdown, extrair apenas a URL
                                if (videoUri && videoUri.includes('](')) {
                                    const markdownMatch = videoUri.match(/\]\(([^\)]+)\)/);
                                    if (markdownMatch && markdownMatch[1]) {
                                        videoUri = markdownMatch[1];
                                    }
                                }
                                
                                if (videoUri) {
                                    // Limpar a URL: remover par√™nteses, colchetes, aspas e outros caracteres inv√°lidos no final
                                    videoUri = videoUri.replace(/[\)\]\}"']+$/, '').trim();
                                    
                                    // Verificar se √© uma URL v√°lida
                                    try {
                                        new URL(videoUri);
                                        console.log('[Veo Laozhang] ‚úÖ V√≠deo URI extra√≠do e limpo:', videoUri);
                                        console.log('[Veo Laozhang] Retornando resposta com v√≠deo URI...');
                                        
                                        // IMPORTANTE: Retornar resposta no formato que o frontend espera
                                        // Frontend espera: { status: 'completed', videoUri: '...' }
                                        const responseData = {
                                            status: 'completed',
                                            videoUri: videoUri,
                                            message: 'V√≠deo gerado com sucesso.'
                                        };
                                        console.log('[Veo Laozhang] Resposta sendo enviada:', JSON.stringify(responseData));
                                        
                                        // Armazenar tamb√©m na opera√ß√£o para polling
                                        if (operationId) {
                                            videoOperations.set(operationId, {
                                                userId,
                                                operation: { id: operationId },
                                                useAdminApi: false,
                                                adminApi: null,
                                                createdAt: new Date(),
                                                status: 'completed',
                                                videoUri: videoUri,
                                                useLaozhang: true,
                                                laozhangKey: laozhangKey
                                            });
                                        }
                                        
                                        return res.json(responseData);
                                    } catch (urlError) {
                                        console.warn('[Veo Laozhang] ‚ö†Ô∏è URL extra√≠da n√£o √© v√°lida:', videoUri, urlError.message);
                                    }
                                }
                            }
                        }
                        
                        console.warn('[Veo Laozhang] ‚ö†Ô∏è N√£o foi poss√≠vel extrair v√≠deo URI do conte√∫do');
                        console.log('[Veo Laozhang] Conte√∫do completo para debug:', cleanContent.substring(0, 1000));
                    }
                    
                    // Se chegou aqui e tem operationId, retornar para polling
                    if (operationId) {
                        // Tentar fazer uma chamada adicional para obter o v√≠deo se o conte√∫do n√£o tiver URI
                        // A Laozhang.ai pode retornar o v√≠deo em uma chamada separada
                        if (fullContent && !fullContent.match(/https?:\/\/[^\s"']+/)) {
                            console.log('[Veo Laozhang] Conte√∫do n√£o cont√©m URI, tentando obter v√≠deo via polling...');
                            
                            // Tentar fazer polling imediatamente (algumas APIs retornam o v√≠deo logo ap√≥s)
                            try {
                                // Aguardar um pouco antes de fazer polling
                                await new Promise(resolve => setTimeout(resolve, 2000));
                                
                                // Fazer uma chamada para verificar se o v√≠deo est√° pronto
                                // Nota: A Laozhang.ai pode ter um endpoint espec√≠fico para isso
                                // Por enquanto, armazenar e deixar o polling do frontend verificar
                            } catch (pollError) {
                                console.warn('[Veo Laozhang] Erro ao tentar polling imediato:', pollError.message);
                            }
                        }
                        
                        // Extrair √∫ltima porcentagem do conte√∫do completo
                        let finalProgress = 0;
                        const finalProgressMatch = fullContent.match(/(?:ËøõÂ∫¶|Progress)[Ôºö:]\s*(\d+\.?\d*)%/gi);
                        if (finalProgressMatch && finalProgressMatch.length > 0) {
                            const lastMatch = finalProgressMatch[finalProgressMatch.length - 1];
                            const percentMatch = lastMatch.match(/(\d+\.?\d*)%/);
                            if (percentMatch && percentMatch[1]) {
                                finalProgress = parseFloat(percentMatch[1]);
                            }
                        }
                        
                        // Armazenar opera√ß√£o com o conte√∫do completo para processamento posterior
                        videoOperations.set(operationId, {
                            userId,
                            operation: { 
                                id: operationId,
                                content: fullContent,
                                model: laozhangModel
                            },
                            useAdminApi: false,
                            adminApi: null,
                            createdAt: new Date(),
                            status: fullContent && fullContent.length > 0 ? 'processing' : 'processing',
                            useLaozhang: true,
                            laozhangKey: laozhangKey,
                            // Armazenar conte√∫do para processamento na rota de status
                            rawContent: fullContent,
                            // Armazenar progresso extra√≠do
                            progress: finalProgress,
                            progressMessage: finalProgress > 0 ? `Gerando v√≠deo... ${finalProgress.toFixed(1)}%` : 'Processando...'
                        });
                        
                        console.log(`[Veo Laozhang] Opera√ß√£o ${operationId} armazenada para polling. Conte√∫do (${fullContent.length} chars): ${fullContent.substring(0, 200)}...`);
                        
                        return res.json({
                            operationId: operationId,
                            status: 'processing',
                            message: 'Gera√ß√£o de v√≠deo iniciada. Use o operationId para verificar o status.'
                        });
                    }
                    
                    // Se n√£o tem operationId nem conte√∫do, retornar erro
                    throw new Error('N√£o foi poss√≠vel obter operationId ou v√≠deo da resposta. Conte√∫do recebido: ' + (fullContent ? fullContent.substring(0, 200) : 'vazio'));
                } else {
                    // Resposta √© JSON normal
                    laozhangResponse = await response.json();
                    console.log(`[Veo Laozhang] ‚úÖ Resposta JSON recebida:`, JSON.stringify(laozhangResponse, null, 2).substring(0, 500));
                }
                
                // Processar resposta JSON
                let responseData = laozhangResponse;
                
                // Se a resposta cont√©m choices (formato Chat Completions)
                if (responseData.choices && responseData.choices.length > 0) {
                    const choice = responseData.choices[0];
                    if (choice.message && choice.message.content) {
                        // Tentar parsear o content como JSON
                        try {
                            const contentData = JSON.parse(choice.message.content);
                            responseData = contentData;
                        } catch (e) {
                            // Se n√£o for JSON, usar o content como est√°
                            responseData = { content: choice.message.content };
                        }
                    }
                }
                
                // Se a resposta cont√©m operationId ou similar, retornar
                if (responseData.operationId || responseData.operation || responseData.id || responseData.name) {
                    const operationId = responseData.operationId || responseData.operation || responseData.id || responseData.name;
                    
                    // Armazenar opera√ß√£o
                    const laozhangOperation = {
                        userId,
                        operation: responseData,
                        useAdminApi: false,
                        adminApi: null,
                        createdAt: new Date(),
                        status: 'processing',
                        useLaozhang: true,
                        laozhangKey: laozhangKey
                    };
                    videoOperations.set(operationId, laozhangOperation);
                    await cacheVideoOperationMetadata(operationId, userId, {
                        apiKeySource: 'laozhang',
                        useLaozhang: true
                    });
                    
                    return res.json({
                        operationId: operationId,
                        status: 'processing',
                        message: 'Gera√ß√£o de v√≠deo iniciada. Use o operationId para verificar o status.'
                    });
                }
                
                // Se a resposta cont√©m v√≠deo diretamente
                if (responseData.video || responseData.uri || responseData.url) {
                    const videoUri = responseData.video?.uri || responseData.uri || responseData.url;
                    // Frontend espera: { status: 'completed', videoUri: '...' }
                    return res.json({
                        status: 'completed',
                        videoUri: videoUri,
                        message: 'V√≠deo gerado com sucesso.'
                    });
                }
                
                // Retornar resposta como est√°
                return res.json({
                    status: 'processing',
                    data: responseData,
                    message: 'Gera√ß√£o de v√≠deo iniciada.'
                });
                
            } catch (laozhangError) {
                console.error('[Veo Laozhang] Erro ao chamar Laozhang.ai:', laozhangError);
                return res.status(500).json({ 
                    message: 'Erro ao gerar v√≠deo: ' + (laozhangError.message || 'Erro desconhecido'),
                    details: laozhangError.details || laozhangError.error || 'Erro ao processar requisi√ß√£o'
                });
            }
        }

        // Validar formato da API key (deve come√ßar com AIza ou similar)
        if (!apiKey.startsWith('AIza') && apiKey.length < 20) {
            console.warn('[Veo] ‚ö†Ô∏è API Key pode estar em formato inv√°lido. Esperado formato Google API key.');
        }

        console.log('[Veo] ‚úÖ API Key configurada:', apiKey.substring(0, 10) + '...' + apiKey.substring(apiKey.length - 4));
        console.log('[Veo] - Tamanho da chave:', apiKey.length, 'caracteres');
        console.log('[Veo] - Usando API do admin:', useAdminApi);

        // Construir payload para a API Veo
        const config = {
            numberOfVideos: 1,
            resolution: resolution
        };

        if (mode !== 'extend-video') {
            config.aspectRatio = aspectRatio;
        }

        // Construir payload base
        const generateVideoPayload = {
            model: model,
            config: config
        };

        // Adicionar prompt se fornecido (obrigat√≥rio para text-to-video)
        // Para extend-video, o prompt deve enfatizar continuar o v√≠deo existente
        if (mode === 'extend-video') {
            // Instru√ß√µes muito espec√≠ficas para garantir que o v√≠deo seja estendido, n√£o recriado
            let extendPrompt = `VIDEO EXTENSION REQUEST:

You have been provided with a video. Your task is to EXTEND this video, creating a seamless continuation.

CRITICAL REQUIREMENTS:
1. This is NOT a new video - it is an EXTENSION of the existing video
2. The extended video must start EXACTLY where the provided video ends
3. Maintain IDENTICAL scene, characters, camera angle, lighting, colors, and visual style
4. Create a smooth, natural continuation - it should feel like ONE continuous video
5. The transition between the original and extension must be seamless
6. Do NOT change the scene, location, or context
7. Do NOT introduce new characters or elements that weren't in the original
8. The final output should be a SINGLE continuous video that combines the original 8 seconds with approximately 7 more seconds of extension, totaling around 15 seconds

${prompt && prompt.trim() ? `Additional continuation direction: ${prompt.trim()}` : 'Continue the video naturally, maintaining the exact same visual style and narrative flow.'}

Remember: The goal is to create ONE unified video, not two separate videos. The extension must connect seamlessly.`;
            
            generateVideoPayload.prompt = extendPrompt;
            console.log('[Veo] Prompt para extend-video:', extendPrompt.substring(0, 300));
        } else if (prompt && prompt.trim()) {
            generateVideoPayload.prompt = prompt.trim();
        }

        // Modo: Frames to Video
        if (mode === 'frames-to-video') {
            if (startFrame && startFrame.base64) {
                generateVideoPayload.image = {
                    imageBytes: startFrame.base64,
                    mimeType: startFrame.mimeType || 'image/jpeg'
                };
            }

            const finalEndFrame = isLooping ? startFrame : endFrame;
            if (finalEndFrame && finalEndFrame.base64) {
                generateVideoPayload.config.lastFrame = {
                    imageBytes: finalEndFrame.base64,
                    mimeType: finalEndFrame.mimeType || 'image/jpeg'
                };
            }
        }
        // Modo: References to Video
        else if (mode === 'references-to-video') {
            const referenceImagesPayload = [];

            for (const img of referenceImages) {
                if (img.base64) {
                    referenceImagesPayload.push({
                        image: {
                            imageBytes: img.base64,
                            mimeType: img.mimeType || 'image/jpeg'
                        },
                        referenceType: 'ASSET'
                    });
                }
            }

            if (styleImage && styleImage.base64) {
                referenceImagesPayload.push({
                    image: {
                        imageBytes: styleImage.base64,
                        mimeType: styleImage.mimeType || 'image/jpeg'
                    },
                    referenceType: 'STYLE'
                });
            }

            if (referenceImagesPayload.length > 0) {
                generateVideoPayload.config.referenceImages = referenceImagesPayload;
            }
        }
        // Modo: Extend Video
        else if (mode === 'extend-video') {
            // Para estender, precisamos do URI do v√≠deo gerado anteriormente
            // ESTRAT√âGIA: Extrair o √∫ltimo frame e usar como imagem inicial
            if (!inputVideo) {
                return res.status(400).json({ message: 'V√≠deo de entrada √© obrigat√≥rio para estender.' });
            }
            
            try {
                let videoUri = null;
                if (inputVideo.uri) {
                    videoUri = inputVideo.uri;
                } else if (inputVideo.base64) {
                    const mimeType = inputVideo.mimeType || 'video/mp4';
                    videoUri = `data:${mimeType};base64,${inputVideo.base64}`;
                }
                
                if (videoUri && videoUri.startsWith('http')) {
                    // Baixar v√≠deo e extrair √∫ltimo frame usando FFmpeg
                    const tempVideoPath = path.join(__dirname, 'temp', `extend_${Date.now()}.mp4`);
                    const tempFramePath = path.join(__dirname, 'temp', `last_frame_${Date.now()}.jpg`);
                    
                    // Criar diret√≥rio temp se n√£o existir
                    await fse.ensureDir(path.dirname(tempVideoPath));
                    
                    // Baixar v√≠deo
                    console.log('[Veo] Baixando v√≠deo para extrair √∫ltimo frame...');
                    const videoResponse = await axios({
                        url: videoUri,
                        method: 'GET',
                        responseType: 'stream',
                        timeout: 30000,
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (compatible; VideoGeneratorBot/1.0; +https://lacasa.ai)',
                            'Referer': videoUri
                        }
                    });
                    
                    const videoStream = fs.createWriteStream(tempVideoPath);
                    await new Promise((resolve, reject) => {
                        videoResponse.data.pipe(videoStream);
                        videoStream.on('finish', resolve);
                        videoStream.on('error', reject);
                    });
                    
                    // Extrair √∫ltimo frame usando FFmpeg
                    console.log('[Veo] Extraindo √∫ltimo frame com FFmpeg...');
                    await new Promise((resolve, reject) => {
                        ffmpeg(tempVideoPath)
                            .screenshots({
                                timestamps: ['99%'], // Pegar frame em 99% do v√≠deo
                                filename: path.basename(tempFramePath),
                                folder: path.dirname(tempFramePath),
                                size: '1280x720' // Manter resolu√ß√£o alta
                            })
                            .on('end', () => {
                                console.log('[Veo] ‚úÖ √öltimo frame extra√≠do com sucesso');
                                resolve();
                            })
                            .on('error', (err) => {
                                console.error('[Veo] ‚ùå Erro ao extrair frame:', err.message);
                                reject(err);
                            });
                    });
                    
                    // Ler frame como base64
                    const frameBuffer = await fs.readFile(tempFramePath);
                    const frameBase64 = frameBuffer.toString('base64');
                    
                    // Limpar arquivos tempor√°rios
                    try {
                        await fs.unlink(tempVideoPath);
                        await fs.unlink(tempFramePath);
                    } catch (cleanupErr) {
                        console.warn('[Veo] Aviso ao limpar arquivos tempor√°rios:', cleanupErr.message);
                    }
                    
                    // Usar frame como imagem inicial (modo frames-to-video)
                    generateVideoPayload.image = {
                        imageBytes: frameBase64,
                        mimeType: 'image/jpeg'
                    };
                    
                    // Atualizar prompt para enfatizar continua√ß√£o
                    if (generateVideoPayload.prompt) {
                        generateVideoPayload.prompt = `VIDEO EXTENSION: The image above is the LAST FRAME of an 8-second video. Generate a continuation that starts EXACTLY from this frame, maintains the SAME scene, characters, camera angle, lighting, and visual style, and creates approximately 7 more seconds of video, resulting in a TOTAL of 15 seconds (8s original + 7s extension). The continuation must be SEAMLESS and feel like ONE continuous video. ${generateVideoPayload.prompt}`;
                    }
                    
                    console.log('[Veo] √öltimo frame extra√≠do e configurado como imagem inicial para continua√ß√£o');
                } else if (inputVideo.uri) {
                    // Fallback: usar URI diretamente se n√£o for HTTP
                    generateVideoPayload.video = {
                        uri: inputVideo.uri
                    };
                } else {
                    return res.status(400).json({ message: 'Para estender um v√≠deo, voc√™ precisa usar um v√≠deo gerado anteriormente pelo Veo (que possui URI).' });
                }
            } catch (extractError) {
                console.error('[Veo] Erro ao extrair √∫ltimo frame:', extractError.message);
                // Fallback: tentar usar URI diretamente
                if (inputVideo.uri) {
                    generateVideoPayload.video = {
                        uri: inputVideo.uri
                    };
                } else {
                    return res.status(400).json({ message: `Erro ao processar v√≠deo para extens√£o: ${extractError.message}` });
                }
            }
        }

        console.log('[Veo] Prompt recebido:', prompt ? `"${prompt.substring(0, 100)}..."` : 'VAZIO');
        console.log('[Veo] Payload completo:', JSON.stringify(generateVideoPayload, null, 2));

        // Usar SDK do Google GenAI para Veo
        // Garantir que a API key est√° limpa (sem espa√ßos)
        const cleanApiKey = apiKey.trim();
        
        if (!cleanApiKey || cleanApiKey.length === 0) {
            console.error('[Veo] ‚ùå API Key est√° vazia ap√≥s limpeza!');
            return res.status(400).json({ 
                message: 'Chave de API inv√°lida. Verifique se a chave do Gemini est√° correta e tem billing habilitado para usar o Veo.' 
            });
        }
        
        console.log('[Veo] Inicializando SDK do Google GenAI...');
        console.log('[Veo] - Modelo:', model);
        console.log('[Veo] - API Key (primeiros 10 chars):', cleanApiKey.substring(0, 10));
        
        const ai = new GoogleGenAI({ apiKey: cleanApiKey });
        
        // Garantir que o prompt est√° presente se necess√°rio
        if (mode === 'text-to-video' && (!prompt || !prompt.trim())) {
            return res.status(400).json({ message: 'Prompt √© obrigat√≥rio para gera√ß√£o de v√≠deo a partir de texto.' });
        }

        // O SDK espera o formato exato: model, config, e opcionalmente prompt, image, video, etc.
        // Construir payload exatamente como no exemplo do VETA
        const sdkPayload = {
            model: model,
            config: generateVideoPayload.config
        };

        // Adicionar prompt se existir (obrigat√≥rio para text-to-video)
        if (generateVideoPayload.prompt) {
            sdkPayload.prompt = generateVideoPayload.prompt;
            console.log('[Veo] Prompt adicionado ao SDK payload:', sdkPayload.prompt.substring(0, 100));
        } else {
            console.warn('[Veo] ATEN√á√ÉO: Prompt n√£o encontrado no generateVideoPayload!');
            // Se for text-to-video e n√£o tiver prompt, adicionar do par√¢metro original
            if (mode === 'text-to-video' && prompt && prompt.trim()) {
                sdkPayload.prompt = prompt.trim();
                console.log('[Veo] Prompt adicionado do par√¢metro original:', sdkPayload.prompt.substring(0, 100));
            }
        }

        // Adicionar image se existir (frames-to-video)
        if (generateVideoPayload.image) {
            sdkPayload.image = generateVideoPayload.image;
        }

        // Adicionar video se existir (extend-video)
        if (generateVideoPayload.video) {
            sdkPayload.video = generateVideoPayload.video;
        }

        // referenceImages j√° est√° em config.referenceImages, n√£o precisa adicionar separadamente

        console.log('[Veo] Payload completo para SDK:', JSON.stringify(sdkPayload, null, 2).substring(0, 1000));
        console.log('[Veo] Chamando SDK generateVideos com modelo:', model);
        
        // Validar que o modelo est√° correto
        const validModels = ['veo-3.1-fast-generate-preview', 'veo-3.1-generate-preview'];
        if (!validModels.includes(model)) {
            console.warn(`[Veo] Modelo "${model}" n√£o est√° na lista de modelos v√°lidos. Usando modelo padr√£o.`);
            sdkPayload.model = 'veo-3.1-fast-generate-preview';
        }
        
        // Chamar SDK - passar o payload diretamente como no exemplo do VETA
        let operation;
        try {
            operation = await ai.models.generateVideos(sdkPayload);
        } catch (sdkError) {
            console.error('[Veo] Erro ao chamar SDK generateVideos:', sdkError);
            
            // Tratar erros espec√≠ficos da API
            if (sdkError.status === 400 && sdkError.message?.includes('API key')) {
                return res.status(400).json({ 
                    message: 'Chave de API inv√°lida. Verifique se a chave do Gemini est√° correta e tem billing habilitado para usar o Veo.',
                    details: 'A chave de API precisa ter acesso ao Veo e billing habilitado no Google Cloud.'
                });
            }
            
            // Re-enviar erro gen√©rico
            return res.status(sdkError.status || 500).json({ 
                message: sdkError.message || 'Erro ao gerar v√≠deo com Veo.',
                details: sdkError.details || sdkError.error || 'Erro desconhecido'
            });
        }
        
        console.log('[Veo] Opera√ß√£o criada:', operation.name || 'Sem nome');

        // Usar o nome completo da opera√ß√£o como ID (pode conter barras)
        const operationId = operation.name || `operation-${Date.now()}-${crypto.randomBytes(4).toString('hex')}`;
        
        console.log('[Veo] OperationId salvo:', operationId);

        // Armazenar opera√ß√£o usando o operationId completo
        const operationData = {
            userId,
            operation,
            prompt: prompt,
            model: model,
            aspectRatio: aspectRatio,
            resolution: resolution,
            useAdminApi,
            adminApi,
            createdAt: new Date(),
            status: 'processing'
        };
        videoOperations.set(operationId, operationData);
        await cacheVideoOperationMetadata(operationId, userId, {
            apiKeySource: apiKeySource || (useLaozhang ? 'laozhang' : 'unknown'),
            userKeyId: userGeminiKeyRow?.id || null,
            adminApiId: adminApi?.id || null,
            useLaozhang
        });
        
        console.log('[Veo] Opera√ß√£o armazenada. Total de opera√ß√µes:', videoOperations.size);

        // Se usou API do admin, debitar cr√©ditos (estimado)
        if (useAdminApi && adminApi) {
            try {
                // Estimar cr√©ditos baseado na resolu√ß√£o e modo
                const estimatedCredits = resolution === '1080p' ? 50 : 25;
                const creditResult = await checkAndDebitCredits(
                    userId,
                    adminApi.id,
                    estimatedCredits,
                    'api_video_generation',
                    JSON.stringify({ model, mode, resolution, aspectRatio })
                );
                console.log(`üí≥ [CR√âDITOS] ${creditResult.creditsUsed.toFixed(2)} cr√©ditos debitados. Saldo restante: ${creditResult.newBalance.toFixed(2)}`);
            } catch (creditError) {
                console.error('‚ùå [CR√âDITOS] Erro ao debitar cr√©ditos:', creditError);
            }
        }

        // Iniciar polling em background (usar cleanApiKey)
        pollVideoOperation(operationId, cleanApiKey);

        res.json({
            operationId: operationId,
            status: 'processing',
            message: 'Gera√ß√£o de v√≠deo iniciada. Use o operationId para verificar o status.'
        });

    } catch (error) {
        console.error('[Veo] Erro ao gerar v√≠deo:', error);
        if (error.response) {
            console.error('[Veo] Status:', error.response.status);
            console.error('[Veo] Data:', error.response.data);
        }
        
        // Tratar erros espec√≠ficos
        let errorMessage = 'Erro ao gerar v√≠deo';
        let statusCode = 500;
        
        if (error.message?.includes('API key') || error.message?.includes('INVALID_ARGUMENT') || 
            error.response?.data?.error?.message?.includes('API key') ||
            error.response?.data?.error?.status === 'INVALID_ARGUMENT') {
            errorMessage = 'Chave de API inv√°lida ou n√£o configurada. Verifique se a chave do Gemini est√° correta e tem billing habilitado para usar o Veo.';
            statusCode = 400;
        } else if (error.message?.includes('PERMISSION_DENIED') || error.response?.data?.error?.status === 'PERMISSION_DENIED') {
            errorMessage = 'Permiss√£o negada. Verifique se a chave de API tem acesso ao Veo e se o billing est√° habilitado.';
            statusCode = 403;
        } else if (error.response?.data?.error?.message) {
            errorMessage = error.response.data.error.message;
            statusCode = error.response.status || 500;
        } else if (error.message) {
            errorMessage = error.message;
        }

        res.status(statusCode).json({ 
            message: errorMessage,
            error: error.message || 'Erro desconhecido',
            details: error.response?.data?.error || error.details || null
        });
    }
});

// Fun√ß√£o para fazer polling da opera√ß√£o
async function pollVideoOperation(operationId, apiKey) {
    const maxAttempts = 60; // 10 minutos m√°ximo (10s * 60)
    let attempts = 0;

    while (attempts < maxAttempts) {
        try {
            const operationData = videoOperations.get(operationId);
            if (!operationData) {
                console.log(`[Veo] Opera√ß√£o ${operationId} n√£o encontrada`);
                break;
            }

            const operation = operationData.operation;
            if (!operation.name) {
                console.log(`[Veo] Opera√ß√£o ${operationId} sem nome`);
                break;
            }

            // Usar SDK para verificar status
            const ai = new GoogleGenAI({ apiKey: apiKey });
            
            // Obter opera√ß√£o atualizada do SDK (precisa do nome da opera√ß√£o)
            const updatedOperation = await ai.operations.getVideosOperation({ name: operationId });
            
            console.log(`[Veo] Status da opera√ß√£o ${operationId}:`, updatedOperation.done ? 'Conclu√≠da' : 'Processando');

            if (updatedOperation.done) {
                // Opera√ß√£o conclu√≠da
                if (updatedOperation.response && updatedOperation.response.generatedVideos) {
                    const videos = updatedOperation.response.generatedVideos;
                    if (videos.length > 0 && videos[0].video && videos[0].video.uri) {
                        const videoUri = videos[0].video.uri;
                        
                        console.log(`[Veo] V√≠deo gerado. URI: ${videoUri}`);
                        
                        try {
                            // Baixar v√≠deo - o URI j√° cont√©m a URL completa
                            let videoUrl = videoUri;
                            if (!videoUrl.includes('key=')) {
                                videoUrl = `${videoUri}${videoUri.includes('?') ? '&' : '?'}key=${apiKey}`;
                            }
                            
                            console.log(`[Veo] Baixando v√≠deo de: ${videoUrl.substring(0, 100)}...`);
                            
                            const videoResponse = await axios.get(videoUrl, {
                                responseType: 'arraybuffer',
                                timeout: 120000
                            });

                            const videoBuffer = Buffer.from(videoResponse.data);
                            const videoBase64 = videoBuffer.toString('base64');

                            // Atualizar opera√ß√£o
                            videoOperations.set(operationId, {
                                ...operationData,
                                status: 'completed',
                                videoUri: videoUri,
                                videoBase64: videoBase64,
                                videoMimeType: 'video/mp4'
                            });

                            console.log(`[Veo] V√≠deo gerado com sucesso: ${operationId} (${videoBuffer.length} bytes)`);
                            await removeVideoOperationCache(operationId);
                            return;
                        } catch (downloadError) {
                            console.error(`[Veo] Erro ao baixar v√≠deo:`, downloadError.message);
                            // Mesmo com erro no download, retornar o URI para o frontend tentar baixar
                            videoOperations.set(operationId, {
                                ...operationData,
                                status: 'completed',
                                videoUri: videoUri,
                                videoBase64: null,
                                videoMimeType: 'video/mp4',
                                downloadError: downloadError.message
                            });
                            await removeVideoOperationCache(operationId);
                            return;
                        }
                    }
                }

                // Verificar se h√° erro na opera√ß√£o
                if (updatedOperation.error) {
                    videoOperations.set(operationId, {
                        ...operationData,
                        status: 'error',
                        error: updatedOperation.error.message || 'Erro na gera√ß√£o do v√≠deo'
                    });
                    await removeVideoOperationCache(operationId);
                } else {
                    videoOperations.set(operationId, {
                        ...operationData,
                        status: 'error',
                        error: 'Nenhum v√≠deo foi gerado na resposta'
                    });
                    await removeVideoOperationCache(operationId);
                }
                break;
            }

            // Atualizar opera√ß√£o no storage
            videoOperations.set(operationId, {
                ...operationData,
                operation: updatedOperation
            });

            // Ainda processando
            attempts++;
            await new Promise(resolve => setTimeout(resolve, 10000)); // Aguardar 10 segundos

        } catch (error) {
            console.error(`[Veo] Erro ao verificar status da opera√ß√£o ${operationId}:`, error.message);
            videoOperations.set(operationId, {
                ...videoOperations.get(operationId),
                status: 'error',
                error: error.message
            });
            await removeVideoOperationCache(operationId);
            break;
        }
    }

    if (attempts >= maxAttempts) {
        videoOperations.set(operationId, {
            ...videoOperations.get(operationId),
            status: 'timeout',
            error: 'Timeout aguardando conclus√£o da gera√ß√£o'
        });
        await removeVideoOperationCache(operationId);
    }
}

// GET /api/video/status/:operationId - Verificar status da gera√ß√£o
app.get('/api/video/status/:operationId', authenticateToken, async (req, res) => {
    // Decodificar o operationId (pode conter barras e caracteres especiais)
    let operationId = decodeURIComponent(req.params.operationId);
    const userId = req.user.id;

    console.log('[Veo] Verificando status para operationId:', operationId);
    console.log('[Veo] Opera√ß√µes dispon√≠veis:', Array.from(videoOperations.keys()));

    try {
        const operationData = videoOperations.get(operationId);
        
        if (!operationData) {
            console.warn('[Veo] Opera√ß√£o n√£o encontrada no Map. Tentando reidratar a partir do banco...');
            const cached = await db.get('SELECT * FROM video_operations_cache WHERE operation_id = ?', [operationId]);
            if (cached) {
                const apiKey = await resolveCachedVideoApiKey(cached);
                if (apiKey) {
                    const restoredOperation = {
                        userId: cached.user_id,
                        operation: { name: operationId },
                        status: 'processing',
                        useAdminApi: cached.api_key_source === 'admin_provider',
                        adminApi: cached.admin_api_id ? await db.get('SELECT * FROM api_providers WHERE id = ?', [cached.admin_api_id]) : null,
                        useLaozhang: cached.use_laozhang === 1
                    };
                    videoOperations.set(operationId, restoredOperation);
                    pollVideoOperation(operationId, apiKey);
                    return res.json({ status: 'processing', restored: true, progress: 0, progressMessage: 'Processando...' });
                }
            }
            
            console.error('[Veo] Opera√ß√£o n√£o encontrada nem no cache. OperationId procurado:', operationId);
            console.error('[Veo] Chaves dispon√≠veis:', Array.from(videoOperations.keys()));
            return res.status(404).json({ message: 'Opera√ß√£o n√£o encontrada' });
        }

        if (operationData.userId !== userId) {
            return res.status(403).json({ message: 'Acesso negado' });
        }

        // Extrair progresso atual se dispon√≠vel
        let currentProgress = operationData.progress || 0;
        let progressMessage = operationData.progressMessage || 'Processando...';
        
        // Se n√£o tem progresso armazenado mas tem conte√∫do, tentar extrair
        if (currentProgress === 0 && (operationData.operation?.content || operationData.rawContent)) {
            const content = operationData.operation?.content || operationData.rawContent || '';
            const progressMatch = content.match(/(?:ËøõÂ∫¶|Progress)[Ôºö:]\s*(\d+\.?\d*)%/gi);
            if (progressMatch && progressMatch.length > 0) {
                const lastMatch = progressMatch[progressMatch.length - 1];
                const percentMatch = lastMatch.match(/(\d+\.?\d*)%/);
                if (percentMatch && percentMatch[1]) {
                    currentProgress = parseFloat(percentMatch[1]);
                    progressMessage = `Gerando v√≠deo... ${currentProgress.toFixed(1)}%`;
                    // Atualizar opera√ß√£o com progresso extra√≠do
                    operationData.progress = currentProgress;
                    operationData.progressMessage = progressMessage;
                    videoOperations.set(operationId, operationData);
                }
            }
        }
        
        // Se for Laozhang.ai e tiver conte√∫do, processar para extrair v√≠deo URI
        if (operationData.useLaozhang && (operationData.operation?.content || operationData.rawContent) && !operationData.videoUri) {
            try {
                let content = operationData.operation?.content || operationData.rawContent || '';
                console.log('[Veo Laozhang] Processando conte√∫do para extrair v√≠deo URI (', content.length, 'chars)');
                
                if (!content || content.trim().length === 0) {
                    console.warn('[Veo Laozhang] ‚ö†Ô∏è Conte√∫do vazio, n√£o √© poss√≠vel extrair v√≠deo URI');
                } else {
                    console.log('[Veo Laozhang] Primeiros 500 chars do conte√∫do:', content.substring(0, 500));
                    
                    // Limpar o conte√∫do (pode ter markdown code blocks)
                    let cleanContent = content.trim();
                    cleanContent = cleanContent.replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/```\s*$/i, '');
                    
                    // Tentar parsear como JSON
                    let contentData = null;
                    try {
                        contentData = JSON.parse(cleanContent);
                        console.log('[Veo Laozhang] ‚úÖ Conte√∫do parseado como JSON');
                    } catch (parseError) {
                        // Se n√£o for JSON v√°lido, tentar extrair JSON do texto
                        console.log('[Veo Laozhang] Conte√∫do n√£o √© JSON puro, tentando extrair JSON...');
                        const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            try {
                                contentData = JSON.parse(jsonMatch[0]);
                                console.log('[Veo Laozhang] ‚úÖ JSON extra√≠do do texto');
                            } catch (e) {
                                console.warn('[Veo Laozhang] N√£o foi poss√≠vel parsear JSON extra√≠do');
                            }
                        }
                    }
                    
                    // Se conseguiu parsear como JSON
                    if (contentData) {
                        // Procurar v√≠deo URI em diferentes formatos
                        const videoUri = contentData.video?.uri || 
                                      contentData.video?.url ||
                                      contentData.uri || 
                                      contentData.url ||
                                      contentData.videoUri ||
                                      contentData.video_url ||
                                      contentData.result?.video?.uri ||
                                      contentData.result?.uri;
                        
                        if (videoUri) {
                            console.log('[Veo Laozhang] ‚úÖ V√≠deo URI encontrado no JSON:', videoUri);
                            // Atualizar opera√ß√£o com v√≠deo URI
                            videoOperations.set(operationId, {
                                ...operationData,
                                videoUri: videoUri,
                                status: 'completed'
                            });
                            
                            return res.json({
                                status: 'completed',
                                videoUri: videoUri,
                                videoBase64: null,
                                videoMimeType: 'video/mp4',
                                error: null,
                                downloadError: null
                            });
                        }
                    }
                    
                    // Se n√£o encontrou no JSON, tentar extrair URI do texto (regex)
                    console.log('[Veo Laozhang] Tentando extrair URI do texto com regex...');
                    const uriPatterns = [
                        /https?:\/\/[^\s"',<>]+/g,  // URLs completas
                        /uri["\s:]+["']?([^"'\s]+)["']?/i,  // uri: "url"
                        /url["\s:]+["']?([^"'\s]+)["']?/i   // url: "url"
                    ];
                    
                    for (const pattern of uriPatterns) {
                        const matches = cleanContent.match(pattern);
                        if (matches && matches.length > 0) {
                            // Pegar a primeira URL que parece ser de v√≠deo
                            let videoUri = matches.find(url => 
                                url.includes('googleapis.com') || 
                                url.includes('storage.googleapis.com') ||
                                url.includes('aliyuncs.com') ||  // Laozhang.ai usa Aliyun CDN
                                url.includes('mycdn') ||
                                url.includes('video') ||
                                url.match(/https?:\/\/[^\s"']+\.mp4/i)
                            ) || matches[0];
                            
                            if (videoUri) {
                                // Limpar a URL: remover par√™nteses, colchetes, aspas e outros caracteres inv√°lidos no final
                                videoUri = videoUri.replace(/[\)\]\}"']+$/, '').trim();
                                
                                // Verificar se √© uma URL v√°lida
                                try {
                                    new URL(videoUri);
                                    console.log('[Veo Laozhang] ‚úÖ V√≠deo URI extra√≠do e limpo:', videoUri);
                                    // Atualizar opera√ß√£o com v√≠deo URI
                                    videoOperations.set(operationId, {
                                        ...operationData,
                                        videoUri: videoUri,
                                        status: 'completed'
                                    });
                                    
                                    return res.json({
                                        status: 'completed',
                                        videoUri: videoUri,
                                        videoBase64: null,
                                        videoMimeType: 'video/mp4',
                                        error: null,
                                        downloadError: null
                                    });
                                } catch (urlError) {
                                    console.warn('[Veo Laozhang] ‚ö†Ô∏è URL extra√≠da n√£o √© v√°lida:', videoUri);
                                }
                            }
                        }
                    }
                    
                    console.warn('[Veo Laozhang] ‚ö†Ô∏è N√£o foi poss√≠vel extrair v√≠deo URI do conte√∫do');
                }
            } catch (error) {
                console.error('[Veo Laozhang] Erro ao processar conte√∫do:', error);
            }
        }
        
        // Se o v√≠deo foi conclu√≠do, salvar no banco de dados
        if (operationData.status === 'completed' && operationData.videoUri) {
            try {
                // A tabela j√° deve existir (criada na inicializa√ß√£o), mas garantimos que existe
                await db.exec(`
                    CREATE TABLE IF NOT EXISTS generated_videos (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        operation_id TEXT UNIQUE NOT NULL,
                        video_uri TEXT NOT NULL,
                        prompt TEXT,
                        model TEXT,
                        aspect_ratio TEXT,
                        resolution TEXT,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                    )
                `);
                
                // Verificar se j√° existe
                const existing = await db.get(
                    'SELECT id FROM generated_videos WHERE operation_id = ?',
                    [operationId]
                );
                
                if (!existing) {
                    // Salvar v√≠deo gerado
                    await db.run(`
                        INSERT INTO generated_videos (
                            user_id, operation_id, video_uri, prompt, model, aspect_ratio, resolution
                        ) VALUES (?, ?, ?, ?, ?, ?, ?)
                    `, [
                        userId,
                        operationId,
                        operationData.videoUri,
                        operationData.prompt || null,
                        operationData.model || null,
                        operationData.aspectRatio || null,
                        operationData.resolution || null
                    ]);
                    console.log('[Video History] ‚úÖ V√≠deo salvo no hist√≥rico:', operationId);
                }
            } catch (error) {
                console.error('[Video History] Erro ao salvar v√≠deo no hist√≥rico:', error);
            }
        }
        
        res.json({
            status: operationData.status,
            videoUri: operationData.videoUri || null,
            videoBase64: operationData.videoBase64 || null,
            videoMimeType: operationData.videoMimeType || null,
            error: operationData.error || null,
            downloadError: operationData.downloadError || null,
            progress: currentProgress,
            progressMessage: progressMessage
        });

    } catch (error) {
        console.error('[Veo] Erro ao verificar status:', error);
        res.status(500).json({ message: 'Erro ao verificar status' });
    }
});

// GET /api/video/download/:operationId - Baixar v√≠deo gerado
app.get('/api/video/download/:operationId', authenticateToken, async (req, res) => {
    // Decodificar o operationId
    let operationId = decodeURIComponent(req.params.operationId);
    const userId = req.user.id;

    try {
        const operationData = videoOperations.get(operationId);
        
        if (!operationData) {
            return res.status(404).json({ message: 'Opera√ß√£o n√£o encontrada' });
        }

        if (operationData.userId !== userId) {
            return res.status(403).json({ message: 'Acesso negado' });
        }

        if (operationData.status !== 'completed') {
            return res.status(400).json({ message: 'V√≠deo ainda n√£o est√° pronto' });
        }

        // Se tiver base64, retornar diretamente
        if (operationData.videoBase64) {
            const videoBuffer = Buffer.from(operationData.videoBase64, 'base64');
            res.setHeader('Content-Type', operationData.videoMimeType || 'video/mp4');
            res.setHeader('Content-Disposition', `attachment; filename="video-${Date.now()}.mp4"`);
            res.setHeader('Content-Length', videoBuffer.length);
            return res.send(videoBuffer);
        }

        // Se n√£o tiver base64 mas tiver URI, baixar do Google e servir
        if (operationData.videoUri) {
            // Buscar API key
            const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            let apiKey = null;
            
            if (geminiKeyData) {
                apiKey = decrypt(geminiKeyData.api_key);
            } else if (operationData.useAdminApi && operationData.adminApi) {
                apiKey = operationData.adminApi.api_key;
            }

            if (!apiKey) {
                return res.status(500).json({ message: 'Chave de API n√£o encontrada' });
            }

            // Adicionar key ao URI se n√£o tiver
            let videoUrl = operationData.videoUri;
            if (!videoUrl.includes('key=')) {
                videoUrl = `${operationData.videoUri}${operationData.videoUri.includes('?') ? '&' : '?'}key=${apiKey}`;
            }

            // Baixar v√≠deo do Google
            const videoResponse = await axios.get(videoUrl, {
                responseType: 'arraybuffer',
                timeout: 120000
            });

            const videoBuffer = Buffer.from(videoResponse.data);
            res.setHeader('Content-Type', operationData.videoMimeType || 'video/mp4');
            res.setHeader('Content-Disposition', `attachment; filename="video-${Date.now()}.mp4"`);
            res.setHeader('Content-Length', videoBuffer.length);
            return res.send(videoBuffer);
        }

        return res.status(404).json({ message: 'V√≠deo n√£o dispon√≠vel' });

    } catch (error) {
        console.error('[Veo] Erro ao baixar v√≠deo:', error);
        res.status(500).json({ message: 'Erro ao baixar v√≠deo' });
    }
});

// Agendar publica√ß√£o de v√≠deo (mantido para compatibilidade, mas agora com suporte a auto-metadata)
app.post('/api/youtube/schedule', authenticateToken, async (req, res) => {
    const { youtubeIntegrationId, videoFilePath, title, description, tags, thumbnailUrl, scheduledTime, autoGenerateMetadata } = req.body;
    const userId = req.user.id;

    if (!title || !scheduledTime) {
        return res.status(400).json({ msg: 'T√≠tulo e hor√°rio agendado s√£o obrigat√≥rios.' });
    }

    try {
        let finalDescription = description;
        let finalTags = tags;

        // Se autoGenerateMetadata estiver ativado, gerar automaticamente
        if (autoGenerateMetadata) {
            try {
                // Buscar niche/subniche do usu√°rio ou do v√≠deo
                const userChannel = await db.get('SELECT niche, subniche FROM user_channels WHERE user_id = ? LIMIT 1', [userId]);
                const metadata = await fetch(`${req.protocol}://${req.get('host')}/api/youtube/generate-metadata`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': req.headers['authorization']
                    },
                    body: JSON.stringify({
                        title: title,
                        niche: userChannel?.niche || null,
                        subniche: userChannel?.subniche || null
                    })
                });

                if (metadata.ok) {
                    const metadataData = await metadata.json();
                    finalDescription = metadataData.description || description;
                    finalTags = metadataData.tags || tags;
                    console.log('[Agendamento] Metadata gerada automaticamente');
                }
            } catch (metaErr) {
                console.warn('[Agendamento] Falha ao gerar metadata autom√°tica, usando valores fornecidos:', metaErr.message);
            }
        }

        const result = await db.run(
            `INSERT INTO scheduled_posts (user_id, youtube_integration_id, video_file_path, title, description, tags, thumbnail_url, scheduled_time)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
            [userId, youtubeIntegrationId || null, videoFilePath || null, title, finalDescription || null, finalTags ? JSON.stringify(finalTags) : null, thumbnailUrl || null, scheduledTime]
        );
        res.status(201).json({ id: result.lastID, msg: 'Publica√ß√£o agendada com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/schedule]:', err);
        res.status(500).json({ msg: 'Erro ao agendar publica√ß√£o.' });
    }
});

// Listar todos os canais conectados do YouTube
app.get('/api/youtube/channels', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const integrations = await db.all(
            'SELECT id, channel_id, channel_name, token_expires_at, created_at, is_active FROM youtube_integrations WHERE user_id = ? AND is_active = 1 ORDER BY created_at DESC',
            [userId]
        );

        const channels = integrations.map(integration => {
            const isExpired = integration.token_expires_at 
                ? new Date(integration.token_expires_at) < new Date()
                : false;
            
            return {
                id: integration.id,
                channelId: integration.channel_id,
                channelName: integration.channel_name,
                niche: integration.niche || null,
                subniche: integration.subniche || null,
                isExpired: isExpired,
                createdAt: integration.created_at
            };
        });

        return res.status(200).json({
            channels: channels,
            count: channels.length,
            maxChannels: 10
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/channels]:', err);
        return res.status(500).json({ msg: 'Erro ao listar canais.' });
    }
});

// Verificar status da integra√ß√£o do YouTube (mantido para compatibilidade)
app.get('/api/youtube/status', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const integrations = await db.all(
            'SELECT * FROM youtube_integrations WHERE user_id = ? AND is_active = 1 ORDER BY created_at DESC',
            [userId]
        );

        if (!integrations || integrations.length === 0) {
            return res.status(200).json({ 
                connected: false, 
                message: 'Nenhuma integra√ß√£o configurada.',
                channels: []
            });
        }

        // Retornar o canal mais recente para compatibilidade
        const latestIntegration = integrations[0];
        const isExpired = latestIntegration.token_expires_at 
            ? new Date(latestIntegration.token_expires_at) < new Date()
            : false;

        return res.status(200).json({
            connected: true,
            channelId: latestIntegration.channel_id,
            channelName: latestIntegration.channel_name,
            isExpired: isExpired,
            createdAt: latestIntegration.created_at,
            totalChannels: integrations.length,
            channels: integrations.map(i => ({
                id: i.id,
                channelId: i.channel_id,
                channelName: i.channel_name,
                isExpired: i.token_expires_at ? new Date(i.token_expires_at) < new Date() : false
            }))
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/status]:', err);
        return res.status(500).json({ msg: 'Erro ao verificar status da integra√ß√£o.' });
    }
});

// Processar sele√ß√£o de canais ap√≥s OAuth (rota interna, chamada pela p√°gina de sele√ß√£o)
// NOTA: Esta rota √© chamada pela p√°gina de sele√ß√£o ap√≥s OAuth v√°lido
app.post('/api/youtube/oauth/connect-channels', async (req, res) => {
    const { userId, channelIds, accessToken, refreshToken, expiresAt } = req.body;

    if (!userId || !channelIds || !Array.isArray(channelIds) || channelIds.length === 0) {
        return res.status(400).json({ msg: 'Dados inv√°lidos.' });
    }

    if (!accessToken) {
        return res.status(400).json({ msg: 'Token de acesso n√£o fornecido.' });
    }

    // Validar que userId √© um n√∫mero v√°lido
    const userIdNum = parseInt(userId);
    if (isNaN(userIdNum) || userIdNum <= 0) {
        return res.status(400).json({ msg: 'ID de usu√°rio inv√°lido.' });
    }

    try {
        // Buscar informa√ß√µes dos canais selecionados
        const channelIdsParam = channelIds.join(',');
        const channelsInfoResponse = await fetch(
            `https://www.googleapis.com/youtube/v3/channels?part=snippet&id=${channelIdsParam}`,
            {
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                },
            }
        );

        if (!channelsInfoResponse.ok) {
            throw new Error('Falha ao buscar informa√ß√µes dos canais');
        }

        const channelsInfo = await channelsInfoResponse.json();
        if (!channelsInfo.items || channelsInfo.items.length === 0) {
            throw new Error('Nenhum canal encontrado');
        }

        // Verificar limite antes de conectar
        const existingChannelsCount = await db.get(
            'SELECT COUNT(*) as count FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
            [userIdNum]
        );
        const currentCount = existingChannelsCount?.count || 0;
        const maxChannels = 10;
        const remainingSlots = maxChannels - currentCount;

        if (channelIds.length > remainingSlots) {
            return res.status(400).json({ 
                msg: `Voc√™ s√≥ pode adicionar mais ${remainingSlots} canal(is). Voc√™ selecionou ${channelIds.length}.` 
            });
        }

        // Verificar quais canais j√° est√£o conectados
        const existingChannels = await db.all(
            'SELECT channel_id FROM youtube_integrations WHERE user_id = ? AND is_active = 1',
            [userId]
        );
        const existingChannelIds = new Set(existingChannels.map(c => c.channel_id));

        let connectedCount = 0;
        let updatedCount = 0;

        // Conectar cada canal selecionado
        for (const channelItem of channelsInfo.items) {
            const channelId = channelItem.id;
            const channelName = channelItem.snippet?.title || 'Canal do YouTube';

            // Pular se j√° est√° conectado
            if (existingChannelIds.has(channelId)) {
                continue;
            }

            // Verificar se j√° existe (mas inativo)
            const existingIntegration = await db.get(
                'SELECT id FROM youtube_integrations WHERE user_id = ? AND channel_id = ?',
                [userIdNum, channelId]
            );

            // Conectar o canal primeiro (sem bloquear na an√°lise)
            let integrationId;
            if (existingIntegration) {
                // Atualizar integra√ß√£o existente
                await db.run(
                    `UPDATE youtube_integrations 
                     SET access_token = ?, refresh_token = ?, token_expires_at = ?, 
                         channel_name = ?, is_active = 1, updated_at = CURRENT_TIMESTAMP 
                     WHERE id = ?`,
                    [accessToken, refreshToken || null, expiresAt, channelName, existingIntegration.id]
                );
                integrationId = existingIntegration.id;
                updatedCount++;
            } else {
                // Criar nova integra√ß√£o
                const result = await db.run(
                    `INSERT INTO youtube_integrations (user_id, channel_id, channel_name, access_token, refresh_token, token_expires_at, is_active)
                     VALUES (?, ?, ?, ?, ?, ?, 1)`,
                    [userIdNum, channelId, channelName, accessToken, refreshToken || null, expiresAt]
                );
                integrationId = result.lastID;
                connectedCount++;
            }

            // Analisar canal em background (n√£o bloqueia a resposta)
            analyzeChannelNiche(channelId, channelName, accessToken, userIdNum)
                .then(nicheAnalysis => {
                    if (nicheAnalysis.niche || nicheAnalysis.subniche) {
                        console.log(`[YouTube OAuth] Nicho detectado para ${channelName}: ${nicheAnalysis.niche} / ${nicheAnalysis.subniche}`);
                        // Atualizar o canal com o nicho detectado
                        db.run(
                            `UPDATE youtube_integrations 
                             SET niche = ?, subniche = ?, updated_at = CURRENT_TIMESTAMP 
                             WHERE id = ?`,
                            [nicheAnalysis.niche, nicheAnalysis.subniche, integrationId]
                        ).catch(err => {
                            console.error(`[YouTube OAuth] Erro ao salvar nicho detectado:`, err.message);
                        });
                    }
                })
                .catch(nicheErr => {
                    console.warn(`[YouTube OAuth] Erro ao analisar nicho do canal ${channelId}:`, nicheErr.message);
                    // N√£o fazer nada, o canal j√° est√° conectado
                });
        }

        console.log(`[YouTube OAuth] Canais conectados: ${connectedCount} novos, ${updatedCount} atualizados para userId: ${userIdNum}`);

        return res.status(200).json({
            msg: 'Canais conectados com sucesso!',
            connected: connectedCount + updatedCount,
            new: connectedCount,
            updated: updatedCount
        });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/oauth/connect-channels]:', err);
        return res.status(500).json({ msg: `Erro ao conectar canais: ${err.message}` });
    }
});

// Desconectar/remover um canal
app.delete('/api/youtube/channels/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const integrationId = parseInt(req.params.id);

    try {
        // Verificar se a integra√ß√£o pertence ao usu√°rio
        const integration = await db.get(
            'SELECT id FROM youtube_integrations WHERE id = ? AND user_id = ?',
            [integrationId, userId]
        );

        if (!integration) {
            return res.status(404).json({ msg: 'Canal n√£o encontrado.' });
        }

        // Desativar a integra√ß√£o (soft delete)
        await db.run(
            'UPDATE youtube_integrations SET is_active = 0, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
            [integrationId]
        );

        console.log(`[YouTube] Canal desconectado: userId=${userId}, integrationId=${integrationId}`);
        return res.status(200).json({ msg: 'Canal desconectado com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/channels/:id DELETE]:', err);
        return res.status(500).json({ msg: 'Erro ao desconectar canal.' });
    }
});

// Listar publica√ß√µes agendadas
app.get('/api/youtube/scheduled', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    console.log(`[YouTube Scheduled] Requisi√ß√£o recebida para userId: ${userId}`);

    try {
        if (!db) {
            console.error('[YouTube Scheduled] Banco de dados n√£o est√° dispon√≠vel');
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        let scheduled = [];
        try {
            scheduled = await db.all(
                'SELECT * FROM scheduled_posts WHERE user_id = ? ORDER BY scheduled_time ASC',
                [userId]
            );
            console.log(`[YouTube Scheduled] Publica√ß√µes encontradas:`, scheduled.length);
        } catch (dbErr) {
            console.error('[YouTube Scheduled] Erro ao buscar publica√ß√µes:', dbErr);
            scheduled = [];
        }

        res.status(200).json(scheduled || []);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/scheduled]:', err);
        // Retornar array vazio se a tabela n√£o existir
        res.status(200).json([]);
    }
});

// === PARTE 2.B: MONITORAMENTO AUTOM√ÅTICO ===

// B.1 - Alertas de V√≠deos Virais: Verificar e notificar sobre v√≠deos virais de competidores
app.get('/api/youtube/viral-alerts', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        console.log(`[Viral Alerts] Buscando alertas para userId: ${userId}`);
        const alerts = await db.all(
            `SELECT * FROM viral_alerts 
             WHERE user_id = ? AND (notified = 0 OR notified IS NULL)
             ORDER BY detected_at DESC 
             LIMIT 50`,
            [userId]
        );

        console.log(`[Viral Alerts] ${alerts?.length || 0} alertas encontrados para userId: ${userId}`);
        res.status(200).json({ alerts: alerts || [] });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/viral-alerts]:', err);
        res.status(500).json({ msg: `Erro ao buscar alertas virais: ${err.message}` });
    }
});

// B.2 - An√°lise Autom√°tica de Tend√™ncias: Escanear YouTube por novos v√≠deos virais
app.post('/api/youtube/scan-trends', authenticateToken, async (req, res) => {
    const { 
        niche, 
        subniche, 
        maxResults = 10,
        minViews = 0,
        minViewsPerDay = 0,
        language = 'pt',
        publishedAfter = 7, // dias
        orderBy = 'viewCount', // viewCount, date, rating, relevance
        videoDuration = 'any', // any, short, medium, long
        videoDefinition = 'any' // any, high, standard
    } = req.body;
    const userId = req.user.id;

    if (!niche) {
        return res.status(400).json({ msg: 'Nicho √© obrigat√≥rio para escanear tend√™ncias.' });
    }

    try {
        // Buscar chave do YouTube ou Gemini (necess√°ria para YouTube API)
        // IMPORTANTE: A chave do Gemini pode ser usada para YouTube API, mas √© melhor usar uma chave espec√≠fica do YouTube
        // Tentar primeiro buscar chave do YouTube, depois Gemini como fallback
        let youtubeApiKey = null;
        
        // Tentar buscar chave do YouTube especificamente
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (youtubeKeyData) {
            youtubeApiKey = decrypt(youtubeKeyData.api_key);
        }
        
        // Se n√£o tiver chave do YouTube, tentar Gemini
        if (!youtubeApiKey) {
            const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
            if (geminiKeyData) {
                youtubeApiKey = decrypt(geminiKeyData.api_key);
            }
        }
        
        if (!youtubeApiKey) {
            return res.status(400).json({ 
                msg: 'Chave de API do YouTube ou Gemini √© necess√°ria para escanear tend√™ncias. Configure uma chave de API do YouTube Data API v3 nas Configura√ß√µes.' 
            });
        }

        // Mapear idioma para c√≥digo do YouTube
        const languageMap = {
            'pt': 'pt',
            'pt-BR': 'pt',
            'en': 'en',
            'es': 'es',
            'fr': 'fr',
            'de': 'de',
            'it': 'it',
            'ja': 'ja',
            'ko': 'ko',
            'zh': 'zh',
            'ru': 'ru'
        };
        const videoLanguage = languageMap[language] || 'pt';
        
        // Mapear dura√ß√£o do v√≠deo
        const durationMap = {
            'short': 'short', // menos de 4 minutos
            'medium': 'medium', // 4-20 minutos
            'long': 'long' // mais de 20 minutos
        };
        const videoDurationParam = durationMap[videoDuration] || 'any';
        
        // Mapear ordena√ß√£o
        const orderMap = {
            'viewCount': 'viewCount',
            'date': 'date',
            'rating': 'rating',
            'relevance': 'relevance'
        };
        const orderParam = orderMap[orderBy] || 'viewCount';
        
        // Calcular data de publica√ß√£o
        const publishedAfterDate = new Date(Date.now() - publishedAfter * 24 * 60 * 60 * 1000).toISOString();
        
        // Buscar v√≠deos virais recentes usando YouTube Data API
        const searchQuery = `${niche} ${subniche || ''}`.trim();
        
        // Construir URL com par√¢metros
        let searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(searchQuery)}&type=video&order=${orderParam}&maxResults=${Math.min(maxResults, 50)}&publishedAfter=${publishedAfterDate}&relevanceLanguage=${videoLanguage}&key=${youtubeApiKey}`;
        
        // Adicionar filtro de dura√ß√£o se especificado
        if (videoDurationParam !== 'any') {
            searchUrl += `&videoDuration=${videoDurationParam}`;
        }
        
        // Adicionar filtro de defini√ß√£o se especificado
        if (videoDefinition !== 'any') {
            searchUrl += `&videoDefinition=${videoDefinition}`;
        }
        
        console.log(`[Scan Trends] Buscando tend√™ncias para: "${searchQuery}"`);
        console.log(`[Scan Trends] Filtros: minViews=${minViews}, minViewsPerDay=${minViewsPerDay}, language=${videoLanguage}, publishedAfter=${publishedAfter} dias, orderBy=${orderParam}, duration=${videoDurationParam}`);
        const searchResponse = await fetch(searchUrl);
        const searchData = await searchResponse.json();
        
        if (!searchResponse.ok) {
            console.error('[Scan Trends] Erro da API do YouTube:', JSON.stringify(searchData, null, 2));
            let errorMsg = 'Falha ao buscar v√≠deos do YouTube.';
            
            if (searchData.error) {
                if (searchData.error.message && searchData.error.message.includes('API key not valid')) {
                    errorMsg = 'A chave de API do YouTube n√£o √© v√°lida. Verifique se a chave est√° correta e se a API do YouTube Data API v3 est√° habilitada no Google Cloud Console.';
                } else {
                    errorMsg = searchData.error.message || errorMsg;
                }
            }
            
            return res.status(400).json({ msg: errorMsg, trends: [] });
        }
        
        if (!searchData.items || searchData.items.length === 0) {
            return res.status(200).json({ trends: [], count: 0, msg: 'Nenhum v√≠deo encontrado para este nicho.' });
        }

        const videoIds = searchData.items.map(item => item.id.videoId).filter(Boolean).join(',');
        
        if (!videoIds) {
            return res.status(200).json({ trends: [], count: 0, msg: 'Nenhum v√≠deo v√°lido encontrado.' });
        }

        // Buscar detalhes dos v√≠deos
        const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoIds}&key=${youtubeApiKey}`;
        const detailsResponse = await fetch(detailsUrl);
        const detailsData = await detailsResponse.json();
        
        if (!detailsResponse.ok) {
            console.error('[Scan Trends] Erro ao buscar detalhes:', detailsData);
            const errorMsg = detailsData.error?.message || 'Falha ao buscar detalhes dos v√≠deos.';
            return res.status(400).json({ msg: errorMsg, trends: [] });
        }

        const trends = [];
        const allVideos = [];
        
        for (const video of detailsData.items || []) {
            const views = parseInt(video.statistics.viewCount || 0);
            const publishedAt = new Date(video.snippet.publishedAt);
            const daysSince = Math.round((new Date() - publishedAt) / (1000 * 60 * 60 * 24));
            const viewsPerDay = daysSince > 0 ? views / daysSince : views;

            const videoData = {
                videoId: video.id,
                title: video.snippet.title,
                url: `https://www.youtube.com/watch?v=${video.id}`,
                channelId: video.snippet.channelId,
                channelName: video.snippet.channelTitle,
                views: views,
                viewsPerDay: Math.round(viewsPerDay),
                daysSince: daysSince,
                thumbnailUrl: video.snippet.thumbnails.high?.url || video.snippet.thumbnails.default?.url,
                isViral: isViralVideo(views, daysSince, viewsPerDay)
            };

            allVideos.push(videoData);

            // Verificar se √© viral
            if (videoData.isViral) {
                // Salvar na tabela de tend√™ncias (ou atualizar se j√° existir)
                try {
                    await db.run(
                        `INSERT OR REPLACE INTO trend_analysis (user_id, niche, subniche, video_id, video_title, video_url, channel_id, channel_name, views, views_per_day, analyzed, detected_at)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)`,
                        [userId, niche, subniche || null, video.id, video.snippet.title, videoData.url, video.snippet.channelId, video.snippet.channelTitle, views, viewsPerDay]
                    );
                } catch (dbErr) {
                    console.error('[Scan Trends] Erro ao salvar tend√™ncia:', dbErr.message);
                }

                trends.push(videoData);
            }
        }

        console.log(`[Scan Trends] Total de v√≠deos encontrados: ${allVideos.length}, V√≠deos virais: ${trends.length}`);
        
        // Se n√£o encontrou v√≠deos virais, retornar os top v√≠deos encontrados mesmo assim
        const finalTrends = trends.length > 0 ? trends : allVideos.slice(0, Math.min(5, allVideos.length));
        
        res.status(200).json({ 
            trends: finalTrends,
            count: finalTrends.length,
            msg: finalTrends.length > 0 
                ? `${finalTrends.length} v√≠deo(s) ${trends.length > 0 ? 'viral(is)' : 'relevante(s)'} encontrado(s) no nicho ${niche}.`
                : `Nenhum v√≠deo encontrado para o nicho ${niche}.`
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/scan-trends]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao escanear tend√™ncias.' });
    }
});
// B.3 - Auto-an√°lise de Canais Competidores: Adicionar canal para monitoramento autom√°tico
app.post('/api/youtube/monitor-competitor', authenticateToken, async (req, res) => {
    const { competitorChannelId, competitorChannelName, niche, subniche, autoAnalyze = true, checkFrequency = 'daily' } = req.body;
    const userId = req.user.id;

    if (!competitorChannelId) {
        return res.status(400).json({ msg: 'ID do canal competidor √© obrigat√≥rio.' });
    }

    try {
        // Verificar se j√° est√° sendo monitorado
        const existing = await db.get(
            'SELECT * FROM competitor_monitoring WHERE user_id = ? AND competitor_channel_id = ?',
            [userId, competitorChannelId]
        );

        if (existing) {
            // Atualizar configura√ß√µes
            await db.run(
                `UPDATE competitor_monitoring 
                 SET competitor_channel_name = ?, niche = ?, subniche = ?, auto_analyze = ?, check_frequency = ?
                 WHERE id = ?`,
                [competitorChannelName || existing.competitor_channel_name, niche || null, subniche || null, autoAnalyze ? 1 : 0, checkFrequency, existing.id]
            );
            return res.status(200).json({ id: existing.id, msg: 'Configura√ß√µes de monitoramento atualizadas.' });
        } else {
            // Criar novo monitoramento
            const result = await db.run(
                `INSERT INTO competitor_monitoring (user_id, competitor_channel_id, competitor_channel_name, niche, subniche, auto_analyze, check_frequency)
                 VALUES (?, ?, ?, ?, ?, ?, ?)`,
                [userId, competitorChannelId, competitorChannelName || null, niche || null, subniche || null, autoAnalyze ? 1 : 0, checkFrequency]
            );
            return res.status(201).json({ id: result.lastID, msg: 'Canal adicionado para monitoramento autom√°tico.' });
        }
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/monitor-competitor]:', err);
        res.status(500).json({ msg: 'Erro ao configurar monitoramento.' });
    }
});

// Listar canais monitorados
app.get('/api/youtube/monitored-competitors', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        const competitors = await db.all(
            'SELECT * FROM competitor_monitoring WHERE user_id = ? ORDER BY created_at DESC',
            [userId]
        );

        res.status(200).json({ competitors: competitors || [] });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/monitored-competitors]:', err);
        res.status(500).json({ msg: 'Erro ao listar canais monitorados.' });
    }
});

// Remover canal do monitoramento
app.delete('/api/youtube/monitor-competitor/:id', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;

    try {
        const result = await db.run(
            'DELETE FROM competitor_monitoring WHERE id = ? AND user_id = ?',
            [id, userId]
        );

        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Monitoramento n√£o encontrado.' });
        }

        res.status(200).json({ msg: 'Monitoramento removido com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/monitor-competitor DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao remover monitoramento.' });
    }
});

// B.4 - Sugest√µes Autom√°ticas: IA sugere novos v√≠deos baseado em tend√™ncias
app.get('/api/youtube/ai-suggestions', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { limit = 10 } = req.query;

    try {
        const suggestions = await db.all(
            `SELECT * FROM ai_suggestions 
             WHERE user_id = ? AND viewed = 0 
             ORDER BY priority DESC, created_at DESC 
             LIMIT ?`,
            [userId, parseInt(limit)]
        );

        res.status(200).json({ suggestions: suggestions || [] });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/ai-suggestions]:', err);
        res.status(500).json({ msg: 'Erro ao buscar sugest√µes.' });
    }
});

// Gerar sugest√µes autom√°ticas baseadas em tend√™ncias
app.post('/api/youtube/generate-suggestions', authenticateToken, async (req, res) => {
    const { niche, subniche } = req.body;
    const userId = req.user.id;

    if (!niche) {
        return res.status(400).json({ msg: 'Nicho √© obrigat√≥rio para gerar sugest√µes.' });
    }

    try {
        console.log(`[Generate Suggestions] Iniciando para nicho: ${niche}, subniche: ${subniche}`);
        
        // Buscar tend√™ncias recentes do usu√°rio (n√£o analisadas ainda)
        const recentTrends = await db.all(
            `SELECT * FROM trend_analysis 
             WHERE user_id = ? AND niche = ? AND (analyzed = 0 OR analyzed IS NULL)
             ORDER BY detected_at DESC LIMIT 5`,
            [userId, niche]
        );
        
        console.log(`[Generate Suggestions] Tend√™ncias encontradas para nicho "${niche}": ${recentTrends.length}`);

        // Se n√£o houver tend√™ncias salvas, buscar tend√™ncias em tempo real
        let trendsToUse = recentTrends;
        if (recentTrends.length === 0) {
            console.log(`[Generate Suggestions] Nenhuma tend√™ncia salva encontrada. Buscando tend√™ncias em tempo real...`);
            
            try {
                // Buscar chave do YouTube ou Gemini
                let youtubeApiKey = null;
                const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
                if (youtubeKeyData) {
                    youtubeApiKey = decrypt(youtubeKeyData.api_key);
                }
                if (!youtubeApiKey) {
                    const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
                    if (geminiKeyData) {
                        youtubeApiKey = decrypt(geminiKeyData.api_key);
                    }
                }
                
                if (youtubeApiKey) {
                    // Buscar v√≠deos recentes do nicho
                    const searchQuery = `${niche} ${subniche || ''}`.trim();
                    const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(searchQuery)}&type=video&order=viewCount&maxResults=5&publishedAfter=${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()}&relevanceLanguage=pt&key=${youtubeApiKey}`;
                    
                    const searchResponse = await fetch(searchUrl);
                    if (searchResponse.ok) {
                        const searchData = await searchResponse.json();
                        if (searchData.items && searchData.items.length > 0) {
                            const videoIds = searchData.items.map(item => item.id.videoId).filter(Boolean).join(',');
                            if (videoIds) {
                                const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoIds}&key=${youtubeApiKey}`;
                                const detailsResponse = await fetch(detailsUrl);
                                if (detailsResponse.ok) {
                                    const detailsData = await detailsResponse.json();
                                    // Criar objetos de tend√™ncia tempor√°rios
                                    trendsToUse = (detailsData.items || []).map(video => ({
                                        video_title: video.snippet.title,
                                        views: parseInt(video.statistics.viewCount || 0),
                                        views_per_day: Math.round((parseInt(video.statistics.viewCount || 0)) / Math.max(1, Math.round((new Date() - new Date(video.snippet.publishedAt)) / (1000 * 60 * 60 * 24)))),
                                        video_url: `https://www.youtube.com/watch?v=${video.id}`,
                                        channel_name: video.snippet.channelTitle
                                    }));
                                    console.log(`[Generate Suggestions] ${trendsToUse.length} tend√™ncias encontradas em tempo real`);
                                }
                            }
                        }
                    }
                }
            } catch (trendsErr) {
                console.warn(`[Generate Suggestions] Erro ao buscar tend√™ncias em tempo real:`, trendsErr.message);
            }
        }

        // Se ainda n√£o houver tend√™ncias, usar o nicho diretamente
        if (trendsToUse.length === 0) {
            console.log(`[Generate Suggestions] Nenhuma tend√™ncia dispon√≠vel. Gerando sugest√µes baseadas apenas no nicho "${niche}"`);
        }

        // Verificar se deve usar cr√©ditos (laozhang.ai) ou API pr√≥pria
        // REGRA: Usa cr√©ditos se usu√°rio marcou prefer√™ncia OU n√£o tem plano que permite API pr√≥pria OU n√£o tem API pr√≥pria configurada
        // REGRA CR√çTICA: Se prefer√™ncia N√ÉO est√° marcada E usu√°rio tem plano que permite E tem API pr√≥pria ‚Üí usar API pr√≥pria
        const creditsCheck = await shouldUseCredits(userId, ['claude', 'openai', 'gemini']);
        
        console.log(`[Generate Suggestions] shouldUseCredits: ${creditsCheck.shouldUse}, reason: ${creditsCheck.reason}`);
        
        let suggestions = [];
        
        // Se deve usar cr√©ditos, usar laozhang.ai primeiro
        if (creditsCheck.shouldUse) {
            console.log('[Generate Suggestions] Verificando chave laozhang.ai...');
            const laozhangKey = await getLaozhangApiKey();
            console.log('[Generate Suggestions] Chave laozhang.ai encontrada:', laozhangKey ? 'Sim' : 'N√£o');
            if (laozhangKey) {
                try {
                    let trendsSummary = '';
                    if (trendsToUse.length > 0) {
                        trendsSummary = trendsToUse.map(t => `- "${t.video_title}" (${t.views} views${t.views_per_day ? ` em ${t.views_per_day} views/dia` : ''})`).join('\n');
                    }

                    const prompt = `Voc√™ √© um ESPECIALISTA EM CRIA√á√ÉO DE CONTE√öDO VIRAL PARA YOUTUBE com conhecimento profundo sobre tend√™ncias, algoritmos e o que faz um v√≠deo viralizar.

${trendsToUse.length > 0 ? `Analise as seguintes tend√™ncias virais no nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''}:

${trendsSummary}

Com base nessas tend√™ncias virais, sugira 5 NOVOS v√≠deos que o criador poderia fazer para aproveitar essas tend√™ncias e potencialmente viralizar tamb√©m.` : `O criador est√° interessado no nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''}.

Com base nas tend√™ncias atuais deste nicho no YouTube, sugira 5 NOVOS v√≠deos com alto potencial viral que o criador poderia fazer.`}

Para cada sugest√£o, forne√ßa:
1. Um t√≠tulo viral e chamativo
2. Uma breve descri√ß√£o do conceito do v√≠deo
3. O motivo pelo qual esta ideia tem potencial de viralizar

Responda APENAS com um JSON v√°lido no formato:
{
  "suggestions": [
    {
      "title": "T√≠tulo viral sugerido",
      "description": "Descri√ß√£o do conceito do v√≠deo",
      "reason": "Por que esta ideia tem potencial de viralizar",
      "priority": 8 (1-10, sendo 10 o maior potencial)
    },
    ...
  ]
}

IMPORTANTE: 
- Os t√≠tulos devem ser em portugu√™s (Brasil)
- Foque em ideias que aproveitem os padr√µes das tend√™ncias analisadas
- Seja espec√≠fico e criativo
- Priorize ideias com alto potencial de engajamento

Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await callLaozhangAPI(prompt, laozhangKey, 'gpt-4o', null, userId, '/api/youtube/generate-suggestions', JSON.stringify({ endpoint: '/api/youtube/generate-suggestions', model: 'gpt-4o' }));
                    // callLaozhangAPI retorna uma string diretamente, n√£o um objeto
                    const responseText = typeof response === 'string' ? response : (response?.titles || response?.text || response?.content || JSON.stringify(response) || '');
                    
                    console.log(`[Sugest√µes IA] Resposta recebida (${responseText.length} caracteres)`);
                    console.log(`[Sugest√µes IA] Primeiros 500 caracteres:`, responseText.substring(0, 500));
                    
                    // Verificar se a API recusou a requisi√ß√£o (apenas se for uma mensagem de erro clara, n√£o JSON v√°lido)
                    const hasValidJson = responseText.match(/\{[\s\S]*"suggestions"[\s\S]*\}/) || responseText.match(/\{[\s\S]*"title"[\s\S]*\}/);
                    
                    if (!hasValidJson) {
                        const errorPatterns = [
                            /^I'm sorry,?\s+I can't assist/i,
                            /^I'm sorry,?\s+I cannot/i,
                            /^I'm unable to assist/i,
                            /^I cannot fulfill/i,
                            /^I must decline/i,
                            /^I can't help with that/i,
                            /^I'm not able to/i,
                            /^This request violates/i,
                            /^I cannot comply/i
                        ];
                        
                        const trimmedResponse = responseText.trim();
                        const isError = errorPatterns.some(pattern => pattern.test(trimmedResponse));
                        
                        if (isError || (trimmedResponse.length < 100 && trimmedResponse.toLowerCase().startsWith("i'm sorry"))) {
                            console.error('[Sugest√µes IA] API recusou a requisi√ß√£o:', responseText.substring(0, 500));
                            throw new Error(`A API de IA recusou processar o prompt. Isso pode acontecer se o conte√∫do violar as pol√≠ticas de uso da API. Tente simplificar o conte√∫do ou remover conte√∫do sens√≠vel.`);
                        }
                    }
                    
                    // Tentar extrair JSON da resposta - usar regex mais robusto para pegar JSON completo
                    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    // Se n√£o encontrar, tentar remover markdown code blocks
                    if (!jsonMatch) {
                        const cleaned = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                        jsonMatch = cleaned.match(/\{[\s\S]*\}/);
                    }
                    
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.suggestions && Array.isArray(parsed.suggestions)) {
                                // Salvar sugest√µes no banco
                                for (const suggestion of parsed.suggestions) {
                                    try {
                                        await db.run(
                                            `INSERT INTO ai_suggestions (user_id, suggestion_type, title, description, niche, subniche, reason, priority, viewed, created_at)
                                             VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)`,
                                            [userId, 'trend_based', suggestion.title || 'Sugest√£o sem t√≠tulo', suggestion.description || 'Sem descri√ß√£o', niche, subniche || null, suggestion.reason || 'Baseado em tend√™ncias virais', suggestion.priority || 5]
                                        );
                                        console.log(`[Sugest√µes IA] Sugest√£o salva: "${suggestion.title || 'Sem t√≠tulo'}"`);
                                    } catch (dbErr) {
                                        console.error(`[Sugest√µes IA] Erro ao salvar sugest√£o:`, dbErr.message);
                                    }
                                }
                                suggestions = parsed.suggestions;
                                console.log(`[Sugest√µes IA] ‚úÖ ${suggestions.length} sugest√µes geradas usando API configurada como padr√£o`);
                            } else {
                                console.warn(`[Sugest√µes IA] Resposta n√£o tem formato esperado (sem array 'suggestions')`);
                                console.warn(`[Sugest√µes IA] Estrutura recebida:`, Object.keys(parsed));
                            }
                        } catch (e) {
                            console.warn(`[Sugest√µes IA] Falha ao parsear JSON:`, e.message);
                            console.warn(`[Sugest√µes IA] JSON encontrado:`, jsonMatch[0].substring(0, 500));
                        }
                    } else {
                        console.warn(`[Sugest√µes IA] Nenhum JSON encontrado na resposta`);
                        console.warn(`[Sugest√µes IA] Resposta completa:`, responseText.substring(0, 1000));
                    }
                } catch (serviceErr) {
                    console.error(`[Sugest√µes IA] Erro ao usar API configurada como padr√£o:`, serviceErr.message);
                    // Se deve usar cr√©ditos e laozhang falhou, n√£o tentar APIs pr√≥prias
                    if (creditsCheck.shouldUse) {
                        return res.status(500).json({ 
                            suggestions: [],
                            count: 0,
                            msg: 'Erro ao gerar sugest√µes usando sistema de cr√©ditos. Verifique se a chave est√° configurada corretamente no painel admin.' 
                        });
                    }
                }
            } else if (creditsCheck.shouldUse) {
                // Se deve usar cr√©ditos mas n√£o tem chave
                return res.status(400).json({ 
                    suggestions: [],
                    count: 0,
                    msg: 'API configurada como padr√£o n√£o est√° configurada. Configure a chave no painel admin ou desmarque a op√ß√£o de usar cr√©ditos.' 
                });
            }
        }
        
        // Se n√£o usar cr√©ditos ou se laozhang falhou (e n√£o √© obrigat√≥rio), usar APIs pr√≥prias
        if (suggestions.length === 0 && !creditsCheck.shouldUse) {
            // Tentar usar IA para gerar sugest√µes baseadas nas tend√™ncias
            const services = ['gemini', 'claude', 'openai'];

            for (const service of services) {
                try {
                    const serviceKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
                    if (!serviceKeyData) continue;

                    const decryptedKey = decrypt(serviceKeyData.api_key);
                    if (!decryptedKey) continue;

                    let apiCallFunction;
                    let model;
                    if (service === 'gemini') {
                        apiCallFunction = callGeminiAPI;
                        model = 'gemini-2.0-flash';
                    } else if (service === 'claude') {
                        apiCallFunction = callClaudeAPI;
                        model = 'claude-3-5-haiku-20241022';
                    } else {
                        apiCallFunction = callOpenAIAPI;
                        model = 'gpt-4o'; // Usar GPT-4o como padr√£o
                    }

                    const trendsSummary = trendsToUse.length > 0 
                        ? trendsToUse.map(t => `- "${t.video_title}" (${t.views} views${t.views_per_day ? ` em ${t.views_per_day} views/dia` : ''})`).join('\n')
                        : '';

                    const prompt = trendsToUse.length > 0 
                        ? `Voc√™ √© um ESPECIALISTA EM CRIA√á√ÉO DE CONTE√öDO VIRAL PARA YOUTUBE com conhecimento profundo sobre tend√™ncias, algoritmos e o que faz um v√≠deo viralizar.

Analise as seguintes tend√™ncias virais no nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''}:

${trendsSummary}

Com base nessas tend√™ncias virais, sugira 5 NOVOS v√≠deos que o criador poderia fazer para aproveitar essas tend√™ncias e potencialmente viralizar tamb√©m.`
                        : `Voc√™ √© um ESPECIALISTA EM CRIA√á√ÉO DE CONTE√öDO VIRAL PARA YOUTUBE com conhecimento profundo sobre tend√™ncias, algoritmos e o que faz um v√≠deo viralizar.

O criador est√° interessado no nicho "${niche}"${subniche ? ` e subnicho "${subniche}"` : ''}.

Com base nas tend√™ncias atuais deste nicho no YouTube, sugira 5 NOVOS v√≠deos com alto potencial viral que o criador poderia fazer.

Para cada sugest√£o, forne√ßa:
1. Um t√≠tulo viral e chamativo
2. Uma breve descri√ß√£o do conceito do v√≠deo
3. O motivo pelo qual esta ideia tem potencial de viralizar

Responda APENAS com um JSON v√°lido no formato:
{
  "suggestions": [
    {
      "title": "T√≠tulo viral sugerido",
      "description": "Descri√ß√£o do conceito do v√≠deo",
      "reason": "Por que esta ideia tem potencial de viralizar",
      "priority": 8 (1-10, sendo 10 o maior potencial)
    },
    ...
  ]
}

IMPORTANTE: 
- Os t√≠tulos devem ser em portugu√™s (Brasil)
- Foque em ideias que aproveitem os padr√µes das tend√™ncias analisadas
- Seja espec√≠fico e criativo
- Priorize ideias com alto potencial de engajamento

Responda APENAS com o JSON, sem texto adicional.`;

                    const response = await apiCallFunction(prompt, decryptedKey, model);
                    // A resposta pode ser string direta ou objeto
                    const responseText = typeof response === 'string' ? response : (response?.titles || response?.text || response?.content || JSON.stringify(response) || '');
                    
                    console.log(`[Sugest√µes IA] Resposta de ${service} (${responseText.length} caracteres)`);
                    
                    // Tentar extrair JSON da resposta - usar regex mais robusto para pegar JSON completo
                    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    // Se n√£o encontrar, tentar remover markdown code blocks
                    if (!jsonMatch) {
                        const cleaned = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                        jsonMatch = cleaned.match(/\{[\s\S]*\}/);
                    }
                    
                    if (jsonMatch) {
                        try {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.suggestions && Array.isArray(parsed.suggestions)) {
                                // Salvar sugest√µes no banco
                                for (const suggestion of parsed.suggestions) {
                                    try {
                                        await db.run(
                                            `INSERT INTO ai_suggestions (user_id, suggestion_type, title, description, niche, subniche, reason, priority, viewed, created_at)
                                             VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)`,
                                            [userId, 'trend_based', suggestion.title || 'Sugest√£o sem t√≠tulo', suggestion.description || 'Sem descri√ß√£o', niche, subniche || null, suggestion.reason || 'Baseado em tend√™ncias virais', suggestion.priority || 5]
                                        );
                                        console.log(`[Sugest√µes IA] Sugest√£o salva: "${suggestion.title || 'Sem t√≠tulo'}"`);
                                    } catch (dbErr) {
                                        console.error(`[Sugest√µes IA] Erro ao salvar sugest√£o:`, dbErr.message);
                                    }
                                }
                                suggestions = parsed.suggestions;
                                console.log(`[Sugest√µes IA] ‚úÖ ${suggestions.length} sugest√µes geradas e salvas usando ${service}`);
                                break;
                            } else {
                                console.warn(`[Sugest√µes IA] Resposta de ${service} n√£o tem formato esperado (sem array 'suggestions')`);
                            }
                        } catch (e) {
                            console.warn(`[Sugest√µes IA] Falha ao parsear JSON de ${service}:`, e.message);
                            console.warn(`[Sugest√µes IA] JSON encontrado:`, jsonMatch[0].substring(0, 500));
                        }
                    } else {
                        console.warn(`[Sugest√µes IA] Nenhum JSON encontrado na resposta de ${service}`);
                    }
                } catch (serviceErr) {
                    console.warn(`[Sugest√µes IA] Falha com ${service}:`, serviceErr.message);
                    continue;
                }
            }
        }

        // Fallback: gerar sugest√µes b√°sicas baseadas nos t√≠tulos das tend√™ncias
        if (suggestions.length === 0 && recentTrends.length > 0) {
            console.log(`[Sugest√µes IA] Gerando sugest√µes b√°sicas baseadas em ${recentTrends.length} tend√™ncias`);
            for (const trend of recentTrends.slice(0, 3)) {
                try {
                    await db.run(
                        `INSERT INTO ai_suggestions (user_id, suggestion_type, title, description, niche, subniche, reason, priority, viewed, created_at)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)`,
                        [userId, 'trend_based', `Vers√£o adaptada: ${trend.video_title}`, `Crie uma vers√£o adaptada deste v√≠deo viral para seu canal`, niche, subniche || null, `Baseado no v√≠deo viral "${trend.video_title}" com ${trend.views} views`, 7]
                    );
                } catch (dbErr) {
                    console.error(`[Sugest√µes IA] Erro ao salvar sugest√£o b√°sica:`, dbErr.message);
                }
            }
            suggestions = recentTrends.slice(0, 3).map(t => ({
                title: `Vers√£o adaptada: ${t.video_title}`,
                description: `Crie uma vers√£o adaptada deste v√≠deo viral para seu canal`,
                reason: `Baseado no v√≠deo viral com ${t.views} views`,
                priority: 7
            }));
            console.log(`[Sugest√µes IA] ‚úÖ ${suggestions.length} sugest√µes b√°sicas geradas`);
        }

        res.status(200).json({ 
            suggestions: suggestions,
            count: suggestions.length,
            msg: `${suggestions.length} sugest√£o(√µes) gerada(s) com sucesso.`
        });

    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/generate-suggestions]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao gerar sugest√µes.' });
    }
});

// Marcar sugest√£o como visualizada
app.put('/api/youtube/ai-suggestions/:id/viewed', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;

    try {
        await db.run(
            'UPDATE ai_suggestions SET viewed = 1 WHERE id = ? AND user_id = ?',
            [id, userId]
        );

        res.status(200).json({ msg: 'Sugest√£o marcada como visualizada.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/youtube/ai-suggestions PUT]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar sugest√£o.' });
    }
});

// === ROTAS DE GERENCIAMENTO DE CANAIS DO USU√ÅRIO ===

// Criar/Atualizar canal do usu√°rio
app.post('/api/channels', authenticateToken, async (req, res) => {
    const { channelName, channelUrl, channelId, niche, language, country } = req.body;
    const userId = req.user.id;

    if (!channelName) {
        return res.status(400).json({ msg: 'Nome do canal √© obrigat√≥rio.' });
    }

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        // Verificar limite de 10 canais por usu√°rio
        const channelCount = await db.get('SELECT COUNT(*) as count FROM user_channels WHERE user_id = ?', [userId]);
        if (channelCount && channelCount.count >= 10) {
            return res.status(400).json({ msg: 'Limite de 10 canais atingido. Exclua um canal antes de adicionar outro.' });
        }

        // Verificar se j√° existe um canal com o mesmo nome para este usu√°rio
        const existing = await db.get('SELECT id FROM user_channels WHERE user_id = ? AND channel_name = ?', [userId, channelName]);
        
        if (existing) {
            // Atualizar canal existente
            await db.run(
                `UPDATE user_channels 
                 SET channel_url = ?, channel_id = ?, niche = ?, language = ?, country = ?, updated_at = CURRENT_TIMESTAMP 
                 WHERE id = ? AND user_id = ?`,
                [channelUrl || null, channelId || null, niche || null, language || 'pt-BR', country || 'BR', existing.id, userId]
            );
            console.log(`[Canais] Canal ${existing.id} atualizado pelo usu√°rio ${userId}`);
            res.status(200).json({ id: existing.id, msg: 'Canal atualizado com sucesso.' });
        } else {
            // Criar novo canal
            const result = await db.run(
                `INSERT INTO user_channels (user_id, channel_name, channel_url, channel_id, niche, language, country) 
                 VALUES (?, ?, ?, ?, ?, ?, ?)`,
                [userId, channelName, channelUrl || null, channelId || null, niche || null, language || 'pt-BR', country || 'BR']
            );
            console.log(`[Canais] Canal ${result.lastID} criado pelo usu√°rio ${userId}`);
            res.status(201).json({ id: result.lastID, msg: 'Canal criado com sucesso.' });
        }
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels POST]:', err);
        if (err.message.includes('UNIQUE constraint failed')) {
            return res.status(400).json({ msg: 'J√° existe um canal com este nome.' });
        }
        res.status(500).json({ msg: 'Erro ao criar/atualizar canal.' });
    }
});

// Listar canais do usu√°rio
app.get('/api/channels', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        const channels = await db.all(
            'SELECT * FROM user_channels WHERE user_id = ? ORDER BY created_at DESC',
            [userId]
        );
        res.status(200).json(channels || []);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels GET]:', err);
        res.status(500).json({ msg: 'Erro ao listar canais.' });
    }
});

// Excluir canal do usu√°rio
app.delete('/api/channels/:id', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        const result = await db.run('DELETE FROM user_channels WHERE id = ? AND user_id = ?', [id, userId]);
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Canal n√£o encontrado ou n√£o pertence a este usu√°rio.' });
        }

        console.log(`[Canais] Canal ${id} exclu√≠do pelo usu√°rio ${userId}`);
        res.status(200).json({ msg: 'Canal exclu√≠do com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao excluir canal.' });
    }
});

// Atualizar status do canal (ativar/desativar)
app.put('/api/channels/:id/status', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const { isActive } = req.body;
    const userId = req.user.id;

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        const result = await db.run(
            'UPDATE user_channels SET is_active = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ? AND user_id = ?',
            [isActive ? 1 : 0, id, userId]
        );
        
        if (result.changes === 0) {
            return res.status(404).json({ msg: 'Canal n√£o encontrado ou n√£o pertence a este usu√°rio.' });
        }

        console.log(`[Canais] Status do canal ${id} atualizado para ${isActive ? 'ativo' : 'inativo'} pelo usu√°rio ${userId}`);
        res.status(200).json({ msg: 'Status do canal atualizado com sucesso.' });
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/:id/status PUT]:', err);
        res.status(500).json({ msg: 'Erro ao atualizar status do canal.' });
    }
});

// Buscar informa√ß√µes do canal a partir da URL
app.post('/api/channels/fetch-info', authenticateToken, async (req, res) => {
    const { channelUrl } = req.body;
    const userId = req.user.id;

    if (!channelUrl) {
        return res.status(400).json({ msg: 'URL do canal √© obrigat√≥ria.' });
    }

    try {
        if (!db) {
            return res.status(503).json({ msg: 'Banco de dados n√£o est√° dispon√≠vel.' });
        }

        const geminiKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'gemini']);
        if (!geminiKeyData) {
            return res.status(400).json({ msg: 'Chave de API do Gemini √© necess√°ria.' });
        }
        const geminiApiKey = decrypt(geminiKeyData.api_key);
        if (!geminiApiKey) {
            return res.status(500).json({ msg: 'Falha ao desencriptar a chave do Gemini.' });
        }

        // Extrair ID do canal da URL
        const match = channelUrl.match(/youtube\.com\/(?:@([\w.-]+)|channel\/([\w-]+)|c\/([\w-]+)|user\/([\w-]+))/);
        if (!match) {
            return res.status(400).json({ msg: 'Formato de URL do canal n√£o suportado.' });
        }

        let ytChannelId;
        const handle = match[1];
        const legacyId = match[2] || match[3] || match[4];

        if (handle) {
            const searchApiUrl = `https://www.googleapis.com/youtube/v3/search?part=id&q=${encodeURIComponent(handle)}&type=channel&maxResults=1&key=${geminiApiKey}`;
            const searchResponse = await fetch(searchApiUrl);
            const searchData = await searchResponse.json();
            if (searchResponse.ok && searchData.items && searchData.items.length > 0) {
                ytChannelId = searchData.items[0].id.channelId;
            }
        } else if (legacyId) {
            ytChannelId = legacyId;
        }

        if (!ytChannelId) {
            return res.status(400).json({ msg: 'N√£o foi poss√≠vel determinar o ID do canal.' });
        }

        // Buscar informa√ß√µes do canal
        const channelUrl_api = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${ytChannelId}&key=${geminiApiKey}`;
        const channelResponse = await fetch(channelUrl_api);
        const channelData = await channelResponse.json();

        if (!channelResponse.ok || !channelData.items || channelData.items.length === 0) {
            return res.status(400).json({ msg: 'Canal n√£o encontrado.' });
        }

        const channel = channelData.items[0];
        const channelName = channel.snippet.title;
        const channelDescription = channel.snippet.description || '';
        const country = channel.snippet.country || 'BR';
        
        // Detectar idioma baseado no pa√≠s ou descri√ß√£o
        let language = 'pt-BR';
        if (country === 'US' || country === 'GB' || country === 'CA' || country === 'AU') {
            language = 'en-US';
        } else if (country === 'ES' || country === 'MX' || country === 'AR' || country === 'CO') {
            language = 'es-ES';
        } else if (country === 'FR') {
            language = 'fr-FR';
        } else if (country === 'DE') {
            language = 'de-DE';
        } else if (country === 'IT') {
            language = 'it-IT';
        } else if (country === 'JP') {
            language = 'ja-JP';
        } else if (country === 'KR') {
            language = 'ko-KR';
        } else if (country === 'CN') {
            language = 'zh-CN';
        }

        // Usar IA para detectar nicho (obrigat√≥rio)
        let niche = '';
        try {
            const nichePrompt = `Analise este canal do YouTube e identifique o nicho principal em uma palavra ou frase curta (m√°ximo 3 palavras). Seja espec√≠fico e preciso.
Nome do Canal: ${channelName}
Descri√ß√£o: ${channelDescription.substring(0, 500)}

IMPORTANTE: Responda APENAS com o nicho, sem explica√ß√µes adicionais, sem pontos, sem aspas, sem nada al√©m do nicho.
Exemplos v√°lidos: Tecnologia, Educa√ß√£o Financeira, Gaming, Culin√°ria, Fitness, Entretenimento, Hist√≥ria, Ci√™ncia, Viagens.

Nicho identificado:`;
            
            console.log('[Canais] Detectando nicho do canal:', channelName);
            const nicheResponse = await callGeminiAPI(nichePrompt, geminiApiKey, 'gemini-2.0-flash-exp');
            if (nicheResponse && nicheResponse.titles) {
                niche = nicheResponse.titles.trim()
                    .split('\n')[0]
                    .replace(/^["']|["']$/g, '') // Remove aspas
                    .replace(/^\.+/, '') // Remove pontos no in√≠cio
                    .substring(0, 50)
                    .trim();
                console.log('[Canais] Nicho detectado:', niche);
            }
            if (!niche || niche.length < 2) {
                console.warn('[Canais] Nicho n√£o detectado ou muito curto, usando fallback');
                // Fallback: usar primeira palavra da descri√ß√£o ou nome do canal
                niche = channelDescription.split(' ').slice(0, 2).join(' ').substring(0, 30) || channelName.split(' ').slice(0, 2).join(' ').substring(0, 30) || 'Entretenimento';
            }
        } catch (nicheErr) {
            console.warn('[Canais] Erro ao detectar nicho:', nicheErr.message);
            // Fallback: usar primeira palavra do nome do canal
            niche = channelName.split(' ').slice(0, 2).join(' ').substring(0, 30) || 'Entretenimento';
        }

        // Garantir que sempre h√° um nicho
        if (!niche || niche.length < 2) {
            niche = 'Entretenimento';
        }

        const responseData = {
            channelName,
            channelId: ytChannelId,
            niche: niche,
            language,
            country
        };
        
        console.log('[Canais] Retornando dados do canal:', responseData);
        res.status(200).json(responseData);
    } catch (err) {
        console.error('[ERRO NA ROTA /api/channels/fetch-info]:', err);
        res.status(500).json({ msg: 'Erro ao buscar informa√ß√µes do canal.' });
    }
});

// === ANIMA√á√ÉO PARALLAX ===
app.post('/api/animate/parallax', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { base64, imageUrl, sceneNumber, duration = 5 } = req.body || {};
    try {
        let imgBuffer;
        if (base64 && typeof base64 === 'string') {
            const commaIdx = base64.indexOf(',');
            const raw = commaIdx >= 0 ? base64.slice(commaIdx + 1) : base64;
            imgBuffer = Buffer.from(raw, 'base64');
        } else if (imageUrl) {
            const resp = await fetch(imageUrl);
            if (!resp.ok) throw new Error('Falha ao baixar imagem');
            imgBuffer = Buffer.from(await resp.arrayBuffer());
        } else {
            return res.status(400).json({ msg: 'Envie base64 ou imageUrl para animar.' });
        }
        const tmpDir = TEMP_DIR || path.join(process.cwd(), 'temp_audio');
        const imgPath = path.join(tmpDir, `parallax_${Date.now()}.png`);
        const outPath = path.join(tmpDir, `parallax_${Date.now()}.mp4`);
        fs.writeFileSync(imgPath, imgBuffer);
        const py = (() => {
            try { execSync('python3 --version', { stdio: 'ignore' }); return 'python3'; } catch {}
            try { execSync('python --version', { stdio: 'ignore' }); return 'python'; } catch {}
            return 'python3';
        })();
        
        // Escapar caminhos corretamente para Windows (caminhos com espa√ßos)
        const scriptPath = path.join(__dirname, 'animator_depth.py');
        // No Windows, usar aspas duplas e escapar corretamente
        const escapePath = (p) => {
            // Normalizar caminho e adicionar aspas se necess√°rio
            const normalized = path.normalize(p);
            // Se cont√©m espa√ßos, adicionar aspas e escapar aspas internas
            if (normalized.includes(' ')) {
                return `"${normalized.replace(/"/g, '\\"')}"`;
            }
            return normalized;
        };
        
        const cmd = `${py} ${escapePath(scriptPath)} --input ${escapePath(imgPath)} --output ${escapePath(outPath)} --duration ${duration}`;
        const { stdout, stderr } = await execAsync(cmd, { maxBuffer: 1024 * 1024 * 50 });
        const videoB64 = fs.readFileSync(outPath).toString('base64');
        try { fs.unlinkSync(imgPath); fs.unlinkSync(outPath); } catch {}
        return res.json({ success: true, sceneNumber: sceneNumber || null, videoBase64: `data:video/mp4;base64,${videoB64}` });
    } catch (err) {
        console.error('[Parallax] Erro:', err.message);
        return res.status(500).json({ msg: `Falha parallax: ${err.message}` });
    }
});

// Rotas do Meta.ai e HuMo removidas - usando apenas Parallax

// ============================================
// INICIAR SERVIDOR (DEPOIS DE TODAS AS ROTAS)
// ============================================
// Vari√°vel para garantir que o servidor s√≥ inicie UMA vez (prote√ß√£o contra race condition)
let serverStarted = false;

// Fun√ß√£o √∫nica para iniciar o servidor (garante que s√≥ inicie uma vez)
function startServer() {
    // Verifica√ß√£o dupla: flag + app.listening para garantir que n√£o inicie duas vezes
    if (serverStarted) {
        return;
    }
    
    // Marcar como iniciado ANTES de tentar iniciar (previne race condition)
    serverStarted = true;
    
    // Iniciar servidor
    try {
        const server = app.listen(PORT, () => {
            console.log(`üöÄ Servidor "La Casa Dark Core" a rodar na porta ${PORT}`);
            if (!db) {
                console.log(`‚ö†Ô∏è  Banco de dados ainda n√£o est√° pronto. Algumas funcionalidades podem n√£o estar dispon√≠veis.`);
            } else {
                console.log(`‚úÖ Todas as rotas registradas e funcionando!`);
            }
            
            // Restaurar loops ativos em background (n√£o bloqueia o servidor)
            // Verifica se o banco est√° pronto antes de executar
            const checkAndRestore = () => {
                if (global.dbReady && db) {
                    restoreActiveLoops().catch(err => {
                        console.error('[NOTIFICATIONS] Erro ao restaurar loops (n√£o cr√≠tico):', err.message);
                    });
                } else {
                    // Tentar novamente ap√≥s 1 segundo se o banco ainda n√£o estiver pronto
                    setTimeout(checkAndRestore, 1000);
                }
            };
            setTimeout(checkAndRestore, 500); // Iniciar verifica√ß√£o ap√≥s 500ms
        });
        
        // Tratamento de erro para porta em uso
        server.on('error', (err) => {
            if (err.code === 'EADDRINUSE') {
                console.error(`‚ùå Erro: A porta ${PORT} j√° est√° em uso.`);
                console.error(`   Por favor, encerre o processo que est√° usando a porta ${PORT} e tente novamente.`);
                console.error(`   Comando: netstat -ano | findstr :${PORT}`);
            } else {
                console.error('‚ùå Erro ao iniciar servidor:', err.message);
            }
            // Resetar flag em caso de erro para permitir nova tentativa
            serverStarted = false;
        });
    } catch (err) {
        console.error('‚ùå Erro ao iniciar servidor:', err.message);
        serverStarted = false;
    }
}

// === SERVI√áO DE TRADU√á√ÉO ONLINE (Gratuito) ===

/**
 * Traduz texto usando m√∫ltiplas APIs gratuitas com fallback
 * Ordem de prioridade:
 * 1. MyMemory Translation API (gratuito, 500 requisi√ß√µes/dia)
 * 2. LibreTranslate (open-source, sem limite se self-hosted)
 * 3. Google Translate via scraping (fallback)
 */
async function translateText(text, fromLang = 'auto', toLang = 'pt') {
    if (!text || text.trim().length === 0) {
        return text;
    }

    // M√âTODO 1: MyMemory Translation API (GRATUITO - 500 req/dia)
    try {
        console.log(`[Tradu√ß√£o] Tentando MyMemory API: ${fromLang} ‚Üí ${toLang}`);
        const mymemoryUrl = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${fromLang}|${toLang}`;
        const response = await fetch(mymemoryUrl);
        const data = await response.json();
        
        if (response.ok && data.responseData && data.responseData.translatedText) {
            console.log(`[Tradu√ß√£o] ‚úÖ Sucesso com MyMemory API`);
            return data.responseData.translatedText;
        }
    } catch (err) {
        console.warn(`[Tradu√ß√£o] MyMemory falhou:`, err.message);
    }

    // M√âTODO 2: LibreTranslate API (GRATUITO - public instance)
    try {
        console.log(`[Tradu√ß√£o] Tentando LibreTranslate API`);
        const libreTranslateUrl = 'https://libretranslate.de/translate';
        const response = await fetch(libreTranslateUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                q: text,
                source: fromLang === 'auto' ? 'en' : fromLang,
                target: toLang,
                format: 'text'
            })
        });
        const data = await response.json();
        
        if (response.ok && data.translatedText) {
            console.log(`[Tradu√ß√£o] ‚úÖ Sucesso com LibreTranslate API`);
            return data.translatedText;
        }
    } catch (err) {
        console.warn(`[Tradu√ß√£o] LibreTranslate falhou:`, err.message);
    }

    // M√âTODO 3: Usar Gemini AI como fallback (se dispon√≠vel)
    try {
        console.log(`[Tradu√ß√£o] Tentando fallback com IA interna`);
        // Se o usu√°rio tiver Gemini configurado, podemos usar para tradu√ß√£o
        return text; // Por enquanto retorna o original se todos falharem
    } catch (err) {
        console.warn(`[Tradu√ß√£o] Todos os m√©todos falharam`);
    }

    return text; // Retorna texto original se todas as tradu√ß√µes falharem
}

// Vari√°vel para armazenar os intervalos de notifica√ß√µes
const notificationLoops = {
    purchase: null,
    user: null
};

// Fun√ß√£o para iniciar um loop de notifica√ß√µes
async function startNotificationLoop(loopType, intervalSeconds) {
    // Parar loop existente se houver
    if (notificationLoops[loopType]) {
        clearInterval(notificationLoops[loopType]);
        notificationLoops[loopType] = null;
    }
    
    console.log(`[NOTIFICATIONS] Iniciando loop ${loopType} com intervalo de ${intervalSeconds} segundos`);
    
    // Executar imediatamente na primeira vez
    await processNotificationLoop(loopType);
    
    // Configurar intervalo
    notificationLoops[loopType] = setInterval(async () => {
        await processNotificationLoop(loopType);
    }, intervalSeconds * 1000);
}

// Fun√ß√£o para processar um loop de notifica√ß√µes
async function processNotificationLoop(loopType) {
    try {
        // Verificar se o loop ainda est√° ativo
        const loopStatus = await db.get('SELECT is_active FROM active_loops WHERE loop_type = ?', [loopType]);
        if (!loopStatus || loopStatus.is_active !== 1) {
            console.log(`[NOTIFICATIONS] Loop ${loopType} n√£o est√° mais ativo, parando...`);
            if (notificationLoops[loopType]) {
                clearInterval(notificationLoops[loopType]);
                notificationLoops[loopType] = null;
            }
            return;
        }
        
        // Obter configura√ß√µes
        const configs = await db.all('SELECT key, value FROM notification_config');
        const config = {};
        configs.forEach(c => { config[c.key] = c.value; });
        
        const enabled = config[`${loopType}_enabled`] === 'true';
        if (!enabled) {
            return; // Loop desabilitado
        }
        
        const interval = parseInt(config[`${loopType}_interval`]) || 5;
        const message = config[`${loopType}_message`] || '';
        
        // Buscar usu√°rios fict√≠cios ativos do tipo correto
        const fakeUsers = await db.all(
            'SELECT * FROM fake_users WHERE type = ? AND is_active = 1 ORDER BY RANDOM() LIMIT 1',
            [loopType]
        );
        
        if (fakeUsers.length === 0) {
            console.log(`[NOTIFICATIONS] Nenhum usu√°rio fict√≠cio ${loopType} dispon√≠vel`);
            return;
        }
        
        const fakeUser = fakeUsers[0];
        
        // Criar mensagem personalizada
        let notificationMessage = message;
        notificationMessage = notificationMessage.replace(/{name}/g, fakeUser.name);
        if (loopType === 'purchase' && fakeUser.plan_name) {
            notificationMessage = notificationMessage.replace(/{plan}/g, fakeUser.plan_name);
        }
        
        // Criar notifica√ß√£o global (user_id = null para todos verem)
        await db.run(
            'INSERT INTO notifications (user_id, title, message, type, is_read, created_at) VALUES (?, ?, ?, ?, 0, CURRENT_TIMESTAMP)',
            [null, loopType === 'purchase' ? 'Nova Compra' : 'Novo Usu√°rio', notificationMessage, loopType]
        );
        
        console.log(`[NOTIFICATIONS] Notifica√ß√£o ${loopType} criada: ${notificationMessage}`);
    } catch (error) {
        console.error(`[NOTIFICATIONS] Erro ao processar loop ${loopType}:`, error);
    }
}

// --- FUN√á√ïES AUXILIARES PARA AN√ÅLISE DE CANAIS VIRAIS ---

// Buscar informa√ß√µes do canal
async function getChannelInfo(channelIdOrHandle, apiKey) {
    try {
        // Limpar handle (remover @ se presente)
        let identifier = channelIdOrHandle.trim();
        if (identifier.startsWith('@')) {
            identifier = identifier.substring(1);
        }
        
        // Tentar buscar por channelId primeiro (se parece com ID)
        if (identifier.length === 24 && identifier.startsWith('UC')) {
            let url = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics,contentDetails&id=${identifier}&key=${apiKey}`;
            let response = await fetch(url);
            let data = await response.json();
            
            if (response.ok && data.items && data.items.length > 0) {
                const channel = data.items[0];
                const publishedAt = new Date(channel.snippet.publishedAt);
                const daysSinceCreation = Math.round((new Date() - publishedAt) / (1000 * 60 * 60 * 24));
                const monthsSinceCreation = Math.round(daysSinceCreation / 30);
                const yearsSinceCreation = (daysSinceCreation / 365).toFixed(1);
                
                return {
                    channelId: channel.id,
                    channelName: channel.snippet.title,
                    channelHandle: channel.snippet.customUrl || identifier,
                    subscriberCount: parseInt(channel.statistics.subscriberCount || 0),
                    videoCount: parseInt(channel.statistics.videoCount || 0),
                    viewCount: parseInt(channel.statistics.viewCount || 0),
                    description: channel.snippet.description || '',
                    thumbnail: channel.snippet.thumbnails.high?.url || channel.snippet.thumbnails.default?.url || '',
                    publishedAt: channel.snippet.publishedAt,
                    daysSinceCreation: daysSinceCreation,
                    monthsSinceCreation: monthsSinceCreation,
                    yearsSinceCreation: parseFloat(yearsSinceCreation)
                };
            }
        }
        
        // Tentar buscar por handle usando search
        const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(identifier)}&type=channel&maxResults=1&key=${apiKey}`;
        const searchResponse = await fetch(searchUrl);
        const searchData = await searchResponse.json();
        
        if (searchResponse.ok && searchData.items && searchData.items.length > 0) {
            const channelId = searchData.items[0].id.channelId;
            
            // Buscar detalhes completos
            const detailsUrl = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics,contentDetails&id=${channelId}&key=${apiKey}`;
            const detailsResponse = await fetch(detailsUrl);
            const detailsData = await detailsResponse.json();
            
            if (detailsResponse.ok && detailsData.items && detailsData.items.length > 0) {
                const channel = detailsData.items[0];
                const publishedAt = new Date(channel.snippet.publishedAt);
                const daysSinceCreation = Math.round((new Date() - publishedAt) / (1000 * 60 * 60 * 24));
                const monthsSinceCreation = Math.round(daysSinceCreation / 30);
                const yearsSinceCreation = (daysSinceCreation / 365).toFixed(1);
                
                return {
                    channelId: channel.id,
                    channelName: channel.snippet.title,
                    channelHandle: channel.snippet.customUrl || identifier,
                    subscriberCount: parseInt(channel.statistics.subscriberCount || 0),
                    videoCount: parseInt(channel.statistics.videoCount || 0),
                    viewCount: parseInt(channel.statistics.viewCount || 0),
                    description: channel.snippet.description || '',
                    thumbnail: channel.snippet.thumbnails.high?.url || channel.snippet.thumbnails.default?.url || '',
                    publishedAt: channel.snippet.publishedAt,
                    daysSinceCreation: daysSinceCreation,
                    monthsSinceCreation: monthsSinceCreation,
                    yearsSinceCreation: parseFloat(yearsSinceCreation)
                };
            }
        }
        
        throw new Error('Canal n√£o encontrado. Verifique a URL ou handle do canal.');
    } catch (err) {
        console.error('[getChannelInfo] Erro:', err);
        throw new Error(`Erro ao buscar informa√ß√µes do canal: ${err.message}`);
    }
}

// Buscar v√≠deos mais vistos do canal
async function getChannelTopVideos(channelId, apiKey, maxResults = 20) {
    try {
        // Buscar v√≠deos ordenados por viewCount
        const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${channelId}&order=viewCount&type=video&maxResults=${maxResults}&key=${apiKey}`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (!response.ok) {
            throw new Error(data.error?.message || 'Erro ao buscar v√≠deos');
        }
        
        if (!data.items || data.items.length === 0) {
            return [];
        }
        
        const videoIds = data.items.map(item => item.id.videoId).join(',');
        
        // Buscar estat√≠sticas detalhadas
        const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics,contentDetails&id=${videoIds}&key=${apiKey}`;
        const detailsResponse = await fetch(detailsUrl);
        const detailsData = await detailsResponse.json();
        
        if (!detailsResponse.ok || !detailsData.items) {
            throw new Error('Erro ao buscar detalhes dos v√≠deos');
        }
        
        return detailsData.items.map(item => {
            const publishedAt = new Date(item.snippet.publishedAt);
            const daysAgo = Math.round((new Date() - publishedAt) / (1000 * 60 * 60 * 24));
            
            return {
                videoId: item.id,
                title: item.snippet.title,
                description: item.snippet.description || '',
                thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default?.url || '',
                publishedAt: item.snippet.publishedAt,
                viewCount: parseInt(item.statistics.viewCount || 0),
                likeCount: parseInt(item.statistics.likeCount || 0),
                commentCount: parseInt(item.statistics.commentCount || 0),
                duration: item.contentDetails.duration,
                tags: item.snippet.tags || [],
                categoryId: item.snippet.categoryId,
                daysAgo: daysAgo,
                viralScore: calculateViralScore(
                    parseInt(item.statistics.viewCount || 0),
                    parseInt(item.statistics.likeCount || 0),
                    parseInt(item.statistics.commentCount || 0),
                    daysAgo
                )
            };
        }).sort((a, b) => b.viralScore - a.viralScore);
    } catch (err) {
        console.error('[getChannelTopVideos] Erro:', err);
        throw new Error(`Erro ao buscar v√≠deos mais vistos: ${err.message}`);
    }
}

// Calcular score viral
function calculateViralScore(views, likes, comments, daysAgo) {
    if (daysAgo === 0) daysAgo = 1;
    const viewsPerDay = views / daysAgo;
    const engagementRate = ((likes + comments) / views) * 100;
    return (viewsPerDay * 0.6) + (engagementRate * 1000 * 0.4);
}

// Buscar coment√°rios de um v√≠deo
async function getVideoComments(videoId, apiKey, maxResults = 100) {
    try {
        const url = `https://www.googleapis.com/youtube/v3/commentThreads?part=snippet&videoId=${videoId}&maxResults=${maxResults}&order=relevance&key=${apiKey}`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (!response.ok) {
            throw new Error(data.error?.message || 'Erro ao buscar coment√°rios');
        }
        
        if (!data.items || data.items.length === 0) {
            return [];
        }
        
        return data.items.map(item => {
            const comment = item.snippet.topLevelComment.snippet;
            return {
                commentId: item.snippet.topLevelComment.id,
                authorName: comment.authorDisplayName,
                authorChannelId: comment.authorChannelId?.value || null,
                text: comment.textDisplay,
                likeCount: parseInt(comment.likeCount || 0),
                publishedAt: comment.publishedAt,
                updatedAt: comment.updatedAt
            };
        });
    } catch (err) {
        console.error('[getVideoComments] Erro:', err);
        // Se n√£o houver coment√°rios ou erro, retornar array vazio
        return [];
    }
}

// Analisar insights virais com IA
async function analyzeViralInsights(channelData, videos, comments, apiKey, service, modelToUse) {
    try {
        const topVideos = videos.slice(0, 10);
        const topComments = comments.slice(0, 50);
        
        // Identificar o v√≠deo mais viral para an√°lise detalhada
        const mostViralVideo = topVideos.reduce((max, v) => {
            const maxViews = max.viewCount || 0;
            const vViews = v.viewCount || 0;
            return vViews > maxViews ? v : max;
        }, topVideos[0]);
        
        const mostViralDaysAgo = mostViralVideo.daysAgo || (mostViralVideo.publishedAt ? Math.round((new Date() - new Date(mostViralVideo.publishedAt)) / (1000 * 60 * 60 * 24)) : 0);
        
        const analysisPrompt = `Voc√™ √© um ESPECIALISTA EM AN√ÅLISE DE CANAIS VIRAIS DO YOUTUBE.

GPT, preciso da sua ajuda para analisar um canal de sucesso no YouTube e usar essa an√°lise como base para a cria√ß√£o do meu pr√≥prio canal dentro do mesmo nicho.

DADOS DO CANAL:
- Nome: ${channelData.channelName}
- Inscritos: ${channelData.subscriberCount.toLocaleString()}
- Total de v√≠deos: ${channelData.videoCount}
- Total de visualiza√ß√µes: ${channelData.viewCount.toLocaleString()}

LISTA COMPLETA DOS V√çDEOS PUBLICADOS (TOP 10 MAIS VISTOS):
${topVideos.map((v, i) => {
    const daysAgo = v.daysAgo || (v.publishedAt ? Math.round((new Date() - new Date(v.publishedAt)) / (1000 * 60 * 60 * 24)) : 0);
    const viralScore = v.viralScore || 0;
    return `
${i + 1}. "${v.title}"
   - Visualiza√ß√µes: ${(v.viewCount || 0).toLocaleString()}
   - Likes: ${(v.likeCount || 0).toLocaleString()}
   - Coment√°rios: ${(v.commentCount || 0).toLocaleString()}
   - Publicado h√°: ${daysAgo} dias
   - Score Viral: ${viralScore.toFixed(2)}
   - Thumbnail URL: ${v.thumbnail || 'N/A'}
`;
}).join('\n')}

V√çDEO MAIS VIRAL DO CANAL:
"${mostViralVideo.title}"
- Visualiza√ß√µes: ${(mostViralVideo.viewCount || 0).toLocaleString()}
- Pegou ${(mostViralVideo.viewCount || 0).toLocaleString()} views em ${mostViralDaysAgo} dias
- Likes: ${(mostViralVideo.likeCount || 0).toLocaleString()}
- Coment√°rios: ${(mostViralVideo.commentCount || 0).toLocaleString()}
- Thumbnail: ${mostViralVideo.thumbnail || 'N/A'}

COMENT√ÅRIOS MAIS RELEVANTES (especialmente dos v√≠deos que performaram melhor):
${topComments.map((c, i) => `
${i + 1}. "${c.text.substring(0, 200)}" - ${c.authorName} (${c.likeCount} likes)
`).join('\n')}

AN√ÅLISE PROFUNDA REQUERIDA:

1. IDENTIFICA√á√ÉO DO NICHO E SUBNICHO:
   - Qual √© o nicho exato desse canal?
   - Qual √© o subnicho (se houver)?
   - H√° subnichos pouco explorados dentro deste nicho que tenham alto volume de buscas e baixa competi√ß√£o?

2. DIFERENCIAIS DE SUCESSO:
   - Quais s√£o os principais diferenciais que tornam esse canal bem-sucedido?
   - O que faz este canal se destacar da concorr√™ncia?

3. P√öBLICO-ALVO:
   - Perfil demogr√°fico (idade, g√™nero, localiza√ß√£o)
   - Interesses espec√≠ficos
   - Comportamento e padr√µes de consumo de conte√∫do

4. PADR√ïES NOS T√çTULOS (AN√ÅLISE DETALHADA):
   - Estrutura comum dos t√≠tulos virais
   - Palavras-chave recorrentes que geram mais views
   - T√©cnicas de hook mais eficazes
   - Comprimento m√©dio ideal
   - Para o v√≠deo mais viral com t√≠tulo "${mostViralVideo.title}", identifique:
     * Por que este t√≠tulo espec√≠fico viralizou?
     * Quais elementos do t√≠tulo s√£o respons√°veis pelo sucesso?
     * Varia√ß√µes deste t√≠tulo que poderiam funcionar igualmente bem

5. AN√ÅLISE DE THUMBNAILS:
   - Para o v√≠deo mais viral com thumbnail "${mostViralVideo.thumbnail || 'N/A'}" e t√≠tulo "${mostViralVideo.title}":
     * Quais elementos visuais da thumbnail contribu√≠ram para o viral?
     * Como a thumbnail complementa o t√≠tulo?
     * Padr√µes visuais que se repetem nas thumbnails dos v√≠deos virais

6. ESTRAT√âGIAS DE ENGAGEMENT:
   - O que gera mais coment√°rios? (identifique nos coment√°rios fornecidos)
   - O que gera mais likes?
   - Timing de publica√ß√£o mais eficaz
   - H√° algo nos coment√°rios que revele desejos ou insatisfa√ß√µes da audi√™ncia que possam ser usados como oportunidade?

7. INSIGHTS VIRAIS:
   - Por que esses v√≠deos viralizaram? (an√°lise profunda)
   - Elementos comuns nos v√≠deos virais
   - Diferen√ßas entre v√≠deos virais e n√£o virais
   - Padr√µes ou formatos que se repetem nos v√≠deos de maior sucesso

8. OPORTUNIDADES ESTRAT√âGICAS:
   - Oportunidades para criar um canal similar com diferenciais competitivos
   - Subnichos dentro deste nicho que est√£o pouco explorados mas com alta demanda
   - Gaps de conte√∫do identificados nos coment√°rios

9. RECOMENDA√á√ïES PR√ÅTICAS:
   - Como estruturar o conte√∫do de um novo canal
   - Linha editorial recomendada
   - Sugest√µes de temas iniciais
   - Estrat√©gias de conte√∫do mais eficazes (tipo de v√≠deo, frequ√™ncia, estilo de narrativa)

RESPONDA EM FORMATO JSON:
{
  "niche_analysis": {
    "exact_niche": "descri√ß√£o do nicho exato",
    "subniche": "subnicho identificado",
    "unexplored_subniches": ["subnicho 1 com alta demanda", "subnicho 2 com alta demanda"],
    "competition_level": "baixa/m√©dia/alta"
  },
  "differentiators": {
    "main_differentiators": ["diferencial 1", "diferencial 2", ...],
    "success_factors": ["fator 1", "fator 2", ...]
  },
  "target_audience": {
    "demographic": "perfil demogr√°fico",
    "interests": ["interesse 1", "interesse 2", ...],
    "behavior": "comportamento identificado"
  },
  "title_patterns": {
    "structure": "descri√ß√£o detalhada da estrutura comum",
    "keywords": ["palavra-chave 1", "palavra-chave 2", ...],
    "hook_techniques": ["t√©cnica 1", "t√©cnica 2", ...],
    "avg_length": n√∫mero,
    "viral_title_analysis": {
      "title": "${mostViralVideo.title}",
      "why_viral": "an√°lise detalhada de por que este t√≠tulo viralizou",
      "key_elements": ["elemento 1", "elemento 2", ...],
      "variations": ["varia√ß√£o 1", "varia√ß√£o 2", "varia√ß√£o 3", ...]
    }
  },
  "thumbnail_analysis": {
    "viral_thumbnail_url": "${mostViralVideo.thumbnail || 'N/A'}",
    "viral_title": "${mostViralVideo.title}",
    "visual_elements": ["elemento visual 1", "elemento visual 2", ...],
    "thumbnail_title_synergy": "como thumbnail e t√≠tulo trabalham juntos",
    "recurring_patterns": ["padr√£o 1", "padr√£o 2", ...]
  },
  "engagement_strategies": {
    "comment_triggers": ["elemento 1", "elemento 2", ...],
    "like_triggers": ["elemento 1", "elemento 2", ...],
    "best_posting_times": "an√°lise de timing",
    "audience_desires": ["desejo 1 identificado nos coment√°rios", "desejo 2", ...],
    "audience_pain_points": ["ponto de dor 1", "ponto de dor 2", ...]
  },
  "viral_insights": {
    "why_viral": "an√°lise detalhada e profunda",
    "common_elements": ["elemento 1", "elemento 2", ...],
    "differences": "diferen√ßas entre v√≠deos virais e n√£o virais",
    "recurring_formats": ["formato 1", "formato 2", ...]
  },
  "opportunities": {
    "competitive_differentiators": ["oportunidade 1", "oportunidade 2", ...],
    "unexplored_subniches": ["subnicho 1", "subnicho 2", ...],
    "content_gaps": ["gap 1", "gap 2", ...]
  },
  "recommendations": {
    "content_structure": "como estruturar conte√∫do",
    "editorial_line": "linha editorial recomendada",
    "initial_themes": ["tema 1", "tema 2", ...],
    "replication_strategy": "estrat√©gia detalhada de replica√ß√£o",
    "suggested_titles": ["t√≠tulo 1 baseado nos padr√µes", "t√≠tulo 2", ...],
    "content_strategies": ["estrat√©gia 1", "estrat√©gia 2", ...],
    "video_types": "tipos de v√≠deo mais eficazes",
    "publishing_frequency": "frequ√™ncia recomendada",
    "narrative_style": "estilo de narrativa"
  }
}`;

        let analysisResponse;
        if (service === 'claude') {
            analysisResponse = await callClaudeAPI(analysisPrompt, apiKey, modelToUse);
        } else if (service === 'openai') {
            analysisResponse = await callOpenAIAPI(analysisPrompt, apiKey, modelToUse);
        } else {
            analysisResponse = await callGeminiAPI(analysisPrompt, apiKey, modelToUse);
        }
        
        const analysisText = typeof analysisResponse === 'string' ? analysisResponse : JSON.stringify(analysisResponse);
        console.log('[analyzeViralInsights] Resposta da IA (primeiros 1000 chars):', analysisText.substring(0, 1000));
        
        let parsed;
        try {
            parsed = parseAIResponse(analysisText, service);
            console.log('[analyzeViralInsights] Parseado com sucesso. Tipo:', typeof parsed);
            console.log('[analyzeViralInsights] Estrutura parseada:', {
                hasTitlePatterns: !!parsed?.title_patterns,
                hasEngagement: !!parsed?.engagement_strategies,
                hasViralInsights: !!parsed?.viral_insights,
                hasRecommendations: !!parsed?.recommendations
            });
        } catch (parseErr) {
            console.error('[analyzeViralInsights] Erro ao parsear resposta da IA:', parseErr);
            console.error('[analyzeViralInsights] Texto que causou erro:', analysisText.substring(0, 500));
            parsed = {};
        }
        
        // Garantir que sempre retorna estrutura v√°lida
        if (!parsed || typeof parsed !== 'object') {
            console.warn('[analyzeViralInsights] Parse retornou valor inv√°lido, usando objeto vazio');
            parsed = {};
        }
        
        // Garantir que todas as se√ß√µes existem
        if (!parsed.niche_analysis || typeof parsed.niche_analysis !== 'object') {
            parsed.niche_analysis = {
                exact_niche: 'N√£o identificado',
                subniche: 'N√£o identificado',
                unexplored_subniches: [],
                competition_level: 'N√£o identificado'
            };
        }
        
        if (!parsed.differentiators || typeof parsed.differentiators !== 'object') {
            parsed.differentiators = {
                main_differentiators: [],
                success_factors: []
            };
        }
        
        if (!parsed.target_audience || typeof parsed.target_audience !== 'object') {
            parsed.target_audience = {
                demographic: 'N√£o identificado',
                interests: [],
                behavior: 'N√£o identificado'
            };
        }
        
        if (!parsed.title_patterns || typeof parsed.title_patterns !== 'object') {
            parsed.title_patterns = {
                structure: 'Estrutura n√£o identificada',
                keywords: [],
                hook_techniques: [],
                avg_length: 0,
                viral_title_analysis: {
                    title: '',
                    why_viral: 'An√°lise n√£o dispon√≠vel',
                    key_elements: [],
                    variations: []
                }
            };
        }
        
        if (!parsed.thumbnail_analysis || typeof parsed.thumbnail_analysis !== 'object') {
            parsed.thumbnail_analysis = {
                viral_thumbnail_url: '',
                viral_title: '',
                visual_elements: [],
                thumbnail_title_synergy: 'An√°lise n√£o dispon√≠vel',
                recurring_patterns: []
            };
        }
        
        if (!parsed.engagement_strategies || typeof parsed.engagement_strategies !== 'object') {
            parsed.engagement_strategies = {
                comment_triggers: [],
                like_triggers: [],
                best_posting_times: 'N√£o identificado',
                audience_desires: [],
                audience_pain_points: []
            };
        }
        
        if (!parsed.viral_insights || typeof parsed.viral_insights !== 'object') {
            parsed.viral_insights = {
                why_viral: 'An√°lise n√£o dispon√≠vel',
                common_elements: [],
                differences: 'N√£o identificado',
                recurring_formats: []
            };
        }
        
        if (!parsed.opportunities || typeof parsed.opportunities !== 'object') {
            parsed.opportunities = {
                competitive_differentiators: [],
                unexplored_subniches: [],
                content_gaps: []
            };
        }
        
        if (!parsed.recommendations || typeof parsed.recommendations !== 'object') {
            parsed.recommendations = {
                content_structure: 'Estrutura n√£o identificada',
                editorial_line: 'Linha editorial n√£o identificada',
                initial_themes: [],
                replication_strategy: 'Estrat√©gia n√£o identificada',
                suggested_titles: [],
                content_strategies: [],
                video_types: 'N√£o identificado',
                publishing_frequency: 'N√£o identificado',
                narrative_style: 'N√£o identificado'
            };
        }
        
        return parsed;
    } catch (err) {
        console.error('[analyzeViralInsights] Erro:', err);
        // Retornar estrutura padr√£o em vez de lan√ßar erro
        return {
            niche_analysis: {
                exact_niche: 'N√£o identificado',
                subniche: 'N√£o identificado',
                unexplored_subniches: [],
                competition_level: 'N√£o identificado'
            },
            differentiators: {
                main_differentiators: [],
                success_factors: []
            },
            target_audience: {
                demographic: 'N√£o identificado',
                interests: [],
                behavior: 'N√£o identificado'
            },
            title_patterns: {
                structure: 'Estrutura n√£o identificada',
                keywords: [],
                hook_techniques: [],
                avg_length: 0,
                viral_title_analysis: {
                    title: '',
                    why_viral: 'An√°lise n√£o dispon√≠vel',
                    key_elements: [],
                    variations: []
                }
            },
            thumbnail_analysis: {
                viral_thumbnail_url: '',
                viral_title: '',
                visual_elements: [],
                thumbnail_title_synergy: 'An√°lise n√£o dispon√≠vel',
                recurring_patterns: []
            },
            engagement_strategies: {
                comment_triggers: [],
                like_triggers: [],
                best_posting_times: 'N√£o identificado',
                audience_desires: [],
                audience_pain_points: []
            },
            viral_insights: {
                why_viral: 'An√°lise n√£o dispon√≠vel',
                common_elements: [],
                differences: 'N√£o identificado',
                recurring_formats: []
            },
            opportunities: {
                competitive_differentiators: [],
                unexplored_subniches: [],
                content_gaps: []
            },
            recommendations: {
                content_structure: 'Estrutura n√£o identificada',
                editorial_line: 'Linha editorial n√£o identificada',
                initial_themes: [],
                replication_strategy: 'Estrat√©gia n√£o identificada',
                suggested_titles: [],
                content_strategies: [],
                video_types: 'N√£o identificado',
                publishing_frequency: 'N√£o identificado',
                narrative_style: 'N√£o identificado'
            }
        };
    }
}

// Analisar insights para novo canal baseado em an√°lises cruzadas
async function analyzeNewChannelInsights(currentInsights, otherChannelsInsights, channelInfo, apiKey, service, modelToUse) {
    try {
        const prompt = `Voc√™ √© um ESPECIALISTA EM CRIA√á√ÉO DE CANAIS VIRAIS NO YOUTUBE.

Com base na an√°lise de m√∫ltiplos canais virais do mesmo nicho, forne√ßa insights espec√≠ficos para CRIAR UM NOVO CANAL que replique o sucesso.

AN√ÅLISE ATUAL DO CANAL: ${channelInfo.channelName}
- Idade do canal: ${channelInfo.yearsSinceCreation || 0} anos
- Inscritos: ${channelInfo.subscriberCount.toLocaleString()}
- Total de v√≠deos: ${channelInfo.videoCount}
- Total de visualiza√ß√µes: ${channelInfo.viewCount.toLocaleString()}

INSIGHTS DO CANAL ATUAL:
${JSON.stringify(currentInsights, null, 2)}

INSIGHTS DE OUTROS CANAIS VIRAIS DO MESMO NICHO:
${otherChannelsInsights.map((oc, i) => `
Canal ${i + 1}: ${oc.channelName}
${JSON.stringify(oc.insights, null, 2)}
`).join('\n---\n')}

ANALISE E FORNE√áA INSIGHTS ESPEC√çFICOS PARA CRIAR UM NOVO CANAL:

1. PADR√ïES CRUZADOS:
   - Quais elementos s√£o comuns em TODOS os canais virais analisados?
   - Quais diferen√ßas estrat√©gicas existem entre os canais?
   - O que funciona melhor para este nicho?

2. ESTRAT√âGIA PARA NOVO CANAL:
   - Como posicionar o novo canal para competir?
   - Quais elementos replicar e quais evitar?
   - Timing ideal para lan√ßamento

3. T√çTULOS OTIMIZADOS:
   - 10 t√≠tulos sugeridos baseados nos padr√µes virais identificados
   - Estrutura ideal para este nicho
   - Palavras-chave essenciais

4. ROADMAP DE CONTE√öDO:
   - Primeiros 10 v√≠deos sugeridos
   - Ordem de publica√ß√£o recomendada
   - Estrat√©gia de crescimento inicial

RESPONDA EM FORMATO JSON:
{
  "cross_patterns": {
    "common_elements": ["elemento1", "elemento2", ...],
    "key_differences": "an√°lise das diferen√ßas",
    "best_practices": ["pr√°tica1", "pr√°tica2", ...]
  },
  "new_channel_strategy": {
    "positioning": "como posicionar",
    "replicate_elements": ["elemento1", "elemento2", ...],
    "avoid_elements": ["elemento1", "elemento2", ...],
    "launch_timing": "quando lan√ßar"
  },
  "optimized_titles": [
    "t√≠tulo 1",
    "t√≠tulo 2",
    ...
  ],
  "content_roadmap": {
    "first_10_videos": [
      {"order": 1, "title": "t√≠tulo", "reason": "por que este primeiro"},
      ...
    ],
    "growth_strategy": "estrat√©gia de crescimento"
  }
}`;

        let response;
        if (service === 'claude') {
            response = await callClaudeAPI(prompt, apiKey, modelToUse);
        } else if (service === 'openai') {
            response = await callOpenAIAPI(prompt, apiKey, modelToUse);
        } else {
            response = await callGeminiAPI(prompt, apiKey, modelToUse);
        }
        
        const responseText = typeof response === 'string' ? response : JSON.stringify(response);
        const parsed = parseAIResponse(responseText, service);
        
        return parsed || {};
    } catch (err) {
        console.error('[analyzeNewChannelInsights] Erro:', err);
        return null;
    }
}

// Fun√ß√£o para restaurar loops ativos ao iniciar o servidor
async function restoreActiveLoops() {
    try {
        // Garantir que a tabela existe
        try {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS active_loops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    loop_type TEXT NOT NULL UNIQUE,
                    is_active BOOLEAN DEFAULT 0,
                    interval_seconds INTEGER DEFAULT 5,
                    started_at DATETIME,
                    stopped_at DATETIME,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        } catch (err) {
            // Tabela j√° existe, continuar
        }
        
        const activeLoops = await db.all('SELECT * FROM active_loops WHERE is_active = 1');
        
        if (activeLoops.length === 0) {
            console.log('[NOTIFICATIONS] Nenhum loop ativo para restaurar');
            return;
        }
        
        console.log(`[NOTIFICATIONS] Restaurando ${activeLoops.length} loop(s) ativo(s)...`);
        
        // Iniciar loops ativos
        for (const loop of activeLoops) {
            if (loop.is_active === 1) {
                console.log(`[NOTIFICATIONS] Iniciando loop ${loop.loop_type} (intervalo: ${loop.interval_seconds}s)`);
                startNotificationLoop(loop.loop_type, loop.interval_seconds);
            }
        }
        
        console.log('[NOTIFICATIONS] Loops ativos restaurados e em execu√ß√£o.');
    } catch (error) {
        console.error('[NOTIFICATIONS] Erro ao restaurar loops:', error);
    }
}

// --- ENDPOINTS PARA AN√ÅLISE DE CANAIS VIRAIS ---

// Detectar nicho automaticamente pela URL do canal
app.post('/api/viral-analysis/detect-niche', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { channelUrl, channelId, channelHandle } = req.body;
        
        if (!channelUrl && !channelId && !channelHandle) {
            return res.status(400).json({ msg: 'URL, ID ou Handle do canal √© obrigat√≥rio.' });
        }
        
        // Buscar API key do YouTube
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (!youtubeKeyData || !youtubeKeyData.api_key) {
            return res.status(400).json({ msg: 'Chave de API do YouTube n√£o configurada.' });
        }
        const youtubeApiKey = decrypt(youtubeKeyData.api_key);
        
        // Extrair channelId da URL se necess√°rio
        let finalChannelId = channelId;
        if (channelUrl && !channelId) {
            const urlMatch = channelUrl.match(/(?:youtube\.com\/(?:c\/|channel\/|user\/|@)|youtu\.be\/)([^\/\?]+)/);
            if (urlMatch) {
                finalChannelId = urlMatch[1];
            }
        }
        if (!finalChannelId && channelHandle) {
            finalChannelId = channelHandle;
        }
        
        // Buscar informa√ß√µes do canal
        const channelInfo = await getChannelInfo(finalChannelId, youtubeApiKey);
        
        // Buscar API key para IA
        let apiKey = null;
        let service = null;
        let modelToUse = null;
        
        const services = ['claude', 'openai', 'gemini'];
        for (const svc of services) {
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
            if (keyData && keyData.api_key) {
                try {
                    apiKey = decrypt(keyData.api_key);
                    service = svc;
                    if (svc === 'claude') modelToUse = 'claude-3-7-sonnet-20250219';
                    else if (svc === 'openai') modelToUse = 'gpt-4o';
                    else modelToUse = 'gemini-2.5-pro';
                    break;
                } catch (e) {
                    continue;
                }
            }
        }
        
        if (!apiKey) {
            return res.status(400).json({ msg: 'Nenhuma API key de IA configurada para detectar o nicho.' });
        }
        
        // Usar IA para detectar o nicho
        const nichePrompt = `Analise as seguintes informa√ß√µes de um canal do YouTube e identifique o NICHO PRINCIPAL do canal.

INFORMA√á√ïES DO CANAL:
- Nome: ${channelInfo.channelName}
- Descri√ß√£o: ${channelInfo.description.substring(0, 500)}
- Total de v√≠deos: ${channelInfo.videoCount}
- Total de visualiza√ß√µes: ${channelInfo.viewCount.toLocaleString()}
- Inscritos: ${channelInfo.subscriberCount.toLocaleString()}

Com base nessas informa√ß√µes, identifique o nicho principal do canal. O nicho deve ser uma palavra ou frase curta (m√°ximo 2 palavras) que descreva o tema principal do conte√∫do.

Exemplos de nichos v√°lidos:
- Hist√≥ria
- Tecnologia
- Educa√ß√£o
- Entretenimento
- Finan√ßas
- Gaming
- Culin√°ria
- Fitness
- Viagens
- Ci√™ncia
- Neg√≥cios
- Marketing

Responda APENAS com o nicho identificado, sem explica√ß√µes adicionais. Use letras mai√∫sculas para a primeira letra de cada palavra.`;

        let nicheResponse;
        if (service === 'claude') {
            nicheResponse = await callClaudeAPI(nichePrompt, apiKey, modelToUse);
        } else if (service === 'openai') {
            nicheResponse = await callOpenAIAPI(nichePrompt, apiKey, modelToUse);
        } else {
            nicheResponse = await callGeminiAPI(nichePrompt, apiKey, modelToUse);
        }
        
        const nicheText = typeof nicheResponse === 'string' ? nicheResponse : JSON.stringify(nicheResponse);
        const parsedNiche = parseAIResponse(nicheText, service);
        
        // Extrair nicho da resposta
        let detectedNiche = null;
        if (typeof parsedNiche === 'string') {
            detectedNiche = parsedNiche.trim();
        } else if (parsedNiche && parsedNiche.niche) {
            detectedNiche = parsedNiche.niche.trim();
        } else if (parsedNiche && typeof parsedNiche === 'object') {
            // Tentar encontrar o nicho no objeto
            detectedNiche = parsedNiche.niche || parsedNiche.title || Object.values(parsedNiche)[0];
            if (typeof detectedNiche === 'string') {
                detectedNiche = detectedNiche.trim();
            }
        }
        
        // Limpar e formatar o nicho
        if (detectedNiche) {
            // Remover aspas, pontos, etc.
            detectedNiche = detectedNiche.replace(/^["']|["']$/g, '').replace(/\.$/, '').trim();
            // Capitalizar primeira letra de cada palavra
            detectedNiche = detectedNiche.split(' ').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            ).join(' ');
        }
        
        res.status(200).json({ 
            niche: detectedNiche || null,
            channel: {
                name: channelInfo.channelName,
                description: channelInfo.description
            }
        });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/detect-niche]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao detectar nicho do canal.' });
    }
});

// Adicionar canal para an√°lise
app.post('/api/viral-analysis/channels', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { channelUrl, channelId, channelHandle } = req.body;
        
        if (!channelUrl && !channelId && !channelHandle) {
            return res.status(400).json({ msg: 'URL, ID ou Handle do canal √© obrigat√≥rio.' });
        }
        
        // Buscar API key do YouTube
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (!youtubeKeyData || !youtubeKeyData.api_key) {
            return res.status(400).json({ msg: 'Chave de API do YouTube n√£o configurada. Configure nas Configura√ß√µes.' });
        }
        
        const apiKey = decrypt(youtubeKeyData.api_key);
        
        // Extrair channelId da URL se necess√°rio
        let finalChannelId = channelId;
        if (channelUrl && !channelId) {
            const urlMatch = channelUrl.match(/(?:youtube\.com\/(?:c\/|channel\/|user\/|@)|youtu\.be\/)([^\/\?]+)/);
            if (urlMatch) {
                finalChannelId = urlMatch[1];
            }
        }
        if (!finalChannelId && channelHandle) {
            finalChannelId = channelHandle;
        }
        
        // Buscar informa√ß√µes do canal
        const channelInfo = await getChannelInfo(finalChannelId, apiKey);
        
        // Verificar se j√° existe an√°lise
        const existing = await db.get('SELECT id FROM channel_viral_analysis WHERE user_id = ? AND channel_id = ?', [userId, channelInfo.channelId]);
        
        if (existing) {
            return res.status(200).json({ 
                msg: 'Canal j√° est√° sendo analisado.',
                analysisId: existing.id,
                channel: channelInfo
            });
        }
        
        // Obter folder_id se fornecido (niche e subniche ser√£o detectados durante a an√°lise)
        const { folder_id } = req.body;
        
        // Criar nova an√°lise (niche e subniche ser√£o detectados durante a an√°lise)
        const result = await db.run(
            `INSERT INTO channel_viral_analysis 
            (user_id, channel_id, channel_name, channel_url, channel_handle, subscriber_count, total_videos, total_views, channel_age_days, channel_age_years, niche, subniche, folder_id, analyzed_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
            [userId, channelInfo.channelId, channelInfo.channelName, channelUrl || `https://youtube.com/channel/${channelInfo.channelId}`, channelInfo.channelHandle, channelInfo.subscriberCount, channelInfo.videoCount, channelInfo.viewCount, channelInfo.daysSinceCreation || 0, channelInfo.yearsSinceCreation || 0, null, null, folder_id || null]
        );
        
        res.status(201).json({
            msg: 'Canal adicionado para an√°lise com sucesso.',
            analysisId: result.lastID,
            channel: channelInfo
        });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/channels]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao adicionar canal para an√°lise.' });
    }
});

// Listar canais em an√°lise
app.get('/api/viral-analysis/channels', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        
        // Verificar quais colunas existem na tabela
        let tableInfo;
        try {
            tableInfo = await db.all("PRAGMA table_info(channel_viral_analysis)");
        } catch (e) {
            // Se a tabela n√£o existir, retornar array vazio
            return res.status(200).json({ channels: [] });
        }
        
        const existingColumns = tableInfo.map(col => col.name);
        
        // Construir SELECT apenas com colunas que existem
        const baseColumns = ['id', 'channel_id', 'channel_name', 'channel_url', 'channel_handle', 'subscriber_count', 'total_videos', 'total_views', 'analyzed_at', 'last_updated'];
        const optionalColumns = ['channel_age_days', 'channel_age_years', 'avg_rpm_usd', 'avg_rpm_brl', 'niche', 'subniche', 'folder_id'];
        
        const selectColumns = [...baseColumns];
        optionalColumns.forEach(col => {
            if (existingColumns.includes(col)) {
                selectColumns.push(col);
            }
        });
        
        const channels = await db.all(
            `SELECT ${selectColumns.join(', ')}
            FROM channel_viral_analysis 
            WHERE user_id = ? 
            ORDER BY analyzed_at DESC 
            LIMIT 5`,
            [userId]
        );
        
        res.status(200).json({ channels });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/channels GET]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao listar canais.' });
    }
});

// Analisar canal completo
app.post('/api/viral-analysis/channels/:analysisId/analyze', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const analysisId = parseInt(req.params.analysisId);
        const { ai_model = 'auto' } = req.body;
        
        // Verificar se a an√°lise pertence ao usu√°rio
        const analysis = await db.get('SELECT * FROM channel_viral_analysis WHERE id = ? AND user_id = ?', [analysisId, userId]);
        if (!analysis) {
            return res.status(404).json({ msg: 'An√°lise n√£o encontrada.' });
        }
        
        // Buscar API keys
        const youtubeKeyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, 'youtube']);
        if (!youtubeKeyData || !youtubeKeyData.api_key) {
            return res.status(400).json({ msg: 'Chave de API do YouTube n√£o configurada.' });
        }
        const youtubeApiKey = decrypt(youtubeKeyData.api_key);
        
        // Buscar API key para IA
        let apiKey = null;
        let service = null;
        let modelToUse = null;
        
        if (ai_model && ai_model !== 'auto') {
            if (ai_model.includes('claude')) {
                service = 'claude';
                modelToUse = 'claude-3-7-sonnet-20250219';
            } else if (ai_model.includes('gpt')) {
                service = 'openai';
                modelToUse = 'gpt-4o';
            } else if (ai_model.includes('gemini')) {
                service = 'gemini';
                modelToUse = 'gemini-2.5-pro';
            }
        }
        
        if (!service) {
            const services = ['claude', 'openai', 'gemini'];
            for (const svc of services) {
                const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
                if (keyData && keyData.api_key) {
                    try {
                        apiKey = decrypt(keyData.api_key);
                        service = svc;
                        if (svc === 'claude') modelToUse = 'claude-3-7-sonnet-20250219';
                        else if (svc === 'openai') modelToUse = 'gpt-4o';
                        else modelToUse = 'gemini-2.5-pro';
                        break;
                    } catch (e) {
                        continue;
                    }
                }
            }
        } else {
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, service]);
            if (keyData && keyData.api_key) {
                apiKey = decrypt(keyData.api_key);
            }
        }
        
        if (!apiKey) {
            return res.status(400).json({ msg: 'Nenhuma API key de IA configurada.' });
        }
        
        // Buscar informa√ß√µes atualizadas do canal
        const channelInfo = await getChannelInfo(analysis.channel_id, youtubeApiKey);
        
        // Buscar top 20 v√≠deos mais vistos
        const videos = await getChannelTopVideos(analysis.channel_id, youtubeApiKey, 20);
        
        // Buscar coment√°rios dos top 5 v√≠deos
        const allComments = [];
        for (let i = 0; i < Math.min(5, videos.length); i++) {
            const comments = await getVideoComments(videos[i].videoId, youtubeApiKey, 20);
            // Adicionar videoId aos coment√°rios para associa√ß√£o
            comments.forEach(comment => {
                comment.videoId = videos[i].videoId;
            });
            allComments.push(...comments);
        }
        
        // Salvar v√≠deos no banco
        for (const video of videos) {
            await db.run(
                `INSERT OR REPLACE INTO channel_viral_videos 
                (analysis_id, video_id, video_url, title, description, thumbnail_url, view_count, like_count, comment_count, published_at, duration, tags_json, category_id, viral_score)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [analysisId, video.videoId, `https://youtube.com/watch?v=${video.videoId}`, video.title, video.description, video.thumbnail, video.viewCount, video.likeCount, video.commentCount, video.publishedAt, video.duration, JSON.stringify(video.tags), video.categoryId, video.viralScore]
            );
        }
        
        // Salvar coment√°rios (associar aos v√≠deos salvos)
        const savedVideos = await db.all('SELECT id, video_id FROM channel_viral_videos WHERE analysis_id = ?', [analysisId]);
        const videoIdMap = {};
        savedVideos.forEach(v => { videoIdMap[v.video_id] = v.id; });
        
        // Agrupar coment√°rios por v√≠deo
        const commentsByVideo = {};
        for (const comment of allComments) {
            if (!commentsByVideo[comment.videoId]) {
                commentsByVideo[comment.videoId] = [];
            }
            commentsByVideo[comment.videoId].push(comment);
        }
        
        // Salvar coment√°rios associados aos v√≠deos corretos
        for (const [youtubeVideoId, comments] of Object.entries(commentsByVideo)) {
            const videoDbId = videoIdMap[youtubeVideoId];
            if (videoDbId) {
                for (const comment of comments) {
                    await db.run(
                        `INSERT OR IGNORE INTO channel_viral_comments 
                        (video_id, comment_id, author_name, author_channel_id, text, like_count, published_at)
                        VALUES (?, ?, ?, ?, ?, ?, ?)`,
                        [videoDbId, comment.commentId, comment.authorName, comment.authorChannelId, comment.text, comment.likeCount, comment.publishedAt]
                    );
                }
            }
        }
        
        // Detectar nicho e subnicho durante a an√°lise (mais preciso)
        let detectedNiche = analysis.niche;
        let detectedSubniche = analysis.subniche || null;
        
        if (!detectedNiche || !detectedSubniche) {
            try {
                // Usar IA para detectar nicho e subnicho baseado nos dados completos do canal
                const nicheDetectionPrompt = `Analise as seguintes informa√ß√µes de um canal do YouTube e identifique o NICHO PRINCIPAL e o SUBNICHO do canal.

INFORMA√á√ïES DO CANAL:
- Nome: ${channelInfo.channelName}
- Descri√ß√£o: ${channelInfo.description ? channelInfo.description.substring(0, 500) : 'N/A'}
- Total de v√≠deos: ${channelInfo.videoCount}
- Total de visualiza√ß√µes: ${channelInfo.viewCount.toLocaleString()}
- Inscritos: ${channelInfo.subscriberCount.toLocaleString()}

TOP 5 V√çDEOS MAIS VISTOS:
${videos.slice(0, 5).map((v, i) => `
${i + 1}. "${v.title}"
   - Visualiza√ß√µes: ${(v.viewCount || 0).toLocaleString()}
`).join('')}

Com base nessas informa√ß√µes, identifique:
1. NICHO PRINCIPAL: Uma palavra ou frase curta (m√°ximo 2 palavras) que descreva o tema principal do conte√∫do.
2. SUBNICHO: Uma palavra ou frase que especifique melhor o foco dentro do nicho principal.

Exemplos:
- Nicho: "Hist√≥ria", Subnicho: "Hist√≥ria Antiga"
- Nicho: "Tecnologia", Subnicho: "Intelig√™ncia Artificial"
- Nicho: "Educa√ß√£o", Subnicho: "Matem√°tica"

Responda APENAS com um JSON v√°lido no formato:
{
  "niche": "Nicho Principal",
  "subniche": "Subnicho Espec√≠fico"
}`;

                let nicheResponse;
                if (service === 'claude') {
                    nicheResponse = await callClaudeAPI(nicheDetectionPrompt, apiKey, modelToUse);
                } else if (service === 'openai') {
                    nicheResponse = await callOpenAIAPI(nicheDetectionPrompt, apiKey, modelToUse);
                } else {
                    nicheResponse = await callGeminiAPI(nicheDetectionPrompt, apiKey, modelToUse);
                }
                
                const nicheText = typeof nicheResponse === 'string' ? nicheResponse : JSON.stringify(nicheResponse);
                const parsedNiche = parseAIResponse(nicheText, service);
                
                if (parsedNiche && typeof parsedNiche === 'object') {
                    if (parsedNiche.niche && !detectedNiche) {
                        detectedNiche = parsedNiche.niche.trim();
                    }
                    if (parsedNiche.subniche) {
                        detectedSubniche = parsedNiche.subniche.trim();
                    }
                } else if (typeof parsedNiche === 'string' && !detectedNiche) {
                    detectedNiche = parsedNiche.trim();
                }
                
                // Limpar e formatar
                if (detectedNiche) {
                    detectedNiche = detectedNiche.replace(/^["']|["']$/g, '').replace(/\.$/, '').trim();
                    detectedNiche = detectedNiche.split(' ').map(word => 
                        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                    ).join(' ');
                }
                if (detectedSubniche) {
                    detectedSubniche = detectedSubniche.replace(/^["']|["']$/g, '').replace(/\.$/, '').trim();
                    detectedSubniche = detectedSubniche.split(' ').map(word => 
                        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                    ).join(' ');
                }
                
                console.log('[Viral Analysis] Nicho detectado:', detectedNiche, 'Subnicho:', detectedSubniche);
            } catch (err) {
                console.error('[Viral Analysis] Erro ao detectar nicho/subnicho:', err);
                // Continuar mesmo se falhar
            }
        }
        
        // Atualizar nicho e subnicho no banco
        if (detectedNiche || detectedSubniche) {
            await db.run(
                'UPDATE channel_viral_analysis SET niche = COALESCE(?, niche), subniche = COALESCE(?, subniche) WHERE id = ?',
                [detectedNiche, detectedSubniche, analysisId]
            );
        }
        
        // Analisar insights virais com IA
        let insights;
        try {
            insights = await analyzeViralInsights(channelInfo, videos, allComments, apiKey, service, modelToUse);
            console.log('[Viral Analysis] Insights gerados:', JSON.stringify(insights).substring(0, 200));
        } catch (err) {
            console.error('[Viral Analysis] Erro ao gerar insights:', err);
            // Usar estrutura vazia se falhar
            insights = {
                title_patterns: {
                    structure: 'Estrutura n√£o identificada',
                    keywords: [],
                    hook_techniques: [],
                    avg_length: 0
                },
                engagement_strategies: {
                    comment_triggers: [],
                    like_triggers: [],
                    best_posting_times: 'N√£o identificado'
                },
                viral_insights: {
                    why_viral: 'An√°lise n√£o dispon√≠vel',
                    common_elements: [],
                    differences: 'N√£o identificado'
                },
                recommendations: {
                    replication_strategy: 'Estrat√©gia n√£o identificada',
                    suggested_titles: [],
                    content_strategies: []
                }
            };
        }
        
        // Calcular RPM m√©dio baseado no nicho (usar nicho atualizado)
        const updatedNiche = detectedNiche || analysis.niche;
        const rpmData = getRPMByNiche(updatedNiche || null);
        
        // Calcular RPM m√©dio do canal (estimativa baseada em views totais)
        const avgRPM = {
            usd: rpmData.usd,
            brl: rpmData.brl
        };
        
        // Calcular valor total ganho estimado do canal
        const totalRevenueUSD = (channelInfo.viewCount / 1000) * avgRPM.usd;
        const totalRevenueBRL = (channelInfo.viewCount / 1000) * avgRPM.brl;
        
        // Analisar insights cruzados para novo canal (usar nicho atualizado)
        const allAnalyses = await db.all(
            `SELECT * FROM channel_viral_analysis WHERE user_id = ? AND niche = ? AND id != ? ORDER BY analyzed_at DESC`,
            [userId, updatedNiche || '', analysisId]
        );
        
        let newChannelInsights = null;
        if (allAnalyses.length > 0) {
            // Buscar insights de outros canais do mesmo nicho
            const otherInsights = [];
            for (const otherAnalysis of allAnalyses.slice(0, 4)) {
                if (otherAnalysis.viral_insights_json) {
                    try {
                        const parsed = typeof otherAnalysis.viral_insights_json === 'string' 
                            ? JSON.parse(otherAnalysis.viral_insights_json) 
                            : otherAnalysis.viral_insights_json;
                        otherInsights.push({
                            channelName: otherAnalysis.channel_name,
                            insights: parsed
                        });
                    } catch (e) {
                        console.error('[Viral Analysis] Erro ao parsear insights de outro canal:', e);
                    }
                }
            }
            
            if (otherInsights.length > 0) {
                newChannelInsights = await analyzeNewChannelInsights(insights, otherInsights, channelInfo, apiKey, service, modelToUse);
            }
        }
        
        // Salvar insights
        const insightsData = {
            title_patterns: insights.title_patterns || {},
            engagement_strategies: insights.engagement_strategies || {},
            viral_insights: insights.viral_insights || {},
            recommendations: insights.recommendations || {}
        };
        
        console.log('[Viral Analysis] Salvando insights no banco:', {
            analysisId,
            hasTitlePatterns: !!insightsData.title_patterns && Object.keys(insightsData.title_patterns).length > 0,
            hasEngagement: !!insightsData.engagement_strategies && Object.keys(insightsData.engagement_strategies).length > 0,
            hasViralInsights: !!insightsData.viral_insights && Object.keys(insightsData.viral_insights).length > 0,
            hasRecommendations: !!insightsData.recommendations && Object.keys(insightsData.recommendations).length > 0,
            insightsDataPreview: JSON.stringify(insightsData).substring(0, 500)
        });
        
        await db.run(
            'UPDATE channel_viral_analysis SET analysis_data_json = ?, viral_insights_json = ?, new_channel_insights_json = ?, avg_rpm_usd = ?, avg_rpm_brl = ?, total_revenue_usd = ?, total_revenue_brl = ?, channel_age_days = ?, channel_age_years = ?, last_updated = CURRENT_TIMESTAMP WHERE id = ?',
            [JSON.stringify({ channelInfo, videos: videos.slice(0, 10) }), JSON.stringify(insightsData), newChannelInsights ? JSON.stringify(newChannelInsights) : null, avgRPM.usd, avgRPM.brl, totalRevenueUSD, totalRevenueBRL, channelInfo.daysSinceCreation || 0, channelInfo.yearsSinceCreation || 0, analysisId]
        );
        
        // Verificar se foi salvo corretamente
        const saved = await db.get('SELECT viral_insights_json FROM channel_viral_analysis WHERE id = ?', [analysisId]);
        console.log('[Viral Analysis] Verifica√ß√£o p√≥s-salvamento:', {
            saved: !!saved,
            hasViralInsightsJson: !!saved?.viral_insights_json,
            length: saved?.viral_insights_json?.length || 0,
            preview: saved?.viral_insights_json?.substring(0, 200) || 'null'
        });
        
        // Salvar insights individuais
        if (insights.title_patterns) {
            await db.run(
                'INSERT INTO channel_viral_insights (analysis_id, insight_type, insight_title, insight_content, priority) VALUES (?, ?, ?, ?, ?)',
                [analysisId, 'title_patterns', 'Padr√µes nos T√≠tulos', JSON.stringify(insights.title_patterns), 1]
            );
        }
        if (insights.engagement_strategies) {
            await db.run(
                'INSERT INTO channel_viral_insights (analysis_id, insight_type, insight_title, insight_content, priority) VALUES (?, ?, ?, ?, ?)',
                [analysisId, 'engagement', 'Estrat√©gias de Engagement', JSON.stringify(insights.engagement_strategies), 2]
            );
        }
        if (insights.viral_insights) {
            await db.run(
                'INSERT INTO channel_viral_insights (analysis_id, insight_type, insight_title, insight_content, priority) VALUES (?, ?, ?, ?, ?)',
                [analysisId, 'viral', 'Insights Virais', JSON.stringify(insights.viral_insights), 3]
            );
        }
        if (insights.recommendations) {
            await db.run(
                'INSERT INTO channel_viral_insights (analysis_id, insight_type, insight_title, insight_content, priority) VALUES (?, ?, ?, ?, ?)',
                [analysisId, 'recommendations', 'Recomenda√ß√µes', JSON.stringify(insights.recommendations), 4]
            );
        }
        
        res.status(200).json({
            msg: 'An√°lise conclu√≠da com sucesso.',
            analysis: {
                channel: channelInfo,
                videosCount: videos.length,
                commentsCount: allComments.length,
                insights: insightsData
            }
        });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/channels/:id/analyze]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao analisar canal.' });
    }
});

// Obter an√°lise completa
app.get('/api/viral-analysis/channels/:analysisId', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const analysisId = parseInt(req.params.analysisId);
        
        const analysis = await db.get('SELECT * FROM channel_viral_analysis WHERE id = ? AND user_id = ?', [analysisId, userId]);
        if (!analysis) {
            return res.status(404).json({ msg: 'An√°lise n√£o encontrada.' });
        }
        
        const videos = await db.all('SELECT * FROM channel_viral_videos WHERE analysis_id = ? ORDER BY view_count DESC, viral_score DESC', [analysisId]);
        const insights = await db.all('SELECT * FROM channel_viral_insights WHERE analysis_id = ? ORDER BY priority', [analysisId]);
        
        // Buscar coment√°rios para cada v√≠deo
        for (const video of videos) {
            const comments = await db.all('SELECT * FROM channel_viral_comments WHERE video_id = ? ORDER BY like_count DESC LIMIT 10', [video.id]);
            video.comments = comments;
        }
        
        // Parsear JSONs se existirem
        let analysisData = null;
        let viralInsights = null;
        
        try {
            if (analysis.analysis_data_json) {
                analysisData = typeof analysis.analysis_data_json === 'string' 
                    ? JSON.parse(analysis.analysis_data_json) 
                    : analysis.analysis_data_json;
            }
        } catch (e) {
            console.error('[Viral Analysis] Erro ao parsear analysis_data_json:', e);
        }
        
        try {
            if (analysis.viral_insights_json) {
                viralInsights = typeof analysis.viral_insights_json === 'string' 
                    ? JSON.parse(analysis.viral_insights_json) 
                    : analysis.viral_insights_json;
                console.log('[Viral Analysis GET] Insights parseados:', {
                    hasTitlePatterns: !!viralInsights?.title_patterns,
                    hasEngagement: !!viralInsights?.engagement_strategies,
                    hasViralInsights: !!viralInsights?.viral_insights,
                    hasRecommendations: !!viralInsights?.recommendations,
                    titlePatternsKeys: viralInsights?.title_patterns ? Object.keys(viralInsights.title_patterns) : [],
                    recommendationsKeys: viralInsights?.recommendations ? Object.keys(viralInsights.recommendations) : []
                });
            } else {
                console.warn('[Viral Analysis GET] viral_insights_json est√° vazio ou null');
            }
        } catch (e) {
            console.error('[Viral Analysis] Erro ao parsear viral_insights_json:', e);
            console.error('[Viral Analysis] Conte√∫do raw:', analysis.viral_insights_json?.substring(0, 500));
        }
        
        // Parsear new_channel_insights se existir
        let newChannelInsights = null;
        try {
            if (analysis.new_channel_insights_json) {
                newChannelInsights = typeof analysis.new_channel_insights_json === 'string' 
                    ? JSON.parse(analysis.new_channel_insights_json) 
                    : analysis.new_channel_insights_json;
            }
        } catch (e) {
            console.error('[Viral Analysis] Erro ao parsear new_channel_insights_json:', e);
        }
        
        console.log('[Viral Analysis GET] Retornando an√°lise:', {
            hasViralInsights: !!viralInsights,
            videosCount: videos.length,
            insightsCount: insights.length
        });
        
        res.status(200).json({
            analysis: {
                ...analysis,
                analysis_data: analysisData,
                viral_insights: viralInsights,
                new_channel_insights: newChannelInsights,
                total_revenue_usd: analysis.total_revenue_usd || null,
                total_revenue_brl: analysis.total_revenue_brl || null
            },
            videos,
            insights
        });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/channels/:id]:', err);
        res.status(500).json({ msg: 'Erro ao buscar an√°lise.' });
    }
});

// Remover canal da an√°lise
app.delete('/api/viral-analysis/channels/:analysisId', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const analysisId = parseInt(req.params.analysisId);
        
        const analysis = await db.get('SELECT id FROM channel_viral_analysis WHERE id = ? AND user_id = ?', [analysisId, userId]);
        if (!analysis) {
            return res.status(404).json({ msg: 'An√°lise n√£o encontrada.' });
        }
        
        await db.run('DELETE FROM channel_viral_analysis WHERE id = ?', [analysisId]);
        
        res.status(200).json({ msg: 'Canal removido da an√°lise com sucesso.' });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/channels/:id DELETE]:', err);
        res.status(500).json({ msg: 'Erro ao remover canal.' });
    }
});

// Cruzar an√°lises de m√∫ltiplos canais e gerar conte√∫do viral
app.post('/api/viral-analysis/cross-analyze', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const { analysisIds } = req.body;
        
        if (!analysisIds || !Array.isArray(analysisIds) || analysisIds.length < 2) {
            return res.status(400).json({ msg: 'Selecione pelo menos 2 an√°lises para cruzar.' });
        }
        
        // Buscar todas as an√°lises selecionadas
        const placeholders = analysisIds.map(() => '?').join(',');
        const analyses = await db.all(
            `SELECT * FROM channel_viral_analysis WHERE id IN (${placeholders}) AND user_id = ?`,
            [...analysisIds, userId]
        );
        
        if (analyses.length < 2) {
            return res.status(400).json({ msg: 'N√£o foi poss√≠vel encontrar as an√°lises selecionadas.' });
        }
        
        // Buscar v√≠deos e insights de cada an√°lise
        const allVideos = [];
        const allInsights = [];
        
        for (const analysis of analyses) {
            const videos = await db.all(
                'SELECT * FROM channel_viral_videos WHERE analysis_id = ? ORDER BY view_count DESC LIMIT 10',
                [analysis.id]
            );
            allVideos.push(...videos.map(v => ({ ...v, channelName: analysis.channel_name, niche: analysis.niche })));
            
            const insights = await db.all(
                'SELECT * FROM channel_viral_insights WHERE analysis_id = ?',
                [analysis.id]
            );
            allInsights.push(...insights.map(i => ({ ...i, channelName: analysis.channel_name })));
        }
        
        // Buscar chave de API do usu√°rio
        const user = await db.get('SELECT openai_api_key FROM users WHERE id = ?', [userId]);
        if (!user || !user.openai_api_key) {
            return res.status(400).json({ msg: 'Configure sua chave de API OpenAI nas configura√ß√µes.' });
        }
        
        // Preparar dados para an√°lise cruzada
        const topVideosByChannel = {};
        analyses.forEach(analysis => {
            const channelVideos = allVideos.filter(v => v.channelName === analysis.channel_name);
            topVideosByChannel[analysis.channel_name] = channelVideos.slice(0, 5);
        });
        
        // Identificar nicho comum entre os canais
        const commonNiche = analyses[0].niche || 'N√£o identificado';
        const allNiches = analyses.map(a => a.niche).filter(n => n);
        const uniqueNiches = [...new Set(allNiches)];
        
        // Identificar v√≠deos mais virais de cada canal para an√°lise de t√≠tulos e thumbnails
        const mostViralVideos = analyses.map(analysis => {
            const channelVideos = allVideos.filter(v => v.channelName === analysis.channel_name);
            return channelVideos.reduce((max, v) => (v.view_count || 0) > (max.view_count || 0) ? v : max, channelVideos[0]);
        }).filter(v => v);
        
        // Criar prompt para an√°lise cruzada com foco em conte√∫do inexplorado
        const crossAnalysisPrompt = `Voc√™ √© um ESPECIALISTA EM AN√ÅLISE DE CANAIS VIRAIS DO YOUTUBE e IDENTIFICA√á√ÉO DE OPORTUNIDADES DE CONTE√öDO INEXPLORADO.

CONTEXTO INICIAL:
Quero criar um canal no YouTube dentro do nicho de "${commonNiche}". Analisei ${analyses.length} canais de sucesso neste nicho, mas percebi que j√° h√° bastante concorr√™ncia em alguns subnichos. Estou em busca de ideias de subnichos dentro de "${commonNiche}" que ainda estejam pouco exploradas no YouTube, com pouca ou nenhuma concorr√™ncia, mas que tenham ALTO VOLUME DE BUSCAS, INTERESSE CRESCENTE e BOM POTENCIAL DE MONETIZA√á√ÉO.

O objetivo √© encontrar uma OPORTUNIDADE √öNICA para criar conte√∫do relevante, com FORTE DEMANDA e BAIXA COMPETI√á√ÉO, gerando CONTE√öDO VIRAL IN√âDITO que ainda n√£o foi explorado no YouTube.

DADOS DOS CANAIS ANALISADOS:

${analyses.map((analysis, idx) => {
    const channelVideos = topVideosByChannel[analysis.channel_name] || [];
    const mostViral = mostViralVideos.find(v => v.channelName === analysis.channel_name);
    return `
CANAL ${idx + 1}: ${analysis.channel_name}
- Inscritos: ${(analysis.subscriber_count || 0).toLocaleString()}
- V√≠deos: ${(analysis.total_videos || 0).toLocaleString()}
- Visualiza√ß√µes: ${(analysis.total_views || 0).toLocaleString()}
- Nicho: ${analysis.niche || 'N√£o identificado'}

TOP 5 V√çDEOS MAIS VISTOS:
${channelVideos.map((v, i) => `
${i + 1}. "${v.title}"
   - Visualiza√ß√µes: ${(v.view_count || 0).toLocaleString()}
   - Likes: ${(v.like_count || 0).toLocaleString()}
   - Coment√°rios: ${(v.comment_count || 0).toLocaleString()}
   - Score Viral: ${(v.viral_score || 0).toFixed(2)}
   - Thumbnail: ${v.thumbnail_url || 'N/A'}
`).join('') || 'Nenhum v√≠deo'}

${mostViral ? `V√çDEO MAIS VIRAL DESTE CANAL:
"${mostViral.title}"
- Pegou ${(mostViral.view_count || 0).toLocaleString()} views
- Thumbnail: ${mostViral.thumbnail_url || 'N/A'}
- Este v√≠deo viralizou com este t√≠tulo e esta thumbnail. Analise profundamente por que funcionou.` : ''}
`;
}).join('\n')}

AN√ÅLISE PROFUNDA REQUERIDA:

1. IDENTIFICA√á√ÉO DE SUBNICHOS INEXPLORADOS:
   - Com base nos dados atuais e tend√™ncias, identifique subnichos dentro de "${commonNiche}" que:
     * Ainda estejam pouco explorados no YouTube
     * Tenham ALTO VOLUME DE BUSCAS (alta demanda)
     * Tenham INTERESSE CRESCENTE (tend√™ncia ascendente)
     * Tenham BOM POTENCIAL DE MONETIZA√á√ÉO
     * Tenham BAIXA OU NENHUMA CONCORR√äNCIA
   - Priorize oportunidades que sejam √öNICAS e ainda n√£o exploradas

2. PADR√ïES COMUNS IDENTIFICADOS:
   - Padr√µes nos t√≠tulos que aparecem em m√∫ltiplos canais e funcionam
   - Padr√µes de engagement (o que gera mais coment√°rios/likes)
   - Temas de conte√∫do comuns que performam bem
   - Estruturas de t√≠tulos que funcionam consistentemente
   - Padr√µes visuais nas thumbnails dos v√≠deos virais

3. AN√ÅLISE DE T√çTULOS VIRAIS (PROMPT ESPEC√çFICO):
${mostViralVideos.map((v, idx) => `
   - Este v√≠deo do canal "${v.channelName}" viralizou, pegou ${(v.view_count || 0).toLocaleString()} views com o t√≠tulo: "${v.title}"
   - Preciso que voc√™ me d√™ varia√ß√µes MUITO CHAMATIVAS focadas em viraliza√ß√£o para um canal subnichado
   - Identifique os elementos-chave deste t√≠tulo que o tornaram viral
`).join('')}

4. AN√ÅLISE DE THUMBNAILS VIRAIS (PROMPT ESPEC√çFICO):
${mostViralVideos.map((v, idx) => `
   - Este v√≠deo com esta thumbnail (${v.thumbnail_url || 'N/A'}) viralizou com o t√≠tulo: "${v.title}"
   - Analise como a thumbnail complementa o t√≠tulo e identifique elementos visuais que contribu√≠ram para o viral
   - Quais adapta√ß√µes desta thumbnail funcionariam para outros t√≠tulos virais?
`).join('')}

5. GERA√á√ÉO DE CONTE√öDO IN√âDITO VIRAL:
   - Gere 15 t√≠tulos ORIGINAIS e IN√âDITOS baseados nos padr√µes identificados
   - Os t√≠tulos devem ser para conte√∫do que AINDA N√ÉO FOI EXPLORADO no YouTube
   - Foque em subnichos com ALTA DEMANDA e BAIXA COMPETI√á√ÉO
   - Combine os melhores elementos de cada canal analisado
   - Crie t√≠tulos que sejam VIRAIS mas para conte√∫do NOVO e INEXPLORADO

6. ESTRAT√âGIA DE CONTE√öDO:
   - Estrat√©gia que combine os melhores elementos de cada canal
   - Foco em subnichos pouco explorados mas com alta demanda
   - Identifique hooks virais que podem ser aplicados em conte√∫do in√©dito
   - Como estruturar conte√∫do para maximizar viraliza√ß√£o em nichos inexplorados

7. RECOMENDA√á√ïES ESPEC√çFICAS:
   - Como criar conte√∫do relevante com forte demanda e baixa competi√ß√£o
   - Oportunidades √∫nicas identificadas
   - Estrat√©gias para monetiza√ß√£o em subnichos inexplorados
   - Roadmap inicial de conte√∫do

Retorne um JSON com a seguinte estrutura:
{
  "unexplored_opportunities": {
    "subniches": [
      {
        "name": "nome do subnicho",
        "demand_level": "alta/m√©dia/baixa",
        "competition_level": "baixa/m√©dia/alta",
        "monetization_potential": "alto/m√©dio/baixo",
        "why_unexplored": "explica√ß√£o",
        "trend_direction": "crescendo/est√°vel/decrescendo"
      }
    ],
    "content_gaps": ["gap 1", "gap 2", ...],
    "unique_angles": ["√¢ngulo √∫nico 1", "√¢ngulo √∫nico 2", ...]
  },
  "common_patterns": {
    "title_patterns": "Descri√ß√£o detalhada dos padr√µes de t√≠tulos comuns que funcionam",
    "engagement_patterns": "Descri√ß√£o dos padr√µes de engagement comuns",
    "content_themes": ["tema1", "tema2", "tema3"],
    "thumbnail_patterns": "Padr√µes visuais das thumbnails virais",
    "viral_title_elements": ["elemento 1", "elemento 2", ...]
  },
  "viral_title_analysis": {
    "viral_titles": [
      {
        "original_title": "t√≠tulo original que viralizou",
        "why_viral": "an√°lise de por que viralizou",
        "key_elements": ["elemento 1", "elemento 2", ...],
        "variations": ["varia√ß√£o 1", "varia√ß√£o 2", "varia√ß√£o 3"]
      }
    ]
  },
  "thumbnail_analysis": {
    "viral_thumbnails": [
      {
        "title": "t√≠tulo do v√≠deo",
        "thumbnail_url": "url da thumbnail",
        "visual_elements": ["elemento 1", "elemento 2", ...],
        "thumbnail_title_synergy": "como trabalham juntos",
        "adaptations": ["adapta√ß√£o 1", "adapta√ß√£o 2", ...]
      }
    ],
    "recurring_patterns": ["padr√£o 1", "padr√£o 2", ...]
  },
  "generated_content": {
    "titles": [
      "t√≠tulo 1 IN√âDITO para conte√∫do n√£o explorado",
      "t√≠tulo 2 IN√âDITO para conte√∫do n√£o explorado",
      ... "t√≠tulo 15"
    ],
    "content_strategy": "Estrat√©gia detalhada de conte√∫do focado em subnichos inexplorados com alta demanda",
    "hooks": ["hook viral 1", "hook viral 2", "hook viral 3"],
    "unexplored_topics": ["t√≥pico 1 inexplorado", "t√≥pico 2 inexplorado", ...]
  },
  "recommendations": {
    "strategic_recommendations": "Recomenda√ß√µes estrat√©gicas para criar conte√∫do viral em subnichos inexplorados",
    "monetization_strategy": "Estrat√©gia de monetiza√ß√£o para conte√∫do in√©dito",
    "content_roadmap": ["v√≠deo 1", "v√≠deo 2", ...],
    "competitive_advantages": ["vantagem 1", "vantagem 2", ...]
  }
}`;

        // Chamar IA para an√°lise cruzada
        const aiResponse = await callOpenAIAPI(
            crossAnalysisPrompt,
            user.openai_api_key,
            'gpt-4o',
            null,
            []
        );
        
        let crossAnalysisData;
        try {
            if (typeof aiResponse === 'string') {
                crossAnalysisData = JSON.parse(aiResponse);
            } else {
                crossAnalysisData = aiResponse;
            }
        } catch (e) {
            console.error('[Cross Analysis] Erro ao parsear resposta da IA:', e);
            crossAnalysisData = {
                common_patterns: {
                    title_patterns: 'An√°lise n√£o dispon√≠vel',
                    engagement_patterns: 'An√°lise n√£o dispon√≠vel',
                    content_themes: []
                },
                generated_content: {
                    titles: [],
                    content_strategy: 'Erro ao gerar estrat√©gia',
                    hooks: []
                },
                recommendations: 'Erro ao gerar recomenda√ß√µes'
            };
        }
        
        res.status(200).json(crossAnalysisData);
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/cross-analyze]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao cruzar an√°lises.' });
    }
});

// Analisar coment√°rios de um v√≠deo e gerar t√≠tulos baseados nos coment√°rios
app.post('/api/viral-analysis/videos/:videoId/analyze-comments', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const videoId = req.params.videoId;
        
        // Buscar v√≠deo no banco
        const video = await db.get(
            'SELECT * FROM channel_viral_videos WHERE video_id = ? AND analysis_id IN (SELECT id FROM channel_viral_analysis WHERE user_id = ?)',
            [videoId, userId]
        );
        
        if (!video) {
            return res.status(404).json({ msg: 'V√≠deo n√£o encontrado.' });
        }
        
        // Buscar coment√°rios do v√≠deo
        const comments = await db.all(
            `SELECT c.* FROM channel_viral_comments c
             INNER JOIN channel_viral_videos v ON c.video_id = v.id
             WHERE v.video_id = ? AND v.analysis_id IN (SELECT id FROM channel_viral_analysis WHERE user_id = ?)
             ORDER BY c.like_count DESC
             LIMIT 100`,
            [videoId, userId]
        );
        
        if (comments.length === 0) {
            return res.status(400).json({ msg: 'Nenhum coment√°rio encontrado para este v√≠deo.' });
        }
        
        // Buscar API key para IA
        let apiKey = null;
        let service = null;
        let modelToUse = null;
        
        const services = ['claude', 'openai', 'gemini'];
        for (const svc of services) {
            const keyData = await db.get('SELECT api_key FROM user_api_keys WHERE user_id = ? AND service_name = ?', [userId, svc]);
            if (keyData && keyData.api_key) {
                try {
                    apiKey = decrypt(keyData.api_key);
                    service = svc;
                    if (svc === 'claude') modelToUse = 'claude-3-7-sonnet-20250219';
                    else if (svc === 'openai') modelToUse = 'gpt-4o';
                    else modelToUse = 'gemini-2.5-pro';
                    break;
                } catch (e) {
                    continue;
                }
            }
        }
        
        if (!apiKey) {
            return res.status(400).json({ msg: 'Nenhuma API key de IA configurada.' });
        }
        
        // Buscar nicho do canal
        const analysis = await db.get(
            'SELECT niche, subniche FROM channel_viral_analysis WHERE id = (SELECT analysis_id FROM channel_viral_videos WHERE video_id = ?)',
            [videoId]
        );
        
        const niche = analysis?.niche || 'N√£o identificado';
        const subniche = analysis?.subniche || '';
        
        // Criar prompt para an√°lise de coment√°rios
        const commentsAnalysisPrompt = `Voc√™ √© um ESPECIALISTA EM AN√ÅLISE DE COMENT√ÅRIOS DO YOUTUBE.

Analise os coment√°rios abaixo de um v√≠deo que viralizou e gere t√≠tulos baseados nos insights dos coment√°rios.

V√çDEO ANALISADO:
- T√≠tulo: "${video.title}"
- Visualiza√ß√µes: ${(video.view_count || 0).toLocaleString()}
- Likes: ${(video.like_count || 0).toLocaleString()}
- Coment√°rios: ${(video.comment_count || 0).toLocaleString()}
- Nicho: ${niche}${subniche ? ` | Subnicho: ${subniche}` : ''}

COMENT√ÅRIOS MAIS RELEVANTES (${comments.length} coment√°rios):
${comments.map((c, i) => `
${i + 1}. "${c.text.substring(0, 300)}" - ${c.author_name} (${c.like_count} likes)
`).join('')}

AN√ÅLISE E GERA√á√ÉO:

1. IDENTIFIQUE OS PADR√ïES NOS COMENT√ÅRIOS:
   - O que os coment√°rios mais mencionam?
   - Quais s√£o as d√∫vidas mais frequentes?
   - Quais s√£o os pontos que geraram mais discuss√£o?
   - O que as pessoas querem saber mais sobre este tema?

2. GERE 15 T√çTULOS BASEADOS NOS COMENT√ÅRIOS:
   - Os t√≠tulos devem abordar os temas mais mencionados nos coment√°rios
   - Devem ser chamativos e focados em viraliza√ß√£o
   - Devem responder √†s d√∫vidas e curiosidades expressas nos coment√°rios
   - Devem ser para o nicho: ${niche}${subniche ? ` (subnicho: ${subniche})` : ''}

3. F√ìRMULA DE ESTRUTURA DO T√çTULO:
   - Identifique a estrutura que funcionou neste v√≠deo
   - Crie uma f√≥rmula que pode ser replicada

Retorne um JSON v√°lido no formato:
{
  "comment_insights": {
    "most_mentioned_topics": ["tema 1", "tema 2", "tema 3"],
    "common_questions": ["pergunta 1", "pergunta 2", "pergunta 3"],
    "discussion_points": ["ponto 1", "ponto 2", "ponto 3"],
    "audience_interests": ["interesse 1", "interesse 2", "interesse 3"]
  },
  "generated_titles": [
    "t√≠tulo 1 baseado nos coment√°rios",
    "t√≠tulo 2 baseado nos coment√°rios",
    ... "t√≠tulo 15"
  ],
  "title_structure_formula": "F√≥rmula de estrutura do t√≠tulo identificada (ex: Pergunta + Tema + Hook)"
}`;

        // Chamar IA
        let aiResponse;
        if (service === 'claude') {
            aiResponse = await callClaudeAPI(commentsAnalysisPrompt, apiKey, modelToUse);
        } else if (service === 'openai') {
            aiResponse = await callOpenAIAPI(commentsAnalysisPrompt, apiKey, modelToUse);
        } else {
            aiResponse = await callGeminiAPI(commentsAnalysisPrompt, apiKey, modelToUse);
        }
        
        const analysisText = typeof aiResponse === 'string' ? aiResponse : JSON.stringify(aiResponse);
        const parsed = parseAIResponse(analysisText, service);
        
        res.status(200).json({
            video: {
                id: video.id,
                title: video.title,
                view_count: video.view_count,
                comment_count: video.comment_count
            },
            comments_analyzed: comments.length,
            analysis: parsed || {
                comment_insights: {},
                generated_titles: [],
                title_structure_formula: 'An√°lise n√£o dispon√≠vel'
            }
        });
    } catch (err) {
        console.error('[ERRO /api/viral-analysis/videos/:videoId/analyze-comments]:', err);
        res.status(500).json({ msg: err.message || 'Erro ao analisar coment√°rios.' });
    }
});

// Rota de tradu√ß√£o
app.post('/api/translate', authenticateToken, async (req, res) => {
    const { text, from = 'auto', to = 'pt' } = req.body;

    if (!text || typeof text !== 'string') {
        return res.status(400).json({ msg: 'Texto para tradu√ß√£o √© obrigat√≥rio.' });
    }

    try {
        const translatedText = await translateText(text, from, to);
        res.status(200).json({
            original: text,
            translated: translatedText,
            from,
            to
        });
    } catch (err) {
        console.error('[ERRO /api/translate]:', err);
        res.status(500).json({ msg: 'Erro ao traduzir texto.' });
    }
});

// Rota de tradu√ß√£o em lote (para m√∫ltiplos textos)
app.post('/api/translate/batch', authenticateToken, async (req, res) => {
    const { texts, from = 'auto', to = 'pt' } = req.body;

    if (!Array.isArray(texts) || texts.length === 0) {
        return res.status(400).json({ msg: 'Array de textos √© obrigat√≥rio.' });
    }

    try {
        const translations = await Promise.all(
            texts.map(text => translateText(text, from, to))
        );

        res.status(200).json({
            translations,
            from,
            to,
            count: translations.length
        });
    } catch (err) {
        console.error('[ERRO /api/translate/batch]:', err);
        res.status(500).json({ msg: 'Erro ao traduzir textos.' });
    }
});

console.log('‚úÖ Servi√ßo de Tradu√ß√£o Online configurado (MyMemory + LibreTranslate)');


// Aguardar banco de dados estar pronto antes de iniciar servidor
// Mas com timeout para n√£o travar indefinidamente
const DB_INIT_TIMEOUT = 10000; // 10 segundos m√°ximo
const startTime = Date.now();

function waitForDatabase() {
    return new Promise((resolve) => {
        if (global.dbReady && db) {
            resolve(true);
            return;
        }
        
        const checkInterval = setInterval(() => {
            if (global.dbReady && db) {
                clearInterval(checkInterval);
                resolve(true);
            } else if (Date.now() - startTime > DB_INIT_TIMEOUT) {
                clearInterval(checkInterval);
                console.warn('‚ö†Ô∏è  Timeout aguardando banco de dados. Iniciando servidor mesmo assim...');
                resolve(false);
            }
        }, 100);
    });
}

// Aguardar banco estar pronto (com timeout)
waitForDatabase().then((dbReady) => {
    if (dbReady) {
        console.log('‚úÖ Banco de dados confirmado como pronto. Iniciando servidor...');
    } else {
        console.warn('‚ö†Ô∏è  Iniciando servidor sem confirma√ß√£o do banco de dados');
    }
    startServer();
});
